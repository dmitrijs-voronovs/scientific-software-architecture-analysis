id,quality_attribute,keyword,matched_word,match_idx,sentence,source,author,repo,version,wiki,url
https://github.com/CliMA/Oceananigans.jl/pull/1326:4669,Testability,test,test,4669,".CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:314; [5] #test#61 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [6] test at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [7] test(; name::Nothing, uuid::Nothing, version::Nothing, url::Nothing, rev::Nothing, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:4901,Testability,test,test,4901,"f), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:314; [5] #test#61 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [6] test at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [7] test(; name::Nothing, uuid::Nothing, version::Nothing, url::Nothing, rev::Nothing, path::Nothing, mode::Pkg.Types.PackageMode, subdir::Nothing, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:80; ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:5203,Testability,test,test,5203,"er: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:314; [5] #test#61 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [6] test at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [7] test(; name::Nothing, uuid::Nothing, version::Nothing, url::Nothing, rev::Nothing, path::Nothing, mode::Pkg.Types.PackageMode, subdir::Nothing, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:80; [8] test() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:72; [9] top-level scope at none:1. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:5361,Testability,test,test,5361,"er: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:314; [5] #test#61 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [6] test at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [7] test(; name::Nothing, uuid::Nothing, version::Nothing, url::Nothing, rev::Nothing, path::Nothing, mode::Pkg.Types.PackageMode, subdir::Nothing, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:80; [8] test() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:72; [9] top-level scope at none:1. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:5475,Testability,test,test,5475,"er: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:314; [5] #test#61 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [6] test at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [7] test(; name::Nothing, uuid::Nothing, version::Nothing, url::Nothing, rev::Nothing, path::Nothing, mode::Pkg.Types.PackageMode, subdir::Nothing, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:80; [8] test() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:72; [9] top-level scope at none:1. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:5586,Testability,test,test,5586,"er: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:314; [5] #test#61 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [6] test at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [7] test(; name::Nothing, uuid::Nothing, version::Nothing, url::Nothing, rev::Nothing, path::Nothing, mode::Pkg.Types.PackageMode, subdir::Nothing, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:80; [8] test() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:72; [9] top-level scope at none:1. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/pull/1326:5904,Testability,test,test,5904,"er: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002cf), meta=nothing); ERROR: Package Oceananigans errored during testing; Stacktrace:; [1] pkgerror(::String) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Types.jl:52; [2] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/Operations.jl:1578; [3] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; coverage::Bool, test_fn::Nothing, julia_args::Cmd, test_args::Cmd, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:327; [4] test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:314; [5] #test#61 at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [6] test at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:67 [inlined]; [7] test(; name::Nothing, uuid::Nothing, version::Nothing, url::Nothing, rev::Nothing, path::Nothing, mode::Pkg.Types.PackageMode, subdir::Nothing, kwargs::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:80; [8] test() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:72; [9] top-level scope at none:1. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1326
https://github.com/CliMA/Oceananigans.jl/issues/1327:84,Testability,test,test,84,"From https://github.com/CliMA/Oceananigans.jl/blob/glw/computed-field-diffusivities/test/test_turbulence_closures.jl, it would be nice to have this feature in the main branch. In particular, it would allow for users to implement their own turbulence closures or mimic the effect of no flux boundary conditions on an immersed boundary",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1327
https://github.com/CliMA/Oceananigans.jl/pull/1328:264,Performance,Perform,Performing,264,"This correctly adds the time-step wizard to `ShallowWaterModel`. . All the tests pass but there are two warnings that maybe should be adressed?. ```; ...; [2021/02/01 11:45:05.426] INFO Testing setting shallow water model fields...; [2021/02/01 11:45:12.752] WARN Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)` -@-> /home/fpoulin/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:43; ...; [2021/02/01 11:45:39.457] INFO Testing time-step wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]]...; [2021/02/01 11:45:39.641] WARN You have used the default iteration_interval=1. This simulation will recalculate the time step every iteration which can be slow. -@-> /home/fpoulin/software/Oceananigans.jl/src/Simulations/simulation.jl:68. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1328
https://github.com/CliMA/Oceananigans.jl/pull/1328:75,Testability,test,tests,75,"This correctly adds the time-step wizard to `ShallowWaterModel`. . All the tests pass but there are two warnings that maybe should be adressed?. ```; ...; [2021/02/01 11:45:05.426] INFO Testing setting shallow water model fields...; [2021/02/01 11:45:12.752] WARN Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)` -@-> /home/fpoulin/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:43; ...; [2021/02/01 11:45:39.457] INFO Testing time-step wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]]...; [2021/02/01 11:45:39.641] WARN You have used the default iteration_interval=1. This simulation will recalculate the time step every iteration which can be slow. -@-> /home/fpoulin/software/Oceananigans.jl/src/Simulations/simulation.jl:68. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1328
https://github.com/CliMA/Oceananigans.jl/pull/1328:186,Testability,Test,Testing,186,"This correctly adds the time-step wizard to `ShallowWaterModel`. . All the tests pass but there are two warnings that maybe should be adressed?. ```; ...; [2021/02/01 11:45:05.426] INFO Testing setting shallow water model fields...; [2021/02/01 11:45:12.752] WARN Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)` -@-> /home/fpoulin/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:43; ...; [2021/02/01 11:45:39.457] INFO Testing time-step wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]]...; [2021/02/01 11:45:39.641] WARN You have used the default iteration_interval=1. This simulation will recalculate the time step every iteration which can be slow. -@-> /home/fpoulin/software/Oceananigans.jl/src/Simulations/simulation.jl:68. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1328
https://github.com/CliMA/Oceananigans.jl/pull/1328:503,Testability,Test,Testing,503,"This correctly adds the time-step wizard to `ShallowWaterModel`. . All the tests pass but there are two warnings that maybe should be adressed?. ```; ...; [2021/02/01 11:45:05.426] INFO Testing setting shallow water model fields...; [2021/02/01 11:45:12.752] WARN Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)` -@-> /home/fpoulin/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:43; ...; [2021/02/01 11:45:39.457] INFO Testing time-step wizard ShallowWaterModels [GPU(), ((Periodic, Periodic, Bounded), (Periodic, Bounded, Bounded), (Bounded, Bounded, Bounded))[1]]...; [2021/02/01 11:45:39.641] WARN You have used the default iteration_interval=1. This simulation will recalculate the time step every iteration which can be slow. -@-> /home/fpoulin/software/Oceananigans.jl/src/Simulations/simulation.jl:68. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1328
https://github.com/CliMA/Oceananigans.jl/pull/1332:28,Deployability,integrat,integrate,28,This was my last attempt to integrate the vertically stretched grid into Oceananigans. This branch is probably too old and stale to be rebased so I'm just opening it so we can see the state of the branch. Will probably start a new branch and copy paste a lot of this stuff into there.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1332
https://github.com/CliMA/Oceananigans.jl/pull/1332:28,Integrability,integrat,integrate,28,This was my last attempt to integrate the vertically stretched grid into Oceananigans. This branch is probably too old and stale to be rebased so I'm just opening it so we can see the state of the branch. Will probably start a new branch and copy paste a lot of this stuff into there.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1332
https://github.com/CliMA/Oceananigans.jl/issues/1334:55,Deployability,integrat,integration,55,"I was thinking that it would be a good idea to make an integration with Python's [`xgcm`](https://github.com/xgcm/xgcm) package easier. The project is relatively new but I expect it to grow given that it has [Pangeo](https://pangeo.io/) support. In my mind, this is related to #1313, since the primary (only?) communication with Python is done through NetCDF files. So including some [grid metrics](https://xgcm.readthedocs.io/en/latest/grid_metrics.html) in the NetCDF output would be helpful. For now I'm not exactly sure what needs to be there since their docs [aren't very explanatory in that sense](https://github.com/xgcm/xgcm/issues/291), but it includes distances between `Face`s and `Center`s of the grids and other measures that should be straightforward. Any thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334
https://github.com/CliMA/Oceananigans.jl/issues/1334:55,Integrability,integrat,integration,55,"I was thinking that it would be a good idea to make an integration with Python's [`xgcm`](https://github.com/xgcm/xgcm) package easier. The project is relatively new but I expect it to grow given that it has [Pangeo](https://pangeo.io/) support. In my mind, this is related to #1313, since the primary (only?) communication with Python is done through NetCDF files. So including some [grid metrics](https://xgcm.readthedocs.io/en/latest/grid_metrics.html) in the NetCDF output would be helpful. For now I'm not exactly sure what needs to be there since their docs [aren't very explanatory in that sense](https://github.com/xgcm/xgcm/issues/291), but it includes distances between `Face`s and `Center`s of the grids and other measures that should be straightforward. Any thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334
https://github.com/CliMA/Oceananigans.jl/pull/1335:32,Security,secur,securely,32,Same typo fix as #1333 but done securely for Buildkite,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1335
https://github.com/CliMA/Oceananigans.jl/pull/1338:938,Deployability,update,updated,938,"This PR is still a work-in-progress but I'm opening it to make the future design of the pressure solver module more transparent as we will be adding some new pressure solvers soon, including a conjugate-gradient solver by @christophernhill. # Motivation. In PR #290 I implemented a pressure solver for the `(Periodic, Bounded, Bounded)` channel topology using the 2D fast cosine transform algorithm described by Makhoul (1982) as CUFFT does not provide cosine transforms for the GPU and does not support FFTs along non-batched dimensions (see https://github.com/JuliaGPU/CUDA.jl/issues/119). This has been a very unpopular decision for good reasons. The 2D DCT algorithm is quite slow (channels are ~2x slower than doubly periodic on GPUs) and is quite complicated. Due to my inexperience, I didn't realize that transposing the array to do the FFT was the way forward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmark",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338
https://github.com/CliMA/Oceananigans.jl/pull/1338:1021,Modifiability,refactor,refactors,1021,"t I'm opening it to make the future design of the pressure solver module more transparent as we will be adding some new pressure solvers soon, including a conjugate-gradient solver by @christophernhill. # Motivation. In PR #290 I implemented a pressure solver for the `(Periodic, Bounded, Bounded)` channel topology using the 2D fast cosine transform algorithm described by Makhoul (1982) as CUFFT does not provide cosine transforms for the GPU and does not support FFTs along non-batched dimensions (see https://github.com/JuliaGPU/CUDA.jl/issues/119). This has been a very unpopular decision for good reasons. The 2D DCT algorithm is quite slow (channels are ~2x slower than doubly periodic on GPUs) and is quite complicated. Due to my inexperience, I didn't realize that transposing the array to do the FFT was the way forward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338
https://github.com/CliMA/Oceananigans.jl/pull/1338:1419,Modifiability,extend,extend,1419,"hm described by Makhoul (1982) as CUFFT does not provide cosine transforms for the GPU and does not support FFTs along non-batched dimensions (see https://github.com/JuliaGPU/CUDA.jl/issues/119). This has been a very unpopular decision for good reasons. The 2D DCT algorithm is quite slow (channels are ~2x slower than doubly periodic on GPUs) and is quite complicated. Due to my inexperience, I didn't realize that transposing the array to do the FFT was the way forward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batch transforms when possible. Note than FFT along dimension 1 is the fastest and FFT along dimension 2 is the slowest. FFT along dimension 3 is in the middle. So whatever FFTW is doing under the hood, FFTs along non-batched dimensions (e.g. along dimension 2) are slow. ```; ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338
https://github.com/CliMA/Oceananigans.jl/pull/1338:1108,Performance,perform,performing,1108,"rent as we will be adding some new pressure solvers soon, including a conjugate-gradient solver by @christophernhill. # Motivation. In PR #290 I implemented a pressure solver for the `(Periodic, Bounded, Bounded)` channel topology using the 2D fast cosine transform algorithm described by Makhoul (1982) as CUFFT does not provide cosine transforms for the GPU and does not support FFTs along non-batched dimensions (see https://github.com/JuliaGPU/CUDA.jl/issues/119). This has been a very unpopular decision for good reasons. The 2D DCT algorithm is quite slow (channels are ~2x slower than doubly periodic on GPUs) and is quite complicated. Due to my inexperience, I didn't realize that transposing the array to do the FFT was the way forward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338
https://github.com/CliMA/Oceananigans.jl/pull/1338:4585,Performance,perform,performance,4585,"│ 684.541 μs │ 688.275 μs │ 811.874 μs │ 1.463 ms │ 0 bytes │ 0 │; │ CPU │ 256 │ 3 │ 93.902 ms │ 94.489 ms │ 94.604 ms │ 95.639 ms │ 0 bytes │ 0 │; └───────────────┴─────┴───────────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┘. 3D FFT --> 3 × 1D FFTs slowdown:; CPU, 16: 1.0807x; CPU, 64: 1.0053x; CPU, 256: 1.1567x; ```. # To batch or not to batch for CUFFT on GPUs?. We should investigate this separately for CUFFT since FFT along dimension 2 requires a transpose. TODO:; - [x] Figure out how to do a FFT_y on the GPU!; - [x] Implement and benchmark doing it the distributed way.; - [x] Benchmark 1 3D FFT with 3 1D FFTs.; - [x] Benchmark 1 3D DCT with 3 1D DCTs. Same benchmarks for the GPU are posted below. Batching is much faster (by a factor of 2-3) so we should batch when possible. Note that FFTs along non-batched dimensions (dimension 2 in this case) are much slower since it involves two transpose operations. Batching will not be possible for some topologies in which cases so we'll take a performance hit. But if the pressure solver is still 10~15% then a 2x hit on the pressure solver is not that large. The hit will mostly affect topologies we don't currently support anyways. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ GPU │ 16 │ (1, 2, 3) │ 25.478 μs │ 32.459 μs │ 122.062 μs │ 703.376 μs │ 224 bytes │ 13 │; │ GPU │ 64 │ (1, 2, 3) │ 67.226 μs │ 71.497 μs │ 146.042 μs │ 647.734 μs │ 224 bytes │ 13 │; │ GPU │ 256 │ (1, 2, 3) │ 2.982 ms │ 3.041 ms │ 3.036 ms │ 3.116 ms │ 224 bytes │ 13 │; │ GPU │ 16 │ 1 │ 14.755 μs │ 30.020 μs │ 107.932 μs │ 677.045 μs │ 96 bytes │ 5 │; │ GPU │ 64 │ 1 │ 26.521 μs │ 41.294 μs │ 114.587 μs │ 674.834 μs │ 96 bytes │ 5 │; │ GPU │ 256 │ 1 │ 9",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338
https://github.com/CliMA/Oceananigans.jl/pull/1338:1547,Testability,Benchmark,Benchmark,1547,".com/JuliaGPU/CUDA.jl/issues/119). This has been a very unpopular decision for good reasons. The 2D DCT algorithm is quite slow (channels are ~2x slower than doubly periodic on GPUs) and is quite complicated. Due to my inexperience, I didn't realize that transposing the array to do the FFT was the way forward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batch transforms when possible. Note than FFT along dimension 1 is the fastest and FFT along dimension 2 is the slowest. FFT along dimension 3 is in the middle. So whatever FFTW is doing under the hood, FFTs along non-batched dimensions (e.g. along dimension 2) are slow. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338
https://github.com/CliMA/Oceananigans.jl/pull/1338:1589,Testability,Benchmark,Benchmark,1589,"ular decision for good reasons. The 2D DCT algorithm is quite slow (channels are ~2x slower than doubly periodic on GPUs) and is quite complicated. Due to my inexperience, I didn't realize that transposing the array to do the FFT was the way forward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batch transforms when possible. Note than FFT along dimension 1 is the fastest and FFT along dimension 2 is the slowest. FFT along dimension 3 is in the middle. So whatever FFTW is doing under the hood, FFTs along non-batched dimensions (e.g. along dimension 2) are slow. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼──",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338
https://github.com/CliMA/Oceananigans.jl/pull/1338:1621,Testability,Benchmark,Benchmark,1621,"ular decision for good reasons. The 2D DCT algorithm is quite slow (channels are ~2x slower than doubly periodic on GPUs) and is quite complicated. Due to my inexperience, I didn't realize that transposing the array to do the FFT was the way forward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batch transforms when possible. Note than FFT along dimension 1 is the fastest and FFT along dimension 2 is the slowest. FFT along dimension 3 is in the middle. So whatever FFTW is doing under the hood, FFTs along non-batched dimensions (e.g. along dimension 2) are slow. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼──",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338
https://github.com/CliMA/Oceananigans.jl/pull/1338:1663,Testability,Benchmark,Benchmark,1663,"dic on GPUs) and is quite complicated. Due to my inexperience, I didn't realize that transposing the array to do the FFT was the way forward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batch transforms when possible. Note than FFT along dimension 1 is the fastest and FFT along dimension 2 is the slowest. FFT along dimension 3 is in the middle. So whatever FFTW is doing under the hood, FFTs along non-batched dimensions (e.g. along dimension 2) are slow. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ CPU │ 16 │ (1, 2",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338
https://github.com/CliMA/Oceananigans.jl/pull/1338:1917,Testability,benchmark,benchmarks,1917,"ward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batch transforms when possible. Note than FFT along dimension 1 is the fastest and FFT along dimension 2 is the slowest. FFT along dimension 3 is in the middle. So whatever FFTW is doing under the hood, FFTs along non-batched dimensions (e.g. along dimension 2) are slow. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ CPU │ 16 │ (1, 2, 3) │ 13.948 μs │ 14.043 μs │ 20.717 μs │ 80.605 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ (1, 2, 3) │ 1.656 ms │ 1.717 ms │ 1.809 ms │ 2.697 ms ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338
https://github.com/CliMA/Oceananigans.jl/pull/1338:1992,Testability,benchmark,benchmarks,1992,"essure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batch transforms when possible. Note than FFT along dimension 1 is the fastest and FFT along dimension 2 is the slowest. FFT along dimension 3 is in the middle. So whatever FFTW is doing under the hood, FFTs along non-batched dimensions (e.g. along dimension 2) are slow. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ CPU │ 16 │ (1, 2, 3) │ 13.948 μs │ 14.043 μs │ 20.717 μs │ 80.605 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ (1, 2, 3) │ 1.656 ms │ 1.717 ms │ 1.809 ms │ 2.697 ms │ 0 bytes │ 0 │; │ CPU │ 256 │ (1, 2, 3) │ 229.619 ms │ 233.008 ms │ 234.033 ms │ 243.288 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 1 │ 3.240 μs │ 3.255 μs │ 3.603 μs │ 6.746 μs │ 0 b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338
https://github.com/CliMA/Oceananigans.jl/pull/1338:2400,Testability,benchmark,benchmarks,2400,"T, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batch transforms when possible. Note than FFT along dimension 1 is the fastest and FFT along dimension 2 is the slowest. FFT along dimension 3 is in the middle. So whatever FFTW is doing under the hood, FFTs along non-batched dimensions (e.g. along dimension 2) are slow. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ CPU │ 16 │ (1, 2, 3) │ 13.948 μs │ 14.043 μs │ 20.717 μs │ 80.605 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ (1, 2, 3) │ 1.656 ms │ 1.717 ms │ 1.809 ms │ 2.697 ms │ 0 bytes │ 0 │; │ CPU │ 256 │ (1, 2, 3) │ 229.619 ms │ 233.008 ms │ 234.033 ms │ 243.288 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 1 │ 3.240 μs │ 3.255 μs │ 3.603 μs │ 6.746 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 1 │ 445.803 μs │ 458.928 μs │ 513.041 μs │ 755.937 μs │ 0 bytes │ 0 │; │ CPU │ 256 │ 1 │ 61.083 ms │ 63.464 ms │ 63.969 ms │ 67.009 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 2 │ 4.085 μs │ 4.135 μs │ 4.723 μs │ 8.088 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 2 │ 564.769 μs │ 579.278 μs │ 615.731 μs │ 804.859 μs │ 0 bytes │ 0 │; │ CPU │ 256 │ 2 │ 110.718 ms │ 111.560 ms │ 111.506 ms │ 112.525 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 3 │ 7.772 μs │ 7.787 μs │ 9.499 μs │ 24.886 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 3 │ 684.541 μs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338
https://github.com/CliMA/Oceananigans.jl/pull/1338:4124,Testability,benchmark,benchmark,4124," 755.937 μs │ 0 bytes │ 0 │; │ CPU │ 256 │ 1 │ 61.083 ms │ 63.464 ms │ 63.969 ms │ 67.009 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 2 │ 4.085 μs │ 4.135 μs │ 4.723 μs │ 8.088 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 2 │ 564.769 μs │ 579.278 μs │ 615.731 μs │ 804.859 μs │ 0 bytes │ 0 │; │ CPU │ 256 │ 2 │ 110.718 ms │ 111.560 ms │ 111.506 ms │ 112.525 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 3 │ 7.772 μs │ 7.787 μs │ 9.499 μs │ 24.886 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 3 │ 684.541 μs │ 688.275 μs │ 811.874 μs │ 1.463 ms │ 0 bytes │ 0 │; │ CPU │ 256 │ 3 │ 93.902 ms │ 94.489 ms │ 94.604 ms │ 95.639 ms │ 0 bytes │ 0 │; └───────────────┴─────┴───────────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┘. 3D FFT --> 3 × 1D FFTs slowdown:; CPU, 16: 1.0807x; CPU, 64: 1.0053x; CPU, 256: 1.1567x; ```. # To batch or not to batch for CUFFT on GPUs?. We should investigate this separately for CUFFT since FFT along dimension 2 requires a transpose. TODO:; - [x] Figure out how to do a FFT_y on the GPU!; - [x] Implement and benchmark doing it the distributed way.; - [x] Benchmark 1 3D FFT with 3 1D FFTs.; - [x] Benchmark 1 3D DCT with 3 1D DCTs. Same benchmarks for the GPU are posted below. Batching is much faster (by a factor of 2-3) so we should batch when possible. Note that FFTs along non-batched dimensions (dimension 2 in this case) are much slower since it involves two transpose operations. Batching will not be possible for some topologies in which cases so we'll take a performance hit. But if the pressure solver is still 10~15% then a 2x hit on the pressure solver is not that large. The hit will mostly affect topologies we don't currently support anyways. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ GPU │ 16 │ ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338
https://github.com/CliMA/Oceananigans.jl/pull/1338:4171,Testability,Benchmark,Benchmark,4171,"s │ 67.009 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 2 │ 4.085 μs │ 4.135 μs │ 4.723 μs │ 8.088 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 2 │ 564.769 μs │ 579.278 μs │ 615.731 μs │ 804.859 μs │ 0 bytes │ 0 │; │ CPU │ 256 │ 2 │ 110.718 ms │ 111.560 ms │ 111.506 ms │ 112.525 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 3 │ 7.772 μs │ 7.787 μs │ 9.499 μs │ 24.886 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 3 │ 684.541 μs │ 688.275 μs │ 811.874 μs │ 1.463 ms │ 0 bytes │ 0 │; │ CPU │ 256 │ 3 │ 93.902 ms │ 94.489 ms │ 94.604 ms │ 95.639 ms │ 0 bytes │ 0 │; └───────────────┴─────┴───────────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┘. 3D FFT --> 3 × 1D FFTs slowdown:; CPU, 16: 1.0807x; CPU, 64: 1.0053x; CPU, 256: 1.1567x; ```. # To batch or not to batch for CUFFT on GPUs?. We should investigate this separately for CUFFT since FFT along dimension 2 requires a transpose. TODO:; - [x] Figure out how to do a FFT_y on the GPU!; - [x] Implement and benchmark doing it the distributed way.; - [x] Benchmark 1 3D FFT with 3 1D FFTs.; - [x] Benchmark 1 3D DCT with 3 1D DCTs. Same benchmarks for the GPU are posted below. Batching is much faster (by a factor of 2-3) so we should batch when possible. Note that FFTs along non-batched dimensions (dimension 2 in this case) are much slower since it involves two transpose operations. Batching will not be possible for some topologies in which cases so we'll take a performance hit. But if the pressure solver is still 10~15% then a 2x hit on the pressure solver is not that large. The hit will mostly affect topologies we don't currently support anyways. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ GPU │ 16 │ (1, 2, 3) │ 25.478 μs │ 32.459 μs │ 122.062 μs │ 703.376 μs │ 224 bytes │ 13 │",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338
https://github.com/CliMA/Oceananigans.jl/pull/1338:4213,Testability,Benchmark,Benchmark,4213,"│ 2 │ 4.085 μs │ 4.135 μs │ 4.723 μs │ 8.088 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 2 │ 564.769 μs │ 579.278 μs │ 615.731 μs │ 804.859 μs │ 0 bytes │ 0 │; │ CPU │ 256 │ 2 │ 110.718 ms │ 111.560 ms │ 111.506 ms │ 112.525 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 3 │ 7.772 μs │ 7.787 μs │ 9.499 μs │ 24.886 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 3 │ 684.541 μs │ 688.275 μs │ 811.874 μs │ 1.463 ms │ 0 bytes │ 0 │; │ CPU │ 256 │ 3 │ 93.902 ms │ 94.489 ms │ 94.604 ms │ 95.639 ms │ 0 bytes │ 0 │; └───────────────┴─────┴───────────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┘. 3D FFT --> 3 × 1D FFTs slowdown:; CPU, 16: 1.0807x; CPU, 64: 1.0053x; CPU, 256: 1.1567x; ```. # To batch or not to batch for CUFFT on GPUs?. We should investigate this separately for CUFFT since FFT along dimension 2 requires a transpose. TODO:; - [x] Figure out how to do a FFT_y on the GPU!; - [x] Implement and benchmark doing it the distributed way.; - [x] Benchmark 1 3D FFT with 3 1D FFTs.; - [x] Benchmark 1 3D DCT with 3 1D DCTs. Same benchmarks for the GPU are posted below. Batching is much faster (by a factor of 2-3) so we should batch when possible. Note that FFTs along non-batched dimensions (dimension 2 in this case) are much slower since it involves two transpose operations. Batching will not be possible for some topologies in which cases so we'll take a performance hit. But if the pressure solver is still 10~15% then a 2x hit on the pressure solver is not that large. The hit will mostly affect topologies we don't currently support anyways. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ GPU │ 16 │ (1, 2, 3) │ 25.478 μs │ 32.459 μs │ 122.062 μs │ 703.376 μs │ 224 bytes │ 13 │; │ GPU │ 64 │ (1, 2, 3) │ 67.226 μs │ 71.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338
https://github.com/CliMA/Oceananigans.jl/pull/1338:4253,Testability,benchmark,benchmarks,4253," μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 2 │ 564.769 μs │ 579.278 μs │ 615.731 μs │ 804.859 μs │ 0 bytes │ 0 │; │ CPU │ 256 │ 2 │ 110.718 ms │ 111.560 ms │ 111.506 ms │ 112.525 ms │ 0 bytes │ 0 │; │ CPU │ 16 │ 3 │ 7.772 μs │ 7.787 μs │ 9.499 μs │ 24.886 μs │ 0 bytes │ 0 │; │ CPU │ 64 │ 3 │ 684.541 μs │ 688.275 μs │ 811.874 μs │ 1.463 ms │ 0 bytes │ 0 │; │ CPU │ 256 │ 3 │ 93.902 ms │ 94.489 ms │ 94.604 ms │ 95.639 ms │ 0 bytes │ 0 │; └───────────────┴─────┴───────────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┘. 3D FFT --> 3 × 1D FFTs slowdown:; CPU, 16: 1.0807x; CPU, 64: 1.0053x; CPU, 256: 1.1567x; ```. # To batch or not to batch for CUFFT on GPUs?. We should investigate this separately for CUFFT since FFT along dimension 2 requires a transpose. TODO:; - [x] Figure out how to do a FFT_y on the GPU!; - [x] Implement and benchmark doing it the distributed way.; - [x] Benchmark 1 3D FFT with 3 1D FFTs.; - [x] Benchmark 1 3D DCT with 3 1D DCTs. Same benchmarks for the GPU are posted below. Batching is much faster (by a factor of 2-3) so we should batch when possible. Note that FFTs along non-batched dimensions (dimension 2 in this case) are much slower since it involves two transpose operations. Batching will not be possible for some topologies in which cases so we'll take a performance hit. But if the pressure solver is still 10~15% then a 2x hit on the pressure solver is not that large. The hit will mostly affect topologies we don't currently support anyways. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ GPU │ 16 │ (1, 2, 3) │ 25.478 μs │ 32.459 μs │ 122.062 μs │ 703.376 μs │ 224 bytes │ 13 │; │ GPU │ 64 │ (1, 2, 3) │ 67.226 μs │ 71.497 μs │ 146.042 μs │ 647.734 μs │ 224 bytes",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338
https://github.com/CliMA/Oceananigans.jl/pull/1338:4784,Testability,benchmark,benchmarks,4784,"s?. We should investigate this separately for CUFFT since FFT along dimension 2 requires a transpose. TODO:; - [x] Figure out how to do a FFT_y on the GPU!; - [x] Implement and benchmark doing it the distributed way.; - [x] Benchmark 1 3D FFT with 3 1D FFTs.; - [x] Benchmark 1 3D DCT with 3 1D DCTs. Same benchmarks for the GPU are posted below. Batching is much faster (by a factor of 2-3) so we should batch when possible. Note that FFTs along non-batched dimensions (dimension 2 in this case) are much slower since it involves two transpose operations. Batching will not be possible for some topologies in which cases so we'll take a performance hit. But if the pressure solver is still 10~15% then a 2x hit on the pressure solver is not that large. The hit will mostly affect topologies we don't currently support anyways. ```; FFT benchmarks; ┌───────────────┬─────┬───────────┬────────────┬────────────┬────────────┬────────────┬───────────┬────────┐; │ Architectures │ Ns │ dims │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────┼───────────┼────────────┼────────────┼────────────┼────────────┼───────────┼────────┤; │ GPU │ 16 │ (1, 2, 3) │ 25.478 μs │ 32.459 μs │ 122.062 μs │ 703.376 μs │ 224 bytes │ 13 │; │ GPU │ 64 │ (1, 2, 3) │ 67.226 μs │ 71.497 μs │ 146.042 μs │ 647.734 μs │ 224 bytes │ 13 │; │ GPU │ 256 │ (1, 2, 3) │ 2.982 ms │ 3.041 ms │ 3.036 ms │ 3.116 ms │ 224 bytes │ 13 │; │ GPU │ 16 │ 1 │ 14.755 μs │ 30.020 μs │ 107.932 μs │ 677.045 μs │ 96 bytes │ 5 │; │ GPU │ 64 │ 1 │ 26.521 μs │ 41.294 μs │ 114.587 μs │ 674.834 μs │ 96 bytes │ 5 │; │ GPU │ 256 │ 1 │ 930.371 μs │ 936.222 μs │ 954.771 μs │ 1.060 ms │ 96 bytes │ 5 │; │ GPU │ 16 │ 2 │ 26.547 μs │ 49.440 μs │ 127.426 μs │ 768.771 μs │ 1.41 KiB │ 59 │; │ GPU │ 64 │ 2 │ 116.160 μs │ 117.772 μs │ 193.909 μs │ 797.293 μs │ 1.41 KiB │ 59 │; │ GPU │ 256 │ 2 │ 4.963 ms │ 5.010 ms │ 5.014 ms │ 5.073 ms │ 1.41 KiB │ 59 │; │ GPU │ 16 │ 3 │ 14.918 μs │ 22.509 μs │ 40.029 μs │ 110.119 μs │ 224 bytes │ 13 │",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338
https://github.com/CliMA/Oceananigans.jl/pull/1338:1379,Usability,simpl,simplify,1379,"hm described by Makhoul (1982) as CUFFT does not provide cosine transforms for the GPU and does not support FFTs along non-batched dimensions (see https://github.com/JuliaGPU/CUDA.jl/issues/119). This has been a very unpopular decision for good reasons. The 2D DCT algorithm is quite slow (channels are ~2x slower than doubly periodic on GPUs) and is quite complicated. Due to my inexperience, I didn't realize that transposing the array to do the FFT was the way forward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batch transforms when possible. Note than FFT along dimension 1 is the fastest and FFT along dimension 2 is the slowest. FFT along dimension 3 is in the middle. So whatever FFTW is doing under the hood, FFTs along non-batched dimensions (e.g. along dimension 2) are slow. ```; ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338
https://github.com/CliMA/Oceananigans.jl/pull/1339:722,Testability,test,tests,722,"This PR implements dichotomous forms for `ShallowWaterModel.solution`: if `solution = ConservativeSolution()`, then the solution fields are `uh, vh, h` and the PDE is written in ""conservative"" form. If `solution = PrimitiveSolution()`, then the `solution` fields are `u, v, η` and the solution is written in the ""primitive"" form. . We will also linearize the solution around `h = H + η`; however @francispoulin and I deemed that `LinearizedPrimitiveSolution` might be misleading since the momentum equation is still nonlinear (only the height equation is linearized). Alternative names to `PrimitiveSolution` are welcome... . To do:. - [ ] implement tendency equations for `solution::PrimitiveSolutionFields`; - [ ] basic tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1339
https://github.com/CliMA/Oceananigans.jl/pull/1340:747,Testability,test,tests,747,"This PR adds `boundary_conditions` to `ComputedField`. I added a new `DefaultComputedFieldBoundaryCondition`, because `DefaultBoundaryCondition` specifies an `ImpenetrableBoundaryCondition` when a field is located on `Face` and the direction is `Bounded`. But I think this is only appropriate for velocities and is not what we want in general. Arguably, we should change `DefaultBoundaryCondition` instead and implement special behavior for velocity fields... Strictly speaking the boundary conditions are only ""correct"" in periodic directions, since we have no way of evaluating what the boundary conditions need to be in `Bounded` directions. Should we use a `nothing` default for `Bounded` directions in all cases for `ComputedField`?. Current tests pass, but I still need to add tests to make sure that halos are filled properly. cc @tomchor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1340
https://github.com/CliMA/Oceananigans.jl/pull/1340:783,Testability,test,tests,783,"This PR adds `boundary_conditions` to `ComputedField`. I added a new `DefaultComputedFieldBoundaryCondition`, because `DefaultBoundaryCondition` specifies an `ImpenetrableBoundaryCondition` when a field is located on `Face` and the direction is `Bounded`. But I think this is only appropriate for velocities and is not what we want in general. Arguably, we should change `DefaultBoundaryCondition` instead and implement special behavior for velocity fields... Strictly speaking the boundary conditions are only ""correct"" in periodic directions, since we have no way of evaluating what the boundary conditions need to be in `Bounded` directions. Should we use a `nothing` default for `Bounded` directions in all cases for `ComputedField`?. Current tests pass, but I still need to add tests to make sure that halos are filled properly. cc @tomchor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1340
https://github.com/CliMA/Oceananigans.jl/pull/1341:48,Availability,checkpoint,checkpoints,48,"This PR adds support for ""cleaning up"" previous checkpoints. Setting `cleanup=true` will cause the checkpointer to delete all previous checkpoints after the latest one has been written. Pair programmed with @qwert2266.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1341
https://github.com/CliMA/Oceananigans.jl/pull/1341:99,Availability,checkpoint,checkpointer,99,"This PR adds support for ""cleaning up"" previous checkpoints. Setting `cleanup=true` will cause the checkpointer to delete all previous checkpoints after the latest one has been written. Pair programmed with @qwert2266.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1341
https://github.com/CliMA/Oceananigans.jl/pull/1341:135,Availability,checkpoint,checkpoints,135,"This PR adds support for ""cleaning up"" previous checkpoints. Setting `cleanup=true` will cause the checkpointer to delete all previous checkpoints after the latest one has been written. Pair programmed with @qwert2266.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1341
https://github.com/CliMA/Oceananigans.jl/pull/1342:1410,Integrability,interface,interface,1410,"For now this PR just adds a function `convective_adjustment!(model, Δt, K)` that performs a convective adjustment step on a model. . I believe this results in an operator splitting method for treating vertically implicit diffusion using backward Euler. ## TODO. If this seems like an appropriate method for implementing vertically implicit diffusion, I'd suggest the following steps for turning this PR into something that can be merged:; 1. Define a new closure; ```julia; 	struct ConvectiveAdjustment{K, ∂}; 	 κ :: K; 	∂b∂z :: ∂; 		...; 	end; ```; 2. Maybe `ConvectiveAdjustment` should act on a `BuoyancyField`?; 3. Refactor `convective_adjustment!` to use the `BatchedTridiagonalSolver`.; 4. Add a free convection test to test that using `ConvectiveAdjustment` on a linearly stratified column model results in a mixed layer with ∂b/∂z ≈ 0 (could also test for the mixed layer depth). `ConvectiveAdjustment` could then be used as part of a tuple of turbulence closures, e.g. ```julia; closure = (IsotropicDiffusivity(κ=1e-4), ConvectiveAdjustment(κv=10)); ```. ## Future plans?. Vertically implicit diffusion with the `BatchedTridiagonalSolver` could then be abstracted to support other parameterizations such as `OceanTurb.KPP` and `OceanTurb.TKEMassFlux`. I think @glwagner envisioned a more general way of time-stepping implicit terms in general, i.e. adding IMEX time-steppers I think?. ## Note on user interface. Right now the user must manually call `convective_adjustment!` inside the `simulation.progress` callback so it's very awkward to use, but it should be usable if we need it. Ideally `convective_adjustment!` would be called at the end of each time step, perhaps by `time_step!` or by a simulation callback. The second approach would require resolving #1138.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1342
https://github.com/CliMA/Oceananigans.jl/pull/1342:619,Modifiability,Refactor,Refactor,619,"For now this PR just adds a function `convective_adjustment!(model, Δt, K)` that performs a convective adjustment step on a model. . I believe this results in an operator splitting method for treating vertically implicit diffusion using backward Euler. ## TODO. If this seems like an appropriate method for implementing vertically implicit diffusion, I'd suggest the following steps for turning this PR into something that can be merged:; 1. Define a new closure; ```julia; 	struct ConvectiveAdjustment{K, ∂}; 	 κ :: K; 	∂b∂z :: ∂; 		...; 	end; ```; 2. Maybe `ConvectiveAdjustment` should act on a `BuoyancyField`?; 3. Refactor `convective_adjustment!` to use the `BatchedTridiagonalSolver`.; 4. Add a free convection test to test that using `ConvectiveAdjustment` on a linearly stratified column model results in a mixed layer with ∂b/∂z ≈ 0 (could also test for the mixed layer depth). `ConvectiveAdjustment` could then be used as part of a tuple of turbulence closures, e.g. ```julia; closure = (IsotropicDiffusivity(κ=1e-4), ConvectiveAdjustment(κv=10)); ```. ## Future plans?. Vertically implicit diffusion with the `BatchedTridiagonalSolver` could then be abstracted to support other parameterizations such as `OceanTurb.KPP` and `OceanTurb.TKEMassFlux`. I think @glwagner envisioned a more general way of time-stepping implicit terms in general, i.e. adding IMEX time-steppers I think?. ## Note on user interface. Right now the user must manually call `convective_adjustment!` inside the `simulation.progress` callback so it's very awkward to use, but it should be usable if we need it. Ideally `convective_adjustment!` would be called at the end of each time step, perhaps by `time_step!` or by a simulation callback. The second approach would require resolving #1138.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1342
https://github.com/CliMA/Oceananigans.jl/pull/1342:1190,Modifiability,parameteriz,parameterizations,1190,"For now this PR just adds a function `convective_adjustment!(model, Δt, K)` that performs a convective adjustment step on a model. . I believe this results in an operator splitting method for treating vertically implicit diffusion using backward Euler. ## TODO. If this seems like an appropriate method for implementing vertically implicit diffusion, I'd suggest the following steps for turning this PR into something that can be merged:; 1. Define a new closure; ```julia; 	struct ConvectiveAdjustment{K, ∂}; 	 κ :: K; 	∂b∂z :: ∂; 		...; 	end; ```; 2. Maybe `ConvectiveAdjustment` should act on a `BuoyancyField`?; 3. Refactor `convective_adjustment!` to use the `BatchedTridiagonalSolver`.; 4. Add a free convection test to test that using `ConvectiveAdjustment` on a linearly stratified column model results in a mixed layer with ∂b/∂z ≈ 0 (could also test for the mixed layer depth). `ConvectiveAdjustment` could then be used as part of a tuple of turbulence closures, e.g. ```julia; closure = (IsotropicDiffusivity(κ=1e-4), ConvectiveAdjustment(κv=10)); ```. ## Future plans?. Vertically implicit diffusion with the `BatchedTridiagonalSolver` could then be abstracted to support other parameterizations such as `OceanTurb.KPP` and `OceanTurb.TKEMassFlux`. I think @glwagner envisioned a more general way of time-stepping implicit terms in general, i.e. adding IMEX time-steppers I think?. ## Note on user interface. Right now the user must manually call `convective_adjustment!` inside the `simulation.progress` callback so it's very awkward to use, but it should be usable if we need it. Ideally `convective_adjustment!` would be called at the end of each time step, perhaps by `time_step!` or by a simulation callback. The second approach would require resolving #1138.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1342
https://github.com/CliMA/Oceananigans.jl/pull/1342:81,Performance,perform,performs,81,"For now this PR just adds a function `convective_adjustment!(model, Δt, K)` that performs a convective adjustment step on a model. . I believe this results in an operator splitting method for treating vertically implicit diffusion using backward Euler. ## TODO. If this seems like an appropriate method for implementing vertically implicit diffusion, I'd suggest the following steps for turning this PR into something that can be merged:; 1. Define a new closure; ```julia; 	struct ConvectiveAdjustment{K, ∂}; 	 κ :: K; 	∂b∂z :: ∂; 		...; 	end; ```; 2. Maybe `ConvectiveAdjustment` should act on a `BuoyancyField`?; 3. Refactor `convective_adjustment!` to use the `BatchedTridiagonalSolver`.; 4. Add a free convection test to test that using `ConvectiveAdjustment` on a linearly stratified column model results in a mixed layer with ∂b/∂z ≈ 0 (could also test for the mixed layer depth). `ConvectiveAdjustment` could then be used as part of a tuple of turbulence closures, e.g. ```julia; closure = (IsotropicDiffusivity(κ=1e-4), ConvectiveAdjustment(κv=10)); ```. ## Future plans?. Vertically implicit diffusion with the `BatchedTridiagonalSolver` could then be abstracted to support other parameterizations such as `OceanTurb.KPP` and `OceanTurb.TKEMassFlux`. I think @glwagner envisioned a more general way of time-stepping implicit terms in general, i.e. adding IMEX time-steppers I think?. ## Note on user interface. Right now the user must manually call `convective_adjustment!` inside the `simulation.progress` callback so it's very awkward to use, but it should be usable if we need it. Ideally `convective_adjustment!` would be called at the end of each time step, perhaps by `time_step!` or by a simulation callback. The second approach would require resolving #1138.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1342
https://github.com/CliMA/Oceananigans.jl/pull/1342:718,Testability,test,test,718,"For now this PR just adds a function `convective_adjustment!(model, Δt, K)` that performs a convective adjustment step on a model. . I believe this results in an operator splitting method for treating vertically implicit diffusion using backward Euler. ## TODO. If this seems like an appropriate method for implementing vertically implicit diffusion, I'd suggest the following steps for turning this PR into something that can be merged:; 1. Define a new closure; ```julia; 	struct ConvectiveAdjustment{K, ∂}; 	 κ :: K; 	∂b∂z :: ∂; 		...; 	end; ```; 2. Maybe `ConvectiveAdjustment` should act on a `BuoyancyField`?; 3. Refactor `convective_adjustment!` to use the `BatchedTridiagonalSolver`.; 4. Add a free convection test to test that using `ConvectiveAdjustment` on a linearly stratified column model results in a mixed layer with ∂b/∂z ≈ 0 (could also test for the mixed layer depth). `ConvectiveAdjustment` could then be used as part of a tuple of turbulence closures, e.g. ```julia; closure = (IsotropicDiffusivity(κ=1e-4), ConvectiveAdjustment(κv=10)); ```. ## Future plans?. Vertically implicit diffusion with the `BatchedTridiagonalSolver` could then be abstracted to support other parameterizations such as `OceanTurb.KPP` and `OceanTurb.TKEMassFlux`. I think @glwagner envisioned a more general way of time-stepping implicit terms in general, i.e. adding IMEX time-steppers I think?. ## Note on user interface. Right now the user must manually call `convective_adjustment!` inside the `simulation.progress` callback so it's very awkward to use, but it should be usable if we need it. Ideally `convective_adjustment!` would be called at the end of each time step, perhaps by `time_step!` or by a simulation callback. The second approach would require resolving #1138.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1342
https://github.com/CliMA/Oceananigans.jl/pull/1342:726,Testability,test,test,726,"For now this PR just adds a function `convective_adjustment!(model, Δt, K)` that performs a convective adjustment step on a model. . I believe this results in an operator splitting method for treating vertically implicit diffusion using backward Euler. ## TODO. If this seems like an appropriate method for implementing vertically implicit diffusion, I'd suggest the following steps for turning this PR into something that can be merged:; 1. Define a new closure; ```julia; 	struct ConvectiveAdjustment{K, ∂}; 	 κ :: K; 	∂b∂z :: ∂; 		...; 	end; ```; 2. Maybe `ConvectiveAdjustment` should act on a `BuoyancyField`?; 3. Refactor `convective_adjustment!` to use the `BatchedTridiagonalSolver`.; 4. Add a free convection test to test that using `ConvectiveAdjustment` on a linearly stratified column model results in a mixed layer with ∂b/∂z ≈ 0 (could also test for the mixed layer depth). `ConvectiveAdjustment` could then be used as part of a tuple of turbulence closures, e.g. ```julia; closure = (IsotropicDiffusivity(κ=1e-4), ConvectiveAdjustment(κv=10)); ```. ## Future plans?. Vertically implicit diffusion with the `BatchedTridiagonalSolver` could then be abstracted to support other parameterizations such as `OceanTurb.KPP` and `OceanTurb.TKEMassFlux`. I think @glwagner envisioned a more general way of time-stepping implicit terms in general, i.e. adding IMEX time-steppers I think?. ## Note on user interface. Right now the user must manually call `convective_adjustment!` inside the `simulation.progress` callback so it's very awkward to use, but it should be usable if we need it. Ideally `convective_adjustment!` would be called at the end of each time step, perhaps by `time_step!` or by a simulation callback. The second approach would require resolving #1138.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1342
https://github.com/CliMA/Oceananigans.jl/pull/1342:855,Testability,test,test,855,"For now this PR just adds a function `convective_adjustment!(model, Δt, K)` that performs a convective adjustment step on a model. . I believe this results in an operator splitting method for treating vertically implicit diffusion using backward Euler. ## TODO. If this seems like an appropriate method for implementing vertically implicit diffusion, I'd suggest the following steps for turning this PR into something that can be merged:; 1. Define a new closure; ```julia; 	struct ConvectiveAdjustment{K, ∂}; 	 κ :: K; 	∂b∂z :: ∂; 		...; 	end; ```; 2. Maybe `ConvectiveAdjustment` should act on a `BuoyancyField`?; 3. Refactor `convective_adjustment!` to use the `BatchedTridiagonalSolver`.; 4. Add a free convection test to test that using `ConvectiveAdjustment` on a linearly stratified column model results in a mixed layer with ∂b/∂z ≈ 0 (could also test for the mixed layer depth). `ConvectiveAdjustment` could then be used as part of a tuple of turbulence closures, e.g. ```julia; closure = (IsotropicDiffusivity(κ=1e-4), ConvectiveAdjustment(κv=10)); ```. ## Future plans?. Vertically implicit diffusion with the `BatchedTridiagonalSolver` could then be abstracted to support other parameterizations such as `OceanTurb.KPP` and `OceanTurb.TKEMassFlux`. I think @glwagner envisioned a more general way of time-stepping implicit terms in general, i.e. adding IMEX time-steppers I think?. ## Note on user interface. Right now the user must manually call `convective_adjustment!` inside the `simulation.progress` callback so it's very awkward to use, but it should be usable if we need it. Ideally `convective_adjustment!` would be called at the end of each time step, perhaps by `time_step!` or by a simulation callback. The second approach would require resolving #1138.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1342
https://github.com/CliMA/Oceananigans.jl/pull/1342:1572,Usability,usab,usable,1572,"For now this PR just adds a function `convective_adjustment!(model, Δt, K)` that performs a convective adjustment step on a model. . I believe this results in an operator splitting method for treating vertically implicit diffusion using backward Euler. ## TODO. If this seems like an appropriate method for implementing vertically implicit diffusion, I'd suggest the following steps for turning this PR into something that can be merged:; 1. Define a new closure; ```julia; 	struct ConvectiveAdjustment{K, ∂}; 	 κ :: K; 	∂b∂z :: ∂; 		...; 	end; ```; 2. Maybe `ConvectiveAdjustment` should act on a `BuoyancyField`?; 3. Refactor `convective_adjustment!` to use the `BatchedTridiagonalSolver`.; 4. Add a free convection test to test that using `ConvectiveAdjustment` on a linearly stratified column model results in a mixed layer with ∂b/∂z ≈ 0 (could also test for the mixed layer depth). `ConvectiveAdjustment` could then be used as part of a tuple of turbulence closures, e.g. ```julia; closure = (IsotropicDiffusivity(κ=1e-4), ConvectiveAdjustment(κv=10)); ```. ## Future plans?. Vertically implicit diffusion with the `BatchedTridiagonalSolver` could then be abstracted to support other parameterizations such as `OceanTurb.KPP` and `OceanTurb.TKEMassFlux`. I think @glwagner envisioned a more general way of time-stepping implicit terms in general, i.e. adding IMEX time-steppers I think?. ## Note on user interface. Right now the user must manually call `convective_adjustment!` inside the `simulation.progress` callback so it's very awkward to use, but it should be usable if we need it. Ideally `convective_adjustment!` would be called at the end of each time step, perhaps by `time_step!` or by a simulation callback. The second approach would require resolving #1138.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1342
https://github.com/CliMA/Oceananigans.jl/pull/1347:169,Testability,test,tested,169,"This pull request changes the compat entry for the `StructArrays` package from `0.4` to `0.4, 0.5`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1347
https://github.com/CliMA/Oceananigans.jl/pull/1347:274,Testability,test,tests,274,"This pull request changes the compat entry for the `StructArrays` package from `0.4` to `0.4, 0.5`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1347
https://github.com/CliMA/Oceananigans.jl/pull/1348:710,Energy Efficiency,Adapt,Adapt,710,"This PR _finally_ revives the half-baked `VerticallyStretchedCartesianGrid` implementation that's been living in Oceananigans.jl for over a year. It also formalizes the `FourierTridiagonalPoissonSolver` that's been living in `test_solvers.jl` for a while as well. I re-ran the regression tests using a `VerticallyStretchedCartesianGrid` with constant spacing as a sanity check and they pass on the CPU which is good and helped uncover some functions that needed generalization. There's still quite a bit to do and test so maybe we should merge this PR after a bit of polish and continue developing and testing the `VerticallyStretchedCartesianGrid` in subsequent smaller PRs?. TODO off the top of my head:; 1. Adapt `VerticallyStretchedCartesianGrid` to work in GPU kernels. It has some offset arrays.; 2. Test the `FourierTridiagonalPoissonSolver` for other/all topologies.; 3. Add some dynamics tests?; 4. Validation experiment: Stratified Couette flow (Vreugdenhil & Taylor, 2018).; 5. Benchmarks! The xy FFT + z Tridiagonal solver might be faster than xyz FFT. Resolves #471. And of course, no PR is complete without eye candy (had to use matplotlib for irregular heatmaps):. https://user-images.githubusercontent.com/20099589/107367287-1fc7b400-6aad-11eb-945f-1fb2694392b2.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348
https://github.com/CliMA/Oceananigans.jl/pull/1348:710,Modifiability,Adapt,Adapt,710,"This PR _finally_ revives the half-baked `VerticallyStretchedCartesianGrid` implementation that's been living in Oceananigans.jl for over a year. It also formalizes the `FourierTridiagonalPoissonSolver` that's been living in `test_solvers.jl` for a while as well. I re-ran the regression tests using a `VerticallyStretchedCartesianGrid` with constant spacing as a sanity check and they pass on the CPU which is good and helped uncover some functions that needed generalization. There's still quite a bit to do and test so maybe we should merge this PR after a bit of polish and continue developing and testing the `VerticallyStretchedCartesianGrid` in subsequent smaller PRs?. TODO off the top of my head:; 1. Adapt `VerticallyStretchedCartesianGrid` to work in GPU kernels. It has some offset arrays.; 2. Test the `FourierTridiagonalPoissonSolver` for other/all topologies.; 3. Add some dynamics tests?; 4. Validation experiment: Stratified Couette flow (Vreugdenhil & Taylor, 2018).; 5. Benchmarks! The xy FFT + z Tridiagonal solver might be faster than xyz FFT. Resolves #471. And of course, no PR is complete without eye candy (had to use matplotlib for irregular heatmaps):. https://user-images.githubusercontent.com/20099589/107367287-1fc7b400-6aad-11eb-945f-1fb2694392b2.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348
https://github.com/CliMA/Oceananigans.jl/pull/1348:364,Safety,sanity check,sanity check,364,"This PR _finally_ revives the half-baked `VerticallyStretchedCartesianGrid` implementation that's been living in Oceananigans.jl for over a year. It also formalizes the `FourierTridiagonalPoissonSolver` that's been living in `test_solvers.jl` for a while as well. I re-ran the regression tests using a `VerticallyStretchedCartesianGrid` with constant spacing as a sanity check and they pass on the CPU which is good and helped uncover some functions that needed generalization. There's still quite a bit to do and test so maybe we should merge this PR after a bit of polish and continue developing and testing the `VerticallyStretchedCartesianGrid` in subsequent smaller PRs?. TODO off the top of my head:; 1. Adapt `VerticallyStretchedCartesianGrid` to work in GPU kernels. It has some offset arrays.; 2. Test the `FourierTridiagonalPoissonSolver` for other/all topologies.; 3. Add some dynamics tests?; 4. Validation experiment: Stratified Couette flow (Vreugdenhil & Taylor, 2018).; 5. Benchmarks! The xy FFT + z Tridiagonal solver might be faster than xyz FFT. Resolves #471. And of course, no PR is complete without eye candy (had to use matplotlib for irregular heatmaps):. https://user-images.githubusercontent.com/20099589/107367287-1fc7b400-6aad-11eb-945f-1fb2694392b2.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348
https://github.com/CliMA/Oceananigans.jl/pull/1348:908,Security,Validat,Validation,908,"This PR _finally_ revives the half-baked `VerticallyStretchedCartesianGrid` implementation that's been living in Oceananigans.jl for over a year. It also formalizes the `FourierTridiagonalPoissonSolver` that's been living in `test_solvers.jl` for a while as well. I re-ran the regression tests using a `VerticallyStretchedCartesianGrid` with constant spacing as a sanity check and they pass on the CPU which is good and helped uncover some functions that needed generalization. There's still quite a bit to do and test so maybe we should merge this PR after a bit of polish and continue developing and testing the `VerticallyStretchedCartesianGrid` in subsequent smaller PRs?. TODO off the top of my head:; 1. Adapt `VerticallyStretchedCartesianGrid` to work in GPU kernels. It has some offset arrays.; 2. Test the `FourierTridiagonalPoissonSolver` for other/all topologies.; 3. Add some dynamics tests?; 4. Validation experiment: Stratified Couette flow (Vreugdenhil & Taylor, 2018).; 5. Benchmarks! The xy FFT + z Tridiagonal solver might be faster than xyz FFT. Resolves #471. And of course, no PR is complete without eye candy (had to use matplotlib for irregular heatmaps):. https://user-images.githubusercontent.com/20099589/107367287-1fc7b400-6aad-11eb-945f-1fb2694392b2.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348
https://github.com/CliMA/Oceananigans.jl/pull/1348:288,Testability,test,tests,288,"This PR _finally_ revives the half-baked `VerticallyStretchedCartesianGrid` implementation that's been living in Oceananigans.jl for over a year. It also formalizes the `FourierTridiagonalPoissonSolver` that's been living in `test_solvers.jl` for a while as well. I re-ran the regression tests using a `VerticallyStretchedCartesianGrid` with constant spacing as a sanity check and they pass on the CPU which is good and helped uncover some functions that needed generalization. There's still quite a bit to do and test so maybe we should merge this PR after a bit of polish and continue developing and testing the `VerticallyStretchedCartesianGrid` in subsequent smaller PRs?. TODO off the top of my head:; 1. Adapt `VerticallyStretchedCartesianGrid` to work in GPU kernels. It has some offset arrays.; 2. Test the `FourierTridiagonalPoissonSolver` for other/all topologies.; 3. Add some dynamics tests?; 4. Validation experiment: Stratified Couette flow (Vreugdenhil & Taylor, 2018).; 5. Benchmarks! The xy FFT + z Tridiagonal solver might be faster than xyz FFT. Resolves #471. And of course, no PR is complete without eye candy (had to use matplotlib for irregular heatmaps):. https://user-images.githubusercontent.com/20099589/107367287-1fc7b400-6aad-11eb-945f-1fb2694392b2.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348
https://github.com/CliMA/Oceananigans.jl/pull/1348:514,Testability,test,test,514,"This PR _finally_ revives the half-baked `VerticallyStretchedCartesianGrid` implementation that's been living in Oceananigans.jl for over a year. It also formalizes the `FourierTridiagonalPoissonSolver` that's been living in `test_solvers.jl` for a while as well. I re-ran the regression tests using a `VerticallyStretchedCartesianGrid` with constant spacing as a sanity check and they pass on the CPU which is good and helped uncover some functions that needed generalization. There's still quite a bit to do and test so maybe we should merge this PR after a bit of polish and continue developing and testing the `VerticallyStretchedCartesianGrid` in subsequent smaller PRs?. TODO off the top of my head:; 1. Adapt `VerticallyStretchedCartesianGrid` to work in GPU kernels. It has some offset arrays.; 2. Test the `FourierTridiagonalPoissonSolver` for other/all topologies.; 3. Add some dynamics tests?; 4. Validation experiment: Stratified Couette flow (Vreugdenhil & Taylor, 2018).; 5. Benchmarks! The xy FFT + z Tridiagonal solver might be faster than xyz FFT. Resolves #471. And of course, no PR is complete without eye candy (had to use matplotlib for irregular heatmaps):. https://user-images.githubusercontent.com/20099589/107367287-1fc7b400-6aad-11eb-945f-1fb2694392b2.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348
https://github.com/CliMA/Oceananigans.jl/pull/1348:602,Testability,test,testing,602,"This PR _finally_ revives the half-baked `VerticallyStretchedCartesianGrid` implementation that's been living in Oceananigans.jl for over a year. It also formalizes the `FourierTridiagonalPoissonSolver` that's been living in `test_solvers.jl` for a while as well. I re-ran the regression tests using a `VerticallyStretchedCartesianGrid` with constant spacing as a sanity check and they pass on the CPU which is good and helped uncover some functions that needed generalization. There's still quite a bit to do and test so maybe we should merge this PR after a bit of polish and continue developing and testing the `VerticallyStretchedCartesianGrid` in subsequent smaller PRs?. TODO off the top of my head:; 1. Adapt `VerticallyStretchedCartesianGrid` to work in GPU kernels. It has some offset arrays.; 2. Test the `FourierTridiagonalPoissonSolver` for other/all topologies.; 3. Add some dynamics tests?; 4. Validation experiment: Stratified Couette flow (Vreugdenhil & Taylor, 2018).; 5. Benchmarks! The xy FFT + z Tridiagonal solver might be faster than xyz FFT. Resolves #471. And of course, no PR is complete without eye candy (had to use matplotlib for irregular heatmaps):. https://user-images.githubusercontent.com/20099589/107367287-1fc7b400-6aad-11eb-945f-1fb2694392b2.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348
https://github.com/CliMA/Oceananigans.jl/pull/1348:806,Testability,Test,Test,806,"This PR _finally_ revives the half-baked `VerticallyStretchedCartesianGrid` implementation that's been living in Oceananigans.jl for over a year. It also formalizes the `FourierTridiagonalPoissonSolver` that's been living in `test_solvers.jl` for a while as well. I re-ran the regression tests using a `VerticallyStretchedCartesianGrid` with constant spacing as a sanity check and they pass on the CPU which is good and helped uncover some functions that needed generalization. There's still quite a bit to do and test so maybe we should merge this PR after a bit of polish and continue developing and testing the `VerticallyStretchedCartesianGrid` in subsequent smaller PRs?. TODO off the top of my head:; 1. Adapt `VerticallyStretchedCartesianGrid` to work in GPU kernels. It has some offset arrays.; 2. Test the `FourierTridiagonalPoissonSolver` for other/all topologies.; 3. Add some dynamics tests?; 4. Validation experiment: Stratified Couette flow (Vreugdenhil & Taylor, 2018).; 5. Benchmarks! The xy FFT + z Tridiagonal solver might be faster than xyz FFT. Resolves #471. And of course, no PR is complete without eye candy (had to use matplotlib for irregular heatmaps):. https://user-images.githubusercontent.com/20099589/107367287-1fc7b400-6aad-11eb-945f-1fb2694392b2.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348
https://github.com/CliMA/Oceananigans.jl/pull/1348:897,Testability,test,tests,897,"This PR _finally_ revives the half-baked `VerticallyStretchedCartesianGrid` implementation that's been living in Oceananigans.jl for over a year. It also formalizes the `FourierTridiagonalPoissonSolver` that's been living in `test_solvers.jl` for a while as well. I re-ran the regression tests using a `VerticallyStretchedCartesianGrid` with constant spacing as a sanity check and they pass on the CPU which is good and helped uncover some functions that needed generalization. There's still quite a bit to do and test so maybe we should merge this PR after a bit of polish and continue developing and testing the `VerticallyStretchedCartesianGrid` in subsequent smaller PRs?. TODO off the top of my head:; 1. Adapt `VerticallyStretchedCartesianGrid` to work in GPU kernels. It has some offset arrays.; 2. Test the `FourierTridiagonalPoissonSolver` for other/all topologies.; 3. Add some dynamics tests?; 4. Validation experiment: Stratified Couette flow (Vreugdenhil & Taylor, 2018).; 5. Benchmarks! The xy FFT + z Tridiagonal solver might be faster than xyz FFT. Resolves #471. And of course, no PR is complete without eye candy (had to use matplotlib for irregular heatmaps):. https://user-images.githubusercontent.com/20099589/107367287-1fc7b400-6aad-11eb-945f-1fb2694392b2.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348
https://github.com/CliMA/Oceananigans.jl/pull/1348:989,Testability,Benchmark,Benchmarks,989,"This PR _finally_ revives the half-baked `VerticallyStretchedCartesianGrid` implementation that's been living in Oceananigans.jl for over a year. It also formalizes the `FourierTridiagonalPoissonSolver` that's been living in `test_solvers.jl` for a while as well. I re-ran the regression tests using a `VerticallyStretchedCartesianGrid` with constant spacing as a sanity check and they pass on the CPU which is good and helped uncover some functions that needed generalization. There's still quite a bit to do and test so maybe we should merge this PR after a bit of polish and continue developing and testing the `VerticallyStretchedCartesianGrid` in subsequent smaller PRs?. TODO off the top of my head:; 1. Adapt `VerticallyStretchedCartesianGrid` to work in GPU kernels. It has some offset arrays.; 2. Test the `FourierTridiagonalPoissonSolver` for other/all topologies.; 3. Add some dynamics tests?; 4. Validation experiment: Stratified Couette flow (Vreugdenhil & Taylor, 2018).; 5. Benchmarks! The xy FFT + z Tridiagonal solver might be faster than xyz FFT. Resolves #471. And of course, no PR is complete without eye candy (had to use matplotlib for irregular heatmaps):. https://user-images.githubusercontent.com/20099589/107367287-1fc7b400-6aad-11eb-945f-1fb2694392b2.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348
https://github.com/CliMA/Oceananigans.jl/pull/1349:428,Testability,test,tests,428,"This PR adds a new `AbstractModel` called `HydrostaticFreeSurfaceModel` to `IncompressibleModel` and `ShallowWaterModel` in the Oceananigans model suite. `HydrostaticFreeSurfaceModel` is intended to solve the hydrostatic Boussinesq equations beneath a free surface. This PR adds the basic infrastructure needed to time step models on a `RegularCartesianGrid` with explicit free surface dynamics. I think we should save dynamics tests and an example for a future PR, and just work on getting some of the basic ingredients into this model. The time-stepping tests are currently in place, but most of `time_step!(model::HydrostaticFreeSurface, dt)` needs to be fleshed out. Todo for this PR:. - [x] correct tendency calculation and time-stepping for an Adams-Bashforth timestepping method; - [x] calculation of vertical velocity from the continuity equation",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1349
https://github.com/CliMA/Oceananigans.jl/pull/1349:556,Testability,test,tests,556,"This PR adds a new `AbstractModel` called `HydrostaticFreeSurfaceModel` to `IncompressibleModel` and `ShallowWaterModel` in the Oceananigans model suite. `HydrostaticFreeSurfaceModel` is intended to solve the hydrostatic Boussinesq equations beneath a free surface. This PR adds the basic infrastructure needed to time step models on a `RegularCartesianGrid` with explicit free surface dynamics. I think we should save dynamics tests and an example for a future PR, and just work on getting some of the basic ingredients into this model. The time-stepping tests are currently in place, but most of `time_step!(model::HydrostaticFreeSurface, dt)` needs to be fleshed out. Todo for this PR:. - [x] correct tendency calculation and time-stepping for an Adams-Bashforth timestepping method; - [x] calculation of vertical velocity from the continuity equation",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1349
https://github.com/CliMA/Oceananigans.jl/pull/1350:22,Energy Efficiency,Reduce,ReducedField,22,"This fleshes out the `ReducedField` implementation a bit more by adding `boundary_conditions`. The `DefaultBoundaryCondition` for a reduced dimension is `nothing`. . This PR also generalizes our `launch!` utility so that kernel layouts can be ""flattened"" along reduced dimensions. It feels like there's a lot of boilerplate in our halo-filling functionality, but I'm not 100% sure how to mitigate (except with some hacky code generation which, we already have some of, and doesn't seem like the right solution). I also took the liberty to generalize halo filling for `Value` and `Gradient` halos while I was in the files (slight scope creep) so that simple `Value`/`Gradient` boundary conditions can be implemented that don't require the `clock, model_fields` keyword arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1350
https://github.com/CliMA/Oceananigans.jl/pull/1350:132,Energy Efficiency,reduce,reduced,132,"This fleshes out the `ReducedField` implementation a bit more by adding `boundary_conditions`. The `DefaultBoundaryCondition` for a reduced dimension is `nothing`. . This PR also generalizes our `launch!` utility so that kernel layouts can be ""flattened"" along reduced dimensions. It feels like there's a lot of boilerplate in our halo-filling functionality, but I'm not 100% sure how to mitigate (except with some hacky code generation which, we already have some of, and doesn't seem like the right solution). I also took the liberty to generalize halo filling for `Value` and `Gradient` halos while I was in the files (slight scope creep) so that simple `Value`/`Gradient` boundary conditions can be implemented that don't require the `clock, model_fields` keyword arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1350
https://github.com/CliMA/Oceananigans.jl/pull/1350:261,Energy Efficiency,reduce,reduced,261,"This fleshes out the `ReducedField` implementation a bit more by adding `boundary_conditions`. The `DefaultBoundaryCondition` for a reduced dimension is `nothing`. . This PR also generalizes our `launch!` utility so that kernel layouts can be ""flattened"" along reduced dimensions. It feels like there's a lot of boilerplate in our halo-filling functionality, but I'm not 100% sure how to mitigate (except with some hacky code generation which, we already have some of, and doesn't seem like the right solution). I also took the liberty to generalize halo filling for `Value` and `Gradient` halos while I was in the files (slight scope creep) so that simple `Value`/`Gradient` boundary conditions can be implemented that don't require the `clock, model_fields` keyword arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1350
https://github.com/CliMA/Oceananigans.jl/pull/1350:650,Usability,simpl,simple,650,"This fleshes out the `ReducedField` implementation a bit more by adding `boundary_conditions`. The `DefaultBoundaryCondition` for a reduced dimension is `nothing`. . This PR also generalizes our `launch!` utility so that kernel layouts can be ""flattened"" along reduced dimensions. It feels like there's a lot of boilerplate in our halo-filling functionality, but I'm not 100% sure how to mitigate (except with some hacky code generation which, we already have some of, and doesn't seem like the right solution). I also took the liberty to generalize halo filling for `Value` and `Gradient` halos while I was in the files (slight scope creep) so that simple `Value`/`Gradient` boundary conditions can be implemented that don't require the `clock, model_fields` keyword arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1350
https://github.com/CliMA/Oceananigans.jl/pull/1352:624,Safety,sanity check,sanity check,624,"This PR implements a fully explicit free surface quasi-second-order Adams-Bashforth time stepping algorithm for `HydrostaticFreeSurfaceModel`. It also adds `examples/geostrophic_adjustment.jl`, which produces this movie:. ![geostrophic_adjustment](https://user-images.githubusercontent.com/15271942/107706468-5c9ed100-6c8e-11eb-9329-2f439ab52858.gif). To support the example, we also now export `HydrostaticFreeSurfaceModel` (and emit a warning when its instantiated to remind users that it's experimental). Happy to take criticism on the geostrophic adjustment example. It's fairly barebones right now and more serves as a sanity check for `HydrostaticFreeSurfaceModel` physics than anything else. It'd be nice to get a little more pedagogical mileage out of it, I think, if we can. This PR also adds placeholder functions for `free_surface::ImplicitFreeSurface` and `free_surface::Nothing` (rigid lid). (Note to myself/future developers: we'll need add a the `barotropic_pressure_solver` property to use for the rigid lid case.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1352
https://github.com/CliMA/Oceananigans.jl/pull/1353:0,Usability,Simpl,Simplifies,0,"Simplifies the `make_example.jl` script that is used to build the Documentation only with 1 or 2 examples (e.g., an example one developer is currently working on). This makes previewing how the example will look like in the actual documentation much faster.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1353
https://github.com/CliMA/Oceananigans.jl/pull/1354:76,Energy Efficiency,Reduce,ReducedField,76,This will be needed to make `HydrostaticFreeSurfaceModel.free_surface.η` a `ReducedField`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1354
https://github.com/CliMA/Oceananigans.jl/pull/1357:14,Safety,avoid,avoid,14,You can never avoid all typos..,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1357
https://github.com/CliMA/Oceananigans.jl/pull/1359:175,Testability,test,tested,175,"This pull request changes the compat entry for the `JLD2` package from `^0.2, ^0.3` to `^0.2, ^0.3, 0.4`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1359
https://github.com/CliMA/Oceananigans.jl/pull/1359:280,Testability,test,tests,280,"This pull request changes the compat entry for the `JLD2` package from `^0.2, ^0.3` to `^0.2, ^0.3, 0.4`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1359
https://github.com/CliMA/Oceananigans.jl/pull/1360:669,Deployability,integrat,integration,669,"This is adds a pre-conditioned conjugate gradient (PCG) solver, with example working against rigid lid internal wave experiment and a single test. This is a first step toward a implicit free-surface PCG solver that can be used with general curvilinear grid finite-volume operators. . Not quite ready for merging yet. 1. we need to iterate a bit the right interface, examples/ etc... . 2. it runs kind of slow on GPU so it needs a little work on indexing and/or broadcast foo is upsetting GPU stuff. . 3. there is only one unit test with periodic bc's. we can add some more with different bc's once it runs fast on GPU. Movie shows internal wave example with PCG solver integration left and FFT solver integration right. . https://user-images.githubusercontent.com/3535328/107964974-f066ea80-6f77-11eb-8c7b-3025fdcf2a47.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360
https://github.com/CliMA/Oceananigans.jl/pull/1360:701,Deployability,integrat,integration,701,"This is adds a pre-conditioned conjugate gradient (PCG) solver, with example working against rigid lid internal wave experiment and a single test. This is a first step toward a implicit free-surface PCG solver that can be used with general curvilinear grid finite-volume operators. . Not quite ready for merging yet. 1. we need to iterate a bit the right interface, examples/ etc... . 2. it runs kind of slow on GPU so it needs a little work on indexing and/or broadcast foo is upsetting GPU stuff. . 3. there is only one unit test with periodic bc's. we can add some more with different bc's once it runs fast on GPU. Movie shows internal wave example with PCG solver integration left and FFT solver integration right. . https://user-images.githubusercontent.com/3535328/107964974-f066ea80-6f77-11eb-8c7b-3025fdcf2a47.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360
https://github.com/CliMA/Oceananigans.jl/pull/1360:355,Integrability,interface,interface,355,"This is adds a pre-conditioned conjugate gradient (PCG) solver, with example working against rigid lid internal wave experiment and a single test. This is a first step toward a implicit free-surface PCG solver that can be used with general curvilinear grid finite-volume operators. . Not quite ready for merging yet. 1. we need to iterate a bit the right interface, examples/ etc... . 2. it runs kind of slow on GPU so it needs a little work on indexing and/or broadcast foo is upsetting GPU stuff. . 3. there is only one unit test with periodic bc's. we can add some more with different bc's once it runs fast on GPU. Movie shows internal wave example with PCG solver integration left and FFT solver integration right. . https://user-images.githubusercontent.com/3535328/107964974-f066ea80-6f77-11eb-8c7b-3025fdcf2a47.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360
https://github.com/CliMA/Oceananigans.jl/pull/1360:669,Integrability,integrat,integration,669,"This is adds a pre-conditioned conjugate gradient (PCG) solver, with example working against rigid lid internal wave experiment and a single test. This is a first step toward a implicit free-surface PCG solver that can be used with general curvilinear grid finite-volume operators. . Not quite ready for merging yet. 1. we need to iterate a bit the right interface, examples/ etc... . 2. it runs kind of slow on GPU so it needs a little work on indexing and/or broadcast foo is upsetting GPU stuff. . 3. there is only one unit test with periodic bc's. we can add some more with different bc's once it runs fast on GPU. Movie shows internal wave example with PCG solver integration left and FFT solver integration right. . https://user-images.githubusercontent.com/3535328/107964974-f066ea80-6f77-11eb-8c7b-3025fdcf2a47.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360
https://github.com/CliMA/Oceananigans.jl/pull/1360:701,Integrability,integrat,integration,701,"This is adds a pre-conditioned conjugate gradient (PCG) solver, with example working against rigid lid internal wave experiment and a single test. This is a first step toward a implicit free-surface PCG solver that can be used with general curvilinear grid finite-volume operators. . Not quite ready for merging yet. 1. we need to iterate a bit the right interface, examples/ etc... . 2. it runs kind of slow on GPU so it needs a little work on indexing and/or broadcast foo is upsetting GPU stuff. . 3. there is only one unit test with periodic bc's. we can add some more with different bc's once it runs fast on GPU. Movie shows internal wave example with PCG solver integration left and FFT solver integration right. . https://user-images.githubusercontent.com/3535328/107964974-f066ea80-6f77-11eb-8c7b-3025fdcf2a47.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360
https://github.com/CliMA/Oceananigans.jl/pull/1360:141,Testability,test,test,141,"This is adds a pre-conditioned conjugate gradient (PCG) solver, with example working against rigid lid internal wave experiment and a single test. This is a first step toward a implicit free-surface PCG solver that can be used with general curvilinear grid finite-volume operators. . Not quite ready for merging yet. 1. we need to iterate a bit the right interface, examples/ etc... . 2. it runs kind of slow on GPU so it needs a little work on indexing and/or broadcast foo is upsetting GPU stuff. . 3. there is only one unit test with periodic bc's. we can add some more with different bc's once it runs fast on GPU. Movie shows internal wave example with PCG solver integration left and FFT solver integration right. . https://user-images.githubusercontent.com/3535328/107964974-f066ea80-6f77-11eb-8c7b-3025fdcf2a47.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360
https://github.com/CliMA/Oceananigans.jl/pull/1360:527,Testability,test,test,527,"This is adds a pre-conditioned conjugate gradient (PCG) solver, with example working against rigid lid internal wave experiment and a single test. This is a first step toward a implicit free-surface PCG solver that can be used with general curvilinear grid finite-volume operators. . Not quite ready for merging yet. 1. we need to iterate a bit the right interface, examples/ etc... . 2. it runs kind of slow on GPU so it needs a little work on indexing and/or broadcast foo is upsetting GPU stuff. . 3. there is only one unit test with periodic bc's. we can add some more with different bc's once it runs fast on GPU. Movie shows internal wave example with PCG solver integration left and FFT solver integration right. . https://user-images.githubusercontent.com/3535328/107964974-f066ea80-6f77-11eb-8c7b-3025fdcf2a47.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360
https://github.com/CliMA/Oceananigans.jl/issues/1364:668,Usability,intuit,intuitive,668,"Ideally, a user could set up and analyze an Oceananigans simulation without knowing anything about the staggered grid. Right now output includes `xC`, `xF`, etc. so this is the one place the user is forced to know about the staggered grid. Many users just want to plot output and not worry about N+1 faces and closing budgets, etc. We should have an option to save output onto an interpolated grid. One option would be to save everything at `(Center, Center, Center)`. Then the output will just have `x`, `y`, and `z`. Interpolated output would become especially useful for users on more complicated grid like the cubed sphere. Most users will probably want plain and intuitive `lat`, `lon`, `z` output.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1364
https://github.com/CliMA/Oceananigans.jl/pull/1365:662,Energy Efficiency,Reduce,Reduce,662,Inspired by @Lichriszz and their problem in [#1362](https://github.com/CliMA/Oceananigans.jl/discussions/1362#discussioncomment-374286) I started to make an example of two dimensional turbulence using the shallow water model. At the moment the results are not necessarily worth looking at but I wonder if people could look at the code [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/two-dimensional-turbulence-shallow-water-example/examples/two_dimensional_turbulence_shallow_water.jl) and say whether the set up is what we want?. A few issues that I have come cross are the following:. - [x] Use the time stepping wizard for numerical stability; - [x] Reduce the number of import statements; - [ ] Plot the vorticity and the divergence fields; - [x] Pick the parameters to get nice results. What is a good a reference for a planar geometry?; - [ ] Should test on GPU; - [ ] Should test with higher resolution. One possible paper is [Polvani et al (1994)](https://aip.scitation.org/doi/pdf/10.1063/1.166002),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1365
https://github.com/CliMA/Oceananigans.jl/pull/1365:865,Testability,test,test,865,Inspired by @Lichriszz and their problem in [#1362](https://github.com/CliMA/Oceananigans.jl/discussions/1362#discussioncomment-374286) I started to make an example of two dimensional turbulence using the shallow water model. At the moment the results are not necessarily worth looking at but I wonder if people could look at the code [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/two-dimensional-turbulence-shallow-water-example/examples/two_dimensional_turbulence_shallow_water.jl) and say whether the set up is what we want?. A few issues that I have come cross are the following:. - [x] Use the time stepping wizard for numerical stability; - [x] Reduce the number of import statements; - [ ] Plot the vorticity and the divergence fields; - [x] Pick the parameters to get nice results. What is a good a reference for a planar geometry?; - [ ] Should test on GPU; - [ ] Should test with higher resolution. One possible paper is [Polvani et al (1994)](https://aip.scitation.org/doi/pdf/10.1063/1.166002),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1365
https://github.com/CliMA/Oceananigans.jl/pull/1365:891,Testability,test,test,891,Inspired by @Lichriszz and their problem in [#1362](https://github.com/CliMA/Oceananigans.jl/discussions/1362#discussioncomment-374286) I started to make an example of two dimensional turbulence using the shallow water model. At the moment the results are not necessarily worth looking at but I wonder if people could look at the code [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/two-dimensional-turbulence-shallow-water-example/examples/two_dimensional_turbulence_shallow_water.jl) and say whether the set up is what we want?. A few issues that I have come cross are the following:. - [x] Use the time stepping wizard for numerical stability; - [x] Reduce the number of import statements; - [ ] Plot the vorticity and the divergence fields; - [x] Pick the parameters to get nice results. What is a good a reference for a planar geometry?; - [ ] Should test on GPU; - [ ] Should test with higher resolution. One possible paper is [Polvani et al (1994)](https://aip.scitation.org/doi/pdf/10.1063/1.166002),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1365
https://github.com/CliMA/Oceananigans.jl/pull/1366:125,Security,validat,validation,125,"This PR implements a `VectorInvariant` formulation for momentum advection in `HydrostaticFreeSurfaceModel`, and also adds a `validation/bickley_jet/bickley_jet.jl` script. . `validation/bickley_jet/` also contains a preliminary implementation of `DiskTimeSeries` which might be useful to merge into the source code eventually to help users post-process their output. With `WENO5` for both `momentum_advection` and `tracer_advection`, we obtain. https://user-images.githubusercontent.com/15271942/108126995-913ccf00-7078-11eb-8ced-ac4d51fe3bd2.mp4. This is more or less what we ""expect"" (though it'd be nice to be more quantitative at some point). With `CenteredSecondOrder` for `momentum_advection`, but `WENO5` for `tracer_advection`, we obtain. https://user-images.githubusercontent.com/15271942/108127592-7454cb80-7079-11eb-9091-45cd93464c6e.mp4. while with `VectorInvariant` we get. https://user-images.githubusercontent.com/15271942/108127600-77e85280-7079-11eb-9f55-2fc5f8ea1a06.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1366
https://github.com/CliMA/Oceananigans.jl/pull/1366:175,Security,validat,validation,175,"This PR implements a `VectorInvariant` formulation for momentum advection in `HydrostaticFreeSurfaceModel`, and also adds a `validation/bickley_jet/bickley_jet.jl` script. . `validation/bickley_jet/` also contains a preliminary implementation of `DiskTimeSeries` which might be useful to merge into the source code eventually to help users post-process their output. With `WENO5` for both `momentum_advection` and `tracer_advection`, we obtain. https://user-images.githubusercontent.com/15271942/108126995-913ccf00-7078-11eb-8ced-ac4d51fe3bd2.mp4. This is more or less what we ""expect"" (though it'd be nice to be more quantitative at some point). With `CenteredSecondOrder` for `momentum_advection`, but `WENO5` for `tracer_advection`, we obtain. https://user-images.githubusercontent.com/15271942/108127592-7454cb80-7079-11eb-9091-45cd93464c6e.mp4. while with `VectorInvariant` we get. https://user-images.githubusercontent.com/15271942/108127600-77e85280-7079-11eb-9f55-2fc5f8ea1a06.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1366
https://github.com/CliMA/Oceananigans.jl/pull/1368:1527,Availability,error,error,1527,"ty_Re40_dx04_small_paper](https://user-images.githubusercontent.com/67593861/108130156-2f329880-707d-11eb-87db-6d519e2513be.gif); ; The barebones of this implementation is rather old at this point. Even though it has been updated to work with the current set up, I imagine there are things that might still need more updating or have become superfluous. All suggestions are appreciated!. ### Description:; Instead of conforming the mesh to the fluid domain, a cartesian grid is generated over the whole area. Then, an added forcing term incorporates the boundary conditions into the equations. In practice, when your boundary conforms to the grids, creating a stair-step like boundary, this becomes much simpler to handle. Here, we replace the tendency terms in `correct_immersed_tendencies.jl` so that when you take the next Runge-Kutta step, you end up with U = 0. . Since this process occurs before the pressure correction, there is a small amount of error that seems to fit with the correction as seen here for various places within the cylinder where it should be zero:; ![Pcorrect_vs_velocity_inside_dx04](https://user-images.githubusercontent.com/67593861/108130321-7ae54200-707d-11eb-9101-273350597d8c.png); ; It would need more testing to truly verify that this is the case, but seems to fit the data so far. ### To Do/ Upcoming:; - Currently working on an arbitrary grid implementation, that can intersect the boundary however it wants. This involves a good amount of interpolation, but it well on the way. This implementation will easily handle Neumann and Dirichlet boundary conditions. It makes more sense for normal and tangential boundary conditions rather than specific (u,v,w) conditions, so we will also project the velocities along with interpolating.; - Need to add a way for the user to specify boundary conditions; - Add tracer capabilities. The implementation is slightly different for arbitrary grids, since tracers will be a scalar that is not rotated into normal and tangent",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1368
https://github.com/CliMA/Oceananigans.jl/pull/1368:795,Deployability,update,updated,795,"This PR is to add the basic implementation of immersed boundaries with grid-conforming coordinates #1036. This is still a work in progress, but so far it can handle forcing the velocity components to create an immersed boundary. It does not work with the tracer equations, yet, and it assumes a Dirichlet-zero boundary condition. The user must give a boolean function to the model, which returns `false` if the point is in the fluid. . This also includes a basic example for steady-state flow around a cylinder in 2D `flow_around_cylinder_lowRe.jl`, such as this:; ![velocity_Re40_dx04_small_paper](https://user-images.githubusercontent.com/67593861/108130156-2f329880-707d-11eb-87db-6d519e2513be.gif); ; The barebones of this implementation is rather old at this point. Even though it has been updated to work with the current set up, I imagine there are things that might still need more updating or have become superfluous. All suggestions are appreciated!. ### Description:; Instead of conforming the mesh to the fluid domain, a cartesian grid is generated over the whole area. Then, an added forcing term incorporates the boundary conditions into the equations. In practice, when your boundary conforms to the grids, creating a stair-step like boundary, this becomes much simpler to handle. Here, we replace the tendency terms in `correct_immersed_tendencies.jl` so that when you take the next Runge-Kutta step, you end up with U = 0. . Since this process occurs before the pressure correction, there is a small amount of error that seems to fit with the correction as seen here for various places within the cylinder where it should be zero:; ![Pcorrect_vs_velocity_inside_dx04](https://user-images.githubusercontent.com/67593861/108130321-7ae54200-707d-11eb-9101-273350597d8c.png); ; It would need more testing to truly verify that this is the case, but seems to fit the data so far. ### To Do/ Upcoming:; - Currently working on an arbitrary grid implementation, that can intersect the boundary",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1368
https://github.com/CliMA/Oceananigans.jl/pull/1368:1810,Testability,test,testing,1810,"user-images.githubusercontent.com/67593861/108130156-2f329880-707d-11eb-87db-6d519e2513be.gif); ; The barebones of this implementation is rather old at this point. Even though it has been updated to work with the current set up, I imagine there are things that might still need more updating or have become superfluous. All suggestions are appreciated!. ### Description:; Instead of conforming the mesh to the fluid domain, a cartesian grid is generated over the whole area. Then, an added forcing term incorporates the boundary conditions into the equations. In practice, when your boundary conforms to the grids, creating a stair-step like boundary, this becomes much simpler to handle. Here, we replace the tendency terms in `correct_immersed_tendencies.jl` so that when you take the next Runge-Kutta step, you end up with U = 0. . Since this process occurs before the pressure correction, there is a small amount of error that seems to fit with the correction as seen here for various places within the cylinder where it should be zero:; ![Pcorrect_vs_velocity_inside_dx04](https://user-images.githubusercontent.com/67593861/108130321-7ae54200-707d-11eb-9101-273350597d8c.png); ; It would need more testing to truly verify that this is the case, but seems to fit the data so far. ### To Do/ Upcoming:; - Currently working on an arbitrary grid implementation, that can intersect the boundary however it wants. This involves a good amount of interpolation, but it well on the way. This implementation will easily handle Neumann and Dirichlet boundary conditions. It makes more sense for normal and tangential boundary conditions rather than specific (u,v,w) conditions, so we will also project the velocities along with interpolating.; - Need to add a way for the user to specify boundary conditions; - Add tracer capabilities. The implementation is slightly different for arbitrary grids, since tracers will be a scalar that is not rotated into normal and tangential components for implementation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1368
https://github.com/CliMA/Oceananigans.jl/pull/1368:1277,Usability,simpl,simpler,1277,"t does not work with the tracer equations, yet, and it assumes a Dirichlet-zero boundary condition. The user must give a boolean function to the model, which returns `false` if the point is in the fluid. . This also includes a basic example for steady-state flow around a cylinder in 2D `flow_around_cylinder_lowRe.jl`, such as this:; ![velocity_Re40_dx04_small_paper](https://user-images.githubusercontent.com/67593861/108130156-2f329880-707d-11eb-87db-6d519e2513be.gif); ; The barebones of this implementation is rather old at this point. Even though it has been updated to work with the current set up, I imagine there are things that might still need more updating or have become superfluous. All suggestions are appreciated!. ### Description:; Instead of conforming the mesh to the fluid domain, a cartesian grid is generated over the whole area. Then, an added forcing term incorporates the boundary conditions into the equations. In practice, when your boundary conforms to the grids, creating a stair-step like boundary, this becomes much simpler to handle. Here, we replace the tendency terms in `correct_immersed_tendencies.jl` so that when you take the next Runge-Kutta step, you end up with U = 0. . Since this process occurs before the pressure correction, there is a small amount of error that seems to fit with the correction as seen here for various places within the cylinder where it should be zero:; ![Pcorrect_vs_velocity_inside_dx04](https://user-images.githubusercontent.com/67593861/108130321-7ae54200-707d-11eb-9101-273350597d8c.png); ; It would need more testing to truly verify that this is the case, but seems to fit the data so far. ### To Do/ Upcoming:; - Currently working on an arbitrary grid implementation, that can intersect the boundary however it wants. This involves a good amount of interpolation, but it well on the way. This implementation will easily handle Neumann and Dirichlet boundary conditions. It makes more sense for normal and tangential boundary cond",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1368
https://github.com/CliMA/Oceananigans.jl/issues/1369:1290,Availability,error,error,1290,"`KernelComputedField` contains a property called `field_dependencies`, which is supposed to be some kind of iterable whose members get `compute!` called on them:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L76-L80. and then are later splatted into the function signature of the `kernel`:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L92. But since `compute!` can be called on non-fields harmlessly, its possible to put any objects at all in `field_dependencies`. The name doesn't help clear things up, since the meaning of ""field dependencies"" is ambiguous (do we mean ""dependencies of the KernelComputed _field_"", and therefore any objects at all, or ""specifically objects that are _fields_ on which the KernelComputedField depends""?). Perhaps even worse is the fact that it makes sense to put `AbstractOperations` in `field_dependencies`, because its possible for `AbstractOperations` to themselves depend on fields, thus warranting the `compute!(abstract_operation)`. A better name than `field_dependencies` is probably `computed_dependencies`. At least this makes clear what's happening under the hood. We should also throw an error if `computed_dependencies` is not iterable (failure will occur later on anyways). A more drastic change is to get rid of `parameters`, which I would be ok with too. However, I think it is potentially a nice feature that some users will appreciate and use to make their scripts and code a little cleaner and more interpretable. See also the discussion on https://github.com/tomchor/Oceanostics.jl/issues/1. cc @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1369
https://github.com/CliMA/Oceananigans.jl/issues/1369:1340,Availability,failure,failure,1340,"`KernelComputedField` contains a property called `field_dependencies`, which is supposed to be some kind of iterable whose members get `compute!` called on them:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L76-L80. and then are later splatted into the function signature of the `kernel`:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L92. But since `compute!` can be called on non-fields harmlessly, its possible to put any objects at all in `field_dependencies`. The name doesn't help clear things up, since the meaning of ""field dependencies"" is ambiguous (do we mean ""dependencies of the KernelComputed _field_"", and therefore any objects at all, or ""specifically objects that are _fields_ on which the KernelComputedField depends""?). Perhaps even worse is the fact that it makes sense to put `AbstractOperations` in `field_dependencies`, because its possible for `AbstractOperations` to themselves depend on fields, thus warranting the `compute!(abstract_operation)`. A better name than `field_dependencies` is probably `computed_dependencies`. At least this makes clear what's happening under the hood. We should also throw an error if `computed_dependencies` is not iterable (failure will occur later on anyways). A more drastic change is to get rid of `parameters`, which I would be ok with too. However, I think it is potentially a nice feature that some users will appreciate and use to make their scripts and code a little cleaner and more interpretable. See also the discussion on https://github.com/tomchor/Oceanostics.jl/issues/1. cc @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1369
https://github.com/CliMA/Oceananigans.jl/issues/1369:689,Integrability,depend,dependencies,689,"`KernelComputedField` contains a property called `field_dependencies`, which is supposed to be some kind of iterable whose members get `compute!` called on them:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L76-L80. and then are later splatted into the function signature of the `kernel`:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L92. But since `compute!` can be called on non-fields harmlessly, its possible to put any objects at all in `field_dependencies`. The name doesn't help clear things up, since the meaning of ""field dependencies"" is ambiguous (do we mean ""dependencies of the KernelComputed _field_"", and therefore any objects at all, or ""specifically objects that are _fields_ on which the KernelComputedField depends""?). Perhaps even worse is the fact that it makes sense to put `AbstractOperations` in `field_dependencies`, because its possible for `AbstractOperations` to themselves depend on fields, thus warranting the `compute!(abstract_operation)`. A better name than `field_dependencies` is probably `computed_dependencies`. At least this makes clear what's happening under the hood. We should also throw an error if `computed_dependencies` is not iterable (failure will occur later on anyways). A more drastic change is to get rid of `parameters`, which I would be ok with too. However, I think it is potentially a nice feature that some users will appreciate and use to make their scripts and code a little cleaner and more interpretable. See also the discussion on https://github.com/tomchor/Oceanostics.jl/issues/1. cc @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1369
https://github.com/CliMA/Oceananigans.jl/issues/1369:729,Integrability,depend,dependencies,729,"`KernelComputedField` contains a property called `field_dependencies`, which is supposed to be some kind of iterable whose members get `compute!` called on them:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L76-L80. and then are later splatted into the function signature of the `kernel`:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L92. But since `compute!` can be called on non-fields harmlessly, its possible to put any objects at all in `field_dependencies`. The name doesn't help clear things up, since the meaning of ""field dependencies"" is ambiguous (do we mean ""dependencies of the KernelComputed _field_"", and therefore any objects at all, or ""specifically objects that are _fields_ on which the KernelComputedField depends""?). Perhaps even worse is the fact that it makes sense to put `AbstractOperations` in `field_dependencies`, because its possible for `AbstractOperations` to themselves depend on fields, thus warranting the `compute!(abstract_operation)`. A better name than `field_dependencies` is probably `computed_dependencies`. At least this makes clear what's happening under the hood. We should also throw an error if `computed_dependencies` is not iterable (failure will occur later on anyways). A more drastic change is to get rid of `parameters`, which I would be ok with too. However, I think it is potentially a nice feature that some users will appreciate and use to make their scripts and code a little cleaner and more interpretable. See also the discussion on https://github.com/tomchor/Oceanostics.jl/issues/1. cc @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1369
https://github.com/CliMA/Oceananigans.jl/issues/1369:884,Integrability,depend,depends,884,"`KernelComputedField` contains a property called `field_dependencies`, which is supposed to be some kind of iterable whose members get `compute!` called on them:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L76-L80. and then are later splatted into the function signature of the `kernel`:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L92. But since `compute!` can be called on non-fields harmlessly, its possible to put any objects at all in `field_dependencies`. The name doesn't help clear things up, since the meaning of ""field dependencies"" is ambiguous (do we mean ""dependencies of the KernelComputed _field_"", and therefore any objects at all, or ""specifically objects that are _fields_ on which the KernelComputedField depends""?). Perhaps even worse is the fact that it makes sense to put `AbstractOperations` in `field_dependencies`, because its possible for `AbstractOperations` to themselves depend on fields, thus warranting the `compute!(abstract_operation)`. A better name than `field_dependencies` is probably `computed_dependencies`. At least this makes clear what's happening under the hood. We should also throw an error if `computed_dependencies` is not iterable (failure will occur later on anyways). A more drastic change is to get rid of `parameters`, which I would be ok with too. However, I think it is potentially a nice feature that some users will appreciate and use to make their scripts and code a little cleaner and more interpretable. See also the discussion on https://github.com/tomchor/Oceanostics.jl/issues/1. cc @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1369
https://github.com/CliMA/Oceananigans.jl/issues/1369:1060,Integrability,depend,depend,1060,"`KernelComputedField` contains a property called `field_dependencies`, which is supposed to be some kind of iterable whose members get `compute!` called on them:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L76-L80. and then are later splatted into the function signature of the `kernel`:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L92. But since `compute!` can be called on non-fields harmlessly, its possible to put any objects at all in `field_dependencies`. The name doesn't help clear things up, since the meaning of ""field dependencies"" is ambiguous (do we mean ""dependencies of the KernelComputed _field_"", and therefore any objects at all, or ""specifically objects that are _fields_ on which the KernelComputedField depends""?). Perhaps even worse is the fact that it makes sense to put `AbstractOperations` in `field_dependencies`, because its possible for `AbstractOperations` to themselves depend on fields, thus warranting the `compute!(abstract_operation)`. A better name than `field_dependencies` is probably `computed_dependencies`. At least this makes clear what's happening under the hood. We should also throw an error if `computed_dependencies` is not iterable (failure will occur later on anyways). A more drastic change is to get rid of `parameters`, which I would be ok with too. However, I think it is potentially a nice feature that some users will appreciate and use to make their scripts and code a little cleaner and more interpretable. See also the discussion on https://github.com/tomchor/Oceanostics.jl/issues/1. cc @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1369
https://github.com/CliMA/Oceananigans.jl/issues/1369:644,Usability,clear,clear,644,"`KernelComputedField` contains a property called `field_dependencies`, which is supposed to be some kind of iterable whose members get `compute!` called on them:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L76-L80. and then are later splatted into the function signature of the `kernel`:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L92. But since `compute!` can be called on non-fields harmlessly, its possible to put any objects at all in `field_dependencies`. The name doesn't help clear things up, since the meaning of ""field dependencies"" is ambiguous (do we mean ""dependencies of the KernelComputed _field_"", and therefore any objects at all, or ""specifically objects that are _fields_ on which the KernelComputedField depends""?). Perhaps even worse is the fact that it makes sense to put `AbstractOperations` in `field_dependencies`, because its possible for `AbstractOperations` to themselves depend on fields, thus warranting the `compute!(abstract_operation)`. A better name than `field_dependencies` is probably `computed_dependencies`. At least this makes clear what's happening under the hood. We should also throw an error if `computed_dependencies` is not iterable (failure will occur later on anyways). A more drastic change is to get rid of `parameters`, which I would be ok with too. However, I think it is potentially a nice feature that some users will appreciate and use to make their scripts and code a little cleaner and more interpretable. See also the discussion on https://github.com/tomchor/Oceanostics.jl/issues/1. cc @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1369
https://github.com/CliMA/Oceananigans.jl/issues/1369:1227,Usability,clear,clear,1227,"`KernelComputedField` contains a property called `field_dependencies`, which is supposed to be some kind of iterable whose members get `compute!` called on them:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L76-L80. and then are later splatted into the function signature of the `kernel`:. https://github.com/CliMA/Oceananigans.jl/blob/df9b830e574261efb1b7b0ee43b783be2381ceaf/src/Fields/kernel_computed_field.jl#L92. But since `compute!` can be called on non-fields harmlessly, its possible to put any objects at all in `field_dependencies`. The name doesn't help clear things up, since the meaning of ""field dependencies"" is ambiguous (do we mean ""dependencies of the KernelComputed _field_"", and therefore any objects at all, or ""specifically objects that are _fields_ on which the KernelComputedField depends""?). Perhaps even worse is the fact that it makes sense to put `AbstractOperations` in `field_dependencies`, because its possible for `AbstractOperations` to themselves depend on fields, thus warranting the `compute!(abstract_operation)`. A better name than `field_dependencies` is probably `computed_dependencies`. At least this makes clear what's happening under the hood. We should also throw an error if `computed_dependencies` is not iterable (failure will occur later on anyways). A more drastic change is to get rid of `parameters`, which I would be ok with too. However, I think it is potentially a nice feature that some users will appreciate and use to make their scripts and code a little cleaner and more interpretable. See also the discussion on https://github.com/tomchor/Oceanostics.jl/issues/1. cc @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1369
https://github.com/CliMA/Oceananigans.jl/pull/1371:742,Availability,error,errors,742,"This PR adds areas, volumes, and a few product operators needed to evaluate correct Coriolis terms on curvilinear grids, following. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8. Before merging we should discuss:. - Should I update all the Coriolis terms? (`beta_plane.jl, non_traditional_f_plane.jl`, etc?); - Are we ok using three-letter codes, even though we only plan to support horizontally-curvilinear grids (rather than vertically curvilinear grids) in the near future?; - Should we add more regression tests / evaluate existing regression tests before changing terms that are not covered?; - It's not feasible to adapt the _entire_ codebase to work on curvilinear grids right now. How should we handle throwing errors for cases that are not supported? Adding `RegularCartesianGrid` annotations in key places seems like the easiest strategy, but we should be careful not to miss any. We can perhaps add annotations to _all_ operators, and then support curvilinearity in as parsimonious fashion as possible to be conservative.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1371
https://github.com/CliMA/Oceananigans.jl/pull/1371:248,Deployability,update,update,248,"This PR adds areas, volumes, and a few product operators needed to evaluate correct Coriolis terms on curvilinear grids, following. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8. Before merging we should discuss:. - Should I update all the Coriolis terms? (`beta_plane.jl, non_traditional_f_plane.jl`, etc?); - Are we ok using three-letter codes, even though we only plan to support horizontally-curvilinear grids (rather than vertically curvilinear grids) in the near future?; - Should we add more regression tests / evaluate existing regression tests before changing terms that are not covered?; - It's not feasible to adapt the _entire_ codebase to work on curvilinear grids right now. How should we handle throwing errors for cases that are not supported? Adding `RegularCartesianGrid` annotations in key places seems like the easiest strategy, but we should be careful not to miss any. We can perhaps add annotations to _all_ operators, and then support curvilinearity in as parsimonious fashion as possible to be conservative.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1371
https://github.com/CliMA/Oceananigans.jl/pull/1371:644,Energy Efficiency,adapt,adapt,644,"This PR adds areas, volumes, and a few product operators needed to evaluate correct Coriolis terms on curvilinear grids, following. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8. Before merging we should discuss:. - Should I update all the Coriolis terms? (`beta_plane.jl, non_traditional_f_plane.jl`, etc?); - Are we ok using three-letter codes, even though we only plan to support horizontally-curvilinear grids (rather than vertically curvilinear grids) in the near future?; - Should we add more regression tests / evaluate existing regression tests before changing terms that are not covered?; - It's not feasible to adapt the _entire_ codebase to work on curvilinear grids right now. How should we handle throwing errors for cases that are not supported? Adding `RegularCartesianGrid` annotations in key places seems like the easiest strategy, but we should be careful not to miss any. We can perhaps add annotations to _all_ operators, and then support curvilinearity in as parsimonious fashion as possible to be conservative.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1371
https://github.com/CliMA/Oceananigans.jl/pull/1371:644,Modifiability,adapt,adapt,644,"This PR adds areas, volumes, and a few product operators needed to evaluate correct Coriolis terms on curvilinear grids, following. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8. Before merging we should discuss:. - Should I update all the Coriolis terms? (`beta_plane.jl, non_traditional_f_plane.jl`, etc?); - Are we ok using three-letter codes, even though we only plan to support horizontally-curvilinear grids (rather than vertically curvilinear grids) in the near future?; - Should we add more regression tests / evaluate existing regression tests before changing terms that are not covered?; - It's not feasible to adapt the _entire_ codebase to work on curvilinear grids right now. How should we handle throwing errors for cases that are not supported? Adding `RegularCartesianGrid` annotations in key places seems like the easiest strategy, but we should be careful not to miss any. We can perhaps add annotations to _all_ operators, and then support curvilinearity in as parsimonious fashion as possible to be conservative.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1371
https://github.com/CliMA/Oceananigans.jl/pull/1371:533,Testability,test,tests,533,"This PR adds areas, volumes, and a few product operators needed to evaluate correct Coriolis terms on curvilinear grids, following. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8. Before merging we should discuss:. - Should I update all the Coriolis terms? (`beta_plane.jl, non_traditional_f_plane.jl`, etc?); - Are we ok using three-letter codes, even though we only plan to support horizontally-curvilinear grids (rather than vertically curvilinear grids) in the near future?; - Should we add more regression tests / evaluate existing regression tests before changing terms that are not covered?; - It's not feasible to adapt the _entire_ codebase to work on curvilinear grids right now. How should we handle throwing errors for cases that are not supported? Adding `RegularCartesianGrid` annotations in key places seems like the easiest strategy, but we should be careful not to miss any. We can perhaps add annotations to _all_ operators, and then support curvilinearity in as parsimonious fashion as possible to be conservative.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1371
https://github.com/CliMA/Oceananigans.jl/pull/1371:570,Testability,test,tests,570,"This PR adds areas, volumes, and a few product operators needed to evaluate correct Coriolis terms on curvilinear grids, following. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8. Before merging we should discuss:. - Should I update all the Coriolis terms? (`beta_plane.jl, non_traditional_f_plane.jl`, etc?); - Are we ok using three-letter codes, even though we only plan to support horizontally-curvilinear grids (rather than vertically curvilinear grids) in the near future?; - Should we add more regression tests / evaluate existing regression tests before changing terms that are not covered?; - It's not feasible to adapt the _entire_ codebase to work on curvilinear grids right now. How should we handle throwing errors for cases that are not supported? Adding `RegularCartesianGrid` annotations in key places seems like the easiest strategy, but we should be careful not to miss any. We can perhaps add annotations to _all_ operators, and then support curvilinearity in as parsimonious fashion as possible to be conservative.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1371
https://github.com/CliMA/Oceananigans.jl/pull/1373:295,Availability,down,download,295,"This PR implements a regression test framework for `HydrostaticFreeSurfaceModel`. This PR doesn't actually change any of the tests; it just adds a script. We'd like to put the regression test data somewhere else, like `OceananigansRegressionTests.jl` or something, and then use `DataDeps.jl` to download updated regression test data if need be. We can experiment with that workflow here. It'd be nice to get regression test data in before modifying any non-regression-tested operators to work on curvilinear grids.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1373
https://github.com/CliMA/Oceananigans.jl/pull/1373:304,Deployability,update,updated,304,"This PR implements a regression test framework for `HydrostaticFreeSurfaceModel`. This PR doesn't actually change any of the tests; it just adds a script. We'd like to put the regression test data somewhere else, like `OceananigansRegressionTests.jl` or something, and then use `DataDeps.jl` to download updated regression test data if need be. We can experiment with that workflow here. It'd be nice to get regression test data in before modifying any non-regression-tested operators to work on curvilinear grids.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1373
https://github.com/CliMA/Oceananigans.jl/pull/1373:32,Testability,test,test,32,"This PR implements a regression test framework for `HydrostaticFreeSurfaceModel`. This PR doesn't actually change any of the tests; it just adds a script. We'd like to put the regression test data somewhere else, like `OceananigansRegressionTests.jl` or something, and then use `DataDeps.jl` to download updated regression test data if need be. We can experiment with that workflow here. It'd be nice to get regression test data in before modifying any non-regression-tested operators to work on curvilinear grids.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1373
https://github.com/CliMA/Oceananigans.jl/pull/1373:125,Testability,test,tests,125,"This PR implements a regression test framework for `HydrostaticFreeSurfaceModel`. This PR doesn't actually change any of the tests; it just adds a script. We'd like to put the regression test data somewhere else, like `OceananigansRegressionTests.jl` or something, and then use `DataDeps.jl` to download updated regression test data if need be. We can experiment with that workflow here. It'd be nice to get regression test data in before modifying any non-regression-tested operators to work on curvilinear grids.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1373
https://github.com/CliMA/Oceananigans.jl/pull/1373:187,Testability,test,test,187,"This PR implements a regression test framework for `HydrostaticFreeSurfaceModel`. This PR doesn't actually change any of the tests; it just adds a script. We'd like to put the regression test data somewhere else, like `OceananigansRegressionTests.jl` or something, and then use `DataDeps.jl` to download updated regression test data if need be. We can experiment with that workflow here. It'd be nice to get regression test data in before modifying any non-regression-tested operators to work on curvilinear grids.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1373
https://github.com/CliMA/Oceananigans.jl/pull/1373:323,Testability,test,test,323,"This PR implements a regression test framework for `HydrostaticFreeSurfaceModel`. This PR doesn't actually change any of the tests; it just adds a script. We'd like to put the regression test data somewhere else, like `OceananigansRegressionTests.jl` or something, and then use `DataDeps.jl` to download updated regression test data if need be. We can experiment with that workflow here. It'd be nice to get regression test data in before modifying any non-regression-tested operators to work on curvilinear grids.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1373
https://github.com/CliMA/Oceananigans.jl/pull/1373:419,Testability,test,test,419,"This PR implements a regression test framework for `HydrostaticFreeSurfaceModel`. This PR doesn't actually change any of the tests; it just adds a script. We'd like to put the regression test data somewhere else, like `OceananigansRegressionTests.jl` or something, and then use `DataDeps.jl` to download updated regression test data if need be. We can experiment with that workflow here. It'd be nice to get regression test data in before modifying any non-regression-tested operators to work on curvilinear grids.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1373
https://github.com/CliMA/Oceananigans.jl/pull/1373:468,Testability,test,tested,468,"This PR implements a regression test framework for `HydrostaticFreeSurfaceModel`. This PR doesn't actually change any of the tests; it just adds a script. We'd like to put the regression test data somewhere else, like `OceananigansRegressionTests.jl` or something, and then use `DataDeps.jl` to download updated regression test data if need be. We can experiment with that workflow here. It'd be nice to get regression test data in before modifying any non-regression-tested operators to work on curvilinear grids.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1373
https://github.com/CliMA/Oceananigans.jl/pull/1374:128,Testability,test,test,128,This PR cleans up the horizontal divergence and vertical vorticity operators for horizontally-curvilinear grids. It also adds a test to ensure that `HydrostaticFreeSurfaceModel` continues to work with `momentum_advection=VectorInvariant()`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1374
https://github.com/CliMA/Oceananigans.jl/pull/1375:365,Energy Efficiency,energy,energy,365,"This PR adds a new turbulence closure called `HorizontalCurvilinearDiffusivity`, following section 2.15.7 in the MITgcm documentation:. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#horizontal-dissipation. There it is stated that this closure. > conserves potential vorticity (thickness weighted relative vorticity) and divergence and dissipates energy, enstrophy and divergence squared. The same details are not given for tracer diffusion, so I left the tracer diffusivity at zero for now. @christophernhill please advise. I also needed to add a few operators. I'm not sure where to put them since we have both ""closure_operators.jl"" and ""viscous_dissipation_operators.jl"". It might make sense to clean this up a bit in this PR --- @ali-ramadhan let me know what you think. To do:. - [x] Tracer diffusion valid on curvilinear grids; - [x] Some clean up of `TurbulenceClosures` module; - [x] Unit tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1375
https://github.com/CliMA/Oceananigans.jl/pull/1375:916,Testability,test,tests,916,"This PR adds a new turbulence closure called `HorizontalCurvilinearDiffusivity`, following section 2.15.7 in the MITgcm documentation:. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#horizontal-dissipation. There it is stated that this closure. > conserves potential vorticity (thickness weighted relative vorticity) and divergence and dissipates energy, enstrophy and divergence squared. The same details are not given for tracer diffusion, so I left the tracer diffusivity at zero for now. @christophernhill please advise. I also needed to add a few operators. I'm not sure where to put them since we have both ""closure_operators.jl"" and ""viscous_dissipation_operators.jl"". It might make sense to clean this up a bit in this PR --- @ali-ramadhan let me know what you think. To do:. - [x] Tracer diffusion valid on curvilinear grids; - [x] Some clean up of `TurbulenceClosures` module; - [x] Unit tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1375
https://github.com/CliMA/Oceananigans.jl/pull/1380:112,Testability,test,test,112,"This PR aims to add a regular lat-lon grid (i.e. with regularly spaced latitude and longitude lines), mainly to test all the new curvilinear operators. Final design TBD probably until PR #1375 is merged. Also gotta figure out the halo situation (probably quite similar to `RegularCartesianGrid`) and add some unit tests. The implementation is based on MITgcm's `ini_spherical_polar_grid.F`: https://github.com/MITgcm/MITgcm/blob/fc300b65987b52171b1110c7930f580ca71dead0/model/src/ini_spherical_polar_grid.F#L142-L151. Since Oceananigans.jl has always assumed rectilinear grids so far, I have kept some conventions like `Nx, Ny, Nz` instead of going for `Nλ, Nϕ, Nz`. I have made the assumption that the user will primarly be interested in the (latitude, longitude) of each grid point. So the grid stores e.g. Δλ and λᶠᵃᵃ instead of Δx and xᶠᵃᵃ. `RegularLatitudeLongitudeGrid` seems possible with very little memory as the grid spacings are cheap to compute, so I think we should try computing as much as we can on the fly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1380
https://github.com/CliMA/Oceananigans.jl/pull/1380:314,Testability,test,tests,314,"This PR aims to add a regular lat-lon grid (i.e. with regularly spaced latitude and longitude lines), mainly to test all the new curvilinear operators. Final design TBD probably until PR #1375 is merged. Also gotta figure out the halo situation (probably quite similar to `RegularCartesianGrid`) and add some unit tests. The implementation is based on MITgcm's `ini_spherical_polar_grid.F`: https://github.com/MITgcm/MITgcm/blob/fc300b65987b52171b1110c7930f580ca71dead0/model/src/ini_spherical_polar_grid.F#L142-L151. Since Oceananigans.jl has always assumed rectilinear grids so far, I have kept some conventions like `Nx, Ny, Nz` instead of going for `Nλ, Nϕ, Nz`. I have made the assumption that the user will primarly be interested in the (latitude, longitude) of each grid point. So the grid stores e.g. Δλ and λᶠᵃᵃ instead of Δx and xᶠᵃᵃ. `RegularLatitudeLongitudeGrid` seems possible with very little memory as the grid spacings are cheap to compute, so I think we should try computing as much as we can on the fly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1380
https://github.com/CliMA/Oceananigans.jl/issues/1381:711,Modifiability,refactor,refactoring,711,"A number of issues are accumulating with `TurbulenceClosures` that we need to address:. 1. #1277 (inconsistency between docs and storage of molecular diffusivity in eddy viscosity scratch array); 2. #1278 (unfortunate default diffusivities for IsotropicDiffusivity and some of the LES closure diffusivities); 3. #1279 (incorrect usage of the term ""biharmonic"", and also the fact that there is no true biharmonic diffusivity). A second annoying issue is the use of `model.diffusivities` as auxiliary space for the eddy diffusivities. Now that we know a bit more about using `adapt_structure`, we can readily put references to eddy diffusivities inside the LES closure objects themselves. Doing this will require refactoring the constructor for `IncompressibleModel`, unfortunately, because we'll need to define a function `regularize_turbulence_closure` so that we can build scratch space once we know what the `grid` is. I also think it's high time that we nuked `RozemaAnisotropicMinimumDissipation` and `BlasiusSmagorinsky`, and also eliminated the ""buoyancy modification"" term from `VerstappenAnisotropicMinimumDissipation`, since it doesn't actually work --- and because we have reason to believe that it may not actually improve the accuracy of the closure, even _if_ correctly implemented. Lastly, I think much of the code in `TurbulenceClosures` could be consolidated. I wanted to put this issue out there in case anyone is somehow using the Rozema version of AMD or Blasius version of Smagorinsky that I don't know about. These are not our most urgent priorities now, but after peeking into the turbulence closures module recently I think it'll be useful to gather all the various improvements we need into one issue.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1381
https://github.com/CliMA/Oceananigans.jl/pull/1384:10,Energy Efficiency,adapt,adapts,10,"~~This PR adapts `BetaPlane` coriolis implementation for curvilinear grids (following #1371 and [MITgcm docs](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8)).~~. ~~Note that the MITgcm docs specify averaging the Coriolis parameter / planetary vorticity (from corner / vorticity nodes, ffc, to the velocity nodes fcc and cfc). However, because the variation in the planetary vorticity is linear, I think the implementation in this PR is correct for beta planes? @jm-c please advise.~~. I would ~~also~~ like to add a Coriolis term valid for the sphere and hydrostatic models (which amounts to the ""traditional approximation""). ~~I'll do this once #1380 is merged.~~ This PR depends on #1380. Some feedback on what to call this object is certainly welcome! I have preliminary proposed ""`HydrostaticSphericalCoriolis` because it was the first silly thing I could think of. To do:. - [x] Add `HydrostaticSphericalCoriolis` plus unit tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384
https://github.com/CliMA/Oceananigans.jl/pull/1384:696,Integrability,depend,depends,696,"~~This PR adapts `BetaPlane` coriolis implementation for curvilinear grids (following #1371 and [MITgcm docs](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8)).~~. ~~Note that the MITgcm docs specify averaging the Coriolis parameter / planetary vorticity (from corner / vorticity nodes, ffc, to the velocity nodes fcc and cfc). However, because the variation in the planetary vorticity is linear, I think the implementation in this PR is correct for beta planes? @jm-c please advise.~~. I would ~~also~~ like to add a Coriolis term valid for the sphere and hydrostatic models (which amounts to the ""traditional approximation""). ~~I'll do this once #1380 is merged.~~ This PR depends on #1380. Some feedback on what to call this object is certainly welcome! I have preliminary proposed ""`HydrostaticSphericalCoriolis` because it was the first silly thing I could think of. To do:. - [x] Add `HydrostaticSphericalCoriolis` plus unit tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384
https://github.com/CliMA/Oceananigans.jl/pull/1384:10,Modifiability,adapt,adapts,10,"~~This PR adapts `BetaPlane` coriolis implementation for curvilinear grids (following #1371 and [MITgcm docs](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8)).~~. ~~Note that the MITgcm docs specify averaging the Coriolis parameter / planetary vorticity (from corner / vorticity nodes, ffc, to the velocity nodes fcc and cfc). However, because the variation in the planetary vorticity is linear, I think the implementation in this PR is correct for beta planes? @jm-c please advise.~~. I would ~~also~~ like to add a Coriolis term valid for the sphere and hydrostatic models (which amounts to the ""traditional approximation""). ~~I'll do this once #1380 is merged.~~ This PR depends on #1380. Some feedback on what to call this object is certainly welcome! I have preliminary proposed ""`HydrostaticSphericalCoriolis` because it was the first silly thing I could think of. To do:. - [x] Add `HydrostaticSphericalCoriolis` plus unit tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384
https://github.com/CliMA/Oceananigans.jl/pull/1384:952,Testability,test,tests,952,"~~This PR adapts `BetaPlane` coriolis implementation for curvilinear grids (following #1371 and [MITgcm docs](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8)).~~. ~~Note that the MITgcm docs specify averaging the Coriolis parameter / planetary vorticity (from corner / vorticity nodes, ffc, to the velocity nodes fcc and cfc). However, because the variation in the planetary vorticity is linear, I think the implementation in this PR is correct for beta planes? @jm-c please advise.~~. I would ~~also~~ like to add a Coriolis term valid for the sphere and hydrostatic models (which amounts to the ""traditional approximation""). ~~I'll do this once #1380 is merged.~~ This PR depends on #1380. Some feedback on what to call this object is certainly welcome! I have preliminary proposed ""`HydrostaticSphericalCoriolis` because it was the first silly thing I could think of. To do:. - [x] Add `HydrostaticSphericalCoriolis` plus unit tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384
https://github.com/CliMA/Oceananigans.jl/pull/1384:719,Usability,feedback,feedback,719,"~~This PR adapts `BetaPlane` coriolis implementation for curvilinear grids (following #1371 and [MITgcm docs](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8)).~~. ~~Note that the MITgcm docs specify averaging the Coriolis parameter / planetary vorticity (from corner / vorticity nodes, ffc, to the velocity nodes fcc and cfc). However, because the variation in the planetary vorticity is linear, I think the implementation in this PR is correct for beta planes? @jm-c please advise.~~. I would ~~also~~ like to add a Coriolis term valid for the sphere and hydrostatic models (which amounts to the ""traditional approximation""). ~~I'll do this once #1380 is merged.~~ This PR depends on #1380. Some feedback on what to call this object is certainly welcome! I have preliminary proposed ""`HydrostaticSphericalCoriolis` because it was the first silly thing I could think of. To do:. - [x] Add `HydrostaticSphericalCoriolis` plus unit tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384
https://github.com/CliMA/Oceananigans.jl/pull/1385:8,Deployability,update,updates,8,This PR updates the HydrostaticFreeSurfaceModel RHS kernel functions to use the correctly-located pressure gradient for curvilinear grids.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1385
https://github.com/CliMA/Oceananigans.jl/pull/1387:8,Testability,test,tests,8,This PR tests whether `push_previews` will work with buildkite using the latest version of Documenter.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1387
https://github.com/CliMA/Oceananigans.jl/pull/1388:93,Availability,checkpoint,checkpoint,93,"There have been 78 commits since the last release so I thought it would be good to put out a checkpoint release. Happy to close this PR if people think this is not necessary. Release notes could say:. Checkpoint release including very experimental support for curvilinear grids, a vertically-stretched rectilinear grid, and a preconditioned conjugate-gradient solver. (or nothing at all). There should be no breaking changes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1388
https://github.com/CliMA/Oceananigans.jl/pull/1388:201,Availability,Checkpoint,Checkpoint,201,"There have been 78 commits since the last release so I thought it would be good to put out a checkpoint release. Happy to close this PR if people think this is not necessary. Release notes could say:. Checkpoint release including very experimental support for curvilinear grids, a vertically-stretched rectilinear grid, and a preconditioned conjugate-gradient solver. (or nothing at all). There should be no breaking changes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1388
https://github.com/CliMA/Oceananigans.jl/pull/1388:42,Deployability,release,release,42,"There have been 78 commits since the last release so I thought it would be good to put out a checkpoint release. Happy to close this PR if people think this is not necessary. Release notes could say:. Checkpoint release including very experimental support for curvilinear grids, a vertically-stretched rectilinear grid, and a preconditioned conjugate-gradient solver. (or nothing at all). There should be no breaking changes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1388
https://github.com/CliMA/Oceananigans.jl/pull/1388:104,Deployability,release,release,104,"There have been 78 commits since the last release so I thought it would be good to put out a checkpoint release. Happy to close this PR if people think this is not necessary. Release notes could say:. Checkpoint release including very experimental support for curvilinear grids, a vertically-stretched rectilinear grid, and a preconditioned conjugate-gradient solver. (or nothing at all). There should be no breaking changes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1388
https://github.com/CliMA/Oceananigans.jl/pull/1388:175,Deployability,Release,Release,175,"There have been 78 commits since the last release so I thought it would be good to put out a checkpoint release. Happy to close this PR if people think this is not necessary. Release notes could say:. Checkpoint release including very experimental support for curvilinear grids, a vertically-stretched rectilinear grid, and a preconditioned conjugate-gradient solver. (or nothing at all). There should be no breaking changes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1388
https://github.com/CliMA/Oceananigans.jl/pull/1388:212,Deployability,release,release,212,"There have been 78 commits since the last release so I thought it would be good to put out a checkpoint release. Happy to close this PR if people think this is not necessary. Release notes could say:. Checkpoint release including very experimental support for curvilinear grids, a vertically-stretched rectilinear grid, and a preconditioned conjugate-gradient solver. (or nothing at all). There should be no breaking changes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1388
https://github.com/CliMA/Oceananigans.jl/pull/1389:279,Usability,Guid,Guide,279,This PR adds instructions for how a contributor can build the documentations locally and preview them. I was tempted to add some info about doc previews but I think doc previews are not generated for PR that come from forks so it's not a good idea to have it in the Contributors Guide.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1389
https://github.com/CliMA/Oceananigans.jl/pull/1390:148,Availability,error,errors,148,"I accidentally left a duplicate `include(""index_permutations.jl"")` when resolving some merge conflicts in PR #1348 which led to method redefinition errors. This PR should get rid of those errors.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1390
https://github.com/CliMA/Oceananigans.jl/pull/1390:188,Availability,error,errors,188,"I accidentally left a duplicate `include(""index_permutations.jl"")` when resolving some merge conflicts in PR #1348 which led to method redefinition errors. This PR should get rid of those errors.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1390
https://github.com/CliMA/Oceananigans.jl/issues/1392:563,Testability,test,tested,563,"Moving a discussion from the slack channel here. . Basically I think it would be useful to have a way to compute averages inside a subset of the domain. From what I get understand from the discussion there are two ways to do this:. - Allowing to pass something like a `FieldSlicer` to `AveragedField`, which would then slice the field before computing the average. This was my original idea, but according to @glwagner it might be tricky.; - Creating something like `WindowedSpatialAverage`, for this purpose specifically. @glwagner suggested something like (not tested):. ```julia; struct WindowedSpatialAverage{F, I, J, K, D}; field :: F; i :: I; j :: J; k :: K; dims :: D; end. WindowedSpatialAverage(field; dims, i=Colon(), j=Colon(), k=Colon()) = WindowedSpatialAverage(field, i, j, k, dims). function (wsa::WindowedSpatialAverage)(model); compute!(wsa.field); window = view(data(wsa.field), wsa.i, wsa.j, wsa.k); return mean(window, dims=wsa.dims); end; ```. CC: @glwagner @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392
https://github.com/CliMA/Oceananigans.jl/issues/1394:102,Modifiability,sandbox,sandbox,102,I suggest we convert the plankton example to use a vertically stretched grid. Then we can delete the `sandbox` directory from the repo. Also in the https://clima.github.io/OceananigansDocumentation/dev/model_setup/grids/ we should point the user to this example in the discussion (that doesn't exist yet?) about vertically stretched grid.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1394
https://github.com/CliMA/Oceananigans.jl/issues/1394:102,Testability,sandbox,sandbox,102,I suggest we convert the plankton example to use a vertically stretched grid. Then we can delete the `sandbox` directory from the repo. Also in the https://clima.github.io/OceananigansDocumentation/dev/model_setup/grids/ we should point the user to this example in the discussion (that doesn't exist yet?) about vertically stretched grid.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1394
https://github.com/CliMA/Oceananigans.jl/pull/1395:26,Modifiability,sandbox,sandbox,26,Sorry meant to delete the sandbox before merging PR #1348.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1395
https://github.com/CliMA/Oceananigans.jl/pull/1395:26,Testability,sandbox,sandbox,26,Sorry meant to delete the sandbox before merging PR #1348.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1395
https://github.com/CliMA/Oceananigans.jl/pull/1396:697,Availability,error,error,697,"This PR adds support for time step alignment and NetCDF output with `DateTime` (from `Base.Dates`) and `TimeDate` (from TimesDates.jl). Confusing names but `DateTime` is a base Julia type, has millisecond accuracy, and is understood by NCDatasets.jl while `TimeDate` comes from TimesDates.jl, has nanosecond accuracy, and must be converted to a `DateTime` to be written to NetCDF by NCDatasets.jl. Interestingly the way NetCDF stores dates and times is by storing a floating point value and some metadata describing it as e.g. ""seconds since 2000-01-01 00:00:00"". Could be minutes, hours, days, since 1900, etc. Not sure if we'll need the nanosecond accuracy but millisecond accuracy can cause an error on the order of a day after ~100 million iterations which could matter if used to compare Oceananigans.jl against ocean reanalysis products?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1396
https://github.com/CliMA/Oceananigans.jl/pull/1397:298,Modifiability,sandbox,sandbox,298,"Closes https://github.com/CliMA/Oceananigans.jl/issues/1392. CC: @glwagner @ali-ramadhan . Sorry that the issue I create went so long! I was doing a bunch of wrong things but in the end it was pretty straightforward. At this point all I have is a working example of `WindowedSpatialAverage` in the sandbox and I'm creating this PR for two reasons:. - Getting feedback on possible edge cases, and maybe figuring out how the `NetCDFOutput` can infer the dimensions correctly; - Figuring out where to include this; - This isn't necessarily attached to an `OutputWriter`, so it feels odd to add it there; - Everywhere else in Oceananigans also feels inappropriate ; - Maybe add it to Oceanostics?; . Anyway, feedback is appreciated. . Also, big thanks to @ali-ramadhan for helping me out with this one.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397
https://github.com/CliMA/Oceananigans.jl/pull/1397:298,Testability,sandbox,sandbox,298,"Closes https://github.com/CliMA/Oceananigans.jl/issues/1392. CC: @glwagner @ali-ramadhan . Sorry that the issue I create went so long! I was doing a bunch of wrong things but in the end it was pretty straightforward. At this point all I have is a working example of `WindowedSpatialAverage` in the sandbox and I'm creating this PR for two reasons:. - Getting feedback on possible edge cases, and maybe figuring out how the `NetCDFOutput` can infer the dimensions correctly; - Figuring out where to include this; - This isn't necessarily attached to an `OutputWriter`, so it feels odd to add it there; - Everywhere else in Oceananigans also feels inappropriate ; - Maybe add it to Oceanostics?; . Anyway, feedback is appreciated. . Also, big thanks to @ali-ramadhan for helping me out with this one.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397
https://github.com/CliMA/Oceananigans.jl/pull/1397:359,Usability,feedback,feedback,359,"Closes https://github.com/CliMA/Oceananigans.jl/issues/1392. CC: @glwagner @ali-ramadhan . Sorry that the issue I create went so long! I was doing a bunch of wrong things but in the end it was pretty straightforward. At this point all I have is a working example of `WindowedSpatialAverage` in the sandbox and I'm creating this PR for two reasons:. - Getting feedback on possible edge cases, and maybe figuring out how the `NetCDFOutput` can infer the dimensions correctly; - Figuring out where to include this; - This isn't necessarily attached to an `OutputWriter`, so it feels odd to add it there; - Everywhere else in Oceananigans also feels inappropriate ; - Maybe add it to Oceanostics?; . Anyway, feedback is appreciated. . Also, big thanks to @ali-ramadhan for helping me out with this one.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397
https://github.com/CliMA/Oceananigans.jl/pull/1397:704,Usability,feedback,feedback,704,"Closes https://github.com/CliMA/Oceananigans.jl/issues/1392. CC: @glwagner @ali-ramadhan . Sorry that the issue I create went so long! I was doing a bunch of wrong things but in the end it was pretty straightforward. At this point all I have is a working example of `WindowedSpatialAverage` in the sandbox and I'm creating this PR for two reasons:. - Getting feedback on possible edge cases, and maybe figuring out how the `NetCDFOutput` can infer the dimensions correctly; - Figuring out where to include this; - This isn't necessarily attached to an `OutputWriter`, so it feels odd to add it there; - Everywhere else in Oceananigans also feels inappropriate ; - Maybe add it to Oceanostics?; . Anyway, feedback is appreciated. . Also, big thanks to @ali-ramadhan for helping me out with this one.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397
https://github.com/CliMA/Oceananigans.jl/pull/1399:442,Security,validat,validating,442,"This PR makes a number of bug fixes needed to time step `HydrostaticFreeSurfaceModel` with a `RegularLatitudeLongitudeGrid`, and adds an experimental ""spherical splash"" example that uses Makie to visualize the solution on the surface of a the sphere:. https://user-images.githubusercontent.com/15271942/109041650-4553e080-769d-11eb-8c05-b169cba87153.mp4. Everything is still experimental, but we need these tools (and bug fixes) to set about validating our curvilinear finite volume numerics implementation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1399
https://github.com/CliMA/Oceananigans.jl/issues/1400:761,Integrability,interface,interface,761,"Oceananigans formally uses a finite volume spatial discretization, which means that all boundary conditions amount to a specification (or a model) for the flux of a quantity across the boundary. We use a central approximation to estimate fluxes due to Neumann or Dirichlet boundary conditions. When fluxes are specified directly by the user (via the `Flux` boundary condition type), we take two steps:. 1. Fill halo regions so that the solution is reflected across the boundary. This ensures that boundary fluxes evaluated while the tendency kernel is evaluated in every cell in the domain are zero, due to two assumptions:; - Advective fluxes across the boundary are zero.; - All turbulence closures have the property that the diffusive flux is zero across an interface if odd derivatives of the solution are zero at the interface.; 2. We ""manually"" add user-specified fluxes to each boundary-adjacent cell. Two major limitations of this method are:. 1. We cannot support turbulence closures that do not impose zero boundary diffusive fluxes when the solution is symmetric across the boundary (one example is true biharmonic diffusion, which is why we only support hyper diffusion at the moment, see #1279). ; 2. This algorithm does not easily generalize to irregular coastlines and bathymetry. I think we should come up with an alternative algorithm that better generalizes to biharmonic diffusion and irregular coastlines. If we limit ourselves to impenetrable boundaries (a reasonable limitation I think) then the needed features are all in the `TurbulenceClosures` module. In particular, I think we need to formalize the use of `diffusive_flux_x`, `diffusive_flux_y` and `diffusive_flux_z` for tracers (and corresponding functions for momentum). With these functions in hand for all `TurbulenceClosures`, we can then write an algorithm that. 1. Either does not fill halo regions or fills them in some trivial manner.; 2. Calculates the tendencies at every point, except for fluxes across boundari",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1400
https://github.com/CliMA/Oceananigans.jl/issues/1400:822,Integrability,interface,interface,822,"Oceananigans formally uses a finite volume spatial discretization, which means that all boundary conditions amount to a specification (or a model) for the flux of a quantity across the boundary. We use a central approximation to estimate fluxes due to Neumann or Dirichlet boundary conditions. When fluxes are specified directly by the user (via the `Flux` boundary condition type), we take two steps:. 1. Fill halo regions so that the solution is reflected across the boundary. This ensures that boundary fluxes evaluated while the tendency kernel is evaluated in every cell in the domain are zero, due to two assumptions:; - Advective fluxes across the boundary are zero.; - All turbulence closures have the property that the diffusive flux is zero across an interface if odd derivatives of the solution are zero at the interface.; 2. We ""manually"" add user-specified fluxes to each boundary-adjacent cell. Two major limitations of this method are:. 1. We cannot support turbulence closures that do not impose zero boundary diffusive fluxes when the solution is symmetric across the boundary (one example is true biharmonic diffusion, which is why we only support hyper diffusion at the moment, see #1279). ; 2. This algorithm does not easily generalize to irregular coastlines and bathymetry. I think we should come up with an alternative algorithm that better generalizes to biharmonic diffusion and irregular coastlines. If we limit ourselves to impenetrable boundaries (a reasonable limitation I think) then the needed features are all in the `TurbulenceClosures` module. In particular, I think we need to formalize the use of `diffusive_flux_x`, `diffusive_flux_y` and `diffusive_flux_z` for tracers (and corresponding functions for momentum). With these functions in hand for all `TurbulenceClosures`, we can then write an algorithm that. 1. Either does not fill halo regions or fills them in some trivial manner.; 2. Calculates the tendencies at every point, except for fluxes across boundari",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1400
https://github.com/CliMA/Oceananigans.jl/issues/1401:4874,Modifiability,variab,variables,4874,", :, 8] =; -0.0260201 -0.0147839 -0.00890929 -0.00551279 -0.00345117 -0.00217171 -0.00136973 … -0.00250611 -0.00396347 -0.00628301 -0.0100122 -0.0161434 -0.0267292 -0.0469493. julia> interior(dwpdz); 1×512×8 view(OffsetArray(::Array{Float64,3}, 0:2, 0:513, 0:9), 1:1, 1:512, 1:8) with eltype Float64:; [:, :, 1] =; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 … 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 … 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. [:, :, 3] =; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 … 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. [:, :, 4] =; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 … 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. [:, :, 5] =; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 … 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. [:, :, 6] =; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 … 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. [:, :, 7] =; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 … 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0. [:, :, 8] =; 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 … 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0; ```. Am I missing something here? Is computation for pressure somehow different from other variables?. Notes:. - If I replace `p = sum(model.pressures)` for `p = model.pressures.pNHS` the result is the same.; - If I calculate instead just the `w * p` term in the kernel the result is correct! So apparently it has to do with the derivative of the pressure, not just the pressure itself.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401
https://github.com/CliMA/Oceananigans.jl/pull/1404:610,Availability,error,error,610,"This PR makes a few bugfixes and improvments:. 1. Fixes a bug for `VectorInvariantEnstrophyConserving` Coriolis scheme for `HydrostaticSphericalCoriolis`; 2. Edits tracer advection operators so they run on curvilinear grids; 3. Adds `validation/solid_body_rotation/` based on [Williamson et al. 1992](https://www.sciencedirect.com/science/article/pii/S0021999105800166). This PR also attempted to add a tracer advection test (using the solid body rotation solution), but this test fails. So we have some work to do to get tracer advection to work still. It'd be nice to implement some quantitative measures of error for the solid body rotation test before merging. Here's a movie that illustrates what the solid body rotation test does (showing incorrect tracer advection):. https://user-images.githubusercontent.com/15271942/109338288-0c9a3f80-7834-11eb-8189-9137cec2cd92.mp4. As a side note, it would be extremely useful to have a utility that computes a height field satisfying discrete geostrophic balance with some flow + Coriolis implementation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404
https://github.com/CliMA/Oceananigans.jl/pull/1404:234,Security,validat,validation,234,"This PR makes a few bugfixes and improvments:. 1. Fixes a bug for `VectorInvariantEnstrophyConserving` Coriolis scheme for `HydrostaticSphericalCoriolis`; 2. Edits tracer advection operators so they run on curvilinear grids; 3. Adds `validation/solid_body_rotation/` based on [Williamson et al. 1992](https://www.sciencedirect.com/science/article/pii/S0021999105800166). This PR also attempted to add a tracer advection test (using the solid body rotation solution), but this test fails. So we have some work to do to get tracer advection to work still. It'd be nice to implement some quantitative measures of error for the solid body rotation test before merging. Here's a movie that illustrates what the solid body rotation test does (showing incorrect tracer advection):. https://user-images.githubusercontent.com/15271942/109338288-0c9a3f80-7834-11eb-8189-9137cec2cd92.mp4. As a side note, it would be extremely useful to have a utility that computes a height field satisfying discrete geostrophic balance with some flow + Coriolis implementation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404
https://github.com/CliMA/Oceananigans.jl/pull/1404:420,Testability,test,test,420,"This PR makes a few bugfixes and improvments:. 1. Fixes a bug for `VectorInvariantEnstrophyConserving` Coriolis scheme for `HydrostaticSphericalCoriolis`; 2. Edits tracer advection operators so they run on curvilinear grids; 3. Adds `validation/solid_body_rotation/` based on [Williamson et al. 1992](https://www.sciencedirect.com/science/article/pii/S0021999105800166). This PR also attempted to add a tracer advection test (using the solid body rotation solution), but this test fails. So we have some work to do to get tracer advection to work still. It'd be nice to implement some quantitative measures of error for the solid body rotation test before merging. Here's a movie that illustrates what the solid body rotation test does (showing incorrect tracer advection):. https://user-images.githubusercontent.com/15271942/109338288-0c9a3f80-7834-11eb-8189-9137cec2cd92.mp4. As a side note, it would be extremely useful to have a utility that computes a height field satisfying discrete geostrophic balance with some flow + Coriolis implementation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404
https://github.com/CliMA/Oceananigans.jl/pull/1404:476,Testability,test,test,476,"This PR makes a few bugfixes and improvments:. 1. Fixes a bug for `VectorInvariantEnstrophyConserving` Coriolis scheme for `HydrostaticSphericalCoriolis`; 2. Edits tracer advection operators so they run on curvilinear grids; 3. Adds `validation/solid_body_rotation/` based on [Williamson et al. 1992](https://www.sciencedirect.com/science/article/pii/S0021999105800166). This PR also attempted to add a tracer advection test (using the solid body rotation solution), but this test fails. So we have some work to do to get tracer advection to work still. It'd be nice to implement some quantitative measures of error for the solid body rotation test before merging. Here's a movie that illustrates what the solid body rotation test does (showing incorrect tracer advection):. https://user-images.githubusercontent.com/15271942/109338288-0c9a3f80-7834-11eb-8189-9137cec2cd92.mp4. As a side note, it would be extremely useful to have a utility that computes a height field satisfying discrete geostrophic balance with some flow + Coriolis implementation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404
https://github.com/CliMA/Oceananigans.jl/pull/1404:644,Testability,test,test,644,"This PR makes a few bugfixes and improvments:. 1. Fixes a bug for `VectorInvariantEnstrophyConserving` Coriolis scheme for `HydrostaticSphericalCoriolis`; 2. Edits tracer advection operators so they run on curvilinear grids; 3. Adds `validation/solid_body_rotation/` based on [Williamson et al. 1992](https://www.sciencedirect.com/science/article/pii/S0021999105800166). This PR also attempted to add a tracer advection test (using the solid body rotation solution), but this test fails. So we have some work to do to get tracer advection to work still. It'd be nice to implement some quantitative measures of error for the solid body rotation test before merging. Here's a movie that illustrates what the solid body rotation test does (showing incorrect tracer advection):. https://user-images.githubusercontent.com/15271942/109338288-0c9a3f80-7834-11eb-8189-9137cec2cd92.mp4. As a side note, it would be extremely useful to have a utility that computes a height field satisfying discrete geostrophic balance with some flow + Coriolis implementation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404
https://github.com/CliMA/Oceananigans.jl/pull/1404:726,Testability,test,test,726,"This PR makes a few bugfixes and improvments:. 1. Fixes a bug for `VectorInvariantEnstrophyConserving` Coriolis scheme for `HydrostaticSphericalCoriolis`; 2. Edits tracer advection operators so they run on curvilinear grids; 3. Adds `validation/solid_body_rotation/` based on [Williamson et al. 1992](https://www.sciencedirect.com/science/article/pii/S0021999105800166). This PR also attempted to add a tracer advection test (using the solid body rotation solution), but this test fails. So we have some work to do to get tracer advection to work still. It'd be nice to implement some quantitative measures of error for the solid body rotation test before merging. Here's a movie that illustrates what the solid body rotation test does (showing incorrect tracer advection):. https://user-images.githubusercontent.com/15271942/109338288-0c9a3f80-7834-11eb-8189-9137cec2cd92.mp4. As a side note, it would be extremely useful to have a utility that computes a height field satisfying discrete geostrophic balance with some flow + Coriolis implementation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1404
https://github.com/CliMA/Oceananigans.jl/issues/1405:1014,Availability,error,error,1014,"Take the 1D diffusion example: https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/. This is the plotting code:. ```julia; using JLD2. file = jldopen(simulation.output_writers[:temperature].filepath). iterations = parse.(Int, keys(file[""timeseries/t""])). anim = @animate for (i, iter) in enumerate(iterations). T = file[""timeseries/T/$iter""][1, 1, :]; t = file[""timeseries/t/$iter""]. plot(T, z, linewidth=2, title=@sprintf(""t = %.3f"", t),; label="""", xlabel=""Temperature"", ylabel=""z"", xlims=(0, 1)); end; ```. But where did `z` come from? From `z = znodes(model.tracers.T)` some lines above. But what if I want to plot in a separate script? Or what if I run my simulation on a cluster and want to plot some data on a different machine?. One solution would be to use `z = file[""grid/zC""]`. However, users may be surprised to learn that this output is not sliced and includes halos though (https://github.com/CliMA/Oceananigans.jl/issues/1194) so many plotting libraries will error because of some dimension mismatch. So if you don't have access to the `grid` then you can't plot the coordinates correctly without wrangling with `file[""grid""]` (which requires users to know about halos). And users may want to plot using other programming languages and libraries/programs where you can't get access to an Oceananigans grid. ---. I guess I'm advocating for plotting without using any Oceananigans functions to make the examples more useful for users. We can make the plotting code more local which would make it more copy-paste-able for users (more user friendly).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1405
https://github.com/CliMA/Oceananigans.jl/issues/1405:1077,Security,access,access,1077,"Take the 1D diffusion example: https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/. This is the plotting code:. ```julia; using JLD2. file = jldopen(simulation.output_writers[:temperature].filepath). iterations = parse.(Int, keys(file[""timeseries/t""])). anim = @animate for (i, iter) in enumerate(iterations). T = file[""timeseries/T/$iter""][1, 1, :]; t = file[""timeseries/t/$iter""]. plot(T, z, linewidth=2, title=@sprintf(""t = %.3f"", t),; label="""", xlabel=""Temperature"", ylabel=""z"", xlims=(0, 1)); end; ```. But where did `z` come from? From `z = znodes(model.tracers.T)` some lines above. But what if I want to plot in a separate script? Or what if I run my simulation on a cluster and want to plot some data on a different machine?. One solution would be to use `z = file[""grid/zC""]`. However, users may be surprised to learn that this output is not sliced and includes halos though (https://github.com/CliMA/Oceananigans.jl/issues/1194) so many plotting libraries will error because of some dimension mismatch. So if you don't have access to the `grid` then you can't plot the coordinates correctly without wrangling with `file[""grid""]` (which requires users to know about halos). And users may want to plot using other programming languages and libraries/programs where you can't get access to an Oceananigans grid. ---. I guess I'm advocating for plotting without using any Oceananigans functions to make the examples more useful for users. We can make the plotting code more local which would make it more copy-paste-able for users (more user friendly).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1405
https://github.com/CliMA/Oceananigans.jl/issues/1405:1330,Security,access,access,1330,"Take the 1D diffusion example: https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/. This is the plotting code:. ```julia; using JLD2. file = jldopen(simulation.output_writers[:temperature].filepath). iterations = parse.(Int, keys(file[""timeseries/t""])). anim = @animate for (i, iter) in enumerate(iterations). T = file[""timeseries/T/$iter""][1, 1, :]; t = file[""timeseries/t/$iter""]. plot(T, z, linewidth=2, title=@sprintf(""t = %.3f"", t),; label="""", xlabel=""Temperature"", ylabel=""z"", xlims=(0, 1)); end; ```. But where did `z` come from? From `z = znodes(model.tracers.T)` some lines above. But what if I want to plot in a separate script? Or what if I run my simulation on a cluster and want to plot some data on a different machine?. One solution would be to use `z = file[""grid/zC""]`. However, users may be surprised to learn that this output is not sliced and includes halos though (https://github.com/CliMA/Oceananigans.jl/issues/1194) so many plotting libraries will error because of some dimension mismatch. So if you don't have access to the `grid` then you can't plot the coordinates correctly without wrangling with `file[""grid""]` (which requires users to know about halos). And users may want to plot using other programming languages and libraries/programs where you can't get access to an Oceananigans grid. ---. I guess I'm advocating for plotting without using any Oceananigans functions to make the examples more useful for users. We can make the plotting code more local which would make it more copy-paste-able for users (more user friendly).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1405
https://github.com/CliMA/Oceananigans.jl/issues/1405:864,Usability,learn,learn,864,"Take the 1D diffusion example: https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/. This is the plotting code:. ```julia; using JLD2. file = jldopen(simulation.output_writers[:temperature].filepath). iterations = parse.(Int, keys(file[""timeseries/t""])). anim = @animate for (i, iter) in enumerate(iterations). T = file[""timeseries/T/$iter""][1, 1, :]; t = file[""timeseries/t/$iter""]. plot(T, z, linewidth=2, title=@sprintf(""t = %.3f"", t),; label="""", xlabel=""Temperature"", ylabel=""z"", xlims=(0, 1)); end; ```. But where did `z` come from? From `z = znodes(model.tracers.T)` some lines above. But what if I want to plot in a separate script? Or what if I run my simulation on a cluster and want to plot some data on a different machine?. One solution would be to use `z = file[""grid/zC""]`. However, users may be surprised to learn that this output is not sliced and includes halos though (https://github.com/CliMA/Oceananigans.jl/issues/1194) so many plotting libraries will error because of some dimension mismatch. So if you don't have access to the `grid` then you can't plot the coordinates correctly without wrangling with `file[""grid""]` (which requires users to know about halos). And users may want to plot using other programming languages and libraries/programs where you can't get access to an Oceananigans grid. ---. I guess I'm advocating for plotting without using any Oceananigans functions to make the examples more useful for users. We can make the plotting code more local which would make it more copy-paste-able for users (more user friendly).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1405
https://github.com/CliMA/Oceananigans.jl/pull/1406:259,Availability,error,errors,259,"This PR ensures enough things are exported by Oceananigans that all the examples can get by with just `using Oceananigans`. The purpose of this PR is to make the package more user friendly as missing names, e.g. `ComputedField`, have become a large source of errors for new users. As this is a large change to the user interface, I've bumped v0.52.0. Resolves #1075; Resolves #1131; Resolves #1132",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1406
https://github.com/CliMA/Oceananigans.jl/pull/1406:319,Integrability,interface,interface,319,"This PR ensures enough things are exported by Oceananigans that all the examples can get by with just `using Oceananigans`. The purpose of this PR is to make the package more user friendly as missing names, e.g. `ComputedField`, have become a large source of errors for new users. As this is a large change to the user interface, I've bumped v0.52.0. Resolves #1075; Resolves #1131; Resolves #1132",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1406
https://github.com/CliMA/Oceananigans.jl/pull/1412:319,Integrability,interface,interface,319,"This PR defines `minimum`, `maximum`, and `mean` for Oceananigans fields (not including halo points)!. I also originally added `extrema` but CUDA.jl actually doesn't support `extrema(::CuArray)` yet. This has been always a source of CUDA scalar operations, especially for new users so I think this PR improves the user interface as it returns the answer users expect (without any CUDA scalar operations). Note: This PR removes the `FieldMaximum` diagnostic and removes the sugary `mean(::Field)` function, so it's a breaking change. Resolves #1117",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1412
https://github.com/CliMA/Oceananigans.jl/pull/1415:482,Modifiability,refactor,refactored,482,"This PR adds tests for `RegularLatitudeLongitudeGrid` which uncovered a couple of stupid bugs in the process. Sorry everyone. I guess we shouldn't be approving important PRs without tests in the future. I've somehow convinced myself that we need `Nλ + 2Hλ + 1` grid points in longitude even when it's periodic (tests don't pass otherwise), but not sure why so maybe let's hold off on merging just yet. This PR should fix things in PR #1404. Also, I didn't like `test_grids.jl` so I refactored it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1415
https://github.com/CliMA/Oceananigans.jl/pull/1415:13,Testability,test,tests,13,"This PR adds tests for `RegularLatitudeLongitudeGrid` which uncovered a couple of stupid bugs in the process. Sorry everyone. I guess we shouldn't be approving important PRs without tests in the future. I've somehow convinced myself that we need `Nλ + 2Hλ + 1` grid points in longitude even when it's periodic (tests don't pass otherwise), but not sure why so maybe let's hold off on merging just yet. This PR should fix things in PR #1404. Also, I didn't like `test_grids.jl` so I refactored it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1415
https://github.com/CliMA/Oceananigans.jl/pull/1415:182,Testability,test,tests,182,"This PR adds tests for `RegularLatitudeLongitudeGrid` which uncovered a couple of stupid bugs in the process. Sorry everyone. I guess we shouldn't be approving important PRs without tests in the future. I've somehow convinced myself that we need `Nλ + 2Hλ + 1` grid points in longitude even when it's periodic (tests don't pass otherwise), but not sure why so maybe let's hold off on merging just yet. This PR should fix things in PR #1404. Also, I didn't like `test_grids.jl` so I refactored it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1415
https://github.com/CliMA/Oceananigans.jl/pull/1415:311,Testability,test,tests,311,"This PR adds tests for `RegularLatitudeLongitudeGrid` which uncovered a couple of stupid bugs in the process. Sorry everyone. I guess we shouldn't be approving important PRs without tests in the future. I've somehow convinced myself that we need `Nλ + 2Hλ + 1` grid points in longitude even when it's periodic (tests don't pass otherwise), but not sure why so maybe let's hold off on merging just yet. This PR should fix things in PR #1404. Also, I didn't like `test_grids.jl` so I refactored it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1415
https://github.com/CliMA/Oceananigans.jl/pull/1417:198,Modifiability,flexible,flexible,198,"This PR uses https://github.com/CliMA/CubedSphere.jl to add grids and fields for the conformal cubed sphere (both a grid for representing one face and for the full cubed sphere). I tried to keep it flexible so that we can do things on only one face, a portion of a face, multiple faces, and can rotate the faces any way in case we want to put the corners on land, etc. This PR is still a work-in-progress. Need to add a `fill_halo_regions!` function and add more tests! Also need to figure out how to compute grid spacings and areas... Originally I wasn't sure how to organize everything so I'm doing everything in a `sandbox` for now. Might also be cool to maybe produce some visualizations for the docs. ![image](https://user-images.githubusercontent.com/20099589/109649608-284e6000-7b2a-11eb-9c67-0ca5bf0d26e5.png). Looking kinda cramped at those corners. ![image](https://user-images.githubusercontent.com/20099589/109650065-b6c2e180-7b2a-11eb-8aa9-f5c8064858ed.png). Unfortunately I had plotting issues with GeoMakie.jl (e.g. https://github.com/JuliaPlots/GeoMakie.jl/issues/55) which is not being maintained right now, so I went back to using matplotlib + cartopy for plotting on maps with projections. ![cubed_sphere_points](https://user-images.githubusercontent.com/20099589/109649281-afe79f00-7b29-11eb-87bf-aa3fe3192cca.png). ![cubed_sphere_staggered_grid](https://user-images.githubusercontent.com/20099589/109649284-b118cc00-7b29-11eb-955f-49ce81cfa3a8.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417
https://github.com/CliMA/Oceananigans.jl/pull/1417:618,Modifiability,sandbox,sandbox,618,"This PR uses https://github.com/CliMA/CubedSphere.jl to add grids and fields for the conformal cubed sphere (both a grid for representing one face and for the full cubed sphere). I tried to keep it flexible so that we can do things on only one face, a portion of a face, multiple faces, and can rotate the faces any way in case we want to put the corners on land, etc. This PR is still a work-in-progress. Need to add a `fill_halo_regions!` function and add more tests! Also need to figure out how to compute grid spacings and areas... Originally I wasn't sure how to organize everything so I'm doing everything in a `sandbox` for now. Might also be cool to maybe produce some visualizations for the docs. ![image](https://user-images.githubusercontent.com/20099589/109649608-284e6000-7b2a-11eb-9c67-0ca5bf0d26e5.png). Looking kinda cramped at those corners. ![image](https://user-images.githubusercontent.com/20099589/109650065-b6c2e180-7b2a-11eb-8aa9-f5c8064858ed.png). Unfortunately I had plotting issues with GeoMakie.jl (e.g. https://github.com/JuliaPlots/GeoMakie.jl/issues/55) which is not being maintained right now, so I went back to using matplotlib + cartopy for plotting on maps with projections. ![cubed_sphere_points](https://user-images.githubusercontent.com/20099589/109649281-afe79f00-7b29-11eb-87bf-aa3fe3192cca.png). ![cubed_sphere_staggered_grid](https://user-images.githubusercontent.com/20099589/109649284-b118cc00-7b29-11eb-955f-49ce81cfa3a8.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417
https://github.com/CliMA/Oceananigans.jl/pull/1417:463,Testability,test,tests,463,"This PR uses https://github.com/CliMA/CubedSphere.jl to add grids and fields for the conformal cubed sphere (both a grid for representing one face and for the full cubed sphere). I tried to keep it flexible so that we can do things on only one face, a portion of a face, multiple faces, and can rotate the faces any way in case we want to put the corners on land, etc. This PR is still a work-in-progress. Need to add a `fill_halo_regions!` function and add more tests! Also need to figure out how to compute grid spacings and areas... Originally I wasn't sure how to organize everything so I'm doing everything in a `sandbox` for now. Might also be cool to maybe produce some visualizations for the docs. ![image](https://user-images.githubusercontent.com/20099589/109649608-284e6000-7b2a-11eb-9c67-0ca5bf0d26e5.png). Looking kinda cramped at those corners. ![image](https://user-images.githubusercontent.com/20099589/109650065-b6c2e180-7b2a-11eb-8aa9-f5c8064858ed.png). Unfortunately I had plotting issues with GeoMakie.jl (e.g. https://github.com/JuliaPlots/GeoMakie.jl/issues/55) which is not being maintained right now, so I went back to using matplotlib + cartopy for plotting on maps with projections. ![cubed_sphere_points](https://user-images.githubusercontent.com/20099589/109649281-afe79f00-7b29-11eb-87bf-aa3fe3192cca.png). ![cubed_sphere_staggered_grid](https://user-images.githubusercontent.com/20099589/109649284-b118cc00-7b29-11eb-955f-49ce81cfa3a8.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417
https://github.com/CliMA/Oceananigans.jl/pull/1417:618,Testability,sandbox,sandbox,618,"This PR uses https://github.com/CliMA/CubedSphere.jl to add grids and fields for the conformal cubed sphere (both a grid for representing one face and for the full cubed sphere). I tried to keep it flexible so that we can do things on only one face, a portion of a face, multiple faces, and can rotate the faces any way in case we want to put the corners on land, etc. This PR is still a work-in-progress. Need to add a `fill_halo_regions!` function and add more tests! Also need to figure out how to compute grid spacings and areas... Originally I wasn't sure how to organize everything so I'm doing everything in a `sandbox` for now. Might also be cool to maybe produce some visualizations for the docs. ![image](https://user-images.githubusercontent.com/20099589/109649608-284e6000-7b2a-11eb-9c67-0ca5bf0d26e5.png). Looking kinda cramped at those corners. ![image](https://user-images.githubusercontent.com/20099589/109650065-b6c2e180-7b2a-11eb-8aa9-f5c8064858ed.png). Unfortunately I had plotting issues with GeoMakie.jl (e.g. https://github.com/JuliaPlots/GeoMakie.jl/issues/55) which is not being maintained right now, so I went back to using matplotlib + cartopy for plotting on maps with projections. ![cubed_sphere_points](https://user-images.githubusercontent.com/20099589/109649281-afe79f00-7b29-11eb-87bf-aa3fe3192cca.png). ![cubed_sphere_staggered_grid](https://user-images.githubusercontent.com/20099589/109649284-b118cc00-7b29-11eb-955f-49ce81cfa3a8.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417
https://github.com/CliMA/Oceananigans.jl/pull/1418:108,Testability,test,tests,108,"This adds current implicit free surface code so we can discuss tidying and also tweak setups, agree on unit tests etc... Code runs with geostrophic adjust test e.g. this movie shows the implicit free surface v fully explicit approach for a small timestep. https://user-images.githubusercontent.com/3535328/109848197-fcaca200-7c1d-11eb-96fa-a3e1e4400162.mp4. as expected the implicit free surface damps waves slightly, but otherwise works the same. . Note - this needs some changes to bring in sync with spatial varying operators. It also has some extra grid terms that might be better in grid/operators somewhere etc...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1418
https://github.com/CliMA/Oceananigans.jl/pull/1418:155,Testability,test,test,155,"This adds current implicit free surface code so we can discuss tidying and also tweak setups, agree on unit tests etc... Code runs with geostrophic adjust test e.g. this movie shows the implicit free surface v fully explicit approach for a small timestep. https://user-images.githubusercontent.com/3535328/109848197-fcaca200-7c1d-11eb-96fa-a3e1e4400162.mp4. as expected the implicit free surface damps waves slightly, but otherwise works the same. . Note - this needs some changes to bring in sync with spatial varying operators. It also has some extra grid terms that might be better in grid/operators somewhere etc...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1418
https://github.com/CliMA/Oceananigans.jl/issues/1420:373,Energy Efficiency,reduce,reduce,373,Most of the convergence tests run in a reasonable amount of time except for a few:. For example: https://buildkite.com/clima/oceananigans-validation-experiments/builds/137. * CPU Gaussian advection-diffusion: ~2:40 hours; * GPU Gaussian advection-diffusion: ~1:45 hours; * CPU forced flow free-slip: ~8 hours. I think for the Gaussian advection-diffusion tests we can just reduce the number of iterations. Some tests run for 26214 iterations. Not sure why the CPU forced flow free-slip is so slow though. It's a 2D simulation. The CPU forced flow fixed-slip is similar I think and takes only ~20 minutes.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1420
https://github.com/CliMA/Oceananigans.jl/issues/1420:138,Security,validat,validation-experiments,138,Most of the convergence tests run in a reasonable amount of time except for a few:. For example: https://buildkite.com/clima/oceananigans-validation-experiments/builds/137. * CPU Gaussian advection-diffusion: ~2:40 hours; * GPU Gaussian advection-diffusion: ~1:45 hours; * CPU forced flow free-slip: ~8 hours. I think for the Gaussian advection-diffusion tests we can just reduce the number of iterations. Some tests run for 26214 iterations. Not sure why the CPU forced flow free-slip is so slow though. It's a 2D simulation. The CPU forced flow fixed-slip is similar I think and takes only ~20 minutes.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1420
https://github.com/CliMA/Oceananigans.jl/issues/1420:24,Testability,test,tests,24,Most of the convergence tests run in a reasonable amount of time except for a few:. For example: https://buildkite.com/clima/oceananigans-validation-experiments/builds/137. * CPU Gaussian advection-diffusion: ~2:40 hours; * GPU Gaussian advection-diffusion: ~1:45 hours; * CPU forced flow free-slip: ~8 hours. I think for the Gaussian advection-diffusion tests we can just reduce the number of iterations. Some tests run for 26214 iterations. Not sure why the CPU forced flow free-slip is so slow though. It's a 2D simulation. The CPU forced flow fixed-slip is similar I think and takes only ~20 minutes.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1420
https://github.com/CliMA/Oceananigans.jl/issues/1420:355,Testability,test,tests,355,Most of the convergence tests run in a reasonable amount of time except for a few:. For example: https://buildkite.com/clima/oceananigans-validation-experiments/builds/137. * CPU Gaussian advection-diffusion: ~2:40 hours; * GPU Gaussian advection-diffusion: ~1:45 hours; * CPU forced flow free-slip: ~8 hours. I think for the Gaussian advection-diffusion tests we can just reduce the number of iterations. Some tests run for 26214 iterations. Not sure why the CPU forced flow free-slip is so slow though. It's a 2D simulation. The CPU forced flow fixed-slip is similar I think and takes only ~20 minutes.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1420
https://github.com/CliMA/Oceananigans.jl/issues/1420:411,Testability,test,tests,411,Most of the convergence tests run in a reasonable amount of time except for a few:. For example: https://buildkite.com/clima/oceananigans-validation-experiments/builds/137. * CPU Gaussian advection-diffusion: ~2:40 hours; * GPU Gaussian advection-diffusion: ~1:45 hours; * CPU forced flow free-slip: ~8 hours. I think for the Gaussian advection-diffusion tests we can just reduce the number of iterations. Some tests run for 26214 iterations. Not sure why the CPU forced flow free-slip is so slow though. It's a 2D simulation. The CPU forced flow fixed-slip is similar I think and takes only ~20 minutes.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1420
https://github.com/CliMA/Oceananigans.jl/issues/1421:194,Usability,clear,clearer,194,"Oceanangans.jl v0.51.0 changed the NetCDF time attribute from. ```julia; Dict(""longname"" => ""Time"", ""units"" => ""s""); ```. to. ```julia; Dict(""longname"" => ""Time"", ""units"" => ""seconds"") # seemed clearer to me.; ```. so now some packages such as xarray decode the time dimension as a `timedelta` instead of just a plain floating-point number. Old behavior can be reproduced via the `decode_times=False` kwarg for [`xarray.open_dataset`](http://xarray.pydata.org/en/stable/generated/xarray.open_dataset.html#xarray.open_dataset). I think this is a good change but the unintended consequence surprised some users (cc @suyashbire1) so I'm opening this issue to see if we indeed want this. If we don't then we shouldn't add a time attribute (and provide a way for users to specify one). @tomchor Maybe you have some thoughts since you've used NetCDF/xarray/Oceananigans.jl quite extensively.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421
https://github.com/CliMA/Oceananigans.jl/issues/1422:189,Deployability,Integrat,IntegratedField,189,"We should look into using `mapreduce` as a way of computing reduced grid metrics and statistics using abstract operations. This could speed up `AveragedField` (and upcoming `SummedField`, `IntegratedField`, etc.) and make them lighter by not having to store a scratch space. There are two methods for `mapreduce`:. ```julia; mapreduce(f, op, itrs...; [init]); mapreduce(f, op, A::AbstractArray...; dims=:, [init]); ```. The first one might be useful for abstract operations (as long as `getindex` is defined?). Might be useful to do a bit of benchmarking to see if we can use them (and potentially get rid of some existing code). The second function I guess would only be useful if we already have a `ComputedField` with an array. We already use `mapreduce` a bit (the second method) but crucially we needed to pass in a view into a `CuArray` (and not a view into an `OffsetArray{CuArray}`): https://github.com/CliMA/Oceananigans.jl/blob/master/src/Solvers/preconditioned_conjugate_gradient_solver.jl#L57-L58",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1422
https://github.com/CliMA/Oceananigans.jl/issues/1422:60,Energy Efficiency,reduce,reduced,60,"We should look into using `mapreduce` as a way of computing reduced grid metrics and statistics using abstract operations. This could speed up `AveragedField` (and upcoming `SummedField`, `IntegratedField`, etc.) and make them lighter by not having to store a scratch space. There are two methods for `mapreduce`:. ```julia; mapreduce(f, op, itrs...; [init]); mapreduce(f, op, A::AbstractArray...; dims=:, [init]); ```. The first one might be useful for abstract operations (as long as `getindex` is defined?). Might be useful to do a bit of benchmarking to see if we can use them (and potentially get rid of some existing code). The second function I guess would only be useful if we already have a `ComputedField` with an array. We already use `mapreduce` a bit (the second method) but crucially we needed to pass in a view into a `CuArray` (and not a view into an `OffsetArray{CuArray}`): https://github.com/CliMA/Oceananigans.jl/blob/master/src/Solvers/preconditioned_conjugate_gradient_solver.jl#L57-L58",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1422
https://github.com/CliMA/Oceananigans.jl/issues/1422:189,Integrability,Integrat,IntegratedField,189,"We should look into using `mapreduce` as a way of computing reduced grid metrics and statistics using abstract operations. This could speed up `AveragedField` (and upcoming `SummedField`, `IntegratedField`, etc.) and make them lighter by not having to store a scratch space. There are two methods for `mapreduce`:. ```julia; mapreduce(f, op, itrs...; [init]); mapreduce(f, op, A::AbstractArray...; dims=:, [init]); ```. The first one might be useful for abstract operations (as long as `getindex` is defined?). Might be useful to do a bit of benchmarking to see if we can use them (and potentially get rid of some existing code). The second function I guess would only be useful if we already have a `ComputedField` with an array. We already use `mapreduce` a bit (the second method) but crucially we needed to pass in a view into a `CuArray` (and not a view into an `OffsetArray{CuArray}`): https://github.com/CliMA/Oceananigans.jl/blob/master/src/Solvers/preconditioned_conjugate_gradient_solver.jl#L57-L58",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1422
https://github.com/CliMA/Oceananigans.jl/issues/1422:542,Testability,benchmark,benchmarking,542,"We should look into using `mapreduce` as a way of computing reduced grid metrics and statistics using abstract operations. This could speed up `AveragedField` (and upcoming `SummedField`, `IntegratedField`, etc.) and make them lighter by not having to store a scratch space. There are two methods for `mapreduce`:. ```julia; mapreduce(f, op, itrs...; [init]); mapreduce(f, op, A::AbstractArray...; dims=:, [init]); ```. The first one might be useful for abstract operations (as long as `getindex` is defined?). Might be useful to do a bit of benchmarking to see if we can use them (and potentially get rid of some existing code). The second function I guess would only be useful if we already have a `ComputedField` with an array. We already use `mapreduce` a bit (the second method) but crucially we needed to pass in a view into a `CuArray` (and not a view into an `OffsetArray{CuArray}`): https://github.com/CliMA/Oceananigans.jl/blob/master/src/Solvers/preconditioned_conjugate_gradient_solver.jl#L57-L58",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1422
https://github.com/CliMA/Oceananigans.jl/pull/1423:1227,Availability,down,down,1227,"This PR implements validation experiments for `HorizontallyCurvilinearAnisotropicDissipation`. There are three experiments:. 1. `validation/curvilinear_diffusion/meridional_diffusion.jl`: Diffusion of a tracer and zonal momentum along a meridian; 2. `validation/curvilinear_diffusion/longitudinal_tracer_diffusion.jl`: Diffusion of a tracer along a circle of constant latitude. We would need a non-trivial `NormalFlow` boundary condition to diffuse meridional momentum, so I didn't implement momentum diffusion for this experiment.; 3. `validation/curvilinear_diffusion/spot_tracer_diffusion.jl`: Diffusion of a Gaussian spot in longitude and latitude. # Meridional diffusion . https://user-images.githubusercontent.com/15271942/109988157-42787180-7cd5-11eb-8dfe-b6f173c6c623.mp4. # Longitudinal tracer diffusion. https://user-images.githubusercontent.com/15271942/109988246-5a4ff580-7cd5-11eb-8f91-f089a3760c7f.mp4. # Spot tracer diffusion. https://user-images.githubusercontent.com/15271942/109988291-650a8a80-7cd5-11eb-81a7-762b65a8d39f.mp4. I propose we merge these and, like the other curvilinear validation experiments, save a quantitative validation for the future. For tracers, quantitative validation requires writing down analytical solutions to the diffusion equation on a spherical surface. For momentum, we cannot yet implement quantitative validation experiments, because our diffusion operator is not correct for the diffusion of a vector on a spherical surface (cc @jm-c, @kburns).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1423
https://github.com/CliMA/Oceananigans.jl/pull/1423:19,Security,validat,validation,19,"This PR implements validation experiments for `HorizontallyCurvilinearAnisotropicDissipation`. There are three experiments:. 1. `validation/curvilinear_diffusion/meridional_diffusion.jl`: Diffusion of a tracer and zonal momentum along a meridian; 2. `validation/curvilinear_diffusion/longitudinal_tracer_diffusion.jl`: Diffusion of a tracer along a circle of constant latitude. We would need a non-trivial `NormalFlow` boundary condition to diffuse meridional momentum, so I didn't implement momentum diffusion for this experiment.; 3. `validation/curvilinear_diffusion/spot_tracer_diffusion.jl`: Diffusion of a Gaussian spot in longitude and latitude. # Meridional diffusion . https://user-images.githubusercontent.com/15271942/109988157-42787180-7cd5-11eb-8dfe-b6f173c6c623.mp4. # Longitudinal tracer diffusion. https://user-images.githubusercontent.com/15271942/109988246-5a4ff580-7cd5-11eb-8f91-f089a3760c7f.mp4. # Spot tracer diffusion. https://user-images.githubusercontent.com/15271942/109988291-650a8a80-7cd5-11eb-81a7-762b65a8d39f.mp4. I propose we merge these and, like the other curvilinear validation experiments, save a quantitative validation for the future. For tracers, quantitative validation requires writing down analytical solutions to the diffusion equation on a spherical surface. For momentum, we cannot yet implement quantitative validation experiments, because our diffusion operator is not correct for the diffusion of a vector on a spherical surface (cc @jm-c, @kburns).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1423
https://github.com/CliMA/Oceananigans.jl/pull/1423:129,Security,validat,validation,129,"This PR implements validation experiments for `HorizontallyCurvilinearAnisotropicDissipation`. There are three experiments:. 1. `validation/curvilinear_diffusion/meridional_diffusion.jl`: Diffusion of a tracer and zonal momentum along a meridian; 2. `validation/curvilinear_diffusion/longitudinal_tracer_diffusion.jl`: Diffusion of a tracer along a circle of constant latitude. We would need a non-trivial `NormalFlow` boundary condition to diffuse meridional momentum, so I didn't implement momentum diffusion for this experiment.; 3. `validation/curvilinear_diffusion/spot_tracer_diffusion.jl`: Diffusion of a Gaussian spot in longitude and latitude. # Meridional diffusion . https://user-images.githubusercontent.com/15271942/109988157-42787180-7cd5-11eb-8dfe-b6f173c6c623.mp4. # Longitudinal tracer diffusion. https://user-images.githubusercontent.com/15271942/109988246-5a4ff580-7cd5-11eb-8f91-f089a3760c7f.mp4. # Spot tracer diffusion. https://user-images.githubusercontent.com/15271942/109988291-650a8a80-7cd5-11eb-81a7-762b65a8d39f.mp4. I propose we merge these and, like the other curvilinear validation experiments, save a quantitative validation for the future. For tracers, quantitative validation requires writing down analytical solutions to the diffusion equation on a spherical surface. For momentum, we cannot yet implement quantitative validation experiments, because our diffusion operator is not correct for the diffusion of a vector on a spherical surface (cc @jm-c, @kburns).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1423
https://github.com/CliMA/Oceananigans.jl/pull/1423:251,Security,validat,validation,251,"This PR implements validation experiments for `HorizontallyCurvilinearAnisotropicDissipation`. There are three experiments:. 1. `validation/curvilinear_diffusion/meridional_diffusion.jl`: Diffusion of a tracer and zonal momentum along a meridian; 2. `validation/curvilinear_diffusion/longitudinal_tracer_diffusion.jl`: Diffusion of a tracer along a circle of constant latitude. We would need a non-trivial `NormalFlow` boundary condition to diffuse meridional momentum, so I didn't implement momentum diffusion for this experiment.; 3. `validation/curvilinear_diffusion/spot_tracer_diffusion.jl`: Diffusion of a Gaussian spot in longitude and latitude. # Meridional diffusion . https://user-images.githubusercontent.com/15271942/109988157-42787180-7cd5-11eb-8dfe-b6f173c6c623.mp4. # Longitudinal tracer diffusion. https://user-images.githubusercontent.com/15271942/109988246-5a4ff580-7cd5-11eb-8f91-f089a3760c7f.mp4. # Spot tracer diffusion. https://user-images.githubusercontent.com/15271942/109988291-650a8a80-7cd5-11eb-81a7-762b65a8d39f.mp4. I propose we merge these and, like the other curvilinear validation experiments, save a quantitative validation for the future. For tracers, quantitative validation requires writing down analytical solutions to the diffusion equation on a spherical surface. For momentum, we cannot yet implement quantitative validation experiments, because our diffusion operator is not correct for the diffusion of a vector on a spherical surface (cc @jm-c, @kburns).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1423
https://github.com/CliMA/Oceananigans.jl/pull/1423:537,Security,validat,validation,537,"This PR implements validation experiments for `HorizontallyCurvilinearAnisotropicDissipation`. There are three experiments:. 1. `validation/curvilinear_diffusion/meridional_diffusion.jl`: Diffusion of a tracer and zonal momentum along a meridian; 2. `validation/curvilinear_diffusion/longitudinal_tracer_diffusion.jl`: Diffusion of a tracer along a circle of constant latitude. We would need a non-trivial `NormalFlow` boundary condition to diffuse meridional momentum, so I didn't implement momentum diffusion for this experiment.; 3. `validation/curvilinear_diffusion/spot_tracer_diffusion.jl`: Diffusion of a Gaussian spot in longitude and latitude. # Meridional diffusion . https://user-images.githubusercontent.com/15271942/109988157-42787180-7cd5-11eb-8dfe-b6f173c6c623.mp4. # Longitudinal tracer diffusion. https://user-images.githubusercontent.com/15271942/109988246-5a4ff580-7cd5-11eb-8f91-f089a3760c7f.mp4. # Spot tracer diffusion. https://user-images.githubusercontent.com/15271942/109988291-650a8a80-7cd5-11eb-81a7-762b65a8d39f.mp4. I propose we merge these and, like the other curvilinear validation experiments, save a quantitative validation for the future. For tracers, quantitative validation requires writing down analytical solutions to the diffusion equation on a spherical surface. For momentum, we cannot yet implement quantitative validation experiments, because our diffusion operator is not correct for the diffusion of a vector on a spherical surface (cc @jm-c, @kburns).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1423
https://github.com/CliMA/Oceananigans.jl/pull/1423:1102,Security,validat,validation,1102,"This PR implements validation experiments for `HorizontallyCurvilinearAnisotropicDissipation`. There are three experiments:. 1. `validation/curvilinear_diffusion/meridional_diffusion.jl`: Diffusion of a tracer and zonal momentum along a meridian; 2. `validation/curvilinear_diffusion/longitudinal_tracer_diffusion.jl`: Diffusion of a tracer along a circle of constant latitude. We would need a non-trivial `NormalFlow` boundary condition to diffuse meridional momentum, so I didn't implement momentum diffusion for this experiment.; 3. `validation/curvilinear_diffusion/spot_tracer_diffusion.jl`: Diffusion of a Gaussian spot in longitude and latitude. # Meridional diffusion . https://user-images.githubusercontent.com/15271942/109988157-42787180-7cd5-11eb-8dfe-b6f173c6c623.mp4. # Longitudinal tracer diffusion. https://user-images.githubusercontent.com/15271942/109988246-5a4ff580-7cd5-11eb-8f91-f089a3760c7f.mp4. # Spot tracer diffusion. https://user-images.githubusercontent.com/15271942/109988291-650a8a80-7cd5-11eb-81a7-762b65a8d39f.mp4. I propose we merge these and, like the other curvilinear validation experiments, save a quantitative validation for the future. For tracers, quantitative validation requires writing down analytical solutions to the diffusion equation on a spherical surface. For momentum, we cannot yet implement quantitative validation experiments, because our diffusion operator is not correct for the diffusion of a vector on a spherical surface (cc @jm-c, @kburns).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1423
https://github.com/CliMA/Oceananigans.jl/pull/1423:1146,Security,validat,validation,1146,"This PR implements validation experiments for `HorizontallyCurvilinearAnisotropicDissipation`. There are three experiments:. 1. `validation/curvilinear_diffusion/meridional_diffusion.jl`: Diffusion of a tracer and zonal momentum along a meridian; 2. `validation/curvilinear_diffusion/longitudinal_tracer_diffusion.jl`: Diffusion of a tracer along a circle of constant latitude. We would need a non-trivial `NormalFlow` boundary condition to diffuse meridional momentum, so I didn't implement momentum diffusion for this experiment.; 3. `validation/curvilinear_diffusion/spot_tracer_diffusion.jl`: Diffusion of a Gaussian spot in longitude and latitude. # Meridional diffusion . https://user-images.githubusercontent.com/15271942/109988157-42787180-7cd5-11eb-8dfe-b6f173c6c623.mp4. # Longitudinal tracer diffusion. https://user-images.githubusercontent.com/15271942/109988246-5a4ff580-7cd5-11eb-8f91-f089a3760c7f.mp4. # Spot tracer diffusion. https://user-images.githubusercontent.com/15271942/109988291-650a8a80-7cd5-11eb-81a7-762b65a8d39f.mp4. I propose we merge these and, like the other curvilinear validation experiments, save a quantitative validation for the future. For tracers, quantitative validation requires writing down analytical solutions to the diffusion equation on a spherical surface. For momentum, we cannot yet implement quantitative validation experiments, because our diffusion operator is not correct for the diffusion of a vector on a spherical surface (cc @jm-c, @kburns).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1423
https://github.com/CliMA/Oceananigans.jl/pull/1423:1199,Security,validat,validation,1199,"This PR implements validation experiments for `HorizontallyCurvilinearAnisotropicDissipation`. There are three experiments:. 1. `validation/curvilinear_diffusion/meridional_diffusion.jl`: Diffusion of a tracer and zonal momentum along a meridian; 2. `validation/curvilinear_diffusion/longitudinal_tracer_diffusion.jl`: Diffusion of a tracer along a circle of constant latitude. We would need a non-trivial `NormalFlow` boundary condition to diffuse meridional momentum, so I didn't implement momentum diffusion for this experiment.; 3. `validation/curvilinear_diffusion/spot_tracer_diffusion.jl`: Diffusion of a Gaussian spot in longitude and latitude. # Meridional diffusion . https://user-images.githubusercontent.com/15271942/109988157-42787180-7cd5-11eb-8dfe-b6f173c6c623.mp4. # Longitudinal tracer diffusion. https://user-images.githubusercontent.com/15271942/109988246-5a4ff580-7cd5-11eb-8f91-f089a3760c7f.mp4. # Spot tracer diffusion. https://user-images.githubusercontent.com/15271942/109988291-650a8a80-7cd5-11eb-81a7-762b65a8d39f.mp4. I propose we merge these and, like the other curvilinear validation experiments, save a quantitative validation for the future. For tracers, quantitative validation requires writing down analytical solutions to the diffusion equation on a spherical surface. For momentum, we cannot yet implement quantitative validation experiments, because our diffusion operator is not correct for the diffusion of a vector on a spherical surface (cc @jm-c, @kburns).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1423
https://github.com/CliMA/Oceananigans.jl/pull/1423:1354,Security,validat,validation,1354,"This PR implements validation experiments for `HorizontallyCurvilinearAnisotropicDissipation`. There are three experiments:. 1. `validation/curvilinear_diffusion/meridional_diffusion.jl`: Diffusion of a tracer and zonal momentum along a meridian; 2. `validation/curvilinear_diffusion/longitudinal_tracer_diffusion.jl`: Diffusion of a tracer along a circle of constant latitude. We would need a non-trivial `NormalFlow` boundary condition to diffuse meridional momentum, so I didn't implement momentum diffusion for this experiment.; 3. `validation/curvilinear_diffusion/spot_tracer_diffusion.jl`: Diffusion of a Gaussian spot in longitude and latitude. # Meridional diffusion . https://user-images.githubusercontent.com/15271942/109988157-42787180-7cd5-11eb-8dfe-b6f173c6c623.mp4. # Longitudinal tracer diffusion. https://user-images.githubusercontent.com/15271942/109988246-5a4ff580-7cd5-11eb-8f91-f089a3760c7f.mp4. # Spot tracer diffusion. https://user-images.githubusercontent.com/15271942/109988291-650a8a80-7cd5-11eb-81a7-762b65a8d39f.mp4. I propose we merge these and, like the other curvilinear validation experiments, save a quantitative validation for the future. For tracers, quantitative validation requires writing down analytical solutions to the diffusion equation on a spherical surface. For momentum, we cannot yet implement quantitative validation experiments, because our diffusion operator is not correct for the diffusion of a vector on a spherical surface (cc @jm-c, @kburns).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1423
https://github.com/CliMA/Oceananigans.jl/pull/1426:131,Security,validat,validation,131,"This PR implements `PrescribedVelocityFields` for `HydrostaticFreeSurfaceModel` (or more precisely, moves the implementation from `validation/` to `src/`). `PrescribedVelocityFields` acts similar to the `velocities` tuple, except that `velocities.u, velocities.v, velocities.w` are prescribed functions of `x, y, z, t` and optional `parameters`. Using the kwarg `velocities=PrescribedVelocityFields(...)` in the constructor for `HydrostaticFreeSurfaceModel` causes the free surface to be set to `nothing` and elides memory allocations for velocity and free surface tendency fields. The model then amounts to tracer advection by the prescribed fields. This feature was discussed on #958, where it was envisioned this feature would be implemented in `IncompressibleModel`. Right now the implementation is specific to `HydrostaticFreeSurfaceModel`. However, I think the tracer advection-diffusion physics permitted by `IncompressibleModel` and `HydrostaticFreeSurfaceModel` are identical right now. So perhaps this PR closes #958?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1426
https://github.com/CliMA/Oceananigans.jl/pull/1428:248,Modifiability,refactor,refactoring,248,"This PR removes . * `src/TurbulenceClosures/turbulence_closure_implementations/rozema_anisotropic_minimum_dissipation.jl`; * `src/TurbulenceClosures/turbulence_closure_implementations/blasius_smagorinsky.jl`. from the source. It also does a bit of refactoring, since types like `AbstractSmagorinsky` are no longer needed to organize the Smagorinsky implementations. RIP `AbstractSmagorinsky`. PS @ali-ramadhan you might have some opinions about how I should provide citations in the source code / docstrings, which I am happy to oblige on this PR. Plus any other misc. cleanup. This PR makes progress towards #1381, and. Resolves #1002 (since the other concerns raised in #1002 can be addressed when resolving #1381).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1428
https://github.com/CliMA/Oceananigans.jl/issues/1429:492,Testability,test,testing,492,"Hey! I just tried out the vertically stretched grid and I'm finding a few issues:. 1. The `OutputWriter` is complaining that there is no field `zC`; 2. It didn't work with the `FT=Float64` argument, so I am using the following. ```; grid = VerticallyStretchedRectilinearGrid(; architecture = GPU(),; size = (Nx,Ny,Nz), x=(0, Lx), y=(0, Ly), zF=zF,; halo = (3, 3, 3),; topology = (Periodic, Bounded, Bounded)); ```. 3. It asks me to use: `halo = (3, 3, 3)` and not `halo = (1, 1, 1)` . 4. For testing purposes, I tried using a linear grid with `zF = collect(-160:2.5:0)`. I ran for 1 short timestep and it produces NaN's in the `u` field. However, using the same linear grid with `RegularRectilinearGrid(size=(Nx, Ny, Nz), extent=(Δx*Nx, Δy*Ny, Δz*Nz), topology = (Periodic, Bounded, Bounded))` works fine. Any ideas?. Many thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429
https://github.com/CliMA/Oceananigans.jl/pull/1430:168,Integrability,interface,interface,168,"This PR adds a distributed constructor for `ShallowWaterModel`, pair programmed with @francispoulin. End goal might be to add a new example showing the distributed MPI interface! Might also showcase the shallow water model, NetCDF output, and plotting with CairoMakie?. This PR depends on PR #590 (which is why it's 90+ commits long...). Most recent 4 commits are the relevant ones.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430
https://github.com/CliMA/Oceananigans.jl/pull/1430:278,Integrability,depend,depends,278,"This PR adds a distributed constructor for `ShallowWaterModel`, pair programmed with @francispoulin. End goal might be to add a new example showing the distributed MPI interface! Might also showcase the shallow water model, NetCDF output, and plotting with CairoMakie?. This PR depends on PR #590 (which is why it's 90+ commits long...). Most recent 4 commits are the relevant ones.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430
https://github.com/CliMA/Oceananigans.jl/issues/1432:215,Availability,error,error,215,"Respected sir,; I want to simulate a small prototype of Open Ocean convection and did all necessary scaling according to that. Please have a look at my code, I don't know why my code isn't working. It is giving NaN error.; ````; using Printf; using Plots; using JLD2. using Oceananigans; using Oceananigans.Utils. using Oceananigans.Grids: nodes; using Oceananigans.Diagnostics: FieldMaximum; using Oceananigans.OutputWriters: JLD2OutputWriter, FieldSlicer, TimeInterval. #number of grid spacing in south,north and vertical direction; Nx=256; Ny=256; Nz=64. #Length of grid in south, north and vertical direction; Lx=4; Ly=4; Lz=0.1. grid = RegularCartesianGrid(size=(Nx, Ny, Nz), extent=(Lx, Ly, Lz)). #Coefficient of Thermal expansion; alpha= 2e-4. #Coefficient of Salinity; saline=0. Ra=1.8e8 #rayleigh number. Ro=0.24 #Horizontal Rossby number. v=1e-6 #diffusive viscocity. k=1e-6 #diffusivity . l=Lx/2 #center of gaussian field. m=Ly/2 #center of gausian field. Bo=9e-5 #maximum surface flux. f=0.5386 #coriolis parameter. beta=4.039e-3. #Gaussian Surface forcing; heat_flux(x,y,t) = Bo*exp(-0.5*((x-l)^2+(y-m)^2)). dTdz = 0 # K m⁻¹. T_bcs = TracerBoundaryConditions(grid,; top = BoundaryCondition(Flux, heat_flux),; bottom = BoundaryCondition(Gradient, dTdz)). Qᵘ=0 #Zero flux boundary condition at the top surface. u_bcs = UVelocityBoundaryConditions(grid, top = BoundaryCondition(Flux, Qᵘ), bottom=ValueBoundaryCondition(0.0)); v_bcs = VVelocityBoundaryConditions(grid, top = BoundaryCondition(Flux, Qᵘ), bottom=ValueBoundaryCondition(0.0)); w_bcs = WVelocityBoundaryConditions(grid, top = ValueBoundaryCondition(0.0), bottom=ValueBoundaryCondition(0.0)). buoyancy = SeawaterBuoyancy(gravitational_acceleration = 300,equation_of_state=LinearEquationOfState(α=alpha, β=saline)). #Incompressible model initiation . using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = IncompressibleModel(architecture = CPU(),. timestepper = :RungeKutta3,; grid = grid,; coriolis = BetaPl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1432
https://github.com/CliMA/Oceananigans.jl/issues/1432:3356,Energy Efficiency,schedul,schedule,3356,"(0.0)); v_bcs = VVelocityBoundaryConditions(grid, top = BoundaryCondition(Flux, Qᵘ), bottom=ValueBoundaryCondition(0.0)); w_bcs = WVelocityBoundaryConditions(grid, top = ValueBoundaryCondition(0.0), bottom=ValueBoundaryCondition(0.0)). buoyancy = SeawaterBuoyancy(gravitational_acceleration = 300,equation_of_state=LinearEquationOfState(α=alpha, β=saline)). #Incompressible model initiation . using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = IncompressibleModel(architecture = CPU(),. timestepper = :RungeKutta3,; grid = grid,; coriolis = BetaPlane(f₀=f, β=beta),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, w=w_bcs, T=T_bcs)). # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. # Temperature initial condition: a stable density gradient with random noise superposed.; dTz = 81.2762. Tᵢ(x, y, z) = 30 + dTz * z + dTz * model.grid.Lz * 1e-6 * Ξ(z). # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-8 * Ξ(z). # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl=1.5, Δt=0.001, max_change=1.1, max_Δt=0.2minute). wmax = FieldMaximum(abs, model.velocities.w). start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), wmax(sim.model),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model, Δt=wizard, stop_time=15minutes, iteration_interval=10,; progress=progress_message). simulation.output_writers[:fields] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers),; prefix = ""modified_open_ocean_convection2"",; schedule = TimeInterval(0.2minute),; force = true). run!(simulation)````",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1432
https://github.com/CliMA/Oceananigans.jl/issues/1432:2844,Integrability,message,message,2844,"(0.0)); v_bcs = VVelocityBoundaryConditions(grid, top = BoundaryCondition(Flux, Qᵘ), bottom=ValueBoundaryCondition(0.0)); w_bcs = WVelocityBoundaryConditions(grid, top = ValueBoundaryCondition(0.0), bottom=ValueBoundaryCondition(0.0)). buoyancy = SeawaterBuoyancy(gravitational_acceleration = 300,equation_of_state=LinearEquationOfState(α=alpha, β=saline)). #Incompressible model initiation . using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = IncompressibleModel(architecture = CPU(),. timestepper = :RungeKutta3,; grid = grid,; coriolis = BetaPlane(f₀=f, β=beta),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, w=w_bcs, T=T_bcs)). # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. # Temperature initial condition: a stable density gradient with random noise superposed.; dTz = 81.2762. Tᵢ(x, y, z) = 30 + dTz * z + dTz * model.grid.Lz * 1e-6 * Ξ(z). # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * 1e-8 * Ξ(z). # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl=1.5, Δt=0.001, max_change=1.1, max_Δt=0.2minute). wmax = FieldMaximum(abs, model.velocities.w). start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), wmax(sim.model),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model, Δt=wizard, stop_time=15minutes, iteration_interval=10,; progress=progress_message). simulation.output_writers[:fields] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers),; prefix = ""modified_open_ocean_convection2"",; schedule = TimeInterval(0.2minute),; force = true). run!(simulation)````",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1432
https://github.com/CliMA/Oceananigans.jl/pull/1433:731,Security,validat,validation,731,"This PR partially generalizes the implementation of flux boundary conditions to work on curvilinear grids. The design implemented in this PR required a number of changes:. - Preservation of field locations in GPU kernels through a generalization of `adapt_structure(to, field::Field)`; - Creation of generic area and volume operators that dispatch on location like `Ax(i, j, k, grid, X, Y, Z)` (others are `Ay`, `Az`, and `volume`); - Generalization of `apply_top_z_flux!`, etc. The similar functions for `x` and `y` could also be generalized in this PR, though we don't have regression tests to ensure that they still work as before...; - Activation of `calculate_boundary_tendencies!` for `HydrostaticFreeSurfaceModel`. The new `validation/barotropic_gyre.jl` experiment is definitely a work in progress but will eventually produce a movie like. https://user-images.githubusercontent.com/15271942/110257064-a747fc00-7f61-11eb-83aa-18665f01efb4.mp4. We may want to add side and bottom drag, tweak the surface stress, and tweak the viscosity.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1433
https://github.com/CliMA/Oceananigans.jl/pull/1433:587,Testability,test,tests,587,"This PR partially generalizes the implementation of flux boundary conditions to work on curvilinear grids. The design implemented in this PR required a number of changes:. - Preservation of field locations in GPU kernels through a generalization of `adapt_structure(to, field::Field)`; - Creation of generic area and volume operators that dispatch on location like `Ax(i, j, k, grid, X, Y, Z)` (others are `Ay`, `Az`, and `volume`); - Generalization of `apply_top_z_flux!`, etc. The similar functions for `x` and `y` could also be generalized in this PR, though we don't have regression tests to ensure that they still work as before...; - Activation of `calculate_boundary_tendencies!` for `HydrostaticFreeSurfaceModel`. The new `validation/barotropic_gyre.jl` experiment is definitely a work in progress but will eventually produce a movie like. https://user-images.githubusercontent.com/15271942/110257064-a747fc00-7f61-11eb-83aa-18665f01efb4.mp4. We may want to add side and bottom drag, tweak the surface stress, and tweak the viscosity.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1433
https://github.com/CliMA/Oceananigans.jl/pull/1435:237,Testability,log,logic,237,"I was trying to understand the dims pattern in the branching in `plan_transforms`, and ended up re-writing it a bit to understand it. Not sure if this is a preferable form, but I thought I'd open a PR in case. I need to double-check the logic, but maybe someone can confirm.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1435
https://github.com/CliMA/Oceananigans.jl/issues/1438:352,Security,validat,validation,352,"For a thesis project about the migration and dispersal of fish larvae in the sea I am looking for CFD tools that allow a newcomer in this field (like myself) the simulation of agent based models (each agent represents a fish) in laminar flows and later in more realistic turbulences. I chose the following steps as milestones:. - First, as a means for validation, I will show a lid driven cavity flow (Oceananigans already does this in an example).; - After this I will combine this with an agent based model where an agent will represent a larvae. At that state the agent should follow simple rules, like drift in the direction of a laminar flow.; - If that works, I will implement a continuity equation to simulate the odor which comes from the reef and which is supposed to help the larvae to find back to the home reef.; - Next, putting n agents into the water and see, if the individuals are behaving differently when put into a swarm. . I am planning to keep this in 2D since doing it in 3D would probably be to difficult given the limited time (3 months). I will not try to simulate the exact ocean currents or the bottom of the ocean. Are you capable of assessing the suitability of Oceananigans for those steps? Is it possible to deliver those steps? . For the Agent based modelling I will be working with the [Agents.jl](https://juliadynamics.github.io/Agents.jl/stable/) package probably, since it seems well documented.; Since I have found Oceananigans, which is also a CFD tool, I was wondering what you think the differences are between that and [WaterLily.jl](https://github.com/weymouth/WaterLily.jl)? Given my description of the project above, would you tend to use either of them?; Thank you!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1438
https://github.com/CliMA/Oceananigans.jl/issues/1438:587,Usability,simpl,simple,587,"For a thesis project about the migration and dispersal of fish larvae in the sea I am looking for CFD tools that allow a newcomer in this field (like myself) the simulation of agent based models (each agent represents a fish) in laminar flows and later in more realistic turbulences. I chose the following steps as milestones:. - First, as a means for validation, I will show a lid driven cavity flow (Oceananigans already does this in an example).; - After this I will combine this with an agent based model where an agent will represent a larvae. At that state the agent should follow simple rules, like drift in the direction of a laminar flow.; - If that works, I will implement a continuity equation to simulate the odor which comes from the reef and which is supposed to help the larvae to find back to the home reef.; - Next, putting n agents into the water and see, if the individuals are behaving differently when put into a swarm. . I am planning to keep this in 2D since doing it in 3D would probably be to difficult given the limited time (3 months). I will not try to simulate the exact ocean currents or the bottom of the ocean. Are you capable of assessing the suitability of Oceananigans for those steps? Is it possible to deliver those steps? . For the Agent based modelling I will be working with the [Agents.jl](https://juliadynamics.github.io/Agents.jl/stable/) package probably, since it seems well documented.; Since I have found Oceananigans, which is also a CFD tool, I was wondering what you think the differences are between that and [WaterLily.jl](https://github.com/weymouth/WaterLily.jl)? Given my description of the project above, would you tend to use either of them?; Thank you!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1438
https://github.com/CliMA/Oceananigans.jl/pull/1439:47,Testability,test,test,47,cc @sandreza this affects your Rossby-Haurwitz test.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1439
https://github.com/CliMA/Oceananigans.jl/pull/1449:27,Modifiability,refactor,refactor,27,"This PR implements a major refactor of the `TurbulenceClosures` module. In particular, it ""standardizes"" how turbulence closures specify diffusive fluxes. Each turbulence closure now defines 12 functions (or opts in to functionality via subtyping, eg `AbstractEddyViscosityClosure`):. * `diffusive_flux_x`, `diffusive_flux_y`, and `diffusive_flux_z` for tracer diffusive fluxes; * `viscous_flux_ux`, `viscous_flux_uy`, and `viscous_flux_uz` for viscous fluxes of x-momentum; * 6 other functions similar to `viscous_flux_ux`, etc for `y` and `z` momentum components. Then there is a single implementation of `∇_κ_∇c`, for example, which calculates the divergence of the diffusive fluxes in a way that generalizes to curvilinear grids. This refactor was not that difficult because many turbulence closures had functions analogous to these --- they were just called by different names. So in a way this PR simply establishes standard notation. A major advantage of standard notation is that we can now correctly specify flux boundary conditions even when we cannot fill halos for this purpose. For example, right now we fill halos so that (fingers crossed!) boundary fluxes are zero when the diffusion operator is evaluated on boundary-adjacent cells, and then in a second step add the specific boundary fluxes. But with a function `diffusive_flux_x`, we can now ""reverse"" boundary fluxes and add specified fluxes generically. This PR therefore makes progress towards #1400. Work on this PR started with a few extra tests for `HydrostaticFreeSurfaceModel` (though its focus is not quite different). So as a bonus this PR also adds tests for `HydrostaticFreeSurfaceModel` (which may need to be disabled if they fail on the GPU so that we can get this PR in sooner rather than later).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1449
https://github.com/CliMA/Oceananigans.jl/pull/1449:739,Modifiability,refactor,refactor,739,"This PR implements a major refactor of the `TurbulenceClosures` module. In particular, it ""standardizes"" how turbulence closures specify diffusive fluxes. Each turbulence closure now defines 12 functions (or opts in to functionality via subtyping, eg `AbstractEddyViscosityClosure`):. * `diffusive_flux_x`, `diffusive_flux_y`, and `diffusive_flux_z` for tracer diffusive fluxes; * `viscous_flux_ux`, `viscous_flux_uy`, and `viscous_flux_uz` for viscous fluxes of x-momentum; * 6 other functions similar to `viscous_flux_ux`, etc for `y` and `z` momentum components. Then there is a single implementation of `∇_κ_∇c`, for example, which calculates the divergence of the diffusive fluxes in a way that generalizes to curvilinear grids. This refactor was not that difficult because many turbulence closures had functions analogous to these --- they were just called by different names. So in a way this PR simply establishes standard notation. A major advantage of standard notation is that we can now correctly specify flux boundary conditions even when we cannot fill halos for this purpose. For example, right now we fill halos so that (fingers crossed!) boundary fluxes are zero when the diffusion operator is evaluated on boundary-adjacent cells, and then in a second step add the specific boundary fluxes. But with a function `diffusive_flux_x`, we can now ""reverse"" boundary fluxes and add specified fluxes generically. This PR therefore makes progress towards #1400. Work on this PR started with a few extra tests for `HydrostaticFreeSurfaceModel` (though its focus is not quite different). So as a bonus this PR also adds tests for `HydrostaticFreeSurfaceModel` (which may need to be disabled if they fail on the GPU so that we can get this PR in sooner rather than later).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1449
https://github.com/CliMA/Oceananigans.jl/pull/1449:1513,Testability,test,tests,1513,"This PR implements a major refactor of the `TurbulenceClosures` module. In particular, it ""standardizes"" how turbulence closures specify diffusive fluxes. Each turbulence closure now defines 12 functions (or opts in to functionality via subtyping, eg `AbstractEddyViscosityClosure`):. * `diffusive_flux_x`, `diffusive_flux_y`, and `diffusive_flux_z` for tracer diffusive fluxes; * `viscous_flux_ux`, `viscous_flux_uy`, and `viscous_flux_uz` for viscous fluxes of x-momentum; * 6 other functions similar to `viscous_flux_ux`, etc for `y` and `z` momentum components. Then there is a single implementation of `∇_κ_∇c`, for example, which calculates the divergence of the diffusive fluxes in a way that generalizes to curvilinear grids. This refactor was not that difficult because many turbulence closures had functions analogous to these --- they were just called by different names. So in a way this PR simply establishes standard notation. A major advantage of standard notation is that we can now correctly specify flux boundary conditions even when we cannot fill halos for this purpose. For example, right now we fill halos so that (fingers crossed!) boundary fluxes are zero when the diffusion operator is evaluated on boundary-adjacent cells, and then in a second step add the specific boundary fluxes. But with a function `diffusive_flux_x`, we can now ""reverse"" boundary fluxes and add specified fluxes generically. This PR therefore makes progress towards #1400. Work on this PR started with a few extra tests for `HydrostaticFreeSurfaceModel` (though its focus is not quite different). So as a bonus this PR also adds tests for `HydrostaticFreeSurfaceModel` (which may need to be disabled if they fail on the GPU so that we can get this PR in sooner rather than later).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1449
https://github.com/CliMA/Oceananigans.jl/pull/1449:1628,Testability,test,tests,1628,"This PR implements a major refactor of the `TurbulenceClosures` module. In particular, it ""standardizes"" how turbulence closures specify diffusive fluxes. Each turbulence closure now defines 12 functions (or opts in to functionality via subtyping, eg `AbstractEddyViscosityClosure`):. * `diffusive_flux_x`, `diffusive_flux_y`, and `diffusive_flux_z` for tracer diffusive fluxes; * `viscous_flux_ux`, `viscous_flux_uy`, and `viscous_flux_uz` for viscous fluxes of x-momentum; * 6 other functions similar to `viscous_flux_ux`, etc for `y` and `z` momentum components. Then there is a single implementation of `∇_κ_∇c`, for example, which calculates the divergence of the diffusive fluxes in a way that generalizes to curvilinear grids. This refactor was not that difficult because many turbulence closures had functions analogous to these --- they were just called by different names. So in a way this PR simply establishes standard notation. A major advantage of standard notation is that we can now correctly specify flux boundary conditions even when we cannot fill halos for this purpose. For example, right now we fill halos so that (fingers crossed!) boundary fluxes are zero when the diffusion operator is evaluated on boundary-adjacent cells, and then in a second step add the specific boundary fluxes. But with a function `diffusive_flux_x`, we can now ""reverse"" boundary fluxes and add specified fluxes generically. This PR therefore makes progress towards #1400. Work on this PR started with a few extra tests for `HydrostaticFreeSurfaceModel` (though its focus is not quite different). So as a bonus this PR also adds tests for `HydrostaticFreeSurfaceModel` (which may need to be disabled if they fail on the GPU so that we can get this PR in sooner rather than later).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1449
https://github.com/CliMA/Oceananigans.jl/pull/1449:903,Usability,simpl,simply,903,"This PR implements a major refactor of the `TurbulenceClosures` module. In particular, it ""standardizes"" how turbulence closures specify diffusive fluxes. Each turbulence closure now defines 12 functions (or opts in to functionality via subtyping, eg `AbstractEddyViscosityClosure`):. * `diffusive_flux_x`, `diffusive_flux_y`, and `diffusive_flux_z` for tracer diffusive fluxes; * `viscous_flux_ux`, `viscous_flux_uy`, and `viscous_flux_uz` for viscous fluxes of x-momentum; * 6 other functions similar to `viscous_flux_ux`, etc for `y` and `z` momentum components. Then there is a single implementation of `∇_κ_∇c`, for example, which calculates the divergence of the diffusive fluxes in a way that generalizes to curvilinear grids. This refactor was not that difficult because many turbulence closures had functions analogous to these --- they were just called by different names. So in a way this PR simply establishes standard notation. A major advantage of standard notation is that we can now correctly specify flux boundary conditions even when we cannot fill halos for this purpose. For example, right now we fill halos so that (fingers crossed!) boundary fluxes are zero when the diffusion operator is evaluated on boundary-adjacent cells, and then in a second step add the specific boundary fluxes. But with a function `diffusive_flux_x`, we can now ""reverse"" boundary fluxes and add specified fluxes generically. This PR therefore makes progress towards #1400. Work on this PR started with a few extra tests for `HydrostaticFreeSurfaceModel` (though its focus is not quite different). So as a bonus this PR also adds tests for `HydrostaticFreeSurfaceModel` (which may need to be disabled if they fail on the GPU so that we can get this PR in sooner rather than later).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1449
https://github.com/CliMA/Oceananigans.jl/issues/1450:702,Testability,test,test,702,"Right now `Oceananigans.Distributed` requires the grid points to be split evenly among the ranks, e.g. if you have 4 ranks along the x-direction then `grid.Nx` must be a multiple of 4. @christophernhill suggested generalizing this. He's written some code for dividing nearly evenly into N subdomains when the global number of points is not exactly divisable by N: https://github.com/christophernhill/iap-2021-12.091/blob/e79dfe9dca5441e561cefd65b4c052b1a1dea5a3/step3.py#L36. `IncompressibleModel` can only be decomposed in y but `ShallowWaterModel` and `HydrostaticFreeSurfaceModel` can be decomposed in x and y so we should try this out with one of them. With shallow water model in this PR we could test different x, y, and xy domain decompositions (all non-equal).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1450
https://github.com/CliMA/Oceananigans.jl/issues/1451:225,Performance,perform,performance,225,"In PR #590 I added a small/quick strong scaling test and @francispoulin calculated the scaling efficiency which wasn't super great:. ```; np efficiency; == ==========; 2 0.96; 4 0.71; 8 0.62; 16 0.56; ```. I guess to improve performance we should do some MPI profiling to find bottlenecks. Could also benchmark the distributed pressure solve and the halo filling separately to see how they scale as well. Might also make sense to benchmark scaling with `ShallowWaterModel` to see if it's an `IncompressibleModel` issue. Might need a pretty large domain to see good scaling with a 2D shallow water model?. @tomchor pointed out that the benchmark could be flawed. We should make sure everything is compiled. Could also try different sizes and a weak scaling benchmark in case the 1D/slab decomposition isn't helping. Maybe trying on a different machine too. Not sure if there's a ""proper"" setup for doing these scaling benchmarks. Bad scaling efficiency might also be a sign of missing barriers/waits?. @vchuravy We might ask for your help!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1451
https://github.com/CliMA/Oceananigans.jl/issues/1451:277,Performance,bottleneck,bottlenecks,277,"In PR #590 I added a small/quick strong scaling test and @francispoulin calculated the scaling efficiency which wasn't super great:. ```; np efficiency; == ==========; 2 0.96; 4 0.71; 8 0.62; 16 0.56; ```. I guess to improve performance we should do some MPI profiling to find bottlenecks. Could also benchmark the distributed pressure solve and the halo filling separately to see how they scale as well. Might also make sense to benchmark scaling with `ShallowWaterModel` to see if it's an `IncompressibleModel` issue. Might need a pretty large domain to see good scaling with a 2D shallow water model?. @tomchor pointed out that the benchmark could be flawed. We should make sure everything is compiled. Could also try different sizes and a weak scaling benchmark in case the 1D/slab decomposition isn't helping. Maybe trying on a different machine too. Not sure if there's a ""proper"" setup for doing these scaling benchmarks. Bad scaling efficiency might also be a sign of missing barriers/waits?. @vchuravy We might ask for your help!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1451
https://github.com/CliMA/Oceananigans.jl/issues/1451:48,Testability,test,test,48,"In PR #590 I added a small/quick strong scaling test and @francispoulin calculated the scaling efficiency which wasn't super great:. ```; np efficiency; == ==========; 2 0.96; 4 0.71; 8 0.62; 16 0.56; ```. I guess to improve performance we should do some MPI profiling to find bottlenecks. Could also benchmark the distributed pressure solve and the halo filling separately to see how they scale as well. Might also make sense to benchmark scaling with `ShallowWaterModel` to see if it's an `IncompressibleModel` issue. Might need a pretty large domain to see good scaling with a 2D shallow water model?. @tomchor pointed out that the benchmark could be flawed. We should make sure everything is compiled. Could also try different sizes and a weak scaling benchmark in case the 1D/slab decomposition isn't helping. Maybe trying on a different machine too. Not sure if there's a ""proper"" setup for doing these scaling benchmarks. Bad scaling efficiency might also be a sign of missing barriers/waits?. @vchuravy We might ask for your help!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1451
https://github.com/CliMA/Oceananigans.jl/issues/1451:301,Testability,benchmark,benchmark,301,"In PR #590 I added a small/quick strong scaling test and @francispoulin calculated the scaling efficiency which wasn't super great:. ```; np efficiency; == ==========; 2 0.96; 4 0.71; 8 0.62; 16 0.56; ```. I guess to improve performance we should do some MPI profiling to find bottlenecks. Could also benchmark the distributed pressure solve and the halo filling separately to see how they scale as well. Might also make sense to benchmark scaling with `ShallowWaterModel` to see if it's an `IncompressibleModel` issue. Might need a pretty large domain to see good scaling with a 2D shallow water model?. @tomchor pointed out that the benchmark could be flawed. We should make sure everything is compiled. Could also try different sizes and a weak scaling benchmark in case the 1D/slab decomposition isn't helping. Maybe trying on a different machine too. Not sure if there's a ""proper"" setup for doing these scaling benchmarks. Bad scaling efficiency might also be a sign of missing barriers/waits?. @vchuravy We might ask for your help!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1451
https://github.com/CliMA/Oceananigans.jl/issues/1451:430,Testability,benchmark,benchmark,430,"In PR #590 I added a small/quick strong scaling test and @francispoulin calculated the scaling efficiency which wasn't super great:. ```; np efficiency; == ==========; 2 0.96; 4 0.71; 8 0.62; 16 0.56; ```. I guess to improve performance we should do some MPI profiling to find bottlenecks. Could also benchmark the distributed pressure solve and the halo filling separately to see how they scale as well. Might also make sense to benchmark scaling with `ShallowWaterModel` to see if it's an `IncompressibleModel` issue. Might need a pretty large domain to see good scaling with a 2D shallow water model?. @tomchor pointed out that the benchmark could be flawed. We should make sure everything is compiled. Could also try different sizes and a weak scaling benchmark in case the 1D/slab decomposition isn't helping. Maybe trying on a different machine too. Not sure if there's a ""proper"" setup for doing these scaling benchmarks. Bad scaling efficiency might also be a sign of missing barriers/waits?. @vchuravy We might ask for your help!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1451
https://github.com/CliMA/Oceananigans.jl/issues/1451:635,Testability,benchmark,benchmark,635,"In PR #590 I added a small/quick strong scaling test and @francispoulin calculated the scaling efficiency which wasn't super great:. ```; np efficiency; == ==========; 2 0.96; 4 0.71; 8 0.62; 16 0.56; ```. I guess to improve performance we should do some MPI profiling to find bottlenecks. Could also benchmark the distributed pressure solve and the halo filling separately to see how they scale as well. Might also make sense to benchmark scaling with `ShallowWaterModel` to see if it's an `IncompressibleModel` issue. Might need a pretty large domain to see good scaling with a 2D shallow water model?. @tomchor pointed out that the benchmark could be flawed. We should make sure everything is compiled. Could also try different sizes and a weak scaling benchmark in case the 1D/slab decomposition isn't helping. Maybe trying on a different machine too. Not sure if there's a ""proper"" setup for doing these scaling benchmarks. Bad scaling efficiency might also be a sign of missing barriers/waits?. @vchuravy We might ask for your help!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1451
https://github.com/CliMA/Oceananigans.jl/issues/1451:756,Testability,benchmark,benchmark,756,"In PR #590 I added a small/quick strong scaling test and @francispoulin calculated the scaling efficiency which wasn't super great:. ```; np efficiency; == ==========; 2 0.96; 4 0.71; 8 0.62; 16 0.56; ```. I guess to improve performance we should do some MPI profiling to find bottlenecks. Could also benchmark the distributed pressure solve and the halo filling separately to see how they scale as well. Might also make sense to benchmark scaling with `ShallowWaterModel` to see if it's an `IncompressibleModel` issue. Might need a pretty large domain to see good scaling with a 2D shallow water model?. @tomchor pointed out that the benchmark could be flawed. We should make sure everything is compiled. Could also try different sizes and a weak scaling benchmark in case the 1D/slab decomposition isn't helping. Maybe trying on a different machine too. Not sure if there's a ""proper"" setup for doing these scaling benchmarks. Bad scaling efficiency might also be a sign of missing barriers/waits?. @vchuravy We might ask for your help!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1451
https://github.com/CliMA/Oceananigans.jl/issues/1451:917,Testability,benchmark,benchmarks,917,"In PR #590 I added a small/quick strong scaling test and @francispoulin calculated the scaling efficiency which wasn't super great:. ```; np efficiency; == ==========; 2 0.96; 4 0.71; 8 0.62; 16 0.56; ```. I guess to improve performance we should do some MPI profiling to find bottlenecks. Could also benchmark the distributed pressure solve and the halo filling separately to see how they scale as well. Might also make sense to benchmark scaling with `ShallowWaterModel` to see if it's an `IncompressibleModel` issue. Might need a pretty large domain to see good scaling with a 2D shallow water model?. @tomchor pointed out that the benchmark could be flawed. We should make sure everything is compiled. Could also try different sizes and a weak scaling benchmark in case the 1D/slab decomposition isn't helping. Maybe trying on a different machine too. Not sure if there's a ""proper"" setup for doing these scaling benchmarks. Bad scaling efficiency might also be a sign of missing barriers/waits?. @vchuravy We might ask for your help!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1451
https://github.com/CliMA/Oceananigans.jl/issues/1453:462,Availability,error,errors,462,"I was thinking it might be cool/useful to inform users if their model is physically/numerically consistent. One example of this is to check that the boundary conditions being imposed match the grid topology (#890). But I think there are many more. Some examples:; * Using `BetaPlane` on a periodic grid.; * Using `WENO5` on a curvilinear grid.; * Using a free surface when z is `Periodic`.; * Using an `FFTBasedPressureSolver` on a curvilinear grid.; * ... Some errors are more likely to be made by users than others of course. But I don't think we can expect users to just know that e.g. `WENO5` doesn't work with `VerticallyStretchedRectilinearGrid` yet. To save ourselves and users some potential future headaches, it seems like we could create a function like `check_consistency(model)` that would perform these checks and print a warning for each inconsistency detected. Unfortunately this could become a pretty ugly monolithic function that's hard to modularize since we're checking the consistency of many different structs acting together.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453
https://github.com/CliMA/Oceananigans.jl/issues/1453:802,Performance,perform,perform,802,"I was thinking it might be cool/useful to inform users if their model is physically/numerically consistent. One example of this is to check that the boundary conditions being imposed match the grid topology (#890). But I think there are many more. Some examples:; * Using `BetaPlane` on a periodic grid.; * Using `WENO5` on a curvilinear grid.; * Using a free surface when z is `Periodic`.; * Using an `FFTBasedPressureSolver` on a curvilinear grid.; * ... Some errors are more likely to be made by users than others of course. But I don't think we can expect users to just know that e.g. `WENO5` doesn't work with `VerticallyStretchedRectilinearGrid` yet. To save ourselves and users some potential future headaches, it seems like we could create a function like `check_consistency(model)` that would perform these checks and print a warning for each inconsistency detected. Unfortunately this could become a pretty ugly monolithic function that's hard to modularize since we're checking the consistency of many different structs acting together.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453
https://github.com/CliMA/Oceananigans.jl/issues/1453:866,Safety,detect,detected,866,"I was thinking it might be cool/useful to inform users if their model is physically/numerically consistent. One example of this is to check that the boundary conditions being imposed match the grid topology (#890). But I think there are many more. Some examples:; * Using `BetaPlane` on a periodic grid.; * Using `WENO5` on a curvilinear grid.; * Using a free surface when z is `Periodic`.; * Using an `FFTBasedPressureSolver` on a curvilinear grid.; * ... Some errors are more likely to be made by users than others of course. But I don't think we can expect users to just know that e.g. `WENO5` doesn't work with `VerticallyStretchedRectilinearGrid` yet. To save ourselves and users some potential future headaches, it seems like we could create a function like `check_consistency(model)` that would perform these checks and print a warning for each inconsistency detected. Unfortunately this could become a pretty ugly monolithic function that's hard to modularize since we're checking the consistency of many different structs acting together.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453
https://github.com/CliMA/Oceananigans.jl/issues/1455:270,Availability,error,errors,270,"I started to learn about how to make docs today and found the instructions [here](https://clima.github.io/OceananigansDocumentation/stable/contributing/) very helpful. . I commented out all of the examples except for two and then ran it but found a bunch of `docstring` errors. It turns out that when I set `doctest` and `strict` to `false`, then things work. But I presume there is still a problem that needs to be resolved. First, when I tried making the docs I found the following message. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```. Then when I tried it again I found a bunch of the following `Error: doctest failure in src/model_setup/output_writers.md:55-76`. . Anyone have an idea as to what I might be doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455
https://github.com/CliMA/Oceananigans.jl/issues/1455:537,Availability,ERROR,ERROR,537,"I started to learn about how to make docs today and found the instructions [here](https://clima.github.io/OceananigansDocumentation/stable/contributing/) very helpful. . I commented out all of the examples except for two and then ran it but found a bunch of `docstring` errors. It turns out that when I set `doctest` and `strict` to `false`, then things work. But I presume there is still a problem that needs to be resolved. First, when I tried making the docs I found the following message. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```. Then when I tried it again I found a bunch of the following `Error: doctest failure in src/model_setup/output_writers.md:55-76`. . Anyone have an idea as to what I might be doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455
https://github.com/CliMA/Oceananigans.jl/issues/1455:581,Availability,error,error,581,"I started to learn about how to make docs today and found the instructions [here](https://clima.github.io/OceananigansDocumentation/stable/contributing/) very helpful. . I commented out all of the examples except for two and then ran it but found a bunch of `docstring` errors. It turns out that when I set `doctest` and `strict` to `false`, then things work. But I presume there is still a problem that needs to be resolved. First, when I tried making the docs I found the following message. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```. Then when I tried it again I found a bunch of the following `Error: doctest failure in src/model_setup/output_writers.md:55-76`. . Anyone have an idea as to what I might be doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455
https://github.com/CliMA/Oceananigans.jl/issues/1455:624,Availability,error,error,624,"I started to learn about how to make docs today and found the instructions [here](https://clima.github.io/OceananigansDocumentation/stable/contributing/) very helpful. . I commented out all of the examples except for two and then ran it but found a bunch of `docstring` errors. It turns out that when I set `doctest` and `strict` to `false`, then things work. But I presume there is still a problem that needs to be resolved. First, when I tried making the docs I found the following message. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```. Then when I tried it again I found a bunch of the following `Error: doctest failure in src/model_setup/output_writers.md:55-76`. . Anyone have an idea as to what I might be doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455
https://github.com/CliMA/Oceananigans.jl/issues/1455:645,Availability,error,error,645,"I started to learn about how to make docs today and found the instructions [here](https://clima.github.io/OceananigansDocumentation/stable/contributing/) very helpful. . I commented out all of the examples except for two and then ran it but found a bunch of `docstring` errors. It turns out that when I set `doctest` and `strict` to `false`, then things work. But I presume there is still a problem that needs to be resolved. First, when I tried making the docs I found the following message. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```. Then when I tried it again I found a bunch of the following `Error: doctest failure in src/model_setup/output_writers.md:55-76`. . Anyone have an idea as to what I might be doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455
https://github.com/CliMA/Oceananigans.jl/issues/1455:1698,Availability,Error,Error,1698,"I started to learn about how to make docs today and found the instructions [here](https://clima.github.io/OceananigansDocumentation/stable/contributing/) very helpful. . I commented out all of the examples except for two and then ran it but found a bunch of `docstring` errors. It turns out that when I set `doctest` and `strict` to `false`, then things work. But I presume there is still a problem that needs to be resolved. First, when I tried making the docs I found the following message. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```. Then when I tried it again I found a bunch of the following `Error: doctest failure in src/model_setup/output_writers.md:55-76`. . Anyone have an idea as to what I might be doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455
https://github.com/CliMA/Oceananigans.jl/issues/1455:1713,Availability,failure,failure,1713,"I started to learn about how to make docs today and found the instructions [here](https://clima.github.io/OceananigansDocumentation/stable/contributing/) very helpful. . I commented out all of the examples except for two and then ran it but found a bunch of `docstring` errors. It turns out that when I set `doctest` and `strict` to `false`, then things work. But I presume there is still a problem that needs to be resolved. First, when I tried making the docs I found the following message. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```. Then when I tried it again I found a bunch of the following `Error: doctest failure in src/model_setup/output_writers.md:55-76`. . Anyone have an idea as to what I might be doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455
https://github.com/CliMA/Oceananigans.jl/issues/1455:484,Integrability,message,message,484,"I started to learn about how to make docs today and found the instructions [here](https://clima.github.io/OceananigansDocumentation/stable/contributing/) very helpful. . I commented out all of the examples except for two and then ran it but found a bunch of `docstring` errors. It turns out that when I set `doctest` and `strict` to `false`, then things work. But I presume there is still a problem that needs to be resolved. First, when I tried making the docs I found the following message. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```. Then when I tried it again I found a bunch of the following `Error: doctest failure in src/model_setup/output_writers.md:55-76`. . Anyone have an idea as to what I might be doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455
https://github.com/CliMA/Oceananigans.jl/issues/1455:544,Performance,Load,LoadError,544,"I started to learn about how to make docs today and found the instructions [here](https://clima.github.io/OceananigansDocumentation/stable/contributing/) very helpful. . I commented out all of the examples except for two and then ran it but found a bunch of `docstring` errors. It turns out that when I set `doctest` and `strict` to `false`, then things work. But I presume there is still a problem that needs to be resolved. First, when I tried making the docs I found the following message. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```. Then when I tried it again I found a bunch of the following `Error: doctest failure in src/model_setup/output_writers.md:55-76`. . Anyone have an idea as to what I might be doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455
https://github.com/CliMA/Oceananigans.jl/issues/1455:13,Usability,learn,learn,13,"I started to learn about how to make docs today and found the instructions [here](https://clima.github.io/OceananigansDocumentation/stable/contributing/) very helpful. . I commented out all of the examples except for two and then ran it but found a bunch of `docstring` errors. It turns out that when I set `doctest` and `strict` to `false`, then things work. But I presume there is still a problem that needs to be resolved. First, when I tried making the docs I found the following message. ```; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Utilities/Selectors.jl:170; [4] #2 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:249 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /home/fpoulin/.julia/packages/Documenter/lul8Y/src/Documenter.jl:248 [inlined]; [7] top-level scope at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/docs/make.jl:137; ```. Then when I tried it again I found a bunch of the following `Error: doctest failure in src/model_setup/output_writers.md:55-76`. . Anyone have an idea as to what I might be doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1455
https://github.com/CliMA/Oceananigans.jl/issues/1458:28,Energy Efficiency,adapt,adapt,28,It should be pretty easy to adapt `correct_incompressible_immersed_tendencies.jl` to create `correct_shallow_water_immersed_tendencies.jl` to this features to `ShallowWaterModel`. It may also make it easier to test the immersed boundary method as there is no need for a pressure solve in simulating the equations.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1458
https://github.com/CliMA/Oceananigans.jl/issues/1458:28,Modifiability,adapt,adapt,28,It should be pretty easy to adapt `correct_incompressible_immersed_tendencies.jl` to create `correct_shallow_water_immersed_tendencies.jl` to this features to `ShallowWaterModel`. It may also make it easier to test the immersed boundary method as there is no need for a pressure solve in simulating the equations.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1458
https://github.com/CliMA/Oceananigans.jl/issues/1458:210,Testability,test,test,210,It should be pretty easy to adapt `correct_incompressible_immersed_tendencies.jl` to create `correct_shallow_water_immersed_tendencies.jl` to this features to `ShallowWaterModel`. It may also make it easier to test the immersed boundary method as there is no need for a pressure solve in simulating the equations.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1458
https://github.com/CliMA/Oceananigans.jl/issues/1459:39,Security,validat,validation,39,"See, e.g., the Stratified Couette flow validation section in Docs: . <img width=""750"" alt=""Screen Shot 2021-03-13 at 4 44 11 pm"" src=""https://user-images.githubusercontent.com/7112768/111020624-6e090380-841b-11eb-8658-1130d560d86b.png"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1459
https://github.com/CliMA/Oceananigans.jl/issues/1460:76,Availability,down,down,76,I think it's time to have something there. At lease a docs page that writes down the equations solved and the state variables... cc @francispoulin,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1460
https://github.com/CliMA/Oceananigans.jl/issues/1460:116,Modifiability,variab,variables,116,I think it's time to have something there. At lease a docs page that writes down the equations solved and the state variables... cc @francispoulin,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1460
https://github.com/CliMA/Oceananigans.jl/issues/1461:156,Deployability,pipeline,pipeline,156,"Should we change to 1.5.4 and be on the ""bleeding edge""?; https://github.com/CliMA/Oceananigans.jl/blob/26ce05b232259f69a858a45fbcf62e3d778cb195/.buildkite/pipeline.yml#L2. cc @maleadt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1461
https://github.com/CliMA/Oceananigans.jl/issues/1462:161,Integrability,message,message,161,"In the [Bickley jet example](https://clima.github.io/OceananigansDocumentation/dev/generated/Bickley_jet_shallow_water/), where we run the simulation we get the message:; ```julia; [ Info: Simulation is stopping. Model time 2.500 minutes has hit or exceeded simulation stop time 2.500 minutes.; ```; This is because we construct the simulation; ```julia; Simulation(model, Δt = 1e-2, stop_time = 150); ```; it's assumed that 150 is 150 seconds. That could be a bit confusing. Is there is a way to tell the `Simulation` constructor that our units are nondimensional? Should we have such option?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1462
https://github.com/CliMA/Oceananigans.jl/pull/1463:0,Deployability,Update,Updates,0,Updates buildkite to use Julia v1.5.4. Closes #1461.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1463
https://github.com/CliMA/Oceananigans.jl/pull/1464:397,Safety,predict,prediction,397,"There are always leftover typos :). @francispoulin, I tried to use your repo to compute the most unstable mode for k=1 and I couldn't do it...; Could you tell me what the actual growth rate for `k = 1` is? I remember 0.138? Am I right? We should report the theoretical growth rate for `k = 1` that fits this domain (and not the overall maximum growth rate) and then compare that with the best-fit prediction. What do you think?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1464
https://github.com/CliMA/Oceananigans.jl/issues/1465:320,Availability,ERROR,ERROR,320,"I'm trying to validate a tilted bottom boundary layer example for https://github.com/CliMA/Oceananigans.jl/pull/1242 and I'm trying to use a `VerticallyStretchedGrid` to save computational resource (since I'm trying to do it on my laptop). I noticed that the simulation fails when using the `TimeStepWizard`:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field Δz; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] cell_advection_timescale(::Array{Float64,3}, ::Array{Float64,3}, ::Array{Float64,3}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}) at /home/tomas/repos2/Oceananigans.jl/src/Utils/cell_advection_timescale.jl:9; [3] cell_advection_timescale(::IncompressibleModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},Bou",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1465
https://github.com/CliMA/Oceananigans.jl/issues/1465:52281,Integrability,rout,routine,52281,"ZeroField,Oceananigans.Fields.ZeroField}}}},Nothing,Nothing},TimeStepWizard{Float64},Array{Any,1},Float64,Float64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(print_progress),Int64,Nothing}) at /home/tomas/repos2/Oceananigans.jl/src/Simulations/run.jl:127; [7] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; [8] include(::String) at ./client.jl:457; [9] top-level scope at REPL[1]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; ```. This is the MWE I'm running:. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz), ; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,; halo=(3,3,3)); ; ; model = IncompressibleModel(grid = grid,; ); ; wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=10,; ). run!(simulation); ```. The bug in question seems to be in the `cell_advection_timescale` routine: https://github.com/CliMA/Oceananigans.jl/blob/c34e6cd2166bbaa057186ffa795d348c1802485f/src/Utils/cell_advection_timescale.jl#L2-L9. I'm not sure the best way to solve this. Ideally we'd calculate the CFL in each point and get the largest values, but that's expensive. Getting the global max of velocity and the global min of Δz also seems like it could be very inaccurate, since the max in velocity could be happening very far from the min in Δz. Maybe a good compromise would be to calculate CFL as a function of `z` and returning the max?. CC: @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1465
https://github.com/CliMA/Oceananigans.jl/issues/1465:51286,Modifiability,sandbox,sandbox,51286,"fsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},Array{Int64,1},Array{Periodic,1},Int64,Nothing,Nothing},Oceananigans.Solvers.DiscreteTransform{Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing}}}}},Nothing,NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}},Nothing,Nothing},TimeStepWizard{Float64},Array{Any,1},Float64,Float64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(print_progress),Int64,Nothing}) at /home/tomas/repos2/Oceananigans.jl/src/Simulations/run.jl:127; [7] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; [8] include(::String) at ./client.jl:457; [9] top-level scope at REPL[1]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; ```. This is the MWE I'm running:. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz), ; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,; halo=(3,3,3)); ; ; model = IncompressibleModel(grid = grid,; ); ; wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=10,; ). run!(simulation); ```. The bug in question seems to be in the `cell_advection_timescale` routine: htt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1465
https://github.com/CliMA/Oceananigans.jl/issues/1465:51446,Modifiability,sandbox,sandbox,51446,"64,1}}},Array{Int64,1},Array{Periodic,1},Int64,Nothing,Nothing},Oceananigans.Solvers.DiscreteTransform{Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing}}}}},Nothing,NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}},Nothing,Nothing},TimeStepWizard{Float64},Array{Any,1},Float64,Float64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(print_progress),Int64,Nothing}) at /home/tomas/repos2/Oceananigans.jl/src/Simulations/run.jl:127; [7] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; [8] include(::String) at ./client.jl:457; [9] top-level scope at REPL[1]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; ```. This is the MWE I'm running:. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz), ; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,; halo=(3,3,3)); ; ; model = IncompressibleModel(grid = grid,; ); ; wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=10,; ). run!(simulation); ```. The bug in question seems to be in the `cell_advection_timescale` routine: https://github.com/CliMA/Oceananigans.jl/blob/c34e6cd2166bbaa057186ffa795d348c1802485f/src/Utils/cell_advection_timescale.jl#L2-L9. I'm not sure the best way to so",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1465
https://github.com/CliMA/Oceananigans.jl/issues/1465:327,Performance,Load,LoadError,327,"I'm trying to validate a tilted bottom boundary layer example for https://github.com/CliMA/Oceananigans.jl/pull/1242 and I'm trying to use a `VerticallyStretchedGrid` to save computational resource (since I'm trying to do it on my laptop). I noticed that the simulation fails when using the `TimeStepWizard`:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field Δz; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] cell_advection_timescale(::Array{Float64,3}, ::Array{Float64,3}, ::Array{Float64,3}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}) at /home/tomas/repos2/Oceananigans.jl/src/Utils/cell_advection_timescale.jl:9; [3] cell_advection_timescale(::IncompressibleModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},Bou",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1465
https://github.com/CliMA/Oceananigans.jl/issues/1465:14,Security,validat,validate,14,"I'm trying to validate a tilted bottom boundary layer example for https://github.com/CliMA/Oceananigans.jl/pull/1242 and I'm trying to use a `VerticallyStretchedGrid` to save computational resource (since I'm trying to do it on my laptop). I noticed that the simulation fails when using the `TimeStepWizard`:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field Δz; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] cell_advection_timescale(::Array{Float64,3}, ::Array{Float64,3}, ::Array{Float64,3}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}) at /home/tomas/repos2/Oceananigans.jl/src/Utils/cell_advection_timescale.jl:9; [3] cell_advection_timescale(::IncompressibleModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},Bou",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1465
https://github.com/CliMA/Oceananigans.jl/issues/1465:51286,Testability,sandbox,sandbox,51286,"fsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},Array{Int64,1},Array{Periodic,1},Int64,Nothing,Nothing},Oceananigans.Solvers.DiscreteTransform{Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing}}}}},Nothing,NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}},Nothing,Nothing},TimeStepWizard{Float64},Array{Any,1},Float64,Float64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(print_progress),Int64,Nothing}) at /home/tomas/repos2/Oceananigans.jl/src/Simulations/run.jl:127; [7] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; [8] include(::String) at ./client.jl:457; [9] top-level scope at REPL[1]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; ```. This is the MWE I'm running:. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz), ; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,; halo=(3,3,3)); ; ; model = IncompressibleModel(grid = grid,; ); ; wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=10,; ). run!(simulation); ```. The bug in question seems to be in the `cell_advection_timescale` routine: htt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1465
https://github.com/CliMA/Oceananigans.jl/issues/1465:51446,Testability,sandbox,sandbox,51446,"64,1}}},Array{Int64,1},Array{Periodic,1},Int64,Nothing,Nothing},Oceananigans.Solvers.DiscreteTransform{Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing}}}}},Nothing,NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}},Nothing,Nothing},TimeStepWizard{Float64},Array{Any,1},Float64,Float64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(print_progress),Int64,Nothing}) at /home/tomas/repos2/Oceananigans.jl/src/Simulations/run.jl:127; [7] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; [8] include(::String) at ./client.jl:457; [9] top-level scope at REPL[1]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; ```. This is the MWE I'm running:. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz), ; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,; halo=(3,3,3)); ; ; model = IncompressibleModel(grid = grid,; ); ; wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=10,; ). run!(simulation); ```. The bug in question seems to be in the `cell_advection_timescale` routine: https://github.com/CliMA/Oceananigans.jl/blob/c34e6cd2166bbaa057186ffa795d348c1802485f/src/Utils/cell_advection_timescale.jl#L2-L9. I'm not sure the best way to so",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1465
https://github.com/CliMA/Oceananigans.jl/issues/1466:204,Availability,error,error,204,"Related to https://github.com/CliMA/Oceananigans.jl/issues/1465. When fixing the MWE I gave in https://github.com/CliMA/Oceananigans.jl/issues/1465 but outputting things with a NetCDFWriter I also get an error:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field xC; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] default_dimensions(::Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},B} where B where Z where Y where X}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::FieldSlicer{Colon,Colon,Colon}) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:38; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},Coordi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466
https://github.com/CliMA/Oceananigans.jl/issues/1466:222,Availability,ERROR,ERROR,222,"Related to https://github.com/CliMA/Oceananigans.jl/issues/1465. When fixing the MWE I gave in https://github.com/CliMA/Oceananigans.jl/issues/1465 but outputting things with a NetCDFWriter I also get an error:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field xC; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] default_dimensions(::Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},B} where B where Z where Y where X}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::FieldSlicer{Colon,Colon,Colon}) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:38; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},Coordi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466
https://github.com/CliMA/Oceananigans.jl/issues/1466:16051,Energy Efficiency,schedul,schedule,16051,"Conditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Center,Center,Face,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[2]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:30; ```. But also, I anticipate there are more bugs waiting to be found with `VerticallyStretchedGrids`. If I issue the command `grep -r ""\<Δz\>"" *` (which basically looks for instances of `Δz` and excludes `Δzᵃᵃᶜ` and `Δzᵃᵃᶠ`) and I get this:. ```; ~/repos2/Oceananigans.jl/src$ grep -r ""\<Δz\>"" *; Fields/interpolate.jl:@inline fractional_z_index(z, ::Center, grid::RegularRectilinearGrid) = @inbounds (z - grid.zC[1]) / grid.Δz; Fields/interpolate.jl:@inline fractional_z_index(z, ::Face, grid::Re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466
https://github.com/CliMA/Oceananigans.jl/issues/1466:16437,Modifiability,sandbox,sandbox,16437,"4,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[2]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:30; ```. But also, I anticipate there are more bugs waiting to be found with `VerticallyStretchedGrids`. If I issue the command `grep -r ""\<Δz\>"" *` (which basically looks for instances of `Δz` and excludes `Δzᵃᵃᶜ` and `Δzᵃᵃᶠ`) and I get this:. ```; ~/repos2/Oceananigans.jl/src$ grep -r ""\<Δz\>"" *; Fields/interpolate.jl:@inline fractional_z_index(z, ::Center, grid::RegularRectilinearGrid) = @inbounds (z - grid.zC[1]) / grid.Δz; Fields/interpolate.jl:@inline fractional_z_index(z, ::Face, grid::RegularRectilinearGrid) = @inbounds (z - grid.zF[1]) / grid.Δz; Grids/regular_latitude_longitude_grid.jl: Δz :: FT; Grids/regular_latitude_longitude_grid.jl: Δλ, Δϕ, Δz = Δ = @. L / N; Grids/regular_latitude_longitude_grid.jl: return RegularLatitudeLongitudeGrid{FT, TX, TY, TZ, typeof(λᶠᵃᵃ)}(Nλ, Nϕ, Nz, Hλ, Hϕ, Hz, Lλ, Lϕ, Lz, Δ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466
https://github.com/CliMA/Oceananigans.jl/issues/1466:16597,Modifiability,sandbox,sandbox,16597,"daryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[2]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:30; ```. But also, I anticipate there are more bugs waiting to be found with `VerticallyStretchedGrids`. If I issue the command `grep -r ""\<Δz\>"" *` (which basically looks for instances of `Δz` and excludes `Δzᵃᵃᶜ` and `Δzᵃᵃᶠ`) and I get this:. ```; ~/repos2/Oceananigans.jl/src$ grep -r ""\<Δz\>"" *; Fields/interpolate.jl:@inline fractional_z_index(z, ::Center, grid::RegularRectilinearGrid) = @inbounds (z - grid.zC[1]) / grid.Δz; Fields/interpolate.jl:@inline fractional_z_index(z, ::Face, grid::RegularRectilinearGrid) = @inbounds (z - grid.zF[1]) / grid.Δz; Grids/regular_latitude_longitude_grid.jl: Δz :: FT; Grids/regular_latitude_longitude_grid.jl: Δλ, Δϕ, Δz = Δ = @. L / N; Grids/regular_latitude_longitude_grid.jl: return RegularLatitudeLongitudeGrid{FT, TX, TY, TZ, typeof(λᶠᵃᵃ)}(Nλ, Nϕ, Nz, Hλ, Hϕ, Hz, Lλ, Lϕ, Lz, Δλ, Δϕ, Δz, λᶠᵃᵃ, λᶜᵃᵃ, ϕᵃᶠᵃ, ϕᵃᶜᵃ, zᵃᵃᶠ, zᵃᵃᶜ, radius); Grids/regular_latitude_longitude_grid.jl: ""grid spacing (Δλ, Δϕ, Δz): "", (g.Δλ, g.Δϕ, g.Δz)); Grids/regu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466
https://github.com/CliMA/Oceananigans.jl/issues/1466:229,Performance,Load,LoadError,229,"Related to https://github.com/CliMA/Oceananigans.jl/issues/1465. When fixing the MWE I gave in https://github.com/CliMA/Oceananigans.jl/issues/1465 but outputting things with a NetCDFWriter I also get an error:. ```julia; ERROR: LoadError: type VerticallyStretchedRectilinearGrid has no field xC; Stacktrace:; [1] getproperty(::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::Symbol) at ./Base.jl:33; [2] default_dimensions(::Dict{String,Field{X,Y,Z,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},B} where B where Z where Y where X}, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::FieldSlicer{Colon,Colon,Colon}) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:38; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},Coordi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466
https://github.com/CliMA/Oceananigans.jl/issues/1466:16437,Testability,sandbox,sandbox,16437,"4,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[2]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:30; ```. But also, I anticipate there are more bugs waiting to be found with `VerticallyStretchedGrids`. If I issue the command `grep -r ""\<Δz\>"" *` (which basically looks for instances of `Δz` and excludes `Δzᵃᵃᶜ` and `Δzᵃᵃᶠ`) and I get this:. ```; ~/repos2/Oceananigans.jl/src$ grep -r ""\<Δz\>"" *; Fields/interpolate.jl:@inline fractional_z_index(z, ::Center, grid::RegularRectilinearGrid) = @inbounds (z - grid.zC[1]) / grid.Δz; Fields/interpolate.jl:@inline fractional_z_index(z, ::Face, grid::RegularRectilinearGrid) = @inbounds (z - grid.zF[1]) / grid.Δz; Grids/regular_latitude_longitude_grid.jl: Δz :: FT; Grids/regular_latitude_longitude_grid.jl: Δλ, Δϕ, Δz = Δ = @. L / N; Grids/regular_latitude_longitude_grid.jl: return RegularLatitudeLongitudeGrid{FT, TX, TY, TZ, typeof(λᶠᵃᵃ)}(Nλ, Nϕ, Nz, Hλ, Hϕ, Hz, Lλ, Lϕ, Lz, Δ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466
https://github.com/CliMA/Oceananigans.jl/issues/1466:16597,Testability,sandbox,sandbox,16597,"daryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[2]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:30; ```. But also, I anticipate there are more bugs waiting to be found with `VerticallyStretchedGrids`. If I issue the command `grep -r ""\<Δz\>"" *` (which basically looks for instances of `Δz` and excludes `Δzᵃᵃᶜ` and `Δzᵃᵃᶠ`) and I get this:. ```; ~/repos2/Oceananigans.jl/src$ grep -r ""\<Δz\>"" *; Fields/interpolate.jl:@inline fractional_z_index(z, ::Center, grid::RegularRectilinearGrid) = @inbounds (z - grid.zC[1]) / grid.Δz; Fields/interpolate.jl:@inline fractional_z_index(z, ::Face, grid::RegularRectilinearGrid) = @inbounds (z - grid.zF[1]) / grid.Δz; Grids/regular_latitude_longitude_grid.jl: Δz :: FT; Grids/regular_latitude_longitude_grid.jl: Δλ, Δϕ, Δz = Δ = @. L / N; Grids/regular_latitude_longitude_grid.jl: return RegularLatitudeLongitudeGrid{FT, TX, TY, TZ, typeof(λᶠᵃᵃ)}(Nλ, Nϕ, Nz, Hλ, Hϕ, Hz, Lλ, Lϕ, Lz, Δλ, Δϕ, Δz, λᶠᵃᵃ, λᶜᵃᵃ, ϕᵃᶠᵃ, ϕᵃᶜᵃ, zᵃᵃᶠ, zᵃᵃᶜ, radius); Grids/regular_latitude_longitude_grid.jl: ""grid spacing (Δλ, Δϕ, Δz): "", (g.Δλ, g.Δϕ, g.Δz)); Grids/regu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466
https://github.com/CliMA/Oceananigans.jl/issues/1468:115,Availability,error,error,115,I just installed Oceananigans on a server that has GPUs and is running julia 1.1.1. When I try and update I get an error saying that the package name could no be resolved. ```; (v1.1) pkg> update Oceanigans; Updating registry at `~/.julia/registries/General`; Updating git-repo `https://github.com/JuliaRegistries/General.git`; ERROR: The following package names could not be resolved:; * Oceanigans (not found in project or manifest); Please specify by known `name=uuid`.; ```. Could this be because of the old version of julia? I have asked if they can update it but no idea if they will.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468
https://github.com/CliMA/Oceananigans.jl/issues/1468:328,Availability,ERROR,ERROR,328,I just installed Oceananigans on a server that has GPUs and is running julia 1.1.1. When I try and update I get an error saying that the package name could no be resolved. ```; (v1.1) pkg> update Oceanigans; Updating registry at `~/.julia/registries/General`; Updating git-repo `https://github.com/JuliaRegistries/General.git`; ERROR: The following package names could not be resolved:; * Oceanigans (not found in project or manifest); Please specify by known `name=uuid`.; ```. Could this be because of the old version of julia? I have asked if they can update it but no idea if they will.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468
https://github.com/CliMA/Oceananigans.jl/issues/1468:7,Deployability,install,installed,7,I just installed Oceananigans on a server that has GPUs and is running julia 1.1.1. When I try and update I get an error saying that the package name could no be resolved. ```; (v1.1) pkg> update Oceanigans; Updating registry at `~/.julia/registries/General`; Updating git-repo `https://github.com/JuliaRegistries/General.git`; ERROR: The following package names could not be resolved:; * Oceanigans (not found in project or manifest); Please specify by known `name=uuid`.; ```. Could this be because of the old version of julia? I have asked if they can update it but no idea if they will.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468
https://github.com/CliMA/Oceananigans.jl/issues/1468:99,Deployability,update,update,99,I just installed Oceananigans on a server that has GPUs and is running julia 1.1.1. When I try and update I get an error saying that the package name could no be resolved. ```; (v1.1) pkg> update Oceanigans; Updating registry at `~/.julia/registries/General`; Updating git-repo `https://github.com/JuliaRegistries/General.git`; ERROR: The following package names could not be resolved:; * Oceanigans (not found in project or manifest); Please specify by known `name=uuid`.; ```. Could this be because of the old version of julia? I have asked if they can update it but no idea if they will.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468
https://github.com/CliMA/Oceananigans.jl/issues/1468:189,Deployability,update,update,189,I just installed Oceananigans on a server that has GPUs and is running julia 1.1.1. When I try and update I get an error saying that the package name could no be resolved. ```; (v1.1) pkg> update Oceanigans; Updating registry at `~/.julia/registries/General`; Updating git-repo `https://github.com/JuliaRegistries/General.git`; ERROR: The following package names could not be resolved:; * Oceanigans (not found in project or manifest); Please specify by known `name=uuid`.; ```. Could this be because of the old version of julia? I have asked if they can update it but no idea if they will.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468
https://github.com/CliMA/Oceananigans.jl/issues/1468:555,Deployability,update,update,555,I just installed Oceananigans on a server that has GPUs and is running julia 1.1.1. When I try and update I get an error saying that the package name could no be resolved. ```; (v1.1) pkg> update Oceanigans; Updating registry at `~/.julia/registries/General`; Updating git-repo `https://github.com/JuliaRegistries/General.git`; ERROR: The following package names could not be resolved:; * Oceanigans (not found in project or manifest); Please specify by known `name=uuid`.; ```. Could this be because of the old version of julia? I have asked if they can update it but no idea if they will.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1468
https://github.com/CliMA/Oceananigans.jl/pull/1472:163,Testability,test,tested,163,"This pull request changes the compat entry for the `MPI` package from `0.16` to `0.16, 0.17`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1472
https://github.com/CliMA/Oceananigans.jl/pull/1472:268,Testability,test,tests,268,"This pull request changes the compat entry for the `MPI` package from `0.16` to `0.16, 0.17`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1472
https://github.com/CliMA/Oceananigans.jl/pull/1474:435,Availability,down,downstream,435,"This pull request sets the compat entry for the `CubedSphere` package to `0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `CubedSphere` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1474
https://github.com/CliMA/Oceananigans.jl/pull/1474:383,Deployability,patch,patch,383,"This pull request sets the compat entry for the `CubedSphere` package to `0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `CubedSphere` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1474
https://github.com/CliMA/Oceananigans.jl/pull/1474:389,Deployability,release,release,389,"This pull request sets the compat entry for the `CubedSphere` package to `0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `CubedSphere` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1474
https://github.com/CliMA/Oceananigans.jl/pull/1474:459,Integrability,depend,depend,459,"This pull request sets the compat entry for the `CubedSphere` package to `0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `CubedSphere` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1474
https://github.com/CliMA/Oceananigans.jl/pull/1474:206,Testability,test,tested,206,"This pull request sets the compat entry for the `CubedSphere` package to `0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `CubedSphere` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1474
https://github.com/CliMA/Oceananigans.jl/pull/1474:311,Testability,test,tests,311,"This pull request sets the compat entry for the `CubedSphere` package to `0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `CubedSphere` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1474
https://github.com/CliMA/Oceananigans.jl/pull/1474:478,Testability,test,tests,478,"This pull request sets the compat entry for the `CubedSphere` package to `0.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `CubedSphere` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1474
https://github.com/CliMA/Oceananigans.jl/pull/1475:431,Availability,down,downstream,431,"This pull request sets the compat entry for the `Rotations` package to `1.0`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Rotations` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1475
https://github.com/CliMA/Oceananigans.jl/pull/1475:379,Deployability,patch,patch,379,"This pull request sets the compat entry for the `Rotations` package to `1.0`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Rotations` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1475
https://github.com/CliMA/Oceananigans.jl/pull/1475:385,Deployability,release,release,385,"This pull request sets the compat entry for the `Rotations` package to `1.0`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Rotations` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1475
https://github.com/CliMA/Oceananigans.jl/pull/1475:455,Integrability,depend,depend,455,"This pull request sets the compat entry for the `Rotations` package to `1.0`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Rotations` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1475
https://github.com/CliMA/Oceananigans.jl/pull/1475:202,Testability,test,tested,202,"This pull request sets the compat entry for the `Rotations` package to `1.0`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Rotations` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1475
https://github.com/CliMA/Oceananigans.jl/pull/1475:307,Testability,test,tests,307,"This pull request sets the compat entry for the `Rotations` package to `1.0`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Rotations` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1475
https://github.com/CliMA/Oceananigans.jl/pull/1475:474,Testability,test,tests,474,"This pull request sets the compat entry for the `Rotations` package to `1.0`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Rotations` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider tagging a patch release immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1475
https://github.com/CliMA/Oceananigans.jl/issues/1477:315,Availability,error,error,315,"I took the shallow water Bickley jet example and made two modifications. I added `using CUDA` and changed the architecture to `GPU` and tried running it on my desktop. The GPU is nothing fancy but there is something and I thought that it should, based on previous tests. Unfortunately, `run!(simulation)` yields an error that you can find below. I also tried this on a server and found a similar error. Two questions.; 1. Could someone else try this in a GPU to see if they get an error?; 2. Anyone have a clue as to what id going wrong in this error?. ```; $ julia --project shallow_water_Bickley_jet.jl ; ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 129, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 9, 1)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields.gpu__compute!), OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}}, Oceananigans.AbstractOperations.BinaryOperation{Face,Face,Center,typeof(-),OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}},Oceananigans.Fields.FunctionField{Face,Face,Center,Nothing,Nothing,typeof(ω̄),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); Stacktrace:; [1] - at /home/fpoulin/software/Oceananigans.jl/src/AbstractOpe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477
https://github.com/CliMA/Oceananigans.jl/issues/1477:396,Availability,error,error,396,"I took the shallow water Bickley jet example and made two modifications. I added `using CUDA` and changed the architecture to `GPU` and tried running it on my desktop. The GPU is nothing fancy but there is something and I thought that it should, based on previous tests. Unfortunately, `run!(simulation)` yields an error that you can find below. I also tried this on a server and found a similar error. Two questions.; 1. Could someone else try this in a GPU to see if they get an error?; 2. Anyone have a clue as to what id going wrong in this error?. ```; $ julia --project shallow_water_Bickley_jet.jl ; ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 129, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 9, 1)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields.gpu__compute!), OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}}, Oceananigans.AbstractOperations.BinaryOperation{Face,Face,Center,typeof(-),OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}},Oceananigans.Fields.FunctionField{Face,Face,Center,Nothing,Nothing,typeof(ω̄),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); Stacktrace:; [1] - at /home/fpoulin/software/Oceananigans.jl/src/AbstractOpe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477
https://github.com/CliMA/Oceananigans.jl/issues/1477:481,Availability,error,error,481,"I took the shallow water Bickley jet example and made two modifications. I added `using CUDA` and changed the architecture to `GPU` and tried running it on my desktop. The GPU is nothing fancy but there is something and I thought that it should, based on previous tests. Unfortunately, `run!(simulation)` yields an error that you can find below. I also tried this on a server and found a similar error. Two questions.; 1. Could someone else try this in a GPU to see if they get an error?; 2. Anyone have a clue as to what id going wrong in this error?. ```; $ julia --project shallow_water_Bickley_jet.jl ; ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 129, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 9, 1)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields.gpu__compute!), OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}}, Oceananigans.AbstractOperations.BinaryOperation{Face,Face,Center,typeof(-),OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}},Oceananigans.Fields.FunctionField{Face,Face,Center,Nothing,Nothing,typeof(ω̄),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); Stacktrace:; [1] - at /home/fpoulin/software/Oceananigans.jl/src/AbstractOpe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477
https://github.com/CliMA/Oceananigans.jl/issues/1477:545,Availability,error,error,545,"I took the shallow water Bickley jet example and made two modifications. I added `using CUDA` and changed the architecture to `GPU` and tried running it on my desktop. The GPU is nothing fancy but there is something and I thought that it should, based on previous tests. Unfortunately, `run!(simulation)` yields an error that you can find below. I also tried this on a server and found a similar error. Two questions.; 1. Could someone else try this in a GPU to see if they get an error?; 2. Anyone have a clue as to what id going wrong in this error?. ```; $ julia --project shallow_water_Bickley_jet.jl ; ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 129, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 9, 1)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields.gpu__compute!), OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}}, Oceananigans.AbstractOperations.BinaryOperation{Face,Face,Center,typeof(-),OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}},Oceananigans.Fields.FunctionField{Face,Face,Center,Nothing,Nothing,typeof(ω̄),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); Stacktrace:; [1] - at /home/fpoulin/software/Oceananigans.jl/src/AbstractOpe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477
https://github.com/CliMA/Oceananigans.jl/issues/1477:607,Availability,ERROR,ERROR,607,"I took the shallow water Bickley jet example and made two modifications. I added `using CUDA` and changed the architecture to `GPU` and tried running it on my desktop. The GPU is nothing fancy but there is something and I thought that it should, based on previous tests. Unfortunately, `run!(simulation)` yields an error that you can find below. I also tried this on a server and found a similar error. Two questions.; 1. Could someone else try this in a GPU to see if they get an error?; 2. Anyone have a clue as to what id going wrong in this error?. ```; $ julia --project shallow_water_Bickley_jet.jl ; ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 129, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 9, 1)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields.gpu__compute!), OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}}, Oceananigans.AbstractOperations.BinaryOperation{Face,Face,Center,typeof(-),OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}},Oceananigans.Fields.FunctionField{Face,Face,Center,Nothing,Nothing,typeof(ω̄),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); Stacktrace:; [1] - at /home/fpoulin/software/Oceananigans.jl/src/AbstractOpe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477
https://github.com/CliMA/Oceananigans.jl/issues/1477:614,Performance,Load,LoadError,614,"I took the shallow water Bickley jet example and made two modifications. I added `using CUDA` and changed the architecture to `GPU` and tried running it on my desktop. The GPU is nothing fancy but there is something and I thought that it should, based on previous tests. Unfortunately, `run!(simulation)` yields an error that you can find below. I also tried this on a server and found a similar error. Two questions.; 1. Could someone else try this in a GPU to see if they get an error?; 2. Anyone have a clue as to what id going wrong in this error?. ```; $ julia --project shallow_water_Bickley_jet.jl ; ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 129, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 9, 1)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields.gpu__compute!), OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}}, Oceananigans.AbstractOperations.BinaryOperation{Face,Face,Center,typeof(-),OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}},Oceananigans.Fields.FunctionField{Face,Face,Center,Nothing,Nothing,typeof(ω̄),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); Stacktrace:; [1] - at /home/fpoulin/software/Oceananigans.jl/src/AbstractOpe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477
https://github.com/CliMA/Oceananigans.jl/issues/1477:264,Testability,test,tests,264,"I took the shallow water Bickley jet example and made two modifications. I added `using CUDA` and changed the architecture to `GPU` and tried running it on my desktop. The GPU is nothing fancy but there is something and I thought that it should, based on previous tests. Unfortunately, `run!(simulation)` yields an error that you can find below. I also tried this on a server and found a similar error. Two questions.; 1. Could someone else try this in a GPU to see if they get an error?; 2. Anyone have a clue as to what id going wrong in this error?. ```; $ julia --project shallow_water_Bickley_jet.jl ; ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 129, 1)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 9, 1)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.Fields.gpu__compute!), OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}}, Oceananigans.AbstractOperations.BinaryOperation{Face,Face,Center,typeof(-),OffsetArrays.OffsetArray{Float64,3,CuDeviceArray{Float64,3,1}},Oceananigans.Fields.FunctionField{Face,Face,Center,Nothing,Nothing,typeof(ω̄),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); Stacktrace:; [1] - at /home/fpoulin/software/Oceananigans.jl/src/AbstractOpe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477
https://github.com/CliMA/Oceananigans.jl/issues/1478:221,Availability,error,error,221,"There are a few gotchas when setting up GPU simulations so it's not always as simple as just changing `CPU` to `GPU`, mainly related to things the GPU compiler does not like. A common one that produces a very non-obvious error is using global variables in forcing functions or any function that will get used in a GPU kernel (e.g. https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733435704 and https://github.com/CliMA/Oceananigans.jl/issues/1477). Might be helpful for users if we add a section or page to the docs that describes these issues.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478
https://github.com/CliMA/Oceananigans.jl/issues/1478:243,Modifiability,variab,variables,243,"There are a few gotchas when setting up GPU simulations so it's not always as simple as just changing `CPU` to `GPU`, mainly related to things the GPU compiler does not like. A common one that produces a very non-obvious error is using global variables in forcing functions or any function that will get used in a GPU kernel (e.g. https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733435704 and https://github.com/CliMA/Oceananigans.jl/issues/1477). Might be helpful for users if we add a section or page to the docs that describes these issues.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478
https://github.com/CliMA/Oceananigans.jl/issues/1478:78,Usability,simpl,simple,78,"There are a few gotchas when setting up GPU simulations so it's not always as simple as just changing `CPU` to `GPU`, mainly related to things the GPU compiler does not like. A common one that produces a very non-obvious error is using global variables in forcing functions or any function that will get used in a GPU kernel (e.g. https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733435704 and https://github.com/CliMA/Oceananigans.jl/issues/1477). Might be helpful for users if we add a section or page to the docs that describes these issues.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478
https://github.com/CliMA/Oceananigans.jl/issues/1479:108,Security,access,access,108,"Inspired by #1477 , I think it's worthwhile to add `norm` to supported functions, which will allow users to access it more easily on CPUs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1479
https://github.com/CliMA/Oceananigans.jl/pull/1480:839,Integrability,depend,depends,839,"This PR adds a validation experiment as suggested by @christophernhill and @jm-c to add a very small Gaussian sea surface height η perturbation in the northern hemisphere of the cubed sphere face and watch it evolve. There is no rotation/Coriolis and no diffusivity right now to test the simplest model possible (so η just splashes around as expected). Next step would be to turn on rotation, diffusivity, and the implicit free surface. Might have to generalize some things, e.g. Coriolis, to non-regular curvilinear grids like `ConformalCubedSphereFaceGrid`. So I guess the main purpose of this PR is to make sure the cubed sphere face works, so maybe the validation experiment won't make it into the final version of this PR. https://user-images.githubusercontent.com/20099589/111330144-139fbb00-8646-11eb-9598-a0e18e88280b.mp4. This PR depends on PR #1433. Will `git rebase main` once it's merged.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1480
https://github.com/CliMA/Oceananigans.jl/pull/1480:209,Modifiability,evolve,evolve,209,"This PR adds a validation experiment as suggested by @christophernhill and @jm-c to add a very small Gaussian sea surface height η perturbation in the northern hemisphere of the cubed sphere face and watch it evolve. There is no rotation/Coriolis and no diffusivity right now to test the simplest model possible (so η just splashes around as expected). Next step would be to turn on rotation, diffusivity, and the implicit free surface. Might have to generalize some things, e.g. Coriolis, to non-regular curvilinear grids like `ConformalCubedSphereFaceGrid`. So I guess the main purpose of this PR is to make sure the cubed sphere face works, so maybe the validation experiment won't make it into the final version of this PR. https://user-images.githubusercontent.com/20099589/111330144-139fbb00-8646-11eb-9598-a0e18e88280b.mp4. This PR depends on PR #1433. Will `git rebase main` once it's merged.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1480
https://github.com/CliMA/Oceananigans.jl/pull/1480:15,Security,validat,validation,15,"This PR adds a validation experiment as suggested by @christophernhill and @jm-c to add a very small Gaussian sea surface height η perturbation in the northern hemisphere of the cubed sphere face and watch it evolve. There is no rotation/Coriolis and no diffusivity right now to test the simplest model possible (so η just splashes around as expected). Next step would be to turn on rotation, diffusivity, and the implicit free surface. Might have to generalize some things, e.g. Coriolis, to non-regular curvilinear grids like `ConformalCubedSphereFaceGrid`. So I guess the main purpose of this PR is to make sure the cubed sphere face works, so maybe the validation experiment won't make it into the final version of this PR. https://user-images.githubusercontent.com/20099589/111330144-139fbb00-8646-11eb-9598-a0e18e88280b.mp4. This PR depends on PR #1433. Will `git rebase main` once it's merged.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1480
https://github.com/CliMA/Oceananigans.jl/pull/1480:657,Security,validat,validation,657,"This PR adds a validation experiment as suggested by @christophernhill and @jm-c to add a very small Gaussian sea surface height η perturbation in the northern hemisphere of the cubed sphere face and watch it evolve. There is no rotation/Coriolis and no diffusivity right now to test the simplest model possible (so η just splashes around as expected). Next step would be to turn on rotation, diffusivity, and the implicit free surface. Might have to generalize some things, e.g. Coriolis, to non-regular curvilinear grids like `ConformalCubedSphereFaceGrid`. So I guess the main purpose of this PR is to make sure the cubed sphere face works, so maybe the validation experiment won't make it into the final version of this PR. https://user-images.githubusercontent.com/20099589/111330144-139fbb00-8646-11eb-9598-a0e18e88280b.mp4. This PR depends on PR #1433. Will `git rebase main` once it's merged.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1480
https://github.com/CliMA/Oceananigans.jl/pull/1480:279,Testability,test,test,279,"This PR adds a validation experiment as suggested by @christophernhill and @jm-c to add a very small Gaussian sea surface height η perturbation in the northern hemisphere of the cubed sphere face and watch it evolve. There is no rotation/Coriolis and no diffusivity right now to test the simplest model possible (so η just splashes around as expected). Next step would be to turn on rotation, diffusivity, and the implicit free surface. Might have to generalize some things, e.g. Coriolis, to non-regular curvilinear grids like `ConformalCubedSphereFaceGrid`. So I guess the main purpose of this PR is to make sure the cubed sphere face works, so maybe the validation experiment won't make it into the final version of this PR. https://user-images.githubusercontent.com/20099589/111330144-139fbb00-8646-11eb-9598-a0e18e88280b.mp4. This PR depends on PR #1433. Will `git rebase main` once it's merged.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1480
https://github.com/CliMA/Oceananigans.jl/pull/1480:288,Usability,simpl,simplest,288,"This PR adds a validation experiment as suggested by @christophernhill and @jm-c to add a very small Gaussian sea surface height η perturbation in the northern hemisphere of the cubed sphere face and watch it evolve. There is no rotation/Coriolis and no diffusivity right now to test the simplest model possible (so η just splashes around as expected). Next step would be to turn on rotation, diffusivity, and the implicit free surface. Might have to generalize some things, e.g. Coriolis, to non-regular curvilinear grids like `ConformalCubedSphereFaceGrid`. So I guess the main purpose of this PR is to make sure the cubed sphere face works, so maybe the validation experiment won't make it into the final version of this PR. https://user-images.githubusercontent.com/20099589/111330144-139fbb00-8646-11eb-9598-a0e18e88280b.mp4. This PR depends on PR #1433. Will `git rebase main` once it's merged.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1480
https://github.com/CliMA/Oceananigans.jl/issues/1483:299,Modifiability,variab,variable,299,"So, I've been running some simulations with a bunch of diagnostics, which make the simulation slower. I think some of the diagnostics that I'm calculating are already being calculated by Oceananigans (like derivatives). If I understand correctly, in each of those cases Oceananigans calculates that variable once to get the tendencies and then does the same calculation again when for my diagnostics, which seems wasteful. Is it possible (or desirable) to create a way for the code not to do the calculation twice if the user wants that diagnostic specifically? Maybe pass options when creating the model like:. ```julia; model = IncompressibleModel(grid, computed_fields=(:dudz, :dvdz,)); ```; so that those fields get stored just like the velocity and the tracers do?. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483
https://github.com/CliMA/Oceananigans.jl/pull/1484:804,Availability,failure,failure,804,"Reverts CliMA/Oceananigans.jl#1444. PR #1444 is quite nice but unfortunately I think the new `fill_halo_regions!`. ```julia; fill_halo_regions!(c::AbstractArray, fieldbcs, grid, args...; kwargs...); ```. broke MPI halo filling since it needs dispatch on. ```julia; fill_halo_regions!(c::AbstractArray, bcs, arch::AbstractMultiArchitecture, grid, c_location, args...); ```. It might be tricky to fix since you can't tell whether you're on `CPU` or `MultiCPU` from inside `fill_halo_regions!` with just knowledge of the `field`... I propose we revert #1444 just for now (since distributed models + tests are broken on master) and immediately open a new PR with the contents of #1444 where we can find a solution. My only idea is to add `architecture` to Field but perhaps it feels a little bloated... This failure was not caught by Buildkite since PR #590 was merged after #1444 was opened, and I think Buildkite only runs tests on branches, not pull requests (i.e. it doesn't merge master and run tests).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1484
https://github.com/CliMA/Oceananigans.jl/pull/1484:596,Testability,test,tests,596,"Reverts CliMA/Oceananigans.jl#1444. PR #1444 is quite nice but unfortunately I think the new `fill_halo_regions!`. ```julia; fill_halo_regions!(c::AbstractArray, fieldbcs, grid, args...; kwargs...); ```. broke MPI halo filling since it needs dispatch on. ```julia; fill_halo_regions!(c::AbstractArray, bcs, arch::AbstractMultiArchitecture, grid, c_location, args...); ```. It might be tricky to fix since you can't tell whether you're on `CPU` or `MultiCPU` from inside `fill_halo_regions!` with just knowledge of the `field`... I propose we revert #1444 just for now (since distributed models + tests are broken on master) and immediately open a new PR with the contents of #1444 where we can find a solution. My only idea is to add `architecture` to Field but perhaps it feels a little bloated... This failure was not caught by Buildkite since PR #590 was merged after #1444 was opened, and I think Buildkite only runs tests on branches, not pull requests (i.e. it doesn't merge master and run tests).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1484
https://github.com/CliMA/Oceananigans.jl/pull/1484:921,Testability,test,tests,921,"Reverts CliMA/Oceananigans.jl#1444. PR #1444 is quite nice but unfortunately I think the new `fill_halo_regions!`. ```julia; fill_halo_regions!(c::AbstractArray, fieldbcs, grid, args...; kwargs...); ```. broke MPI halo filling since it needs dispatch on. ```julia; fill_halo_regions!(c::AbstractArray, bcs, arch::AbstractMultiArchitecture, grid, c_location, args...); ```. It might be tricky to fix since you can't tell whether you're on `CPU` or `MultiCPU` from inside `fill_halo_regions!` with just knowledge of the `field`... I propose we revert #1444 just for now (since distributed models + tests are broken on master) and immediately open a new PR with the contents of #1444 where we can find a solution. My only idea is to add `architecture` to Field but perhaps it feels a little bloated... This failure was not caught by Buildkite since PR #590 was merged after #1444 was opened, and I think Buildkite only runs tests on branches, not pull requests (i.e. it doesn't merge master and run tests).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1484
https://github.com/CliMA/Oceananigans.jl/pull/1484:996,Testability,test,tests,996,"Reverts CliMA/Oceananigans.jl#1444. PR #1444 is quite nice but unfortunately I think the new `fill_halo_regions!`. ```julia; fill_halo_regions!(c::AbstractArray, fieldbcs, grid, args...; kwargs...); ```. broke MPI halo filling since it needs dispatch on. ```julia; fill_halo_regions!(c::AbstractArray, bcs, arch::AbstractMultiArchitecture, grid, c_location, args...); ```. It might be tricky to fix since you can't tell whether you're on `CPU` or `MultiCPU` from inside `fill_halo_regions!` with just knowledge of the `field`... I propose we revert #1444 just for now (since distributed models + tests are broken on master) and immediately open a new PR with the contents of #1444 where we can find a solution. My only idea is to add `architecture` to Field but perhaps it feels a little bloated... This failure was not caught by Buildkite since PR #590 was merged after #1444 was opened, and I think Buildkite only runs tests on branches, not pull requests (i.e. it doesn't merge master and run tests).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1484
https://github.com/CliMA/Oceananigans.jl/pull/1486:8,Deployability,update,updates,8,This PR updates the ancient `test_flux_budget` to be able to test all topologies and boundaries. I've also called it `test_incompressible_flux_budget` since it uses `IncompressibleModel`. This will allow us to generalize `apply_x_bcs` and `apply_y_bcs` to curvilinear grids without fear that we've broken something.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1486
https://github.com/CliMA/Oceananigans.jl/pull/1486:61,Testability,test,test,61,This PR updates the ancient `test_flux_budget` to be able to test all topologies and boundaries. I've also called it `test_incompressible_flux_budget` since it uses `IncompressibleModel`. This will allow us to generalize `apply_x_bcs` and `apply_y_bcs` to curvilinear grids without fear that we've broken something.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1486
https://github.com/CliMA/Oceananigans.jl/pull/1490:115,Testability,test,tests,115,This PR splits up `test_output_writers.jl` into three files since it was getting pretty long and unwieldy and adds tests for `NetCDFOutputWriter` with `VerticallyStretchedRectilinearGrid` and `RegularLatitudeLongitudeGrid` which pass thanks to @tomchor's PR #1487!. cc @mukund-gupta,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1490
https://github.com/CliMA/Oceananigans.jl/issues/1492:87,Modifiability,parameteriz,parameterization,87,"Some time ago @sandreza and @xiaozhour suggested it would be useful to add the GM-Redi parameterization to Oceananigans.jl since we may want to train mesoscale eddy parameterizations. I'm opening this issue to discuss on what exactly needs to be implemented. My main reference is https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html. It seems that there are three different new closures that could potentially be added:; 1. Redi (symmetric) tensor diffusivity.; 2. Gent-McWilliams (anti-symmetric) tensor diffusivity.; 3. GM-Redi combining the two. Note: @glwagner has already implemented parts of the Redi tensor and GM for `TwoDimensionalLeith` so GM-Redi might not need too much extra work: https://github.com/CliMA/Oceananigans.jl/blob/master/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl. # Questions/proposal. 1. Do we make the small-angle approximation? I would say yes. In Oceananigans.jl right now each component of the tensor diffusivity is calculated on-the-fly so the unapproximated tensor could end up being 2-4x more expensive to compute. We cannot compute the full tensor in one go (reusing the isopycnal slopes) and we may not want to since it takes up a lot of memory (9 extra field?). But maybe there's a good reason to not make the small-angle approximation? We could eventually support both (unapproximated and small-angle approximation). See https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#redi-scheme-isopycnal-diffusion for a comparison of the two. 2. Is GM-Redi the main parameterization of interest? Would people use the fully symmetric or the fully anti-symmetric diffusivity tensor by themselves?. If not then maybe we can save some time by just implementing one new closure, `GMRedi` or `GentMcWilliamsRedi`. If we take the isopycnal diffusivity to be the same for both the symmetric and anti-symmetric tensor then we the resulting tensor is quite cheap to compute (only 3 components) if performance is impo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1492
https://github.com/CliMA/Oceananigans.jl/issues/1492:165,Modifiability,parameteriz,parameterizations,165,"Some time ago @sandreza and @xiaozhour suggested it would be useful to add the GM-Redi parameterization to Oceananigans.jl since we may want to train mesoscale eddy parameterizations. I'm opening this issue to discuss on what exactly needs to be implemented. My main reference is https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html. It seems that there are three different new closures that could potentially be added:; 1. Redi (symmetric) tensor diffusivity.; 2. Gent-McWilliams (anti-symmetric) tensor diffusivity.; 3. GM-Redi combining the two. Note: @glwagner has already implemented parts of the Redi tensor and GM for `TwoDimensionalLeith` so GM-Redi might not need too much extra work: https://github.com/CliMA/Oceananigans.jl/blob/master/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl. # Questions/proposal. 1. Do we make the small-angle approximation? I would say yes. In Oceananigans.jl right now each component of the tensor diffusivity is calculated on-the-fly so the unapproximated tensor could end up being 2-4x more expensive to compute. We cannot compute the full tensor in one go (reusing the isopycnal slopes) and we may not want to since it takes up a lot of memory (9 extra field?). But maybe there's a good reason to not make the small-angle approximation? We could eventually support both (unapproximated and small-angle approximation). See https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#redi-scheme-isopycnal-diffusion for a comparison of the two. 2. Is GM-Redi the main parameterization of interest? Would people use the fully symmetric or the fully anti-symmetric diffusivity tensor by themselves?. If not then maybe we can save some time by just implementing one new closure, `GMRedi` or `GentMcWilliamsRedi`. If we take the isopycnal diffusivity to be the same for both the symmetric and anti-symmetric tensor then we the resulting tensor is quite cheap to compute (only 3 components) if performance is impo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1492
https://github.com/CliMA/Oceananigans.jl/issues/1492:1561,Modifiability,parameteriz,parameterization,1561,"to discuss on what exactly needs to be implemented. My main reference is https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html. It seems that there are three different new closures that could potentially be added:; 1. Redi (symmetric) tensor diffusivity.; 2. Gent-McWilliams (anti-symmetric) tensor diffusivity.; 3. GM-Redi combining the two. Note: @glwagner has already implemented parts of the Redi tensor and GM for `TwoDimensionalLeith` so GM-Redi might not need too much extra work: https://github.com/CliMA/Oceananigans.jl/blob/master/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl. # Questions/proposal. 1. Do we make the small-angle approximation? I would say yes. In Oceananigans.jl right now each component of the tensor diffusivity is calculated on-the-fly so the unapproximated tensor could end up being 2-4x more expensive to compute. We cannot compute the full tensor in one go (reusing the isopycnal slopes) and we may not want to since it takes up a lot of memory (9 extra field?). But maybe there's a good reason to not make the small-angle approximation? We could eventually support both (unapproximated and small-angle approximation). See https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#redi-scheme-isopycnal-diffusion for a comparison of the two. 2. Is GM-Redi the main parameterization of interest? Would people use the fully symmetric or the fully anti-symmetric diffusivity tensor by themselves?. If not then maybe we can save some time by just implementing one new closure, `GMRedi` or `GentMcWilliamsRedi`. If we take the isopycnal diffusivity to be the same for both the symmetric and anti-symmetric tensor then we the resulting tensor is quite cheap to compute (only 3 components) if performance is important:. From https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#griffies-skew-flux; ![image](https://user-images.githubusercontent.com/20099589/111556957-1abbeb80-8762-11eb-9fb3-870d447efa5f.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1492
https://github.com/CliMA/Oceananigans.jl/issues/1492:1982,Performance,perform,performance,1982,"to discuss on what exactly needs to be implemented. My main reference is https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html. It seems that there are three different new closures that could potentially be added:; 1. Redi (symmetric) tensor diffusivity.; 2. Gent-McWilliams (anti-symmetric) tensor diffusivity.; 3. GM-Redi combining the two. Note: @glwagner has already implemented parts of the Redi tensor and GM for `TwoDimensionalLeith` so GM-Redi might not need too much extra work: https://github.com/CliMA/Oceananigans.jl/blob/master/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl. # Questions/proposal. 1. Do we make the small-angle approximation? I would say yes. In Oceananigans.jl right now each component of the tensor diffusivity is calculated on-the-fly so the unapproximated tensor could end up being 2-4x more expensive to compute. We cannot compute the full tensor in one go (reusing the isopycnal slopes) and we may not want to since it takes up a lot of memory (9 extra field?). But maybe there's a good reason to not make the small-angle approximation? We could eventually support both (unapproximated and small-angle approximation). See https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#redi-scheme-isopycnal-diffusion for a comparison of the two. 2. Is GM-Redi the main parameterization of interest? Would people use the fully symmetric or the fully anti-symmetric diffusivity tensor by themselves?. If not then maybe we can save some time by just implementing one new closure, `GMRedi` or `GentMcWilliamsRedi`. If we take the isopycnal diffusivity to be the same for both the symmetric and anti-symmetric tensor then we the resulting tensor is quite cheap to compute (only 3 components) if performance is important:. From https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#griffies-skew-flux; ![image](https://user-images.githubusercontent.com/20099589/111556957-1abbeb80-8762-11eb-9fb3-870d447efa5f.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1492
https://github.com/CliMA/Oceananigans.jl/issues/1493:1064,Availability,down,down,1064,"discussions with @glwagner that have over time convinced me that adding some native post-processing and data analysis capabilities to Oceananigans.jl by relying on `Oceananigans.AbstractOperations` under the hood would be a killer feature. This would eventually allow users to compute new/complex terms, close budgets, etc. on any grid without worrying about the staggered grid. So it might finally fulfill the dream of going from idea -> model/simulation -> analysis -> paper purely in Julia and (most importantly) without needing to know anything about the staggered grid. Since the interface remains very similar between the different models and grid, this could potentially allow future users to easily switch between different equation sets and grids while keeping the same analysis script. I thought we opened an issue about this but I can't seem to find it so maybe not? Either way this has been on my mind lately (and would help quite a bit with OceanParameterizations.jl) so I thought I'd write down some thoughts. # Plan?. The main feature would be the ability to construct `Field`s from output. Then the machinery of `Oceananigans.AbstractOperations` is available! Some extra quality-of-life features would allow for a more xarray-like experience such as named axis behavior (#457) through https://github.com/rafaqz/DimensionalData.jl. Maybe the easiest thing would be to first create a new field, `TimeSeriesField` or something with a `DimensionalData.DimArray` under the hood, that stores (x, y, z, t) data from a file and works with abstract operations?. # Some thoughts. 1. It's probably easiest to add support for constructing fields from JLD2 first then NetCDF.; 2. Complex abstract operations on the GPU can fail but most data analysis is done on the CPU so #1241 probably won't be an issue.; 3. While there is some overlap with xgcm support (#1334) these two issues are quite orthogonal. Why not both!; 4. We might have to find a way of lazily loading data from disk with Dimension",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493
https://github.com/CliMA/Oceananigans.jl/issues/1493:1225,Availability,avail,available,1225,"r feature. This would eventually allow users to compute new/complex terms, close budgets, etc. on any grid without worrying about the staggered grid. So it might finally fulfill the dream of going from idea -> model/simulation -> analysis -> paper purely in Julia and (most importantly) without needing to know anything about the staggered grid. Since the interface remains very similar between the different models and grid, this could potentially allow future users to easily switch between different equation sets and grids while keeping the same analysis script. I thought we opened an issue about this but I can't seem to find it so maybe not? Either way this has been on my mind lately (and would help quite a bit with OceanParameterizations.jl) so I thought I'd write down some thoughts. # Plan?. The main feature would be the ability to construct `Field`s from output. Then the machinery of `Oceananigans.AbstractOperations` is available! Some extra quality-of-life features would allow for a more xarray-like experience such as named axis behavior (#457) through https://github.com/rafaqz/DimensionalData.jl. Maybe the easiest thing would be to first create a new field, `TimeSeriesField` or something with a `DimensionalData.DimArray` under the hood, that stores (x, y, z, t) data from a file and works with abstract operations?. # Some thoughts. 1. It's probably easiest to add support for constructing fields from JLD2 first then NetCDF.; 2. Complex abstract operations on the GPU can fail but most data analysis is done on the CPU so #1241 probably won't be an issue.; 3. While there is some overlap with xgcm support (#1334) these two issues are quite orthogonal. Why not both!; 4. We might have to find a way of lazily loading data from disk with DimensionalData.jl so we can analyze large datasets without loading the complete dataset into memory, but this could come later.; 5. One of the big features of xarray is that together with Dask you can analyze huge datasets that do not fi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493
https://github.com/CliMA/Oceananigans.jl/issues/1493:2809,Energy Efficiency,power,power,2809,"ed an issue about this but I can't seem to find it so maybe not? Either way this has been on my mind lately (and would help quite a bit with OceanParameterizations.jl) so I thought I'd write down some thoughts. # Plan?. The main feature would be the ability to construct `Field`s from output. Then the machinery of `Oceananigans.AbstractOperations` is available! Some extra quality-of-life features would allow for a more xarray-like experience such as named axis behavior (#457) through https://github.com/rafaqz/DimensionalData.jl. Maybe the easiest thing would be to first create a new field, `TimeSeriesField` or something with a `DimensionalData.DimArray` under the hood, that stores (x, y, z, t) data from a file and works with abstract operations?. # Some thoughts. 1. It's probably easiest to add support for constructing fields from JLD2 first then NetCDF.; 2. Complex abstract operations on the GPU can fail but most data analysis is done on the CPU so #1241 probably won't be an issue.; 3. While there is some overlap with xgcm support (#1334) these two issues are quite orthogonal. Why not both!; 4. We might have to find a way of lazily loading data from disk with DimensionalData.jl so we can analyze large datasets without loading the complete dataset into memory, but this could come later.; 5. One of the big features of xarray is that together with Dask you can analyze huge datasets that do not fit in memory using many cores quite quickly. This is probably not possible with Julia right now (maybe with Dagger.jl in the future), but it seems that this might be an edge case. Most users will probably be able to get by with lazily loading data from disk?. # Example?. I was thinking what would be a good example would be to showcase this feature. The example could show how to go from math -> setup -> simulation -> analysis -> results. So it would have to be pretty simple but with enough complexity to showcase the power of the framework. So probably no closing of TKE budgets...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493
https://github.com/CliMA/Oceananigans.jl/issues/1493:645,Integrability,interface,interface,645,"# Motivation. This issue is a summary of some not-so-recent discussions with @glwagner that have over time convinced me that adding some native post-processing and data analysis capabilities to Oceananigans.jl by relying on `Oceananigans.AbstractOperations` under the hood would be a killer feature. This would eventually allow users to compute new/complex terms, close budgets, etc. on any grid without worrying about the staggered grid. So it might finally fulfill the dream of going from idea -> model/simulation -> analysis -> paper purely in Julia and (most importantly) without needing to know anything about the staggered grid. Since the interface remains very similar between the different models and grid, this could potentially allow future users to easily switch between different equation sets and grids while keeping the same analysis script. I thought we opened an issue about this but I can't seem to find it so maybe not? Either way this has been on my mind lately (and would help quite a bit with OceanParameterizations.jl) so I thought I'd write down some thoughts. # Plan?. The main feature would be the ability to construct `Field`s from output. Then the machinery of `Oceananigans.AbstractOperations` is available! Some extra quality-of-life features would allow for a more xarray-like experience such as named axis behavior (#457) through https://github.com/rafaqz/DimensionalData.jl. Maybe the easiest thing would be to first create a new field, `TimeSeriesField` or something with a `DimensionalData.DimArray` under the hood, that stores (x, y, z, t) data from a file and works with abstract operations?. # Some thoughts. 1. It's probably easiest to add support for constructing fields from JLD2 first then NetCDF.; 2. Complex abstract operations on the GPU can fail but most data analysis is done on the CPU so #1241 probably won't be an issue.; 3. While there is some overlap with xgcm support (#1334) these two issues are quite orthogonal. Why not both!; 4. We might have to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493
https://github.com/CliMA/Oceananigans.jl/issues/1493:2023,Performance,load,loading,2023,"ed an issue about this but I can't seem to find it so maybe not? Either way this has been on my mind lately (and would help quite a bit with OceanParameterizations.jl) so I thought I'd write down some thoughts. # Plan?. The main feature would be the ability to construct `Field`s from output. Then the machinery of `Oceananigans.AbstractOperations` is available! Some extra quality-of-life features would allow for a more xarray-like experience such as named axis behavior (#457) through https://github.com/rafaqz/DimensionalData.jl. Maybe the easiest thing would be to first create a new field, `TimeSeriesField` or something with a `DimensionalData.DimArray` under the hood, that stores (x, y, z, t) data from a file and works with abstract operations?. # Some thoughts. 1. It's probably easiest to add support for constructing fields from JLD2 first then NetCDF.; 2. Complex abstract operations on the GPU can fail but most data analysis is done on the CPU so #1241 probably won't be an issue.; 3. While there is some overlap with xgcm support (#1334) these two issues are quite orthogonal. Why not both!; 4. We might have to find a way of lazily loading data from disk with DimensionalData.jl so we can analyze large datasets without loading the complete dataset into memory, but this could come later.; 5. One of the big features of xarray is that together with Dask you can analyze huge datasets that do not fit in memory using many cores quite quickly. This is probably not possible with Julia right now (maybe with Dagger.jl in the future), but it seems that this might be an edge case. Most users will probably be able to get by with lazily loading data from disk?. # Example?. I was thinking what would be a good example would be to showcase this feature. The example could show how to go from math -> setup -> simulation -> analysis -> results. So it would have to be pretty simple but with enough complexity to showcase the power of the framework. So probably no closing of TKE budgets...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493
https://github.com/CliMA/Oceananigans.jl/issues/1493:2111,Performance,load,loading,2111,"ed an issue about this but I can't seem to find it so maybe not? Either way this has been on my mind lately (and would help quite a bit with OceanParameterizations.jl) so I thought I'd write down some thoughts. # Plan?. The main feature would be the ability to construct `Field`s from output. Then the machinery of `Oceananigans.AbstractOperations` is available! Some extra quality-of-life features would allow for a more xarray-like experience such as named axis behavior (#457) through https://github.com/rafaqz/DimensionalData.jl. Maybe the easiest thing would be to first create a new field, `TimeSeriesField` or something with a `DimensionalData.DimArray` under the hood, that stores (x, y, z, t) data from a file and works with abstract operations?. # Some thoughts. 1. It's probably easiest to add support for constructing fields from JLD2 first then NetCDF.; 2. Complex abstract operations on the GPU can fail but most data analysis is done on the CPU so #1241 probably won't be an issue.; 3. While there is some overlap with xgcm support (#1334) these two issues are quite orthogonal. Why not both!; 4. We might have to find a way of lazily loading data from disk with DimensionalData.jl so we can analyze large datasets without loading the complete dataset into memory, but this could come later.; 5. One of the big features of xarray is that together with Dask you can analyze huge datasets that do not fit in memory using many cores quite quickly. This is probably not possible with Julia right now (maybe with Dagger.jl in the future), but it seems that this might be an edge case. Most users will probably be able to get by with lazily loading data from disk?. # Example?. I was thinking what would be a good example would be to showcase this feature. The example could show how to go from math -> setup -> simulation -> analysis -> results. So it would have to be pretty simple but with enough complexity to showcase the power of the framework. So probably no closing of TKE budgets...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493
https://github.com/CliMA/Oceananigans.jl/issues/1493:2523,Performance,load,loading,2523,"ed an issue about this but I can't seem to find it so maybe not? Either way this has been on my mind lately (and would help quite a bit with OceanParameterizations.jl) so I thought I'd write down some thoughts. # Plan?. The main feature would be the ability to construct `Field`s from output. Then the machinery of `Oceananigans.AbstractOperations` is available! Some extra quality-of-life features would allow for a more xarray-like experience such as named axis behavior (#457) through https://github.com/rafaqz/DimensionalData.jl. Maybe the easiest thing would be to first create a new field, `TimeSeriesField` or something with a `DimensionalData.DimArray` under the hood, that stores (x, y, z, t) data from a file and works with abstract operations?. # Some thoughts. 1. It's probably easiest to add support for constructing fields from JLD2 first then NetCDF.; 2. Complex abstract operations on the GPU can fail but most data analysis is done on the CPU so #1241 probably won't be an issue.; 3. While there is some overlap with xgcm support (#1334) these two issues are quite orthogonal. Why not both!; 4. We might have to find a way of lazily loading data from disk with DimensionalData.jl so we can analyze large datasets without loading the complete dataset into memory, but this could come later.; 5. One of the big features of xarray is that together with Dask you can analyze huge datasets that do not fit in memory using many cores quite quickly. This is probably not possible with Julia right now (maybe with Dagger.jl in the future), but it seems that this might be an edge case. Most users will probably be able to get by with lazily loading data from disk?. # Example?. I was thinking what would be a good example would be to showcase this feature. The example could show how to go from math -> setup -> simulation -> analysis -> results. So it would have to be pretty simple but with enough complexity to showcase the power of the framework. So probably no closing of TKE budgets...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493
https://github.com/CliMA/Oceananigans.jl/issues/1493:2759,Usability,simpl,simple,2759,"ed an issue about this but I can't seem to find it so maybe not? Either way this has been on my mind lately (and would help quite a bit with OceanParameterizations.jl) so I thought I'd write down some thoughts. # Plan?. The main feature would be the ability to construct `Field`s from output. Then the machinery of `Oceananigans.AbstractOperations` is available! Some extra quality-of-life features would allow for a more xarray-like experience such as named axis behavior (#457) through https://github.com/rafaqz/DimensionalData.jl. Maybe the easiest thing would be to first create a new field, `TimeSeriesField` or something with a `DimensionalData.DimArray` under the hood, that stores (x, y, z, t) data from a file and works with abstract operations?. # Some thoughts. 1. It's probably easiest to add support for constructing fields from JLD2 first then NetCDF.; 2. Complex abstract operations on the GPU can fail but most data analysis is done on the CPU so #1241 probably won't be an issue.; 3. While there is some overlap with xgcm support (#1334) these two issues are quite orthogonal. Why not both!; 4. We might have to find a way of lazily loading data from disk with DimensionalData.jl so we can analyze large datasets without loading the complete dataset into memory, but this could come later.; 5. One of the big features of xarray is that together with Dask you can analyze huge datasets that do not fit in memory using many cores quite quickly. This is probably not possible with Julia right now (maybe with Dagger.jl in the future), but it seems that this might be an edge case. Most users will probably be able to get by with lazily loading data from disk?. # Example?. I was thinking what would be a good example would be to showcase this feature. The example could show how to go from math -> setup -> simulation -> analysis -> results. So it would have to be pretty simple but with enough complexity to showcase the power of the framework. So probably no closing of TKE budgets...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493
https://github.com/CliMA/Oceananigans.jl/pull/1494:446,Usability,clear,clear,446,"This changes the behavior of `show()` for VerticallyStretchedGrids to. ```julia; VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 500.0], y ∈ [0.0, 23.4375], z ∈ [0.0, 100.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (128, 1, 32); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (3.90625, 23.4375, [min=0.97654576571653, max=5.174919985099578]); ```. This is very clear but also a bit on the verbose side. Another option would be. ```julia; VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 500.0], y ∈ [0.0, 23.4375], z ∈ [0.0, 100.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (128, 1, 32); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (3.90625, 23.4375, [0.97654576571653, 5.174919985099578]); ```. and then the `min` and `max` are implicit. I'm happy to change to whatever is preferred. CC @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1494
https://github.com/CliMA/Oceananigans.jl/issues/1496:297,Availability,down,down,297,"So, only now am I realizing that maybe the name `gravitational_unit_vector` is misleading since it points the opposite way as it should. . I think what we had in mind was the vertical unit vector, which should point up, but we ended up naming it `gravitational_unit_vector`, which actually points down! I suggest a change to `vertical_unit_vector` which is more in line with what we want, and also the same name can be used when we implement that tilting of the Coriolis parameter. So a user could set-up a simulation as. ```julia; model = IncompressibleModel(grid, buoyancy = Buoyancy(model=BuoyancyTracer(), vertical_unit_vector=g̃),; coriolis = FPlane(f=1e-4, vertical_unit_vector=g̃,); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1496
https://github.com/CliMA/Oceananigans.jl/pull/1497:541,Availability,down,down,541,"This PR adds a new function `accurate_cell_advection_timescale` that is used to compute CFL at every grid point then reduced to find the maximum (which is the correct way as discussed in #1201). It will allow us to use the `TimeStepWizard` for adaptive time-stepping on all grids. I'll also extend it to `ShallowWaterModel` before merging. So it works great and scales well on the CPU but not so well on the GPU (see below). At 256^3, `cfl(model)` takes as long as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497
https://github.com/CliMA/Oceananigans.jl/pull/1497:1181,Availability,down,down,1181,"ow us to use the `TimeStepWizard` for adaptive time-stepping on all grids. I'll also extend it to `ShallowWaterModel` before merging. So it works great and scales well on the CPU but not so well on the GPU (see below). At 256^3, `cfl(model)` takes as long as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 2.632 ms (7058 allocations: 820.19 KiB). julia> @btime cfl(model); 1.294 ms (257 allocations: 25.36 KiB); ```. ```; julia> model.architecture; CPU(). julia> size(grid); (256, 256, 256). ju",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497
https://github.com/CliMA/Oceananigans.jl/pull/1497:1455,Availability,down,download,1455,"ng as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 2.632 ms (7058 allocations: 820.19 KiB). julia> @btime cfl(model); 1.294 ms (257 allocations: 25.36 KiB); ```. ```; julia> model.architecture; CPU(). julia> size(grid); (256, 256, 256). julia> @btime time_step!(model, 1); 3.378 s (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 134.737 ms (10 allocations: 4.16 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (256, 256, 256). julia> @btime time_step!(model, 1)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497
https://github.com/CliMA/Oceananigans.jl/pull/1497:1591,Availability,avail,available,1591,"ing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 2.632 ms (7058 allocations: 820.19 KiB). julia> @btime cfl(model); 1.294 ms (257 allocations: 25.36 KiB); ```. ```; julia> model.architecture; CPU(). julia> size(grid); (256, 256, 256). julia> @btime time_step!(model, 1); 3.378 s (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 134.737 ms (10 allocations: 4.16 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (256, 256, 256). julia> @btime time_step!(model, 1); 22.507 ms (7066 allocations: 1.09 MiB). julia> @btime cfl(model); 128.361 ms (257 allocations: 41.53 KiB); ```. Resol",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497
https://github.com/CliMA/Oceananigans.jl/pull/1497:117,Energy Efficiency,reduce,reduced,117,"This PR adds a new function `accurate_cell_advection_timescale` that is used to compute CFL at every grid point then reduced to find the maximum (which is the correct way as discussed in #1201). It will allow us to use the `TimeStepWizard` for adaptive time-stepping on all grids. I'll also extend it to `ShallowWaterModel` before merging. So it works great and scales well on the CPU but not so well on the GPU (see below). At 256^3, `cfl(model)` takes as long as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497
https://github.com/CliMA/Oceananigans.jl/pull/1497:244,Energy Efficiency,adapt,adaptive,244,"This PR adds a new function `accurate_cell_advection_timescale` that is used to compute CFL at every grid point then reduced to find the maximum (which is the correct way as discussed in #1201). It will allow us to use the `TimeStepWizard` for adaptive time-stepping on all grids. I'll also extend it to `ShallowWaterModel` before merging. So it works great and scales well on the CPU but not so well on the GPU (see below). At 256^3, `cfl(model)` takes as long as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497
https://github.com/CliMA/Oceananigans.jl/pull/1497:546,Energy Efficiency,adapt,adaptive,546,"This PR adds a new function `accurate_cell_advection_timescale` that is used to compute CFL at every grid point then reduced to find the maximum (which is the correct way as discussed in #1201). It will allow us to use the `TimeStepWizard` for adaptive time-stepping on all grids. I'll also extend it to `ShallowWaterModel` before merging. So it works great and scales well on the CPU but not so well on the GPU (see below). At 256^3, `cfl(model)` takes as long as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497
https://github.com/CliMA/Oceananigans.jl/pull/1497:654,Energy Efficiency,adapt,adaptive,654,"This PR adds a new function `accurate_cell_advection_timescale` that is used to compute CFL at every grid point then reduced to find the maximum (which is the correct way as discussed in #1201). It will allow us to use the `TimeStepWizard` for adaptive time-stepping on all grids. I'll also extend it to `ShallowWaterModel` before merging. So it works great and scales well on the CPU but not so well on the GPU (see below). At 256^3, `cfl(model)` takes as long as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497
https://github.com/CliMA/Oceananigans.jl/pull/1497:1171,Energy Efficiency,reduce,reduce,1171,"ow us to use the `TimeStepWizard` for adaptive time-stepping on all grids. I'll also extend it to `ShallowWaterModel` before merging. So it works great and scales well on the CPU but not so well on the GPU (see below). At 256^3, `cfl(model)` takes as long as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 2.632 ms (7058 allocations: 820.19 KiB). julia> @btime cfl(model); 1.294 ms (257 allocations: 25.36 KiB); ```. ```; julia> model.architecture; CPU(). julia> size(grid); (256, 256, 256). ju",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497
https://github.com/CliMA/Oceananigans.jl/pull/1497:1266,Energy Efficiency,reduce,reduce,1266,"ow us to use the `TimeStepWizard` for adaptive time-stepping on all grids. I'll also extend it to `ShallowWaterModel` before merging. So it works great and scales well on the CPU but not so well on the GPU (see below). At 256^3, `cfl(model)` takes as long as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 2.632 ms (7058 allocations: 820.19 KiB). julia> @btime cfl(model); 1.294 ms (257 allocations: 25.36 KiB); ```. ```; julia> model.architecture; CPU(). julia> size(grid); (256, 256, 256). ju",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497
https://github.com/CliMA/Oceananigans.jl/pull/1497:244,Modifiability,adapt,adaptive,244,"This PR adds a new function `accurate_cell_advection_timescale` that is used to compute CFL at every grid point then reduced to find the maximum (which is the correct way as discussed in #1201). It will allow us to use the `TimeStepWizard` for adaptive time-stepping on all grids. I'll also extend it to `ShallowWaterModel` before merging. So it works great and scales well on the CPU but not so well on the GPU (see below). At 256^3, `cfl(model)` takes as long as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497
https://github.com/CliMA/Oceananigans.jl/pull/1497:291,Modifiability,extend,extend,291,"This PR adds a new function `accurate_cell_advection_timescale` that is used to compute CFL at every grid point then reduced to find the maximum (which is the correct way as discussed in #1201). It will allow us to use the `TimeStepWizard` for adaptive time-stepping on all grids. I'll also extend it to `ShallowWaterModel` before merging. So it works great and scales well on the CPU but not so well on the GPU (see below). At 256^3, `cfl(model)` takes as long as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497
https://github.com/CliMA/Oceananigans.jl/pull/1497:546,Modifiability,adapt,adaptive,546,"This PR adds a new function `accurate_cell_advection_timescale` that is used to compute CFL at every grid point then reduced to find the maximum (which is the correct way as discussed in #1201). It will allow us to use the `TimeStepWizard` for adaptive time-stepping on all grids. I'll also extend it to `ShallowWaterModel` before merging. So it works great and scales well on the CPU but not so well on the GPU (see below). At 256^3, `cfl(model)` takes as long as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497
https://github.com/CliMA/Oceananigans.jl/pull/1497:654,Modifiability,adapt,adaptive,654,"This PR adds a new function `accurate_cell_advection_timescale` that is used to compute CFL at every grid point then reduced to find the maximum (which is the correct way as discussed in #1201). It will allow us to use the `TimeStepWizard` for adaptive time-stepping on all grids. I'll also extend it to `ShallowWaterModel` before merging. So it works great and scales well on the CPU but not so well on the GPU (see below). At 256^3, `cfl(model)` takes as long as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497
https://github.com/CliMA/Oceananigans.jl/pull/1497:1372,Performance,optimiz,optimizing,1372," GPU (see below). At 256^3, `cfl(model)` takes as long as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 2.632 ms (7058 allocations: 820.19 KiB). julia> @btime cfl(model); 1.294 ms (257 allocations: 25.36 KiB); ```. ```; julia> model.architecture; CPU(). julia> size(grid); (256, 256, 256). julia> @btime time_step!(model, 1); 3.378 s (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 134.737 ms (10 allocations: 4.16 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid);",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497
https://github.com/CliMA/Oceananigans.jl/pull/1497:1561,Performance,optimiz,optimized,1561,"ing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 2.632 ms (7058 allocations: 820.19 KiB). julia> @btime cfl(model); 1.294 ms (257 allocations: 25.36 KiB); ```. ```; julia> model.architecture; CPU(). julia> size(grid); (256, 256, 256). julia> @btime time_step!(model, 1); 3.378 s (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 134.737 ms (10 allocations: 4.16 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (256, 256, 256). julia> @btime time_step!(model, 1); 22.507 ms (7066 allocations: 1.09 MiB). julia> @btime cfl(model); 128.361 ms (257 allocations: 41.53 KiB); ```. Resol",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497
https://github.com/CliMA/Oceananigans.jl/pull/1498:44,Security,validat,validation,44,This PR adds a tilted bottom boundary layer validation based on one of the simulations in [this paper](https://journals.ametsoc.org/view/journals/phoc/50/6/JPO-D-20-0027.1.xml). This is only a draft for now! (So not ready for review.) In particular I still need to. - [x] Add a sponge layer to the top.; - [x] Confirm that the result is still qualitatively correct; - [x] Add a tilted coriolis acceleration (implemented in #1892). This example renders here: https://clima.github.io/OceananigansDocumentation/previews/PR1498/generated/tilted_bottom_boundary_layer/. CC: @wenegrat,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498
https://github.com/CliMA/Oceananigans.jl/issues/1499:83,Energy Efficiency,efficient,efficient,83,"Now that `ShallowWaterModel` is established I think it's important to make it more efficient. At the moment when we use `WENO5`, as I've been doing, we define 3 halo points in each direction. That means that our 1-layer model is really a 7-layer model, which is much more storage than we need. I very much want to remove this so that we can be much more efficient and have the code run faster. I know that #1024 tried to establish a flat dimension for `IncompressibleModel`. This is before my time and I heard multiple people tried doing this and it was a challenge. . I would like to do something independent of #1024, and force that any grid for `ShallowWaterModel` not define halo regions in the vertical and then not fill in those halo regions as it evolves. Below are a list of different things that I think should be done but am very curious to know what people suggest. I haven't tried this so I'm sure there are some details that I have not thought of and hoping to learn from others. - [ ] Maybe define the boundary conditions to be `flat` in the vertical and then try and get flat to work for this model?; - [ ] Maybe in `field_boundary_conditions.jl`, define `uhFluxBoundaryCondtions`, `vhFluxBoundaryCondtions`, `hBoundaryCondtions` that do not do anything to `top` and `bottom`?; - [ ] If we set the number of halos in the vertical to be 0, then we should still be able to use `new_data.jl` without having to modify it?; - [ ] Tell `fill_halo_regions.jl` to not do anything for `bottom` and `top`.; - [ ] If we remove the halos then I don't think we have to modify the tendencies at all so that might be fine.; - [ ] Other things that I've not considered?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499
https://github.com/CliMA/Oceananigans.jl/issues/1499:354,Energy Efficiency,efficient,efficient,354,"Now that `ShallowWaterModel` is established I think it's important to make it more efficient. At the moment when we use `WENO5`, as I've been doing, we define 3 halo points in each direction. That means that our 1-layer model is really a 7-layer model, which is much more storage than we need. I very much want to remove this so that we can be much more efficient and have the code run faster. I know that #1024 tried to establish a flat dimension for `IncompressibleModel`. This is before my time and I heard multiple people tried doing this and it was a challenge. . I would like to do something independent of #1024, and force that any grid for `ShallowWaterModel` not define halo regions in the vertical and then not fill in those halo regions as it evolves. Below are a list of different things that I think should be done but am very curious to know what people suggest. I haven't tried this so I'm sure there are some details that I have not thought of and hoping to learn from others. - [ ] Maybe define the boundary conditions to be `flat` in the vertical and then try and get flat to work for this model?; - [ ] Maybe in `field_boundary_conditions.jl`, define `uhFluxBoundaryCondtions`, `vhFluxBoundaryCondtions`, `hBoundaryCondtions` that do not do anything to `top` and `bottom`?; - [ ] If we set the number of halos in the vertical to be 0, then we should still be able to use `new_data.jl` without having to modify it?; - [ ] Tell `fill_halo_regions.jl` to not do anything for `bottom` and `top`.; - [ ] If we remove the halos then I don't think we have to modify the tendencies at all so that might be fine.; - [ ] Other things that I've not considered?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499
https://github.com/CliMA/Oceananigans.jl/issues/1499:754,Modifiability,evolve,evolves,754,"Now that `ShallowWaterModel` is established I think it's important to make it more efficient. At the moment when we use `WENO5`, as I've been doing, we define 3 halo points in each direction. That means that our 1-layer model is really a 7-layer model, which is much more storage than we need. I very much want to remove this so that we can be much more efficient and have the code run faster. I know that #1024 tried to establish a flat dimension for `IncompressibleModel`. This is before my time and I heard multiple people tried doing this and it was a challenge. . I would like to do something independent of #1024, and force that any grid for `ShallowWaterModel` not define halo regions in the vertical and then not fill in those halo regions as it evolves. Below are a list of different things that I think should be done but am very curious to know what people suggest. I haven't tried this so I'm sure there are some details that I have not thought of and hoping to learn from others. - [ ] Maybe define the boundary conditions to be `flat` in the vertical and then try and get flat to work for this model?; - [ ] Maybe in `field_boundary_conditions.jl`, define `uhFluxBoundaryCondtions`, `vhFluxBoundaryCondtions`, `hBoundaryCondtions` that do not do anything to `top` and `bottom`?; - [ ] If we set the number of halos in the vertical to be 0, then we should still be able to use `new_data.jl` without having to modify it?; - [ ] Tell `fill_halo_regions.jl` to not do anything for `bottom` and `top`.; - [ ] If we remove the halos then I don't think we have to modify the tendencies at all so that might be fine.; - [ ] Other things that I've not considered?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499
https://github.com/CliMA/Oceananigans.jl/issues/1499:974,Usability,learn,learn,974,"Now that `ShallowWaterModel` is established I think it's important to make it more efficient. At the moment when we use `WENO5`, as I've been doing, we define 3 halo points in each direction. That means that our 1-layer model is really a 7-layer model, which is much more storage than we need. I very much want to remove this so that we can be much more efficient and have the code run faster. I know that #1024 tried to establish a flat dimension for `IncompressibleModel`. This is before my time and I heard multiple people tried doing this and it was a challenge. . I would like to do something independent of #1024, and force that any grid for `ShallowWaterModel` not define halo regions in the vertical and then not fill in those halo regions as it evolves. Below are a list of different things that I think should be done but am very curious to know what people suggest. I haven't tried this so I'm sure there are some details that I have not thought of and hoping to learn from others. - [ ] Maybe define the boundary conditions to be `flat` in the vertical and then try and get flat to work for this model?; - [ ] Maybe in `field_boundary_conditions.jl`, define `uhFluxBoundaryCondtions`, `vhFluxBoundaryCondtions`, `hBoundaryCondtions` that do not do anything to `top` and `bottom`?; - [ ] If we set the number of halos in the vertical to be 0, then we should still be able to use `new_data.jl` without having to modify it?; - [ ] Tell `fill_halo_regions.jl` to not do anything for `bottom` and `top`.; - [ ] If we remove the halos then I don't think we have to modify the tendencies at all so that might be fine.; - [ ] Other things that I've not considered?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499
https://github.com/CliMA/Oceananigans.jl/pull/1504:252,Testability,test,tested,252,"This PR borrowed very heavily from #1024 and successfully uses `Flat` in the context of the shallow water model in various ways: z direction only, y and z direction and x,y,z directions. All possibilities should work but these are the ones that I have tested explicitly. . There is a file `test/test_flat_shallow_water_model.jl` needs to be turned into a proper test. Also, I modified the shallow water Bickley jet example and it works. I am curious to see whether this has any impact on the other models. . What do you think?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1504
https://github.com/CliMA/Oceananigans.jl/pull/1504:290,Testability,test,test,290,"This PR borrowed very heavily from #1024 and successfully uses `Flat` in the context of the shallow water model in various ways: z direction only, y and z direction and x,y,z directions. All possibilities should work but these are the ones that I have tested explicitly. . There is a file `test/test_flat_shallow_water_model.jl` needs to be turned into a proper test. Also, I modified the shallow water Bickley jet example and it works. I am curious to see whether this has any impact on the other models. . What do you think?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1504
https://github.com/CliMA/Oceananigans.jl/pull/1504:362,Testability,test,test,362,"This PR borrowed very heavily from #1024 and successfully uses `Flat` in the context of the shallow water model in various ways: z direction only, y and z direction and x,y,z directions. All possibilities should work but these are the ones that I have tested explicitly. . There is a file `test/test_flat_shallow_water_model.jl` needs to be turned into a proper test. Also, I modified the shallow water Bickley jet example and it works. I am curious to see whether this has any impact on the other models. . What do you think?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1504
https://github.com/CliMA/Oceananigans.jl/pull/1505:458,Integrability,depend,dependent,458,"This PR adds MPI waits after sending and receiving all the halos and overlaps halo communication (thanks @christophernhill!). I was initially worried that overlapping halo communication would cause the corner halos to become wrong (I'm not even sure if the corner halos should be filled via communication?). But running the MPI example the movie looked fine so I'll keep the overlapping for now. Scaling benchmarks are better now! Results seem quite machine-dependent but on Satori for weak scaling I'm seeing >90% efficiency up to 16 ranks then ~85% efficiency on 32 ranks. Strong scaling seems noisier/a bit worse for some reason (including a 104% efficiency hit haha) but definitely better than before. # Weak scaling (shallow water). ```; Shallow water model weak scaling benchmark; ┌──────────────┬─────────┬─────────┬─────────┬─────────┬─────────┬────────────┬────────┬─────────┐; │ size │ ranks │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├──────────────┼─────────┼─────────┼─────────┼─────────┼─────────┼────────────┼────────┼─────────┤; │ (8192, 256) │ (1, 1) │ 1.188 s │ 1.190 s │ 1.190 s │ 1.193 s │ 416.81 KiB │ 2665 │ 5 │; │ (8192, 512) │ (1, 2) │ 1.187 s │ 1.192 s │ 1.192 s │ 1.200 s │ 408.80 KiB │ 3178 │ 10 │; │ (8192, 1024) │ (1, 4) │ 1.204 s │ 1.206 s │ 1.206 s │ 1.212 s │ 408.80 KiB │ 3178 │ 20 │; │ (8192, 2048) │ (1, 8) │ 1.220 s │ 1.223 s │ 1.223 s │ 1.230 s │ 408.80 KiB │ 3178 │ 40 │; │ (8192, 4096) │ (1, 16) │ 1.281 s │ 1.283 s │ 1.284 s │ 1.291 s │ 408.80 KiB │ 3178 │ 64 │; │ (8192, 8192) │ (1, 32) │ 1.347 s │ 1.417 s │ 1.424 s │ 1.497 s │ 408.80 KiB │ 3178 │ 128 │; └──────────────┴─────────┴─────────┴─────────┴─────────┴─────────┴────────────┴────────┴─────────┘; ```. ```; Shallow water model weak scaling speedup; ┌──────────────┬─────────┬──────────┬────────────┬──────────┬────────┐; │ size │ ranks │ slowdown │ efficiency │ memory │ allocs │; ├──────────────┼─────────┼──────────┼────────────┼──────────┼────────┤; │ (8192, 256) │ (1, 1) │ 1.0 │ 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505
https://github.com/CliMA/Oceananigans.jl/pull/1505:404,Testability,benchmark,benchmarks,404,"This PR adds MPI waits after sending and receiving all the halos and overlaps halo communication (thanks @christophernhill!). I was initially worried that overlapping halo communication would cause the corner halos to become wrong (I'm not even sure if the corner halos should be filled via communication?). But running the MPI example the movie looked fine so I'll keep the overlapping for now. Scaling benchmarks are better now! Results seem quite machine-dependent but on Satori for weak scaling I'm seeing >90% efficiency up to 16 ranks then ~85% efficiency on 32 ranks. Strong scaling seems noisier/a bit worse for some reason (including a 104% efficiency hit haha) but definitely better than before. # Weak scaling (shallow water). ```; Shallow water model weak scaling benchmark; ┌──────────────┬─────────┬─────────┬─────────┬─────────┬─────────┬────────────┬────────┬─────────┐; │ size │ ranks │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├──────────────┼─────────┼─────────┼─────────┼─────────┼─────────┼────────────┼────────┼─────────┤; │ (8192, 256) │ (1, 1) │ 1.188 s │ 1.190 s │ 1.190 s │ 1.193 s │ 416.81 KiB │ 2665 │ 5 │; │ (8192, 512) │ (1, 2) │ 1.187 s │ 1.192 s │ 1.192 s │ 1.200 s │ 408.80 KiB │ 3178 │ 10 │; │ (8192, 1024) │ (1, 4) │ 1.204 s │ 1.206 s │ 1.206 s │ 1.212 s │ 408.80 KiB │ 3178 │ 20 │; │ (8192, 2048) │ (1, 8) │ 1.220 s │ 1.223 s │ 1.223 s │ 1.230 s │ 408.80 KiB │ 3178 │ 40 │; │ (8192, 4096) │ (1, 16) │ 1.281 s │ 1.283 s │ 1.284 s │ 1.291 s │ 408.80 KiB │ 3178 │ 64 │; │ (8192, 8192) │ (1, 32) │ 1.347 s │ 1.417 s │ 1.424 s │ 1.497 s │ 408.80 KiB │ 3178 │ 128 │; └──────────────┴─────────┴─────────┴─────────┴─────────┴─────────┴────────────┴────────┴─────────┘; ```. ```; Shallow water model weak scaling speedup; ┌──────────────┬─────────┬──────────┬────────────┬──────────┬────────┐; │ size │ ranks │ slowdown │ efficiency │ memory │ allocs │; ├──────────────┼─────────┼──────────┼────────────┼──────────┼────────┤; │ (8192, 256) │ (1, 1) │ 1.0 │ 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505
https://github.com/CliMA/Oceananigans.jl/pull/1505:776,Testability,benchmark,benchmark,776,"This PR adds MPI waits after sending and receiving all the halos and overlaps halo communication (thanks @christophernhill!). I was initially worried that overlapping halo communication would cause the corner halos to become wrong (I'm not even sure if the corner halos should be filled via communication?). But running the MPI example the movie looked fine so I'll keep the overlapping for now. Scaling benchmarks are better now! Results seem quite machine-dependent but on Satori for weak scaling I'm seeing >90% efficiency up to 16 ranks then ~85% efficiency on 32 ranks. Strong scaling seems noisier/a bit worse for some reason (including a 104% efficiency hit haha) but definitely better than before. # Weak scaling (shallow water). ```; Shallow water model weak scaling benchmark; ┌──────────────┬─────────┬─────────┬─────────┬─────────┬─────────┬────────────┬────────┬─────────┐; │ size │ ranks │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├──────────────┼─────────┼─────────┼─────────┼─────────┼─────────┼────────────┼────────┼─────────┤; │ (8192, 256) │ (1, 1) │ 1.188 s │ 1.190 s │ 1.190 s │ 1.193 s │ 416.81 KiB │ 2665 │ 5 │; │ (8192, 512) │ (1, 2) │ 1.187 s │ 1.192 s │ 1.192 s │ 1.200 s │ 408.80 KiB │ 3178 │ 10 │; │ (8192, 1024) │ (1, 4) │ 1.204 s │ 1.206 s │ 1.206 s │ 1.212 s │ 408.80 KiB │ 3178 │ 20 │; │ (8192, 2048) │ (1, 8) │ 1.220 s │ 1.223 s │ 1.223 s │ 1.230 s │ 408.80 KiB │ 3178 │ 40 │; │ (8192, 4096) │ (1, 16) │ 1.281 s │ 1.283 s │ 1.284 s │ 1.291 s │ 408.80 KiB │ 3178 │ 64 │; │ (8192, 8192) │ (1, 32) │ 1.347 s │ 1.417 s │ 1.424 s │ 1.497 s │ 408.80 KiB │ 3178 │ 128 │; └──────────────┴─────────┴─────────┴─────────┴─────────┴─────────┴────────────┴────────┴─────────┘; ```. ```; Shallow water model weak scaling speedup; ┌──────────────┬─────────┬──────────┬────────────┬──────────┬────────┐; │ size │ ranks │ slowdown │ efficiency │ memory │ allocs │; ├──────────────┼─────────┼──────────┼────────────┼──────────┼────────┤; │ (8192, 256) │ (1, 1) │ 1.0 │ 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505
https://github.com/CliMA/Oceananigans.jl/pull/1505:2510,Testability,benchmark,benchmark,2510,"────────┴─────────┴─────────┴────────────┴────────┴─────────┘; ```. ```; Shallow water model weak scaling speedup; ┌──────────────┬─────────┬──────────┬────────────┬──────────┬────────┐; │ size │ ranks │ slowdown │ efficiency │ memory │ allocs │; ├──────────────┼─────────┼──────────┼────────────┼──────────┼────────┤; │ (8192, 256) │ (1, 1) │ 1.0 │ 1.0 │ 1.0 │ 1.0 │; │ (8192, 512) │ (1, 2) │ 1.00165 │ 0.998349 │ 0.980769 │ 1.1925 │; │ (8192, 1024) │ (1, 4) │ 1.01309 │ 0.987079 │ 0.980769 │ 1.1925 │; │ (8192, 2048) │ (1, 8) │ 1.02721 │ 0.973514 │ 0.980769 │ 1.1925 │; │ (8192, 4096) │ (1, 16) │ 1.07822 │ 0.927452 │ 0.980769 │ 1.1925 │; │ (8192, 8192) │ (1, 32) │ 1.19049 │ 0.83999 │ 0.980769 │ 1.1925 │; └──────────────┴─────────┴──────────┴────────────┴──────────┴────────┘; ```. # Strong scaling (shallow water). ```; Shallow water model strong scaling benchmark; ┌──────────────┬─────────┬──────────┬──────────┬──────────┬──────────┬────────────┬────────┬─────────┐; │ size │ ranks │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├──────────────┼─────────┼──────────┼──────────┼──────────┼──────────┼────────────┼────────┼─────────┤; │ (8192, 8192) │ (1, 1) │ 37.687 s │ 37.687 s │ 37.687 s │ 37.687 s │ 417.50 KiB │ 2709 │ 1 │; │ (8192, 8192) │ (1, 2) │ 19.278 s │ 19.280 s │ 19.280 s │ 19.282 s │ 409.48 KiB │ 3222 │ 2 │; │ (8192, 8192) │ (1, 4) │ 9.027 s │ 9.030 s │ 9.029 s │ 9.031 s │ 409.48 KiB │ 3222 │ 4 │; │ (8192, 8192) │ (1, 8) │ 5.499 s │ 5.514 s │ 5.513 s │ 5.520 s │ 409.48 KiB │ 3222 │ 8 │; │ (8192, 8192) │ (1, 16) │ 2.587 s │ 2.598 s │ 2.599 s │ 2.608 s │ 409.48 KiB │ 3222 │ 32 │; │ (8192, 8192) │ (1, 32) │ 1.355 s │ 1.437 s │ 1.438 s │ 1.544 s │ 408.80 KiB │ 3178 │ 128 │; └──────────────┴─────────┴──────────┴──────────┴──────────┴──────────┴────────────┴────────┴─────────┘; ```. ```; Shallow water model strong scaling speedup; ┌──────────────┬─────────┬─────────┬────────────┬──────────┬─────────┐; │ size │ ranks │ speedup │ efficiency │ memory │ allocs │; ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1505
https://github.com/CliMA/Oceananigans.jl/issues/1507:438,Availability,Error,Error,438,"Hello,; maybe this is an easy one since those mentioned scripts ([lid_driven_cavity](https://github.com/CliMA/Oceananigans.jl/blob/master/validation/lid_driven_cavity/lid_driven_cavity.jl) & [thermal_bubble](https://github.com/CliMA/Oceananigans.jl/blob/master/validation/thermal_bubble/thermal_bubble.jl)) don't seem that complicated. But after several days of reading code, poking around and trying stuff out I couldn't get rid of this Error when running them.; Did someone have or can point me to a solution?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507
https://github.com/CliMA/Oceananigans.jl/issues/1507:138,Security,validat,validation,138,"Hello,; maybe this is an easy one since those mentioned scripts ([lid_driven_cavity](https://github.com/CliMA/Oceananigans.jl/blob/master/validation/lid_driven_cavity/lid_driven_cavity.jl) & [thermal_bubble](https://github.com/CliMA/Oceananigans.jl/blob/master/validation/thermal_bubble/thermal_bubble.jl)) don't seem that complicated. But after several days of reading code, poking around and trying stuff out I couldn't get rid of this Error when running them.; Did someone have or can point me to a solution?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507
https://github.com/CliMA/Oceananigans.jl/issues/1507:261,Security,validat,validation,261,"Hello,; maybe this is an easy one since those mentioned scripts ([lid_driven_cavity](https://github.com/CliMA/Oceananigans.jl/blob/master/validation/lid_driven_cavity/lid_driven_cavity.jl) & [thermal_bubble](https://github.com/CliMA/Oceananigans.jl/blob/master/validation/thermal_bubble/thermal_bubble.jl)) don't seem that complicated. But after several days of reading code, poking around and trying stuff out I couldn't get rid of this Error when running them.; Did someone have or can point me to a solution?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507
https://github.com/CliMA/Oceananigans.jl/pull/1508:8,Testability,benchmark,benchmarks,8,Include benchmarks of the shallow water model on CPUs vs GPUs.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1508
https://github.com/CliMA/Oceananigans.jl/issues/1509:2162,Energy Efficiency,reduce,reduce,2162,"uite different when working with GPUs and I honestly don't even know where to begin. Below is an excerpt of my run script that shows the initial and boundary condition creation with a CPU architecture. If anyone can share resources on how to code this for a GPU or just explain it if it is easy, I would greatly appreciate the help!. ```; ρₒ = 1025; ############## Boundary conditions ###################; ## Pulling the boundary conditions from the data csv; df = CSV.read(""data_inputs/kma_buoy_fluxes_soulik.csv"", DataFrame);. seconds = df.time[:]*86400; # convert to seconds; secs = [tnow - seconds[1] for tnow in seconds]; # set first time stamp to 0; secs = [s - 518400 for s in secs]; # Move 0 time stamp to later in the time series. ## make the splines; spl_taux = Spline1D(secs, df.taux/(ρₒ), k=1);; spl_tauy = Spline1D(secs, df.tauy/(ρₒ), k=1);; spl_latHF = Spline1D(secs, df.lat_hf/(ρₒ * cᴾ), k=1);; spl_senHF = Spline1D(secs, df.sens_hf/(ρₒ * cᴾ), k=1);. ## turn the splines into functional arguments; @inline Fxn_taux(x,y,t) = spl_taux(t);; @inline Fxn_tauy(x,y,t) = spl_tauy(t);; @inline Fxn_HFlx(x,y,t) = spl_latHF(t) + spl_senHF(t); # K m⁻¹ s⁻¹, surface _temperature_ flux. ############# Initial conditions #############; ## Initial surface stress condition; Qo = sqrt(spl_taux(0)^2 + spl_tauy(0)^2). ## Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz); # noise. ## Velocity initial condition: random noise scaled by the initial stress.; uᵢ(x, y, z) = abs(Qo) * 1e-3 * Ξ(z);; wᵢ(x, y, z) = abs(Qo) * 1e-6 * Ξ(z); # This was added to reduce the scale of the w profile. ## Temperature and Salinity initial condition. # Intialize from glider data; df_i = CSV.read(""data_inputs/initial_prof.csv"",DataFrame); Temp = df_i.temp[:]; Salinity = df_i.sal[:]; depth=df_i.depth[:]. spl_temp = Spline1D(depth,Temp,k=1); spl_sal = Spline1D(depth,Salinity,k=1). @inline tempset_prof(x,y,z) = spl_temp(z); @inline salset_prof(x,y,z) = spl_sal(z); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509
https://github.com/CliMA/Oceananigans.jl/issues/1509:390,Performance,perform,perform,390,"Hi all!. With the help of Ali and a colleague at my school, I can now run Oceananigans using a GPU on my school's HPC. I am now at a step that is totally unfamiliar to me, coding for a GPU. . Based on what I have read from the Oceananigans documentation, I think the only trouble I will have is creating my forcing functions and my initial conditions. Currently, I read in data from csv's, perform a 1D spline interpolation, and then assign the interpolated function (which is 1D) to a 3D field function. . My understanding is that the way arrays are treated is quite different when working with GPUs and I honestly don't even know where to begin. Below is an excerpt of my run script that shows the initial and boundary condition creation with a CPU architecture. If anyone can share resources on how to code this for a GPU or just explain it if it is easy, I would greatly appreciate the help!. ```; ρₒ = 1025; ############## Boundary conditions ###################; ## Pulling the boundary conditions from the data csv; df = CSV.read(""data_inputs/kma_buoy_fluxes_soulik.csv"", DataFrame);. seconds = df.time[:]*86400; # convert to seconds; secs = [tnow - seconds[1] for tnow in seconds]; # set first time stamp to 0; secs = [s - 518400 for s in secs]; # Move 0 time stamp to later in the time series. ## make the splines; spl_taux = Spline1D(secs, df.taux/(ρₒ), k=1);; spl_tauy = Spline1D(secs, df.tauy/(ρₒ), k=1);; spl_latHF = Spline1D(secs, df.lat_hf/(ρₒ * cᴾ), k=1);; spl_senHF = Spline1D(secs, df.sens_hf/(ρₒ * cᴾ), k=1);. ## turn the splines into functional arguments; @inline Fxn_taux(x,y,t) = spl_taux(t);; @inline Fxn_tauy(x,y,t) = spl_tauy(t);; @inline Fxn_HFlx(x,y,t) = spl_latHF(t) + spl_senHF(t); # K m⁻¹ s⁻¹, surface _temperature_ flux. ############# Initial conditions #############; ## Initial surface stress condition; Qo = sqrt(spl_taux(0)^2 + spl_tauy(0)^2). ## Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz); # noise. ## Veloci",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509
https://github.com/CliMA/Oceananigans.jl/pull/1510:395,Availability,ERROR,ERROR,395,"I have made a first attempt to add tracers into `ShallowWaterModel`, but unfortunately, have a problem with the new function I have created, `div_ucvc` to compute the divergence of the tracer, `c`, times the velocity `(u,v)`. . When I try running a simulation I get the following output, which is a TaskFailedexcetion, and seems to be having problems with convert. ```; julia> run!(simulation); ERROR: TaskFailedException:; MethodError: Cannot `convert` an object of type Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Center,typeof(+),Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Center,typeof(+),Float64,Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Center,typeof(*),Field{Center,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{Nothing,Nothing}}}},Float64,typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},Oceananigans.AbstractOperations.BinaryOperation{Center,Center,Center,typeof(*),Field{Center,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1510
https://github.com/CliMA/Oceananigans.jl/pull/1513:442,Availability,error,error,442,"Do we want to update the one and two dimensional examples to include `Flat`? . If not then we can ignore this PR. . If yes, then this is my attempt to do so. The good news is that most of the one and two dimensional examples work very easily. Unfortunately, a couple of them, geostrophic adjustment and convecting plankton, do not. I don't know why at the moment and these should certainly be fixed before a merge happens. If it happens. The error get I get is `NaN` after (I believe) the first interval. So I suspect one of the tendencies is not being computed correctly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513
https://github.com/CliMA/Oceananigans.jl/pull/1513:14,Deployability,update,update,14,"Do we want to update the one and two dimensional examples to include `Flat`? . If not then we can ignore this PR. . If yes, then this is my attempt to do so. The good news is that most of the one and two dimensional examples work very easily. Unfortunately, a couple of them, geostrophic adjustment and convecting plankton, do not. I don't know why at the moment and these should certainly be fixed before a merge happens. If it happens. The error get I get is `NaN` after (I believe) the first interval. So I suspect one of the tendencies is not being computed correctly.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1513
https://github.com/CliMA/Oceananigans.jl/pull/1514:155,Testability,test,test,155,Just updating the `Manifest.toml` and the Buildkite Julia version number to see if everything passes. I've been using 1.6 fine on my laptop so this should test 1.6 + GPUs.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514
https://github.com/CliMA/Oceananigans.jl/pull/1516:13,Deployability,update,updates,13,"This PR just updates and cleans up the lid-driven cavity script. At some point I'd like to add all the validation experiments into CI and into the docs as advanced examples, but this will have to wait for now. The issue is that the script was using `Flat` back when it did nothing but now when using `Flat` you need to pass a 2-tuple for the grid size. I switched the script from `Flat` to `Bounded` until `Flat` is fully working. cc @maeckha. Resolves #1507",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1516
https://github.com/CliMA/Oceananigans.jl/pull/1516:103,Security,validat,validation,103,"This PR just updates and cleans up the lid-driven cavity script. At some point I'd like to add all the validation experiments into CI and into the docs as advanced examples, but this will have to wait for now. The issue is that the script was using `Flat` back when it did nothing but now when using `Flat` you need to pass a 2-tuple for the grid size. I switched the script from `Flat` to `Bounded` until `Flat` is fully working. cc @maeckha. Resolves #1507",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1516
https://github.com/CliMA/Oceananigans.jl/issues/1517:4897,Energy Efficiency,schedul,schedule,4897,"enter, Face; using Oceananigans.Fields: KernelComputedField; using Oceananigans.Operators; @kernel function isotropic_viscous_dissipation_ccc!(ϵ, grid, ν, u, v, w); i, j, k = @index(Global, NTuple). Σˣˣ = ∂xᶜᵃᵃ(i, j, k, grid, u); Σʸʸ = ∂yᵃᶜᵃ(i, j, k, grid, v); Σᶻᶻ = ∂zᵃᵃᶜ(i, j, k, grid, w). Σˣʸ = (ℑxyᶜᶜᵃ(i, j, k, grid, ∂yᵃᶠᵃ, u) + ℑxyᶜᶜᵃ(i, j, k, grid, ∂xᶠᵃᵃ, v)) / 2; Σˣᶻ = (ℑxzᶜᵃᶜ(i, j, k, grid, ∂zᵃᵃᶠ, u) + ℑxzᶜᵃᶜ(i, j, k, grid, ∂xᶠᵃᵃ, w)) / 2; Σʸᶻ = (ℑyzᵃᶜᶜ(i, j, k, grid, ∂zᵃᵃᶠ, v) + ℑyzᵃᶜᶜ(i, j, k, grid, ∂yᵃᶠᵃ, w)) / 2. @inbounds ϵ[i, j, k] = 2 * (Σˣˣ^2 + Σʸʸ^2 + Σᶻᶻ^2 + 2 * (Σˣʸ^2 + Σˣᶻ^2 + Σʸᶻ^2)); end; ε_i = KernelComputedField(Center, Center, Center, isotropic_viscous_dissipation_ccc!, model;; computed_dependencies=(κ, u, v, w)). # Vertical vorticity [s⁻¹]; tke = KineticEnergy(model, u, v, w). outputs = (tke=tke, ε_i=ε_i). using Oceananigans.OutputWriters: NetCDFOutputWriter, TimeInterval, AveragedTimeInterval; simulation.output_writers[:snap] = NetCDFOutputWriter(model, outputs,; schedule = TimeInterval(100minutes),; filepath = ""snap.eady.nc"",; mode = ""c""); simulation.output_writers[:avg2] = NetCDFOutputWriter(model, outputs,; schedule = AveragedTimeInterval(100minutes; window=99.99minutes, stride=1),; filepath = ""avg2.eady.nc"",; mode = ""c""); #----. #++++ Run simulation; println(""Running!""); run!(simulation); #-----; ```. This runs without any problem or warning. When I plot the TKE the results are as expected. The plots below are averaged in space. TKE is pretty much what I expected, meaning both outputs differ very little:. ![Screenshot from 2021-03-29 07-43-44](https://user-images.githubusercontent.com/13205162/112854425-af77f080-9062-11eb-9617-96e4fe334ec9.png). Dissipation is not what I expected since the difference between snapshot and time-averages is way too large:. ![Screenshot from 2021-03-29 07-44-20](https://user-images.githubusercontent.com/13205162/112854571-d7675400-9062-11eb-8d94-58bddd42bb24.png). Am I missing something obvious here? Does any",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517
https://github.com/CliMA/Oceananigans.jl/issues/1517:5047,Energy Efficiency,schedul,schedule,5047,", ν, u, v, w); i, j, k = @index(Global, NTuple). Σˣˣ = ∂xᶜᵃᵃ(i, j, k, grid, u); Σʸʸ = ∂yᵃᶜᵃ(i, j, k, grid, v); Σᶻᶻ = ∂zᵃᵃᶜ(i, j, k, grid, w). Σˣʸ = (ℑxyᶜᶜᵃ(i, j, k, grid, ∂yᵃᶠᵃ, u) + ℑxyᶜᶜᵃ(i, j, k, grid, ∂xᶠᵃᵃ, v)) / 2; Σˣᶻ = (ℑxzᶜᵃᶜ(i, j, k, grid, ∂zᵃᵃᶠ, u) + ℑxzᶜᵃᶜ(i, j, k, grid, ∂xᶠᵃᵃ, w)) / 2; Σʸᶻ = (ℑyzᵃᶜᶜ(i, j, k, grid, ∂zᵃᵃᶠ, v) + ℑyzᵃᶜᶜ(i, j, k, grid, ∂yᵃᶠᵃ, w)) / 2. @inbounds ϵ[i, j, k] = 2 * (Σˣˣ^2 + Σʸʸ^2 + Σᶻᶻ^2 + 2 * (Σˣʸ^2 + Σˣᶻ^2 + Σʸᶻ^2)); end; ε_i = KernelComputedField(Center, Center, Center, isotropic_viscous_dissipation_ccc!, model;; computed_dependencies=(κ, u, v, w)). # Vertical vorticity [s⁻¹]; tke = KineticEnergy(model, u, v, w). outputs = (tke=tke, ε_i=ε_i). using Oceananigans.OutputWriters: NetCDFOutputWriter, TimeInterval, AveragedTimeInterval; simulation.output_writers[:snap] = NetCDFOutputWriter(model, outputs,; schedule = TimeInterval(100minutes),; filepath = ""snap.eady.nc"",; mode = ""c""); simulation.output_writers[:avg2] = NetCDFOutputWriter(model, outputs,; schedule = AveragedTimeInterval(100minutes; window=99.99minutes, stride=1),; filepath = ""avg2.eady.nc"",; mode = ""c""); #----. #++++ Run simulation; println(""Running!""); run!(simulation); #-----; ```. This runs without any problem or warning. When I plot the TKE the results are as expected. The plots below are averaged in space. TKE is pretty much what I expected, meaning both outputs differ very little:. ![Screenshot from 2021-03-29 07-43-44](https://user-images.githubusercontent.com/13205162/112854425-af77f080-9062-11eb-9617-96e4fe334ec9.png). Dissipation is not what I expected since the difference between snapshot and time-averages is way too large:. ![Screenshot from 2021-03-29 07-44-20](https://user-images.githubusercontent.com/13205162/112854571-d7675400-9062-11eb-8d94-58bddd42bb24.png). Am I missing something obvious here? Does anyone have an idea of what's happening?. Thanks!. PS: Here are the packages being used:. ```; [c7e460c6] ArgParse v1.1.2; [63c18a36] KernelAbstractions",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517
https://github.com/CliMA/Oceananigans.jl/issues/1517:317,Usability,simpl,simplified,317,"I've been experiencing a odd behavior when outputting dissipation where the results outputting a snapshot and a time-averaged field are different. This doesn't seem to happen for other outputs for some reason and I'm having a hard time understanding what's going on. . Maybe the best way to illustrate this is with a simplified version of the Eady turbulence example in the docs. The first part of the simulation is basically the same as the example, except with a simple constant isotropic diffusivity for closure (and a different progress messenger). I'm listing it below for completeness, but if you're familiar with the example in the docs you can skip this:. ```julia; using Oceananigans; using Oceananigans.Utils; using Oceananigans.Units; using Printf. grid = RegularRectilinearGrid(size=(24, 24, 16), x=(0, 1e6), y=(0, 1e6), z=(-4e3, 0)); coriolis = FPlane(f=1e-4) # [s⁻¹]. const basic_state_parameters = ( α = 10 * coriolis.f, # s⁻¹, geostrophic shear; f = coriolis.f, # s⁻¹, Coriolis parameter; N = 1e-3, # s⁻¹, buoyancy frequency; Lz = grid.Lz) # m, ocean depth. using Oceananigans.Fields: BackgroundField. # Background fields are defined via functions of x, y, z, t, and optional parameters; U(x, y, z, t, p) = + p.α * (z + p.Lz); B(x, y, z, t, p) = - p.α * p.f * y + p.N^2 * z. U_field = BackgroundField(U, parameters=basic_state_parameters); B_field = BackgroundField(B, parameters=basic_state_parameters). #++++ Drag; const cᴰ = 1e-4 # quadratic drag coefficient. @inline drag_u(x, y, t, u, v, cᴰ) = - cᴰ * u * sqrt(u^2 + v^2); @inline drag_v(x, y, t, u, v, cᴰ) = - cᴰ * v * sqrt(u^2 + v^2). drag_bc_u = BoundaryCondition(Flux, drag_u, field_dependencies=(:u, :v), parameters=cᴰ); drag_bc_v = BoundaryCondition(Flux, drag_v, field_dependencies=(:u, :v), parameters=cᴰ). u_bcs = UVelocityBoundaryConditions(grid, bottom = drag_bc_u); v_bcs = VVelocityBoundaryConditions(grid, bottom = drag_bc_v); #-----. #++++ Turbulence closures; const κ = 1e-2 # [m² s⁻¹] Laplacian vertical viscosity ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517
https://github.com/CliMA/Oceananigans.jl/issues/1517:465,Usability,simpl,simple,465,"I've been experiencing a odd behavior when outputting dissipation where the results outputting a snapshot and a time-averaged field are different. This doesn't seem to happen for other outputs for some reason and I'm having a hard time understanding what's going on. . Maybe the best way to illustrate this is with a simplified version of the Eady turbulence example in the docs. The first part of the simulation is basically the same as the example, except with a simple constant isotropic diffusivity for closure (and a different progress messenger). I'm listing it below for completeness, but if you're familiar with the example in the docs you can skip this:. ```julia; using Oceananigans; using Oceananigans.Utils; using Oceananigans.Units; using Printf. grid = RegularRectilinearGrid(size=(24, 24, 16), x=(0, 1e6), y=(0, 1e6), z=(-4e3, 0)); coriolis = FPlane(f=1e-4) # [s⁻¹]. const basic_state_parameters = ( α = 10 * coriolis.f, # s⁻¹, geostrophic shear; f = coriolis.f, # s⁻¹, Coriolis parameter; N = 1e-3, # s⁻¹, buoyancy frequency; Lz = grid.Lz) # m, ocean depth. using Oceananigans.Fields: BackgroundField. # Background fields are defined via functions of x, y, z, t, and optional parameters; U(x, y, z, t, p) = + p.α * (z + p.Lz); B(x, y, z, t, p) = - p.α * p.f * y + p.N^2 * z. U_field = BackgroundField(U, parameters=basic_state_parameters); B_field = BackgroundField(B, parameters=basic_state_parameters). #++++ Drag; const cᴰ = 1e-4 # quadratic drag coefficient. @inline drag_u(x, y, t, u, v, cᴰ) = - cᴰ * u * sqrt(u^2 + v^2); @inline drag_v(x, y, t, u, v, cᴰ) = - cᴰ * v * sqrt(u^2 + v^2). drag_bc_u = BoundaryCondition(Flux, drag_u, field_dependencies=(:u, :v), parameters=cᴰ); drag_bc_v = BoundaryCondition(Flux, drag_v, field_dependencies=(:u, :v), parameters=cᴰ). u_bcs = UVelocityBoundaryConditions(grid, bottom = drag_bc_u); v_bcs = VVelocityBoundaryConditions(grid, bottom = drag_bc_v); #-----. #++++ Turbulence closures; const κ = 1e-2 # [m² s⁻¹] Laplacian vertical viscosity ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517
https://github.com/CliMA/Oceananigans.jl/pull/1518:8,Deployability,update,updates,8,"This PR updates the README and cleans it up a bit since it was out of date, and adds a section on ""citing"" Oceananigans.jl and a page with a list of publications using Oceananigans.jl. Open to suggestions if anyone thinks something is missing or could be better!. Resolves #973; Resolves #1101",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1518
https://github.com/CliMA/Oceananigans.jl/pull/1520:462,Testability,test,test,462,@tomchor You pointed out that `KernelComputedField` + `TimeAveragedInterval` seemed to be accumulating over time in #1517. This PR just explicitly zeroes out the `KernelComputedField`'s data in `compute!` so everything should still work since `compute!` should recompute everything. Might help uncover accumulation-related bugs?. I couldn't find much wrong otherwise so this is just a shot in the dark. Designing a `KernelComputedField` + `TimeAveragedInterval` test might be better than continuing to try different hacks 😅,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1520
https://github.com/CliMA/Oceananigans.jl/pull/1522:562,Availability,down,down,562,This PR adds a new submodule `Oceananigans.CubedSpheres` that implements new grid and field types for running `HydrostaticFreeSurfaceModel` with a fully connected cubed sphere (should eventually also be flexible enough to just use 1 < n < 6 faces but I'm just testing 6 faces for now). This PR is still a work-in-progress and is quite messy with some pretty horrible code (please don't judge :sob:). I'll be adding to it and refactoring it over the next few days. Compile times have increased significantly with `grid::ConformalCubedSphereGrid` which has slowed down development but should be pretty close to being able to time step. EDIT: This might only be on Julia 1.6...,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522
https://github.com/CliMA/Oceananigans.jl/pull/1522:203,Modifiability,flexible,flexible,203,This PR adds a new submodule `Oceananigans.CubedSpheres` that implements new grid and field types for running `HydrostaticFreeSurfaceModel` with a fully connected cubed sphere (should eventually also be flexible enough to just use 1 < n < 6 faces but I'm just testing 6 faces for now). This PR is still a work-in-progress and is quite messy with some pretty horrible code (please don't judge :sob:). I'll be adding to it and refactoring it over the next few days. Compile times have increased significantly with `grid::ConformalCubedSphereGrid` which has slowed down development but should be pretty close to being able to time step. EDIT: This might only be on Julia 1.6...,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522
https://github.com/CliMA/Oceananigans.jl/pull/1522:425,Modifiability,refactor,refactoring,425,This PR adds a new submodule `Oceananigans.CubedSpheres` that implements new grid and field types for running `HydrostaticFreeSurfaceModel` with a fully connected cubed sphere (should eventually also be flexible enough to just use 1 < n < 6 faces but I'm just testing 6 faces for now). This PR is still a work-in-progress and is quite messy with some pretty horrible code (please don't judge :sob:). I'll be adding to it and refactoring it over the next few days. Compile times have increased significantly with `grid::ConformalCubedSphereGrid` which has slowed down development but should be pretty close to being able to time step. EDIT: This might only be on Julia 1.6...,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522
https://github.com/CliMA/Oceananigans.jl/pull/1522:260,Testability,test,testing,260,This PR adds a new submodule `Oceananigans.CubedSpheres` that implements new grid and field types for running `HydrostaticFreeSurfaceModel` with a fully connected cubed sphere (should eventually also be flexible enough to just use 1 < n < 6 faces but I'm just testing 6 faces for now). This PR is still a work-in-progress and is quite messy with some pretty horrible code (please don't judge :sob:). I'll be adding to it and refactoring it over the next few days. Compile times have increased significantly with `grid::ConformalCubedSphereGrid` which has slowed down development but should be pretty close to being able to time step. EDIT: This might only be on Julia 1.6...,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522
https://github.com/CliMA/Oceananigans.jl/pull/1524:197,Testability,test,tested,197,"This pull request changes the compat entry for the `KernelAbstractions` package from `^0.3, 0.4, 0.5` to `^0.3, 0.4, 0.5, 0.6`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1524
https://github.com/CliMA/Oceananigans.jl/pull/1524:302,Testability,test,tests,302,"This pull request changes the compat entry for the `KernelAbstractions` package from `^0.3, 0.4, 0.5` to `^0.3, 0.4, 0.5, 0.6`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1524
https://github.com/CliMA/Oceananigans.jl/pull/1525:33,Testability,test,test,33,"Cleans up the file organization, test, import statements, and some formatting irregularities. Resolves #1521 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1525
https://github.com/CliMA/Oceananigans.jl/pull/1526:22,Testability,test,tests,22,Resolves #1512. Needs tests. Docstring for `FieldSlicer` could probably be spruced up too.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1526
https://github.com/CliMA/Oceananigans.jl/pull/1530:110,Deployability,deploy,deploy,110,Documenter.jl uses KaTeX by default but MathJax3 might be better for us. Will wait for Buildkite to build and deploy the docs to see 🤞 . Resolves #528 (hopefully),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530
https://github.com/CliMA/Oceananigans.jl/pull/1531:245,Security,validat,validation,245,This PR adds biharmonic diffusion appropriate for curvilinear grids as described by the MITgcm docs:. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#horizontal-dissipation. Looking for suggestions on more comprehensive tests / validation experiments.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1531
https://github.com/CliMA/Oceananigans.jl/pull/1531:237,Testability,test,tests,237,This PR adds biharmonic diffusion appropriate for curvilinear grids as described by the MITgcm docs:. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#horizontal-dissipation. Looking for suggestions on more comprehensive tests / validation experiments.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1531
https://github.com/CliMA/Oceananigans.jl/issues/1538:239,Availability,ERROR,ERROR,239,"Might be nice if this worked (although right now we can use `FunctionField` directly which isn't too hard):. ```julia; julia> Ψ(λ, φ, z) = - R * u₀ * (sind(φ) * cosd(α) - cosd(λ) * cosd(φ) * sind(α)). julia> ∂x(Ψ); ```. ```; julia> ∂x(Ψ); ERROR: MethodError: no method matching ∂x(::typeof(Ψ)); Closest candidates are:; ∂x(::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}, ::Union{Type{Nothing}, Type{Center}, Type{Face}}) at /home/alir/Oceananigans.jl/src/AbstractOperations/derivatives.jl:45; ∂x(::Tuple, ::Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A) where {X, Y, Z} at /home/alir/Oceananigans.jl/src/AbstractOperations/derivatives.jl:62; ∂x(::Oceananigans.Fields.AbstractField{X,Y,Z,A,G} where G where A) where {X, Y, Z} at /home/alir/Oceananigans.jl/src/AbstractOperations/derivatives.jl:89; Stacktrace:; [1] top-level scope at REPL[18]:1; ```. I guess for it to work we would also have to sepcify the location of the function, maybe via; ```julia; julia> ∂x(@at (Face, Face, Center) Ψ); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1538
https://github.com/CliMA/Oceananigans.jl/pull/1539:127,Energy Efficiency,Reduce,ReducedField,127,Calling `similar(f)` returns a field at the same location and with identical boundary conditions as `f` for `f::Field` and `f::ReducedField`. cc @christophernhill,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1539
https://github.com/CliMA/Oceananigans.jl/pull/1540:80,Energy Efficiency,Reduce,ReducedField,80,This PR changes the surface displacement in `HydrostaticFreeSurfaceModel` to a `ReducedField` rather than full `Field`. cc @christophernhill,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1540
https://github.com/CliMA/Oceananigans.jl/pull/1541:1436,Deployability,Update,Update,1436,"This PR fixes a bug in the `FourierTridiagonalPoissonSolver` that almost certainly meant it produced incorrect answers. There were two concurrent bugs that cancelled each other out, which allowed tests to pass:. 1. The Laplacian operator (previously called `∇²`, now called `∇²ᶜᶜᶜ`) was incorrect, because ""Face"" and ""Center"" superscripts were swapped. In other words, the Laplacian operator was correct for an object located at `(Face, Face, Face)`, rather than `(Center, Center, Center)` as it was being applied.; 2. `ΔzF` and `ΔzC` were also swapped in derivation of the `FourierTridiagonalPoissonSolver`. This means that both the docs and the code were incorrect. The tests passed because these two bugs effectively cancel each other out. This PR fixes both bugs. There still may be a lingering issue however, because the docs multiply the entire Poisson equation by the vertical grid spacing (which in the docs is written `ΔzC`, but should be `ΔzF`), including the source term. I didn't see immediately where to replace `ΔzC` with `ΔzF` in `solve_poisson_equation!`. The tests may pass anyways because there is no test that incompressibility is maintained on a stretched grid. I also cleaned up the Laplacian operators a bit, and the grid spacing operators, and added a convenience function `set_source_term!` so that users don't have to know about the special formulation that `FourierTridiagonalPoissonSolver` uses. TODO:. - [x] Update the docs; - [x] Test incompressibility on a stretched grid",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541
https://github.com/CliMA/Oceananigans.jl/pull/1541:135,Performance,concurren,concurrent,135,"This PR fixes a bug in the `FourierTridiagonalPoissonSolver` that almost certainly meant it produced incorrect answers. There were two concurrent bugs that cancelled each other out, which allowed tests to pass:. 1. The Laplacian operator (previously called `∇²`, now called `∇²ᶜᶜᶜ`) was incorrect, because ""Face"" and ""Center"" superscripts were swapped. In other words, the Laplacian operator was correct for an object located at `(Face, Face, Face)`, rather than `(Center, Center, Center)` as it was being applied.; 2. `ΔzF` and `ΔzC` were also swapped in derivation of the `FourierTridiagonalPoissonSolver`. This means that both the docs and the code were incorrect. The tests passed because these two bugs effectively cancel each other out. This PR fixes both bugs. There still may be a lingering issue however, because the docs multiply the entire Poisson equation by the vertical grid spacing (which in the docs is written `ΔzC`, but should be `ΔzF`), including the source term. I didn't see immediately where to replace `ΔzC` with `ΔzF` in `solve_poisson_equation!`. The tests may pass anyways because there is no test that incompressibility is maintained on a stretched grid. I also cleaned up the Laplacian operators a bit, and the grid spacing operators, and added a convenience function `set_source_term!` so that users don't have to know about the special formulation that `FourierTridiagonalPoissonSolver` uses. TODO:. - [x] Update the docs; - [x] Test incompressibility on a stretched grid",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541
https://github.com/CliMA/Oceananigans.jl/pull/1541:196,Testability,test,tests,196,"This PR fixes a bug in the `FourierTridiagonalPoissonSolver` that almost certainly meant it produced incorrect answers. There were two concurrent bugs that cancelled each other out, which allowed tests to pass:. 1. The Laplacian operator (previously called `∇²`, now called `∇²ᶜᶜᶜ`) was incorrect, because ""Face"" and ""Center"" superscripts were swapped. In other words, the Laplacian operator was correct for an object located at `(Face, Face, Face)`, rather than `(Center, Center, Center)` as it was being applied.; 2. `ΔzF` and `ΔzC` were also swapped in derivation of the `FourierTridiagonalPoissonSolver`. This means that both the docs and the code were incorrect. The tests passed because these two bugs effectively cancel each other out. This PR fixes both bugs. There still may be a lingering issue however, because the docs multiply the entire Poisson equation by the vertical grid spacing (which in the docs is written `ΔzC`, but should be `ΔzF`), including the source term. I didn't see immediately where to replace `ΔzC` with `ΔzF` in `solve_poisson_equation!`. The tests may pass anyways because there is no test that incompressibility is maintained on a stretched grid. I also cleaned up the Laplacian operators a bit, and the grid spacing operators, and added a convenience function `set_source_term!` so that users don't have to know about the special formulation that `FourierTridiagonalPoissonSolver` uses. TODO:. - [x] Update the docs; - [x] Test incompressibility on a stretched grid",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541
https://github.com/CliMA/Oceananigans.jl/pull/1541:672,Testability,test,tests,672,"This PR fixes a bug in the `FourierTridiagonalPoissonSolver` that almost certainly meant it produced incorrect answers. There were two concurrent bugs that cancelled each other out, which allowed tests to pass:. 1. The Laplacian operator (previously called `∇²`, now called `∇²ᶜᶜᶜ`) was incorrect, because ""Face"" and ""Center"" superscripts were swapped. In other words, the Laplacian operator was correct for an object located at `(Face, Face, Face)`, rather than `(Center, Center, Center)` as it was being applied.; 2. `ΔzF` and `ΔzC` were also swapped in derivation of the `FourierTridiagonalPoissonSolver`. This means that both the docs and the code were incorrect. The tests passed because these two bugs effectively cancel each other out. This PR fixes both bugs. There still may be a lingering issue however, because the docs multiply the entire Poisson equation by the vertical grid spacing (which in the docs is written `ΔzC`, but should be `ΔzF`), including the source term. I didn't see immediately where to replace `ΔzC` with `ΔzF` in `solve_poisson_equation!`. The tests may pass anyways because there is no test that incompressibility is maintained on a stretched grid. I also cleaned up the Laplacian operators a bit, and the grid spacing operators, and added a convenience function `set_source_term!` so that users don't have to know about the special formulation that `FourierTridiagonalPoissonSolver` uses. TODO:. - [x] Update the docs; - [x] Test incompressibility on a stretched grid",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541
https://github.com/CliMA/Oceananigans.jl/pull/1541:1076,Testability,test,tests,1076,"This PR fixes a bug in the `FourierTridiagonalPoissonSolver` that almost certainly meant it produced incorrect answers. There were two concurrent bugs that cancelled each other out, which allowed tests to pass:. 1. The Laplacian operator (previously called `∇²`, now called `∇²ᶜᶜᶜ`) was incorrect, because ""Face"" and ""Center"" superscripts were swapped. In other words, the Laplacian operator was correct for an object located at `(Face, Face, Face)`, rather than `(Center, Center, Center)` as it was being applied.; 2. `ΔzF` and `ΔzC` were also swapped in derivation of the `FourierTridiagonalPoissonSolver`. This means that both the docs and the code were incorrect. The tests passed because these two bugs effectively cancel each other out. This PR fixes both bugs. There still may be a lingering issue however, because the docs multiply the entire Poisson equation by the vertical grid spacing (which in the docs is written `ΔzC`, but should be `ΔzF`), including the source term. I didn't see immediately where to replace `ΔzC` with `ΔzF` in `solve_poisson_equation!`. The tests may pass anyways because there is no test that incompressibility is maintained on a stretched grid. I also cleaned up the Laplacian operators a bit, and the grid spacing operators, and added a convenience function `set_source_term!` so that users don't have to know about the special formulation that `FourierTridiagonalPoissonSolver` uses. TODO:. - [x] Update the docs; - [x] Test incompressibility on a stretched grid",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541
https://github.com/CliMA/Oceananigans.jl/pull/1541:1119,Testability,test,test,1119,"This PR fixes a bug in the `FourierTridiagonalPoissonSolver` that almost certainly meant it produced incorrect answers. There were two concurrent bugs that cancelled each other out, which allowed tests to pass:. 1. The Laplacian operator (previously called `∇²`, now called `∇²ᶜᶜᶜ`) was incorrect, because ""Face"" and ""Center"" superscripts were swapped. In other words, the Laplacian operator was correct for an object located at `(Face, Face, Face)`, rather than `(Center, Center, Center)` as it was being applied.; 2. `ΔzF` and `ΔzC` were also swapped in derivation of the `FourierTridiagonalPoissonSolver`. This means that both the docs and the code were incorrect. The tests passed because these two bugs effectively cancel each other out. This PR fixes both bugs. There still may be a lingering issue however, because the docs multiply the entire Poisson equation by the vertical grid spacing (which in the docs is written `ΔzC`, but should be `ΔzF`), including the source term. I didn't see immediately where to replace `ΔzC` with `ΔzF` in `solve_poisson_equation!`. The tests may pass anyways because there is no test that incompressibility is maintained on a stretched grid. I also cleaned up the Laplacian operators a bit, and the grid spacing operators, and added a convenience function `set_source_term!` so that users don't have to know about the special formulation that `FourierTridiagonalPoissonSolver` uses. TODO:. - [x] Update the docs; - [x] Test incompressibility on a stretched grid",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541
https://github.com/CliMA/Oceananigans.jl/pull/1541:1459,Testability,Test,Test,1459,"This PR fixes a bug in the `FourierTridiagonalPoissonSolver` that almost certainly meant it produced incorrect answers. There were two concurrent bugs that cancelled each other out, which allowed tests to pass:. 1. The Laplacian operator (previously called `∇²`, now called `∇²ᶜᶜᶜ`) was incorrect, because ""Face"" and ""Center"" superscripts were swapped. In other words, the Laplacian operator was correct for an object located at `(Face, Face, Face)`, rather than `(Center, Center, Center)` as it was being applied.; 2. `ΔzF` and `ΔzC` were also swapped in derivation of the `FourierTridiagonalPoissonSolver`. This means that both the docs and the code were incorrect. The tests passed because these two bugs effectively cancel each other out. This PR fixes both bugs. There still may be a lingering issue however, because the docs multiply the entire Poisson equation by the vertical grid spacing (which in the docs is written `ΔzC`, but should be `ΔzF`), including the source term. I didn't see immediately where to replace `ΔzC` with `ΔzF` in `solve_poisson_equation!`. The tests may pass anyways because there is no test that incompressibility is maintained on a stretched grid. I also cleaned up the Laplacian operators a bit, and the grid spacing operators, and added a convenience function `set_source_term!` so that users don't have to know about the special formulation that `FourierTridiagonalPoissonSolver` uses. TODO:. - [x] Update the docs; - [x] Test incompressibility on a stretched grid",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1541
https://github.com/CliMA/Oceananigans.jl/issues/1542:325,Availability,error,errors,325,"I'm trying to build the docs locally because I want to resolve https://github.com/CliMA/Oceananigans.jl/issues/1478. I followed the instructions in [the docs](https://clima.github.io/OceananigansDocumentation/stable/contributing/#Documentation) but I'm not able to generate `index.html`. Here's a pastebin with the first few errors that appear: https://pastebin.com/25A8SqeX. It looks like the doc generator is comparing the actual output with some expected output? Is that something the docs should do?. Anyway, I've never built julia docs before so I'm kinda unfamiliar with this. Help is appreciated!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1542
https://github.com/CliMA/Oceananigans.jl/pull/1543:356,Usability,feedback,feedback,356,"Closes https://github.com/CliMA/Oceananigans.jl/issues/1478. As mentioned in https://github.com/CliMA/Oceananigans.jl/issues/1542 I couldn't build the docs locally so I probably made some markdown mistakes along the way, which is why this is a draft pull request. This first draft is also somewhat incomplete. I figured I'd create the PR early to get some feedback along the way though. I'm especially unfamiliar with the part about converting arrays to CUDA etc., so some help/collaboration there is much appreciated. CC @ali-ramadhan @glwagner @navidcy @francispoulin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543
https://github.com/CliMA/Oceananigans.jl/pull/1544:740,Testability,test,tests,740,"Following up on @glwagner 's suggestion in #1532, here is a slight modification to `VerticallyStretchedGrid`, which is consistent with what I'm proposing in that other PR. I actually made a few changes here than I needed to, but these changes are cosmetic and have no impact on functionality. . There are two significant differences. . 1. Like the other grids, we now specify `x,y,z` when defining the grid. We can also add `extent` if people wanted, but it's not in place now.; 2. What is called `zF_generator` in `master`, is now passed as a separate argument. I also changed the name to `z_stetch` since this is what @tomchor used in his example and stretch seems more appropriate than generator. Again, this is easily changed. The grid tests all pass and not sure why other tests seem to fail. What do people think about this difference?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544
https://github.com/CliMA/Oceananigans.jl/pull/1544:778,Testability,test,tests,778,"Following up on @glwagner 's suggestion in #1532, here is a slight modification to `VerticallyStretchedGrid`, which is consistent with what I'm proposing in that other PR. I actually made a few changes here than I needed to, but these changes are cosmetic and have no impact on functionality. . There are two significant differences. . 1. Like the other grids, we now specify `x,y,z` when defining the grid. We can also add `extent` if people wanted, but it's not in place now.; 2. What is called `zF_generator` in `master`, is now passed as a separate argument. I also changed the name to `z_stetch` since this is what @tomchor used in his example and stretch seems more appropriate than generator. Again, this is easily changed. The grid tests all pass and not sure why other tests seem to fail. What do people think about this difference?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544
https://github.com/CliMA/Oceananigans.jl/pull/1545:91,Availability,Checkpoint,Checkpointer,91,"Not sure if this is something we want to do by default, probably makes sense to make it a `Checkpointer` property, but it's useful as you might want to checkpoint a final time at the end of the simulation (preserving a 3D state) and when running on clusters with time limits, you want to checkpoint one final time before the job's time limit is up (to avoid repeating computational work on subsequent jobs).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1545
https://github.com/CliMA/Oceananigans.jl/pull/1545:152,Availability,checkpoint,checkpoint,152,"Not sure if this is something we want to do by default, probably makes sense to make it a `Checkpointer` property, but it's useful as you might want to checkpoint a final time at the end of the simulation (preserving a 3D state) and when running on clusters with time limits, you want to checkpoint one final time before the job's time limit is up (to avoid repeating computational work on subsequent jobs).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1545
https://github.com/CliMA/Oceananigans.jl/pull/1545:288,Availability,checkpoint,checkpoint,288,"Not sure if this is something we want to do by default, probably makes sense to make it a `Checkpointer` property, but it's useful as you might want to checkpoint a final time at the end of the simulation (preserving a 3D state) and when running on clusters with time limits, you want to checkpoint one final time before the job's time limit is up (to avoid repeating computational work on subsequent jobs).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1545
https://github.com/CliMA/Oceananigans.jl/pull/1545:352,Safety,avoid,avoid,352,"Not sure if this is something we want to do by default, probably makes sense to make it a `Checkpointer` property, but it's useful as you might want to checkpoint a final time at the end of the simulation (preserving a 3D state) and when running on clusters with time limits, you want to checkpoint one final time before the job's time limit is up (to avoid repeating computational work on subsequent jobs).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1545
https://github.com/CliMA/Oceananigans.jl/issues/1546:126,Deployability,release,releases,126,"It looks like KernelAbstractions.jl has added experimental support for AMD: https://github.com/JuliaGPU/KernelAbstractions.jl/releases/tag/v0.6.0. Should we try to make the code more GPU-architecture-agnostic based on that? From what I've heard, end-user level AMD GPUs are generally cheaper than Nvidia ones for similar performance. So running Oceananigans on AMD could potentially make it significantly easier for people to run simulations on their personal computer instead of a cluster.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1546
https://github.com/CliMA/Oceananigans.jl/issues/1546:321,Performance,perform,performance,321,"It looks like KernelAbstractions.jl has added experimental support for AMD: https://github.com/JuliaGPU/KernelAbstractions.jl/releases/tag/v0.6.0. Should we try to make the code more GPU-architecture-agnostic based on that? From what I've heard, end-user level AMD GPUs are generally cheaper than Nvidia ones for similar performance. So running Oceananigans on AMD could potentially make it significantly easier for people to run simulations on their personal computer instead of a cluster.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1546
https://github.com/CliMA/Oceananigans.jl/issues/1547:95,Availability,Checkpoint,Checkpointer,95,"I'm not sure if we're officially supporting Julia 1.6 yet, but I noticed that when I create a `Checkpointer` in Julia 1.6 things don't really work. All other output files are created normally (meaning for me NetCDF files) but the checkpoint never does and the simulation just hangs there. ```julia; Simulation{typename(IncompressibleModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (TimeStepWizard{Float64}): 2.747 seconds ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: 300.0; ├── Stop time: 7.272 days, stop iteration: Inf; ├── Diagnostics: typename(OrderedCollections.OrderedDict) with 1 entry:; │ └── nan_checker => typename(NaNChecker); └── Output writers: typename(OrderedCollections.OrderedDict) with 4 entries:; │ ├── out_writer => typename(NetCDFOutputWriter); │ ├── vid_writer => typename(NetCDFOutputWriter); │ ├── avg_writer => typename(NetCDFOutputWriter); │ └── chk_writer => typename(Checkpointer). ---> Starting run!; ```. I waited for over 15 min but the next lines (which are supposed to be the progress messenger) never come up. Everything works normally when I revert back to Julia 1.5.3. . I don't have time to create a clean reproducible MWE at the moment, but I can do so later if needed. I just thought I should post this while it's fresh in my head.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547
https://github.com/CliMA/Oceananigans.jl/issues/1547:230,Availability,checkpoint,checkpoint,230,"I'm not sure if we're officially supporting Julia 1.6 yet, but I noticed that when I create a `Checkpointer` in Julia 1.6 things don't really work. All other output files are created normally (meaning for me NetCDF files) but the checkpoint never does and the simulation just hangs there. ```julia; Simulation{typename(IncompressibleModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (TimeStepWizard{Float64}): 2.747 seconds ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: 300.0; ├── Stop time: 7.272 days, stop iteration: Inf; ├── Diagnostics: typename(OrderedCollections.OrderedDict) with 1 entry:; │ └── nan_checker => typename(NaNChecker); └── Output writers: typename(OrderedCollections.OrderedDict) with 4 entries:; │ ├── out_writer => typename(NetCDFOutputWriter); │ ├── vid_writer => typename(NetCDFOutputWriter); │ ├── avg_writer => typename(NetCDFOutputWriter); │ └── chk_writer => typename(Checkpointer). ---> Starting run!; ```. I waited for over 15 min but the next lines (which are supposed to be the progress messenger) never come up. Everything works normally when I revert back to Julia 1.5.3. . I don't have time to create a clean reproducible MWE at the moment, but I can do so later if needed. I just thought I should post this while it's fresh in my head.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547
https://github.com/CliMA/Oceananigans.jl/issues/1547:1147,Availability,Checkpoint,Checkpointer,1147,"I'm not sure if we're officially supporting Julia 1.6 yet, but I noticed that when I create a `Checkpointer` in Julia 1.6 things don't really work. All other output files are created normally (meaning for me NetCDF files) but the checkpoint never does and the simulation just hangs there. ```julia; Simulation{typename(IncompressibleModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (TimeStepWizard{Float64}): 2.747 seconds ; ├── Iteration interval: 5; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: 300.0; ├── Stop time: 7.272 days, stop iteration: Inf; ├── Diagnostics: typename(OrderedCollections.OrderedDict) with 1 entry:; │ └── nan_checker => typename(NaNChecker); └── Output writers: typename(OrderedCollections.OrderedDict) with 4 entries:; │ ├── out_writer => typename(NetCDFOutputWriter); │ ├── vid_writer => typename(NetCDFOutputWriter); │ ├── avg_writer => typename(NetCDFOutputWriter); │ └── chk_writer => typename(Checkpointer). ---> Starting run!; ```. I waited for over 15 min but the next lines (which are supposed to be the progress messenger) never come up. Everything works normally when I revert back to Julia 1.5.3. . I don't have time to create a clean reproducible MWE at the moment, but I can do so later if needed. I just thought I should post this while it's fresh in my head.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547
https://github.com/CliMA/Oceananigans.jl/issues/1548:315,Usability,simpl,simple,315,Probably a question for @whitleyv or @glwagner but how hard would it be to support tracers with the current immersed boundary implementation?. My understanding is that currently the velocity tendencies are corrected inside the immersed boundary but not tracer tendencies (which seems to work fine in 2D?). Is it as simple as adding a new kernel like [`_correct_immersed_tendencies!`](https://github.com/CliMA/Oceananigans.jl/blob/6bfc1551c57403268138b85620d88dba8114a4c0/src/Models/IncompressibleModels/correct_incompressible_immersed_tendencies.jl#L43) but for tracers?. cc @gianlisi @wanyingkang,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1548
https://github.com/CliMA/Oceananigans.jl/issues/1549:246,Availability,avail,available,246,"I believe Oceananigans currently has the option to have curvilinear coordinates in the horizontal and a regular grid in the vertical. This has been used to solve the `HydrostaticFreeSurfaceModel` in spherical coordinates. Using what is currently available, it seems like one could adapt this to create a `HydrostaticFreeSurfaceModel` and maybe `IncompressibleModel` that allows for topography that varies in one-dimension. We could use a curvlinear grid in the `x-z` plane that is build on terrain following coordinates over smooth topography and then use a regular grid for the `y` direction. . I think this model would be interesting in it's own right but if nothing else it could be used for comparison with immersed boundary methods that include topography, which I presume is an idea people have? Immersed boundary could be more powerful in that it would allow for two-dimensional topography. **Questions**: . - If I define a `terrain-following` grid then what new code will need to adapted to do the above? ; - Would this be as easy to do for the nonhydrostatic model as for the hydrostatic one?; - If we define a `boundary-following` shallow water model to deal with smooth coastlines, could we modify the `ShallowWaterModel` to evolve in this geometry? This is actually purely horizontal so maybe it would be easier?. I have not done anything towards these goals and simply testing the waters (pun intended) as to how easy/difficult and interesting, and people think of this. @glwagner ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549
https://github.com/CliMA/Oceananigans.jl/issues/1549:281,Energy Efficiency,adapt,adapt,281,"I believe Oceananigans currently has the option to have curvilinear coordinates in the horizontal and a regular grid in the vertical. This has been used to solve the `HydrostaticFreeSurfaceModel` in spherical coordinates. Using what is currently available, it seems like one could adapt this to create a `HydrostaticFreeSurfaceModel` and maybe `IncompressibleModel` that allows for topography that varies in one-dimension. We could use a curvlinear grid in the `x-z` plane that is build on terrain following coordinates over smooth topography and then use a regular grid for the `y` direction. . I think this model would be interesting in it's own right but if nothing else it could be used for comparison with immersed boundary methods that include topography, which I presume is an idea people have? Immersed boundary could be more powerful in that it would allow for two-dimensional topography. **Questions**: . - If I define a `terrain-following` grid then what new code will need to adapted to do the above? ; - Would this be as easy to do for the nonhydrostatic model as for the hydrostatic one?; - If we define a `boundary-following` shallow water model to deal with smooth coastlines, could we modify the `ShallowWaterModel` to evolve in this geometry? This is actually purely horizontal so maybe it would be easier?. I have not done anything towards these goals and simply testing the waters (pun intended) as to how easy/difficult and interesting, and people think of this. @glwagner ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549
https://github.com/CliMA/Oceananigans.jl/issues/1549:834,Energy Efficiency,power,powerful,834,"I believe Oceananigans currently has the option to have curvilinear coordinates in the horizontal and a regular grid in the vertical. This has been used to solve the `HydrostaticFreeSurfaceModel` in spherical coordinates. Using what is currently available, it seems like one could adapt this to create a `HydrostaticFreeSurfaceModel` and maybe `IncompressibleModel` that allows for topography that varies in one-dimension. We could use a curvlinear grid in the `x-z` plane that is build on terrain following coordinates over smooth topography and then use a regular grid for the `y` direction. . I think this model would be interesting in it's own right but if nothing else it could be used for comparison with immersed boundary methods that include topography, which I presume is an idea people have? Immersed boundary could be more powerful in that it would allow for two-dimensional topography. **Questions**: . - If I define a `terrain-following` grid then what new code will need to adapted to do the above? ; - Would this be as easy to do for the nonhydrostatic model as for the hydrostatic one?; - If we define a `boundary-following` shallow water model to deal with smooth coastlines, could we modify the `ShallowWaterModel` to evolve in this geometry? This is actually purely horizontal so maybe it would be easier?. I have not done anything towards these goals and simply testing the waters (pun intended) as to how easy/difficult and interesting, and people think of this. @glwagner ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549
https://github.com/CliMA/Oceananigans.jl/issues/1549:988,Energy Efficiency,adapt,adapted,988,"I believe Oceananigans currently has the option to have curvilinear coordinates in the horizontal and a regular grid in the vertical. This has been used to solve the `HydrostaticFreeSurfaceModel` in spherical coordinates. Using what is currently available, it seems like one could adapt this to create a `HydrostaticFreeSurfaceModel` and maybe `IncompressibleModel` that allows for topography that varies in one-dimension. We could use a curvlinear grid in the `x-z` plane that is build on terrain following coordinates over smooth topography and then use a regular grid for the `y` direction. . I think this model would be interesting in it's own right but if nothing else it could be used for comparison with immersed boundary methods that include topography, which I presume is an idea people have? Immersed boundary could be more powerful in that it would allow for two-dimensional topography. **Questions**: . - If I define a `terrain-following` grid then what new code will need to adapted to do the above? ; - Would this be as easy to do for the nonhydrostatic model as for the hydrostatic one?; - If we define a `boundary-following` shallow water model to deal with smooth coastlines, could we modify the `ShallowWaterModel` to evolve in this geometry? This is actually purely horizontal so maybe it would be easier?. I have not done anything towards these goals and simply testing the waters (pun intended) as to how easy/difficult and interesting, and people think of this. @glwagner ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549
https://github.com/CliMA/Oceananigans.jl/issues/1549:281,Modifiability,adapt,adapt,281,"I believe Oceananigans currently has the option to have curvilinear coordinates in the horizontal and a regular grid in the vertical. This has been used to solve the `HydrostaticFreeSurfaceModel` in spherical coordinates. Using what is currently available, it seems like one could adapt this to create a `HydrostaticFreeSurfaceModel` and maybe `IncompressibleModel` that allows for topography that varies in one-dimension. We could use a curvlinear grid in the `x-z` plane that is build on terrain following coordinates over smooth topography and then use a regular grid for the `y` direction. . I think this model would be interesting in it's own right but if nothing else it could be used for comparison with immersed boundary methods that include topography, which I presume is an idea people have? Immersed boundary could be more powerful in that it would allow for two-dimensional topography. **Questions**: . - If I define a `terrain-following` grid then what new code will need to adapted to do the above? ; - Would this be as easy to do for the nonhydrostatic model as for the hydrostatic one?; - If we define a `boundary-following` shallow water model to deal with smooth coastlines, could we modify the `ShallowWaterModel` to evolve in this geometry? This is actually purely horizontal so maybe it would be easier?. I have not done anything towards these goals and simply testing the waters (pun intended) as to how easy/difficult and interesting, and people think of this. @glwagner ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549
https://github.com/CliMA/Oceananigans.jl/issues/1549:988,Modifiability,adapt,adapted,988,"I believe Oceananigans currently has the option to have curvilinear coordinates in the horizontal and a regular grid in the vertical. This has been used to solve the `HydrostaticFreeSurfaceModel` in spherical coordinates. Using what is currently available, it seems like one could adapt this to create a `HydrostaticFreeSurfaceModel` and maybe `IncompressibleModel` that allows for topography that varies in one-dimension. We could use a curvlinear grid in the `x-z` plane that is build on terrain following coordinates over smooth topography and then use a regular grid for the `y` direction. . I think this model would be interesting in it's own right but if nothing else it could be used for comparison with immersed boundary methods that include topography, which I presume is an idea people have? Immersed boundary could be more powerful in that it would allow for two-dimensional topography. **Questions**: . - If I define a `terrain-following` grid then what new code will need to adapted to do the above? ; - Would this be as easy to do for the nonhydrostatic model as for the hydrostatic one?; - If we define a `boundary-following` shallow water model to deal with smooth coastlines, could we modify the `ShallowWaterModel` to evolve in this geometry? This is actually purely horizontal so maybe it would be easier?. I have not done anything towards these goals and simply testing the waters (pun intended) as to how easy/difficult and interesting, and people think of this. @glwagner ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549
https://github.com/CliMA/Oceananigans.jl/issues/1549:1236,Modifiability,evolve,evolve,1236,"I believe Oceananigans currently has the option to have curvilinear coordinates in the horizontal and a regular grid in the vertical. This has been used to solve the `HydrostaticFreeSurfaceModel` in spherical coordinates. Using what is currently available, it seems like one could adapt this to create a `HydrostaticFreeSurfaceModel` and maybe `IncompressibleModel` that allows for topography that varies in one-dimension. We could use a curvlinear grid in the `x-z` plane that is build on terrain following coordinates over smooth topography and then use a regular grid for the `y` direction. . I think this model would be interesting in it's own right but if nothing else it could be used for comparison with immersed boundary methods that include topography, which I presume is an idea people have? Immersed boundary could be more powerful in that it would allow for two-dimensional topography. **Questions**: . - If I define a `terrain-following` grid then what new code will need to adapted to do the above? ; - Would this be as easy to do for the nonhydrostatic model as for the hydrostatic one?; - If we define a `boundary-following` shallow water model to deal with smooth coastlines, could we modify the `ShallowWaterModel` to evolve in this geometry? This is actually purely horizontal so maybe it would be easier?. I have not done anything towards these goals and simply testing the waters (pun intended) as to how easy/difficult and interesting, and people think of this. @glwagner ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549
https://github.com/CliMA/Oceananigans.jl/issues/1549:1382,Testability,test,testing,1382,"I believe Oceananigans currently has the option to have curvilinear coordinates in the horizontal and a regular grid in the vertical. This has been used to solve the `HydrostaticFreeSurfaceModel` in spherical coordinates. Using what is currently available, it seems like one could adapt this to create a `HydrostaticFreeSurfaceModel` and maybe `IncompressibleModel` that allows for topography that varies in one-dimension. We could use a curvlinear grid in the `x-z` plane that is build on terrain following coordinates over smooth topography and then use a regular grid for the `y` direction. . I think this model would be interesting in it's own right but if nothing else it could be used for comparison with immersed boundary methods that include topography, which I presume is an idea people have? Immersed boundary could be more powerful in that it would allow for two-dimensional topography. **Questions**: . - If I define a `terrain-following` grid then what new code will need to adapted to do the above? ; - Would this be as easy to do for the nonhydrostatic model as for the hydrostatic one?; - If we define a `boundary-following` shallow water model to deal with smooth coastlines, could we modify the `ShallowWaterModel` to evolve in this geometry? This is actually purely horizontal so maybe it would be easier?. I have not done anything towards these goals and simply testing the waters (pun intended) as to how easy/difficult and interesting, and people think of this. @glwagner ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549
https://github.com/CliMA/Oceananigans.jl/issues/1549:1375,Usability,simpl,simply,1375,"I believe Oceananigans currently has the option to have curvilinear coordinates in the horizontal and a regular grid in the vertical. This has been used to solve the `HydrostaticFreeSurfaceModel` in spherical coordinates. Using what is currently available, it seems like one could adapt this to create a `HydrostaticFreeSurfaceModel` and maybe `IncompressibleModel` that allows for topography that varies in one-dimension. We could use a curvlinear grid in the `x-z` plane that is build on terrain following coordinates over smooth topography and then use a regular grid for the `y` direction. . I think this model would be interesting in it's own right but if nothing else it could be used for comparison with immersed boundary methods that include topography, which I presume is an idea people have? Immersed boundary could be more powerful in that it would allow for two-dimensional topography. **Questions**: . - If I define a `terrain-following` grid then what new code will need to adapted to do the above? ; - Would this be as easy to do for the nonhydrostatic model as for the hydrostatic one?; - If we define a `boundary-following` shallow water model to deal with smooth coastlines, could we modify the `ShallowWaterModel` to evolve in this geometry? This is actually purely horizontal so maybe it would be easier?. I have not done anything towards these goals and simply testing the waters (pun intended) as to how easy/difficult and interesting, and people think of this. @glwagner ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549
https://github.com/CliMA/Oceananigans.jl/issues/1551:955,Deployability,continuous,continuous,955,"This issue picks up a conversation on #1544 about user interface design for stretched grids. On that PR various proposals for specifying the nodes / cell interfaces of `VerticallyStretchedRectilinearGrid` were proposed. To preface: we don't need to have a _single_ interface, since it may actually be useful to have various options for specification. Some users may want to provide arrays that specify cell interface locations, others may want to use generating functions. The currently proposed options require some understanding of the staggered grid. The current interface requires a keyword argument `zF` that specifies the location of vertical cell interfaces. #1544 proposed to change the name of this argument to `z_faces` or `z_stretch`. For this interface the meaning of the keyword argument needs to be explained in terms of the staggered grid. An alternative possibility is an interface that uses a mapping or warping function that maps from a continuous, unstretched coordinate to a stretched coordinate. This interface would then resemble the interface for `RegularRectilinearGrid` in that users would provide both `size` and `z` to specify the number of grid points and the end points of the interval. However, an additional argument such as `z_stretching` would be used to specify how the grid is compressed or stretched. One example is to generate a grid with Chebyshev spacing in z. For this a user writes. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = z -> cos(π / 2 * (z - 1))); ```. The main difference between this type of interface and an interface using a generating function with keyword argument `z_faces` is that the number of grid points is not a parameter in the continuous map `z_stretching`. cc @francispoulin @kburns @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551
https://github.com/CliMA/Oceananigans.jl/issues/1551:1777,Deployability,continuous,continuous,1777,"This issue picks up a conversation on #1544 about user interface design for stretched grids. On that PR various proposals for specifying the nodes / cell interfaces of `VerticallyStretchedRectilinearGrid` were proposed. To preface: we don't need to have a _single_ interface, since it may actually be useful to have various options for specification. Some users may want to provide arrays that specify cell interface locations, others may want to use generating functions. The currently proposed options require some understanding of the staggered grid. The current interface requires a keyword argument `zF` that specifies the location of vertical cell interfaces. #1544 proposed to change the name of this argument to `z_faces` or `z_stretch`. For this interface the meaning of the keyword argument needs to be explained in terms of the staggered grid. An alternative possibility is an interface that uses a mapping or warping function that maps from a continuous, unstretched coordinate to a stretched coordinate. This interface would then resemble the interface for `RegularRectilinearGrid` in that users would provide both `size` and `z` to specify the number of grid points and the end points of the interval. However, an additional argument such as `z_stretching` would be used to specify how the grid is compressed or stretched. One example is to generate a grid with Chebyshev spacing in z. For this a user writes. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = z -> cos(π / 2 * (z - 1))); ```. The main difference between this type of interface and an interface using a generating function with keyword argument `z_faces` is that the number of grid points is not a parameter in the continuous map `z_stretching`. cc @francispoulin @kburns @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551
https://github.com/CliMA/Oceananigans.jl/issues/1551:55,Integrability,interface,interface,55,"This issue picks up a conversation on #1544 about user interface design for stretched grids. On that PR various proposals for specifying the nodes / cell interfaces of `VerticallyStretchedRectilinearGrid` were proposed. To preface: we don't need to have a _single_ interface, since it may actually be useful to have various options for specification. Some users may want to provide arrays that specify cell interface locations, others may want to use generating functions. The currently proposed options require some understanding of the staggered grid. The current interface requires a keyword argument `zF` that specifies the location of vertical cell interfaces. #1544 proposed to change the name of this argument to `z_faces` or `z_stretch`. For this interface the meaning of the keyword argument needs to be explained in terms of the staggered grid. An alternative possibility is an interface that uses a mapping or warping function that maps from a continuous, unstretched coordinate to a stretched coordinate. This interface would then resemble the interface for `RegularRectilinearGrid` in that users would provide both `size` and `z` to specify the number of grid points and the end points of the interval. However, an additional argument such as `z_stretching` would be used to specify how the grid is compressed or stretched. One example is to generate a grid with Chebyshev spacing in z. For this a user writes. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = z -> cos(π / 2 * (z - 1))); ```. The main difference between this type of interface and an interface using a generating function with keyword argument `z_faces` is that the number of grid points is not a parameter in the continuous map `z_stretching`. cc @francispoulin @kburns @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551
https://github.com/CliMA/Oceananigans.jl/issues/1551:154,Integrability,interface,interfaces,154,"This issue picks up a conversation on #1544 about user interface design for stretched grids. On that PR various proposals for specifying the nodes / cell interfaces of `VerticallyStretchedRectilinearGrid` were proposed. To preface: we don't need to have a _single_ interface, since it may actually be useful to have various options for specification. Some users may want to provide arrays that specify cell interface locations, others may want to use generating functions. The currently proposed options require some understanding of the staggered grid. The current interface requires a keyword argument `zF` that specifies the location of vertical cell interfaces. #1544 proposed to change the name of this argument to `z_faces` or `z_stretch`. For this interface the meaning of the keyword argument needs to be explained in terms of the staggered grid. An alternative possibility is an interface that uses a mapping or warping function that maps from a continuous, unstretched coordinate to a stretched coordinate. This interface would then resemble the interface for `RegularRectilinearGrid` in that users would provide both `size` and `z` to specify the number of grid points and the end points of the interval. However, an additional argument such as `z_stretching` would be used to specify how the grid is compressed or stretched. One example is to generate a grid with Chebyshev spacing in z. For this a user writes. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = z -> cos(π / 2 * (z - 1))); ```. The main difference between this type of interface and an interface using a generating function with keyword argument `z_faces` is that the number of grid points is not a parameter in the continuous map `z_stretching`. cc @francispoulin @kburns @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551
https://github.com/CliMA/Oceananigans.jl/issues/1551:265,Integrability,interface,interface,265,"This issue picks up a conversation on #1544 about user interface design for stretched grids. On that PR various proposals for specifying the nodes / cell interfaces of `VerticallyStretchedRectilinearGrid` were proposed. To preface: we don't need to have a _single_ interface, since it may actually be useful to have various options for specification. Some users may want to provide arrays that specify cell interface locations, others may want to use generating functions. The currently proposed options require some understanding of the staggered grid. The current interface requires a keyword argument `zF` that specifies the location of vertical cell interfaces. #1544 proposed to change the name of this argument to `z_faces` or `z_stretch`. For this interface the meaning of the keyword argument needs to be explained in terms of the staggered grid. An alternative possibility is an interface that uses a mapping or warping function that maps from a continuous, unstretched coordinate to a stretched coordinate. This interface would then resemble the interface for `RegularRectilinearGrid` in that users would provide both `size` and `z` to specify the number of grid points and the end points of the interval. However, an additional argument such as `z_stretching` would be used to specify how the grid is compressed or stretched. One example is to generate a grid with Chebyshev spacing in z. For this a user writes. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = z -> cos(π / 2 * (z - 1))); ```. The main difference between this type of interface and an interface using a generating function with keyword argument `z_faces` is that the number of grid points is not a parameter in the continuous map `z_stretching`. cc @francispoulin @kburns @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551
https://github.com/CliMA/Oceananigans.jl/issues/1551:407,Integrability,interface,interface,407,"This issue picks up a conversation on #1544 about user interface design for stretched grids. On that PR various proposals for specifying the nodes / cell interfaces of `VerticallyStretchedRectilinearGrid` were proposed. To preface: we don't need to have a _single_ interface, since it may actually be useful to have various options for specification. Some users may want to provide arrays that specify cell interface locations, others may want to use generating functions. The currently proposed options require some understanding of the staggered grid. The current interface requires a keyword argument `zF` that specifies the location of vertical cell interfaces. #1544 proposed to change the name of this argument to `z_faces` or `z_stretch`. For this interface the meaning of the keyword argument needs to be explained in terms of the staggered grid. An alternative possibility is an interface that uses a mapping or warping function that maps from a continuous, unstretched coordinate to a stretched coordinate. This interface would then resemble the interface for `RegularRectilinearGrid` in that users would provide both `size` and `z` to specify the number of grid points and the end points of the interval. However, an additional argument such as `z_stretching` would be used to specify how the grid is compressed or stretched. One example is to generate a grid with Chebyshev spacing in z. For this a user writes. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = z -> cos(π / 2 * (z - 1))); ```. The main difference between this type of interface and an interface using a generating function with keyword argument `z_faces` is that the number of grid points is not a parameter in the continuous map `z_stretching`. cc @francispoulin @kburns @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551
https://github.com/CliMA/Oceananigans.jl/issues/1551:566,Integrability,interface,interface,566,"This issue picks up a conversation on #1544 about user interface design for stretched grids. On that PR various proposals for specifying the nodes / cell interfaces of `VerticallyStretchedRectilinearGrid` were proposed. To preface: we don't need to have a _single_ interface, since it may actually be useful to have various options for specification. Some users may want to provide arrays that specify cell interface locations, others may want to use generating functions. The currently proposed options require some understanding of the staggered grid. The current interface requires a keyword argument `zF` that specifies the location of vertical cell interfaces. #1544 proposed to change the name of this argument to `z_faces` or `z_stretch`. For this interface the meaning of the keyword argument needs to be explained in terms of the staggered grid. An alternative possibility is an interface that uses a mapping or warping function that maps from a continuous, unstretched coordinate to a stretched coordinate. This interface would then resemble the interface for `RegularRectilinearGrid` in that users would provide both `size` and `z` to specify the number of grid points and the end points of the interval. However, an additional argument such as `z_stretching` would be used to specify how the grid is compressed or stretched. One example is to generate a grid with Chebyshev spacing in z. For this a user writes. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = z -> cos(π / 2 * (z - 1))); ```. The main difference between this type of interface and an interface using a generating function with keyword argument `z_faces` is that the number of grid points is not a parameter in the continuous map `z_stretching`. cc @francispoulin @kburns @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551
https://github.com/CliMA/Oceananigans.jl/issues/1551:654,Integrability,interface,interfaces,654,"This issue picks up a conversation on #1544 about user interface design for stretched grids. On that PR various proposals for specifying the nodes / cell interfaces of `VerticallyStretchedRectilinearGrid` were proposed. To preface: we don't need to have a _single_ interface, since it may actually be useful to have various options for specification. Some users may want to provide arrays that specify cell interface locations, others may want to use generating functions. The currently proposed options require some understanding of the staggered grid. The current interface requires a keyword argument `zF` that specifies the location of vertical cell interfaces. #1544 proposed to change the name of this argument to `z_faces` or `z_stretch`. For this interface the meaning of the keyword argument needs to be explained in terms of the staggered grid. An alternative possibility is an interface that uses a mapping or warping function that maps from a continuous, unstretched coordinate to a stretched coordinate. This interface would then resemble the interface for `RegularRectilinearGrid` in that users would provide both `size` and `z` to specify the number of grid points and the end points of the interval. However, an additional argument such as `z_stretching` would be used to specify how the grid is compressed or stretched. One example is to generate a grid with Chebyshev spacing in z. For this a user writes. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = z -> cos(π / 2 * (z - 1))); ```. The main difference between this type of interface and an interface using a generating function with keyword argument `z_faces` is that the number of grid points is not a parameter in the continuous map `z_stretching`. cc @francispoulin @kburns @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551
https://github.com/CliMA/Oceananigans.jl/issues/1551:755,Integrability,interface,interface,755,"This issue picks up a conversation on #1544 about user interface design for stretched grids. On that PR various proposals for specifying the nodes / cell interfaces of `VerticallyStretchedRectilinearGrid` were proposed. To preface: we don't need to have a _single_ interface, since it may actually be useful to have various options for specification. Some users may want to provide arrays that specify cell interface locations, others may want to use generating functions. The currently proposed options require some understanding of the staggered grid. The current interface requires a keyword argument `zF` that specifies the location of vertical cell interfaces. #1544 proposed to change the name of this argument to `z_faces` or `z_stretch`. For this interface the meaning of the keyword argument needs to be explained in terms of the staggered grid. An alternative possibility is an interface that uses a mapping or warping function that maps from a continuous, unstretched coordinate to a stretched coordinate. This interface would then resemble the interface for `RegularRectilinearGrid` in that users would provide both `size` and `z` to specify the number of grid points and the end points of the interval. However, an additional argument such as `z_stretching` would be used to specify how the grid is compressed or stretched. One example is to generate a grid with Chebyshev spacing in z. For this a user writes. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = z -> cos(π / 2 * (z - 1))); ```. The main difference between this type of interface and an interface using a generating function with keyword argument `z_faces` is that the number of grid points is not a parameter in the continuous map `z_stretching`. cc @francispoulin @kburns @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551
https://github.com/CliMA/Oceananigans.jl/issues/1551:888,Integrability,interface,interface,888,"This issue picks up a conversation on #1544 about user interface design for stretched grids. On that PR various proposals for specifying the nodes / cell interfaces of `VerticallyStretchedRectilinearGrid` were proposed. To preface: we don't need to have a _single_ interface, since it may actually be useful to have various options for specification. Some users may want to provide arrays that specify cell interface locations, others may want to use generating functions. The currently proposed options require some understanding of the staggered grid. The current interface requires a keyword argument `zF` that specifies the location of vertical cell interfaces. #1544 proposed to change the name of this argument to `z_faces` or `z_stretch`. For this interface the meaning of the keyword argument needs to be explained in terms of the staggered grid. An alternative possibility is an interface that uses a mapping or warping function that maps from a continuous, unstretched coordinate to a stretched coordinate. This interface would then resemble the interface for `RegularRectilinearGrid` in that users would provide both `size` and `z` to specify the number of grid points and the end points of the interval. However, an additional argument such as `z_stretching` would be used to specify how the grid is compressed or stretched. One example is to generate a grid with Chebyshev spacing in z. For this a user writes. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = z -> cos(π / 2 * (z - 1))); ```. The main difference between this type of interface and an interface using a generating function with keyword argument `z_faces` is that the number of grid points is not a parameter in the continuous map `z_stretching`. cc @francispoulin @kburns @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551
https://github.com/CliMA/Oceananigans.jl/issues/1551:1022,Integrability,interface,interface,1022,"This issue picks up a conversation on #1544 about user interface design for stretched grids. On that PR various proposals for specifying the nodes / cell interfaces of `VerticallyStretchedRectilinearGrid` were proposed. To preface: we don't need to have a _single_ interface, since it may actually be useful to have various options for specification. Some users may want to provide arrays that specify cell interface locations, others may want to use generating functions. The currently proposed options require some understanding of the staggered grid. The current interface requires a keyword argument `zF` that specifies the location of vertical cell interfaces. #1544 proposed to change the name of this argument to `z_faces` or `z_stretch`. For this interface the meaning of the keyword argument needs to be explained in terms of the staggered grid. An alternative possibility is an interface that uses a mapping or warping function that maps from a continuous, unstretched coordinate to a stretched coordinate. This interface would then resemble the interface for `RegularRectilinearGrid` in that users would provide both `size` and `z` to specify the number of grid points and the end points of the interval. However, an additional argument such as `z_stretching` would be used to specify how the grid is compressed or stretched. One example is to generate a grid with Chebyshev spacing in z. For this a user writes. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = z -> cos(π / 2 * (z - 1))); ```. The main difference between this type of interface and an interface using a generating function with keyword argument `z_faces` is that the number of grid points is not a parameter in the continuous map `z_stretching`. cc @francispoulin @kburns @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551
https://github.com/CliMA/Oceananigans.jl/issues/1551:1056,Integrability,interface,interface,1056,"This issue picks up a conversation on #1544 about user interface design for stretched grids. On that PR various proposals for specifying the nodes / cell interfaces of `VerticallyStretchedRectilinearGrid` were proposed. To preface: we don't need to have a _single_ interface, since it may actually be useful to have various options for specification. Some users may want to provide arrays that specify cell interface locations, others may want to use generating functions. The currently proposed options require some understanding of the staggered grid. The current interface requires a keyword argument `zF` that specifies the location of vertical cell interfaces. #1544 proposed to change the name of this argument to `z_faces` or `z_stretch`. For this interface the meaning of the keyword argument needs to be explained in terms of the staggered grid. An alternative possibility is an interface that uses a mapping or warping function that maps from a continuous, unstretched coordinate to a stretched coordinate. This interface would then resemble the interface for `RegularRectilinearGrid` in that users would provide both `size` and `z` to specify the number of grid points and the end points of the interval. However, an additional argument such as `z_stretching` would be used to specify how the grid is compressed or stretched. One example is to generate a grid with Chebyshev spacing in z. For this a user writes. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = z -> cos(π / 2 * (z - 1))); ```. The main difference between this type of interface and an interface using a generating function with keyword argument `z_faces` is that the number of grid points is not a parameter in the continuous map `z_stretching`. cc @francispoulin @kburns @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551
https://github.com/CliMA/Oceananigans.jl/issues/1551:1630,Integrability,interface,interface,1630,"This issue picks up a conversation on #1544 about user interface design for stretched grids. On that PR various proposals for specifying the nodes / cell interfaces of `VerticallyStretchedRectilinearGrid` were proposed. To preface: we don't need to have a _single_ interface, since it may actually be useful to have various options for specification. Some users may want to provide arrays that specify cell interface locations, others may want to use generating functions. The currently proposed options require some understanding of the staggered grid. The current interface requires a keyword argument `zF` that specifies the location of vertical cell interfaces. #1544 proposed to change the name of this argument to `z_faces` or `z_stretch`. For this interface the meaning of the keyword argument needs to be explained in terms of the staggered grid. An alternative possibility is an interface that uses a mapping or warping function that maps from a continuous, unstretched coordinate to a stretched coordinate. This interface would then resemble the interface for `RegularRectilinearGrid` in that users would provide both `size` and `z` to specify the number of grid points and the end points of the interval. However, an additional argument such as `z_stretching` would be used to specify how the grid is compressed or stretched. One example is to generate a grid with Chebyshev spacing in z. For this a user writes. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = z -> cos(π / 2 * (z - 1))); ```. The main difference between this type of interface and an interface using a generating function with keyword argument `z_faces` is that the number of grid points is not a parameter in the continuous map `z_stretching`. cc @francispoulin @kburns @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551
https://github.com/CliMA/Oceananigans.jl/issues/1551:1647,Integrability,interface,interface,1647,"This issue picks up a conversation on #1544 about user interface design for stretched grids. On that PR various proposals for specifying the nodes / cell interfaces of `VerticallyStretchedRectilinearGrid` were proposed. To preface: we don't need to have a _single_ interface, since it may actually be useful to have various options for specification. Some users may want to provide arrays that specify cell interface locations, others may want to use generating functions. The currently proposed options require some understanding of the staggered grid. The current interface requires a keyword argument `zF` that specifies the location of vertical cell interfaces. #1544 proposed to change the name of this argument to `z_faces` or `z_stretch`. For this interface the meaning of the keyword argument needs to be explained in terms of the staggered grid. An alternative possibility is an interface that uses a mapping or warping function that maps from a continuous, unstretched coordinate to a stretched coordinate. This interface would then resemble the interface for `RegularRectilinearGrid` in that users would provide both `size` and `z` to specify the number of grid points and the end points of the interval. However, an additional argument such as `z_stretching` would be used to specify how the grid is compressed or stretched. One example is to generate a grid with Chebyshev spacing in z. For this a user writes. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = z -> cos(π / 2 * (z - 1))); ```. The main difference between this type of interface and an interface using a generating function with keyword argument `z_faces` is that the number of grid points is not a parameter in the continuous map `z_stretching`. cc @francispoulin @kburns @tomchor @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551
https://github.com/CliMA/Oceananigans.jl/pull/1552:70,Deployability,update,updated,70,Unit tests are ~~failing~~ hanging because a data dependency has been updated causing the checksum to not match. https://github.com/CliMA/OceananigansArtifacts.jl/pull/3,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1552
https://github.com/CliMA/Oceananigans.jl/pull/1552:50,Integrability,depend,dependency,50,Unit tests are ~~failing~~ hanging because a data dependency has been updated causing the checksum to not match. https://github.com/CliMA/OceananigansArtifacts.jl/pull/3,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1552
https://github.com/CliMA/Oceananigans.jl/pull/1552:90,Security,checksum,checksum,90,Unit tests are ~~failing~~ hanging because a data dependency has been updated causing the checksum to not match. https://github.com/CliMA/OceananigansArtifacts.jl/pull/3,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1552
https://github.com/CliMA/Oceananigans.jl/pull/1552:5,Testability,test,tests,5,Unit tests are ~~failing~~ hanging because a data dependency has been updated causing the checksum to not match. https://github.com/CliMA/OceananigansArtifacts.jl/pull/3,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1552
https://github.com/CliMA/Oceananigans.jl/issues/1553:802,Energy Efficiency,Efficient,Efficient,802,"Okay, so I'm just gonna throw this out there: is it advantageous to migrate the Poisson solvers to a separate package (PoissonSolvers.jl)? It would be akin to the relationship between PencilFFTs.jl and PencilArrays.jl. I've been thinking about it for the past few days and I can see some pros:. - Separating the code can make Oceananigans easier to maintain:; - fewer things to test in every PR (the tests are becoming larger and larger and apparently we're starting to have backlogs on buildkite); - fewer lines/modules in general can make it easier to make sense of the code, especially for beginner users/contributors (in general the smaller the code base, the easier it is to attract contributors). Also having (brief) docs just for the solvers would be a very useful reference in general imho.; - Efficient Poisson solvers are hard to write and it's an art of their own since different BCs generally require different algorithms. With that said, having a separate package just for that might not only benefit the community (a quick google search for something like ""poisson solver julia"" shows that there's interest) but also it might make it easier for someone who needs a specific algorithm that we don't yet have to make a contribution that might help us. That said, I've never touched the Poisson solvers in Oceananigans so I don't know how ""portable"" they are, or if there are significant disadvantages. So some feedback here would be helpful. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553
https://github.com/CliMA/Oceananigans.jl/issues/1553:1351,Modifiability,portab,portable,1351,"Okay, so I'm just gonna throw this out there: is it advantageous to migrate the Poisson solvers to a separate package (PoissonSolvers.jl)? It would be akin to the relationship between PencilFFTs.jl and PencilArrays.jl. I've been thinking about it for the past few days and I can see some pros:. - Separating the code can make Oceananigans easier to maintain:; - fewer things to test in every PR (the tests are becoming larger and larger and apparently we're starting to have backlogs on buildkite); - fewer lines/modules in general can make it easier to make sense of the code, especially for beginner users/contributors (in general the smaller the code base, the easier it is to attract contributors). Also having (brief) docs just for the solvers would be a very useful reference in general imho.; - Efficient Poisson solvers are hard to write and it's an art of their own since different BCs generally require different algorithms. With that said, having a separate package just for that might not only benefit the community (a quick google search for something like ""poisson solver julia"" shows that there's interest) but also it might make it easier for someone who needs a specific algorithm that we don't yet have to make a contribution that might help us. That said, I've never touched the Poisson solvers in Oceananigans so I don't know how ""portable"" they are, or if there are significant disadvantages. So some feedback here would be helpful. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553
https://github.com/CliMA/Oceananigans.jl/issues/1553:378,Testability,test,test,378,"Okay, so I'm just gonna throw this out there: is it advantageous to migrate the Poisson solvers to a separate package (PoissonSolvers.jl)? It would be akin to the relationship between PencilFFTs.jl and PencilArrays.jl. I've been thinking about it for the past few days and I can see some pros:. - Separating the code can make Oceananigans easier to maintain:; - fewer things to test in every PR (the tests are becoming larger and larger and apparently we're starting to have backlogs on buildkite); - fewer lines/modules in general can make it easier to make sense of the code, especially for beginner users/contributors (in general the smaller the code base, the easier it is to attract contributors). Also having (brief) docs just for the solvers would be a very useful reference in general imho.; - Efficient Poisson solvers are hard to write and it's an art of their own since different BCs generally require different algorithms. With that said, having a separate package just for that might not only benefit the community (a quick google search for something like ""poisson solver julia"" shows that there's interest) but also it might make it easier for someone who needs a specific algorithm that we don't yet have to make a contribution that might help us. That said, I've never touched the Poisson solvers in Oceananigans so I don't know how ""portable"" they are, or if there are significant disadvantages. So some feedback here would be helpful. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553
https://github.com/CliMA/Oceananigans.jl/issues/1553:400,Testability,test,tests,400,"Okay, so I'm just gonna throw this out there: is it advantageous to migrate the Poisson solvers to a separate package (PoissonSolvers.jl)? It would be akin to the relationship between PencilFFTs.jl and PencilArrays.jl. I've been thinking about it for the past few days and I can see some pros:. - Separating the code can make Oceananigans easier to maintain:; - fewer things to test in every PR (the tests are becoming larger and larger and apparently we're starting to have backlogs on buildkite); - fewer lines/modules in general can make it easier to make sense of the code, especially for beginner users/contributors (in general the smaller the code base, the easier it is to attract contributors). Also having (brief) docs just for the solvers would be a very useful reference in general imho.; - Efficient Poisson solvers are hard to write and it's an art of their own since different BCs generally require different algorithms. With that said, having a separate package just for that might not only benefit the community (a quick google search for something like ""poisson solver julia"" shows that there's interest) but also it might make it easier for someone who needs a specific algorithm that we don't yet have to make a contribution that might help us. That said, I've never touched the Poisson solvers in Oceananigans so I don't know how ""portable"" they are, or if there are significant disadvantages. So some feedback here would be helpful. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553
https://github.com/CliMA/Oceananigans.jl/issues/1553:1422,Usability,feedback,feedback,1422,"Okay, so I'm just gonna throw this out there: is it advantageous to migrate the Poisson solvers to a separate package (PoissonSolvers.jl)? It would be akin to the relationship between PencilFFTs.jl and PencilArrays.jl. I've been thinking about it for the past few days and I can see some pros:. - Separating the code can make Oceananigans easier to maintain:; - fewer things to test in every PR (the tests are becoming larger and larger and apparently we're starting to have backlogs on buildkite); - fewer lines/modules in general can make it easier to make sense of the code, especially for beginner users/contributors (in general the smaller the code base, the easier it is to attract contributors). Also having (brief) docs just for the solvers would be a very useful reference in general imho.; - Efficient Poisson solvers are hard to write and it's an art of their own since different BCs generally require different algorithms. With that said, having a separate package just for that might not only benefit the community (a quick google search for something like ""poisson solver julia"" shows that there's interest) but also it might make it easier for someone who needs a specific algorithm that we don't yet have to make a contribution that might help us. That said, I've never touched the Poisson solvers in Oceananigans so I don't know how ""portable"" they are, or if there are significant disadvantages. So some feedback here would be helpful. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553
https://github.com/CliMA/Oceananigans.jl/issues/1554:631,Availability,ERROR,ERROR,631,"I have put together an example for my own benefit (not to be merged into master unless people want it to be) that looks at the simulation of inertial instability in 2D. See [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/inertially_unstable_jet.jl) for the code. . I believe everything is working on a CPU but I am having two difficulties with GPUs. . 1. In line 39, where I define the background buoyancy of the jet, I can't use `coriolis.f` because CUDA seems to need a global variable and this doesn't cut it. I am presently using `f` instead and this works, but should this work? `ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!`; 2. When I make a simulation from a gpu calculation, I get that the buoyancy perturbation has perturbations at the top and bottom, which are not physical. Which is to say that it has different boundary conditions. I didn't actually specify the boundary conditions differently but just wanted a solid top and bottom. If I specify the boundary conditions explicitly, should this fix the problem? Maybe that's a fix but is this expected behaviour?. https://user-images.githubusercontent.com/8239041/113899192-8d851900-979a-11eb-97a7-b7f8085864b7.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554
https://github.com/CliMA/Oceananigans.jl/issues/1554:525,Modifiability,variab,variable,525,"I have put together an example for my own benefit (not to be merged into master unless people want it to be) that looks at the simulation of inertial instability in 2D. See [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/inertially_unstable_jet.jl) for the code. . I believe everything is working on a CPU but I am having two difficulties with GPUs. . 1. In line 39, where I define the background buoyancy of the jet, I can't use `coriolis.f` because CUDA seems to need a global variable and this doesn't cut it. I am presently using `f` instead and this works, but should this work? `ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!`; 2. When I make a simulation from a gpu calculation, I get that the buoyancy perturbation has perturbations at the top and bottom, which are not physical. Which is to say that it has different boundary conditions. I didn't actually specify the boundary conditions differently but just wanted a solid top and bottom. If I specify the boundary conditions explicitly, should this fix the problem? Maybe that's a fix but is this expected behaviour?. https://user-images.githubusercontent.com/8239041/113899192-8d851900-979a-11eb-97a7-b7f8085864b7.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554
https://github.com/CliMA/Oceananigans.jl/issues/1554:638,Performance,Load,LoadError,638,"I have put together an example for my own benefit (not to be merged into master unless people want it to be) that looks at the simulation of inertial instability in 2D. See [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/inertially_unstable_jet.jl) for the code. . I believe everything is working on a CPU but I am having two difficulties with GPUs. . 1. In line 39, where I define the background buoyancy of the jet, I can't use `coriolis.f` because CUDA seems to need a global variable and this doesn't cut it. I am presently using `f` instead and this works, but should this work? `ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!`; 2. When I make a simulation from a gpu calculation, I get that the buoyancy perturbation has perturbations at the top and bottom, which are not physical. Which is to say that it has different boundary conditions. I didn't actually specify the boundary conditions differently but just wanted a solid top and bottom. If I specify the boundary conditions explicitly, should this fix the problem? Maybe that's a fix but is this expected behaviour?. https://user-images.githubusercontent.com/8239041/113899192-8d851900-979a-11eb-97a7-b7f8085864b7.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554
https://github.com/CliMA/Oceananigans.jl/issues/1555:281,Availability,error,error,281,"I am using Oceananigans v0.54.0 with Julia v1.6 on GPU. I tried setting an initial condition in salinity as follows:. ```; Stop = 29.5; Sbot = 32; ztop = -35; zbot = -70; dSdz = (Sbot-Stop)/ztop; S_func(x, y, z) = Stop + dSdz*(z > ztop)*z ; set!(model, S=S_func); ```. and got the error copied below. Note that this works fine in Julia v1.5.4. . ```; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/3q18R/deps/deps.jl:15; ERROR: LoadError: MethodError: no method matching set!(::Field{Center, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, CuArray{Float64, 2}}}}}}, ::typeof(S_func)); Closest candidates are:; set!(::Oceananigans.Fields.AbstractField, !Matched::Number) at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:14; set!(::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G, !Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G) where {X, Y, Z, A} at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:16; set!(!Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where {X, Y, Z, A<:(OffsetArrays.OffsetArray{T, D, var""#s203""} where {T, D, var""#s203""<:Array}), G}, ::Function) at /home/guptam/.julia/p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1555
https://github.com/CliMA/Oceananigans.jl/issues/1555:585,Availability,ERROR,ERROR,585,"I am using Oceananigans v0.54.0 with Julia v1.6 on GPU. I tried setting an initial condition in salinity as follows:. ```; Stop = 29.5; Sbot = 32; ztop = -35; zbot = -70; dSdz = (Sbot-Stop)/ztop; S_func(x, y, z) = Stop + dSdz*(z > ztop)*z ; set!(model, S=S_func); ```. and got the error copied below. Note that this works fine in Julia v1.5.4. . ```; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/3q18R/deps/deps.jl:15; ERROR: LoadError: MethodError: no method matching set!(::Field{Center, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, CuArray{Float64, 2}}}}}}, ::typeof(S_func)); Closest candidates are:; set!(::Oceananigans.Fields.AbstractField, !Matched::Number) at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:14; set!(::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G, !Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G) where {X, Y, Z, A} at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:16; set!(!Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where {X, Y, Z, A<:(OffsetArrays.OffsetArray{T, D, var""#s203""} where {T, D, var""#s203""<:Array}), G}, ::Function) at /home/guptam/.julia/p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1555
https://github.com/CliMA/Oceananigans.jl/issues/1555:489,Deployability,Configurat,Configuration,489,"I am using Oceananigans v0.54.0 with Julia v1.6 on GPU. I tried setting an initial condition in salinity as follows:. ```; Stop = 29.5; Sbot = 32; ztop = -35; zbot = -70; dSdz = (Sbot-Stop)/ztop; S_func(x, y, z) = Stop + dSdz*(z > ztop)*z ; set!(model, S=S_func); ```. and got the error copied below. Note that this works fine in Julia v1.5.4. . ```; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/3q18R/deps/deps.jl:15; ERROR: LoadError: MethodError: no method matching set!(::Field{Center, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, CuArray{Float64, 2}}}}}}, ::typeof(S_func)); Closest candidates are:; set!(::Oceananigans.Fields.AbstractField, !Matched::Number) at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:14; set!(::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G, !Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G) where {X, Y, Z, A} at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:16; set!(!Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where {X, Y, Z, A<:(OffsetArrays.OffsetArray{T, D, var""#s203""} where {T, D, var""#s203""<:Array}), G}, ::Function) at /home/guptam/.julia/p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1555
https://github.com/CliMA/Oceananigans.jl/issues/1555:489,Modifiability,Config,Configuration,489,"I am using Oceananigans v0.54.0 with Julia v1.6 on GPU. I tried setting an initial condition in salinity as follows:. ```; Stop = 29.5; Sbot = 32; ztop = -35; zbot = -70; dSdz = (Sbot-Stop)/ztop; S_func(x, y, z) = Stop + dSdz*(z > ztop)*z ; set!(model, S=S_func); ```. and got the error copied below. Note that this works fine in Julia v1.5.4. . ```; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/3q18R/deps/deps.jl:15; ERROR: LoadError: MethodError: no method matching set!(::Field{Center, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, CuArray{Float64, 2}}}}}}, ::typeof(S_func)); Closest candidates are:; set!(::Oceananigans.Fields.AbstractField, !Matched::Number) at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:14; set!(::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G, !Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G) where {X, Y, Z, A} at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:16; set!(!Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where {X, Y, Z, A<:(OffsetArrays.OffsetArray{T, D, var""#s203""} where {T, D, var""#s203""<:Array}), G}, ::Function) at /home/guptam/.julia/p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1555
https://github.com/CliMA/Oceananigans.jl/issues/1555:592,Performance,Load,LoadError,592,"I am using Oceananigans v0.54.0 with Julia v1.6 on GPU. I tried setting an initial condition in salinity as follows:. ```; Stop = 29.5; Sbot = 32; ztop = -35; zbot = -70; dSdz = (Sbot-Stop)/ztop; S_func(x, y, z) = Stop + dSdz*(z > ztop)*z ; set!(model, S=S_func); ```. and got the error copied below. Note that this works fine in Julia v1.5.4. . ```; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/3q18R/deps/deps.jl:15; ERROR: LoadError: MethodError: no method matching set!(::Field{Center, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, CuArray{Float64, 2}}}}}}, ::typeof(S_func)); Closest candidates are:; set!(::Oceananigans.Fields.AbstractField, !Matched::Number) at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:14; set!(::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G, !Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G) where {X, Y, Z, A} at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:16; set!(!Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where {X, Y, Z, A<:(OffsetArrays.OffsetArray{T, D, var""#s203""} where {T, D, var""#s203""<:Array}), G}, ::Function) at /home/guptam/.julia/p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1555
https://github.com/CliMA/Oceananigans.jl/pull/1556:86,Testability,test,tested,86,Pair programming with @francispoulin we figured out that the pressure solvers are not tested for `Flat` topologies which might be causing #1554. This PR just adds a warning about this until the pressure solvers properly support `Flat`. Resolves #1554 (?),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1556
https://github.com/CliMA/Oceananigans.jl/pull/1559:118,Testability,test,test,118,I guess you need to use `Inf` instead of `∞` which isn't an actual `Float64` in Julia. We accidently merged a failing test from PR #1557 into the main branch: https://buildkite.com/clima/oceananigans/builds/1935#32b55ec6-724f-4c5d-951f-bf6735923583,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1559
https://github.com/CliMA/Oceananigans.jl/pull/1563:443,Availability,down,downstream,443,"This pull request sets the compat entry for the `Tullio` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Tullio` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1563
https://github.com/CliMA/Oceananigans.jl/pull/1563:381,Deployability,release,release,381,"This pull request sets the compat entry for the `Tullio` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Tullio` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1563
https://github.com/CliMA/Oceananigans.jl/pull/1563:467,Integrability,depend,depend,467,"This pull request sets the compat entry for the `Tullio` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Tullio` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1563
https://github.com/CliMA/Oceananigans.jl/pull/1563:196,Testability,test,tested,196,"This pull request sets the compat entry for the `Tullio` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Tullio` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1563
https://github.com/CliMA/Oceananigans.jl/pull/1563:301,Testability,test,tests,301,"This pull request sets the compat entry for the `Tullio` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Tullio` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1563
https://github.com/CliMA/Oceananigans.jl/pull/1563:486,Testability,test,tests,486,"This pull request sets the compat entry for the `Tullio` package to `0.2`. This is a brand new compat entry. Previously, you did not have a compat entry for the `Tullio` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1563
https://github.com/CliMA/Oceananigans.jl/issues/1564:847,Availability,down,down,847,"In my attempt to study inertial instability I have two versions of the code. 1. Takes the solution to be a sum of the background and the perturbations, and **evolves the total** field. [code here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/NoDecomposition/Bickley_Gaussian_jet_total.jl); 2. Stores the basic state in `BackgroundField` and **evolves the perturbation**, like the Eady problem. [code here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/Bickley_Gaussian_jet.jl). Actually, the first one uses `BackgroundField` for the background stratification, but not for the jet. Since evolving a solution that uses `BackgroundField` has three times as many advection terms, and in this 2D scenario advection is probably the most costly, I was expecting the slow down to be a factor of `3`. What I actually find is a slow down of `16`!?. Is this to be expected?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564
https://github.com/CliMA/Oceananigans.jl/issues/1564:906,Availability,down,down,906,"In my attempt to study inertial instability I have two versions of the code. 1. Takes the solution to be a sum of the background and the perturbations, and **evolves the total** field. [code here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/NoDecomposition/Bickley_Gaussian_jet_total.jl); 2. Stores the basic state in `BackgroundField` and **evolves the perturbation**, like the Eady problem. [code here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/Bickley_Gaussian_jet.jl). Actually, the first one uses `BackgroundField` for the background stratification, but not for the jet. Since evolving a solution that uses `BackgroundField` has three times as many advection terms, and in this 2D scenario advection is probably the most costly, I was expecting the slow down to be a factor of `3`. What I actually find is a slow down of `16`!?. Is this to be expected?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564
https://github.com/CliMA/Oceananigans.jl/issues/1564:158,Modifiability,evolve,evolves,158,"In my attempt to study inertial instability I have two versions of the code. 1. Takes the solution to be a sum of the background and the perturbations, and **evolves the total** field. [code here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/NoDecomposition/Bickley_Gaussian_jet_total.jl); 2. Stores the basic state in `BackgroundField` and **evolves the perturbation**, like the Eady problem. [code here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/Bickley_Gaussian_jet.jl). Actually, the first one uses `BackgroundField` for the background stratification, but not for the jet. Since evolving a solution that uses `BackgroundField` has three times as many advection terms, and in this 2D scenario advection is probably the most costly, I was expecting the slow down to be a factor of `3`. What I actually find is a slow down of `16`!?. Is this to be expected?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564
https://github.com/CliMA/Oceananigans.jl/issues/1564:385,Modifiability,evolve,evolves,385,"In my attempt to study inertial instability I have two versions of the code. 1. Takes the solution to be a sum of the background and the perturbations, and **evolves the total** field. [code here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/NoDecomposition/Bickley_Gaussian_jet_total.jl); 2. Stores the basic state in `BackgroundField` and **evolves the perturbation**, like the Eady problem. [code here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/Bickley_Gaussian_jet.jl). Actually, the first one uses `BackgroundField` for the background stratification, but not for the jet. Since evolving a solution that uses `BackgroundField` has three times as many advection terms, and in this 2D scenario advection is probably the most costly, I was expecting the slow down to be a factor of `3`. What I actually find is a slow down of `16`!?. Is this to be expected?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564
https://github.com/CliMA/Oceananigans.jl/pull/1565:167,Testability,test,tested,167,"This pull request changes the compat entry for the `CUDA` package from `^1, ^2` to `^1, ^2, 3.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1565
https://github.com/CliMA/Oceananigans.jl/pull/1565:272,Testability,test,tests,272,"This pull request changes the compat entry for the `CUDA` package from `^1, ^2` to `^1, ^2, 3.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1565
https://github.com/CliMA/Oceananigans.jl/pull/1566:31,Testability,test,test,31,This is an attempt to resolves test failing after 39ee546.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1566
https://github.com/CliMA/Oceananigans.jl/pull/1567:4,Testability,test,testing,4,I'm testing this.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1567
https://github.com/CliMA/Oceananigans.jl/pull/1568:0,Testability,Test,Tests,0,Tests still fail but docs passed somehow. ; https://clima.github.io/OceananigansDocumentation/previews/PR1568/,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1568
https://github.com/CliMA/Oceananigans.jl/pull/1570:45,Security,validat,validation,45,"Currently a work in progress, but it has one validation experiment (Rossby-Haurwitz) and one ""for fun"" dynamics test (Bickley Jet)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1570
https://github.com/CliMA/Oceananigans.jl/pull/1570:112,Testability,test,test,112,"Currently a work in progress, but it has one validation experiment (Rossby-Haurwitz) and one ""for fun"" dynamics test (Bickley Jet)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1570
https://github.com/CliMA/Oceananigans.jl/issues/1571:1067,Availability,ERROR,ERROR,1067,"Hi all,; I have tried the Vertical stretching function in my code, and I tried Constructing the Vertically stretched grid with Chebyshev spacing in the z direction.-; ```; julia> computational_grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, Lx),; y = (0, Ly),; halo = (3, 3, 3),; zF = k -> cos(π * (2k - 1) / 2Nz)); VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 4.0], y ∈ [0.0, 4.0], z ∈ [0.9996988186962042, -0.9996988186962042]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (256, 256, 64); halo size (Hx, Hy, Hz): (3, 3, 3); grid spacing (Δx, Δy, Δz): (0.015625, 0.015625, [min=-0.04908245704582441, max=0.0]); ```. But when I set up the model, I got an UndefVarError stating this- . ```; julia> model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)); ERROR: UndefVarError: ld not defined; Stacktrace:; [1] Oceananigans.Solvers.FourierTridiagonalPoissonSolver(::CPU, ::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}}, ::UInt32) at /home/552/ss1986/.julia/packages/Oceananigans/SPGnT/src/Solvers/fourier_tridiagonal_poisson_solver.jl:54; [2] FourierTridiagonalPoissonSolver at /home/552/ss1986/.julia/packages/Oceananigans/SPGnT/src/Solvers/fourier_tridiagonal_poisson_solver.jl:24 [inlined]; [3] PressureSolver at /home/552/ss1986/.julia/packages/Oceananigans/SPGnT/src/Solvers/Solvers.jl:45 [inlined]; [4] IncompressibleModel(; grid::VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1571
https://github.com/CliMA/Oceananigans.jl/issues/1571:4043,Deployability,Continuous,ContinuousBoundaryFunction,4043,"oundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value,Float64},BoundaryCondition{Oceananigans.BoundaryConditions.Flux,Int64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Value,Float64},BoundaryCondition{Oceananigans.BoundaryConditions.Flux,Int64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Gradient,Int64},BoundaryCondition{Oceananigans.BoundaryConditions.Flux,Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Nothing,Nothing,Nothing,Nothing,typeof(Q),Nothing,Tuple{},Nothing,Nothing}}}}}}}, tracers::Tuple{Symbol,Symbol}, timestepper::Symbol, background_fields::NamedTuple{(),Tuple{}}, particles::Nothing, velocities::Nothing, pressures::Nothing, diffusivities::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing) at /home/552/ss1986/.julia/packages/Oceananigans/SPGnT/src/Models/IncompressibleModels/incompressible_model.jl:145; [5] top-level scope at REPL[226]:1; ```; And I think that this is because of the Vertical stretching function, but I couldn't get what is Id here? I haven't used Id anywhere.; Am I heading in the right direction?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1571
https://github.com/CliMA/Oceananigans.jl/issues/1574:935,Availability,error,error,935,"Hi! I am trying to implement the following setup with a `VerticallyStretchedRectilinearGrid` and `AnisotropicBiharmonicDiffusivity`:. ```; ## Initializing grid; # Horizontal grid; Nx = 64; Ny = 64; Δy = 250.0; Δx = 250.0; Lx = Δx*Nx; Ly = Δy*Ny; # Vertical grid; Lz = 160; zF = collect(0:2.5:160); zF = -zF[end:-1:1]; ; Nz = length(zF) - 1; # Setup grid; grid = VerticallyStretchedRectilinearGrid(Float64; architecture = GPU(),size = (Nx,Ny,Nz), x=(0, Lx), y=(0, Ly), zF=zF, halo = (3, 3, 3), topology = (Periodic, Bounded, Bounded)). ## Turbulence closure; kappaH = 1e5 # m4/s; kappaV = 5e-5 # m2/s. ## Setting up model; model = IncompressibleModel(; architecture = GPU(),; grid = grid,; closure = (AnisotropicDiffusivity(νh=0, κh=0, κz = kappaV, νz = kappaV),; AnisotropicBiharmonicDiffusivity(νh=kappaH, κh=kappaH)); ). ## Running; simulation = Simulation(model, Δt=2, stop_iteration=1) ; run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: time = 2.0, iteration = 1: NaN found in u. Aborting simulation.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] run_diagnostic!(::NaNChecker{IterationInterval,NamedTuple{(:u,),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}}}, ::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574
https://github.com/CliMA/Oceananigans.jl/issues/1574:948,Availability,ERROR,ERROR,948,"Hi! I am trying to implement the following setup with a `VerticallyStretchedRectilinearGrid` and `AnisotropicBiharmonicDiffusivity`:. ```; ## Initializing grid; # Horizontal grid; Nx = 64; Ny = 64; Δy = 250.0; Δx = 250.0; Lx = Δx*Nx; Ly = Δy*Ny; # Vertical grid; Lz = 160; zF = collect(0:2.5:160); zF = -zF[end:-1:1]; ; Nz = length(zF) - 1; # Setup grid; grid = VerticallyStretchedRectilinearGrid(Float64; architecture = GPU(),size = (Nx,Ny,Nz), x=(0, Lx), y=(0, Ly), zF=zF, halo = (3, 3, 3), topology = (Periodic, Bounded, Bounded)). ## Turbulence closure; kappaH = 1e5 # m4/s; kappaV = 5e-5 # m2/s. ## Setting up model; model = IncompressibleModel(; architecture = GPU(),; grid = grid,; closure = (AnisotropicDiffusivity(νh=0, κh=0, κz = kappaV, νz = kappaV),; AnisotropicBiharmonicDiffusivity(νh=kappaH, κh=kappaH)); ). ## Running; simulation = Simulation(model, Δt=2, stop_iteration=1) ; run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: time = 2.0, iteration = 1: NaN found in u. Aborting simulation.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] run_diagnostic!(::NaNChecker{IterationInterval,NamedTuple{(:u,),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}}}, ::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574
https://github.com/CliMA/Oceananigans.jl/issues/1574:1048,Availability,error,error,1048," with a `VerticallyStretchedRectilinearGrid` and `AnisotropicBiharmonicDiffusivity`:. ```; ## Initializing grid; # Horizontal grid; Nx = 64; Ny = 64; Δy = 250.0; Δx = 250.0; Lx = Δx*Nx; Ly = Δy*Ny; # Vertical grid; Lz = 160; zF = collect(0:2.5:160); zF = -zF[end:-1:1]; ; Nz = length(zF) - 1; # Setup grid; grid = VerticallyStretchedRectilinearGrid(Float64; architecture = GPU(),size = (Nx,Ny,Nz), x=(0, Lx), y=(0, Ly), zF=zF, halo = (3, 3, 3), topology = (Periodic, Bounded, Bounded)). ## Turbulence closure; kappaH = 1e5 # m4/s; kappaV = 5e-5 # m2/s. ## Setting up model; model = IncompressibleModel(; architecture = GPU(),; grid = grid,; closure = (AnisotropicDiffusivity(νh=0, κh=0, κz = kappaV, νz = kappaV),; AnisotropicBiharmonicDiffusivity(νh=kappaH, κh=kappaH)); ). ## Running; simulation = Simulation(model, Δt=2, stop_iteration=1) ; run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: time = 2.0, iteration = 1: NaN found in u. Aborting simulation.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] run_diagnostic!(::NaNChecker{IterationInterval,NamedTuple{(:u,),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}}}, ::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574
https://github.com/CliMA/Oceananigans.jl/issues/1574:1069,Availability,error,error,1069,"tchedRectilinearGrid` and `AnisotropicBiharmonicDiffusivity`:. ```; ## Initializing grid; # Horizontal grid; Nx = 64; Ny = 64; Δy = 250.0; Δx = 250.0; Lx = Δx*Nx; Ly = Δy*Ny; # Vertical grid; Lz = 160; zF = collect(0:2.5:160); zF = -zF[end:-1:1]; ; Nz = length(zF) - 1; # Setup grid; grid = VerticallyStretchedRectilinearGrid(Float64; architecture = GPU(),size = (Nx,Ny,Nz), x=(0, Lx), y=(0, Ly), zF=zF, halo = (3, 3, 3), topology = (Periodic, Bounded, Bounded)). ## Turbulence closure; kappaH = 1e5 # m4/s; kappaV = 5e-5 # m2/s. ## Setting up model; model = IncompressibleModel(; architecture = GPU(),; grid = grid,; closure = (AnisotropicDiffusivity(νh=0, κh=0, κz = kappaV, νz = kappaV),; AnisotropicBiharmonicDiffusivity(νh=kappaH, κh=kappaH)); ). ## Running; simulation = Simulation(model, Δt=2, stop_iteration=1) ; run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: time = 2.0, iteration = 1: NaN found in u. Aborting simulation.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] run_diagnostic!(::NaNChecker{IterationInterval,NamedTuple{(:u,),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}}}, ::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},Vertical",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574
https://github.com/CliMA/Oceananigans.jl/issues/1574:93778,Availability,error,error,93778,",Int64,Periodic,Int64,Nothing,Nothing},Oceananigans.Solvers.DiscreteTransform{AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},Oceananigans.Solvers.Backward,GPU,VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}},Int64,Bounded,Int64,NamedTuple{(:forward, :backward),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}},Tuple{Int64,Int64,Int64}}}}}},Tuple{Nothing,Nothing},NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}},Nothing,Nothing},Int64,Array{Any,1},Int64,Float64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(Oceananigans.Simulations.default_progress),Int64,Nothing}) at /home/guptam/.julia/packages/Oceananigans/wJDxT/src/Simulations/run.jl:127; [8] top-level scope at /central/home/guptam/ocean_floes/test_stratif/test_stretched.jl:80; [9] include(::Function, ::Module, ::String) at ./Base.jl:380; [10] include(::Module, ::String) at ./Base.jl:368; [11] exec_options(::Base.JLOptions) at ./client.jl:296; [12] _start() at ./client.jl:506; in expression starting at /central/home/guptam/ocean_floes/test_stratif/test_stretched.jl:76; ```. I believe this is caused by the `AnisotropicBiharmonicDiffusivity` component of the turbulence closure, since using a simple `AnisotropicDiffusivity` works fine. Also note that the above setup works on a `RegularRectilinearGrid`. Any ideas? . I am working on the `ali/unclog-docs` branch to avoid the error reported here #1571, using Julia v1.5.4 and Oceananigans v0.54.0 + GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574
https://github.com/CliMA/Oceananigans.jl/issues/1574:955,Performance,Load,LoadError,955,"Hi! I am trying to implement the following setup with a `VerticallyStretchedRectilinearGrid` and `AnisotropicBiharmonicDiffusivity`:. ```; ## Initializing grid; # Horizontal grid; Nx = 64; Ny = 64; Δy = 250.0; Δx = 250.0; Lx = Δx*Nx; Ly = Δy*Ny; # Vertical grid; Lz = 160; zF = collect(0:2.5:160); zF = -zF[end:-1:1]; ; Nz = length(zF) - 1; # Setup grid; grid = VerticallyStretchedRectilinearGrid(Float64; architecture = GPU(),size = (Nx,Ny,Nz), x=(0, Lx), y=(0, Ly), zF=zF, halo = (3, 3, 3), topology = (Periodic, Bounded, Bounded)). ## Turbulence closure; kappaH = 1e5 # m4/s; kappaV = 5e-5 # m2/s. ## Setting up model; model = IncompressibleModel(; architecture = GPU(),; grid = grid,; closure = (AnisotropicDiffusivity(νh=0, κh=0, κz = kappaV, νz = kappaV),; AnisotropicBiharmonicDiffusivity(νh=kappaH, κh=kappaH)); ). ## Running; simulation = Simulation(model, Δt=2, stop_iteration=1) ; run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: time = 2.0, iteration = 1: NaN found in u. Aborting simulation.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] run_diagnostic!(::NaNChecker{IterationInterval,NamedTuple{(:u,),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}}}, ::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574
https://github.com/CliMA/Oceananigans.jl/issues/1574:1009,Safety,Abort,Aborting,1009," implement the following setup with a `VerticallyStretchedRectilinearGrid` and `AnisotropicBiharmonicDiffusivity`:. ```; ## Initializing grid; # Horizontal grid; Nx = 64; Ny = 64; Δy = 250.0; Δx = 250.0; Lx = Δx*Nx; Ly = Δy*Ny; # Vertical grid; Lz = 160; zF = collect(0:2.5:160); zF = -zF[end:-1:1]; ; Nz = length(zF) - 1; # Setup grid; grid = VerticallyStretchedRectilinearGrid(Float64; architecture = GPU(),size = (Nx,Ny,Nz), x=(0, Lx), y=(0, Ly), zF=zF, halo = (3, 3, 3), topology = (Periodic, Bounded, Bounded)). ## Turbulence closure; kappaH = 1e5 # m4/s; kappaV = 5e-5 # m2/s. ## Setting up model; model = IncompressibleModel(; architecture = GPU(),; grid = grid,; closure = (AnisotropicDiffusivity(νh=0, κh=0, κz = kappaV, νz = kappaV),; AnisotropicBiharmonicDiffusivity(νh=kappaH, κh=kappaH)); ). ## Running; simulation = Simulation(model, Δt=2, stop_iteration=1) ; run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: time = 2.0, iteration = 1: NaN found in u. Aborting simulation.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] run_diagnostic!(::NaNChecker{IterationInterval,NamedTuple{(:u,),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}}}, ::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center,Center,OffsetArra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574
https://github.com/CliMA/Oceananigans.jl/issues/1574:93768,Safety,avoid,avoid,93768,",Int64,Periodic,Int64,Nothing,Nothing},Oceananigans.Solvers.DiscreteTransform{AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},Oceananigans.Solvers.Backward,GPU,VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}},Int64,Bounded,Int64,NamedTuple{(:forward, :backward),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}},Tuple{Int64,Int64,Int64}}}}}},Tuple{Nothing,Nothing},NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}},Nothing,Nothing},Int64,Array{Any,1},Int64,Float64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(Oceananigans.Simulations.default_progress),Int64,Nothing}) at /home/guptam/.julia/packages/Oceananigans/wJDxT/src/Simulations/run.jl:127; [8] top-level scope at /central/home/guptam/ocean_floes/test_stratif/test_stretched.jl:80; [9] include(::Function, ::Module, ::String) at ./Base.jl:380; [10] include(::Module, ::String) at ./Base.jl:368; [11] exec_options(::Base.JLOptions) at ./client.jl:296; [12] _start() at ./client.jl:506; in expression starting at /central/home/guptam/ocean_floes/test_stratif/test_stretched.jl:76; ```. I believe this is caused by the `AnisotropicBiharmonicDiffusivity` component of the turbulence closure, since using a simple `AnisotropicDiffusivity` works fine. Also note that the above setup works on a `RegularRectilinearGrid`. Any ideas? . I am working on the `ali/unclog-docs` branch to avoid the error reported here #1571, using Julia v1.5.4 and Oceananigans v0.54.0 + GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574
https://github.com/CliMA/Oceananigans.jl/issues/1574:93595,Usability,simpl,simple,93595,",Int64,Periodic,Int64,Nothing,Nothing},Oceananigans.Solvers.DiscreteTransform{AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},Oceananigans.Solvers.Backward,GPU,VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}},Int64,Bounded,Int64,NamedTuple{(:forward, :backward),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}},Tuple{Int64,Int64,Int64}}}}}},Tuple{Nothing,Nothing},NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}},Nothing,Nothing},Int64,Array{Any,1},Int64,Float64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(Oceananigans.Simulations.default_progress),Int64,Nothing}) at /home/guptam/.julia/packages/Oceananigans/wJDxT/src/Simulations/run.jl:127; [8] top-level scope at /central/home/guptam/ocean_floes/test_stratif/test_stretched.jl:80; [9] include(::Function, ::Module, ::String) at ./Base.jl:380; [10] include(::Module, ::String) at ./Base.jl:368; [11] exec_options(::Base.JLOptions) at ./client.jl:296; [12] _start() at ./client.jl:506; in expression starting at /central/home/guptam/ocean_floes/test_stratif/test_stretched.jl:76; ```. I believe this is caused by the `AnisotropicBiharmonicDiffusivity` component of the turbulence closure, since using a simple `AnisotropicDiffusivity` works fine. Also note that the above setup works on a `RegularRectilinearGrid`. Any ideas? . I am working on the `ali/unclog-docs` branch to avoid the error reported here #1571, using Julia v1.5.4 and Oceananigans v0.54.0 + GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574
https://github.com/CliMA/Oceananigans.jl/pull/1575:300,Availability,toler,tolerance,300,"This PR refactors the `PreconditionedConjugateGradientSolver` and `ImplicitFreeSurface` and their tests. It adds one new test that ensures a single time-step of the `HydrostaticFreeSurfaceModel` can be made with `free_surface = ImplicitFreeSurface()`. In the new interface the maximum iterations and tolerance of the conjugate gradient solver used for the implicit free surface step are adjusted via kwargs to `ImplicitFreeSurface`. For example:. ```julia; free_surface = ImplicitFreeSurface(tolerance = 1e-7, maximum_iterations = Nx * Ny); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1575
https://github.com/CliMA/Oceananigans.jl/pull/1575:492,Availability,toler,tolerance,492,"This PR refactors the `PreconditionedConjugateGradientSolver` and `ImplicitFreeSurface` and their tests. It adds one new test that ensures a single time-step of the `HydrostaticFreeSurfaceModel` can be made with `free_surface = ImplicitFreeSurface()`. In the new interface the maximum iterations and tolerance of the conjugate gradient solver used for the implicit free surface step are adjusted via kwargs to `ImplicitFreeSurface`. For example:. ```julia; free_surface = ImplicitFreeSurface(tolerance = 1e-7, maximum_iterations = Nx * Ny); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1575
https://github.com/CliMA/Oceananigans.jl/pull/1575:263,Integrability,interface,interface,263,"This PR refactors the `PreconditionedConjugateGradientSolver` and `ImplicitFreeSurface` and their tests. It adds one new test that ensures a single time-step of the `HydrostaticFreeSurfaceModel` can be made with `free_surface = ImplicitFreeSurface()`. In the new interface the maximum iterations and tolerance of the conjugate gradient solver used for the implicit free surface step are adjusted via kwargs to `ImplicitFreeSurface`. For example:. ```julia; free_surface = ImplicitFreeSurface(tolerance = 1e-7, maximum_iterations = Nx * Ny); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1575
https://github.com/CliMA/Oceananigans.jl/pull/1575:8,Modifiability,refactor,refactors,8,"This PR refactors the `PreconditionedConjugateGradientSolver` and `ImplicitFreeSurface` and their tests. It adds one new test that ensures a single time-step of the `HydrostaticFreeSurfaceModel` can be made with `free_surface = ImplicitFreeSurface()`. In the new interface the maximum iterations and tolerance of the conjugate gradient solver used for the implicit free surface step are adjusted via kwargs to `ImplicitFreeSurface`. For example:. ```julia; free_surface = ImplicitFreeSurface(tolerance = 1e-7, maximum_iterations = Nx * Ny); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1575
https://github.com/CliMA/Oceananigans.jl/pull/1575:98,Testability,test,tests,98,"This PR refactors the `PreconditionedConjugateGradientSolver` and `ImplicitFreeSurface` and their tests. It adds one new test that ensures a single time-step of the `HydrostaticFreeSurfaceModel` can be made with `free_surface = ImplicitFreeSurface()`. In the new interface the maximum iterations and tolerance of the conjugate gradient solver used for the implicit free surface step are adjusted via kwargs to `ImplicitFreeSurface`. For example:. ```julia; free_surface = ImplicitFreeSurface(tolerance = 1e-7, maximum_iterations = Nx * Ny); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1575
https://github.com/CliMA/Oceananigans.jl/pull/1575:121,Testability,test,test,121,"This PR refactors the `PreconditionedConjugateGradientSolver` and `ImplicitFreeSurface` and their tests. It adds one new test that ensures a single time-step of the `HydrostaticFreeSurfaceModel` can be made with `free_surface = ImplicitFreeSurface()`. In the new interface the maximum iterations and tolerance of the conjugate gradient solver used for the implicit free surface step are adjusted via kwargs to `ImplicitFreeSurface`. For example:. ```julia; free_surface = ImplicitFreeSurface(tolerance = 1e-7, maximum_iterations = Nx * Ny); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1575
https://github.com/CliMA/Oceananigans.jl/pull/1576:26,Deployability,release,release,26,We need this to tag a new release.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1576
https://github.com/CliMA/Oceananigans.jl/issues/1584:242,Availability,down,down,242,"https://github.com/CliMA/Oceananigans.jl/blob/28dadbcc52a2badd242e89ba30c8cc34f9117327/src/Operators/vorticity_operators.jl#L1-L2. At the cubed sphere corners the grid is not actually orthogonal and so the vector-invariant formulation breaks down unless we compute the circulation carefully for each corner. ![image](https://user-images.githubusercontent.com/20099589/114737069-a8183e80-9d14-11eb-9a9c-07b5243af3c2.png). I've attached the appropriate reference (Adcroft et al., 2004):. [Adcroft et al, 2004, Monthly Weather Review, Implementation of an Atmosphere–Ocean General Circulation Model on the Expanded Spherical Cube.pdf](https://github.com/CliMA/Oceananigans.jl/files/6311899/Adcroft.et.al.2004.Monthly.Weather.Review.Implementation.of.an.Atmosphere.Ocean.General.Circulation.Model.on.the.Expanded.Spherical.Cube.pdf). Here is the MITgcm implementation: https://github.com/MITgcm/MITgcm/blob/master/pkg/mom_common/mom_calc_relvort3.F. Once this is fixed, the Rossby-Haurwitz test case in PR #1570 with momentum advection should stop blowing up at the corners.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1584
https://github.com/CliMA/Oceananigans.jl/issues/1584:986,Testability,test,test,986,"https://github.com/CliMA/Oceananigans.jl/blob/28dadbcc52a2badd242e89ba30c8cc34f9117327/src/Operators/vorticity_operators.jl#L1-L2. At the cubed sphere corners the grid is not actually orthogonal and so the vector-invariant formulation breaks down unless we compute the circulation carefully for each corner. ![image](https://user-images.githubusercontent.com/20099589/114737069-a8183e80-9d14-11eb-9a9c-07b5243af3c2.png). I've attached the appropriate reference (Adcroft et al., 2004):. [Adcroft et al, 2004, Monthly Weather Review, Implementation of an Atmosphere–Ocean General Circulation Model on the Expanded Spherical Cube.pdf](https://github.com/CliMA/Oceananigans.jl/files/6311899/Adcroft.et.al.2004.Monthly.Weather.Review.Implementation.of.an.Atmosphere.Ocean.General.Circulation.Model.on.the.Expanded.Spherical.Cube.pdf). Here is the MITgcm implementation: https://github.com/MITgcm/MITgcm/blob/master/pkg/mom_common/mom_calc_relvort3.F. Once this is fixed, the Rossby-Haurwitz test case in PR #1570 with momentum advection should stop blowing up at the corners.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1584
https://github.com/CliMA/Oceananigans.jl/issues/1586:264,Integrability,depend,dependency,264,"Right now we load cubed sphere grids from a file which is a Julia/JLD2.jl version of the binary files used by MITgcm. These grid files are currently stored at https://github.com/CliMA/OceananigansArtifacts.jl. The easiest way to use them is to load them as a data dependency with DataDeps.jl: https://github.com/CliMA/Oceananigans.jl/blob/master/test/data_dependencies.jl. This works well for the CS32 and CS96 grids, but for much larger grids like the CS510 the grid file is ~200 MiB uncompressed (~118 MiB compressed with JLD2's `compress=true`) which is bigger than GitHub's 100 MiB file size limit. 200 MiB for a grid file is also a bit cumbersome. Right now I'm thinking of hosting CS510 on the engaging cluster, although git lfs for OceananigansArtifacts.jl may be an option. It would be nice to be able to generate conformal cubed sphere grid files to make it easier for users to use cubed sphere grids, and also for the added flexibility of not being limited to three common resolutions (CS32, CS96, and CS510). It would also be good to keep the ability to load a cubed sphere grid from file since we may want to do this for other grids besides the cubed sphere in the future (lat-lon-cap or LLC grids?), and it would be useful to test that the grids we generate are indeed correct by comparing with the grid files. I'm opening this issue just to document what we know about conformal cubed sphere grid generation. It's not a particularly urgent issue. # Computing grid metrics. We already have some code that generates conformal cubed sphere grids with the coordinates, but they are missing the grid metrics (grid spacings and areas). @christophernhill has pointed out these MITgcm MATLAB scripts that may just be what we need to compute the grid metrics. http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/README?revision=1.1.1.1&view=markup; http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/calc_fvgrid.m?revis",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1586
https://github.com/CliMA/Oceananigans.jl/issues/1586:13,Performance,load,load,13,"Right now we load cubed sphere grids from a file which is a Julia/JLD2.jl version of the binary files used by MITgcm. These grid files are currently stored at https://github.com/CliMA/OceananigansArtifacts.jl. The easiest way to use them is to load them as a data dependency with DataDeps.jl: https://github.com/CliMA/Oceananigans.jl/blob/master/test/data_dependencies.jl. This works well for the CS32 and CS96 grids, but for much larger grids like the CS510 the grid file is ~200 MiB uncompressed (~118 MiB compressed with JLD2's `compress=true`) which is bigger than GitHub's 100 MiB file size limit. 200 MiB for a grid file is also a bit cumbersome. Right now I'm thinking of hosting CS510 on the engaging cluster, although git lfs for OceananigansArtifacts.jl may be an option. It would be nice to be able to generate conformal cubed sphere grid files to make it easier for users to use cubed sphere grids, and also for the added flexibility of not being limited to three common resolutions (CS32, CS96, and CS510). It would also be good to keep the ability to load a cubed sphere grid from file since we may want to do this for other grids besides the cubed sphere in the future (lat-lon-cap or LLC grids?), and it would be useful to test that the grids we generate are indeed correct by comparing with the grid files. I'm opening this issue just to document what we know about conformal cubed sphere grid generation. It's not a particularly urgent issue. # Computing grid metrics. We already have some code that generates conformal cubed sphere grids with the coordinates, but they are missing the grid metrics (grid spacings and areas). @christophernhill has pointed out these MITgcm MATLAB scripts that may just be what we need to compute the grid metrics. http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/README?revision=1.1.1.1&view=markup; http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/calc_fvgrid.m?revis",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1586
https://github.com/CliMA/Oceananigans.jl/issues/1586:244,Performance,load,load,244,"Right now we load cubed sphere grids from a file which is a Julia/JLD2.jl version of the binary files used by MITgcm. These grid files are currently stored at https://github.com/CliMA/OceananigansArtifacts.jl. The easiest way to use them is to load them as a data dependency with DataDeps.jl: https://github.com/CliMA/Oceananigans.jl/blob/master/test/data_dependencies.jl. This works well for the CS32 and CS96 grids, but for much larger grids like the CS510 the grid file is ~200 MiB uncompressed (~118 MiB compressed with JLD2's `compress=true`) which is bigger than GitHub's 100 MiB file size limit. 200 MiB for a grid file is also a bit cumbersome. Right now I'm thinking of hosting CS510 on the engaging cluster, although git lfs for OceananigansArtifacts.jl may be an option. It would be nice to be able to generate conformal cubed sphere grid files to make it easier for users to use cubed sphere grids, and also for the added flexibility of not being limited to three common resolutions (CS32, CS96, and CS510). It would also be good to keep the ability to load a cubed sphere grid from file since we may want to do this for other grids besides the cubed sphere in the future (lat-lon-cap or LLC grids?), and it would be useful to test that the grids we generate are indeed correct by comparing with the grid files. I'm opening this issue just to document what we know about conformal cubed sphere grid generation. It's not a particularly urgent issue. # Computing grid metrics. We already have some code that generates conformal cubed sphere grids with the coordinates, but they are missing the grid metrics (grid spacings and areas). @christophernhill has pointed out these MITgcm MATLAB scripts that may just be what we need to compute the grid metrics. http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/README?revision=1.1.1.1&view=markup; http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/calc_fvgrid.m?revis",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1586
https://github.com/CliMA/Oceananigans.jl/issues/1586:1065,Performance,load,load,1065,"ub.com/CliMA/OceananigansArtifacts.jl. The easiest way to use them is to load them as a data dependency with DataDeps.jl: https://github.com/CliMA/Oceananigans.jl/blob/master/test/data_dependencies.jl. This works well for the CS32 and CS96 grids, but for much larger grids like the CS510 the grid file is ~200 MiB uncompressed (~118 MiB compressed with JLD2's `compress=true`) which is bigger than GitHub's 100 MiB file size limit. 200 MiB for a grid file is also a bit cumbersome. Right now I'm thinking of hosting CS510 on the engaging cluster, although git lfs for OceananigansArtifacts.jl may be an option. It would be nice to be able to generate conformal cubed sphere grid files to make it easier for users to use cubed sphere grids, and also for the added flexibility of not being limited to three common resolutions (CS32, CS96, and CS510). It would also be good to keep the ability to load a cubed sphere grid from file since we may want to do this for other grids besides the cubed sphere in the future (lat-lon-cap or LLC grids?), and it would be useful to test that the grids we generate are indeed correct by comparing with the grid files. I'm opening this issue just to document what we know about conformal cubed sphere grid generation. It's not a particularly urgent issue. # Computing grid metrics. We already have some code that generates conformal cubed sphere grids with the coordinates, but they are missing the grid metrics (grid spacings and areas). @christophernhill has pointed out these MITgcm MATLAB scripts that may just be what we need to compute the grid metrics. http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/README?revision=1.1.1.1&view=markup; http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/calc_fvgrid.m?revision=1.1.1.1&view=markup; http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/gengrid_fn.m?revision=1.1.1.1&view=markup. He also ment",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1586
https://github.com/CliMA/Oceananigans.jl/issues/1586:346,Testability,test,test,346,"Right now we load cubed sphere grids from a file which is a Julia/JLD2.jl version of the binary files used by MITgcm. These grid files are currently stored at https://github.com/CliMA/OceananigansArtifacts.jl. The easiest way to use them is to load them as a data dependency with DataDeps.jl: https://github.com/CliMA/Oceananigans.jl/blob/master/test/data_dependencies.jl. This works well for the CS32 and CS96 grids, but for much larger grids like the CS510 the grid file is ~200 MiB uncompressed (~118 MiB compressed with JLD2's `compress=true`) which is bigger than GitHub's 100 MiB file size limit. 200 MiB for a grid file is also a bit cumbersome. Right now I'm thinking of hosting CS510 on the engaging cluster, although git lfs for OceananigansArtifacts.jl may be an option. It would be nice to be able to generate conformal cubed sphere grid files to make it easier for users to use cubed sphere grids, and also for the added flexibility of not being limited to three common resolutions (CS32, CS96, and CS510). It would also be good to keep the ability to load a cubed sphere grid from file since we may want to do this for other grids besides the cubed sphere in the future (lat-lon-cap or LLC grids?), and it would be useful to test that the grids we generate are indeed correct by comparing with the grid files. I'm opening this issue just to document what we know about conformal cubed sphere grid generation. It's not a particularly urgent issue. # Computing grid metrics. We already have some code that generates conformal cubed sphere grids with the coordinates, but they are missing the grid metrics (grid spacings and areas). @christophernhill has pointed out these MITgcm MATLAB scripts that may just be what we need to compute the grid metrics. http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/README?revision=1.1.1.1&view=markup; http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/calc_fvgrid.m?revis",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1586
https://github.com/CliMA/Oceananigans.jl/issues/1586:1239,Testability,test,test,1239,"ub.com/CliMA/OceananigansArtifacts.jl. The easiest way to use them is to load them as a data dependency with DataDeps.jl: https://github.com/CliMA/Oceananigans.jl/blob/master/test/data_dependencies.jl. This works well for the CS32 and CS96 grids, but for much larger grids like the CS510 the grid file is ~200 MiB uncompressed (~118 MiB compressed with JLD2's `compress=true`) which is bigger than GitHub's 100 MiB file size limit. 200 MiB for a grid file is also a bit cumbersome. Right now I'm thinking of hosting CS510 on the engaging cluster, although git lfs for OceananigansArtifacts.jl may be an option. It would be nice to be able to generate conformal cubed sphere grid files to make it easier for users to use cubed sphere grids, and also for the added flexibility of not being limited to three common resolutions (CS32, CS96, and CS510). It would also be good to keep the ability to load a cubed sphere grid from file since we may want to do this for other grids besides the cubed sphere in the future (lat-lon-cap or LLC grids?), and it would be useful to test that the grids we generate are indeed correct by comparing with the grid files. I'm opening this issue just to document what we know about conformal cubed sphere grid generation. It's not a particularly urgent issue. # Computing grid metrics. We already have some code that generates conformal cubed sphere grids with the coordinates, but they are missing the grid metrics (grid spacings and areas). @christophernhill has pointed out these MITgcm MATLAB scripts that may just be what we need to compute the grid metrics. http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/README?revision=1.1.1.1&view=markup; http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/calc_fvgrid.m?revision=1.1.1.1&view=markup; http://wwwcvs.mitgcm.org/viewvc/MITgcm/MITgcm_contrib/high_res_cube/matlab-grid-generator/gengrid_fn.m?revision=1.1.1.1&view=markup. He also ment",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1586
https://github.com/CliMA/Oceananigans.jl/pull/1589:189,Availability,error,errors,189,"The `@hascuda` macro used to be necessary but with the addition of `CUDA.has_cuda()` I don't think it is anymore. So this PR finally gets rid of the `@hascuda` macro. It's been a source of errors for users, especially when using Oceananigans on clusters where some nodes have GPUs and others do not. So hopefully this PR will help reduce errors for users on clusters.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1589
https://github.com/CliMA/Oceananigans.jl/pull/1589:338,Availability,error,errors,338,"The `@hascuda` macro used to be necessary but with the addition of `CUDA.has_cuda()` I don't think it is anymore. So this PR finally gets rid of the `@hascuda` macro. It's been a source of errors for users, especially when using Oceananigans on clusters where some nodes have GPUs and others do not. So hopefully this PR will help reduce errors for users on clusters.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1589
https://github.com/CliMA/Oceananigans.jl/pull/1589:331,Energy Efficiency,reduce,reduce,331,"The `@hascuda` macro used to be necessary but with the addition of `CUDA.has_cuda()` I don't think it is anymore. So this PR finally gets rid of the `@hascuda` macro. It's been a source of errors for users, especially when using Oceananigans on clusters where some nodes have GPUs and others do not. So hopefully this PR will help reduce errors for users on clusters.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1589
https://github.com/CliMA/Oceananigans.jl/pull/1596:1884,Availability,robust,robust,1884,"``. Broadcasting also works with `AbstractOperations`:. ```julia; julia> d = Field(Face, Center, Center, CPU(), grid); Field located at (Face, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (4, 4, 3); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux). julia> dx_c = ∂x(c); Derivative at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ∂xᶠᶜᵃ at (Face, Center, Center) via identity;    └── Field located at (Center, Center, Center). julia> d .= 2 .* dx_c. julia> interior(d); 2×2×1 view(OffsetArray(::Array{Float64,3}, 0:3, 0:3, 0:2), 1:2, 1:2, 1:1) with eltype Float64:; [:, :, 1] =; 4.36713 3.46522; -1.988 4.13932; ```. Under the hood we launch kernels, so broadcasting is multithreaded and works on the GPU as well as the CPU. This is just the beginning I think. This PR only implements in-place broadcasting, but out-of-place (allocating) broadcasting would be useful for analysis of data via `AbstractField`. For this I think we need to define `Base.copy` in addition to `copyto!` (but this is simple since we already have `similar`...) ~~We also need to write a lot more code to make broadcasting robust: for example, we should check that broadcasted objects have the same location. We might also be able to implement interpolation correctly. This PR shows that all of this is possible.~~. This PR implements interpolated broadcasting by transforming `Base.Broadcast.Broadcasted` to `AbstractOperation`. Note: it also defines some new helper functions for `BinaryOperation` that should help with type inference and GPU compilation. This was necessary to get some of the broadcasting tests work (since broadcasting also uses `AbstractOperation`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1596
https://github.com/CliMA/Oceananigans.jl/pull/1596:2370,Testability,test,tests,2370,"``. Broadcasting also works with `AbstractOperations`:. ```julia; julia> d = Field(Face, Center, Center, CPU(), grid); Field located at (Face, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (4, 4, 3); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux). julia> dx_c = ∂x(c); Derivative at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ∂xᶠᶜᵃ at (Face, Center, Center) via identity;    └── Field located at (Center, Center, Center). julia> d .= 2 .* dx_c. julia> interior(d); 2×2×1 view(OffsetArray(::Array{Float64,3}, 0:3, 0:3, 0:2), 1:2, 1:2, 1:1) with eltype Float64:; [:, :, 1] =; 4.36713 3.46522; -1.988 4.13932; ```. Under the hood we launch kernels, so broadcasting is multithreaded and works on the GPU as well as the CPU. This is just the beginning I think. This PR only implements in-place broadcasting, but out-of-place (allocating) broadcasting would be useful for analysis of data via `AbstractField`. For this I think we need to define `Base.copy` in addition to `copyto!` (but this is simple since we already have `similar`...) ~~We also need to write a lot more code to make broadcasting robust: for example, we should check that broadcasted objects have the same location. We might also be able to implement interpolation correctly. This PR shows that all of this is possible.~~. This PR implements interpolated broadcasting by transforming `Base.Broadcast.Broadcasted` to `AbstractOperation`. Note: it also defines some new helper functions for `BinaryOperation` that should help with type inference and GPU compilation. This was necessary to get some of the broadcasting tests work (since broadcasting also uses `AbstractOperation`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1596
https://github.com/CliMA/Oceananigans.jl/pull/1596:1780,Usability,simpl,simple,1780,"``. Broadcasting also works with `AbstractOperations`:. ```julia; julia> d = Field(Face, Center, Center, CPU(), grid); Field located at (Face, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (4, 4, 3); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux). julia> dx_c = ∂x(c); Derivative at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ∂xᶠᶜᵃ at (Face, Center, Center) via identity;    └── Field located at (Center, Center, Center). julia> d .= 2 .* dx_c. julia> interior(d); 2×2×1 view(OffsetArray(::Array{Float64,3}, 0:3, 0:3, 0:2), 1:2, 1:2, 1:1) with eltype Float64:; [:, :, 1] =; 4.36713 3.46522; -1.988 4.13932; ```. Under the hood we launch kernels, so broadcasting is multithreaded and works on the GPU as well as the CPU. This is just the beginning I think. This PR only implements in-place broadcasting, but out-of-place (allocating) broadcasting would be useful for analysis of data via `AbstractField`. For this I think we need to define `Base.copy` in addition to `copyto!` (but this is simple since we already have `similar`...) ~~We also need to write a lot more code to make broadcasting robust: for example, we should check that broadcasted objects have the same location. We might also be able to implement interpolation correctly. This PR shows that all of this is possible.~~. This PR implements interpolated broadcasting by transforming `Base.Broadcast.Broadcasted` to `AbstractOperation`. Note: it also defines some new helper functions for `BinaryOperation` that should help with type inference and GPU compilation. This was necessary to get some of the broadcasting tests work (since broadcasting also uses `AbstractOperation`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1596
https://github.com/CliMA/Oceananigans.jl/pull/1599:5480,Availability,error,error,5480,"nded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ^ at (Face, Center, Center);    ├── - at (Face, Center, Center);    │   ├── Field located at (Face, Center, Center);    │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    └── 2; ```. An added benefit is that the `BinaryOperation` object is simpler. This could help compilation as well... Of course, users do want to be able to specify the location of `BinaryOperations` for output. For this we change how `@at` works: now we wrap the entire user-prescribed expression in an interpolation operator that interpolates the result to the user-specified location. If the location of the underlying expression is already at the user-specified location, this is just an identity. But when the underlying operation is a ""stubborn"" `BinaryOperator`, we interpolate:. ```julia; julia> uu = @at (Center, Center, Center) u * u; UnaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; identity at (Center, Center, Center) via ℑxᶜᵃᵃ;    └── * at (Face, Center, Center);       ├── Field located at (Face, Center, Center);       └── Field located at (Face, Center, Center). julia> uu.arg; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Field located at (Face, Center, Center); ```. This also means that operations between `ReducedField` and `Field` also end up at the right place, and we have no need to throw an error if a `BinaryOperation` has a `Nothing` location (in fact, this might be a useful abstraction for binary operations between `ReducedField`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599
https://github.com/CliMA/Oceananigans.jl/pull/1599:1442,Energy Efficiency,energy,energy,1442," operations to be built at user-specified locations. In other words, users might want something like. ```julia; using Oceananigans; grid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); model = IncompressibleModel(architecture=CPU(), grid=grid); u, v, w = model.velocities. uu = @at (Center, Center, Center) u * u. # output; BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Center, Center, Center) via ℑxᶜᵃᵃ;    ├── Field located at (Face, Center, Center);    └── Field located at (Face, Center, Center); ```. which would compute `u * u` at `(Face, Center, Center)`, and subsequently interpolate to cell centers. The object `uu` would then be defined at cell centers. The main issue of this design in terms of functionality is that it produces expression trees that interpolate ""too eagerly"". A common example is a turbulent kinetic energy computation:. ```julia; U = AveragedField(u, dims=(1, 2)); V = AveragedField(v, dims=(1, 2)). tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2); ```. Inspection of this object reveals that while `u - U` does not interpolate, the squaring `(u - U)^2` would be performed at cell centers:. ```julia; julia> tke.args[1].b; 2. julia> tke.args[1].a; BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; - at (Center, Center, Center) via identity;    ├── Field located at (Face, Center, Center);    └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center); ```. This isn't what we want (usually): instead, we want both `u - U` and subsequent squaring in `(u - U)^2` to be performed at `(Face, Center, Center)`. This PR addresses this issue by getting rid of the third int",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599
https://github.com/CliMA/Oceananigans.jl/pull/1599:5390,Energy Efficiency,Reduce,ReducedField,5390,"nded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ^ at (Face, Center, Center);    ├── - at (Face, Center, Center);    │   ├── Field located at (Face, Center, Center);    │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    └── 2; ```. An added benefit is that the `BinaryOperation` object is simpler. This could help compilation as well... Of course, users do want to be able to specify the location of `BinaryOperations` for output. For this we change how `@at` works: now we wrap the entire user-prescribed expression in an interpolation operator that interpolates the result to the user-specified location. If the location of the underlying expression is already at the user-specified location, this is just an identity. But when the underlying operation is a ""stubborn"" `BinaryOperator`, we interpolate:. ```julia; julia> uu = @at (Center, Center, Center) u * u; UnaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; identity at (Center, Center, Center) via ℑxᶜᵃᵃ;    └── * at (Face, Center, Center);       ├── Field located at (Face, Center, Center);       └── Field located at (Face, Center, Center). julia> uu.arg; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Field located at (Face, Center, Center); ```. This also means that operations between `ReducedField` and `Field` also end up at the right place, and we have no need to throw an error if a `BinaryOperation` has a `Nothing` location (in fact, this might be a useful abstraction for binary operations between `ReducedField`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599
https://github.com/CliMA/Oceananigans.jl/pull/1599:5610,Energy Efficiency,Reduce,ReducedField,5610,"nded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ^ at (Face, Center, Center);    ├── - at (Face, Center, Center);    │   ├── Field located at (Face, Center, Center);    │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    └── 2; ```. An added benefit is that the `BinaryOperation` object is simpler. This could help compilation as well... Of course, users do want to be able to specify the location of `BinaryOperations` for output. For this we change how `@at` works: now we wrap the entire user-prescribed expression in an interpolation operator that interpolates the result to the user-specified location. If the location of the underlying expression is already at the user-specified location, this is just an identity. But when the underlying operation is a ""stubborn"" `BinaryOperator`, we interpolate:. ```julia; julia> uu = @at (Center, Center, Center) u * u; UnaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; identity at (Center, Center, Center) via ℑxᶜᵃᵃ;    └── * at (Face, Center, Center);       ├── Field located at (Face, Center, Center);       └── Field located at (Face, Center, Center). julia> uu.arg; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Field located at (Face, Center, Center); ```. This also means that operations between `ReducedField` and `Field` also end up at the right place, and we have no need to throw an error if a `BinaryOperation` has a `Nothing` location (in fact, this might be a useful abstraction for binary operations between `ReducedField`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599
https://github.com/CliMA/Oceananigans.jl/pull/1599:4211,Integrability,wrap,wrap,4211," 0.0]; └── tree: ; * at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Field located at (Face, Center, Center); ```. and. ```julia; julia> tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2);. julia> tke.arg.args[1]; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ^ at (Face, Center, Center);    ├── - at (Face, Center, Center);    │   ├── Field located at (Face, Center, Center);    │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    └── 2; ```. An added benefit is that the `BinaryOperation` object is simpler. This could help compilation as well... Of course, users do want to be able to specify the location of `BinaryOperations` for output. For this we change how `@at` works: now we wrap the entire user-prescribed expression in an interpolation operator that interpolates the result to the user-specified location. If the location of the underlying expression is already at the user-specified location, this is just an identity. But when the underlying operation is a ""stubborn"" `BinaryOperator`, we interpolate:. ```julia; julia> uu = @at (Center, Center, Center) u * u; UnaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; identity at (Center, Center, Center) via ℑxᶜᵃᵃ;    └── * at (Face, Center, Center);       ├── Field located at (Face, Center, Center);       └── Field located at (Face, Center, Center). julia> uu.arg; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Face, Center, Center);    ├── ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599
https://github.com/CliMA/Oceananigans.jl/pull/1599:1723,Performance,perform,performed,1723,"grid); u, v, w = model.velocities. uu = @at (Center, Center, Center) u * u. # output; BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Center, Center, Center) via ℑxᶜᵃᵃ;    ├── Field located at (Face, Center, Center);    └── Field located at (Face, Center, Center); ```. which would compute `u * u` at `(Face, Center, Center)`, and subsequently interpolate to cell centers. The object `uu` would then be defined at cell centers. The main issue of this design in terms of functionality is that it produces expression trees that interpolate ""too eagerly"". A common example is a turbulent kinetic energy computation:. ```julia; U = AveragedField(u, dims=(1, 2)); V = AveragedField(v, dims=(1, 2)). tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2); ```. Inspection of this object reveals that while `u - U` does not interpolate, the squaring `(u - U)^2` would be performed at cell centers:. ```julia; julia> tke.args[1].b; 2. julia> tke.args[1].a; BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; - at (Center, Center, Center) via identity;    ├── Field located at (Face, Center, Center);    └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center); ```. This isn't what we want (usually): instead, we want both `u - U` and subsequent squaring in `(u - U)^2` to be performed at `(Face, Center, Center)`. This PR addresses this issue by getting rid of the third interpolation in `BinaryOperation`, and changing how locations for `BinaryOperation` are inferred. Now, when locations are specified via `@at`, they are taken as a ""suggestion"" that only acts if the two elements of the binary operation have different _c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599
https://github.com/CliMA/Oceananigans.jl/pull/1599:2333,Performance,perform,performed,2333,"his design in terms of functionality is that it produces expression trees that interpolate ""too eagerly"". A common example is a turbulent kinetic energy computation:. ```julia; U = AveragedField(u, dims=(1, 2)); V = AveragedField(v, dims=(1, 2)). tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2); ```. Inspection of this object reveals that while `u - U` does not interpolate, the squaring `(u - U)^2` would be performed at cell centers:. ```julia; julia> tke.args[1].b; 2. julia> tke.args[1].a; BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; - at (Center, Center, Center) via identity;    ├── Field located at (Face, Center, Center);    └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center); ```. This isn't what we want (usually): instead, we want both `u - U` and subsequent squaring in `(u - U)^2` to be performed at `(Face, Center, Center)`. This PR addresses this issue by getting rid of the third interpolation in `BinaryOperation`, and changing how locations for `BinaryOperation` are inferred. Now, when locations are specified via `@at`, they are taken as a ""suggestion"" that only acts if the two elements of the binary operation have different _concrete_ locations such that a difference needs to be resolved. In other cases (such as a binary operation between fields at common locations, or a binary operation between a field and a number), the location of the members of the operation is preserved. In this way, `BinaryOperations` are ""stubborn"". . We thus have results like. ```julia; julia> *((Center, Center, Center), u, u); BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Face, Center, Cen",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599
https://github.com/CliMA/Oceananigans.jl/pull/1599:2974,Testability,stub,stubborn,2974," [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; - at (Center, Center, Center) via identity;    ├── Field located at (Face, Center, Center);    └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center); ```. This isn't what we want (usually): instead, we want both `u - U` and subsequent squaring in `(u - U)^2` to be performed at `(Face, Center, Center)`. This PR addresses this issue by getting rid of the third interpolation in `BinaryOperation`, and changing how locations for `BinaryOperation` are inferred. Now, when locations are specified via `@at`, they are taken as a ""suggestion"" that only acts if the two elements of the binary operation have different _concrete_ locations such that a difference needs to be resolved. In other cases (such as a binary operation between fields at common locations, or a binary operation between a field and a number), the location of the members of the operation is preserved. In this way, `BinaryOperations` are ""stubborn"". . We thus have results like. ```julia; julia> *((Center, Center, Center), u, u); BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Field located at (Face, Center, Center); ```. and. ```julia; julia> tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2);. julia> tke.arg.args[1]; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ^ at (Face, Center, Center);    ├── - at (Face, Center, Center);    │   ├── Field located at (Face, Center, Center);    │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    └──",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599
https://github.com/CliMA/Oceananigans.jl/pull/1599:4498,Testability,stub,stubborn,4498," tke.arg.args[1]; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ^ at (Face, Center, Center);    ├── - at (Face, Center, Center);    │   ├── Field located at (Face, Center, Center);    │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    └── 2; ```. An added benefit is that the `BinaryOperation` object is simpler. This could help compilation as well... Of course, users do want to be able to specify the location of `BinaryOperations` for output. For this we change how `@at` works: now we wrap the entire user-prescribed expression in an interpolation operator that interpolates the result to the user-specified location. If the location of the underlying expression is already at the user-specified location, this is just an identity. But when the underlying operation is a ""stubborn"" `BinaryOperator`, we interpolate:. ```julia; julia> uu = @at (Center, Center, Center) u * u; UnaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; identity at (Center, Center, Center) via ℑxᶜᵃᵃ;    └── * at (Face, Center, Center);       ├── Field located at (Face, Center, Center);       └── Field located at (Face, Center, Center). julia> uu.arg; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Field located at (Face, Center, Center); ```. This also means that operations between `ReducedField` and `Field` also end up at the right place, and we have no need to throw an error if a `BinaryOp",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599
https://github.com/CliMA/Oceananigans.jl/pull/1599:4026,Usability,simpl,simpler,4026,"esults like. ```julia; julia> *((Center, Center, Center), u, u); BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Field located at (Face, Center, Center); ```. and. ```julia; julia> tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2);. julia> tke.arg.args[1]; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; ^ at (Face, Center, Center);    ├── - at (Face, Center, Center);    │   ├── Field located at (Face, Center, Center);    │   └── AveragedField over dims=(1, 2) located at (⋅, ⋅, Center) of Field located at (Face, Center, Center);    └── 2; ```. An added benefit is that the `BinaryOperation` object is simpler. This could help compilation as well... Of course, users do want to be able to specify the location of `BinaryOperations` for output. For this we change how `@at` works: now we wrap the entire user-prescribed expression in an interpolation operator that interpolates the result to the user-specified location. If the location of the underlying expression is already at the user-specified location, this is just an identity. But when the underlying operation is a ""stubborn"" `BinaryOperator`, we interpolate:. ```julia; julia> uu = @at (Center, Center, Center) u * u; UnaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; identity at (Center, Center, Center) via ℑxᶜᵃᵃ;    └── * at (Face, Center, Center);       ├── Field located at (Face, Center, Center);       └── Field located at (Face, Center, Center). julia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599
https://github.com/CliMA/Oceananigans.jl/pull/1600:0,Deployability,Release,Release,0,"Release notes:. * Tests and fixes for `FFTBasedPoissonSolver` for topologies with `Flat` dimensions (#1560); * Improved `AbstractOperations` that are much more likely to compile on the GPU, with better ""location inference"" for `BinaryOperation` (#1595, #1599)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1600
https://github.com/CliMA/Oceananigans.jl/pull/1600:18,Testability,Test,Tests,18,"Release notes:. * Tests and fixes for `FFTBasedPoissonSolver` for topologies with `Flat` dimensions (#1560); * Improved `AbstractOperations` that are much more likely to compile on the GPU, with better ""location inference"" for `BinaryOperation` (#1595, #1599)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1600
https://github.com/CliMA/Oceananigans.jl/pull/1602:680,Deployability,integrat,integrate,680,"This PR adds an eddying aquaplanet validation experiment that's still a work-in-progress (early stage PR). The idea is to force a `HydrostaticFreeSurfaceModel` on a `CubedSphereGrid` with a ""tradewind-like"" zonal wind stress pattern akin to [Marshall et al. (2007)](https://journals.ametsoc.org/view/journals/atsc/64/12/2007jas2226.1.xml). This is figure 3 from the paper:. ![i1520-0469-64-12-4270-f03](https://user-images.githubusercontent.com/20099589/115593956-293a7d00-a2a3-11eb-98cd-4874b6b3d638.gif). and this is the analytic formula I'm using to mimic it:. ![image](https://user-images.githubusercontent.com/20099589/115593657-c8ab4000-a2a2-11eb-8090-b584e88b7e72.png). We integrate `τ` to obtain a streamfunction for the wind stress which we then use to diagnose the surface ; momentum fluxes on the cubed sphere. _I think I got the magnitude wrong so I fixed it with a scaling factor..._. I tried adding a lot of noise to the initial velocities but the wind stress smoothed it away. https://user-images.githubusercontent.com/20099589/115597574-6739a000-a2a7-11eb-9fd5-70ace544bef7.mp4. @christophernhill suggested adding some random noise to the wind stress as well. And we probably also need a mechanism to remove energy otherwise the wind stress keeps accelerating the fluid until the model blows up. Maybe we need some bottom drag even though we only have one vertical level?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1602
https://github.com/CliMA/Oceananigans.jl/pull/1602:1224,Energy Efficiency,energy,energy,1224,"This PR adds an eddying aquaplanet validation experiment that's still a work-in-progress (early stage PR). The idea is to force a `HydrostaticFreeSurfaceModel` on a `CubedSphereGrid` with a ""tradewind-like"" zonal wind stress pattern akin to [Marshall et al. (2007)](https://journals.ametsoc.org/view/journals/atsc/64/12/2007jas2226.1.xml). This is figure 3 from the paper:. ![i1520-0469-64-12-4270-f03](https://user-images.githubusercontent.com/20099589/115593956-293a7d00-a2a3-11eb-98cd-4874b6b3d638.gif). and this is the analytic formula I'm using to mimic it:. ![image](https://user-images.githubusercontent.com/20099589/115593657-c8ab4000-a2a2-11eb-8090-b584e88b7e72.png). We integrate `τ` to obtain a streamfunction for the wind stress which we then use to diagnose the surface ; momentum fluxes on the cubed sphere. _I think I got the magnitude wrong so I fixed it with a scaling factor..._. I tried adding a lot of noise to the initial velocities but the wind stress smoothed it away. https://user-images.githubusercontent.com/20099589/115597574-6739a000-a2a7-11eb-9fd5-70ace544bef7.mp4. @christophernhill suggested adding some random noise to the wind stress as well. And we probably also need a mechanism to remove energy otherwise the wind stress keeps accelerating the fluid until the model blows up. Maybe we need some bottom drag even though we only have one vertical level?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1602
https://github.com/CliMA/Oceananigans.jl/pull/1602:680,Integrability,integrat,integrate,680,"This PR adds an eddying aquaplanet validation experiment that's still a work-in-progress (early stage PR). The idea is to force a `HydrostaticFreeSurfaceModel` on a `CubedSphereGrid` with a ""tradewind-like"" zonal wind stress pattern akin to [Marshall et al. (2007)](https://journals.ametsoc.org/view/journals/atsc/64/12/2007jas2226.1.xml). This is figure 3 from the paper:. ![i1520-0469-64-12-4270-f03](https://user-images.githubusercontent.com/20099589/115593956-293a7d00-a2a3-11eb-98cd-4874b6b3d638.gif). and this is the analytic formula I'm using to mimic it:. ![image](https://user-images.githubusercontent.com/20099589/115593657-c8ab4000-a2a2-11eb-8090-b584e88b7e72.png). We integrate `τ` to obtain a streamfunction for the wind stress which we then use to diagnose the surface ; momentum fluxes on the cubed sphere. _I think I got the magnitude wrong so I fixed it with a scaling factor..._. I tried adding a lot of noise to the initial velocities but the wind stress smoothed it away. https://user-images.githubusercontent.com/20099589/115597574-6739a000-a2a7-11eb-9fd5-70ace544bef7.mp4. @christophernhill suggested adding some random noise to the wind stress as well. And we probably also need a mechanism to remove energy otherwise the wind stress keeps accelerating the fluid until the model blows up. Maybe we need some bottom drag even though we only have one vertical level?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1602
https://github.com/CliMA/Oceananigans.jl/pull/1602:35,Security,validat,validation,35,"This PR adds an eddying aquaplanet validation experiment that's still a work-in-progress (early stage PR). The idea is to force a `HydrostaticFreeSurfaceModel` on a `CubedSphereGrid` with a ""tradewind-like"" zonal wind stress pattern akin to [Marshall et al. (2007)](https://journals.ametsoc.org/view/journals/atsc/64/12/2007jas2226.1.xml). This is figure 3 from the paper:. ![i1520-0469-64-12-4270-f03](https://user-images.githubusercontent.com/20099589/115593956-293a7d00-a2a3-11eb-98cd-4874b6b3d638.gif). and this is the analytic formula I'm using to mimic it:. ![image](https://user-images.githubusercontent.com/20099589/115593657-c8ab4000-a2a2-11eb-8090-b584e88b7e72.png). We integrate `τ` to obtain a streamfunction for the wind stress which we then use to diagnose the surface ; momentum fluxes on the cubed sphere. _I think I got the magnitude wrong so I fixed it with a scaling factor..._. I tried adding a lot of noise to the initial velocities but the wind stress smoothed it away. https://user-images.githubusercontent.com/20099589/115597574-6739a000-a2a7-11eb-9fd5-70ace544bef7.mp4. @christophernhill suggested adding some random noise to the wind stress as well. And we probably also need a mechanism to remove energy otherwise the wind stress keeps accelerating the fluid until the model blows up. Maybe we need some bottom drag even though we only have one vertical level?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1602
https://github.com/CliMA/Oceananigans.jl/pull/1603:19,Testability,test,test,19,TODO:. - [x] Add a test that `KernelComputedField` works with `ConformalCubedSphereGrid`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1603
https://github.com/CliMA/Oceananigans.jl/pull/1604:353,Energy Efficiency,allocate,allocates,353,"Should run these benchmarks again once everything works on the GPU. Notes:; 1. Lat-lon grid seems slower than the single cubed sphere face, which is weird. Maybe the cost of computing the grid metrics on the fly is actually adding up to a significant overhead?; 2. Cubed sphere grid performs better than it should (less than 6x slower than 1 face), but allocates a lot of memory.; 3. Explicit vs. implicit free surface solver performance is problem-dependent so for the purposes of this benchmarks every implicit solver is forced to take 1 iteration. ```; Hydrostatic model benchmarks; ┌───────────────┬──────────────────────────────┬─────────────────────┬───────────┬───────────┬───────────┬───────────┬────────────┬─────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ExplicitFreeSurface │ 3.127 ms │ 3.632 ms │ 3.665 ms │ 4.225 ms │ 263.23 KiB │ 1726 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ExplicitFreeSurface │ 9.765 ms │ 10.370 ms │ 10.428 ms │ 11.847 ms │ 290.50 KiB │ 1984 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ExplicitFreeSurface │ 5.986 ms │ 9.676 ms │ 10.276 ms │ 16.990 ms │ 151.66 KiB │ 1994 │ 10 │; │ CPU │ ConformalCubedSphereGrid │ ExplicitFreeSurface │ 24.817 ms │ 28.235 ms │ 30.393 ms │ 45.743 ms │ 2.12 MiB │ 41751 │ 10 │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ImplicitFreeSurface │ 6.418 ms │ 6.925 ms │ 7.147 ms │ 9.625 ms │ 578.41 KiB │ 3545 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ImplicitFreeSurface │ 15.913 ms │ 16.438 ms │ 17.028 ms │ 20.042 ms │ 656.92 KiB │ 4306 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ImplicitFreeSurface │ 9.89",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1604
https://github.com/CliMA/Oceananigans.jl/pull/1604:449,Integrability,depend,dependent,449,"Should run these benchmarks again once everything works on the GPU. Notes:; 1. Lat-lon grid seems slower than the single cubed sphere face, which is weird. Maybe the cost of computing the grid metrics on the fly is actually adding up to a significant overhead?; 2. Cubed sphere grid performs better than it should (less than 6x slower than 1 face), but allocates a lot of memory.; 3. Explicit vs. implicit free surface solver performance is problem-dependent so for the purposes of this benchmarks every implicit solver is forced to take 1 iteration. ```; Hydrostatic model benchmarks; ┌───────────────┬──────────────────────────────┬─────────────────────┬───────────┬───────────┬───────────┬───────────┬────────────┬─────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ExplicitFreeSurface │ 3.127 ms │ 3.632 ms │ 3.665 ms │ 4.225 ms │ 263.23 KiB │ 1726 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ExplicitFreeSurface │ 9.765 ms │ 10.370 ms │ 10.428 ms │ 11.847 ms │ 290.50 KiB │ 1984 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ExplicitFreeSurface │ 5.986 ms │ 9.676 ms │ 10.276 ms │ 16.990 ms │ 151.66 KiB │ 1994 │ 10 │; │ CPU │ ConformalCubedSphereGrid │ ExplicitFreeSurface │ 24.817 ms │ 28.235 ms │ 30.393 ms │ 45.743 ms │ 2.12 MiB │ 41751 │ 10 │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ImplicitFreeSurface │ 6.418 ms │ 6.925 ms │ 7.147 ms │ 9.625 ms │ 578.41 KiB │ 3545 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ImplicitFreeSurface │ 15.913 ms │ 16.438 ms │ 17.028 ms │ 20.042 ms │ 656.92 KiB │ 4306 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ImplicitFreeSurface │ 9.89",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1604
https://github.com/CliMA/Oceananigans.jl/pull/1604:283,Performance,perform,performs,283,"Should run these benchmarks again once everything works on the GPU. Notes:; 1. Lat-lon grid seems slower than the single cubed sphere face, which is weird. Maybe the cost of computing the grid metrics on the fly is actually adding up to a significant overhead?; 2. Cubed sphere grid performs better than it should (less than 6x slower than 1 face), but allocates a lot of memory.; 3. Explicit vs. implicit free surface solver performance is problem-dependent so for the purposes of this benchmarks every implicit solver is forced to take 1 iteration. ```; Hydrostatic model benchmarks; ┌───────────────┬──────────────────────────────┬─────────────────────┬───────────┬───────────┬───────────┬───────────┬────────────┬─────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ExplicitFreeSurface │ 3.127 ms │ 3.632 ms │ 3.665 ms │ 4.225 ms │ 263.23 KiB │ 1726 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ExplicitFreeSurface │ 9.765 ms │ 10.370 ms │ 10.428 ms │ 11.847 ms │ 290.50 KiB │ 1984 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ExplicitFreeSurface │ 5.986 ms │ 9.676 ms │ 10.276 ms │ 16.990 ms │ 151.66 KiB │ 1994 │ 10 │; │ CPU │ ConformalCubedSphereGrid │ ExplicitFreeSurface │ 24.817 ms │ 28.235 ms │ 30.393 ms │ 45.743 ms │ 2.12 MiB │ 41751 │ 10 │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ImplicitFreeSurface │ 6.418 ms │ 6.925 ms │ 7.147 ms │ 9.625 ms │ 578.41 KiB │ 3545 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ImplicitFreeSurface │ 15.913 ms │ 16.438 ms │ 17.028 ms │ 20.042 ms │ 656.92 KiB │ 4306 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ImplicitFreeSurface │ 9.89",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1604
https://github.com/CliMA/Oceananigans.jl/pull/1604:426,Performance,perform,performance,426,"Should run these benchmarks again once everything works on the GPU. Notes:; 1. Lat-lon grid seems slower than the single cubed sphere face, which is weird. Maybe the cost of computing the grid metrics on the fly is actually adding up to a significant overhead?; 2. Cubed sphere grid performs better than it should (less than 6x slower than 1 face), but allocates a lot of memory.; 3. Explicit vs. implicit free surface solver performance is problem-dependent so for the purposes of this benchmarks every implicit solver is forced to take 1 iteration. ```; Hydrostatic model benchmarks; ┌───────────────┬──────────────────────────────┬─────────────────────┬───────────┬───────────┬───────────┬───────────┬────────────┬─────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ExplicitFreeSurface │ 3.127 ms │ 3.632 ms │ 3.665 ms │ 4.225 ms │ 263.23 KiB │ 1726 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ExplicitFreeSurface │ 9.765 ms │ 10.370 ms │ 10.428 ms │ 11.847 ms │ 290.50 KiB │ 1984 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ExplicitFreeSurface │ 5.986 ms │ 9.676 ms │ 10.276 ms │ 16.990 ms │ 151.66 KiB │ 1994 │ 10 │; │ CPU │ ConformalCubedSphereGrid │ ExplicitFreeSurface │ 24.817 ms │ 28.235 ms │ 30.393 ms │ 45.743 ms │ 2.12 MiB │ 41751 │ 10 │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ImplicitFreeSurface │ 6.418 ms │ 6.925 ms │ 7.147 ms │ 9.625 ms │ 578.41 KiB │ 3545 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ImplicitFreeSurface │ 15.913 ms │ 16.438 ms │ 17.028 ms │ 20.042 ms │ 656.92 KiB │ 4306 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ImplicitFreeSurface │ 9.89",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1604
https://github.com/CliMA/Oceananigans.jl/pull/1604:17,Testability,benchmark,benchmarks,17,"Should run these benchmarks again once everything works on the GPU. Notes:; 1. Lat-lon grid seems slower than the single cubed sphere face, which is weird. Maybe the cost of computing the grid metrics on the fly is actually adding up to a significant overhead?; 2. Cubed sphere grid performs better than it should (less than 6x slower than 1 face), but allocates a lot of memory.; 3. Explicit vs. implicit free surface solver performance is problem-dependent so for the purposes of this benchmarks every implicit solver is forced to take 1 iteration. ```; Hydrostatic model benchmarks; ┌───────────────┬──────────────────────────────┬─────────────────────┬───────────┬───────────┬───────────┬───────────┬────────────┬─────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ExplicitFreeSurface │ 3.127 ms │ 3.632 ms │ 3.665 ms │ 4.225 ms │ 263.23 KiB │ 1726 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ExplicitFreeSurface │ 9.765 ms │ 10.370 ms │ 10.428 ms │ 11.847 ms │ 290.50 KiB │ 1984 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ExplicitFreeSurface │ 5.986 ms │ 9.676 ms │ 10.276 ms │ 16.990 ms │ 151.66 KiB │ 1994 │ 10 │; │ CPU │ ConformalCubedSphereGrid │ ExplicitFreeSurface │ 24.817 ms │ 28.235 ms │ 30.393 ms │ 45.743 ms │ 2.12 MiB │ 41751 │ 10 │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ImplicitFreeSurface │ 6.418 ms │ 6.925 ms │ 7.147 ms │ 9.625 ms │ 578.41 KiB │ 3545 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ImplicitFreeSurface │ 15.913 ms │ 16.438 ms │ 17.028 ms │ 20.042 ms │ 656.92 KiB │ 4306 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ImplicitFreeSurface │ 9.89",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1604
https://github.com/CliMA/Oceananigans.jl/pull/1604:487,Testability,benchmark,benchmarks,487,"Should run these benchmarks again once everything works on the GPU. Notes:; 1. Lat-lon grid seems slower than the single cubed sphere face, which is weird. Maybe the cost of computing the grid metrics on the fly is actually adding up to a significant overhead?; 2. Cubed sphere grid performs better than it should (less than 6x slower than 1 face), but allocates a lot of memory.; 3. Explicit vs. implicit free surface solver performance is problem-dependent so for the purposes of this benchmarks every implicit solver is forced to take 1 iteration. ```; Hydrostatic model benchmarks; ┌───────────────┬──────────────────────────────┬─────────────────────┬───────────┬───────────┬───────────┬───────────┬────────────┬─────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ExplicitFreeSurface │ 3.127 ms │ 3.632 ms │ 3.665 ms │ 4.225 ms │ 263.23 KiB │ 1726 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ExplicitFreeSurface │ 9.765 ms │ 10.370 ms │ 10.428 ms │ 11.847 ms │ 290.50 KiB │ 1984 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ExplicitFreeSurface │ 5.986 ms │ 9.676 ms │ 10.276 ms │ 16.990 ms │ 151.66 KiB │ 1994 │ 10 │; │ CPU │ ConformalCubedSphereGrid │ ExplicitFreeSurface │ 24.817 ms │ 28.235 ms │ 30.393 ms │ 45.743 ms │ 2.12 MiB │ 41751 │ 10 │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ImplicitFreeSurface │ 6.418 ms │ 6.925 ms │ 7.147 ms │ 9.625 ms │ 578.41 KiB │ 3545 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ImplicitFreeSurface │ 15.913 ms │ 16.438 ms │ 17.028 ms │ 20.042 ms │ 656.92 KiB │ 4306 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ImplicitFreeSurface │ 9.89",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1604
https://github.com/CliMA/Oceananigans.jl/pull/1604:574,Testability,benchmark,benchmarks,574,"Should run these benchmarks again once everything works on the GPU. Notes:; 1. Lat-lon grid seems slower than the single cubed sphere face, which is weird. Maybe the cost of computing the grid metrics on the fly is actually adding up to a significant overhead?; 2. Cubed sphere grid performs better than it should (less than 6x slower than 1 face), but allocates a lot of memory.; 3. Explicit vs. implicit free surface solver performance is problem-dependent so for the purposes of this benchmarks every implicit solver is forced to take 1 iteration. ```; Hydrostatic model benchmarks; ┌───────────────┬──────────────────────────────┬─────────────────────┬───────────┬───────────┬───────────┬───────────┬────────────┬─────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ExplicitFreeSurface │ 3.127 ms │ 3.632 ms │ 3.665 ms │ 4.225 ms │ 263.23 KiB │ 1726 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ExplicitFreeSurface │ 9.765 ms │ 10.370 ms │ 10.428 ms │ 11.847 ms │ 290.50 KiB │ 1984 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ExplicitFreeSurface │ 5.986 ms │ 9.676 ms │ 10.276 ms │ 16.990 ms │ 151.66 KiB │ 1994 │ 10 │; │ CPU │ ConformalCubedSphereGrid │ ExplicitFreeSurface │ 24.817 ms │ 28.235 ms │ 30.393 ms │ 45.743 ms │ 2.12 MiB │ 41751 │ 10 │; ├───────────────┼──────────────────────────────┼─────────────────────┼───────────┼───────────┼───────────┼───────────┼────────────┼─────────┼─────────┤; │ CPU │ RegularRectilinearGrid │ ImplicitFreeSurface │ 6.418 ms │ 6.925 ms │ 7.147 ms │ 9.625 ms │ 578.41 KiB │ 3545 │ 10 │; │ CPU │ RegularLatitudeLongitudeGrid │ ImplicitFreeSurface │ 15.913 ms │ 16.438 ms │ 17.028 ms │ 20.042 ms │ 656.92 KiB │ 4306 │ 10 │; │ CPU │ ConformalCubedSphereFaceGrid │ ImplicitFreeSurface │ 9.89",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1604
https://github.com/CliMA/Oceananigans.jl/issues/1605:22,Availability,error,error,22,`with_halo` throws an error for `VerticallyStretchedRectilinearGrid`:. https://github.com/CliMA/Oceananigans.jl/blob/6ff1f69e2bc5d66a0889fb3c62fb2a3b633ab535/src/Grids/vertically_stretched_rectilinear_grid.jl#L227-L231. despite that the stretched `z_faces` / `zF` kwarg can be inferred from `grid.zᵃᵃᶠ`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1605
https://github.com/CliMA/Oceananigans.jl/pull/1607:1636,Testability,Test,Tests,1636,"Resolves #1452 . Example:. ```julia; julia> using Oceananigans. julia> using Oceananigans.AbstractOperations: GridMetric. julia> grid = RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (1, 1, 1); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (1.0, 1.0, 1.0). julia> Δz = GridMetric{Center, Center, Center}(Oceananigans.Operators.Δzᵃᵃᶜ, grid); GridMetric at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; GridMetric at (Center, Center, Center). julia> c = CenterField(CPU(), grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (3, 3, 3); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux). julia> c_dz = c * Δz; BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; * at (Center, Center, Center);    ├── Field located at (Center, Center, Center);    └── GridMetric at (Center, Center, Center); ```. TODO:. - [x] Add `architecture(grid)` for grids other than `RegularRectilinearGrid`.; - [x] Tests; - [x] Explore the possibility of special objects `Δx, Δy, Δz` that infer `BinaryOperation` location and create appropriate `GridMetric` operations at appropriate locations automagically.; - [x] I don't think we need `Difference` as proposed on #1452, but if others disagree we can add them here. cc @tomchor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1607
https://github.com/CliMA/Oceananigans.jl/issues/1610:328,Integrability,wrap,wrapper,328,Right now `interior(field)` returns a view into `f.data` --- an `OffsetArray`. But we obtain the same indexing behavior if `interior(field)` returns a view into `parent(f)` with appropriate indices. The benefit is that a view into `parent(f)` is `Base.SubArray` and supported in many GPU operations. It's also simpler (a single wrapper around an `AbstractArray`). A `view` into `OffsetArray` is a wrapper around a wrapper. Since indexing is the same I don't think this is a breaking change either. Just wondering if anyone objects. If nobody does we can probably nix `interiorparent` as well.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1610
https://github.com/CliMA/Oceananigans.jl/issues/1610:397,Integrability,wrap,wrapper,397,Right now `interior(field)` returns a view into `f.data` --- an `OffsetArray`. But we obtain the same indexing behavior if `interior(field)` returns a view into `parent(f)` with appropriate indices. The benefit is that a view into `parent(f)` is `Base.SubArray` and supported in many GPU operations. It's also simpler (a single wrapper around an `AbstractArray`). A `view` into `OffsetArray` is a wrapper around a wrapper. Since indexing is the same I don't think this is a breaking change either. Just wondering if anyone objects. If nobody does we can probably nix `interiorparent` as well.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1610
https://github.com/CliMA/Oceananigans.jl/issues/1610:414,Integrability,wrap,wrapper,414,Right now `interior(field)` returns a view into `f.data` --- an `OffsetArray`. But we obtain the same indexing behavior if `interior(field)` returns a view into `parent(f)` with appropriate indices. The benefit is that a view into `parent(f)` is `Base.SubArray` and supported in many GPU operations. It's also simpler (a single wrapper around an `AbstractArray`). A `view` into `OffsetArray` is a wrapper around a wrapper. Since indexing is the same I don't think this is a breaking change either. Just wondering if anyone objects. If nobody does we can probably nix `interiorparent` as well.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1610
https://github.com/CliMA/Oceananigans.jl/issues/1610:310,Usability,simpl,simpler,310,Right now `interior(field)` returns a view into `f.data` --- an `OffsetArray`. But we obtain the same indexing behavior if `interior(field)` returns a view into `parent(f)` with appropriate indices. The benefit is that a view into `parent(f)` is `Base.SubArray` and supported in many GPU operations. It's also simpler (a single wrapper around an `AbstractArray`). A `view` into `OffsetArray` is a wrapper around a wrapper. Since indexing is the same I don't think this is a breaking change either. Just wondering if anyone objects. If nobody does we can probably nix `interiorparent` as well.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1610
https://github.com/CliMA/Oceananigans.jl/pull/1611:516,Energy Efficiency,allocate,allocate,516,"This PR adds support for in-place reduction operations where the target is an `AbstractReducedField` and the source is either an `AbstractDataField`, `AbstractOperation`, or array of some kind. These work on the GPU. In the end the solution was simple since we now subtype `AbstractArray`; we only need to pass a view into the interior indices of the target to `Base.mapreducedim!` (which on the GPU ends up at `GPUArrays.mapreducedim!`). The result is that `AveragedField(op::AbstractOperation)` no longer needs to allocate memory for the three-dimensional result of computing `op`. Instead, `op` is reduced in a kernel. This is both faster (much much faster, I think --- though a benchmark is a good idea) and more memory efficient. It also greatly simplifies `compute!(field::AveragedField)`:. ```julia; function compute!(avg::AveragedField, time=nothing); compute_at!(avg.operand, time); mean!(avg, operand); return nothing; end; ```. So, resolves #1422. I also took the liberty of resolving #1610 and nuking `interiorparent`...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1611
https://github.com/CliMA/Oceananigans.jl/pull/1611:601,Energy Efficiency,reduce,reduced,601,"This PR adds support for in-place reduction operations where the target is an `AbstractReducedField` and the source is either an `AbstractDataField`, `AbstractOperation`, or array of some kind. These work on the GPU. In the end the solution was simple since we now subtype `AbstractArray`; we only need to pass a view into the interior indices of the target to `Base.mapreducedim!` (which on the GPU ends up at `GPUArrays.mapreducedim!`). The result is that `AveragedField(op::AbstractOperation)` no longer needs to allocate memory for the three-dimensional result of computing `op`. Instead, `op` is reduced in a kernel. This is both faster (much much faster, I think --- though a benchmark is a good idea) and more memory efficient. It also greatly simplifies `compute!(field::AveragedField)`:. ```julia; function compute!(avg::AveragedField, time=nothing); compute_at!(avg.operand, time); mean!(avg, operand); return nothing; end; ```. So, resolves #1422. I also took the liberty of resolving #1610 and nuking `interiorparent`...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1611
https://github.com/CliMA/Oceananigans.jl/pull/1611:724,Energy Efficiency,efficient,efficient,724,"This PR adds support for in-place reduction operations where the target is an `AbstractReducedField` and the source is either an `AbstractDataField`, `AbstractOperation`, or array of some kind. These work on the GPU. In the end the solution was simple since we now subtype `AbstractArray`; we only need to pass a view into the interior indices of the target to `Base.mapreducedim!` (which on the GPU ends up at `GPUArrays.mapreducedim!`). The result is that `AveragedField(op::AbstractOperation)` no longer needs to allocate memory for the three-dimensional result of computing `op`. Instead, `op` is reduced in a kernel. This is both faster (much much faster, I think --- though a benchmark is a good idea) and more memory efficient. It also greatly simplifies `compute!(field::AveragedField)`:. ```julia; function compute!(avg::AveragedField, time=nothing); compute_at!(avg.operand, time); mean!(avg, operand); return nothing; end; ```. So, resolves #1422. I also took the liberty of resolving #1610 and nuking `interiorparent`...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1611
https://github.com/CliMA/Oceananigans.jl/pull/1611:682,Testability,benchmark,benchmark,682,"This PR adds support for in-place reduction operations where the target is an `AbstractReducedField` and the source is either an `AbstractDataField`, `AbstractOperation`, or array of some kind. These work on the GPU. In the end the solution was simple since we now subtype `AbstractArray`; we only need to pass a view into the interior indices of the target to `Base.mapreducedim!` (which on the GPU ends up at `GPUArrays.mapreducedim!`). The result is that `AveragedField(op::AbstractOperation)` no longer needs to allocate memory for the three-dimensional result of computing `op`. Instead, `op` is reduced in a kernel. This is both faster (much much faster, I think --- though a benchmark is a good idea) and more memory efficient. It also greatly simplifies `compute!(field::AveragedField)`:. ```julia; function compute!(avg::AveragedField, time=nothing); compute_at!(avg.operand, time); mean!(avg, operand); return nothing; end; ```. So, resolves #1422. I also took the liberty of resolving #1610 and nuking `interiorparent`...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1611
https://github.com/CliMA/Oceananigans.jl/pull/1611:245,Usability,simpl,simple,245,"This PR adds support for in-place reduction operations where the target is an `AbstractReducedField` and the source is either an `AbstractDataField`, `AbstractOperation`, or array of some kind. These work on the GPU. In the end the solution was simple since we now subtype `AbstractArray`; we only need to pass a view into the interior indices of the target to `Base.mapreducedim!` (which on the GPU ends up at `GPUArrays.mapreducedim!`). The result is that `AveragedField(op::AbstractOperation)` no longer needs to allocate memory for the three-dimensional result of computing `op`. Instead, `op` is reduced in a kernel. This is both faster (much much faster, I think --- though a benchmark is a good idea) and more memory efficient. It also greatly simplifies `compute!(field::AveragedField)`:. ```julia; function compute!(avg::AveragedField, time=nothing); compute_at!(avg.operand, time); mean!(avg, operand); return nothing; end; ```. So, resolves #1422. I also took the liberty of resolving #1610 and nuking `interiorparent`...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1611
https://github.com/CliMA/Oceananigans.jl/pull/1611:751,Usability,simpl,simplifies,751,"This PR adds support for in-place reduction operations where the target is an `AbstractReducedField` and the source is either an `AbstractDataField`, `AbstractOperation`, or array of some kind. These work on the GPU. In the end the solution was simple since we now subtype `AbstractArray`; we only need to pass a view into the interior indices of the target to `Base.mapreducedim!` (which on the GPU ends up at `GPUArrays.mapreducedim!`). The result is that `AveragedField(op::AbstractOperation)` no longer needs to allocate memory for the three-dimensional result of computing `op`. Instead, `op` is reduced in a kernel. This is both faster (much much faster, I think --- though a benchmark is a good idea) and more memory efficient. It also greatly simplifies `compute!(field::AveragedField)`:. ```julia; function compute!(avg::AveragedField, time=nothing); compute_at!(avg.operand, time); mean!(avg, operand); return nothing; end; ```. So, resolves #1422. I also took the liberty of resolving #1610 and nuking `interiorparent`...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1611
https://github.com/CliMA/Oceananigans.jl/issues/1613:89,Availability,error,error,89,"Hello everyone,; I am facing some difficulty in running this code. This doesn't show any error and generates an output JLD2 file and then seemed to freeze. No sign appears. It even doesn't write any output in the file. From the system point of view, I can see that Julia correctly recognizes GPUs as being am_70 type and compiles some code for them. Then it starts to execute the following statement:. ```run!(simulation)```. That statement is running for some time and get freezes. Can you please run it in your system, I want to check whether it is the code or my system creating this strange behaviour. . ```; using Printf; # using Pkg; # pkg""add Oceananigans#ali/unclog-docs""; using Oceananigans; using Oceananigans.Utils; using Oceananigans.Units: minute, minutes, hour; using Oceananigans.Grids: nodes; using Oceananigans.Diagnostics; using Oceananigans.OutputWriters: JLD2OutputWriter, FieldSlicer, TimeInterval; using Statistics; using CUDA. #number of grid spacing in south,north and vertical direction and in oceananigans ; #they call this as the size of one grid in that direction; const Nx=256; const Ny=256; const Nz=64. #Length of grid in south, north and vertical direction; const Lx=4; const Ly=4; const Lz=0.1. #Vetrical temperature gradient; const dTz = 70. #scaled gravitational acceleration; const g=300. const R0=1; const T0=30; const Factor_T =1e-6; const Factor_V=1e-8. Name_of_simulation = ""ocean_convection_Fplane_GPU"". #Coefficient of Thermal expansion; const alpha= 2e-4; #Coefficient of Salinity; const saline=0; #diffusive viscocity; const v=1e-5 ; #diffusivity; const k=2e-6 . const l=Lx/2 #center of gaussian field; const m=Ly/2 #center of gausian field. const Bo=3.6e-4 #maximum surface flux; const f=-0.5 #coriolis parameter. computational_grid = RegularRectilinearGrid(size=(Nx, Ny, Nz), extent=(Lx, Ly, Lz)); show(computational_grid). ##xC,yC,zC are not defined for vertically stretched grid; # computational_grid.zᵃᵃᶜ; # computational_grid.xᶜᵃᵃ; # computational_gri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613
https://github.com/CliMA/Oceananigans.jl/issues/1613:4909,Deployability,update,update,4909,"z * Factor_T * Ξ(z). # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * Factor_V * Ξ(z). # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl= 0.6, Δt = 0.05, max_change = 1.1, max_Δt = 0.2minute). # A type for calculating adaptive time steps based on capping the CFL number at `cfl`.; # On calling `update_Δt!(wizard, model)`, the `TimeStepWizard` computes a time-step such that; # ``cfl = max(u/Δx, v/Δy, w/Δz) Δt``, where ``max(u/Δx, v/Δy, w/Δz)`` is the maximum ratio; # between model velocity and along-velocity grid spacing anywhere on the model grid. The new; # `Δt` is constrained to change by a multiplicative factor no more than `max_change` or no; # less than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model, Δt=wizard, stop_time= 10minute, iteration_interval = 10,; progress=progress_message). simulation.output_writers[:fields] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers),; prefix = Name_of_simulation,; schedule = TimeInterval(0.2minute),; force = true). run!(simulation). using JLD2. using Plots. # load(""modified_open_ocean_convection_Fplane_GPU.jld2""). file = jldopen(""ocean_convection_Fplane_GPU.jld2""). # Coordinate arrays; xC, yC, zC = file[""grid/xC""][1:256],file[""grid/yC""][1:256],file[""grid/zC""][1:65]; Lx, Ly, Lz = file[""grid/Lx""],file[""grid/Ly""],f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613
https://github.com/CliMA/Oceananigans.jl/issues/1613:4269,Energy Efficiency,adapt,adaptive,4269,"e)). #Incompressible model initiation . using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = IncompressibleModel(architecture = GPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)). # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. # Temperature initial condition: a stable density gradient with random noise superposed. Tᵢ(x, y, z) = T0 + dTz * z + dTz * model.grid.Lz * Factor_T * Ξ(z). # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * Factor_V * Ξ(z). # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl= 0.6, Δt = 0.05, max_change = 1.1, max_Δt = 0.2minute). # A type for calculating adaptive time steps based on capping the CFL number at `cfl`.; # On calling `update_Δt!(wizard, model)`, the `TimeStepWizard` computes a time-step such that; # ``cfl = max(u/Δx, v/Δy, w/Δz) Δt``, where ``max(u/Δx, v/Δy, w/Δz)`` is the maximum ratio; # between model velocity and along-velocity grid spacing anywhere on the model grid. The new; # `Δt` is constrained to change by a multiplicative factor no more than `max_change` or no; # less than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_n",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613
https://github.com/CliMA/Oceananigans.jl/issues/1613:5565,Energy Efficiency,schedul,schedule,5565,"ocity grid spacing anywhere on the model grid. The new; # `Δt` is constrained to change by a multiplicative factor no more than `max_change` or no; # less than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model, Δt=wizard, stop_time= 10minute, iteration_interval = 10,; progress=progress_message). simulation.output_writers[:fields] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers),; prefix = Name_of_simulation,; schedule = TimeInterval(0.2minute),; force = true). run!(simulation). using JLD2. using Plots. # load(""modified_open_ocean_convection_Fplane_GPU.jld2""). file = jldopen(""ocean_convection_Fplane_GPU.jld2""). # Coordinate arrays; xC, yC, zC = file[""grid/xC""][1:256],file[""grid/yC""][1:256],file[""grid/zC""][1:65]; Lx, Ly, Lz = file[""grid/Lx""],file[""grid/Ly""],file[""grid/Lz""]. # Extract a vector of iterations; iterations = parse.(Int, keys(file[""timeseries/t""])). @info ""Making a neat movie of verticle velocity and Temperature..."". anim = @animate for (i, iteration) in enumerate(iterations). @info ""Plotting frame $i from iteration $iteration..."". t = file[""timeseries/t/$iteration""]; u_snapshot = file[""timeseries/u/$iteration""][:, :, 60]; v_snapshot = file[""timeseries/v/$iteration""][:, :, 60]; w_snapshot = file[""timeseries/w/$iteration""][:, 128, :]; speed_snapshot = sqrt.(u_snapshot.*u_snapshot + v_snapshot.*v_snapshot); # T_snapshot = file[""timeseries/T/$iteration""][:, 128, :]; . ulims = 0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613
https://github.com/CliMA/Oceananigans.jl/issues/1613:5045,Integrability,message,message,5045,"the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl= 0.6, Δt = 0.05, max_change = 1.1, max_Δt = 0.2minute). # A type for calculating adaptive time steps based on capping the CFL number at `cfl`.; # On calling `update_Δt!(wizard, model)`, the `TimeStepWizard` computes a time-step such that; # ``cfl = max(u/Δx, v/Δy, w/Δz) Δt``, where ``max(u/Δx, v/Δy, w/Δz)`` is the maximum ratio; # between model velocity and along-velocity grid spacing anywhere on the model grid. The new; # `Δt` is constrained to change by a multiplicative factor no more than `max_change` or no; # less than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model, Δt=wizard, stop_time= 10minute, iteration_interval = 10,; progress=progress_message). simulation.output_writers[:fields] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers),; prefix = Name_of_simulation,; schedule = TimeInterval(0.2minute),; force = true). run!(simulation). using JLD2. using Plots. # load(""modified_open_ocean_convection_Fplane_GPU.jld2""). file = jldopen(""ocean_convection_Fplane_GPU.jld2""). # Coordinate arrays; xC, yC, zC = file[""grid/xC""][1:256],file[""grid/yC""][1:256],file[""grid/zC""][1:65]; Lx, Ly, Lz = file[""grid/Lx""],file[""grid/Ly""],file[""grid/Lz""]. # Extract a vector of iterations; iterations = parse.(Int, keys(file[""timeseries/t""])). @info ""Making a neat movie of verticle velocity an",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613
https://github.com/CliMA/Oceananigans.jl/issues/1613:4269,Modifiability,adapt,adaptive,4269,"e)). #Incompressible model initiation . using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = IncompressibleModel(architecture = GPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)). # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. # Temperature initial condition: a stable density gradient with random noise superposed. Tᵢ(x, y, z) = T0 + dTz * z + dTz * model.grid.Lz * Factor_T * Ξ(z). # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * Factor_V * Ξ(z). # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl= 0.6, Δt = 0.05, max_change = 1.1, max_Δt = 0.2minute). # A type for calculating adaptive time steps based on capping the CFL number at `cfl`.; # On calling `update_Δt!(wizard, model)`, the `TimeStepWizard` computes a time-step such that; # ``cfl = max(u/Δx, v/Δy, w/Δz) Δt``, where ``max(u/Δx, v/Δy, w/Δz)`` is the maximum ratio; # between model velocity and along-velocity grid spacing anywhere on the model grid. The new; # `Δt` is constrained to change by a multiplicative factor no more than `max_change` or no; # less than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_n",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613
https://github.com/CliMA/Oceananigans.jl/issues/1613:5662,Performance,load,load,5662," `max_change` or no; # less than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model, Δt=wizard, stop_time= 10minute, iteration_interval = 10,; progress=progress_message). simulation.output_writers[:fields] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers),; prefix = Name_of_simulation,; schedule = TimeInterval(0.2minute),; force = true). run!(simulation). using JLD2. using Plots. # load(""modified_open_ocean_convection_Fplane_GPU.jld2""). file = jldopen(""ocean_convection_Fplane_GPU.jld2""). # Coordinate arrays; xC, yC, zC = file[""grid/xC""][1:256],file[""grid/yC""][1:256],file[""grid/zC""][1:65]; Lx, Ly, Lz = file[""grid/Lx""],file[""grid/Ly""],file[""grid/Lz""]. # Extract a vector of iterations; iterations = parse.(Int, keys(file[""timeseries/t""])). @info ""Making a neat movie of verticle velocity and Temperature..."". anim = @animate for (i, iteration) in enumerate(iterations). @info ""Plotting frame $i from iteration $iteration..."". t = file[""timeseries/t/$iteration""]; u_snapshot = file[""timeseries/u/$iteration""][:, :, 60]; v_snapshot = file[""timeseries/v/$iteration""][:, :, 60]; w_snapshot = file[""timeseries/w/$iteration""][:, 128, :]; speed_snapshot = sqrt.(u_snapshot.*u_snapshot + v_snapshot.*v_snapshot); # T_snapshot = file[""timeseries/T/$iteration""][:, 128, :]; . ulims = 0.0025; ; ulevels = range(-ulims, stop=ulims, length=50); ; slims = 0.025; ; slevels = range(0, stop=slims, length=50); ; Tlims ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613
https://github.com/CliMA/Oceananigans.jl/pull/1614:161,Deployability,configurat,configurations,161,"This PR intends to abstract the concept of a grid with ""multiple regions"" from the cubed sphere. We only need one `MultiRegionGrid` to support a wide variety of configurations, including the CubedSphere. The hope in the near term is that this clarifies the code and implementation of cross-region halo exchanges. This PR was also going to implement broadcasting and try to get `ComputedField` working for fields and `AbstractOperations` distributed across multiple regions. This would get the PreconditionedConjugateGradientSolver working on MultiRegionGrid. To get this working we ""only"" need to define `get_region(op, i)` for `op::BinaryOperation, UnaryOperation, MultiaryOperation, Derivative`, which might not be too difficult. It also intends to define a macro `@regionalize` which we can use either to decorate existing functions or to conveniently extend functions to broadcast across multiple regions. Right now ""regional broadcasting"" is done manually, which is cumbersome and presumably can only lead to a build up of boilerplate. My changes broke the halo exchange tests however. @ali-ramadhan I need your help to fix these. If we can fix the tests, then we can move forward with this PR. Otherwise we may have to start over.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1614
https://github.com/CliMA/Oceananigans.jl/pull/1614:161,Modifiability,config,configurations,161,"This PR intends to abstract the concept of a grid with ""multiple regions"" from the cubed sphere. We only need one `MultiRegionGrid` to support a wide variety of configurations, including the CubedSphere. The hope in the near term is that this clarifies the code and implementation of cross-region halo exchanges. This PR was also going to implement broadcasting and try to get `ComputedField` working for fields and `AbstractOperations` distributed across multiple regions. This would get the PreconditionedConjugateGradientSolver working on MultiRegionGrid. To get this working we ""only"" need to define `get_region(op, i)` for `op::BinaryOperation, UnaryOperation, MultiaryOperation, Derivative`, which might not be too difficult. It also intends to define a macro `@regionalize` which we can use either to decorate existing functions or to conveniently extend functions to broadcast across multiple regions. Right now ""regional broadcasting"" is done manually, which is cumbersome and presumably can only lead to a build up of boilerplate. My changes broke the halo exchange tests however. @ali-ramadhan I need your help to fix these. If we can fix the tests, then we can move forward with this PR. Otherwise we may have to start over.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1614
https://github.com/CliMA/Oceananigans.jl/pull/1614:855,Modifiability,extend,extend,855,"This PR intends to abstract the concept of a grid with ""multiple regions"" from the cubed sphere. We only need one `MultiRegionGrid` to support a wide variety of configurations, including the CubedSphere. The hope in the near term is that this clarifies the code and implementation of cross-region halo exchanges. This PR was also going to implement broadcasting and try to get `ComputedField` working for fields and `AbstractOperations` distributed across multiple regions. This would get the PreconditionedConjugateGradientSolver working on MultiRegionGrid. To get this working we ""only"" need to define `get_region(op, i)` for `op::BinaryOperation, UnaryOperation, MultiaryOperation, Derivative`, which might not be too difficult. It also intends to define a macro `@regionalize` which we can use either to decorate existing functions or to conveniently extend functions to broadcast across multiple regions. Right now ""regional broadcasting"" is done manually, which is cumbersome and presumably can only lead to a build up of boilerplate. My changes broke the halo exchange tests however. @ali-ramadhan I need your help to fix these. If we can fix the tests, then we can move forward with this PR. Otherwise we may have to start over.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1614
https://github.com/CliMA/Oceananigans.jl/pull/1614:1076,Testability,test,tests,1076,"This PR intends to abstract the concept of a grid with ""multiple regions"" from the cubed sphere. We only need one `MultiRegionGrid` to support a wide variety of configurations, including the CubedSphere. The hope in the near term is that this clarifies the code and implementation of cross-region halo exchanges. This PR was also going to implement broadcasting and try to get `ComputedField` working for fields and `AbstractOperations` distributed across multiple regions. This would get the PreconditionedConjugateGradientSolver working on MultiRegionGrid. To get this working we ""only"" need to define `get_region(op, i)` for `op::BinaryOperation, UnaryOperation, MultiaryOperation, Derivative`, which might not be too difficult. It also intends to define a macro `@regionalize` which we can use either to decorate existing functions or to conveniently extend functions to broadcast across multiple regions. Right now ""regional broadcasting"" is done manually, which is cumbersome and presumably can only lead to a build up of boilerplate. My changes broke the halo exchange tests however. @ali-ramadhan I need your help to fix these. If we can fix the tests, then we can move forward with this PR. Otherwise we may have to start over.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1614
https://github.com/CliMA/Oceananigans.jl/pull/1614:1154,Testability,test,tests,1154,"This PR intends to abstract the concept of a grid with ""multiple regions"" from the cubed sphere. We only need one `MultiRegionGrid` to support a wide variety of configurations, including the CubedSphere. The hope in the near term is that this clarifies the code and implementation of cross-region halo exchanges. This PR was also going to implement broadcasting and try to get `ComputedField` working for fields and `AbstractOperations` distributed across multiple regions. This would get the PreconditionedConjugateGradientSolver working on MultiRegionGrid. To get this working we ""only"" need to define `get_region(op, i)` for `op::BinaryOperation, UnaryOperation, MultiaryOperation, Derivative`, which might not be too difficult. It also intends to define a macro `@regionalize` which we can use either to decorate existing functions or to conveniently extend functions to broadcast across multiple regions. Right now ""regional broadcasting"" is done manually, which is cumbersome and presumably can only lead to a build up of boilerplate. My changes broke the halo exchange tests however. @ali-ramadhan I need your help to fix these. If we can fix the tests, then we can move forward with this PR. Otherwise we may have to start over.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1614
https://github.com/CliMA/Oceananigans.jl/pull/1619:81,Availability,error,error,81,"Trying to use `AnisotropicMinimumDissipation` with `buoyancy = nothing` threw an error because it tries to access `buoyancy.model`, which doesn't exist when `buoyancy = nothing`. This PR fixes that bug and adds a few tests for time-stepping AMD with different buoyancy models, including `buoyancy=nothing`. The bug is fixed by adding a new default `Cb = nothing` (rather than `Cb = 0.0`), in which case the computation of the buoyancy modification term is elided entirely. This might speed up some models (but who knows by how much). It is _still_ the case that users who specify a non-default `Cb` without a buoyancy model receive error that could be hard to interpret. We could `validate_closure` for this. I feel it's not worth the effort right now though because the buoyancy modification term is not implemented correctly anyways, and it seems that even if implemented correctly it may not improve the fidelity of simulations with buoyancy. A better solution might be to delete the code associated with the buoyancy modification term and simplify our lives.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1619
https://github.com/CliMA/Oceananigans.jl/pull/1619:632,Availability,error,error,632,"Trying to use `AnisotropicMinimumDissipation` with `buoyancy = nothing` threw an error because it tries to access `buoyancy.model`, which doesn't exist when `buoyancy = nothing`. This PR fixes that bug and adds a few tests for time-stepping AMD with different buoyancy models, including `buoyancy=nothing`. The bug is fixed by adding a new default `Cb = nothing` (rather than `Cb = 0.0`), in which case the computation of the buoyancy modification term is elided entirely. This might speed up some models (but who knows by how much). It is _still_ the case that users who specify a non-default `Cb` without a buoyancy model receive error that could be hard to interpret. We could `validate_closure` for this. I feel it's not worth the effort right now though because the buoyancy modification term is not implemented correctly anyways, and it seems that even if implemented correctly it may not improve the fidelity of simulations with buoyancy. A better solution might be to delete the code associated with the buoyancy modification term and simplify our lives.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1619
https://github.com/CliMA/Oceananigans.jl/pull/1619:107,Security,access,access,107,"Trying to use `AnisotropicMinimumDissipation` with `buoyancy = nothing` threw an error because it tries to access `buoyancy.model`, which doesn't exist when `buoyancy = nothing`. This PR fixes that bug and adds a few tests for time-stepping AMD with different buoyancy models, including `buoyancy=nothing`. The bug is fixed by adding a new default `Cb = nothing` (rather than `Cb = 0.0`), in which case the computation of the buoyancy modification term is elided entirely. This might speed up some models (but who knows by how much). It is _still_ the case that users who specify a non-default `Cb` without a buoyancy model receive error that could be hard to interpret. We could `validate_closure` for this. I feel it's not worth the effort right now though because the buoyancy modification term is not implemented correctly anyways, and it seems that even if implemented correctly it may not improve the fidelity of simulations with buoyancy. A better solution might be to delete the code associated with the buoyancy modification term and simplify our lives.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1619
https://github.com/CliMA/Oceananigans.jl/pull/1619:217,Testability,test,tests,217,"Trying to use `AnisotropicMinimumDissipation` with `buoyancy = nothing` threw an error because it tries to access `buoyancy.model`, which doesn't exist when `buoyancy = nothing`. This PR fixes that bug and adds a few tests for time-stepping AMD with different buoyancy models, including `buoyancy=nothing`. The bug is fixed by adding a new default `Cb = nothing` (rather than `Cb = 0.0`), in which case the computation of the buoyancy modification term is elided entirely. This might speed up some models (but who knows by how much). It is _still_ the case that users who specify a non-default `Cb` without a buoyancy model receive error that could be hard to interpret. We could `validate_closure` for this. I feel it's not worth the effort right now though because the buoyancy modification term is not implemented correctly anyways, and it seems that even if implemented correctly it may not improve the fidelity of simulations with buoyancy. A better solution might be to delete the code associated with the buoyancy modification term and simplify our lives.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1619
https://github.com/CliMA/Oceananigans.jl/pull/1619:1043,Usability,simpl,simplify,1043,"Trying to use `AnisotropicMinimumDissipation` with `buoyancy = nothing` threw an error because it tries to access `buoyancy.model`, which doesn't exist when `buoyancy = nothing`. This PR fixes that bug and adds a few tests for time-stepping AMD with different buoyancy models, including `buoyancy=nothing`. The bug is fixed by adding a new default `Cb = nothing` (rather than `Cb = 0.0`), in which case the computation of the buoyancy modification term is elided entirely. This might speed up some models (but who knows by how much). It is _still_ the case that users who specify a non-default `Cb` without a buoyancy model receive error that could be hard to interpret. We could `validate_closure` for this. I feel it's not worth the effort right now though because the buoyancy modification term is not implemented correctly anyways, and it seems that even if implemented correctly it may not improve the fidelity of simulations with buoyancy. A better solution might be to delete the code associated with the buoyancy modification term and simplify our lives.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1619
https://github.com/CliMA/Oceananigans.jl/pull/1621:84,Deployability,update,update,84,This may resolve #1601 . We'll need to test manually I think since we don't want to update the whole `Manifest.toml`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1621
https://github.com/CliMA/Oceananigans.jl/pull/1621:39,Testability,test,test,39,This may resolve #1601 . We'll need to test manually I think since we don't want to update the whole `Manifest.toml`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1621
https://github.com/CliMA/Oceananigans.jl/pull/1622:96,Security,validat,validation,96,This PR fixes `set!` for `CubedSphereReducedField` for now which is used in the Rossby-Haurwitz validation experiment (and adds tests).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1622
https://github.com/CliMA/Oceananigans.jl/pull/1622:128,Testability,test,tests,128,This PR fixes `set!` for `CubedSphereReducedField` for now which is used in the Rossby-Haurwitz validation experiment (and adds tests).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1622
https://github.com/CliMA/Oceananigans.jl/issues/1623:211,Energy Efficiency,reduce,reduced,211,"Now that we have an interface for fast on-the-fly reductions, it might make sense to implement a `KernelFunctionOperation` feature that accepts custom `kernel_function(i, j, k, grid, fields...)` so these can be reduced. (And in fact, this might also provide a replacement for `KernelComputedField`). Something like. ```julia; struct KernelFunctionOperation{LX, LY, LZ, P, A, G, T, K, D} <: AbstractOperation{LX, LY, LZ, A, G, T}; op :: K; grid :: G; architecture :: A; computed_dependencies :: D; parameters :: P; end. @inline Base.getindex(κ::KernelFunctionOperation, i, j, k) = κ.op(i, j, k, grid, κ.computed_dependencies..., κ.parameters}; @inline Base.getindex(κ::KernelFunctionOperation{LX, LY, LZ, <:Nothing}, i, j, k) where {LX, LY, LZ} = κ.op(i, j, k, grid, κ.computed_dependencies...}; ```. With an appropriate `compute!` (or `compute_at!`) method for ensuring that `computed_dependencies` get computed, this might be a better / leaner interface than the one provided by `KernelComputedField`, with the added, extremely useful benefit that it can be reduced on the fly just like other `AbstractOperation`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1623
https://github.com/CliMA/Oceananigans.jl/issues/1623:1059,Energy Efficiency,reduce,reduced,1059,"Now that we have an interface for fast on-the-fly reductions, it might make sense to implement a `KernelFunctionOperation` feature that accepts custom `kernel_function(i, j, k, grid, fields...)` so these can be reduced. (And in fact, this might also provide a replacement for `KernelComputedField`). Something like. ```julia; struct KernelFunctionOperation{LX, LY, LZ, P, A, G, T, K, D} <: AbstractOperation{LX, LY, LZ, A, G, T}; op :: K; grid :: G; architecture :: A; computed_dependencies :: D; parameters :: P; end. @inline Base.getindex(κ::KernelFunctionOperation, i, j, k) = κ.op(i, j, k, grid, κ.computed_dependencies..., κ.parameters}; @inline Base.getindex(κ::KernelFunctionOperation{LX, LY, LZ, <:Nothing}, i, j, k) where {LX, LY, LZ} = κ.op(i, j, k, grid, κ.computed_dependencies...}; ```. With an appropriate `compute!` (or `compute_at!`) method for ensuring that `computed_dependencies` get computed, this might be a better / leaner interface than the one provided by `KernelComputedField`, with the added, extremely useful benefit that it can be reduced on the fly just like other `AbstractOperation`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1623
https://github.com/CliMA/Oceananigans.jl/issues/1623:20,Integrability,interface,interface,20,"Now that we have an interface for fast on-the-fly reductions, it might make sense to implement a `KernelFunctionOperation` feature that accepts custom `kernel_function(i, j, k, grid, fields...)` so these can be reduced. (And in fact, this might also provide a replacement for `KernelComputedField`). Something like. ```julia; struct KernelFunctionOperation{LX, LY, LZ, P, A, G, T, K, D} <: AbstractOperation{LX, LY, LZ, A, G, T}; op :: K; grid :: G; architecture :: A; computed_dependencies :: D; parameters :: P; end. @inline Base.getindex(κ::KernelFunctionOperation, i, j, k) = κ.op(i, j, k, grid, κ.computed_dependencies..., κ.parameters}; @inline Base.getindex(κ::KernelFunctionOperation{LX, LY, LZ, <:Nothing}, i, j, k) where {LX, LY, LZ} = κ.op(i, j, k, grid, κ.computed_dependencies...}; ```. With an appropriate `compute!` (or `compute_at!`) method for ensuring that `computed_dependencies` get computed, this might be a better / leaner interface than the one provided by `KernelComputedField`, with the added, extremely useful benefit that it can be reduced on the fly just like other `AbstractOperation`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1623
https://github.com/CliMA/Oceananigans.jl/issues/1623:945,Integrability,interface,interface,945,"Now that we have an interface for fast on-the-fly reductions, it might make sense to implement a `KernelFunctionOperation` feature that accepts custom `kernel_function(i, j, k, grid, fields...)` so these can be reduced. (And in fact, this might also provide a replacement for `KernelComputedField`). Something like. ```julia; struct KernelFunctionOperation{LX, LY, LZ, P, A, G, T, K, D} <: AbstractOperation{LX, LY, LZ, A, G, T}; op :: K; grid :: G; architecture :: A; computed_dependencies :: D; parameters :: P; end. @inline Base.getindex(κ::KernelFunctionOperation, i, j, k) = κ.op(i, j, k, grid, κ.computed_dependencies..., κ.parameters}; @inline Base.getindex(κ::KernelFunctionOperation{LX, LY, LZ, <:Nothing}, i, j, k) where {LX, LY, LZ} = κ.op(i, j, k, grid, κ.computed_dependencies...}; ```. With an appropriate `compute!` (or `compute_at!`) method for ensuring that `computed_dependencies` get computed, this might be a better / leaner interface than the one provided by `KernelComputedField`, with the added, extremely useful benefit that it can be reduced on the fly just like other `AbstractOperation`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1623
https://github.com/CliMA/Oceananigans.jl/pull/1624:179,Testability,test,tested,179,"This pull request changes the compat entry for the `ArrayInterface` package from `= 3.1.6` to `= 3.1.6, 3.1`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1624
https://github.com/CliMA/Oceananigans.jl/pull/1624:284,Testability,test,tests,284,"This pull request changes the compat entry for the `ArrayInterface` package from `= 3.1.6` to `= 3.1.6, 3.1`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1624
https://github.com/CliMA/Oceananigans.jl/issues/1625:141,Availability,error,errors,141,"So, let me start by saying that I'm not 100% sure that this issue is an Oceananigans issue or not, but it did start a few weeks ago when the errors due to `ArrayInterface` started and the error only happens with Oceananigans. Also, the error happens in the server I use, but not on my laptop for some reason. Consider the following session on my laptop. Here I'm trying to make an environment as fresh as possible. (Which is why I'm creating a project from scratch and defining a new `DEPOT_PATH` that isn't `~/.julia`.). ```; (base) tomas@np900:~/Dropbox/tests$ mkdir julia_test; (base) tomas@np900:~/Dropbox/tests$ cd julia_test/; (base) tomas@np900:~/Dropbox/tests/julia_test$ touch Project.toml; (base) tomas@np900:~/Dropbox/tests/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (base) tomas@np900:~/Dropbox/tests/julia_test$ julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> sr; ERROR: Could not determine command. (julia_test) pkg> st; Status `~/Dropbox/tests/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `~/Dropbox/tests/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # LOTS OF THINGS HAPPEN THAT I'M SKIPPING. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625
https://github.com/CliMA/Oceananigans.jl/issues/1625:188,Availability,error,error,188,"So, let me start by saying that I'm not 100% sure that this issue is an Oceananigans issue or not, but it did start a few weeks ago when the errors due to `ArrayInterface` started and the error only happens with Oceananigans. Also, the error happens in the server I use, but not on my laptop for some reason. Consider the following session on my laptop. Here I'm trying to make an environment as fresh as possible. (Which is why I'm creating a project from scratch and defining a new `DEPOT_PATH` that isn't `~/.julia`.). ```; (base) tomas@np900:~/Dropbox/tests$ mkdir julia_test; (base) tomas@np900:~/Dropbox/tests$ cd julia_test/; (base) tomas@np900:~/Dropbox/tests/julia_test$ touch Project.toml; (base) tomas@np900:~/Dropbox/tests/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (base) tomas@np900:~/Dropbox/tests/julia_test$ julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> sr; ERROR: Could not determine command. (julia_test) pkg> st; Status `~/Dropbox/tests/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `~/Dropbox/tests/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # LOTS OF THINGS HAPPEN THAT I'M SKIPPING. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625
https://github.com/CliMA/Oceananigans.jl/issues/1625:236,Availability,error,error,236,"So, let me start by saying that I'm not 100% sure that this issue is an Oceananigans issue or not, but it did start a few weeks ago when the errors due to `ArrayInterface` started and the error only happens with Oceananigans. Also, the error happens in the server I use, but not on my laptop for some reason. Consider the following session on my laptop. Here I'm trying to make an environment as fresh as possible. (Which is why I'm creating a project from scratch and defining a new `DEPOT_PATH` that isn't `~/.julia`.). ```; (base) tomas@np900:~/Dropbox/tests$ mkdir julia_test; (base) tomas@np900:~/Dropbox/tests$ cd julia_test/; (base) tomas@np900:~/Dropbox/tests/julia_test$ touch Project.toml; (base) tomas@np900:~/Dropbox/tests/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (base) tomas@np900:~/Dropbox/tests/julia_test$ julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> sr; ERROR: Could not determine command. (julia_test) pkg> st; Status `~/Dropbox/tests/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `~/Dropbox/tests/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # LOTS OF THINGS HAPPEN THAT I'M SKIPPING. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625
https://github.com/CliMA/Oceananigans.jl/issues/1625:1154,Availability,ERROR,ERROR,1154,"yInterface` started and the error only happens with Oceananigans. Also, the error happens in the server I use, but not on my laptop for some reason. Consider the following session on my laptop. Here I'm trying to make an environment as fresh as possible. (Which is why I'm creating a project from scratch and defining a new `DEPOT_PATH` that isn't `~/.julia`.). ```; (base) tomas@np900:~/Dropbox/tests$ mkdir julia_test; (base) tomas@np900:~/Dropbox/tests$ cd julia_test/; (base) tomas@np900:~/Dropbox/tests/julia_test$ touch Project.toml; (base) tomas@np900:~/Dropbox/tests/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (base) tomas@np900:~/Dropbox/tests/julia_test$ julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> sr; ERROR: Could not determine command. (julia_test) pkg> st; Status `~/Dropbox/tests/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `~/Dropbox/tests/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # LOTS OF THINGS HAPPEN THAT I'M SKIPPING. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scratch_cheyenne$ cd julia_test/; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ touch Project.toml; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625
https://github.com/CliMA/Oceananigans.jl/issues/1625:1841,Availability,down,downloaded,1841,"oject; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> sr; ERROR: Could not determine command. (julia_test) pkg> st; Status `~/Dropbox/tests/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `~/Dropbox/tests/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # LOTS OF THINGS HAPPEN THAT I'M SKIPPING. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scratch_cheyenne$ cd julia_test/; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ touch Project.toml; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ ~/Downloads/julia-1.5.4/bin/julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> st; Status `/glade/scratch/tomasc/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `/glade/scratch/tomasc/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # THINGS HAPPEN HERE T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625
https://github.com/CliMA/Oceananigans.jl/issues/1625:2272,Availability,Down,Downloads,2272,"_test) pkg> st; Status `~/Dropbox/tests/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `~/Dropbox/tests/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # LOTS OF THINGS HAPPEN THAT I'M SKIPPING. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scratch_cheyenne$ cd julia_test/; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ touch Project.toml; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ ~/Downloads/julia-1.5.4/bin/julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> st; Status `/glade/scratch/tomasc/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `/glade/scratch/tomasc/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # THINGS HAPPEN HERE THAT I'LL SKIP. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. ```. The complete session is [here](https://pastebin.com/9frpW70Z). Everything here is pretty much same, with the only difference being that now the REPL hangs after `using Oce",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625
https://github.com/CliMA/Oceananigans.jl/issues/1625:1115,Deployability,release,release,1115,"w weeks ago when the errors due to `ArrayInterface` started and the error only happens with Oceananigans. Also, the error happens in the server I use, but not on my laptop for some reason. Consider the following session on my laptop. Here I'm trying to make an environment as fresh as possible. (Which is why I'm creating a project from scratch and defining a new `DEPOT_PATH` that isn't `~/.julia`.). ```; (base) tomas@np900:~/Dropbox/tests$ mkdir julia_test; (base) tomas@np900:~/Dropbox/tests$ cd julia_test/; (base) tomas@np900:~/Dropbox/tests/julia_test$ touch Project.toml; (base) tomas@np900:~/Dropbox/tests/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (base) tomas@np900:~/Dropbox/tests/julia_test$ julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> sr; ERROR: Could not determine command. (julia_test) pkg> st; Status `~/Dropbox/tests/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `~/Dropbox/tests/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # LOTS OF THINGS HAPPEN THAT I'M SKIPPING. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scratch_cheyenne$ cd julia_test/; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ touch Project.toml; (p39) tomasc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625
https://github.com/CliMA/Oceananigans.jl/issues/1625:2574,Deployability,release,release,2574,"e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scratch_cheyenne$ cd julia_test/; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ touch Project.toml; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ ~/Downloads/julia-1.5.4/bin/julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> st; Status `/glade/scratch/tomasc/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `/glade/scratch/tomasc/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # THINGS HAPPEN HERE THAT I'LL SKIP. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. ```. The complete session is [here](https://pastebin.com/9frpW70Z). Everything here is pretty much same, with the only difference being that now the REPL hangs after `using Oceananigans` and nothing happens. I have tested this with other packages but this only happens with Oceananigans. Something ever weirder: after I get impatient I can cancel the command (pressing `Ctrl+C` repeatedly) and then if I issue the line again it works!:. ```julia; julia> using Oceananigans; ^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C; ^C^C^C^CWARNING: Force throwing a SIGINT.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625
https://github.com/CliMA/Oceananigans.jl/issues/1625:556,Testability,test,tests,556,"So, let me start by saying that I'm not 100% sure that this issue is an Oceananigans issue or not, but it did start a few weeks ago when the errors due to `ArrayInterface` started and the error only happens with Oceananigans. Also, the error happens in the server I use, but not on my laptop for some reason. Consider the following session on my laptop. Here I'm trying to make an environment as fresh as possible. (Which is why I'm creating a project from scratch and defining a new `DEPOT_PATH` that isn't `~/.julia`.). ```; (base) tomas@np900:~/Dropbox/tests$ mkdir julia_test; (base) tomas@np900:~/Dropbox/tests$ cd julia_test/; (base) tomas@np900:~/Dropbox/tests/julia_test$ touch Project.toml; (base) tomas@np900:~/Dropbox/tests/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (base) tomas@np900:~/Dropbox/tests/julia_test$ julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> sr; ERROR: Could not determine command. (julia_test) pkg> st; Status `~/Dropbox/tests/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `~/Dropbox/tests/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # LOTS OF THINGS HAPPEN THAT I'M SKIPPING. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625
https://github.com/CliMA/Oceananigans.jl/issues/1625:610,Testability,test,tests,610,"So, let me start by saying that I'm not 100% sure that this issue is an Oceananigans issue or not, but it did start a few weeks ago when the errors due to `ArrayInterface` started and the error only happens with Oceananigans. Also, the error happens in the server I use, but not on my laptop for some reason. Consider the following session on my laptop. Here I'm trying to make an environment as fresh as possible. (Which is why I'm creating a project from scratch and defining a new `DEPOT_PATH` that isn't `~/.julia`.). ```; (base) tomas@np900:~/Dropbox/tests$ mkdir julia_test; (base) tomas@np900:~/Dropbox/tests$ cd julia_test/; (base) tomas@np900:~/Dropbox/tests/julia_test$ touch Project.toml; (base) tomas@np900:~/Dropbox/tests/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (base) tomas@np900:~/Dropbox/tests/julia_test$ julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> sr; ERROR: Could not determine command. (julia_test) pkg> st; Status `~/Dropbox/tests/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `~/Dropbox/tests/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # LOTS OF THINGS HAPPEN THAT I'M SKIPPING. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625
https://github.com/CliMA/Oceananigans.jl/issues/1625:662,Testability,test,tests,662,"So, let me start by saying that I'm not 100% sure that this issue is an Oceananigans issue or not, but it did start a few weeks ago when the errors due to `ArrayInterface` started and the error only happens with Oceananigans. Also, the error happens in the server I use, but not on my laptop for some reason. Consider the following session on my laptop. Here I'm trying to make an environment as fresh as possible. (Which is why I'm creating a project from scratch and defining a new `DEPOT_PATH` that isn't `~/.julia`.). ```; (base) tomas@np900:~/Dropbox/tests$ mkdir julia_test; (base) tomas@np900:~/Dropbox/tests$ cd julia_test/; (base) tomas@np900:~/Dropbox/tests/julia_test$ touch Project.toml; (base) tomas@np900:~/Dropbox/tests/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (base) tomas@np900:~/Dropbox/tests/julia_test$ julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> sr; ERROR: Could not determine command. (julia_test) pkg> st; Status `~/Dropbox/tests/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `~/Dropbox/tests/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # LOTS OF THINGS HAPPEN THAT I'M SKIPPING. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625
https://github.com/CliMA/Oceananigans.jl/issues/1625:729,Testability,test,tests,729,"So, let me start by saying that I'm not 100% sure that this issue is an Oceananigans issue or not, but it did start a few weeks ago when the errors due to `ArrayInterface` started and the error only happens with Oceananigans. Also, the error happens in the server I use, but not on my laptop for some reason. Consider the following session on my laptop. Here I'm trying to make an environment as fresh as possible. (Which is why I'm creating a project from scratch and defining a new `DEPOT_PATH` that isn't `~/.julia`.). ```; (base) tomas@np900:~/Dropbox/tests$ mkdir julia_test; (base) tomas@np900:~/Dropbox/tests$ cd julia_test/; (base) tomas@np900:~/Dropbox/tests/julia_test$ touch Project.toml; (base) tomas@np900:~/Dropbox/tests/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (base) tomas@np900:~/Dropbox/tests/julia_test$ julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> sr; ERROR: Could not determine command. (julia_test) pkg> st; Status `~/Dropbox/tests/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `~/Dropbox/tests/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # LOTS OF THINGS HAPPEN THAT I'M SKIPPING. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625
https://github.com/CliMA/Oceananigans.jl/issues/1625:821,Testability,test,tests,821,"So, let me start by saying that I'm not 100% sure that this issue is an Oceananigans issue or not, but it did start a few weeks ago when the errors due to `ArrayInterface` started and the error only happens with Oceananigans. Also, the error happens in the server I use, but not on my laptop for some reason. Consider the following session on my laptop. Here I'm trying to make an environment as fresh as possible. (Which is why I'm creating a project from scratch and defining a new `DEPOT_PATH` that isn't `~/.julia`.). ```; (base) tomas@np900:~/Dropbox/tests$ mkdir julia_test; (base) tomas@np900:~/Dropbox/tests$ cd julia_test/; (base) tomas@np900:~/Dropbox/tests/julia_test$ touch Project.toml; (base) tomas@np900:~/Dropbox/tests/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (base) tomas@np900:~/Dropbox/tests/julia_test$ julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> sr; ERROR: Could not determine command. (julia_test) pkg> st; Status `~/Dropbox/tests/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `~/Dropbox/tests/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # LOTS OF THINGS HAPPEN THAT I'M SKIPPING. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625
https://github.com/CliMA/Oceananigans.jl/issues/1625:1230,Testability,test,tests,1230,"ns. Also, the error happens in the server I use, but not on my laptop for some reason. Consider the following session on my laptop. Here I'm trying to make an environment as fresh as possible. (Which is why I'm creating a project from scratch and defining a new `DEPOT_PATH` that isn't `~/.julia`.). ```; (base) tomas@np900:~/Dropbox/tests$ mkdir julia_test; (base) tomas@np900:~/Dropbox/tests$ cd julia_test/; (base) tomas@np900:~/Dropbox/tests/julia_test$ touch Project.toml; (base) tomas@np900:~/Dropbox/tests/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (base) tomas@np900:~/Dropbox/tests/julia_test$ julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> sr; ERROR: Could not determine command. (julia_test) pkg> st; Status `~/Dropbox/tests/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `~/Dropbox/tests/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # LOTS OF THINGS HAPPEN THAT I'M SKIPPING. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scratch_cheyenne$ cd julia_test/; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ touch Project.toml; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (p39) toma",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625
https://github.com/CliMA/Oceananigans.jl/issues/1625:1329,Testability,test,tests,1329,"r the following session on my laptop. Here I'm trying to make an environment as fresh as possible. (Which is why I'm creating a project from scratch and defining a new `DEPOT_PATH` that isn't `~/.julia`.). ```; (base) tomas@np900:~/Dropbox/tests$ mkdir julia_test; (base) tomas@np900:~/Dropbox/tests$ cd julia_test/; (base) tomas@np900:~/Dropbox/tests/julia_test$ touch Project.toml; (base) tomas@np900:~/Dropbox/tests/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (base) tomas@np900:~/Dropbox/tests/julia_test$ julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> sr; ERROR: Could not determine command. (julia_test) pkg> st; Status `~/Dropbox/tests/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `~/Dropbox/tests/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # LOTS OF THINGS HAPPEN THAT I'M SKIPPING. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. julia> . ```. So basically this works as expected. You can see the complete output [here](https://pastebin.com/XwghaH7e). However, if I do that same thing on the server, I get the following. (Note that I'm even using a freshly downloaded Julia binary, to be as general as possible.). ```; (p39) tomasc@casper-login1:~/scratch_cheyenne$ mkdir julia_test; (p39) tomasc@casper-login1:~/scratch_cheyenne$ cd julia_test/; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ touch Project.toml; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ export JULIA_DEPOT_PATH=""`pwd`/julia_depot""; (p39) tomasc@casper-login1:~/scratch_cheyenne/julia_test$ ~/Downloads/julia-1.5.4/bin/julia --project; _",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625
https://github.com/CliMA/Oceananigans.jl/issues/1625:3236,Testability,test,tested,3236,"$ ~/Downloads/julia-1.5.4/bin/julia --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.5.4 (2021-03-11); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (julia_test) pkg> st; Status `/glade/scratch/tomasc/julia_test/Project.toml` (empty project). (julia_test) pkg> st --manifest; Status `/glade/scratch/tomasc/julia_test/Manifest.toml` (empty manifest). (julia_test) pkg> add Oceananigans. # THINGS HAPPEN HERE THAT I'LL SKIP. (julia_test) pkg> precompile; Precompiling project...; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. julia> using Oceananigans. ```. The complete session is [here](https://pastebin.com/9frpW70Z). Everything here is pretty much same, with the only difference being that now the REPL hangs after `using Oceananigans` and nothing happens. I have tested this with other packages but this only happens with Oceananigans. Something ever weirder: after I get impatient I can cancel the command (pressing `Ctrl+C` repeatedly) and then if I issue the line again it works!:. ```julia; julia> using Oceananigans; ^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C^C; ^C^C^C^CWARNING: Force throwing a SIGINT. julia> using Oceananigans. julia> grid = RegularRectilinearGrid(size=(1,1,1), extent=(1,1,1)); RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (1, 1, 1); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (1.0, 1.0, 1.0). julia> ; ```. So basically I'm very lost on this one. Two main questions are:. - Why is the `using` command hanging in the first place? (And then working if I cancel and try again?); - Why is the behavior different between these two machines? I thought I was ensuring that I was starting from a fresh environment in b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1625
https://github.com/CliMA/Oceananigans.jl/pull/1626:41,Security,validat,validation,41,This PR adds a few barotropic turbulence validation tests on `RegularLatitudeLongitudeGrid`. It also includes some miscellaneous improvements needed for these simulations:. * Bugfixes for `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` (missing functions + closure shenanigans to solve type inference issues); * Allows `TimeStepWizard` to accept user-defined `cell_advection_timescale` functions; * Implements `auxiliary_fields` computed during `update_state!` for `HydrostaticFreeSurfaceModel`. Here's where we are at:. https://user-images.githubusercontent.com/15271942/116346519-4ab5d000-a79f-11eb-8c7f-91281db0ff56.mp4,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1626
https://github.com/CliMA/Oceananigans.jl/pull/1626:52,Testability,test,tests,52,This PR adds a few barotropic turbulence validation tests on `RegularLatitudeLongitudeGrid`. It also includes some miscellaneous improvements needed for these simulations:. * Bugfixes for `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` (missing functions + closure shenanigans to solve type inference issues); * Allows `TimeStepWizard` to accept user-defined `cell_advection_timescale` functions; * Implements `auxiliary_fields` computed during `update_state!` for `HydrostaticFreeSurfaceModel`. Here's where we are at:. https://user-images.githubusercontent.com/15271942/116346519-4ab5d000-a79f-11eb-8c7f-91281db0ff56.mp4,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1626
https://github.com/CliMA/Oceananigans.jl/pull/1628:167,Testability,test,tested,167,"This pull request changes the compat entry for the `CUDA` package from `^1, ^2` to `^1, ^2, 3.1`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1628
https://github.com/CliMA/Oceananigans.jl/pull/1628:272,Testability,test,tests,272,"This pull request changes the compat entry for the `CUDA` package from `^1, ^2` to `^1, ^2, 3.1`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1628
https://github.com/CliMA/Oceananigans.jl/issues/1630:190,Testability,test,test,190,"In `test_dynamics.jl`, an experiment is set up with inhomogeneous boundary conditions on temperature:. https://github.com/CliMA/Oceananigans.jl/blob/f83fce8c9b7f7fde41247be700d544720537dd35/test/test_dynamics.jl#L310-L312. while using `closure = nothing`:. https://github.com/CliMA/Oceananigans.jl/blob/f83fce8c9b7f7fde41247be700d544720537dd35/test/test_dynamics.jl#L314-L321. This is at best misleading --- with `closure = nothing`, boundary conditions are not enforced. It may also be innocuous though, because there is no diffusive flux _anywhere_ -- not only across boundaries. It may in fact make sense to throw a warning when using `closure = nothing` with non-default boundary conditions (""Boundary conditions are not enforced when `isnothing(closure)`"").",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1630
https://github.com/CliMA/Oceananigans.jl/issues/1630:344,Testability,test,test,344,"In `test_dynamics.jl`, an experiment is set up with inhomogeneous boundary conditions on temperature:. https://github.com/CliMA/Oceananigans.jl/blob/f83fce8c9b7f7fde41247be700d544720537dd35/test/test_dynamics.jl#L310-L312. while using `closure = nothing`:. https://github.com/CliMA/Oceananigans.jl/blob/f83fce8c9b7f7fde41247be700d544720537dd35/test/test_dynamics.jl#L314-L321. This is at best misleading --- with `closure = nothing`, boundary conditions are not enforced. It may also be innocuous though, because there is no diffusive flux _anywhere_ -- not only across boundaries. It may in fact make sense to throw a warning when using `closure = nothing` with non-default boundary conditions (""Boundary conditions are not enforced when `isnothing(closure)`"").",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1630
https://github.com/CliMA/Oceananigans.jl/pull/1631:40,Testability,test,test,40,Resolves #1629 . TODO:. - [x] Perhaps a test?; - [x] OK from @ali-ramadhan that we bypass compute_and_slice_output for `LagrangianParticles`. cc @tomchor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1631
https://github.com/CliMA/Oceananigans.jl/issues/1634:616,Deployability,update,updated,616,"This is motivated by the small discussion on the slack channel and my own experiences last week trying to run some of the code there. Apparently the scripts in the `validation/` directory are not included in CI (probably because they would take too long?), but it would still be nice if they were kept up-to-date with the master branch. @glwagner mentioned the possibility of running occasional CIs specific for validation. An alternative solution might be creating a different package on github just for the validation scripts. I noticed that JuliaRegistrator creates a new PR every time one of the dependencies is updated. So, by having Oceanigans as a dependency, this process would be made automatic by that and we'd only need to update the PRs if the tests failed. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634
https://github.com/CliMA/Oceananigans.jl/issues/1634:734,Deployability,update,update,734,"This is motivated by the small discussion on the slack channel and my own experiences last week trying to run some of the code there. Apparently the scripts in the `validation/` directory are not included in CI (probably because they would take too long?), but it would still be nice if they were kept up-to-date with the master branch. @glwagner mentioned the possibility of running occasional CIs specific for validation. An alternative solution might be creating a different package on github just for the validation scripts. I noticed that JuliaRegistrator creates a new PR every time one of the dependencies is updated. So, by having Oceanigans as a dependency, this process would be made automatic by that and we'd only need to update the PRs if the tests failed. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634
https://github.com/CliMA/Oceananigans.jl/issues/1634:600,Integrability,depend,dependencies,600,"This is motivated by the small discussion on the slack channel and my own experiences last week trying to run some of the code there. Apparently the scripts in the `validation/` directory are not included in CI (probably because they would take too long?), but it would still be nice if they were kept up-to-date with the master branch. @glwagner mentioned the possibility of running occasional CIs specific for validation. An alternative solution might be creating a different package on github just for the validation scripts. I noticed that JuliaRegistrator creates a new PR every time one of the dependencies is updated. So, by having Oceanigans as a dependency, this process would be made automatic by that and we'd only need to update the PRs if the tests failed. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634
https://github.com/CliMA/Oceananigans.jl/issues/1634:655,Integrability,depend,dependency,655,"This is motivated by the small discussion on the slack channel and my own experiences last week trying to run some of the code there. Apparently the scripts in the `validation/` directory are not included in CI (probably because they would take too long?), but it would still be nice if they were kept up-to-date with the master branch. @glwagner mentioned the possibility of running occasional CIs specific for validation. An alternative solution might be creating a different package on github just for the validation scripts. I noticed that JuliaRegistrator creates a new PR every time one of the dependencies is updated. So, by having Oceanigans as a dependency, this process would be made automatic by that and we'd only need to update the PRs if the tests failed. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634
https://github.com/CliMA/Oceananigans.jl/issues/1634:165,Security,validat,validation,165,"This is motivated by the small discussion on the slack channel and my own experiences last week trying to run some of the code there. Apparently the scripts in the `validation/` directory are not included in CI (probably because they would take too long?), but it would still be nice if they were kept up-to-date with the master branch. @glwagner mentioned the possibility of running occasional CIs specific for validation. An alternative solution might be creating a different package on github just for the validation scripts. I noticed that JuliaRegistrator creates a new PR every time one of the dependencies is updated. So, by having Oceanigans as a dependency, this process would be made automatic by that and we'd only need to update the PRs if the tests failed. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634
https://github.com/CliMA/Oceananigans.jl/issues/1634:412,Security,validat,validation,412,"This is motivated by the small discussion on the slack channel and my own experiences last week trying to run some of the code there. Apparently the scripts in the `validation/` directory are not included in CI (probably because they would take too long?), but it would still be nice if they were kept up-to-date with the master branch. @glwagner mentioned the possibility of running occasional CIs specific for validation. An alternative solution might be creating a different package on github just for the validation scripts. I noticed that JuliaRegistrator creates a new PR every time one of the dependencies is updated. So, by having Oceanigans as a dependency, this process would be made automatic by that and we'd only need to update the PRs if the tests failed. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634
https://github.com/CliMA/Oceananigans.jl/issues/1634:509,Security,validat,validation,509,"This is motivated by the small discussion on the slack channel and my own experiences last week trying to run some of the code there. Apparently the scripts in the `validation/` directory are not included in CI (probably because they would take too long?), but it would still be nice if they were kept up-to-date with the master branch. @glwagner mentioned the possibility of running occasional CIs specific for validation. An alternative solution might be creating a different package on github just for the validation scripts. I noticed that JuliaRegistrator creates a new PR every time one of the dependencies is updated. So, by having Oceanigans as a dependency, this process would be made automatic by that and we'd only need to update the PRs if the tests failed. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634
https://github.com/CliMA/Oceananigans.jl/issues/1634:756,Testability,test,tests,756,"This is motivated by the small discussion on the slack channel and my own experiences last week trying to run some of the code there. Apparently the scripts in the `validation/` directory are not included in CI (probably because they would take too long?), but it would still be nice if they were kept up-to-date with the master branch. @glwagner mentioned the possibility of running occasional CIs specific for validation. An alternative solution might be creating a different package on github just for the validation scripts. I noticed that JuliaRegistrator creates a new PR every time one of the dependencies is updated. So, by having Oceanigans as a dependency, this process would be made automatic by that and we'd only need to update the PRs if the tests failed. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1634
https://github.com/CliMA/Oceananigans.jl/issues/1635:25,Availability,error,error,25,"Hello, I am getting this error while trying to add Oceananigans on the NASA Pleiade cluster. Any ideas? Thanks a lot ! Lia. (@v1.6) pkg> update Oceananigans; Updating registry at `~/.julia/registries/General`; Installed HDF5_jll ─── v1.10.5+7; Installed ColorTypes ─ v0.11.0; Installed HTTP ─────── v0.9.8; Installed HDF5 ─────── v0.13.7; Installed URIs ─────── v1.3.0; Downloaded artifact: HDF5; No Changes to `~/.julia/environments/v1.6/Project.toml`; Updating `~/.julia/environments/v1.6/Manifest.toml`; [3da002f7] ↑ ColorTypes v0.10.12 ⇒ v0.11.0; [f67ccb44] ↑ HDF5 v0.13.6 ⇒ v0.13.7; [cd3eb016] ↑ HTTP v0.8.19 ⇒ v0.9.8; [5c2747f8] + URIs v1.3.0; [0234f1f7] ↓ HDF5_jll v1.12.0+1 ⇒ v1.10.5+7; Building HDF5 → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/0b812e7872e2199a5a04944f486b4048944f1ed8/build.log`; Precompiling project...; ✗ Oceananigans; 15 dependencies successfully precompiled in 101 seconds (143 already precompiled); 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1635
https://github.com/CliMA/Oceananigans.jl/issues/1635:370,Availability,Down,Downloaded,370,"Hello, I am getting this error while trying to add Oceananigans on the NASA Pleiade cluster. Any ideas? Thanks a lot ! Lia. (@v1.6) pkg> update Oceananigans; Updating registry at `~/.julia/registries/General`; Installed HDF5_jll ─── v1.10.5+7; Installed ColorTypes ─ v0.11.0; Installed HTTP ─────── v0.9.8; Installed HDF5 ─────── v0.13.7; Installed URIs ─────── v1.3.0; Downloaded artifact: HDF5; No Changes to `~/.julia/environments/v1.6/Project.toml`; Updating `~/.julia/environments/v1.6/Manifest.toml`; [3da002f7] ↑ ColorTypes v0.10.12 ⇒ v0.11.0; [f67ccb44] ↑ HDF5 v0.13.6 ⇒ v0.13.7; [cd3eb016] ↑ HTTP v0.8.19 ⇒ v0.9.8; [5c2747f8] + URIs v1.3.0; [0234f1f7] ↓ HDF5_jll v1.12.0+1 ⇒ v1.10.5+7; Building HDF5 → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/0b812e7872e2199a5a04944f486b4048944f1ed8/build.log`; Precompiling project...; ✗ Oceananigans; 15 dependencies successfully precompiled in 101 seconds (143 already precompiled); 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1635
https://github.com/CliMA/Oceananigans.jl/issues/1635:962,Availability,error,errored,962,"Hello, I am getting this error while trying to add Oceananigans on the NASA Pleiade cluster. Any ideas? Thanks a lot ! Lia. (@v1.6) pkg> update Oceananigans; Updating registry at `~/.julia/registries/General`; Installed HDF5_jll ─── v1.10.5+7; Installed ColorTypes ─ v0.11.0; Installed HTTP ─────── v0.9.8; Installed HDF5 ─────── v0.13.7; Installed URIs ─────── v1.3.0; Downloaded artifact: HDF5; No Changes to `~/.julia/environments/v1.6/Project.toml`; Updating `~/.julia/environments/v1.6/Manifest.toml`; [3da002f7] ↑ ColorTypes v0.10.12 ⇒ v0.11.0; [f67ccb44] ↑ HDF5 v0.13.6 ⇒ v0.13.7; [cd3eb016] ↑ HTTP v0.8.19 ⇒ v0.9.8; [5c2747f8] + URIs v1.3.0; [0234f1f7] ↓ HDF5_jll v1.12.0+1 ⇒ v1.10.5+7; Building HDF5 → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/0b812e7872e2199a5a04944f486b4048944f1ed8/build.log`; Precompiling project...; ✗ Oceananigans; 15 dependencies successfully precompiled in 101 seconds (143 already precompiled); 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1635
https://github.com/CliMA/Oceananigans.jl/issues/1635:137,Deployability,update,update,137,"Hello, I am getting this error while trying to add Oceananigans on the NASA Pleiade cluster. Any ideas? Thanks a lot ! Lia. (@v1.6) pkg> update Oceananigans; Updating registry at `~/.julia/registries/General`; Installed HDF5_jll ─── v1.10.5+7; Installed ColorTypes ─ v0.11.0; Installed HTTP ─────── v0.9.8; Installed HDF5 ─────── v0.13.7; Installed URIs ─────── v1.3.0; Downloaded artifact: HDF5; No Changes to `~/.julia/environments/v1.6/Project.toml`; Updating `~/.julia/environments/v1.6/Manifest.toml`; [3da002f7] ↑ ColorTypes v0.10.12 ⇒ v0.11.0; [f67ccb44] ↑ HDF5 v0.13.6 ⇒ v0.13.7; [cd3eb016] ↑ HTTP v0.8.19 ⇒ v0.9.8; [5c2747f8] + URIs v1.3.0; [0234f1f7] ↓ HDF5_jll v1.12.0+1 ⇒ v1.10.5+7; Building HDF5 → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/0b812e7872e2199a5a04944f486b4048944f1ed8/build.log`; Precompiling project...; ✗ Oceananigans; 15 dependencies successfully precompiled in 101 seconds (143 already precompiled); 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1635
https://github.com/CliMA/Oceananigans.jl/issues/1635:210,Deployability,Install,Installed,210,"Hello, I am getting this error while trying to add Oceananigans on the NASA Pleiade cluster. Any ideas? Thanks a lot ! Lia. (@v1.6) pkg> update Oceananigans; Updating registry at `~/.julia/registries/General`; Installed HDF5_jll ─── v1.10.5+7; Installed ColorTypes ─ v0.11.0; Installed HTTP ─────── v0.9.8; Installed HDF5 ─────── v0.13.7; Installed URIs ─────── v1.3.0; Downloaded artifact: HDF5; No Changes to `~/.julia/environments/v1.6/Project.toml`; Updating `~/.julia/environments/v1.6/Manifest.toml`; [3da002f7] ↑ ColorTypes v0.10.12 ⇒ v0.11.0; [f67ccb44] ↑ HDF5 v0.13.6 ⇒ v0.13.7; [cd3eb016] ↑ HTTP v0.8.19 ⇒ v0.9.8; [5c2747f8] + URIs v1.3.0; [0234f1f7] ↓ HDF5_jll v1.12.0+1 ⇒ v1.10.5+7; Building HDF5 → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/0b812e7872e2199a5a04944f486b4048944f1ed8/build.log`; Precompiling project...; ✗ Oceananigans; 15 dependencies successfully precompiled in 101 seconds (143 already precompiled); 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1635
https://github.com/CliMA/Oceananigans.jl/issues/1635:244,Deployability,Install,Installed,244,"Hello, I am getting this error while trying to add Oceananigans on the NASA Pleiade cluster. Any ideas? Thanks a lot ! Lia. (@v1.6) pkg> update Oceananigans; Updating registry at `~/.julia/registries/General`; Installed HDF5_jll ─── v1.10.5+7; Installed ColorTypes ─ v0.11.0; Installed HTTP ─────── v0.9.8; Installed HDF5 ─────── v0.13.7; Installed URIs ─────── v1.3.0; Downloaded artifact: HDF5; No Changes to `~/.julia/environments/v1.6/Project.toml`; Updating `~/.julia/environments/v1.6/Manifest.toml`; [3da002f7] ↑ ColorTypes v0.10.12 ⇒ v0.11.0; [f67ccb44] ↑ HDF5 v0.13.6 ⇒ v0.13.7; [cd3eb016] ↑ HTTP v0.8.19 ⇒ v0.9.8; [5c2747f8] + URIs v1.3.0; [0234f1f7] ↓ HDF5_jll v1.12.0+1 ⇒ v1.10.5+7; Building HDF5 → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/0b812e7872e2199a5a04944f486b4048944f1ed8/build.log`; Precompiling project...; ✗ Oceananigans; 15 dependencies successfully precompiled in 101 seconds (143 already precompiled); 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1635
https://github.com/CliMA/Oceananigans.jl/issues/1635:276,Deployability,Install,Installed,276,"Hello, I am getting this error while trying to add Oceananigans on the NASA Pleiade cluster. Any ideas? Thanks a lot ! Lia. (@v1.6) pkg> update Oceananigans; Updating registry at `~/.julia/registries/General`; Installed HDF5_jll ─── v1.10.5+7; Installed ColorTypes ─ v0.11.0; Installed HTTP ─────── v0.9.8; Installed HDF5 ─────── v0.13.7; Installed URIs ─────── v1.3.0; Downloaded artifact: HDF5; No Changes to `~/.julia/environments/v1.6/Project.toml`; Updating `~/.julia/environments/v1.6/Manifest.toml`; [3da002f7] ↑ ColorTypes v0.10.12 ⇒ v0.11.0; [f67ccb44] ↑ HDF5 v0.13.6 ⇒ v0.13.7; [cd3eb016] ↑ HTTP v0.8.19 ⇒ v0.9.8; [5c2747f8] + URIs v1.3.0; [0234f1f7] ↓ HDF5_jll v1.12.0+1 ⇒ v1.10.5+7; Building HDF5 → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/0b812e7872e2199a5a04944f486b4048944f1ed8/build.log`; Precompiling project...; ✗ Oceananigans; 15 dependencies successfully precompiled in 101 seconds (143 already precompiled); 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1635
https://github.com/CliMA/Oceananigans.jl/issues/1635:307,Deployability,Install,Installed,307,"Hello, I am getting this error while trying to add Oceananigans on the NASA Pleiade cluster. Any ideas? Thanks a lot ! Lia. (@v1.6) pkg> update Oceananigans; Updating registry at `~/.julia/registries/General`; Installed HDF5_jll ─── v1.10.5+7; Installed ColorTypes ─ v0.11.0; Installed HTTP ─────── v0.9.8; Installed HDF5 ─────── v0.13.7; Installed URIs ─────── v1.3.0; Downloaded artifact: HDF5; No Changes to `~/.julia/environments/v1.6/Project.toml`; Updating `~/.julia/environments/v1.6/Manifest.toml`; [3da002f7] ↑ ColorTypes v0.10.12 ⇒ v0.11.0; [f67ccb44] ↑ HDF5 v0.13.6 ⇒ v0.13.7; [cd3eb016] ↑ HTTP v0.8.19 ⇒ v0.9.8; [5c2747f8] + URIs v1.3.0; [0234f1f7] ↓ HDF5_jll v1.12.0+1 ⇒ v1.10.5+7; Building HDF5 → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/0b812e7872e2199a5a04944f486b4048944f1ed8/build.log`; Precompiling project...; ✗ Oceananigans; 15 dependencies successfully precompiled in 101 seconds (143 already precompiled); 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1635
https://github.com/CliMA/Oceananigans.jl/issues/1635:339,Deployability,Install,Installed,339,"Hello, I am getting this error while trying to add Oceananigans on the NASA Pleiade cluster. Any ideas? Thanks a lot ! Lia. (@v1.6) pkg> update Oceananigans; Updating registry at `~/.julia/registries/General`; Installed HDF5_jll ─── v1.10.5+7; Installed ColorTypes ─ v0.11.0; Installed HTTP ─────── v0.9.8; Installed HDF5 ─────── v0.13.7; Installed URIs ─────── v1.3.0; Downloaded artifact: HDF5; No Changes to `~/.julia/environments/v1.6/Project.toml`; Updating `~/.julia/environments/v1.6/Manifest.toml`; [3da002f7] ↑ ColorTypes v0.10.12 ⇒ v0.11.0; [f67ccb44] ↑ HDF5 v0.13.6 ⇒ v0.13.7; [cd3eb016] ↑ HTTP v0.8.19 ⇒ v0.9.8; [5c2747f8] + URIs v1.3.0; [0234f1f7] ↓ HDF5_jll v1.12.0+1 ⇒ v1.10.5+7; Building HDF5 → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/0b812e7872e2199a5a04944f486b4048944f1ed8/build.log`; Precompiling project...; ✗ Oceananigans; 15 dependencies successfully precompiled in 101 seconds (143 already precompiled); 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1635
https://github.com/CliMA/Oceananigans.jl/issues/1635:869,Integrability,depend,dependencies,869,"Hello, I am getting this error while trying to add Oceananigans on the NASA Pleiade cluster. Any ideas? Thanks a lot ! Lia. (@v1.6) pkg> update Oceananigans; Updating registry at `~/.julia/registries/General`; Installed HDF5_jll ─── v1.10.5+7; Installed ColorTypes ─ v0.11.0; Installed HTTP ─────── v0.9.8; Installed HDF5 ─────── v0.13.7; Installed URIs ─────── v1.3.0; Downloaded artifact: HDF5; No Changes to `~/.julia/environments/v1.6/Project.toml`; Updating `~/.julia/environments/v1.6/Manifest.toml`; [3da002f7] ↑ ColorTypes v0.10.12 ⇒ v0.11.0; [f67ccb44] ↑ HDF5 v0.13.6 ⇒ v0.13.7; [cd3eb016] ↑ HTTP v0.8.19 ⇒ v0.9.8; [5c2747f8] + URIs v1.3.0; [0234f1f7] ↓ HDF5_jll v1.12.0+1 ⇒ v1.10.5+7; Building HDF5 → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/0b812e7872e2199a5a04944f486b4048944f1ed8/build.log`; Precompiling project...; ✗ Oceananigans; 15 dependencies successfully precompiled in 101 seconds (143 already precompiled); 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1635
https://github.com/CliMA/Oceananigans.jl/issues/1635:951,Integrability,depend,dependency,951,"Hello, I am getting this error while trying to add Oceananigans on the NASA Pleiade cluster. Any ideas? Thanks a lot ! Lia. (@v1.6) pkg> update Oceananigans; Updating registry at `~/.julia/registries/General`; Installed HDF5_jll ─── v1.10.5+7; Installed ColorTypes ─ v0.11.0; Installed HTTP ─────── v0.9.8; Installed HDF5 ─────── v0.13.7; Installed URIs ─────── v1.3.0; Downloaded artifact: HDF5; No Changes to `~/.julia/environments/v1.6/Project.toml`; Updating `~/.julia/environments/v1.6/Manifest.toml`; [3da002f7] ↑ ColorTypes v0.10.12 ⇒ v0.11.0; [f67ccb44] ↑ HDF5 v0.13.6 ⇒ v0.13.7; [cd3eb016] ↑ HTTP v0.8.19 ⇒ v0.9.8; [5c2747f8] + URIs v1.3.0; [0234f1f7] ↓ HDF5_jll v1.12.0+1 ⇒ v1.10.5+7; Building HDF5 → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/0b812e7872e2199a5a04944f486b4048944f1ed8/build.log`; Precompiling project...; ✗ Oceananigans; 15 dependencies successfully precompiled in 101 seconds (143 already precompiled); 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1635
https://github.com/CliMA/Oceananigans.jl/issues/1635:1037,Performance,load,load,1037,"Hello, I am getting this error while trying to add Oceananigans on the NASA Pleiade cluster. Any ideas? Thanks a lot ! Lia. (@v1.6) pkg> update Oceananigans; Updating registry at `~/.julia/registries/General`; Installed HDF5_jll ─── v1.10.5+7; Installed ColorTypes ─ v0.11.0; Installed HTTP ─────── v0.9.8; Installed HDF5 ─────── v0.13.7; Installed URIs ─────── v1.3.0; Downloaded artifact: HDF5; No Changes to `~/.julia/environments/v1.6/Project.toml`; Updating `~/.julia/environments/v1.6/Manifest.toml`; [3da002f7] ↑ ColorTypes v0.10.12 ⇒ v0.11.0; [f67ccb44] ↑ HDF5 v0.13.6 ⇒ v0.13.7; [cd3eb016] ↑ HTTP v0.8.19 ⇒ v0.9.8; [5c2747f8] + URIs v1.3.0; [0234f1f7] ↓ HDF5_jll v1.12.0+1 ⇒ v1.10.5+7; Building HDF5 → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/0b812e7872e2199a5a04944f486b4048944f1ed8/build.log`; Precompiling project...; ✗ Oceananigans; 15 dependencies successfully precompiled in 101 seconds (143 already precompiled); 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1635
https://github.com/CliMA/Oceananigans.jl/issues/1635:819,Testability,log,log,819,"Hello, I am getting this error while trying to add Oceananigans on the NASA Pleiade cluster. Any ideas? Thanks a lot ! Lia. (@v1.6) pkg> update Oceananigans; Updating registry at `~/.julia/registries/General`; Installed HDF5_jll ─── v1.10.5+7; Installed ColorTypes ─ v0.11.0; Installed HTTP ─────── v0.9.8; Installed HDF5 ─────── v0.13.7; Installed URIs ─────── v1.3.0; Downloaded artifact: HDF5; No Changes to `~/.julia/environments/v1.6/Project.toml`; Updating `~/.julia/environments/v1.6/Manifest.toml`; [3da002f7] ↑ ColorTypes v0.10.12 ⇒ v0.11.0; [f67ccb44] ↑ HDF5 v0.13.6 ⇒ v0.13.7; [cd3eb016] ↑ HTTP v0.8.19 ⇒ v0.9.8; [5c2747f8] + URIs v1.3.0; [0234f1f7] ↓ HDF5_jll v1.12.0+1 ⇒ v1.10.5+7; Building HDF5 → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/0b812e7872e2199a5a04944f486b4048944f1ed8/build.log`; Precompiling project...; ✗ Oceananigans; 15 dependencies successfully precompiled in 101 seconds (143 already precompiled); 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1635
https://github.com/CliMA/Oceananigans.jl/issues/1637:20,Availability,error,error,20,On GPU it throws an error regarding CUDA scalar operations.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1637
https://github.com/CliMA/Oceananigans.jl/pull/1638:234,Availability,error,errors,234,"This PR uses a view into the underlying array of grid spacings rather than a view into the OffsetArray of grid spacings in `Base.show` for `VerticallyStretchedRectilinearGrid`. This should allow `maximum` and `minimum` to run without errors and allow `VerticallyStretchedRectilinearGrid` to be printed on the GPU. Would be best to add a test, cc @navidcy. Closes #1637 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1638
https://github.com/CliMA/Oceananigans.jl/pull/1638:337,Testability,test,test,337,"This PR uses a view into the underlying array of grid spacings rather than a view into the OffsetArray of grid spacings in `Base.show` for `VerticallyStretchedRectilinearGrid`. This should allow `maximum` and `minimum` to run without errors and allow `VerticallyStretchedRectilinearGrid` to be printed on the GPU. Would be best to add a test, cc @navidcy. Closes #1637 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1638
https://github.com/CliMA/Oceananigans.jl/pull/1639:44,Deployability,integrat,integration,44,"This PR implements vertically-implicit time integration for tracers and momentum. We restrict attention to the `HydrostaticFreeSurfaceModel` and quasi-Adams-Bashforth time integration. This requires some refactoring of function-calling in `TurbulenceClosures` some upgrades to `BatchedTridiagonalSolver`, and changes to `ab2_step!(model::HydrostaticFreeSurfaceModel, dt)`. At first we will only support vertically implicit diffusion for `HorizontallyCurvilinearAnisotropicDiffusivity`. However, `TurbulenceClosures` has been extensively refactored to permit quick extension of vertically-implicit time-stepping to `IsotropicDiffusivity`, `AnisotropicDiffusivity`, and LES closures. ~~There are a few questions to answer before implementing implicit time-stepping there that we should discuss in issues.~~ It should be straightforward enough to implement vertically implicit time stepping for these closures and test them with existing regression tests. To construct a model that steps forward the vertical component of `HorizontallyCurvilinearAnisotropicDiffusivity` implicitly, we introduce the syntax. ```julia; ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()); ```. The default `time_discretization` is `ExplicitTimeDiscretization`. The constructor for `HydrostaticFreeSurfaceModel` handles constructing a `VerticallyImplicitDiffusionSolver` when implicit time discretization is specified. This script:. ```julia; using Plots; using Printf; using Oceananigans; using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization, time_discretization. grid = RegularRectilinearGrid(size=128, z=(-0.5, 0.5), topology=(Flat, Flat, Bounded)). evd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0); ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()). model_kwargs = (grid=grid, tracers=:c, buoyancy=nothing, velocit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639
https://github.com/CliMA/Oceananigans.jl/pull/1639:172,Deployability,integrat,integration,172,"This PR implements vertically-implicit time integration for tracers and momentum. We restrict attention to the `HydrostaticFreeSurfaceModel` and quasi-Adams-Bashforth time integration. This requires some refactoring of function-calling in `TurbulenceClosures` some upgrades to `BatchedTridiagonalSolver`, and changes to `ab2_step!(model::HydrostaticFreeSurfaceModel, dt)`. At first we will only support vertically implicit diffusion for `HorizontallyCurvilinearAnisotropicDiffusivity`. However, `TurbulenceClosures` has been extensively refactored to permit quick extension of vertically-implicit time-stepping to `IsotropicDiffusivity`, `AnisotropicDiffusivity`, and LES closures. ~~There are a few questions to answer before implementing implicit time-stepping there that we should discuss in issues.~~ It should be straightforward enough to implement vertically implicit time stepping for these closures and test them with existing regression tests. To construct a model that steps forward the vertical component of `HorizontallyCurvilinearAnisotropicDiffusivity` implicitly, we introduce the syntax. ```julia; ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()); ```. The default `time_discretization` is `ExplicitTimeDiscretization`. The constructor for `HydrostaticFreeSurfaceModel` handles constructing a `VerticallyImplicitDiffusionSolver` when implicit time discretization is specified. This script:. ```julia; using Plots; using Printf; using Oceananigans; using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization, time_discretization. grid = RegularRectilinearGrid(size=128, z=(-0.5, 0.5), topology=(Flat, Flat, Bounded)). evd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0); ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()). model_kwargs = (grid=grid, tracers=:c, buoyancy=nothing, velocit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639
https://github.com/CliMA/Oceananigans.jl/pull/1639:265,Deployability,upgrade,upgrades,265,"This PR implements vertically-implicit time integration for tracers and momentum. We restrict attention to the `HydrostaticFreeSurfaceModel` and quasi-Adams-Bashforth time integration. This requires some refactoring of function-calling in `TurbulenceClosures` some upgrades to `BatchedTridiagonalSolver`, and changes to `ab2_step!(model::HydrostaticFreeSurfaceModel, dt)`. At first we will only support vertically implicit diffusion for `HorizontallyCurvilinearAnisotropicDiffusivity`. However, `TurbulenceClosures` has been extensively refactored to permit quick extension of vertically-implicit time-stepping to `IsotropicDiffusivity`, `AnisotropicDiffusivity`, and LES closures. ~~There are a few questions to answer before implementing implicit time-stepping there that we should discuss in issues.~~ It should be straightforward enough to implement vertically implicit time stepping for these closures and test them with existing regression tests. To construct a model that steps forward the vertical component of `HorizontallyCurvilinearAnisotropicDiffusivity` implicitly, we introduce the syntax. ```julia; ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()); ```. The default `time_discretization` is `ExplicitTimeDiscretization`. The constructor for `HydrostaticFreeSurfaceModel` handles constructing a `VerticallyImplicitDiffusionSolver` when implicit time discretization is specified. This script:. ```julia; using Plots; using Printf; using Oceananigans; using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization, time_discretization. grid = RegularRectilinearGrid(size=128, z=(-0.5, 0.5), topology=(Flat, Flat, Bounded)). evd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0); ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()). model_kwargs = (grid=grid, tracers=:c, buoyancy=nothing, velocit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639
https://github.com/CliMA/Oceananigans.jl/pull/1639:44,Integrability,integrat,integration,44,"This PR implements vertically-implicit time integration for tracers and momentum. We restrict attention to the `HydrostaticFreeSurfaceModel` and quasi-Adams-Bashforth time integration. This requires some refactoring of function-calling in `TurbulenceClosures` some upgrades to `BatchedTridiagonalSolver`, and changes to `ab2_step!(model::HydrostaticFreeSurfaceModel, dt)`. At first we will only support vertically implicit diffusion for `HorizontallyCurvilinearAnisotropicDiffusivity`. However, `TurbulenceClosures` has been extensively refactored to permit quick extension of vertically-implicit time-stepping to `IsotropicDiffusivity`, `AnisotropicDiffusivity`, and LES closures. ~~There are a few questions to answer before implementing implicit time-stepping there that we should discuss in issues.~~ It should be straightforward enough to implement vertically implicit time stepping for these closures and test them with existing regression tests. To construct a model that steps forward the vertical component of `HorizontallyCurvilinearAnisotropicDiffusivity` implicitly, we introduce the syntax. ```julia; ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()); ```. The default `time_discretization` is `ExplicitTimeDiscretization`. The constructor for `HydrostaticFreeSurfaceModel` handles constructing a `VerticallyImplicitDiffusionSolver` when implicit time discretization is specified. This script:. ```julia; using Plots; using Printf; using Oceananigans; using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization, time_discretization. grid = RegularRectilinearGrid(size=128, z=(-0.5, 0.5), topology=(Flat, Flat, Bounded)). evd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0); ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()). model_kwargs = (grid=grid, tracers=:c, buoyancy=nothing, velocit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639
https://github.com/CliMA/Oceananigans.jl/pull/1639:172,Integrability,integrat,integration,172,"This PR implements vertically-implicit time integration for tracers and momentum. We restrict attention to the `HydrostaticFreeSurfaceModel` and quasi-Adams-Bashforth time integration. This requires some refactoring of function-calling in `TurbulenceClosures` some upgrades to `BatchedTridiagonalSolver`, and changes to `ab2_step!(model::HydrostaticFreeSurfaceModel, dt)`. At first we will only support vertically implicit diffusion for `HorizontallyCurvilinearAnisotropicDiffusivity`. However, `TurbulenceClosures` has been extensively refactored to permit quick extension of vertically-implicit time-stepping to `IsotropicDiffusivity`, `AnisotropicDiffusivity`, and LES closures. ~~There are a few questions to answer before implementing implicit time-stepping there that we should discuss in issues.~~ It should be straightforward enough to implement vertically implicit time stepping for these closures and test them with existing regression tests. To construct a model that steps forward the vertical component of `HorizontallyCurvilinearAnisotropicDiffusivity` implicitly, we introduce the syntax. ```julia; ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()); ```. The default `time_discretization` is `ExplicitTimeDiscretization`. The constructor for `HydrostaticFreeSurfaceModel` handles constructing a `VerticallyImplicitDiffusionSolver` when implicit time discretization is specified. This script:. ```julia; using Plots; using Printf; using Oceananigans; using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization, time_discretization. grid = RegularRectilinearGrid(size=128, z=(-0.5, 0.5), topology=(Flat, Flat, Bounded)). evd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0); ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()). model_kwargs = (grid=grid, tracers=:c, buoyancy=nothing, velocit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639
https://github.com/CliMA/Oceananigans.jl/pull/1639:204,Modifiability,refactor,refactoring,204,"This PR implements vertically-implicit time integration for tracers and momentum. We restrict attention to the `HydrostaticFreeSurfaceModel` and quasi-Adams-Bashforth time integration. This requires some refactoring of function-calling in `TurbulenceClosures` some upgrades to `BatchedTridiagonalSolver`, and changes to `ab2_step!(model::HydrostaticFreeSurfaceModel, dt)`. At first we will only support vertically implicit diffusion for `HorizontallyCurvilinearAnisotropicDiffusivity`. However, `TurbulenceClosures` has been extensively refactored to permit quick extension of vertically-implicit time-stepping to `IsotropicDiffusivity`, `AnisotropicDiffusivity`, and LES closures. ~~There are a few questions to answer before implementing implicit time-stepping there that we should discuss in issues.~~ It should be straightforward enough to implement vertically implicit time stepping for these closures and test them with existing regression tests. To construct a model that steps forward the vertical component of `HorizontallyCurvilinearAnisotropicDiffusivity` implicitly, we introduce the syntax. ```julia; ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()); ```. The default `time_discretization` is `ExplicitTimeDiscretization`. The constructor for `HydrostaticFreeSurfaceModel` handles constructing a `VerticallyImplicitDiffusionSolver` when implicit time discretization is specified. This script:. ```julia; using Plots; using Printf; using Oceananigans; using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization, time_discretization. grid = RegularRectilinearGrid(size=128, z=(-0.5, 0.5), topology=(Flat, Flat, Bounded)). evd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0); ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()). model_kwargs = (grid=grid, tracers=:c, buoyancy=nothing, velocit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639
https://github.com/CliMA/Oceananigans.jl/pull/1639:537,Modifiability,refactor,refactored,537,"This PR implements vertically-implicit time integration for tracers and momentum. We restrict attention to the `HydrostaticFreeSurfaceModel` and quasi-Adams-Bashforth time integration. This requires some refactoring of function-calling in `TurbulenceClosures` some upgrades to `BatchedTridiagonalSolver`, and changes to `ab2_step!(model::HydrostaticFreeSurfaceModel, dt)`. At first we will only support vertically implicit diffusion for `HorizontallyCurvilinearAnisotropicDiffusivity`. However, `TurbulenceClosures` has been extensively refactored to permit quick extension of vertically-implicit time-stepping to `IsotropicDiffusivity`, `AnisotropicDiffusivity`, and LES closures. ~~There are a few questions to answer before implementing implicit time-stepping there that we should discuss in issues.~~ It should be straightforward enough to implement vertically implicit time stepping for these closures and test them with existing regression tests. To construct a model that steps forward the vertical component of `HorizontallyCurvilinearAnisotropicDiffusivity` implicitly, we introduce the syntax. ```julia; ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()); ```. The default `time_discretization` is `ExplicitTimeDiscretization`. The constructor for `HydrostaticFreeSurfaceModel` handles constructing a `VerticallyImplicitDiffusionSolver` when implicit time discretization is specified. This script:. ```julia; using Plots; using Printf; using Oceananigans; using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization, time_discretization. grid = RegularRectilinearGrid(size=128, z=(-0.5, 0.5), topology=(Flat, Flat, Bounded)). evd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0); ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()). model_kwargs = (grid=grid, tracers=:c, buoyancy=nothing, velocit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639
https://github.com/CliMA/Oceananigans.jl/pull/1639:3643,Modifiability,extend,extends,3643,"odel = HydrostaticFreeSurfaceModel(; closure=ivd_closure, model_kwargs...); explicit_model = HydrostaticFreeSurfaceModel(; closure=evd_closure, model_kwargs...); models = (implicit_model, explicit_model); ; initial_temperature(x, y, z) = exp(-z^2 / 0.02). [set!(model, c=initial_temperature) for model in models]. z = znodes(implicit_model.tracers.c). c_implicit = view(interior(implicit_model.tracers.c), 1, 1, :); c_explicit = view(interior(explicit_model.tracers.c), 1, 1, :). c_plot = plot(c_implicit, z, linewidth = 2, label = ""t = 0"", xlabel = ""Tracer concentration"", ylabel = ""z""); ; diffusion_time_scale = implicit_model.grid.Δz^2 / implicit_model.closure.κz.c; stop_time = 100diffusion_time_scale. simulations = [Simulation(explicit_model, Δt = 1e-1 * diffusion_time_scale, stop_time = stop_time),; Simulation(implicit_model, Δt = 1e0 * diffusion_time_scale, stop_time = stop_time)]. [run!(simulation) for simulation in simulations]. plot!(c_plot, c_implicit, z, linewidth = 3, alpha = 0.6, label = @sprintf(""implicit model, t = %.3e"", model.clock.time)); plot!(c_plot, c_explicit, z, linewidth = 2, linestyle = :dash, label = @sprintf(""explicit model, t = %.3e"", model.clock.time)). display(c_plot); ```. produces. <img width=""1392"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117589924-a6f2eb00-b0e1-11eb-87a2-fb51a4eacc85.png"">. Note that with implicit treatment of the diffusion term we can use a time step comparable to the diffusion time-scale. The same time-step with explicit time discretization leads to model blow up. ~~Future~~ This PR ~~will hopefully~~ extends functionality to other closures and also to `IncompressibleModel` and the RK3 time-stepper. In the process of cleaning up TurbulenceClosures I am also resolving a few other issues, such as an incorrect formulation of viscous fluxes for `IsotropicDiffusivity` and the semi-random default viscosity and thermal diffusivities that we've been using. Resolves #1278; Resolves #1643 ; Resolves #1644",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639
https://github.com/CliMA/Oceananigans.jl/pull/1639:911,Testability,test,test,911,"This PR implements vertically-implicit time integration for tracers and momentum. We restrict attention to the `HydrostaticFreeSurfaceModel` and quasi-Adams-Bashforth time integration. This requires some refactoring of function-calling in `TurbulenceClosures` some upgrades to `BatchedTridiagonalSolver`, and changes to `ab2_step!(model::HydrostaticFreeSurfaceModel, dt)`. At first we will only support vertically implicit diffusion for `HorizontallyCurvilinearAnisotropicDiffusivity`. However, `TurbulenceClosures` has been extensively refactored to permit quick extension of vertically-implicit time-stepping to `IsotropicDiffusivity`, `AnisotropicDiffusivity`, and LES closures. ~~There are a few questions to answer before implementing implicit time-stepping there that we should discuss in issues.~~ It should be straightforward enough to implement vertically implicit time stepping for these closures and test them with existing regression tests. To construct a model that steps forward the vertical component of `HorizontallyCurvilinearAnisotropicDiffusivity` implicitly, we introduce the syntax. ```julia; ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()); ```. The default `time_discretization` is `ExplicitTimeDiscretization`. The constructor for `HydrostaticFreeSurfaceModel` handles constructing a `VerticallyImplicitDiffusionSolver` when implicit time discretization is specified. This script:. ```julia; using Plots; using Printf; using Oceananigans; using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization, time_discretization. grid = RegularRectilinearGrid(size=128, z=(-0.5, 0.5), topology=(Flat, Flat, Bounded)). evd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0); ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()). model_kwargs = (grid=grid, tracers=:c, buoyancy=nothing, velocit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639
https://github.com/CliMA/Oceananigans.jl/pull/1639:946,Testability,test,tests,946,"This PR implements vertically-implicit time integration for tracers and momentum. We restrict attention to the `HydrostaticFreeSurfaceModel` and quasi-Adams-Bashforth time integration. This requires some refactoring of function-calling in `TurbulenceClosures` some upgrades to `BatchedTridiagonalSolver`, and changes to `ab2_step!(model::HydrostaticFreeSurfaceModel, dt)`. At first we will only support vertically implicit diffusion for `HorizontallyCurvilinearAnisotropicDiffusivity`. However, `TurbulenceClosures` has been extensively refactored to permit quick extension of vertically-implicit time-stepping to `IsotropicDiffusivity`, `AnisotropicDiffusivity`, and LES closures. ~~There are a few questions to answer before implementing implicit time-stepping there that we should discuss in issues.~~ It should be straightforward enough to implement vertically implicit time stepping for these closures and test them with existing regression tests. To construct a model that steps forward the vertical component of `HorizontallyCurvilinearAnisotropicDiffusivity` implicitly, we introduce the syntax. ```julia; ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()); ```. The default `time_discretization` is `ExplicitTimeDiscretization`. The constructor for `HydrostaticFreeSurfaceModel` handles constructing a `VerticallyImplicitDiffusionSolver` when implicit time discretization is specified. This script:. ```julia; using Plots; using Printf; using Oceananigans; using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization, time_discretization. grid = RegularRectilinearGrid(size=128, z=(-0.5, 0.5), topology=(Flat, Flat, Bounded)). evd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0); ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()). model_kwargs = (grid=grid, tracers=:c, buoyancy=nothing, velocit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639
https://github.com/CliMA/Oceananigans.jl/pull/1640:104,Energy Efficiency,Reduce,ReducedField,104,"This will allow us to support 4 dimensional fields. PS: do we actually need `AbstractReducedField` and `ReducedField`? We can infer the `dims` property (dimensions over which a field is reduced) from the locations, and don't need to store it...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1640
https://github.com/CliMA/Oceananigans.jl/pull/1640:186,Energy Efficiency,reduce,reduced,186,"This will allow us to support 4 dimensional fields. PS: do we actually need `AbstractReducedField` and `ReducedField`? We can infer the `dims` property (dimensions over which a field is reduced) from the locations, and don't need to store it...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1640
https://github.com/CliMA/Oceananigans.jl/pull/1641:324,Performance,load,loaded,324,"This PR is a first stab at tackling #1493. It adds a `FieldTimeSeries` type that stores a time series of an entire field taken from a JLD2 file and a `FieldDataset` function that stores all the fields from a JLD2 file in a `Dict{String,FieldTimeSeries}`. There are two flavors: `FieldTimeSeries{InMemory}` where the data is loaded fully into memory into a 4D array, and `FieldTimeSeries{OnDisk}` which lazily loads different time snapshots from disk. Indexing linearly into a `FieldTimeSeries` returns a `Field`. Immediate TODO:; - [x] Test `architecture = GPU()`. Right now it's pretty barebones. Some more work on `Oceananigans.Fields` might be needed before we get a fully-featured `FieldTimeSeries`. Eventually it would be great to be able to be able to:; 1. Have `FieldTimeSeries` work with abstract operations like it was a `Field` broadcasting over time.; 2. Work with `FieldTimeSeries` as if it were a 4D array (with operations ignoring the halos).; 2. Have named dimensions, slick selectors, and references dimensions through DimensionalData.jl. Some things to think about:; 1. Since the aim is to work with abstract operations, `FieldTimeSeries` right now only work with JLD2 data that includes halos. Do we want to support loading data without halos?; 2. Do we want `FieldTimeSeries` to support reading from NetCDF? If the answer to (1) is yes then this shouldn't be hard to support.; 3. Right now function boundary conditions are lost in serialization. We should probably allow users to specify boundary conditions on `FieldTimeSeries`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1641
https://github.com/CliMA/Oceananigans.jl/pull/1641:409,Performance,load,loads,409,"This PR is a first stab at tackling #1493. It adds a `FieldTimeSeries` type that stores a time series of an entire field taken from a JLD2 file and a `FieldDataset` function that stores all the fields from a JLD2 file in a `Dict{String,FieldTimeSeries}`. There are two flavors: `FieldTimeSeries{InMemory}` where the data is loaded fully into memory into a 4D array, and `FieldTimeSeries{OnDisk}` which lazily loads different time snapshots from disk. Indexing linearly into a `FieldTimeSeries` returns a `Field`. Immediate TODO:; - [x] Test `architecture = GPU()`. Right now it's pretty barebones. Some more work on `Oceananigans.Fields` might be needed before we get a fully-featured `FieldTimeSeries`. Eventually it would be great to be able to be able to:; 1. Have `FieldTimeSeries` work with abstract operations like it was a `Field` broadcasting over time.; 2. Work with `FieldTimeSeries` as if it were a 4D array (with operations ignoring the halos).; 2. Have named dimensions, slick selectors, and references dimensions through DimensionalData.jl. Some things to think about:; 1. Since the aim is to work with abstract operations, `FieldTimeSeries` right now only work with JLD2 data that includes halos. Do we want to support loading data without halos?; 2. Do we want `FieldTimeSeries` to support reading from NetCDF? If the answer to (1) is yes then this shouldn't be hard to support.; 3. Right now function boundary conditions are lost in serialization. We should probably allow users to specify boundary conditions on `FieldTimeSeries`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1641
https://github.com/CliMA/Oceananigans.jl/pull/1641:1234,Performance,load,loading,1234,"This PR is a first stab at tackling #1493. It adds a `FieldTimeSeries` type that stores a time series of an entire field taken from a JLD2 file and a `FieldDataset` function that stores all the fields from a JLD2 file in a `Dict{String,FieldTimeSeries}`. There are two flavors: `FieldTimeSeries{InMemory}` where the data is loaded fully into memory into a 4D array, and `FieldTimeSeries{OnDisk}` which lazily loads different time snapshots from disk. Indexing linearly into a `FieldTimeSeries` returns a `Field`. Immediate TODO:; - [x] Test `architecture = GPU()`. Right now it's pretty barebones. Some more work on `Oceananigans.Fields` might be needed before we get a fully-featured `FieldTimeSeries`. Eventually it would be great to be able to be able to:; 1. Have `FieldTimeSeries` work with abstract operations like it was a `Field` broadcasting over time.; 2. Work with `FieldTimeSeries` as if it were a 4D array (with operations ignoring the halos).; 2. Have named dimensions, slick selectors, and references dimensions through DimensionalData.jl. Some things to think about:; 1. Since the aim is to work with abstract operations, `FieldTimeSeries` right now only work with JLD2 data that includes halos. Do we want to support loading data without halos?; 2. Do we want `FieldTimeSeries` to support reading from NetCDF? If the answer to (1) is yes then this shouldn't be hard to support.; 3. Right now function boundary conditions are lost in serialization. We should probably allow users to specify boundary conditions on `FieldTimeSeries`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1641
https://github.com/CliMA/Oceananigans.jl/pull/1641:536,Testability,Test,Test,536,"This PR is a first stab at tackling #1493. It adds a `FieldTimeSeries` type that stores a time series of an entire field taken from a JLD2 file and a `FieldDataset` function that stores all the fields from a JLD2 file in a `Dict{String,FieldTimeSeries}`. There are two flavors: `FieldTimeSeries{InMemory}` where the data is loaded fully into memory into a 4D array, and `FieldTimeSeries{OnDisk}` which lazily loads different time snapshots from disk. Indexing linearly into a `FieldTimeSeries` returns a `Field`. Immediate TODO:; - [x] Test `architecture = GPU()`. Right now it's pretty barebones. Some more work on `Oceananigans.Fields` might be needed before we get a fully-featured `FieldTimeSeries`. Eventually it would be great to be able to be able to:; 1. Have `FieldTimeSeries` work with abstract operations like it was a `Field` broadcasting over time.; 2. Work with `FieldTimeSeries` as if it were a 4D array (with operations ignoring the halos).; 2. Have named dimensions, slick selectors, and references dimensions through DimensionalData.jl. Some things to think about:; 1. Since the aim is to work with abstract operations, `FieldTimeSeries` right now only work with JLD2 data that includes halos. Do we want to support loading data without halos?; 2. Do we want `FieldTimeSeries` to support reading from NetCDF? If the answer to (1) is yes then this shouldn't be hard to support.; 3. Right now function boundary conditions are lost in serialization. We should probably allow users to specify boundary conditions on `FieldTimeSeries`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1641
https://github.com/CliMA/Oceananigans.jl/issues/1643:533,Availability,down,downshifted,533,"I suspect that the docstring for the `BatchedTridiagonalSolver`,. https://github.com/CliMA/Oceananigans.jl/blob/60c2278aafc536f0cd6b086ccd606bc6755e6e5e/src/Solvers/batched_tridiagonal_solver.jl#L17-L23. is incorrect. The docstring suggests that `c` (the upper diagonal) is indexed from `k=2` to `k=Nz`; however it is actually indexed from `k=1` to `k=Nz-1`:. https://github.com/CliMA/Oceananigans.jl/blob/60c2278aafc536f0cd6b086ccd606bc6755e6e5e/src/Solvers/batched_tridiagonal_solver.jl#L82-L84. In the above code the `c` index is downshifted by 1, so that, if I am interpreting the algorithm correctly, the docstring should read:. ```; b(i, j, 1)ϕ(i, j, 1) + c(i, j, 1)ϕ(i, j, 2) = f(i, j, 1), k = 1; a(i, j, k-1)ϕ(i, j, k-1) + b(i, j, k)ϕ(i, j, k) + c(i, j, k)ϕ(i, j, k+1) = f(i, j, k), k = 2, ..., N-1; a(i, j, N-1)ϕ(i, j, N-1) + b(i, j, N)ϕ(i, j, N) = f(i, j, N), k = N; ```. This is also consistent with the tests, which use arrays of length `Nz-1` for both `a` and `c`. If `c` were indexed in the way implied by the docstring, the `c` array would either have to be length `Nz` or have a `k` index that's offset by 1. The indexing convention that's _implemented_ (rather than the one implied by the docstring) matches constructor interface for the matrix type `Tridiagonal`, which is convenient for testing against solutions produced by julia's built-in `\` operator. However, it means that function inputs need to shift indices by 1 compared to what most would consider ""intuitive"" (that the index of the coefficient `c` matches the index of the solution element `ϕ` that it multiplies).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1643
https://github.com/CliMA/Oceananigans.jl/issues/1643:1237,Integrability,interface,interface,1237,"I suspect that the docstring for the `BatchedTridiagonalSolver`,. https://github.com/CliMA/Oceananigans.jl/blob/60c2278aafc536f0cd6b086ccd606bc6755e6e5e/src/Solvers/batched_tridiagonal_solver.jl#L17-L23. is incorrect. The docstring suggests that `c` (the upper diagonal) is indexed from `k=2` to `k=Nz`; however it is actually indexed from `k=1` to `k=Nz-1`:. https://github.com/CliMA/Oceananigans.jl/blob/60c2278aafc536f0cd6b086ccd606bc6755e6e5e/src/Solvers/batched_tridiagonal_solver.jl#L82-L84. In the above code the `c` index is downshifted by 1, so that, if I am interpreting the algorithm correctly, the docstring should read:. ```; b(i, j, 1)ϕ(i, j, 1) + c(i, j, 1)ϕ(i, j, 2) = f(i, j, 1), k = 1; a(i, j, k-1)ϕ(i, j, k-1) + b(i, j, k)ϕ(i, j, k) + c(i, j, k)ϕ(i, j, k+1) = f(i, j, k), k = 2, ..., N-1; a(i, j, N-1)ϕ(i, j, N-1) + b(i, j, N)ϕ(i, j, N) = f(i, j, N), k = N; ```. This is also consistent with the tests, which use arrays of length `Nz-1` for both `a` and `c`. If `c` were indexed in the way implied by the docstring, the `c` array would either have to be length `Nz` or have a `k` index that's offset by 1. The indexing convention that's _implemented_ (rather than the one implied by the docstring) matches constructor interface for the matrix type `Tridiagonal`, which is convenient for testing against solutions produced by julia's built-in `\` operator. However, it means that function inputs need to shift indices by 1 compared to what most would consider ""intuitive"" (that the index of the coefficient `c` matches the index of the solution element `ϕ` that it multiplies).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1643
https://github.com/CliMA/Oceananigans.jl/issues/1643:915,Testability,test,tests,915,"I suspect that the docstring for the `BatchedTridiagonalSolver`,. https://github.com/CliMA/Oceananigans.jl/blob/60c2278aafc536f0cd6b086ccd606bc6755e6e5e/src/Solvers/batched_tridiagonal_solver.jl#L17-L23. is incorrect. The docstring suggests that `c` (the upper diagonal) is indexed from `k=2` to `k=Nz`; however it is actually indexed from `k=1` to `k=Nz-1`:. https://github.com/CliMA/Oceananigans.jl/blob/60c2278aafc536f0cd6b086ccd606bc6755e6e5e/src/Solvers/batched_tridiagonal_solver.jl#L82-L84. In the above code the `c` index is downshifted by 1, so that, if I am interpreting the algorithm correctly, the docstring should read:. ```; b(i, j, 1)ϕ(i, j, 1) + c(i, j, 1)ϕ(i, j, 2) = f(i, j, 1), k = 1; a(i, j, k-1)ϕ(i, j, k-1) + b(i, j, k)ϕ(i, j, k) + c(i, j, k)ϕ(i, j, k+1) = f(i, j, k), k = 2, ..., N-1; a(i, j, N-1)ϕ(i, j, N-1) + b(i, j, N)ϕ(i, j, N) = f(i, j, N), k = N; ```. This is also consistent with the tests, which use arrays of length `Nz-1` for both `a` and `c`. If `c` were indexed in the way implied by the docstring, the `c` array would either have to be length `Nz` or have a `k` index that's offset by 1. The indexing convention that's _implemented_ (rather than the one implied by the docstring) matches constructor interface for the matrix type `Tridiagonal`, which is convenient for testing against solutions produced by julia's built-in `\` operator. However, it means that function inputs need to shift indices by 1 compared to what most would consider ""intuitive"" (that the index of the coefficient `c` matches the index of the solution element `ϕ` that it multiplies).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1643
https://github.com/CliMA/Oceananigans.jl/issues/1643:1306,Testability,test,testing,1306,"I suspect that the docstring for the `BatchedTridiagonalSolver`,. https://github.com/CliMA/Oceananigans.jl/blob/60c2278aafc536f0cd6b086ccd606bc6755e6e5e/src/Solvers/batched_tridiagonal_solver.jl#L17-L23. is incorrect. The docstring suggests that `c` (the upper diagonal) is indexed from `k=2` to `k=Nz`; however it is actually indexed from `k=1` to `k=Nz-1`:. https://github.com/CliMA/Oceananigans.jl/blob/60c2278aafc536f0cd6b086ccd606bc6755e6e5e/src/Solvers/batched_tridiagonal_solver.jl#L82-L84. In the above code the `c` index is downshifted by 1, so that, if I am interpreting the algorithm correctly, the docstring should read:. ```; b(i, j, 1)ϕ(i, j, 1) + c(i, j, 1)ϕ(i, j, 2) = f(i, j, 1), k = 1; a(i, j, k-1)ϕ(i, j, k-1) + b(i, j, k)ϕ(i, j, k) + c(i, j, k)ϕ(i, j, k+1) = f(i, j, k), k = 2, ..., N-1; a(i, j, N-1)ϕ(i, j, N-1) + b(i, j, N)ϕ(i, j, N) = f(i, j, N), k = N; ```. This is also consistent with the tests, which use arrays of length `Nz-1` for both `a` and `c`. If `c` were indexed in the way implied by the docstring, the `c` array would either have to be length `Nz` or have a `k` index that's offset by 1. The indexing convention that's _implemented_ (rather than the one implied by the docstring) matches constructor interface for the matrix type `Tridiagonal`, which is convenient for testing against solutions produced by julia's built-in `\` operator. However, it means that function inputs need to shift indices by 1 compared to what most would consider ""intuitive"" (that the index of the coefficient `c` matches the index of the solution element `ϕ` that it multiplies).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1643
https://github.com/CliMA/Oceananigans.jl/issues/1643:1479,Usability,intuit,intuitive,1479,"I suspect that the docstring for the `BatchedTridiagonalSolver`,. https://github.com/CliMA/Oceananigans.jl/blob/60c2278aafc536f0cd6b086ccd606bc6755e6e5e/src/Solvers/batched_tridiagonal_solver.jl#L17-L23. is incorrect. The docstring suggests that `c` (the upper diagonal) is indexed from `k=2` to `k=Nz`; however it is actually indexed from `k=1` to `k=Nz-1`:. https://github.com/CliMA/Oceananigans.jl/blob/60c2278aafc536f0cd6b086ccd606bc6755e6e5e/src/Solvers/batched_tridiagonal_solver.jl#L82-L84. In the above code the `c` index is downshifted by 1, so that, if I am interpreting the algorithm correctly, the docstring should read:. ```; b(i, j, 1)ϕ(i, j, 1) + c(i, j, 1)ϕ(i, j, 2) = f(i, j, 1), k = 1; a(i, j, k-1)ϕ(i, j, k-1) + b(i, j, k)ϕ(i, j, k) + c(i, j, k)ϕ(i, j, k+1) = f(i, j, k), k = 2, ..., N-1; a(i, j, N-1)ϕ(i, j, N-1) + b(i, j, N)ϕ(i, j, N) = f(i, j, N), k = N; ```. This is also consistent with the tests, which use arrays of length `Nz-1` for both `a` and `c`. If `c` were indexed in the way implied by the docstring, the `c` array would either have to be length `Nz` or have a `k` index that's offset by 1. The indexing convention that's _implemented_ (rather than the one implied by the docstring) matches constructor interface for the matrix type `Tridiagonal`, which is convenient for testing against solutions produced by julia's built-in `\` operator. However, it means that function inputs need to shift indices by 1 compared to what most would consider ""intuitive"" (that the index of the coefficient `c` matches the index of the solution element `ϕ` that it multiplies).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1643
https://github.com/CliMA/Oceananigans.jl/pull/1645:167,Testability,test,tested,167,"This pull request changes the compat entry for the `CUDA` package from `^1, ^2` to `^1, ^2, 3.2`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1645
https://github.com/CliMA/Oceananigans.jl/pull/1645:272,Testability,test,tests,272,"This pull request changes the compat entry for the `CUDA` package from `^1, ^2` to `^1, ^2, 3.2`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1645
https://github.com/CliMA/Oceananigans.jl/issues/1647:324,Integrability,wrap,wrapped,324,"It might be pretty nice to support syntax like `interior(f::AbstractField, i, j, k)` that returns `view(parent(f), i′, j′, k′)`, where `i′, j′, k′` are offset to account for the halo regions. One reason this is useful is because `view(f.data, i, j, k)` is a _doubly-wrapped_ array (it's a view of an `OffsetArray`, which is wrapped around either `Array` or `CuArray`) and therefore cannot be used in broadcasting, reductions, etc on the GPU. cc @mukund-gupta",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1647
https://github.com/CliMA/Oceananigans.jl/pull/1648:1090,Security,validat,validate,1090,"This PR creates a new script that computes the convergence rates for all of the advection schemes and plots them together in one figure, which is doing what #1276 tried to do. The output is a figure and the following:; ```; Results are for the L1-norm:. Method = CenteredSecondOrder(), Rate of Convergence = 1.99, Expected = 2; Method = UpwindBiasedThirdOrder(), Rate of Convergence = 2.99, Expected = 3; Method = CenteredFourthOrder(), Rate of Convergence = 3.98, Expected = 4; Method = UpwindBiasedFifthOrder(), Rate of Convergence = 4.97, Expected = 5; Method = WENO5(), Rate of Convergence = 5.00, Expected = 5; ``` . ![convergence_rates](https://user-images.githubusercontent.com/8239041/117871837-dcc3db00-b26b-11eb-9307-0156e84714ee.png). The rates are very, very close to the theory. Questions:. - Can someone help me align the output so that Rate of Convergence appears in the same location?; - Any suggestions on how to improve the plot?; - I needed to add Polynomials to do this. Any problems with adding this to the Manifest?. Next Steps:. @ali-ramadhan suggested using this to validate new advection schemes, and I think it's a good idea. Things we could do next include,. - [ ] First order upwinding; - [ ] Sixth order center differencing; - [ ] Nth-order WENO",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1648
https://github.com/CliMA/Oceananigans.jl/pull/1649:352,Energy Efficiency,adapt,adapting,352,"Previously, `getindex` for `Nothing` locations was specified to `AbstractReducedField`. This PR extends these functions to apply to `AbstractDataField`. The effect of this is limited because `Field`s are still entirely ""unwrapped"" within kernels, meaning that we lose their location data. If/when we are able to preserve location data for `Field` when adapting to the `GPU`, we may not need `ReducedField` or `AbstractReducedField` any longer -- we can instead use `Nothing` locations to indicate that a field is reduced along a particular direction.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1649
https://github.com/CliMA/Oceananigans.jl/pull/1649:392,Energy Efficiency,Reduce,ReducedField,392,"Previously, `getindex` for `Nothing` locations was specified to `AbstractReducedField`. This PR extends these functions to apply to `AbstractDataField`. The effect of this is limited because `Field`s are still entirely ""unwrapped"" within kernels, meaning that we lose their location data. If/when we are able to preserve location data for `Field` when adapting to the `GPU`, we may not need `ReducedField` or `AbstractReducedField` any longer -- we can instead use `Nothing` locations to indicate that a field is reduced along a particular direction.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1649
https://github.com/CliMA/Oceananigans.jl/pull/1649:513,Energy Efficiency,reduce,reduced,513,"Previously, `getindex` for `Nothing` locations was specified to `AbstractReducedField`. This PR extends these functions to apply to `AbstractDataField`. The effect of this is limited because `Field`s are still entirely ""unwrapped"" within kernels, meaning that we lose their location data. If/when we are able to preserve location data for `Field` when adapting to the `GPU`, we may not need `ReducedField` or `AbstractReducedField` any longer -- we can instead use `Nothing` locations to indicate that a field is reduced along a particular direction.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1649
https://github.com/CliMA/Oceananigans.jl/pull/1649:96,Modifiability,extend,extends,96,"Previously, `getindex` for `Nothing` locations was specified to `AbstractReducedField`. This PR extends these functions to apply to `AbstractDataField`. The effect of this is limited because `Field`s are still entirely ""unwrapped"" within kernels, meaning that we lose their location data. If/when we are able to preserve location data for `Field` when adapting to the `GPU`, we may not need `ReducedField` or `AbstractReducedField` any longer -- we can instead use `Nothing` locations to indicate that a field is reduced along a particular direction.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1649
https://github.com/CliMA/Oceananigans.jl/pull/1649:352,Modifiability,adapt,adapting,352,"Previously, `getindex` for `Nothing` locations was specified to `AbstractReducedField`. This PR extends these functions to apply to `AbstractDataField`. The effect of this is limited because `Field`s are still entirely ""unwrapped"" within kernels, meaning that we lose their location data. If/when we are able to preserve location data for `Field` when adapting to the `GPU`, we may not need `ReducedField` or `AbstractReducedField` any longer -- we can instead use `Nothing` locations to indicate that a field is reduced along a particular direction.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1649
https://github.com/CliMA/Oceananigans.jl/pull/1654:468,Availability,Mask,Masking,468,"This PR implements a primitive immersed boundary scheme that is ""fitted"" to the grid. The scheme is specified with a function of `(x, y, z)` that is true when ""solid"" and false when ""fluid"". (A better name for the model kwarg than `immersed_boundary` might be `immersed_solid`.) It only supports no flux boundary conditions, but it should be ""relatively"" straightforward to support user specified flux boundary conditions. The scheme has the following ingredients:. * Masking of solid cells to 0 for both velocities and tracers.; * Elides diffusive fluxes across solid boundaries with an explicit `ifelse` embedded in diffusive flux and viscous flux functions. Because of the second point the scheme is ""invasive"" in that it requires the immersed boundary to be inserted into the tendency calculation. On the upside, it is likely cheap since it doesn't require any extra loops (except for the masking). EDIT: the implementation in this PR is _very_ invasive in that it introduces a grid wrapper that implements the immersed boundary functionality. Grid wrappers make the implementation of more sophisticated immersed boundary methods such as partial cell and shaved cells much easier. To support user-specified fluxes, we'd have to distinguish between a `solid_node` and a `fluid_solid_boundary_node`, and drop in the user-specified flux when appropriate. There's a primitive validation test in `validation/immersed_boundary/immersed_hydrostatic_diffusion.jl` that produces this plot:. <img width=""587"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117931760-0dc40000-b2ac-11eb-8978-2c376d706948.png"">. I'm not sure how the immersed boundary will interact with the free surface, so we'd have to test that. In order to implement this scheme in `IncompressibleModel`, we'll have to get rid of the existing implementation. It's also unclear how accurate either this or the previous approximation is without modification of the pressure solver algorithm. I think to merge this we nee",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654
https://github.com/CliMA/Oceananigans.jl/pull/1654:893,Availability,mask,masking,893,"This PR implements a primitive immersed boundary scheme that is ""fitted"" to the grid. The scheme is specified with a function of `(x, y, z)` that is true when ""solid"" and false when ""fluid"". (A better name for the model kwarg than `immersed_boundary` might be `immersed_solid`.) It only supports no flux boundary conditions, but it should be ""relatively"" straightforward to support user specified flux boundary conditions. The scheme has the following ingredients:. * Masking of solid cells to 0 for both velocities and tracers.; * Elides diffusive fluxes across solid boundaries with an explicit `ifelse` embedded in diffusive flux and viscous flux functions. Because of the second point the scheme is ""invasive"" in that it requires the immersed boundary to be inserted into the tendency calculation. On the upside, it is likely cheap since it doesn't require any extra loops (except for the masking). EDIT: the implementation in this PR is _very_ invasive in that it introduces a grid wrapper that implements the immersed boundary functionality. Grid wrappers make the implementation of more sophisticated immersed boundary methods such as partial cell and shaved cells much easier. To support user-specified fluxes, we'd have to distinguish between a `solid_node` and a `fluid_solid_boundary_node`, and drop in the user-specified flux when appropriate. There's a primitive validation test in `validation/immersed_boundary/immersed_hydrostatic_diffusion.jl` that produces this plot:. <img width=""587"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117931760-0dc40000-b2ac-11eb-8978-2c376d706948.png"">. I'm not sure how the immersed boundary will interact with the free surface, so we'd have to test that. In order to implement this scheme in `IncompressibleModel`, we'll have to get rid of the existing implementation. It's also unclear how accurate either this or the previous approximation is without modification of the pressure solver algorithm. I think to merge this we nee",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654
https://github.com/CliMA/Oceananigans.jl/pull/1654:987,Integrability,wrap,wrapper,987,"This PR implements a primitive immersed boundary scheme that is ""fitted"" to the grid. The scheme is specified with a function of `(x, y, z)` that is true when ""solid"" and false when ""fluid"". (A better name for the model kwarg than `immersed_boundary` might be `immersed_solid`.) It only supports no flux boundary conditions, but it should be ""relatively"" straightforward to support user specified flux boundary conditions. The scheme has the following ingredients:. * Masking of solid cells to 0 for both velocities and tracers.; * Elides diffusive fluxes across solid boundaries with an explicit `ifelse` embedded in diffusive flux and viscous flux functions. Because of the second point the scheme is ""invasive"" in that it requires the immersed boundary to be inserted into the tendency calculation. On the upside, it is likely cheap since it doesn't require any extra loops (except for the masking). EDIT: the implementation in this PR is _very_ invasive in that it introduces a grid wrapper that implements the immersed boundary functionality. Grid wrappers make the implementation of more sophisticated immersed boundary methods such as partial cell and shaved cells much easier. To support user-specified fluxes, we'd have to distinguish between a `solid_node` and a `fluid_solid_boundary_node`, and drop in the user-specified flux when appropriate. There's a primitive validation test in `validation/immersed_boundary/immersed_hydrostatic_diffusion.jl` that produces this plot:. <img width=""587"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117931760-0dc40000-b2ac-11eb-8978-2c376d706948.png"">. I'm not sure how the immersed boundary will interact with the free surface, so we'd have to test that. In order to implement this scheme in `IncompressibleModel`, we'll have to get rid of the existing implementation. It's also unclear how accurate either this or the previous approximation is without modification of the pressure solver algorithm. I think to merge this we nee",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654
https://github.com/CliMA/Oceananigans.jl/pull/1654:1053,Integrability,wrap,wrappers,1053,"a function of `(x, y, z)` that is true when ""solid"" and false when ""fluid"". (A better name for the model kwarg than `immersed_boundary` might be `immersed_solid`.) It only supports no flux boundary conditions, but it should be ""relatively"" straightforward to support user specified flux boundary conditions. The scheme has the following ingredients:. * Masking of solid cells to 0 for both velocities and tracers.; * Elides diffusive fluxes across solid boundaries with an explicit `ifelse` embedded in diffusive flux and viscous flux functions. Because of the second point the scheme is ""invasive"" in that it requires the immersed boundary to be inserted into the tendency calculation. On the upside, it is likely cheap since it doesn't require any extra loops (except for the masking). EDIT: the implementation in this PR is _very_ invasive in that it introduces a grid wrapper that implements the immersed boundary functionality. Grid wrappers make the implementation of more sophisticated immersed boundary methods such as partial cell and shaved cells much easier. To support user-specified fluxes, we'd have to distinguish between a `solid_node` and a `fluid_solid_boundary_node`, and drop in the user-specified flux when appropriate. There's a primitive validation test in `validation/immersed_boundary/immersed_hydrostatic_diffusion.jl` that produces this plot:. <img width=""587"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117931760-0dc40000-b2ac-11eb-8978-2c376d706948.png"">. I'm not sure how the immersed boundary will interact with the free surface, so we'd have to test that. In order to implement this scheme in `IncompressibleModel`, we'll have to get rid of the existing implementation. It's also unclear how accurate either this or the previous approximation is without modification of the pressure solver algorithm. I think to merge this we need 1) unit tests and 2) a validation tests that exercises the momentum equations. Supporting user-specified fluxes c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654
https://github.com/CliMA/Oceananigans.jl/pull/1654:1376,Security,validat,validation,1376,"undary conditions, but it should be ""relatively"" straightforward to support user specified flux boundary conditions. The scheme has the following ingredients:. * Masking of solid cells to 0 for both velocities and tracers.; * Elides diffusive fluxes across solid boundaries with an explicit `ifelse` embedded in diffusive flux and viscous flux functions. Because of the second point the scheme is ""invasive"" in that it requires the immersed boundary to be inserted into the tendency calculation. On the upside, it is likely cheap since it doesn't require any extra loops (except for the masking). EDIT: the implementation in this PR is _very_ invasive in that it introduces a grid wrapper that implements the immersed boundary functionality. Grid wrappers make the implementation of more sophisticated immersed boundary methods such as partial cell and shaved cells much easier. To support user-specified fluxes, we'd have to distinguish between a `solid_node` and a `fluid_solid_boundary_node`, and drop in the user-specified flux when appropriate. There's a primitive validation test in `validation/immersed_boundary/immersed_hydrostatic_diffusion.jl` that produces this plot:. <img width=""587"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117931760-0dc40000-b2ac-11eb-8978-2c376d706948.png"">. I'm not sure how the immersed boundary will interact with the free surface, so we'd have to test that. In order to implement this scheme in `IncompressibleModel`, we'll have to get rid of the existing implementation. It's also unclear how accurate either this or the previous approximation is without modification of the pressure solver algorithm. I think to merge this we need 1) unit tests and 2) a validation tests that exercises the momentum equations. Supporting user-specified fluxes can come in a subsequent PR. Some of the pieces to support immersed boundaries with VerticallyImplicitTimeDiscretization are in place but it's not 100% supported yet. cc @hdrake @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654
https://github.com/CliMA/Oceananigans.jl/pull/1654:1396,Security,validat,validation,1396,"undary conditions, but it should be ""relatively"" straightforward to support user specified flux boundary conditions. The scheme has the following ingredients:. * Masking of solid cells to 0 for both velocities and tracers.; * Elides diffusive fluxes across solid boundaries with an explicit `ifelse` embedded in diffusive flux and viscous flux functions. Because of the second point the scheme is ""invasive"" in that it requires the immersed boundary to be inserted into the tendency calculation. On the upside, it is likely cheap since it doesn't require any extra loops (except for the masking). EDIT: the implementation in this PR is _very_ invasive in that it introduces a grid wrapper that implements the immersed boundary functionality. Grid wrappers make the implementation of more sophisticated immersed boundary methods such as partial cell and shaved cells much easier. To support user-specified fluxes, we'd have to distinguish between a `solid_node` and a `fluid_solid_boundary_node`, and drop in the user-specified flux when appropriate. There's a primitive validation test in `validation/immersed_boundary/immersed_hydrostatic_diffusion.jl` that produces this plot:. <img width=""587"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117931760-0dc40000-b2ac-11eb-8978-2c376d706948.png"">. I'm not sure how the immersed boundary will interact with the free surface, so we'd have to test that. In order to implement this scheme in `IncompressibleModel`, we'll have to get rid of the existing implementation. It's also unclear how accurate either this or the previous approximation is without modification of the pressure solver algorithm. I think to merge this we need 1) unit tests and 2) a validation tests that exercises the momentum equations. Supporting user-specified fluxes can come in a subsequent PR. Some of the pieces to support immersed boundaries with VerticallyImplicitTimeDiscretization are in place but it's not 100% supported yet. cc @hdrake @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654
https://github.com/CliMA/Oceananigans.jl/pull/1654:2026,Security,validat,validation,2026,"undary conditions, but it should be ""relatively"" straightforward to support user specified flux boundary conditions. The scheme has the following ingredients:. * Masking of solid cells to 0 for both velocities and tracers.; * Elides diffusive fluxes across solid boundaries with an explicit `ifelse` embedded in diffusive flux and viscous flux functions. Because of the second point the scheme is ""invasive"" in that it requires the immersed boundary to be inserted into the tendency calculation. On the upside, it is likely cheap since it doesn't require any extra loops (except for the masking). EDIT: the implementation in this PR is _very_ invasive in that it introduces a grid wrapper that implements the immersed boundary functionality. Grid wrappers make the implementation of more sophisticated immersed boundary methods such as partial cell and shaved cells much easier. To support user-specified fluxes, we'd have to distinguish between a `solid_node` and a `fluid_solid_boundary_node`, and drop in the user-specified flux when appropriate. There's a primitive validation test in `validation/immersed_boundary/immersed_hydrostatic_diffusion.jl` that produces this plot:. <img width=""587"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117931760-0dc40000-b2ac-11eb-8978-2c376d706948.png"">. I'm not sure how the immersed boundary will interact with the free surface, so we'd have to test that. In order to implement this scheme in `IncompressibleModel`, we'll have to get rid of the existing implementation. It's also unclear how accurate either this or the previous approximation is without modification of the pressure solver algorithm. I think to merge this we need 1) unit tests and 2) a validation tests that exercises the momentum equations. Supporting user-specified fluxes can come in a subsequent PR. Some of the pieces to support immersed boundaries with VerticallyImplicitTimeDiscretization are in place but it's not 100% supported yet. cc @hdrake @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654
https://github.com/CliMA/Oceananigans.jl/pull/1654:1387,Testability,test,test,1387,"undary conditions, but it should be ""relatively"" straightforward to support user specified flux boundary conditions. The scheme has the following ingredients:. * Masking of solid cells to 0 for both velocities and tracers.; * Elides diffusive fluxes across solid boundaries with an explicit `ifelse` embedded in diffusive flux and viscous flux functions. Because of the second point the scheme is ""invasive"" in that it requires the immersed boundary to be inserted into the tendency calculation. On the upside, it is likely cheap since it doesn't require any extra loops (except for the masking). EDIT: the implementation in this PR is _very_ invasive in that it introduces a grid wrapper that implements the immersed boundary functionality. Grid wrappers make the implementation of more sophisticated immersed boundary methods such as partial cell and shaved cells much easier. To support user-specified fluxes, we'd have to distinguish between a `solid_node` and a `fluid_solid_boundary_node`, and drop in the user-specified flux when appropriate. There's a primitive validation test in `validation/immersed_boundary/immersed_hydrostatic_diffusion.jl` that produces this plot:. <img width=""587"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117931760-0dc40000-b2ac-11eb-8978-2c376d706948.png"">. I'm not sure how the immersed boundary will interact with the free surface, so we'd have to test that. In order to implement this scheme in `IncompressibleModel`, we'll have to get rid of the existing implementation. It's also unclear how accurate either this or the previous approximation is without modification of the pressure solver algorithm. I think to merge this we need 1) unit tests and 2) a validation tests that exercises the momentum equations. Supporting user-specified fluxes can come in a subsequent PR. Some of the pieces to support immersed boundaries with VerticallyImplicitTimeDiscretization are in place but it's not 100% supported yet. cc @hdrake @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654
https://github.com/CliMA/Oceananigans.jl/pull/1654:1717,Testability,test,test,1717,"undary conditions, but it should be ""relatively"" straightforward to support user specified flux boundary conditions. The scheme has the following ingredients:. * Masking of solid cells to 0 for both velocities and tracers.; * Elides diffusive fluxes across solid boundaries with an explicit `ifelse` embedded in diffusive flux and viscous flux functions. Because of the second point the scheme is ""invasive"" in that it requires the immersed boundary to be inserted into the tendency calculation. On the upside, it is likely cheap since it doesn't require any extra loops (except for the masking). EDIT: the implementation in this PR is _very_ invasive in that it introduces a grid wrapper that implements the immersed boundary functionality. Grid wrappers make the implementation of more sophisticated immersed boundary methods such as partial cell and shaved cells much easier. To support user-specified fluxes, we'd have to distinguish between a `solid_node` and a `fluid_solid_boundary_node`, and drop in the user-specified flux when appropriate. There's a primitive validation test in `validation/immersed_boundary/immersed_hydrostatic_diffusion.jl` that produces this plot:. <img width=""587"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117931760-0dc40000-b2ac-11eb-8978-2c376d706948.png"">. I'm not sure how the immersed boundary will interact with the free surface, so we'd have to test that. In order to implement this scheme in `IncompressibleModel`, we'll have to get rid of the existing implementation. It's also unclear how accurate either this or the previous approximation is without modification of the pressure solver algorithm. I think to merge this we need 1) unit tests and 2) a validation tests that exercises the momentum equations. Supporting user-specified fluxes can come in a subsequent PR. Some of the pieces to support immersed boundaries with VerticallyImplicitTimeDiscretization are in place but it's not 100% supported yet. cc @hdrake @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654
https://github.com/CliMA/Oceananigans.jl/pull/1654:2011,Testability,test,tests,2011,"undary conditions, but it should be ""relatively"" straightforward to support user specified flux boundary conditions. The scheme has the following ingredients:. * Masking of solid cells to 0 for both velocities and tracers.; * Elides diffusive fluxes across solid boundaries with an explicit `ifelse` embedded in diffusive flux and viscous flux functions. Because of the second point the scheme is ""invasive"" in that it requires the immersed boundary to be inserted into the tendency calculation. On the upside, it is likely cheap since it doesn't require any extra loops (except for the masking). EDIT: the implementation in this PR is _very_ invasive in that it introduces a grid wrapper that implements the immersed boundary functionality. Grid wrappers make the implementation of more sophisticated immersed boundary methods such as partial cell and shaved cells much easier. To support user-specified fluxes, we'd have to distinguish between a `solid_node` and a `fluid_solid_boundary_node`, and drop in the user-specified flux when appropriate. There's a primitive validation test in `validation/immersed_boundary/immersed_hydrostatic_diffusion.jl` that produces this plot:. <img width=""587"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117931760-0dc40000-b2ac-11eb-8978-2c376d706948.png"">. I'm not sure how the immersed boundary will interact with the free surface, so we'd have to test that. In order to implement this scheme in `IncompressibleModel`, we'll have to get rid of the existing implementation. It's also unclear how accurate either this or the previous approximation is without modification of the pressure solver algorithm. I think to merge this we need 1) unit tests and 2) a validation tests that exercises the momentum equations. Supporting user-specified fluxes can come in a subsequent PR. Some of the pieces to support immersed boundaries with VerticallyImplicitTimeDiscretization are in place but it's not 100% supported yet. cc @hdrake @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654
https://github.com/CliMA/Oceananigans.jl/pull/1654:2037,Testability,test,tests,2037,"undary conditions, but it should be ""relatively"" straightforward to support user specified flux boundary conditions. The scheme has the following ingredients:. * Masking of solid cells to 0 for both velocities and tracers.; * Elides diffusive fluxes across solid boundaries with an explicit `ifelse` embedded in diffusive flux and viscous flux functions. Because of the second point the scheme is ""invasive"" in that it requires the immersed boundary to be inserted into the tendency calculation. On the upside, it is likely cheap since it doesn't require any extra loops (except for the masking). EDIT: the implementation in this PR is _very_ invasive in that it introduces a grid wrapper that implements the immersed boundary functionality. Grid wrappers make the implementation of more sophisticated immersed boundary methods such as partial cell and shaved cells much easier. To support user-specified fluxes, we'd have to distinguish between a `solid_node` and a `fluid_solid_boundary_node`, and drop in the user-specified flux when appropriate. There's a primitive validation test in `validation/immersed_boundary/immersed_hydrostatic_diffusion.jl` that produces this plot:. <img width=""587"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117931760-0dc40000-b2ac-11eb-8978-2c376d706948.png"">. I'm not sure how the immersed boundary will interact with the free surface, so we'd have to test that. In order to implement this scheme in `IncompressibleModel`, we'll have to get rid of the existing implementation. It's also unclear how accurate either this or the previous approximation is without modification of the pressure solver algorithm. I think to merge this we need 1) unit tests and 2) a validation tests that exercises the momentum equations. Supporting user-specified fluxes can come in a subsequent PR. Some of the pieces to support immersed boundaries with VerticallyImplicitTimeDiscretization are in place but it's not 100% supported yet. cc @hdrake @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654
https://github.com/CliMA/Oceananigans.jl/issues/1655:537,Energy Efficiency,reduce,reduced,537,"EDIT: We can't set the locations of _all_ `Field` to `Nothing`. So I'm changing this issue topic to a discussion of whether we should support 1- and 2-argument functions for `set!` (when 2 or 1 directions are `Flat`), and also `dropdims` the `Flat` dimensions in `interior`. Previously:; This would allow us to use two- or one-argument function specification in `set!`, as well as two- and two-dimensional indexing. It might also make sense to `dropdims` `Nothing` locations when outputting raw field data... (it makes broadcasting with reduced fields, etc more difficult, but probably makes _most_ activities easier, like plotting)... ?. This would automagically solve @francispoulin's pain provided that `Flat` vertical topologies are enforced in the constructor for `ShallowWaterModel`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1655
https://github.com/CliMA/Oceananigans.jl/issues/1656:299,Availability,error,error,299,"I run https://github.com/CliMA/Oceananigans.jl/blob/master/examples/two_dimensional_turbulence.jl with success. but when trying to adapt the y-boundary ( or x or both) to Bounded. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Flat),size=(128, 128),extent=(2π, 2π)). I get the following error (I included a show to show the grid and its size). ```julia; grid = RegularRectilinearGrid{Float64, Periodic, Bounded, Flat}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [-1.2810265668750775e-18, 6.283185307179586], z ∈ [0.0, 0.0]; topology: (Periodic, Bounded, Flat); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 0); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 0.0); ┌ Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Grids\automatic_halo_sizing.jl:41; size(model.grid) = (128, 128, 1); ERROR: LoadError: DimensionMismatch(""array could not be broadcast to match destination""); Stacktrace:; [1] check_broadcast_shape at .\broadcast.jl:520 [inlined]; [2] check_broadcast_shape at .\broadcast.jl:521 [inlined]; [3] check_broadcast_axes at .\broadcast.jl:523 [inlined]; [4] instantiate(::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3},Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Array{Float64,3}}}) at .\broadcast.jl:269; [5] materialize! at .\broadcast.jl:848 [inlined]; [6] materialize! at C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Fields\broadcasting_abstract_fields.jl:19 [inlined]; [7] set!(::Field{Center,Face,Center,CPU,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656
https://github.com/CliMA/Oceananigans.jl/issues/1656:1075,Availability,ERROR,ERROR,1075," adapt the y-boundary ( or x or both) to Bounded. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Flat),size=(128, 128),extent=(2π, 2π)). I get the following error (I included a show to show the grid and its size). ```julia; grid = RegularRectilinearGrid{Float64, Periodic, Bounded, Flat}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [-1.2810265668750775e-18, 6.283185307179586], z ∈ [0.0, 0.0]; topology: (Periodic, Bounded, Flat); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 0); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 0.0); ┌ Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Grids\automatic_halo_sizing.jl:41; size(model.grid) = (128, 128, 1); ERROR: LoadError: DimensionMismatch(""array could not be broadcast to match destination""); Stacktrace:; [1] check_broadcast_shape at .\broadcast.jl:520 [inlined]; [2] check_broadcast_shape at .\broadcast.jl:521 [inlined]; [3] check_broadcast_axes at .\broadcast.jl:523 [inlined]; [4] instantiate(::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3},Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Array{Float64,3}}}) at .\broadcast.jl:269; [5] materialize! at .\broadcast.jl:848 [inlined]; [6] materialize! at C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Fields\broadcasting_abstract_fields.jl:19 [inlined]; [7] set!(::Field{Center,Face,Center,CPU,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Float64,NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656
https://github.com/CliMA/Oceananigans.jl/issues/1656:131,Energy Efficiency,adapt,adapt,131,"I run https://github.com/CliMA/Oceananigans.jl/blob/master/examples/two_dimensional_turbulence.jl with success. but when trying to adapt the y-boundary ( or x or both) to Bounded. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Flat),size=(128, 128),extent=(2π, 2π)). I get the following error (I included a show to show the grid and its size). ```julia; grid = RegularRectilinearGrid{Float64, Periodic, Bounded, Flat}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [-1.2810265668750775e-18, 6.283185307179586], z ∈ [0.0, 0.0]; topology: (Periodic, Bounded, Flat); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 0); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 0.0); ┌ Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Grids\automatic_halo_sizing.jl:41; size(model.grid) = (128, 128, 1); ERROR: LoadError: DimensionMismatch(""array could not be broadcast to match destination""); Stacktrace:; [1] check_broadcast_shape at .\broadcast.jl:520 [inlined]; [2] check_broadcast_shape at .\broadcast.jl:521 [inlined]; [3] check_broadcast_axes at .\broadcast.jl:523 [inlined]; [4] instantiate(::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3},Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Array{Float64,3}}}) at .\broadcast.jl:269; [5] materialize! at .\broadcast.jl:848 [inlined]; [6] materialize! at C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Fields\broadcasting_abstract_fields.jl:19 [inlined]; [7] set!(::Field{Center,Face,Center,CPU,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656
https://github.com/CliMA/Oceananigans.jl/issues/1656:131,Modifiability,adapt,adapt,131,"I run https://github.com/CliMA/Oceananigans.jl/blob/master/examples/two_dimensional_turbulence.jl with success. but when trying to adapt the y-boundary ( or x or both) to Bounded. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Flat),size=(128, 128),extent=(2π, 2π)). I get the following error (I included a show to show the grid and its size). ```julia; grid = RegularRectilinearGrid{Float64, Periodic, Bounded, Flat}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [-1.2810265668750775e-18, 6.283185307179586], z ∈ [0.0, 0.0]; topology: (Periodic, Bounded, Flat); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 0); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 0.0); ┌ Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Grids\automatic_halo_sizing.jl:41; size(model.grid) = (128, 128, 1); ERROR: LoadError: DimensionMismatch(""array could not be broadcast to match destination""); Stacktrace:; [1] check_broadcast_shape at .\broadcast.jl:520 [inlined]; [2] check_broadcast_shape at .\broadcast.jl:521 [inlined]; [3] check_broadcast_axes at .\broadcast.jl:523 [inlined]; [4] instantiate(::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3},Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Array{Float64,3}}}) at .\broadcast.jl:269; [5] materialize! at .\broadcast.jl:848 [inlined]; [6] materialize! at C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Fields\broadcasting_abstract_fields.jl:19 [inlined]; [7] set!(::Field{Center,Face,Center,CPU,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656
https://github.com/CliMA/Oceananigans.jl/issues/1656:1082,Performance,Load,LoadError,1082," adapt the y-boundary ( or x or both) to Bounded. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Flat),size=(128, 128),extent=(2π, 2π)). I get the following error (I included a show to show the grid and its size). ```julia; grid = RegularRectilinearGrid{Float64, Periodic, Bounded, Flat}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [-1.2810265668750775e-18, 6.283185307179586], z ∈ [0.0, 0.0]; topology: (Periodic, Bounded, Flat); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 0); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 0.0); ┌ Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Grids\automatic_halo_sizing.jl:41; size(model.grid) = (128, 128, 1); ERROR: LoadError: DimensionMismatch(""array could not be broadcast to match destination""); Stacktrace:; [1] check_broadcast_shape at .\broadcast.jl:520 [inlined]; [2] check_broadcast_shape at .\broadcast.jl:521 [inlined]; [3] check_broadcast_axes at .\broadcast.jl:523 [inlined]; [4] instantiate(::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3},Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Array{Float64,3}}}) at .\broadcast.jl:269; [5] materialize! at .\broadcast.jl:848 [inlined]; [6] materialize! at C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Fields\broadcasting_abstract_fields.jl:19 [inlined]; [7] set!(::Field{Center,Face,Center,CPU,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Float64,NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656
https://github.com/CliMA/Oceananigans.jl/issues/1656:856,Safety,avoid,avoid,856,"I run https://github.com/CliMA/Oceananigans.jl/blob/master/examples/two_dimensional_turbulence.jl with success. but when trying to adapt the y-boundary ( or x or both) to Bounded. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Flat),size=(128, 128),extent=(2π, 2π)). I get the following error (I included a show to show the grid and its size). ```julia; grid = RegularRectilinearGrid{Float64, Periodic, Bounded, Flat}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [-1.2810265668750775e-18, 6.283185307179586], z ∈ [0.0, 0.0]; topology: (Periodic, Bounded, Flat); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 0); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 0.0); ┌ Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Grids\automatic_halo_sizing.jl:41; size(model.grid) = (128, 128, 1); ERROR: LoadError: DimensionMismatch(""array could not be broadcast to match destination""); Stacktrace:; [1] check_broadcast_shape at .\broadcast.jl:520 [inlined]; [2] check_broadcast_shape at .\broadcast.jl:521 [inlined]; [3] check_broadcast_axes at .\broadcast.jl:523 [inlined]; [4] instantiate(::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3},Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Array{Float64,3}}}) at .\broadcast.jl:269; [5] materialize! at .\broadcast.jl:848 [inlined]; [6] materialize! at C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Fields\broadcasting_abstract_fields.jl:19 [inlined]; [7] set!(::Field{Center,Face,Center,CPU,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656
https://github.com/CliMA/Oceananigans.jl/issues/1657:790,Availability,Avail,Available,790,"Yesterday I tried running the diffusion example on a server and it run but there was a lot of output that appeared when doing simple plotting, see below. This is not an oceananigans thing as much as a `Plots.jl` thing. We found out that adding the line `ENV[""GKSwstype""]=""nul""` seemed to resolve the issue. Do people know how common a problem this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSA",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:956,Integrability,rout,routine,956,"Yesterday I tried running the diffusion example on a server and it run but there was a lot of output that appeared when doing simple plotting, see below. This is not an oceananigans thing as much as a `Plots.jl` thing. We found out that adding the line `ENV[""GKSwstype""]=""nul""` seemed to resolve the issue. Do people know how common a problem this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSA",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:1051,Integrability,rout,routine,1051,"a server and it run but there was a lot of output that appeared when doing simple plotting, see below. This is not an oceananigans thing as much as a `Plots.jl` thing. We found out that adding the line `ENV[""GKSwstype""]=""nul""` seemed to resolve the issue. Do people know how common a problem this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in prop",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:1150,Integrability,rout,routine,1150,"low. This is not an oceananigans thing as much as a `Plots.jl` thing. We found out that adding the line `ENV[""GKSwstype""]=""nul""` seemed to resolve the issue. Do people know how common a problem this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in prope",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:1246,Integrability,rout,routine,1246,"he line `ENV[""GKSwstype""]=""nul""` seemed to resolve the issue. Do people know how common a problem this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in prope",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:1342,Integrability,rout,routine,1342,"m this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in prope",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:1438,Integrability,rout,routine,1438,"e in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper st",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:1534,Integrability,rout,routine,1534,"uld not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:1630,Integrability,rout,routine,1630,"en though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:1726,Integrability,rout,routine,1726," initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS mus",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:1822,Integrability,rout,routine,1822," linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:1918,Integrability,rout,routine,1918,ocket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:2014,Integrability,rout,routine,2014,e either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:2110,Integrability,rout,routine,2110,t be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:2206,Integrability,rout,routine,2206,t be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:2302,Integrability,rout,routine,2302,t be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:2398,Integrability,rout,routine,2398,ust be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must ,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:2490,Integrability,rout,routine,2490,KS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS m,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:2582,Integrability,rout,routine,2582,e. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. G,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:2674,Integrability,rout,routine,2674,state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper stat,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:2766,Integrability,rout,routine,2766,per state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper ,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:2858,Integrability,rout,routine,2858,roper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in prope,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:2954,Integrability,rout,routine,2954,roper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper st,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:3050,Integrability,rout,routine,3050,roper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:3146,Integrability,rout,routine,3146,roper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:3242,Integrability,rout,routine,3242,roper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS mus,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:3338,Integrability,rout,routine,3338,roper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:3434,Integrability,rout,routine,3434,in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:3530,Integrability,rout,routine,3530,in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:3626,Integrability,rout,routine,3626,in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:3722,Integrability,rout,routine,3722,in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:3818,Integrability,rout,routine,3818,in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:3914,Integrability,rout,routine,3914,in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:4006,Integrability,rout,routine,4006,in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:4098,Integrability,rout,routine,4098,in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:4190,Integrability,rout,routine,4190,in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:4282,Integrability,rout,routine,4282,in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:4374,Integrability,rout,routine,4374,in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine TEXT; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:569,Modifiability,plugin,plugin,569,"Yesterday I tried running the diffusion example on a server and it run but there was a lot of output that appeared when doing simple plotting, see below. This is not an oceananigans thing as much as a `Plots.jl` thing. We found out that adding the line `ENV[""GKSwstype""]=""nul""` seemed to resolve the issue. Do people know how common a problem this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSA",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:608,Modifiability,plugin,plugin,608,"Yesterday I tried running the diffusion example on a server and it run but there was a lot of output that appeared when doing simple plotting, see below. This is not an oceananigans thing as much as a `Plots.jl` thing. We found out that adding the line `ENV[""GKSwstype""]=""nul""` seemed to resolve the issue. Do people know how common a problem this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSA",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:710,Modifiability,plugin,plugin,710,"Yesterday I tried running the diffusion example on a server and it run but there was a lot of output that appeared when doing simple plotting, see below. This is not an oceananigans thing as much as a `Plots.jl` thing. We found out that adding the line `ENV[""GKSwstype""]=""nul""` seemed to resolve the issue. Do people know how common a problem this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSA",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:809,Modifiability,plugin,plugins,809,"Yesterday I tried running the diffusion example on a server and it run but there was a lot of output that appeared when doing simple plotting, see below. This is not an oceananigans thing as much as a `Plots.jl` thing. We found out that adding the line `ENV[""GKSwstype""]=""nul""` seemed to resolve the issue. Do people know how common a problem this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSA",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:587,Performance,load,load,587,"Yesterday I tried running the diffusion example on a server and it run but there was a lot of output that appeared when doing simple plotting, see below. This is not an oceananigans thing as much as a `Plots.jl` thing. We found out that adding the line `ENV[""GKSwstype""]=""nul""` seemed to resolve the issue. Do people know how common a problem this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSA",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/issues/1657:126,Usability,simpl,simple,126,"Yesterday I tried running the diffusion example on a server and it run but there was a lot of output that appeared when doing simple plotting, see below. This is not an oceananigans thing as much as a `Plots.jl` thing. We found out that adding the line `ENV[""GKSwstype""]=""nul""` seemed to resolve the issue. Do people know how common a problem this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSA",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657
https://github.com/CliMA/Oceananigans.jl/pull/1659:28,Energy Efficiency,efficient,efficient,28,Using `Flat` should be more efficient in terms of memory.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1659
https://github.com/CliMA/Oceananigans.jl/pull/1662:126,Availability,error,error,126,Assert that the topology is Flat in the vertical and also have a test that `Periodic` or `Bounded` in the vertical creates an error.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662
https://github.com/CliMA/Oceananigans.jl/pull/1662:0,Testability,Assert,Assert,0,Assert that the topology is Flat in the vertical and also have a test that `Periodic` or `Bounded` in the vertical creates an error.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662
https://github.com/CliMA/Oceananigans.jl/pull/1662:65,Testability,test,test,65,Assert that the topology is Flat in the vertical and also have a test that `Periodic` or `Bounded` in the vertical creates an error.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662
https://github.com/CliMA/Oceananigans.jl/pull/1663:196,Availability,error,error,196,Following a discussion with @glwagner I have tried to use the Immersed Boundary Method for `ShallowWaterModel`. I have not succeeded yet but hope we can have a fruitful discussison here to fix my error. . Can someone help me figure out what I'm doing wrong?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663
https://github.com/CliMA/Oceananigans.jl/pull/1664:216,Energy Efficiency,energy,energy,216,"This WIP PR implements a `TKEBasedVerticalDiffusivity` that intends to describe mixing in the ocean surface boundary layer and interior with an eddy diffusivity that depends on a prognostic subgrid turbulent kinetic energy variable. This scheme may eventually also contain ""convective adjustment"" as a submodel, in which case it will have the short hand ""CATKE"" which stands for ""Convective adjustment and turbulent kinetic energy parameterization"". The scheme without convective adjustment is briefly described in [a poster presented at Ocean Sciences 2020](https://glwagner.github.io/assets/figures/ocean_sciences_2020_poster.png), with a few minor differences in the details.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1664
https://github.com/CliMA/Oceananigans.jl/pull/1664:424,Energy Efficiency,energy,energy,424,"This WIP PR implements a `TKEBasedVerticalDiffusivity` that intends to describe mixing in the ocean surface boundary layer and interior with an eddy diffusivity that depends on a prognostic subgrid turbulent kinetic energy variable. This scheme may eventually also contain ""convective adjustment"" as a submodel, in which case it will have the short hand ""CATKE"" which stands for ""Convective adjustment and turbulent kinetic energy parameterization"". The scheme without convective adjustment is briefly described in [a poster presented at Ocean Sciences 2020](https://glwagner.github.io/assets/figures/ocean_sciences_2020_poster.png), with a few minor differences in the details.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1664
https://github.com/CliMA/Oceananigans.jl/pull/1664:166,Integrability,depend,depends,166,"This WIP PR implements a `TKEBasedVerticalDiffusivity` that intends to describe mixing in the ocean surface boundary layer and interior with an eddy diffusivity that depends on a prognostic subgrid turbulent kinetic energy variable. This scheme may eventually also contain ""convective adjustment"" as a submodel, in which case it will have the short hand ""CATKE"" which stands for ""Convective adjustment and turbulent kinetic energy parameterization"". The scheme without convective adjustment is briefly described in [a poster presented at Ocean Sciences 2020](https://glwagner.github.io/assets/figures/ocean_sciences_2020_poster.png), with a few minor differences in the details.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1664
https://github.com/CliMA/Oceananigans.jl/pull/1664:223,Modifiability,variab,variable,223,"This WIP PR implements a `TKEBasedVerticalDiffusivity` that intends to describe mixing in the ocean surface boundary layer and interior with an eddy diffusivity that depends on a prognostic subgrid turbulent kinetic energy variable. This scheme may eventually also contain ""convective adjustment"" as a submodel, in which case it will have the short hand ""CATKE"" which stands for ""Convective adjustment and turbulent kinetic energy parameterization"". The scheme without convective adjustment is briefly described in [a poster presented at Ocean Sciences 2020](https://glwagner.github.io/assets/figures/ocean_sciences_2020_poster.png), with a few minor differences in the details.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1664
https://github.com/CliMA/Oceananigans.jl/pull/1664:431,Modifiability,parameteriz,parameterization,431,"This WIP PR implements a `TKEBasedVerticalDiffusivity` that intends to describe mixing in the ocean surface boundary layer and interior with an eddy diffusivity that depends on a prognostic subgrid turbulent kinetic energy variable. This scheme may eventually also contain ""convective adjustment"" as a submodel, in which case it will have the short hand ""CATKE"" which stands for ""Convective adjustment and turbulent kinetic energy parameterization"". The scheme without convective adjustment is briefly described in [a poster presented at Ocean Sciences 2020](https://glwagner.github.io/assets/figures/ocean_sciences_2020_poster.png), with a few minor differences in the details.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1664
https://github.com/CliMA/Oceananigans.jl/issues/1666:320,Safety,avoid,avoid,320,"Following up on #1662, copied below. We should make it so that for `ShallowWaterModel`, if we set halo to (3,3), or whatever is appropriate, there is no warning. ```; [2021/05/18 12:18:29.494] WARN Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid. -@-> /home/fpoulin/software/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1666
https://github.com/CliMA/Oceananigans.jl/pull/1669:1180,Security,validat,validation,1180,Hijacking @christophernhill's branch and work!. @jm-c set up the same velocity halo exchange from https://github.com/CliMA/Oceananigans.jl/blob/7cc147bbf831fe4de66584d812e56debcfa6e43f/test/test_cubed_sphere_halo_exchange.jl#L378-L382 in MITgcm from which we were able to figure out where the Oceananigans cubed sphere halo exchange was going wrong. There were a several discrepancies (all at halo corners or adjacent to the halo corners). ```; u face 1: 2 discrepancies; v face 1: 3 discrepancies; u face 2: 2 discrepancies; v face 2: 3 discrepancies; u face 3: 1 discrepancies; v face 3: 2 discrepancies; u face 4: 1 discrepancies; v face 4: 3 discrepancies; u face 5: 0 discrepancies; v face 5: 2 discrepancies; u face 6: 0 discrepancies; v face 6: 2 discrepancies; u: 6 discrepancies; v: 15 discrepancies; ```. Not totally sure why our halo exchange algorithm isn't filling these correctly so for now we fix each one after filling all the velocity halos. Now that our halo exchange exactly matches MITgcm's we might want to add some extra tests to make sure we're testing each of these points. Some existing tests need to be cleaned up too. After this fix the Rossby-Haurwitz validation seems pretty happy (it used to exhibit numerical artifacts at some corners then blow up after a few days). https://user-images.githubusercontent.com/20099589/118747990-0317e680-b829-11eb-94c3-40002f928e52.mp4. The eddying aquaplanet validation from PR #1602 doesn't look as happy so it might still have setup issues (and maybe also plotting issues since vorticity is at the corners).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1669
https://github.com/CliMA/Oceananigans.jl/pull/1669:1424,Security,validat,validation,1424,Hijacking @christophernhill's branch and work!. @jm-c set up the same velocity halo exchange from https://github.com/CliMA/Oceananigans.jl/blob/7cc147bbf831fe4de66584d812e56debcfa6e43f/test/test_cubed_sphere_halo_exchange.jl#L378-L382 in MITgcm from which we were able to figure out where the Oceananigans cubed sphere halo exchange was going wrong. There were a several discrepancies (all at halo corners or adjacent to the halo corners). ```; u face 1: 2 discrepancies; v face 1: 3 discrepancies; u face 2: 2 discrepancies; v face 2: 3 discrepancies; u face 3: 1 discrepancies; v face 3: 2 discrepancies; u face 4: 1 discrepancies; v face 4: 3 discrepancies; u face 5: 0 discrepancies; v face 5: 2 discrepancies; u face 6: 0 discrepancies; v face 6: 2 discrepancies; u: 6 discrepancies; v: 15 discrepancies; ```. Not totally sure why our halo exchange algorithm isn't filling these correctly so for now we fix each one after filling all the velocity halos. Now that our halo exchange exactly matches MITgcm's we might want to add some extra tests to make sure we're testing each of these points. Some existing tests need to be cleaned up too. After this fix the Rossby-Haurwitz validation seems pretty happy (it used to exhibit numerical artifacts at some corners then blow up after a few days). https://user-images.githubusercontent.com/20099589/118747990-0317e680-b829-11eb-94c3-40002f928e52.mp4. The eddying aquaplanet validation from PR #1602 doesn't look as happy so it might still have setup issues (and maybe also plotting issues since vorticity is at the corners).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1669
https://github.com/CliMA/Oceananigans.jl/pull/1669:185,Testability,test,test,185,Hijacking @christophernhill's branch and work!. @jm-c set up the same velocity halo exchange from https://github.com/CliMA/Oceananigans.jl/blob/7cc147bbf831fe4de66584d812e56debcfa6e43f/test/test_cubed_sphere_halo_exchange.jl#L378-L382 in MITgcm from which we were able to figure out where the Oceananigans cubed sphere halo exchange was going wrong. There were a several discrepancies (all at halo corners or adjacent to the halo corners). ```; u face 1: 2 discrepancies; v face 1: 3 discrepancies; u face 2: 2 discrepancies; v face 2: 3 discrepancies; u face 3: 1 discrepancies; v face 3: 2 discrepancies; u face 4: 1 discrepancies; v face 4: 3 discrepancies; u face 5: 0 discrepancies; v face 5: 2 discrepancies; u face 6: 0 discrepancies; v face 6: 2 discrepancies; u: 6 discrepancies; v: 15 discrepancies; ```. Not totally sure why our halo exchange algorithm isn't filling these correctly so for now we fix each one after filling all the velocity halos. Now that our halo exchange exactly matches MITgcm's we might want to add some extra tests to make sure we're testing each of these points. Some existing tests need to be cleaned up too. After this fix the Rossby-Haurwitz validation seems pretty happy (it used to exhibit numerical artifacts at some corners then blow up after a few days). https://user-images.githubusercontent.com/20099589/118747990-0317e680-b829-11eb-94c3-40002f928e52.mp4. The eddying aquaplanet validation from PR #1602 doesn't look as happy so it might still have setup issues (and maybe also plotting issues since vorticity is at the corners).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1669
https://github.com/CliMA/Oceananigans.jl/pull/1669:1043,Testability,test,tests,1043,Hijacking @christophernhill's branch and work!. @jm-c set up the same velocity halo exchange from https://github.com/CliMA/Oceananigans.jl/blob/7cc147bbf831fe4de66584d812e56debcfa6e43f/test/test_cubed_sphere_halo_exchange.jl#L378-L382 in MITgcm from which we were able to figure out where the Oceananigans cubed sphere halo exchange was going wrong. There were a several discrepancies (all at halo corners or adjacent to the halo corners). ```; u face 1: 2 discrepancies; v face 1: 3 discrepancies; u face 2: 2 discrepancies; v face 2: 3 discrepancies; u face 3: 1 discrepancies; v face 3: 2 discrepancies; u face 4: 1 discrepancies; v face 4: 3 discrepancies; u face 5: 0 discrepancies; v face 5: 2 discrepancies; u face 6: 0 discrepancies; v face 6: 2 discrepancies; u: 6 discrepancies; v: 15 discrepancies; ```. Not totally sure why our halo exchange algorithm isn't filling these correctly so for now we fix each one after filling all the velocity halos. Now that our halo exchange exactly matches MITgcm's we might want to add some extra tests to make sure we're testing each of these points. Some existing tests need to be cleaned up too. After this fix the Rossby-Haurwitz validation seems pretty happy (it used to exhibit numerical artifacts at some corners then blow up after a few days). https://user-images.githubusercontent.com/20099589/118747990-0317e680-b829-11eb-94c3-40002f928e52.mp4. The eddying aquaplanet validation from PR #1602 doesn't look as happy so it might still have setup issues (and maybe also plotting issues since vorticity is at the corners).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1669
https://github.com/CliMA/Oceananigans.jl/pull/1669:1068,Testability,test,testing,1068,Hijacking @christophernhill's branch and work!. @jm-c set up the same velocity halo exchange from https://github.com/CliMA/Oceananigans.jl/blob/7cc147bbf831fe4de66584d812e56debcfa6e43f/test/test_cubed_sphere_halo_exchange.jl#L378-L382 in MITgcm from which we were able to figure out where the Oceananigans cubed sphere halo exchange was going wrong. There were a several discrepancies (all at halo corners or adjacent to the halo corners). ```; u face 1: 2 discrepancies; v face 1: 3 discrepancies; u face 2: 2 discrepancies; v face 2: 3 discrepancies; u face 3: 1 discrepancies; v face 3: 2 discrepancies; u face 4: 1 discrepancies; v face 4: 3 discrepancies; u face 5: 0 discrepancies; v face 5: 2 discrepancies; u face 6: 0 discrepancies; v face 6: 2 discrepancies; u: 6 discrepancies; v: 15 discrepancies; ```. Not totally sure why our halo exchange algorithm isn't filling these correctly so for now we fix each one after filling all the velocity halos. Now that our halo exchange exactly matches MITgcm's we might want to add some extra tests to make sure we're testing each of these points. Some existing tests need to be cleaned up too. After this fix the Rossby-Haurwitz validation seems pretty happy (it used to exhibit numerical artifacts at some corners then blow up after a few days). https://user-images.githubusercontent.com/20099589/118747990-0317e680-b829-11eb-94c3-40002f928e52.mp4. The eddying aquaplanet validation from PR #1602 doesn't look as happy so it might still have setup issues (and maybe also plotting issues since vorticity is at the corners).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1669
https://github.com/CliMA/Oceananigans.jl/pull/1669:1112,Testability,test,tests,1112,Hijacking @christophernhill's branch and work!. @jm-c set up the same velocity halo exchange from https://github.com/CliMA/Oceananigans.jl/blob/7cc147bbf831fe4de66584d812e56debcfa6e43f/test/test_cubed_sphere_halo_exchange.jl#L378-L382 in MITgcm from which we were able to figure out where the Oceananigans cubed sphere halo exchange was going wrong. There were a several discrepancies (all at halo corners or adjacent to the halo corners). ```; u face 1: 2 discrepancies; v face 1: 3 discrepancies; u face 2: 2 discrepancies; v face 2: 3 discrepancies; u face 3: 1 discrepancies; v face 3: 2 discrepancies; u face 4: 1 discrepancies; v face 4: 3 discrepancies; u face 5: 0 discrepancies; v face 5: 2 discrepancies; u face 6: 0 discrepancies; v face 6: 2 discrepancies; u: 6 discrepancies; v: 15 discrepancies; ```. Not totally sure why our halo exchange algorithm isn't filling these correctly so for now we fix each one after filling all the velocity halos. Now that our halo exchange exactly matches MITgcm's we might want to add some extra tests to make sure we're testing each of these points. Some existing tests need to be cleaned up too. After this fix the Rossby-Haurwitz validation seems pretty happy (it used to exhibit numerical artifacts at some corners then blow up after a few days). https://user-images.githubusercontent.com/20099589/118747990-0317e680-b829-11eb-94c3-40002f928e52.mp4. The eddying aquaplanet validation from PR #1602 doesn't look as happy so it might still have setup issues (and maybe also plotting issues since vorticity is at the corners).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1669
https://github.com/CliMA/Oceananigans.jl/pull/1670:111,Availability,checkpoint,checkpointer,111,This PR removes the now out-of-date `restore_from_checkpoint` function and updates the docs. Unfortunately the checkpointer test that was commented out in PR https://github.com/CliMA/Oceananigans.jl/pull/1639 is failing again now when uncommented.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1670
https://github.com/CliMA/Oceananigans.jl/pull/1670:75,Deployability,update,updates,75,This PR removes the now out-of-date `restore_from_checkpoint` function and updates the docs. Unfortunately the checkpointer test that was commented out in PR https://github.com/CliMA/Oceananigans.jl/pull/1639 is failing again now when uncommented.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1670
https://github.com/CliMA/Oceananigans.jl/pull/1670:124,Testability,test,test,124,This PR removes the now out-of-date `restore_from_checkpoint` function and updates the docs. Unfortunately the checkpointer test that was commented out in PR https://github.com/CliMA/Oceananigans.jl/pull/1639 is failing again now when uncommented.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1670
https://github.com/CliMA/Oceananigans.jl/issues/1672:57,Testability,benchmark,benchmarks,57,"I tried to run both the shallow water and incompressible benchmarks and ran into problems when they tried to output the CPU to GPU speedup table html file. ; The problem seems to be cause by the html file being named ""[model name]_CPU_->_GPU_speedup.html"" and "">"" not being allowed to be a part of filenames. It was fixed by changing the output filename to ""[model name]_CPU_to_GPU_speedup.html"".; This issue occurred while running on Windows10, but I think it would likely be a problem elsewhere too where "">"" is a reserved character for file and directory names.; @francispoulin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1672
https://github.com/CliMA/Oceananigans.jl/pull/1673:459,Availability,down,downstream,459,"This pull request sets the compat entry for the `ArrayInterface` package to `3.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `ArrayInterface` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1673
https://github.com/CliMA/Oceananigans.jl/pull/1673:397,Deployability,release,release,397,"This pull request sets the compat entry for the `ArrayInterface` package to `3.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `ArrayInterface` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1673
https://github.com/CliMA/Oceananigans.jl/pull/1673:483,Integrability,depend,depend,483,"This pull request sets the compat entry for the `ArrayInterface` package to `3.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `ArrayInterface` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1673
https://github.com/CliMA/Oceananigans.jl/pull/1673:212,Testability,test,tested,212,"This pull request sets the compat entry for the `ArrayInterface` package to `3.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `ArrayInterface` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1673
https://github.com/CliMA/Oceananigans.jl/pull/1673:317,Testability,test,tests,317,"This pull request sets the compat entry for the `ArrayInterface` package to `3.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `ArrayInterface` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1673
https://github.com/CliMA/Oceananigans.jl/pull/1673:502,Testability,test,tests,502,"This pull request sets the compat entry for the `ArrayInterface` package to `3.1`. This is a brand new compat entry. Previously, you did not have a compat entry for the `ArrayInterface` package. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request. Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1673
https://github.com/CliMA/Oceananigans.jl/issues/1676:19,Performance,Perform,Performance,19,We should run the [Performance Benchmarks](https://clima.github.io/OceananigansDocumentation/stable/benchmarks/) with the latest Oceananigans.jl version and on Julia v1.6.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1676
https://github.com/CliMA/Oceananigans.jl/issues/1676:31,Testability,Benchmark,Benchmarks,31,We should run the [Performance Benchmarks](https://clima.github.io/OceananigansDocumentation/stable/benchmarks/) with the latest Oceananigans.jl version and on Julia v1.6.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1676
https://github.com/CliMA/Oceananigans.jl/issues/1676:100,Testability,benchmark,benchmarks,100,We should run the [Performance Benchmarks](https://clima.github.io/OceananigansDocumentation/stable/benchmarks/) with the latest Oceananigans.jl version and on Julia v1.6.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1676
https://github.com/CliMA/Oceananigans.jl/pull/1677:0,Deployability,Update,Updates,0,Updates `docs/Manifest.toml`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1677
https://github.com/CliMA/Oceananigans.jl/issues/1679:1563,Deployability,update,updated,1563,"ognostic equation (fully Lagrangian isopycnal coordinates, semi-Lagrangian hybrid coordinates / _z-tilde_ coordinates that vary only with high frequency motion, and adaptive methods that prescribe GVC dynamics to obtain favorable properties like concentration in regions of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equation",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:1794,Deployability,integrat,integrate,1794,"s of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during ste",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:2460,Deployability,integrat,integrating,2460,"epping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to st",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:664,Energy Efficiency,adapt,adaptive,664,"The equations of motion for most or all major ocean modeling software are implemented using a ""Generalized Vertical Coordinate"" (GVC). Generalized vertical coordinates contain a ""fixed z"" coordinate as a limiting case, but generalize to vertical coordinates that. * Are fixed in time but conform to topographic variations (`σ` coordinates);; * Vary in time in a diagnostic manner (for example, _z-star_ coordinates, which vary with the sea surface displacement);; * Vary in time according to some prognostic equation (fully Lagrangian isopycnal coordinates, semi-Lagrangian hybrid coordinates / _z-tilde_ coordinates that vary only with high frequency motion, and adaptive methods that prescribe GVC dynamics to obtain favorable properties like concentration in regions of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:4652,Energy Efficiency,adapt,adaptive,4652,"put unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap” methods](https://agupubs.onlinelibrary.wiley.com/doi/epdf/10.1029/2019MS001954) (Griffies et al, 2019); * [“z-tilde” GVC used by the NEMO ocean model](https://www.sciencedirect.com/science/article/pii/S1463500311000126?casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (Leclair and Madec 2011); * [Evaluation of various GVC in MPAS-Ocean](https://www.sciencedirect.com/science/article/pii/S1463500314001796) (Petersen et al 2015); * [GVC in a nonhydrostatic compressible atmospheric model ENDgame](https://rmets.onlinelibrary.wiley.com/doi/full/10.1002/qj.3368) (Kavcic and Thuburn, 2018); * [Correct calculation of pressure gradients in a finite volume model](https://www.sciencedirect.com/science/article/pii/S1463500308000243?casa_token=vsSBQiBsJugAAAAA:GHaDu6afxrLQ4NIdCDiGWl47xClDdYRdM-CSFlZ8kGxQMAOov7vSHAKp_Ch5hQ9OsousvG8sCg) (Adcroft et al 2008); [An “adaptive”, semi-Lagrangian GVC](https://www.sciencedirect.com/science/article/pii/S1463500302000604) (Burchard and Beckers 2004) See also a [3D description](https://www.sciencedirect.com/science/article/pii/S1463500309002248?casa_token=l2d7ijIAiN8AAAAA:kVzMMRqaP2d6U0QDaqB1vqfWKHjIpGWZr0EovdkMJtxHxGSb_xEQ8SlG3OtYkb2mz-6ggmGwGA) (Hofmeister et al 2010) and [realistic test case](https://www.sciencedirect.com/science/article/pii/S1463500311000801?casa_token=CkEoHLOnIxMAAAAA:QWjy9Ck26XOhdWf5K-IaJghogprZ06FDTuCZeORuBO69lWLcRYiWkz4uFtoXRLbfTATnuk932w) (Hofmeister et al 2011); [“z star” GVC in MITgcm](https://www.sciencedirect.com/science/article/pii/S1463500303000544) (Adcroft and Campin 2004)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:1170,Integrability,depend,dependent,1170,"* Are fixed in time but conform to topographic variations (`σ` coordinates);; * Vary in time in a diagnostic manner (for example, _z-star_ coordinates, which vary with the sea surface displacement);; * Vary in time according to some prognostic equation (fully Lagrangian isopycnal coordinates, semi-Lagrangian hybrid coordinates / _z-tilde_ coordinates that vary only with high frequency motion, and adaptive methods that prescribe GVC dynamics to obtain favorable properties like concentration in regions of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordina",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:1794,Integrability,integrat,integrate,1794,"s of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during ste",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:2407,Integrability,depend,dependence,2407," This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variabl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:2460,Integrability,integrat,integrating,2460,"epping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to st",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:2731,Integrability,depend,depending,2731,"rdinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:664,Modifiability,adapt,adaptive,664,"The equations of motion for most or all major ocean modeling software are implemented using a ""Generalized Vertical Coordinate"" (GVC). Generalized vertical coordinates contain a ""fixed z"" coordinate as a limiting case, but generalize to vertical coordinates that. * Are fixed in time but conform to topographic variations (`σ` coordinates);; * Vary in time in a diagnostic manner (for example, _z-star_ coordinates, which vary with the sea surface displacement);; * Vary in time according to some prognostic equation (fully Lagrangian isopycnal coordinates, semi-Lagrangian hybrid coordinates / _z-tilde_ coordinates that vary only with high frequency motion, and adaptive methods that prescribe GVC dynamics to obtain favorable properties like concentration in regions of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:995,Modifiability,refactor,refactoring,995,"eling software are implemented using a ""Generalized Vertical Coordinate"" (GVC). Generalized vertical coordinates contain a ""fixed z"" coordinate as a limiting case, but generalize to vertical coordinates that. * Are fixed in time but conform to topographic variations (`σ` coordinates);; * Vary in time in a diagnostic manner (for example, _z-star_ coordinates, which vary with the sea surface displacement);; * Vary in time according to some prognostic equation (fully Lagrangian isopycnal coordinates, semi-Lagrangian hybrid coordinates / _z-tilde_ coordinates that vary only with high frequency motion, and adaptive methods that prescribe GVC dynamics to obtain favorable properties like concentration in regions of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:1150,Modifiability,variab,variables,1150,"eling software are implemented using a ""Generalized Vertical Coordinate"" (GVC). Generalized vertical coordinates contain a ""fixed z"" coordinate as a limiting case, but generalize to vertical coordinates that. * Are fixed in time but conform to topographic variations (`σ` coordinates);; * Vary in time in a diagnostic manner (for example, _z-star_ coordinates, which vary with the sea surface displacement);; * Vary in time according to some prognostic equation (fully Lagrangian isopycnal coordinates, semi-Lagrangian hybrid coordinates / _z-tilde_ coordinates that vary only with high frequency motion, and adaptive methods that prescribe GVC dynamics to obtain favorable properties like concentration in regions of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:1452,Modifiability,variab,variable,1452,"ognostic equation (fully Lagrangian isopycnal coordinates, semi-Lagrangian hybrid coordinates / _z-tilde_ coordinates that vary only with high frequency motion, and adaptive methods that prescribe GVC dynamics to obtain favorable properties like concentration in regions of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equation",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:1748,Modifiability,refactor,refactor,1748,"s of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during ste",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:2090,Modifiability,refactor,refactored,2090,"otentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:2724,Modifiability,evolve,evolve,2724,"rdinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:2856,Modifiability,variab,variables,2856,"tical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap” methods](https://agupubs.onlinelibrary.wiley.com/doi/epdf/10.1029/2019MS001954) (Griffies et al, 2019); * [“z-tilde” GVC used by the NEMO ocean model](https",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:2875,Modifiability,variab,variables,2875,"tical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap” methods](https://agupubs.onlinelibrary.wiley.com/doi/epdf/10.1029/2019MS001954) (Griffies et al, 2019); * [“z-tilde” GVC used by the NEMO ocean model](https",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:2908,Modifiability,variab,variables,2908,"tical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap” methods](https://agupubs.onlinelibrary.wiley.com/doi/epdf/10.1029/2019MS001954) (Griffies et al, 2019); * [“z-tilde” GVC used by the NEMO ocean model](https",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:3027,Modifiability,variab,variables,3027,"hich accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap” methods](https://agupubs.onlinelibrary.wiley.com/doi/epdf/10.1029/2019MS001954) (Griffies et al, 2019); * [“z-tilde” GVC used by the NEMO ocean model](https://www.sciencedirect.com/science/article/pii/S1463500311000126?casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (Leclair and Madec 2011); * [Evaluation of various GVC in MPAS-Ocean](https://www.sciencedirect.com/science/article/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:3159,Modifiability,evolve,evolve,3159,"hich accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap” methods](https://agupubs.onlinelibrary.wiley.com/doi/epdf/10.1029/2019MS001954) (Griffies et al, 2019); * [“z-tilde” GVC used by the NEMO ocean model](https://www.sciencedirect.com/science/article/pii/S1463500311000126?casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (Leclair and Madec 2011); * [Evaluation of various GVC in MPAS-Ocean](https://www.sciencedirect.com/science/article/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:3362,Modifiability,variab,variables,3362,"hich accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap” methods](https://agupubs.onlinelibrary.wiley.com/doi/epdf/10.1029/2019MS001954) (Griffies et al, 2019); * [“z-tilde” GVC used by the NEMO ocean model](https://www.sciencedirect.com/science/article/pii/S1463500311000126?casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (Leclair and Madec 2011); * [Evaluation of various GVC in MPAS-Ocean](https://www.sciencedirect.com/science/article/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:4652,Modifiability,adapt,adaptive,4652,"put unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap” methods](https://agupubs.onlinelibrary.wiley.com/doi/epdf/10.1029/2019MS001954) (Griffies et al, 2019); * [“z-tilde” GVC used by the NEMO ocean model](https://www.sciencedirect.com/science/article/pii/S1463500311000126?casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (Leclair and Madec 2011); * [Evaluation of various GVC in MPAS-Ocean](https://www.sciencedirect.com/science/article/pii/S1463500314001796) (Petersen et al 2015); * [GVC in a nonhydrostatic compressible atmospheric model ENDgame](https://rmets.onlinelibrary.wiley.com/doi/full/10.1002/qj.3368) (Kavcic and Thuburn, 2018); * [Correct calculation of pressure gradients in a finite volume model](https://www.sciencedirect.com/science/article/pii/S1463500308000243?casa_token=vsSBQiBsJugAAAAA:GHaDu6afxrLQ4NIdCDiGWl47xClDdYRdM-CSFlZ8kGxQMAOov7vSHAKp_Ch5hQ9OsousvG8sCg) (Adcroft et al 2008); [An “adaptive”, semi-Lagrangian GVC](https://www.sciencedirect.com/science/article/pii/S1463500302000604) (Burchard and Beckers 2004) See also a [3D description](https://www.sciencedirect.com/science/article/pii/S1463500309002248?casa_token=l2d7ijIAiN8AAAAA:kVzMMRqaP2d6U0QDaqB1vqfWKHjIpGWZr0EovdkMJtxHxGSb_xEQ8SlG3OtYkb2mz-6ggmGwGA) (Hofmeister et al 2010) and [realistic test case](https://www.sciencedirect.com/science/article/pii/S1463500311000801?casa_token=CkEoHLOnIxMAAAAA:QWjy9Ck26XOhdWf5K-IaJghogprZ06FDTuCZeORuBO69lWLcRYiWkz4uFtoXRLbfTATnuk932w) (Hofmeister et al 2011); [“z star” GVC in MITgcm](https://www.sciencedirect.com/science/article/pii/S1463500303000544) (Adcroft and Campin 2004)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:874,Safety,avoid,avoid,874,"The equations of motion for most or all major ocean modeling software are implemented using a ""Generalized Vertical Coordinate"" (GVC). Generalized vertical coordinates contain a ""fixed z"" coordinate as a limiting case, but generalize to vertical coordinates that. * Are fixed in time but conform to topographic variations (`σ` coordinates);; * Vary in time in a diagnostic manner (for example, _z-star_ coordinates, which vary with the sea surface displacement);; * Vary in time according to some prognostic equation (fully Lagrangian isopycnal coordinates, semi-Lagrangian hybrid coordinates / _z-tilde_ coordinates that vary only with high frequency motion, and adaptive methods that prescribe GVC dynamics to obtain favorable properties like concentration in regions of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:2038,Safety,avoid,avoid,2038,"otentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:2027,Testability,test,testing,2027,"otentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:2651,Testability,test,test,2651,"ry roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.o",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:5020,Testability,test,test,5020,"put unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap” methods](https://agupubs.onlinelibrary.wiley.com/doi/epdf/10.1029/2019MS001954) (Griffies et al, 2019); * [“z-tilde” GVC used by the NEMO ocean model](https://www.sciencedirect.com/science/article/pii/S1463500311000126?casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (Leclair and Madec 2011); * [Evaluation of various GVC in MPAS-Ocean](https://www.sciencedirect.com/science/article/pii/S1463500314001796) (Petersen et al 2015); * [GVC in a nonhydrostatic compressible atmospheric model ENDgame](https://rmets.onlinelibrary.wiley.com/doi/full/10.1002/qj.3368) (Kavcic and Thuburn, 2018); * [Correct calculation of pressure gradients in a finite volume model](https://www.sciencedirect.com/science/article/pii/S1463500308000243?casa_token=vsSBQiBsJugAAAAA:GHaDu6afxrLQ4NIdCDiGWl47xClDdYRdM-CSFlZ8kGxQMAOov7vSHAKp_Ch5hQ9OsousvG8sCg) (Adcroft et al 2008); [An “adaptive”, semi-Lagrangian GVC](https://www.sciencedirect.com/science/article/pii/S1463500302000604) (Burchard and Beckers 2004) See also a [3D description](https://www.sciencedirect.com/science/article/pii/S1463500309002248?casa_token=l2d7ijIAiN8AAAAA:kVzMMRqaP2d6U0QDaqB1vqfWKHjIpGWZr0EovdkMJtxHxGSb_xEQ8SlG3OtYkb2mz-6ggmGwGA) (Hofmeister et al 2010) and [realistic test case](https://www.sciencedirect.com/science/article/pii/S1463500311000801?casa_token=CkEoHLOnIxMAAAAA:QWjy9Ck26XOhdWf5K-IaJghogprZ06FDTuCZeORuBO69lWLcRYiWkz4uFtoXRLbfTATnuk932w) (Hofmeister et al 2011); [“z star” GVC in MITgcm](https://www.sciencedirect.com/science/article/pii/S1463500303000544) (Adcroft and Campin 2004)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:2365,Usability,simpl,simple,2365," This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variabl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/issues/1679:3050,Usability,simpl,simplifies,3050,"hich accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap” methods](https://agupubs.onlinelibrary.wiley.com/doi/epdf/10.1029/2019MS001954) (Griffies et al, 2019); * [“z-tilde” GVC used by the NEMO ocean model](https://www.sciencedirect.com/science/article/pii/S1463500311000126?casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (Leclair and Madec 2011); * [Evaluation of various GVC in MPAS-Ocean](https://www.sciencedirect.com/science/article/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679
https://github.com/CliMA/Oceananigans.jl/pull/1682:17,Availability,error,errors,17,Right now `show` errors since `ZeroField.grid` is not a struct property.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1682
https://github.com/CliMA/Oceananigans.jl/issues/1684:30,Availability,error,error,30,"Encountered this pretty weird error where `compute!(::AveragedField)` fails when the grid is larger than 22^3. Not sure what's causing it but last thing on the stacktrace in Oceananigans.jl is `sum!` in `mapreduce_abstract_fields.jl` so maybe something changed with `CUDA.mapreducedim!` in v3?. Putting the _high priority_ tag on this issue since it breaks LESbrary.jl pretty badly and I expect other people's scripts too... ```julia; using Oceananigans. # grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1)) # OK; # grid = RegularRectilinearGrid(size=(22, 22, 22), extent=(1, 1, 1)) # OK; # grid = RegularRectilinearGrid(size=(23, 23, 23), extent=(1, 1, 1)) # NOT OK; grid = RegularRectilinearGrid(size=(32, 32, 32), extent=(1, 1, 1)) # NOT OK. model = IncompressibleModel(grid=grid, architecture=GPU()). U = AveragedField(model.velocities.u, dims=(1, 2)); compute!(U); ```. ```; ERROR: MethodError: Cannot `convert` an object of type CUDA.CuDeviceArray{Float64, 4, 1} to an object of type Base.ReshapedArray{Float64, 4, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}} ; Closest candidates are:; convert(::Type{T}, ::LinearAlgebra.Factorization) where T<:AbstractArray at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58; convert(::Type{T}, ::T) where T<:AbstractArray at abstractarray.jl:14; convert(::Type{T}, ::T) where T at essentials.jl:205; ...; Stacktrace:; [1] cconvert(T::Type, x::CUDA.CuDeviceArray{Float64, 4, 1}); @ Base ./essentials.jl:396; [2] macro expansion; @ ~/.julia/packages/CUDA/3VnCC/lib/cudadrv/execution.jl:83 [inlined]; [3] convert_arguments(::CUDA.var""#32#33""{Base.Iterators.Pairs{Symbol, Int64, Tuple{Symbol, Symbol, Symbol}, NamedTuple{(:threads, :blocks, :shmem), Tuple{Int64, Int64, I",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684
https://github.com/CliMA/Oceananigans.jl/issues/1684:896,Availability,ERROR,ERROR,896,"Encountered this pretty weird error where `compute!(::AveragedField)` fails when the grid is larger than 22^3. Not sure what's causing it but last thing on the stacktrace in Oceananigans.jl is `sum!` in `mapreduce_abstract_fields.jl` so maybe something changed with `CUDA.mapreducedim!` in v3?. Putting the _high priority_ tag on this issue since it breaks LESbrary.jl pretty badly and I expect other people's scripts too... ```julia; using Oceananigans. # grid = RegularRectilinearGrid(size=(16, 16, 16), extent=(1, 1, 1)) # OK; # grid = RegularRectilinearGrid(size=(22, 22, 22), extent=(1, 1, 1)) # OK; # grid = RegularRectilinearGrid(size=(23, 23, 23), extent=(1, 1, 1)) # NOT OK; grid = RegularRectilinearGrid(size=(32, 32, 32), extent=(1, 1, 1)) # NOT OK. model = IncompressibleModel(grid=grid, architecture=GPU()). U = AveragedField(model.velocities.u, dims=(1, 2)); compute!(U); ```. ```; ERROR: MethodError: Cannot `convert` an object of type CUDA.CuDeviceArray{Float64, 4, 1} to an object of type Base.ReshapedArray{Float64, 4, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, UnitRange{Int64}, UnitRange{Int64}}, false}, Tuple{Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}, Base.MultiplicativeInverses.SignedMultiplicativeInverse{Int64}}} ; Closest candidates are:; convert(::Type{T}, ::LinearAlgebra.Factorization) where T<:AbstractArray at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.6/LinearAlgebra/src/factorization.jl:58; convert(::Type{T}, ::T) where T<:AbstractArray at abstractarray.jl:14; convert(::Type{T}, ::T) where T at essentials.jl:205; ...; Stacktrace:; [1] cconvert(T::Type, x::CUDA.CuDeviceArray{Float64, 4, 1}); @ Base ./essentials.jl:396; [2] macro expansion; @ ~/.julia/packages/CUDA/3VnCC/lib/cudadrv/execution.jl:83 [inlined]; [3] convert_arguments(::CUDA.var""#32#33""{Base.Iterators.Pairs{Symbol, Int64, Tuple{Symbol, Symbol, Symbol}, NamedTuple{(:threads, :blocks, :shmem), Tuple{Int64, Int64, I",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684
https://github.com/CliMA/Oceananigans.jl/issues/1684:14647,Availability,Down,Downloads,14647, v1.4.1; [69de0a69] Parsers v1.1.0; [0e08944d] PencilArrays v0.9.4; [4a48f351] PencilFFTs v0.12.2; [21216c6a] Preferences v1.2.2; [74087812] Random123 v1.3.1; [e6cf234a] RandomNumbers v1.4.0; [189a3867] Reexport v1.0.0; [ae029012] Requires v1.1.3; [6038ab10] Rotations v1.0.2; [1bc83da4] SafeTestsets v0.0.1; [6c6a2e73] Scratch v1.0.3; [d496a93d] SeawaterPolynomials v0.2.0; [276daf66] SpecialFunctions v1.4.1; [aedffcd0] Static v0.2.4; [90137ffa] StaticArrays v1.2.0; [15972242] StaticPermutations v0.3.0; [09ab397b] StructArrays v0.5.1; [856f2bd8] StructTypes v1.7.2; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.4.2; [6aa5eb33] TaylorSeries v0.10.13; [a759f4b9] TimerOutputs v0.5.9; [3bb67fe8] TranscodingStreams v0.9.5; [bc48ee85] Tullio v0.2.14; [f5851436] FFTW_jll v3.3.9+7; [0234f1f7] HDF5_jll v1.12.0+1; [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2; [856f044c] MKL_jll v2021.1.1+1; [7cb0a576] MPICH_jll v3.3.2+10; [9237b28f] MicrosoftMPI_jll v10.1.3+0; [7243133f] NetCDF_jll v400.702.400+0; [fe0851c0] OpenMPI_jll v4.1.1+0; [458c3c95] OpenSSL_jll v1.1.1+6; [efe28fd5] OpenSpecFun_jll v0.5.4+0; [0dad84c5] ArgTools; [56f22d72] Artifacts; [2a0f44e3] Base64; [ade2ca70] Dates; [8bb1440f] DelimitedFiles; [8ba89e20] Distributed; [f43a241f] Downloads; [b77e0a4c] InteractiveUtils; [4af54fe1] LazyArtifacts; [b27032c2] LibCURL; [76f85450] LibGit2; [8f399da3] Libdl; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [d6f4376e] Markdown; [a63ad114] Mmap; [ca575930] NetworkOptions; [44cfe95a] Pkg; [de0858da] Printf; [3fa0cd96] REPL; [9a3f8284] Random; [ea8e919c] SHA; [9e88b42a] Serialization; [1a1011a3] SharedArrays; [6462fe0b] Sockets; [2f01184e] SparseArrays; [10745b16] Statistics; [fa267f1f] TOML; [a4e569a6] Tar; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; [e66e0078] CompilerSupportLibraries_jll; [deac9b47] LibCURL_jll; [29816b5a] LibSSH2_jll; [c8ffd9c3] MbedTLS_jll; [14a3606d] MozillaCACerts_jll; [83775a58] Zlib_jll; [8e850ede] nghttp2_jll; [3f19e933] p7zip_jll; ```. </details>,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684
https://github.com/CliMA/Oceananigans.jl/issues/1684:6802,Energy Efficiency,reduce,reducedim,6802,", RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}; init::Nothing); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/mapreduce.jl:228; [9] mapreducedim!; @ ~/.julia/packages/CUDA/3VnCC/src/mapreduce.jl:142 [inlined]; [10] mapreducedim!; @ ~/.julia/packages/GPUArrays/Z5nPF/src/host/mapreduce.jl:10 [inlined]; [11] #sum!#699; @ ./reducedim.jl:895 [inlined]; [12] #sum!#53; @ ~/Oceananigans.jl/src/Fields/mapreduce_abstract_fields.jl:14 [inlined]; [13] mean!(R::AveragedField{Nothing, Nothing, Center, Oceananigans.Fields.FieldStatus{Float64}, GPU, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, 2, Field{Face, Center, Center, GPU, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684
https://github.com/CliMA/Oceananigans.jl/issues/1684:12175,Energy Efficiency,Adapt,Adapt,12175,"CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/averaged_field.jl:61; [16] top-level scope; @ REPL[55]:1; [17] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/initialization.jl:81; ```. # Environment. ```; julia> versioninfo(); Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); ```. <details>; <summary>Manifest</summary>. ```; (Oceananigans) pkg> st -m; Project Oceananigans v0.58.1; Status `~/Oceananigans.jl/Manifest.toml`; [621f4979] AbstractFFTs v1.0.1; [79e6a3ab] Adapt v3.3.0; [4fba245c] ArrayInterface v3.1.14; [ab4f0b2a] BFloat16s v0.1.0; [fa961155] CEnum v0.4.1; [179af706] CFTime v0.1.1; [052768ef] CUDA v3.2.1; [72cfdca4] CUDAKernels v0.2.1; [7057c7e9] Cassette v0.3.6; [d360d2e6] ChainRulesCore v0.9.44; [34da2185] Compat v3.30.0; [a8cc5b0e] Crayons v4.0.4; [7445602f] CubedSphere v0.1.0; [9a962f9c] DataAPI v1.6.0; [864edb3b] DataStructures v0.18.9; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.0.2; [ffbed154] DocStringExtensions v0.8.4; [b305315f] Elliptic v1.0.1; [e2ba6199] ExprTools v0.1.3; [7a1cc6ca] FFTW v1.4.1; [5789e2e9] FileIO v1.9.0; [0c68f7d7] GPUArrays v6.4.1; [61eb1bfa] GPUCompiler v0.11.5; [c27321d9] Glob v1.3.0; [615f187c] IfElse v0.1.0; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.6; [692b3bcd] JLLWrappers v1.3.0; [0f8b85d8] JSON3 v1.8.1; [63c18a36] KernelAbstractions v0.6.3; [929cbde3] LLVM v3.7.0; [2ab3a3ac] LogExpFunctions v0.2.4; [da04e1cc] MPI v0.17.2; [1914dd2f] MacroTools v0.5.6; [",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684
https://github.com/CliMA/Oceananigans.jl/issues/1684:12175,Modifiability,Adapt,Adapt,12175,"CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/averaged_field.jl:61; [16] top-level scope; @ REPL[55]:1; [17] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/initialization.jl:81; ```. # Environment. ```; julia> versioninfo(); Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); ```. <details>; <summary>Manifest</summary>. ```; (Oceananigans) pkg> st -m; Project Oceananigans v0.58.1; Status `~/Oceananigans.jl/Manifest.toml`; [621f4979] AbstractFFTs v1.0.1; [79e6a3ab] Adapt v3.3.0; [4fba245c] ArrayInterface v3.1.14; [ab4f0b2a] BFloat16s v0.1.0; [fa961155] CEnum v0.4.1; [179af706] CFTime v0.1.1; [052768ef] CUDA v3.2.1; [72cfdca4] CUDAKernels v0.2.1; [7057c7e9] Cassette v0.3.6; [d360d2e6] ChainRulesCore v0.9.44; [34da2185] Compat v3.30.0; [a8cc5b0e] Crayons v4.0.4; [7445602f] CubedSphere v0.1.0; [9a962f9c] DataAPI v1.6.0; [864edb3b] DataStructures v0.18.9; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.0.2; [ffbed154] DocStringExtensions v0.8.4; [b305315f] Elliptic v1.0.1; [e2ba6199] ExprTools v0.1.3; [7a1cc6ca] FFTW v1.4.1; [5789e2e9] FileIO v1.9.0; [0c68f7d7] GPUArrays v6.4.1; [61eb1bfa] GPUCompiler v0.11.5; [c27321d9] Glob v1.3.0; [615f187c] IfElse v0.1.0; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.6; [692b3bcd] JLLWrappers v1.3.0; [0f8b85d8] JSON3 v1.8.1; [63c18a36] KernelAbstractions v0.6.3; [929cbde3] LLVM v3.7.0; [2ab3a3ac] LogExpFunctions v0.2.4; [da04e1cc] MPI v0.17.2; [1914dd2f] MacroTools v0.5.6; [",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684
https://github.com/CliMA/Oceananigans.jl/issues/1684:13690,Safety,Safe,SafeTestsets,13690,ptic v1.0.1; [e2ba6199] ExprTools v0.1.3; [7a1cc6ca] FFTW v1.4.1; [5789e2e9] FileIO v1.9.0; [0c68f7d7] GPUArrays v6.4.1; [61eb1bfa] GPUCompiler v0.11.5; [c27321d9] Glob v1.3.0; [615f187c] IfElse v0.1.0; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.6; [692b3bcd] JLLWrappers v1.3.0; [0f8b85d8] JSON3 v1.8.1; [63c18a36] KernelAbstractions v0.6.3; [929cbde3] LLVM v3.7.0; [2ab3a3ac] LogExpFunctions v0.2.4; [da04e1cc] MPI v0.17.2; [1914dd2f] MacroTools v0.5.6; [c03570c3] Memoize v0.4.4; [85f8d34a] NCDatasets v0.11.5; [77ba4419] NaNMath v0.3.5; [d0ccf422] Oceanostics v0.3.3 `https://github.com/tomchor/Oceanostics.jl.git#main`; [6fe1bfb0] OffsetArrays v1.8.0; [bac558e1] OrderedCollections v1.4.1; [69de0a69] Parsers v1.1.0; [0e08944d] PencilArrays v0.9.4; [4a48f351] PencilFFTs v0.12.2; [21216c6a] Preferences v1.2.2; [74087812] Random123 v1.3.1; [e6cf234a] RandomNumbers v1.4.0; [189a3867] Reexport v1.0.0; [ae029012] Requires v1.1.3; [6038ab10] Rotations v1.0.2; [1bc83da4] SafeTestsets v0.0.1; [6c6a2e73] Scratch v1.0.3; [d496a93d] SeawaterPolynomials v0.2.0; [276daf66] SpecialFunctions v1.4.1; [aedffcd0] Static v0.2.4; [90137ffa] StaticArrays v1.2.0; [15972242] StaticPermutations v0.3.0; [09ab397b] StructArrays v0.5.1; [856f2bd8] StructTypes v1.7.2; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.4.2; [6aa5eb33] TaylorSeries v0.10.13; [a759f4b9] TimerOutputs v0.5.9; [3bb67fe8] TranscodingStreams v0.9.5; [bc48ee85] Tullio v0.2.14; [f5851436] FFTW_jll v3.3.9+7; [0234f1f7] HDF5_jll v1.12.0+1; [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2; [856f044c] MKL_jll v2021.1.1+1; [7cb0a576] MPICH_jll v3.3.2+10; [9237b28f] MicrosoftMPI_jll v10.1.3+0; [7243133f] NetCDF_jll v400.702.400+0; [fe0851c0] OpenMPI_jll v4.1.1+0; [458c3c95] OpenSSL_jll v1.1.1+6; [efe28fd5] OpenSpecFun_jll v0.5.4+0; [0dad84c5] ArgTools; [56f22d72] Artifacts; [2a0f44e3] Base64; [ade2ca70] Dates; [8bb1440f] DelimitedFiles; [8ba89e20] Distributed; [f43a241f] Downloads; [b77e0a4c] InteractiveUtils; [4af,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684
https://github.com/CliMA/Oceananigans.jl/issues/1684:13094,Testability,Log,LogExpFunctions,13094, `~/Oceananigans.jl/Manifest.toml`; [621f4979] AbstractFFTs v1.0.1; [79e6a3ab] Adapt v3.3.0; [4fba245c] ArrayInterface v3.1.14; [ab4f0b2a] BFloat16s v0.1.0; [fa961155] CEnum v0.4.1; [179af706] CFTime v0.1.1; [052768ef] CUDA v3.2.1; [72cfdca4] CUDAKernels v0.2.1; [7057c7e9] Cassette v0.3.6; [d360d2e6] ChainRulesCore v0.9.44; [34da2185] Compat v3.30.0; [a8cc5b0e] Crayons v4.0.4; [7445602f] CubedSphere v0.1.0; [9a962f9c] DataAPI v1.6.0; [864edb3b] DataStructures v0.18.9; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.0.2; [ffbed154] DocStringExtensions v0.8.4; [b305315f] Elliptic v1.0.1; [e2ba6199] ExprTools v0.1.3; [7a1cc6ca] FFTW v1.4.1; [5789e2e9] FileIO v1.9.0; [0c68f7d7] GPUArrays v6.4.1; [61eb1bfa] GPUCompiler v0.11.5; [c27321d9] Glob v1.3.0; [615f187c] IfElse v0.1.0; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.6; [692b3bcd] JLLWrappers v1.3.0; [0f8b85d8] JSON3 v1.8.1; [63c18a36] KernelAbstractions v0.6.3; [929cbde3] LLVM v3.7.0; [2ab3a3ac] LogExpFunctions v0.2.4; [da04e1cc] MPI v0.17.2; [1914dd2f] MacroTools v0.5.6; [c03570c3] Memoize v0.4.4; [85f8d34a] NCDatasets v0.11.5; [77ba4419] NaNMath v0.3.5; [d0ccf422] Oceanostics v0.3.3 `https://github.com/tomchor/Oceanostics.jl.git#main`; [6fe1bfb0] OffsetArrays v1.8.0; [bac558e1] OrderedCollections v1.4.1; [69de0a69] Parsers v1.1.0; [0e08944d] PencilArrays v0.9.4; [4a48f351] PencilFFTs v0.12.2; [21216c6a] Preferences v1.2.2; [74087812] Random123 v1.3.1; [e6cf234a] RandomNumbers v1.4.0; [189a3867] Reexport v1.0.0; [ae029012] Requires v1.1.3; [6038ab10] Rotations v1.0.2; [1bc83da4] SafeTestsets v0.0.1; [6c6a2e73] Scratch v1.0.3; [d496a93d] SeawaterPolynomials v0.2.0; [276daf66] SpecialFunctions v1.4.1; [aedffcd0] Static v0.2.4; [90137ffa] StaticArrays v1.2.0; [15972242] StaticPermutations v0.3.0; [09ab397b] StructArrays v0.5.1; [856f2bd8] StructTypes v1.7.2; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.4.2; [6aa5eb33] TaylorSeries v0.10.13; [a759f4b9] TimerOutputs v0.5.9; [3,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684
https://github.com/CliMA/Oceananigans.jl/issues/1684:14808,Testability,Log,Logging,14808, v1.4.1; [69de0a69] Parsers v1.1.0; [0e08944d] PencilArrays v0.9.4; [4a48f351] PencilFFTs v0.12.2; [21216c6a] Preferences v1.2.2; [74087812] Random123 v1.3.1; [e6cf234a] RandomNumbers v1.4.0; [189a3867] Reexport v1.0.0; [ae029012] Requires v1.1.3; [6038ab10] Rotations v1.0.2; [1bc83da4] SafeTestsets v0.0.1; [6c6a2e73] Scratch v1.0.3; [d496a93d] SeawaterPolynomials v0.2.0; [276daf66] SpecialFunctions v1.4.1; [aedffcd0] Static v0.2.4; [90137ffa] StaticArrays v1.2.0; [15972242] StaticPermutations v0.3.0; [09ab397b] StructArrays v0.5.1; [856f2bd8] StructTypes v1.7.2; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.4.2; [6aa5eb33] TaylorSeries v0.10.13; [a759f4b9] TimerOutputs v0.5.9; [3bb67fe8] TranscodingStreams v0.9.5; [bc48ee85] Tullio v0.2.14; [f5851436] FFTW_jll v3.3.9+7; [0234f1f7] HDF5_jll v1.12.0+1; [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2; [856f044c] MKL_jll v2021.1.1+1; [7cb0a576] MPICH_jll v3.3.2+10; [9237b28f] MicrosoftMPI_jll v10.1.3+0; [7243133f] NetCDF_jll v400.702.400+0; [fe0851c0] OpenMPI_jll v4.1.1+0; [458c3c95] OpenSSL_jll v1.1.1+6; [efe28fd5] OpenSpecFun_jll v0.5.4+0; [0dad84c5] ArgTools; [56f22d72] Artifacts; [2a0f44e3] Base64; [ade2ca70] Dates; [8bb1440f] DelimitedFiles; [8ba89e20] Distributed; [f43a241f] Downloads; [b77e0a4c] InteractiveUtils; [4af54fe1] LazyArtifacts; [b27032c2] LibCURL; [76f85450] LibGit2; [8f399da3] Libdl; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [d6f4376e] Markdown; [a63ad114] Mmap; [ca575930] NetworkOptions; [44cfe95a] Pkg; [de0858da] Printf; [3fa0cd96] REPL; [9a3f8284] Random; [ea8e919c] SHA; [9e88b42a] Serialization; [1a1011a3] SharedArrays; [6462fe0b] Sockets; [2f01184e] SparseArrays; [10745b16] Statistics; [fa267f1f] TOML; [a4e569a6] Tar; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; [e66e0078] CompilerSupportLibraries_jll; [deac9b47] LibCURL_jll; [29816b5a] LibSSH2_jll; [c8ffd9c3] MbedTLS_jll; [14a3606d] MozillaCACerts_jll; [83775a58] Zlib_jll; [8e850ede] nghttp2_jll; [3f19e933] p7zip_jll; ```. </details>,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684
https://github.com/CliMA/Oceananigans.jl/issues/1684:15132,Testability,Test,Test,15132, v1.4.1; [69de0a69] Parsers v1.1.0; [0e08944d] PencilArrays v0.9.4; [4a48f351] PencilFFTs v0.12.2; [21216c6a] Preferences v1.2.2; [74087812] Random123 v1.3.1; [e6cf234a] RandomNumbers v1.4.0; [189a3867] Reexport v1.0.0; [ae029012] Requires v1.1.3; [6038ab10] Rotations v1.0.2; [1bc83da4] SafeTestsets v0.0.1; [6c6a2e73] Scratch v1.0.3; [d496a93d] SeawaterPolynomials v0.2.0; [276daf66] SpecialFunctions v1.4.1; [aedffcd0] Static v0.2.4; [90137ffa] StaticArrays v1.2.0; [15972242] StaticPermutations v0.3.0; [09ab397b] StructArrays v0.5.1; [856f2bd8] StructTypes v1.7.2; [3783bdb8] TableTraits v1.0.1; [bd369af6] Tables v1.4.2; [6aa5eb33] TaylorSeries v0.10.13; [a759f4b9] TimerOutputs v0.5.9; [3bb67fe8] TranscodingStreams v0.9.5; [bc48ee85] Tullio v0.2.14; [f5851436] FFTW_jll v3.3.9+7; [0234f1f7] HDF5_jll v1.12.0+1; [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2; [856f044c] MKL_jll v2021.1.1+1; [7cb0a576] MPICH_jll v3.3.2+10; [9237b28f] MicrosoftMPI_jll v10.1.3+0; [7243133f] NetCDF_jll v400.702.400+0; [fe0851c0] OpenMPI_jll v4.1.1+0; [458c3c95] OpenSSL_jll v1.1.1+6; [efe28fd5] OpenSpecFun_jll v0.5.4+0; [0dad84c5] ArgTools; [56f22d72] Artifacts; [2a0f44e3] Base64; [ade2ca70] Dates; [8bb1440f] DelimitedFiles; [8ba89e20] Distributed; [f43a241f] Downloads; [b77e0a4c] InteractiveUtils; [4af54fe1] LazyArtifacts; [b27032c2] LibCURL; [76f85450] LibGit2; [8f399da3] Libdl; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [d6f4376e] Markdown; [a63ad114] Mmap; [ca575930] NetworkOptions; [44cfe95a] Pkg; [de0858da] Printf; [3fa0cd96] REPL; [9a3f8284] Random; [ea8e919c] SHA; [9e88b42a] Serialization; [1a1011a3] SharedArrays; [6462fe0b] Sockets; [2f01184e] SparseArrays; [10745b16] Statistics; [fa267f1f] TOML; [a4e569a6] Tar; [8dfed614] Test; [cf7118a7] UUIDs; [4ec0a83e] Unicode; [e66e0078] CompilerSupportLibraries_jll; [deac9b47] LibCURL_jll; [29816b5a] LibSSH2_jll; [c8ffd9c3] MbedTLS_jll; [14a3606d] MozillaCACerts_jll; [83775a58] Zlib_jll; [8e850ede] nghttp2_jll; [3f19e933] p7zip_jll; ```. </details>,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684
https://github.com/CliMA/Oceananigans.jl/pull/1688:75,Availability,toler,tolerance,75,This tests also fails intermittently due to being slightly above the tight tolerance: https://buildkite.com/clima/oceananigans/builds/2660#fdbc1bf9-350b-4051-9977-5ec4683ca080/22-534,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1688
https://github.com/CliMA/Oceananigans.jl/pull/1688:5,Testability,test,tests,5,This tests also fails intermittently due to being slightly above the tight tolerance: https://buildkite.com/clima/oceananigans/builds/2660#fdbc1bf9-350b-4051-9977-5ec4683ca080/22-534,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1688
https://github.com/CliMA/Oceananigans.jl/pull/1689:55,Availability,toler,tolerance,55,It's still failing intermittently after increasing the tolerance in PR #1686: https://buildkite.com/clima/oceananigans/builds/2672#74321ab5-528f-48c2-bd0c-5ab006881fd3/22-2077,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1689
https://github.com/CliMA/Oceananigans.jl/pull/1690:104,Availability,down,down,104,This PR restructures the Physics section of the Docs so that equations solved by each model are written down. Preview of the docs: http://clima.github.io/OceananigansDocumentation/previews/PR1690. Closes #1460.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1690
https://github.com/CliMA/Oceananigans.jl/pull/1692:175,Testability,test,tested,175,"This pull request changes the compat entry for the `MPI` package from `0.16, 0.17` to `0.16, 0.17, 0.18`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1692
https://github.com/CliMA/Oceananigans.jl/pull/1692:280,Testability,test,tests,280,"This pull request changes the compat entry for the `MPI` package from `0.16, 0.17` to `0.16, 0.17, 0.18`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1692
https://github.com/CliMA/Oceananigans.jl/issues/1693:67,Availability,down,downwards,67,"Hydrostatic pressure is _supposed to be_ calculated by integrating downwards using a stencil in which pressure is located at `(Center, Center, Center)`. This requires interpolating buoyancy to `(Center, Center, Face)`. However, in the kernel of the integral, the buoyancy is multiplied by `Δzᵃᵃᶜ(i, j, k+1, grid)`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Models/IncompressibleModels/update_hydrostatic_pressure.jl#L15. This isn't the correct kernel if the integral corresponds to a discretization of the hydrostatic pressure term in the vertical momentum equation (omitting `i, j` for brevity) using a pressure field `p` located at (`Center, Center, Center`):. ```julia; (p[k] - p[k-1]) / Δzᵃᵃᶠ[k] = ℑzᵃᵃᶠ(k, b); ```. In other words, differencing a field at vertical `Center` requires dividing by `Δzᵃᵃᶠ`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Operators/derivative_operators.jl#L12. Another way to view the error is that we are multiplying a field located at `Center, Center, Face` by a grid metric located at `Center, Center, Center`. Possibly this error crept into the code due to a confusion about the superscript notation (there have been a few others of this nature). I'm not sure if it's easily caught; it probably depends on the importance of a horizontally-variable hydrostatic pressure.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1693
https://github.com/CliMA/Oceananigans.jl/issues/1693:1013,Availability,error,error,1013,"Hydrostatic pressure is _supposed to be_ calculated by integrating downwards using a stencil in which pressure is located at `(Center, Center, Center)`. This requires interpolating buoyancy to `(Center, Center, Face)`. However, in the kernel of the integral, the buoyancy is multiplied by `Δzᵃᵃᶜ(i, j, k+1, grid)`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Models/IncompressibleModels/update_hydrostatic_pressure.jl#L15. This isn't the correct kernel if the integral corresponds to a discretization of the hydrostatic pressure term in the vertical momentum equation (omitting `i, j` for brevity) using a pressure field `p` located at (`Center, Center, Center`):. ```julia; (p[k] - p[k-1]) / Δzᵃᵃᶠ[k] = ℑzᵃᵃᶠ(k, b); ```. In other words, differencing a field at vertical `Center` requires dividing by `Δzᵃᵃᶠ`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Operators/derivative_operators.jl#L12. Another way to view the error is that we are multiplying a field located at `Center, Center, Face` by a grid metric located at `Center, Center, Center`. Possibly this error crept into the code due to a confusion about the superscript notation (there have been a few others of this nature). I'm not sure if it's easily caught; it probably depends on the importance of a horizontally-variable hydrostatic pressure.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1693
https://github.com/CliMA/Oceananigans.jl/issues/1693:1156,Availability,error,error,1156,"Hydrostatic pressure is _supposed to be_ calculated by integrating downwards using a stencil in which pressure is located at `(Center, Center, Center)`. This requires interpolating buoyancy to `(Center, Center, Face)`. However, in the kernel of the integral, the buoyancy is multiplied by `Δzᵃᵃᶜ(i, j, k+1, grid)`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Models/IncompressibleModels/update_hydrostatic_pressure.jl#L15. This isn't the correct kernel if the integral corresponds to a discretization of the hydrostatic pressure term in the vertical momentum equation (omitting `i, j` for brevity) using a pressure field `p` located at (`Center, Center, Center`):. ```julia; (p[k] - p[k-1]) / Δzᵃᵃᶠ[k] = ℑzᵃᵃᶠ(k, b); ```. In other words, differencing a field at vertical `Center` requires dividing by `Δzᵃᵃᶠ`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Operators/derivative_operators.jl#L12. Another way to view the error is that we are multiplying a field located at `Center, Center, Face` by a grid metric located at `Center, Center, Center`. Possibly this error crept into the code due to a confusion about the superscript notation (there have been a few others of this nature). I'm not sure if it's easily caught; it probably depends on the importance of a horizontally-variable hydrostatic pressure.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1693
https://github.com/CliMA/Oceananigans.jl/issues/1693:55,Deployability,integrat,integrating,55,"Hydrostatic pressure is _supposed to be_ calculated by integrating downwards using a stencil in which pressure is located at `(Center, Center, Center)`. This requires interpolating buoyancy to `(Center, Center, Face)`. However, in the kernel of the integral, the buoyancy is multiplied by `Δzᵃᵃᶜ(i, j, k+1, grid)`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Models/IncompressibleModels/update_hydrostatic_pressure.jl#L15. This isn't the correct kernel if the integral corresponds to a discretization of the hydrostatic pressure term in the vertical momentum equation (omitting `i, j` for brevity) using a pressure field `p` located at (`Center, Center, Center`):. ```julia; (p[k] - p[k-1]) / Δzᵃᵃᶠ[k] = ℑzᵃᵃᶠ(k, b); ```. In other words, differencing a field at vertical `Center` requires dividing by `Δzᵃᵃᶠ`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Operators/derivative_operators.jl#L12. Another way to view the error is that we are multiplying a field located at `Center, Center, Face` by a grid metric located at `Center, Center, Center`. Possibly this error crept into the code due to a confusion about the superscript notation (there have been a few others of this nature). I'm not sure if it's easily caught; it probably depends on the importance of a horizontally-variable hydrostatic pressure.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1693
https://github.com/CliMA/Oceananigans.jl/issues/1693:55,Integrability,integrat,integrating,55,"Hydrostatic pressure is _supposed to be_ calculated by integrating downwards using a stencil in which pressure is located at `(Center, Center, Center)`. This requires interpolating buoyancy to `(Center, Center, Face)`. However, in the kernel of the integral, the buoyancy is multiplied by `Δzᵃᵃᶜ(i, j, k+1, grid)`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Models/IncompressibleModels/update_hydrostatic_pressure.jl#L15. This isn't the correct kernel if the integral corresponds to a discretization of the hydrostatic pressure term in the vertical momentum equation (omitting `i, j` for brevity) using a pressure field `p` located at (`Center, Center, Center`):. ```julia; (p[k] - p[k-1]) / Δzᵃᵃᶠ[k] = ℑzᵃᵃᶠ(k, b); ```. In other words, differencing a field at vertical `Center` requires dividing by `Δzᵃᵃᶠ`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Operators/derivative_operators.jl#L12. Another way to view the error is that we are multiplying a field located at `Center, Center, Face` by a grid metric located at `Center, Center, Center`. Possibly this error crept into the code due to a confusion about the superscript notation (there have been a few others of this nature). I'm not sure if it's easily caught; it probably depends on the importance of a horizontally-variable hydrostatic pressure.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1693
https://github.com/CliMA/Oceananigans.jl/issues/1693:1327,Integrability,depend,depends,1327,"Hydrostatic pressure is _supposed to be_ calculated by integrating downwards using a stencil in which pressure is located at `(Center, Center, Center)`. This requires interpolating buoyancy to `(Center, Center, Face)`. However, in the kernel of the integral, the buoyancy is multiplied by `Δzᵃᵃᶜ(i, j, k+1, grid)`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Models/IncompressibleModels/update_hydrostatic_pressure.jl#L15. This isn't the correct kernel if the integral corresponds to a discretization of the hydrostatic pressure term in the vertical momentum equation (omitting `i, j` for brevity) using a pressure field `p` located at (`Center, Center, Center`):. ```julia; (p[k] - p[k-1]) / Δzᵃᵃᶠ[k] = ℑzᵃᵃᶠ(k, b); ```. In other words, differencing a field at vertical `Center` requires dividing by `Δzᵃᵃᶠ`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Operators/derivative_operators.jl#L12. Another way to view the error is that we are multiplying a field located at `Center, Center, Face` by a grid metric located at `Center, Center, Center`. Possibly this error crept into the code due to a confusion about the superscript notation (there have been a few others of this nature). I'm not sure if it's easily caught; it probably depends on the importance of a horizontally-variable hydrostatic pressure.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1693
https://github.com/CliMA/Oceananigans.jl/issues/1693:1371,Modifiability,variab,variable,1371,"Hydrostatic pressure is _supposed to be_ calculated by integrating downwards using a stencil in which pressure is located at `(Center, Center, Center)`. This requires interpolating buoyancy to `(Center, Center, Face)`. However, in the kernel of the integral, the buoyancy is multiplied by `Δzᵃᵃᶜ(i, j, k+1, grid)`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Models/IncompressibleModels/update_hydrostatic_pressure.jl#L15. This isn't the correct kernel if the integral corresponds to a discretization of the hydrostatic pressure term in the vertical momentum equation (omitting `i, j` for brevity) using a pressure field `p` located at (`Center, Center, Center`):. ```julia; (p[k] - p[k-1]) / Δzᵃᵃᶠ[k] = ℑzᵃᵃᶠ(k, b); ```. In other words, differencing a field at vertical `Center` requires dividing by `Δzᵃᵃᶠ`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Operators/derivative_operators.jl#L12. Another way to view the error is that we are multiplying a field located at `Center, Center, Face` by a grid metric located at `Center, Center, Center`. Possibly this error crept into the code due to a confusion about the superscript notation (there have been a few others of this nature). I'm not sure if it's easily caught; it probably depends on the importance of a horizontally-variable hydrostatic pressure.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1693
https://github.com/CliMA/Oceananigans.jl/issues/1694:37,Security,validat,validation,37,Should we promote the [internal tide validation experiment](https://github.com/CliMA/Oceananigans.jl/blob/master/validation/immersed_boundaries/internal_tide.jl) to a literate one that goes into the docs?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1694
https://github.com/CliMA/Oceananigans.jl/issues/1694:113,Security,validat,validation,113,Should we promote the [internal tide validation experiment](https://github.com/CliMA/Oceananigans.jl/blob/master/validation/immersed_boundaries/internal_tide.jl) to a literate one that goes into the docs?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1694
https://github.com/CliMA/Oceananigans.jl/issues/1695:494,Modifiability,Parameteriz,Parameterize,494,"There's a number of changes we should make to `TKEBasedVerticalDiffusivity` that might make parameter estimation easier:. * Pull out a single “bulk” scaling parameter from the diffusivity scalings rather than using two independent scales for Ri -> -infty and Ri -> + infty; * Identify one diffusivity as “primary” (eg tracer diffusivities), and formulate the other diffusivities in terms of the ratio between the primary diffusivity (eg, using Prandtl numbers rather than raw diffusivities); * Parameterize the diffusivity scaling functions in terms of a “-” and “delta” rather than “-” and “+” value. Eventually we want to embed a convective adjustment ""submodel"" in `TKEBasedVerticalDiffusivity`; in this we want to write the convective adjustment diffusivity as a “correction” to the ""primary"" diffusivity. cc @adelinehillier",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1695
https://github.com/CliMA/Oceananigans.jl/issues/1696:4,Security,Validat,Validation,4,"The Validation experiments in the Docs is very incomplete. I suggest we nuke it? Perhaps just leave the convergence tests page there and rename it to ""Convergence Tests""?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1696
https://github.com/CliMA/Oceananigans.jl/issues/1696:116,Testability,test,tests,116,"The Validation experiments in the Docs is very incomplete. I suggest we nuke it? Perhaps just leave the convergence tests page there and rename it to ""Convergence Tests""?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1696
https://github.com/CliMA/Oceananigans.jl/issues/1696:163,Testability,Test,Tests,163,"The Validation experiments in the Docs is very incomplete. I suggest we nuke it? Perhaps just leave the convergence tests page there and rename it to ""Convergence Tests""?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1696
https://github.com/CliMA/Oceananigans.jl/pull/1700:138,Testability,test,tests,138,Some intermediate commits from last week attempting to subtype `AbstractField <: DimensionalData.AbstractDimArray` but needs more work as tests are failing. Resolves #457; Works on (partially resolves?) #1493,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1700
https://github.com/CliMA/Oceananigans.jl/issues/1702:23,Availability,error,error,23,Probably due to a sign error in flux divergence according to @glwagner,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1702
https://github.com/CliMA/Oceananigans.jl/pull/1703:657,Availability,error,error,657,"Resolves #1702 noticed by @mukund-gupta . In a [previous PR](https://github.com/CliMA/Oceananigans.jl/commit/3afd5b59fce91f9ab4aa6d0d19cd64fef7aea4cf#) we changed the notation of the closure term to indicate that it's the divergence of a flux, rather than specifically the divergence of a _viscous_ or _diffusive_ flux. This notational change required us to change the term's sign. Specifically, we used the redefinition. ```; ∂ⱼ_2ν_Σ₁ⱼ = - ∂ⱼ_τ₁ⱼ; ```. for the diffusive flux of x-momentum. However, we did not change the sign of the flux divergence for `AnisotropicBiharmonicDiffusivity`; we only changed the _name_ of the term. This PR corrects the sign error. There are a few closures that don't have regression tests and this highlights the danger of that.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1703
https://github.com/CliMA/Oceananigans.jl/pull/1703:716,Testability,test,tests,716,"Resolves #1702 noticed by @mukund-gupta . In a [previous PR](https://github.com/CliMA/Oceananigans.jl/commit/3afd5b59fce91f9ab4aa6d0d19cd64fef7aea4cf#) we changed the notation of the closure term to indicate that it's the divergence of a flux, rather than specifically the divergence of a _viscous_ or _diffusive_ flux. This notational change required us to change the term's sign. Specifically, we used the redefinition. ```; ∂ⱼ_2ν_Σ₁ⱼ = - ∂ⱼ_τ₁ⱼ; ```. for the diffusive flux of x-momentum. However, we did not change the sign of the flux divergence for `AnisotropicBiharmonicDiffusivity`; we only changed the _name_ of the term. This PR corrects the sign error. There are a few closures that don't have regression tests and this highlights the danger of that.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1703
https://github.com/CliMA/Oceananigans.jl/issues/1704:38,Performance,perform,performance,38,In [A simple algorithm to improve the performance of the WENO scheme on non-uniform grids](https://link.springer.com/article/10.1007/s10409-017-0715-2) a simple method for generalizing WENO stencils for stretched grids is described. This scheme is easy to implement and limits to what we already have implemented in the case of a regular grid.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1704
https://github.com/CliMA/Oceananigans.jl/issues/1704:6,Usability,simpl,simple,6,In [A simple algorithm to improve the performance of the WENO scheme on non-uniform grids](https://link.springer.com/article/10.1007/s10409-017-0715-2) a simple method for generalizing WENO stencils for stretched grids is described. This scheme is easy to implement and limits to what we already have implemented in the case of a regular grid.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1704
https://github.com/CliMA/Oceananigans.jl/issues/1704:154,Usability,simpl,simple,154,In [A simple algorithm to improve the performance of the WENO scheme on non-uniform grids](https://link.springer.com/article/10.1007/s10409-017-0715-2) a simple method for generalizing WENO stencils for stretched grids is described. This scheme is easy to implement and limits to what we already have implemented in the case of a regular grid.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1704
https://github.com/CliMA/Oceananigans.jl/issues/1706:228,Availability,ERROR,ERROR,228,"Not sure if this means we cannot use PowerPC/Satori for now?. ```julia; julia> using Oceananigans. julia> IncompressibleModel(architecture=GPU(), grid=RegularRectilinearGrid(size=(32, 32, 32), extent=(1, 1, 1))); ```. ```julia; ERROR: cfunction: closures are not supported on this platform; Stacktrace:; [1] compile_method_instance(job::GPUCompiler.CompilerJob, method_instance::Core.MethodInstance); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/jlgen.jl:325; [2] macro expansion; @ ~/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [3] irgen(job::GPUCompiler.CompilerJob, method_instance::Core.MethodInstance); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/irgen.jl:4; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:142 [inlined]; [5] macro expansion; @ ~/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [6] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:141 [inlined]; [7] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64; libraries::Bool, deferred_codegen::Bool, optimize::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:62; [8] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:60; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:300; [10] check_cache; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/cache.jl:47 [inlined]; [11] cached_compilation; @ ~/.julia/packages/GPUArrays/Z5nPF/src/host/broadcast.jl:57 [inlined]; [12] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{GPUArrays.var""#broadcast_kernel#16"", Tuple{CUDA.CuKernelContext, CUDA.CuDeviceArray{Float64, 3, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneT",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706
https://github.com/CliMA/Oceananigans.jl/issues/1706:7680,Availability,avail,available,7680,"forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Tuple{Symbol, Symbol}, timestepper::Symbol, background_fields::NamedTuple{(), Tuple{}}, particles::Nothing, velocities::Nothing, pressures::Nothing, diffusivities::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing); @ Oceananigans.Models.IncompressibleModels ~/.julia/packages/Oceananigans/IxOwr/src/Models/IncompressibleModels/incompressible_model.jl:142; [28] top-level scope; @ REPL[4]:1; [29] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/initialization.jl:81; ```. # Environment. ```julia; julia> versioninfo(); Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); ```. ```julia; julia> CUDA.versioninfo(); CUDA toolkit 10.1.243, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.1; - CUFFT: 10.1.1; - CUSOLVER: 10.2.0; - CUSPARSE: 10.3.0; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; ┌ Warning: Could not find or load CUDNN; run with JULIA_DEBUG=CUDA for more details.; └ @ CUDA ~/.julia/packages/CUDA/3VnCC/deps/bindeps.jl:354; - CUDNN: missing; ┌ Warning: Could not find or load CUTENSOR; run with JULIA_DEBUG=CUDA for more details.; └ @ CUDA ~/.julia/packages/CUDA/3VnCC/deps/bindeps.jl:409; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.1; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4; - Device support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 29.284 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 24.457 GiB / 31.749 GiB available); ```. ```julia; (@v1.6) pkg> st; Status `~/.julia/environments/v1.6/Project.toml`; [052768ef] CUDA v3.2.1; [13f3f980] CairoMakie v0.5.2; [9e8cae18] Oceananigans v0.58.1; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706
https://github.com/CliMA/Oceananigans.jl/issues/1706:7748,Availability,avail,available,7748,"forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Tuple{Symbol, Symbol}, timestepper::Symbol, background_fields::NamedTuple{(), Tuple{}}, particles::Nothing, velocities::Nothing, pressures::Nothing, diffusivities::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing); @ Oceananigans.Models.IncompressibleModels ~/.julia/packages/Oceananigans/IxOwr/src/Models/IncompressibleModels/incompressible_model.jl:142; [28] top-level scope; @ REPL[4]:1; [29] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/initialization.jl:81; ```. # Environment. ```julia; julia> versioninfo(); Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); ```. ```julia; julia> CUDA.versioninfo(); CUDA toolkit 10.1.243, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.1; - CUFFT: 10.1.1; - CUSOLVER: 10.2.0; - CUSPARSE: 10.3.0; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; ┌ Warning: Could not find or load CUDNN; run with JULIA_DEBUG=CUDA for more details.; └ @ CUDA ~/.julia/packages/CUDA/3VnCC/deps/bindeps.jl:354; - CUDNN: missing; ┌ Warning: Could not find or load CUTENSOR; run with JULIA_DEBUG=CUDA for more details.; └ @ CUDA ~/.julia/packages/CUDA/3VnCC/deps/bindeps.jl:409; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.1; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4; - Device support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 29.284 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 24.457 GiB / 31.749 GiB available); ```. ```julia; (@v1.6) pkg> st; Status `~/.julia/environments/v1.6/Project.toml`; [052768ef] CUDA v3.2.1; [13f3f980] CairoMakie v0.5.2; [9e8cae18] Oceananigans v0.58.1; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706
https://github.com/CliMA/Oceananigans.jl/issues/1706:6852,Deployability,install,installation,6852,".BuoyancyModels.ZDirection}, coriolis::Nothing, stokes_drift::Nothing, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Tuple{Symbol, Symbol}, timestepper::Symbol, background_fields::NamedTuple{(), Tuple{}}, particles::Nothing, velocities::Nothing, pressures::Nothing, diffusivities::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing); @ Oceananigans.Models.IncompressibleModels ~/.julia/packages/Oceananigans/IxOwr/src/Models/IncompressibleModels/incompressible_model.jl:142; [28] top-level scope; @ REPL[4]:1; [29] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/initialization.jl:81; ```. # Environment. ```julia; julia> versioninfo(); Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); ```. ```julia; julia> CUDA.versioninfo(); CUDA toolkit 10.1.243, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.1; - CUFFT: 10.1.1; - CUSOLVER: 10.2.0; - CUSPARSE: 10.3.0; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; ┌ Warning: Could not find or load CUDNN; run with JULIA_DEBUG=CUDA for more details.; └ @ CUDA ~/.julia/packages/CUDA/3VnCC/deps/bindeps.jl:354; - CUDNN: missing; ┌ Warning: Could not find or load CUTENSOR; run with JULIA_DEBUG=CUDA for more details.; └ @ CUDA ~/.julia/packages/CUDA/3VnCC/deps/bindeps.jl:409; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.1; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4; - Device support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 29.284 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 24.457 GiB / 31.749 GiB available); ```. ```julia; (@v1.6) pkg> st; Status `~/.julia/environments/v1.6/Project.toml`; [052768ef] CUDA v3.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706
https://github.com/CliMA/Oceananigans.jl/issues/1706:37,Energy Efficiency,Power,PowerPC,37,"Not sure if this means we cannot use PowerPC/Satori for now?. ```julia; julia> using Oceananigans. julia> IncompressibleModel(architecture=GPU(), grid=RegularRectilinearGrid(size=(32, 32, 32), extent=(1, 1, 1))); ```. ```julia; ERROR: cfunction: closures are not supported on this platform; Stacktrace:; [1] compile_method_instance(job::GPUCompiler.CompilerJob, method_instance::Core.MethodInstance); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/jlgen.jl:325; [2] macro expansion; @ ~/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [3] irgen(job::GPUCompiler.CompilerJob, method_instance::Core.MethodInstance); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/irgen.jl:4; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:142 [inlined]; [5] macro expansion; @ ~/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [6] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:141 [inlined]; [7] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64; libraries::Bool, deferred_codegen::Bool, optimize::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:62; [8] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:60; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:300; [10] check_cache; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/cache.jl:47 [inlined]; [11] cached_compilation; @ ~/.julia/packages/GPUArrays/Z5nPF/src/host/broadcast.jl:57 [inlined]; [12] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{GPUArrays.var""#broadcast_kernel#16"", Tuple{CUDA.CuKernelContext, CUDA.CuDeviceArray{Float64, 3, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneT",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706
https://github.com/CliMA/Oceananigans.jl/issues/1706:1100,Performance,optimiz,optimize,1100,"sing Oceananigans. julia> IncompressibleModel(architecture=GPU(), grid=RegularRectilinearGrid(size=(32, 32, 32), extent=(1, 1, 1))); ```. ```julia; ERROR: cfunction: closures are not supported on this platform; Stacktrace:; [1] compile_method_instance(job::GPUCompiler.CompilerJob, method_instance::Core.MethodInstance); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/jlgen.jl:325; [2] macro expansion; @ ~/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [3] irgen(job::GPUCompiler.CompilerJob, method_instance::Core.MethodInstance); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/irgen.jl:4; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:142 [inlined]; [5] macro expansion; @ ~/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [6] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:141 [inlined]; [7] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64; libraries::Bool, deferred_codegen::Bool, optimize::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:62; [8] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:60; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:300; [10] check_cache; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/cache.jl:47 [inlined]; [11] cached_compilation; @ ~/.julia/packages/GPUArrays/Z5nPF/src/host/broadcast.jl:57 [inlined]; [12] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{GPUArrays.var""#broadcast_kernel#16"", Tuple{CUDA.CuKernelContext, CUDA.CuDeviceArray{Float64, 3, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Int64}}, Int64}}}, compiler::typeof(CUDA.cufu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706
https://github.com/CliMA/Oceananigans.jl/issues/1706:1532,Performance,cache,cache,1532,"utputs/PZq45/src/TimerOutput.jl:226 [inlined]; [3] irgen(job::GPUCompiler.CompilerJob, method_instance::Core.MethodInstance); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/irgen.jl:4; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:142 [inlined]; [5] macro expansion; @ ~/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [6] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:141 [inlined]; [7] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64; libraries::Bool, deferred_codegen::Bool, optimize::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:62; [8] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:60; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:300; [10] check_cache; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/cache.jl:47 [inlined]; [11] cached_compilation; @ ~/.julia/packages/GPUArrays/Z5nPF/src/host/broadcast.jl:57 [inlined]; [12] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{GPUArrays.var""#broadcast_kernel#16"", Tuple{CUDA.CuKernelContext, CUDA.CuDeviceArray{Float64, 3, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Int64}}, Int64}}}, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/cache.jl:0; [13] cufunction(f::GPUArrays.var""#broadcast_kernel#16"", tt::Type{Tuple{CUDA.CuKernelContext, CUDA.CuDeviceArray{Float64, 3, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Int64}}, Int64}}; name::Nothing, kwargs::Base.Iterators.Pairs{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706
https://github.com/CliMA/Oceananigans.jl/issues/1706:1676,Performance,cache,cache,1676,"Compiler/eJOtJ/src/irgen.jl:4; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:142 [inlined]; [5] macro expansion; @ ~/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [6] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:141 [inlined]; [7] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64; libraries::Bool, deferred_codegen::Bool, optimize::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:62; [8] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:60; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:300; [10] check_cache; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/cache.jl:47 [inlined]; [11] cached_compilation; @ ~/.julia/packages/GPUArrays/Z5nPF/src/host/broadcast.jl:57 [inlined]; [12] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{GPUArrays.var""#broadcast_kernel#16"", Tuple{CUDA.CuKernelContext, CUDA.CuDeviceArray{Float64, 3, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Int64}}, Int64}}}, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/cache.jl:0; [13] cufunction(f::GPUArrays.var""#broadcast_kernel#16"", tt::Type{Tuple{CUDA.CuKernelContext, CUDA.CuDeviceArray{Float64, 3, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Int64}}, Int64}}; name::Nothing, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:289; [14] cufunction; @ ~/.julia/packages/CU",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706
https://github.com/CliMA/Oceananigans.jl/issues/1706:2191,Performance,cache,cache,2191,"ler/eJOtJ/src/utils.jl:62; [8] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:60; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:300; [10] check_cache; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/cache.jl:47 [inlined]; [11] cached_compilation; @ ~/.julia/packages/GPUArrays/Z5nPF/src/host/broadcast.jl:57 [inlined]; [12] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{GPUArrays.var""#broadcast_kernel#16"", Tuple{CUDA.CuKernelContext, CUDA.CuDeviceArray{Float64, 3, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Int64}}, Int64}}}, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/cache.jl:0; [13] cufunction(f::GPUArrays.var""#broadcast_kernel#16"", tt::Type{Tuple{CUDA.CuKernelContext, CUDA.CuDeviceArray{Float64, 3, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Int64}}, Int64}}; name::Nothing, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:289; [14] cufunction; @ ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:283 [inlined]; [15] macro expansion; @ ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:102 [inlined]; [16] #launch_heuristic#286; @ ~/.julia/packages/CUDA/3VnCC/src/gpuarrays.jl:17 [inlined]; [17] launch_heuristic; @ ~/.julia/packages/CUDA/3VnCC/src/gpuarrays.jl:17 [inlined]; [18] copyto!; @ ~/.julia/packages/GPUArrays/Z5nPF/src/host/broadcast.jl:63 [inlined]; [19] copyto!; @ ~/.julia/packages/GPUArrays/Z5nPF/src/host/broadcast.jl:73 [inlined]; [20] mat",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706
https://github.com/CliMA/Oceananigans.jl/issues/1706:7087,Performance,load,load,7087,"forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Tuple{Symbol, Symbol}, timestepper::Symbol, background_fields::NamedTuple{(), Tuple{}}, particles::Nothing, velocities::Nothing, pressures::Nothing, diffusivities::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing); @ Oceananigans.Models.IncompressibleModels ~/.julia/packages/Oceananigans/IxOwr/src/Models/IncompressibleModels/incompressible_model.jl:142; [28] top-level scope; @ REPL[4]:1; [29] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/initialization.jl:81; ```. # Environment. ```julia; julia> versioninfo(); Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); ```. ```julia; julia> CUDA.versioninfo(); CUDA toolkit 10.1.243, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.1; - CUFFT: 10.1.1; - CUSOLVER: 10.2.0; - CUSPARSE: 10.3.0; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; ┌ Warning: Could not find or load CUDNN; run with JULIA_DEBUG=CUDA for more details.; └ @ CUDA ~/.julia/packages/CUDA/3VnCC/deps/bindeps.jl:354; - CUDNN: missing; ┌ Warning: Could not find or load CUTENSOR; run with JULIA_DEBUG=CUDA for more details.; └ @ CUDA ~/.julia/packages/CUDA/3VnCC/deps/bindeps.jl:409; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.1; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4; - Device support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 29.284 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 24.457 GiB / 31.749 GiB available); ```. ```julia; (@v1.6) pkg> st; Status `~/.julia/environments/v1.6/Project.toml`; [052768ef] CUDA v3.2.1; [13f3f980] CairoMakie v0.5.2; [9e8cae18] Oceananigans v0.58.1; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706
https://github.com/CliMA/Oceananigans.jl/issues/1706:7250,Performance,load,load,7250,"forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Tuple{Symbol, Symbol}, timestepper::Symbol, background_fields::NamedTuple{(), Tuple{}}, particles::Nothing, velocities::Nothing, pressures::Nothing, diffusivities::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing); @ Oceananigans.Models.IncompressibleModels ~/.julia/packages/Oceananigans/IxOwr/src/Models/IncompressibleModels/incompressible_model.jl:142; [28] top-level scope; @ REPL[4]:1; [29] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/initialization.jl:81; ```. # Environment. ```julia; julia> versioninfo(); Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); ```. ```julia; julia> CUDA.versioninfo(); CUDA toolkit 10.1.243, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.1; - CUFFT: 10.1.1; - CUSOLVER: 10.2.0; - CUSPARSE: 10.3.0; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; ┌ Warning: Could not find or load CUDNN; run with JULIA_DEBUG=CUDA for more details.; └ @ CUDA ~/.julia/packages/CUDA/3VnCC/deps/bindeps.jl:354; - CUDNN: missing; ┌ Warning: Could not find or load CUTENSOR; run with JULIA_DEBUG=CUDA for more details.; └ @ CUDA ~/.julia/packages/CUDA/3VnCC/deps/bindeps.jl:409; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.1; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4; - Device support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 29.284 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 24.457 GiB / 31.749 GiB available); ```. ```julia; (@v1.6) pkg> st; Status `~/.julia/environments/v1.6/Project.toml`; [052768ef] CUDA v3.2.1; [13f3f980] CairoMakie v0.5.2; [9e8cae18] Oceananigans v0.58.1; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706
https://github.com/CliMA/Oceananigans.jl/pull/1707:8,Deployability,update,updates,8,This PR updates the instructions for building docs locally. We should avoid `Pkg.develop()` since we are offering a `docs/Manifest.toml`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707
https://github.com/CliMA/Oceananigans.jl/pull/1707:70,Safety,avoid,avoid,70,This PR updates the instructions for building docs locally. We should avoid `Pkg.develop()` since we are offering a `docs/Manifest.toml`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707
https://github.com/CliMA/Oceananigans.jl/pull/1714:8,Deployability,update,updates,8,This PR updates the Docs/Library section with latest docstrings. Closes #1713.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1714
https://github.com/CliMA/Oceananigans.jl/pull/1717:46,Availability,error,errors,46,"validation/barotropic/barotropic.jl currently errors when you try and run it. 1. The Flux() type is not imported; 2. The explicit stepper and timestep aren't in sync and code NaNs. The timestep is set for implicit free surface. . These two tweaks make it run and produce something ""reasonable"". ; It could be good to have it set so it runs as cloned?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1717
https://github.com/CliMA/Oceananigans.jl/pull/1717:0,Security,validat,validation,0,"validation/barotropic/barotropic.jl currently errors when you try and run it. 1. The Flux() type is not imported; 2. The explicit stepper and timestep aren't in sync and code NaNs. The timestep is set for implicit free surface. . These two tweaks make it run and produce something ""reasonable"". ; It could be good to have it set so it runs as cloned?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1717
https://github.com/CliMA/Oceananigans.jl/pull/1718:72,Availability,mask,masking,72,This PR updates the grid metrics used by `ShallowWaterModel` and adds a masking step to `update_state!` so that `ShallowWaterModel`s can be run on `ImmersedBoundaryGrid`. Co-authored by @francispoulin . Supercedes #1663,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1718
https://github.com/CliMA/Oceananigans.jl/pull/1718:8,Deployability,update,updates,8,This PR updates the grid metrics used by `ShallowWaterModel` and adds a masking step to `update_state!` so that `ShallowWaterModel`s can be run on `ImmersedBoundaryGrid`. Co-authored by @francispoulin . Supercedes #1663,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1718
https://github.com/CliMA/Oceananigans.jl/pull/1719:429,Testability,test,test,429,"High-order advection schemes invoke wide stencils that can produce unintended non-zero fluxes across solid immersed boundaries. This PR elides advective fluxes across immersed boundaries for `GridFittedImmersedBoundary` to address that. In addition, we should probably introduce boundary-conditional interpolation so that we limit to second-order advection close to immersed boundaries. I'll drop that into this PR too and add a test for high-order advection with immersed boundaries.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1719
https://github.com/CliMA/Oceananigans.jl/issues/1720:36,Availability,mask,masking,36,"`GridFittedImmersedBoundary` uses a masking technique to immerse a grid-fitted boundary into some primary grid. For this purpose it elides diffusive fluxes across immersed interfaces (and soon will elide advective fluxes via #1719). This permits simulations that conserve tracers and momentum. However, users typically want to enforce boundary conditions across immersed boundaries. The simplest boundary condition to support is `FluxBoundaryCondition`. But there are a number of complications. Our current boundary condition API really bakes in the assumption of directionally-aligned boundaries, since fluxes are defined in the x, y, z direction, according to the boundary in question. This only makes sense for boundaries that are aligned with x, y, z, respectively. For boundaries that can point in any direction, it probably makes more sense to define fluxes _normal_ to the boundary. But then if we want to have a consistent API for specifying boundary conditions for both immersed boundaries and grid boundaries, we need to change the current convention for specifying grid boundary conditions. Fluxes would no longer point in the positive direction but _inwards_ or _outwards_ (in the former case, this means that negative tracer fluxes at the top boundary would lead to a decrease in tracer, eg cooling in the case of temperature). Not hard to implement, but certainly a _major_ breaking change. Another question is where we should _store_ the boundary conditions. Right now boundary conditions are stored in `Field.boundary_conditions for each field`. If we continue with this approach we need to generalize / redesign `FieldBoundaryConditions`. It might make sense to flatten the structure and have boundary conditions for `west, east, south, north, bottom, top[, immersed_boundary_label]`. This has the _potential_ to permit us to specify different boundary conditions on different ""parts"" of the immersed boundary, if we come up with an abstraction for partitioning an immersed boundary. ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720
https://github.com/CliMA/Oceananigans.jl/issues/1720:172,Integrability,interface,interfaces,172,"`GridFittedImmersedBoundary` uses a masking technique to immerse a grid-fitted boundary into some primary grid. For this purpose it elides diffusive fluxes across immersed interfaces (and soon will elide advective fluxes via #1719). This permits simulations that conserve tracers and momentum. However, users typically want to enforce boundary conditions across immersed boundaries. The simplest boundary condition to support is `FluxBoundaryCondition`. But there are a number of complications. Our current boundary condition API really bakes in the assumption of directionally-aligned boundaries, since fluxes are defined in the x, y, z direction, according to the boundary in question. This only makes sense for boundaries that are aligned with x, y, z, respectively. For boundaries that can point in any direction, it probably makes more sense to define fluxes _normal_ to the boundary. But then if we want to have a consistent API for specifying boundary conditions for both immersed boundaries and grid boundaries, we need to change the current convention for specifying grid boundary conditions. Fluxes would no longer point in the positive direction but _inwards_ or _outwards_ (in the former case, this means that negative tracer fluxes at the top boundary would lead to a decrease in tracer, eg cooling in the case of temperature). Not hard to implement, but certainly a _major_ breaking change. Another question is where we should _store_ the boundary conditions. Right now boundary conditions are stored in `Field.boundary_conditions for each field`. If we continue with this approach we need to generalize / redesign `FieldBoundaryConditions`. It might make sense to flatten the structure and have boundary conditions for `west, east, south, north, bottom, top[, immersed_boundary_label]`. This has the _potential_ to permit us to specify different boundary conditions on different ""parts"" of the immersed boundary, if we come up with an abstraction for partitioning an immersed boundary. ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720
https://github.com/CliMA/Oceananigans.jl/issues/1720:2562,Integrability,interface,interface,2562,"d to change the current convention for specifying grid boundary conditions. Fluxes would no longer point in the positive direction but _inwards_ or _outwards_ (in the former case, this means that negative tracer fluxes at the top boundary would lead to a decrease in tracer, eg cooling in the case of temperature). Not hard to implement, but certainly a _major_ breaking change. Another question is where we should _store_ the boundary conditions. Right now boundary conditions are stored in `Field.boundary_conditions for each field`. If we continue with this approach we need to generalize / redesign `FieldBoundaryConditions`. It might make sense to flatten the structure and have boundary conditions for `west, east, south, north, bottom, top[, immersed_boundary_label]`. This has the _potential_ to permit us to specify different boundary conditions on different ""parts"" of the immersed boundary, if we come up with an abstraction for partitioning an immersed boundary. With the two changes above we might have an API that looks something like. ```julia; c_bcs = TracerBoundaryConditions(grid, top = NormalFluxBoundaryCondition(args...),; boundary_1 = NormalFluxBoundaryCondition(args...), boundary_2 = NormalFluxBoundaryCondition(more_args...)); ```. We also may want to change how boundary conditions are implemented. Currently we launch a bunch of 2D kernels to enforce boundary conditions. But enforcing boundary conditions across immersed boundaries either requires a 3D kernel or a 1D kernel that traverses every fluid-solid interface (probably requiring some tedious bookkeeping to generate the iteration). From the software perspective, it's probably simpler to move the enforcement of flux boundary condition inside the 3D interior tendency kernel and evaluate boundary conditions at the same time that interior tendency contributions are evaluated (in other words, replace diffusive fluxes with the specified boundary normal flux when appropriate). cc @whitleyv this affects your work.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720
https://github.com/CliMA/Oceananigans.jl/issues/1720:387,Usability,simpl,simplest,387,"`GridFittedImmersedBoundary` uses a masking technique to immerse a grid-fitted boundary into some primary grid. For this purpose it elides diffusive fluxes across immersed interfaces (and soon will elide advective fluxes via #1719). This permits simulations that conserve tracers and momentum. However, users typically want to enforce boundary conditions across immersed boundaries. The simplest boundary condition to support is `FluxBoundaryCondition`. But there are a number of complications. Our current boundary condition API really bakes in the assumption of directionally-aligned boundaries, since fluxes are defined in the x, y, z direction, according to the boundary in question. This only makes sense for boundaries that are aligned with x, y, z, respectively. For boundaries that can point in any direction, it probably makes more sense to define fluxes _normal_ to the boundary. But then if we want to have a consistent API for specifying boundary conditions for both immersed boundaries and grid boundaries, we need to change the current convention for specifying grid boundary conditions. Fluxes would no longer point in the positive direction but _inwards_ or _outwards_ (in the former case, this means that negative tracer fluxes at the top boundary would lead to a decrease in tracer, eg cooling in the case of temperature). Not hard to implement, but certainly a _major_ breaking change. Another question is where we should _store_ the boundary conditions. Right now boundary conditions are stored in `Field.boundary_conditions for each field`. If we continue with this approach we need to generalize / redesign `FieldBoundaryConditions`. It might make sense to flatten the structure and have boundary conditions for `west, east, south, north, bottom, top[, immersed_boundary_label]`. This has the _potential_ to permit us to specify different boundary conditions on different ""parts"" of the immersed boundary, if we come up with an abstraction for partitioning an immersed boundary. ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720
https://github.com/CliMA/Oceananigans.jl/issues/1720:2690,Usability,simpl,simpler,2690,"d to change the current convention for specifying grid boundary conditions. Fluxes would no longer point in the positive direction but _inwards_ or _outwards_ (in the former case, this means that negative tracer fluxes at the top boundary would lead to a decrease in tracer, eg cooling in the case of temperature). Not hard to implement, but certainly a _major_ breaking change. Another question is where we should _store_ the boundary conditions. Right now boundary conditions are stored in `Field.boundary_conditions for each field`. If we continue with this approach we need to generalize / redesign `FieldBoundaryConditions`. It might make sense to flatten the structure and have boundary conditions for `west, east, south, north, bottom, top[, immersed_boundary_label]`. This has the _potential_ to permit us to specify different boundary conditions on different ""parts"" of the immersed boundary, if we come up with an abstraction for partitioning an immersed boundary. With the two changes above we might have an API that looks something like. ```julia; c_bcs = TracerBoundaryConditions(grid, top = NormalFluxBoundaryCondition(args...),; boundary_1 = NormalFluxBoundaryCondition(args...), boundary_2 = NormalFluxBoundaryCondition(more_args...)); ```. We also may want to change how boundary conditions are implemented. Currently we launch a bunch of 2D kernels to enforce boundary conditions. But enforcing boundary conditions across immersed boundaries either requires a 3D kernel or a 1D kernel that traverses every fluid-solid interface (probably requiring some tedious bookkeeping to generate the iteration). From the software perspective, it's probably simpler to move the enforcement of flux boundary condition inside the 3D interior tendency kernel and evaluate boundary conditions at the same time that interior tendency contributions are evaluated (in other words, replace diffusive fluxes with the specified boundary normal flux when appropriate). cc @whitleyv this affects your work.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720
https://github.com/CliMA/Oceananigans.jl/issues/1722:11532,Availability,error,errors,11532," 1.99019 │ 1.38345 │; │ CPU │ (1, 0) │ 1.06409 │ 1.39873 │ 1.17271 │; │ CPU │ (2, 0) │ 1.17887 │ 1.99054 │ 1.38949 │; │ CPU │ (2, 3) │ 1.55493 │ 4.04677 │ 2.37198 │; │ CPU │ (2, 5) │ 1.97115 │ 5.84537 │ 2.96377 │; │ CPU │ (2, 10) │ 2.6031 │ 11.7179 │ 4.63889 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘. Arbitrary tracers relative performance (GPU); ┌───────────────┬─────────┬──────────┬─────────┬─────────┐; │ Architectures │ tracers │ slowdown │ memory │ allocs │; ├───────────────┼─────────┼──────────┼─────────┼─────────┤; │ GPU │ (0, 0) │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ (0, 1) │ 1.0941 │ 1.39053 │ 1.16013 │; │ GPU │ (0, 2) │ 1.19399 │ 1.85081 │ 1.29592 │; │ GPU │ (1, 0) │ 1.08489 │ 1.39037 │ 1.15883 │; │ GPU │ (2, 0) │ 1.19157 │ 1.85109 │ 1.29153 │; │ GPU │ (2, 3) │ 1.47824 │ 3.50924 │ 1.45881 │; │ GPU │ (2, 5) │ 1.66293 │ 4.95474 │ 1.94286 │; │ GPU │ (2, 10) │ 2.13524 │ 9.47276 │ 2.52301 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘; ```; Some errors were encountered running the turbulence closure benchmark script with grid size 256 x 256 x 128.; There was an issue with the Nothing closure which was avoided by removing that type of closure from the closure array.; ```. Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Turbulence closure benchmarks; ┌───────────────┬──────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ Architectures │ Clo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722
https://github.com/CliMA/Oceananigans.jl/issues/1722:293,Deployability,update,update,293,"@francispoulin and I recently ran some of the benchmark scripts with Julia 1.6.0 and Oceananigans v0.58.1.; If these benchmarks differ enough from the ones currently shown on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/benchmarks.md) then I'll make a PR to update them. The hardware these new benchmarks were run on are mostly the exact as the old benchmarks save for a few that were ran on Titan V GPUs but are now run on Tesla V100 GPUs. The shallow water model benchmarks were run without problems. With CPU, when the grid size exceeded 2048 x 2048, only one sample could be benchmarked. Trying to get more samples benchmarked by increasing the sampling time limit resulted in out of memory exceptions.; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Shallow water model benchmarks; ┌───────────────┬─────────────┬──────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼──────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 2.041 ms │ 2.154 ms │ 2.246 ms │ 3.207 ms │ 1.36 MiB │ 2253 │ 10 │; │ CPU │ Float64 │ 64 │ 3.224 ms │ 3.367 ms │ 3.408 ms │ 4.031 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Float64 │ 128 │ 7.495 ms │ 7.620 ms │ 7.661 ms │ 8.193 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722
https://github.com/CliMA/Oceananigans.jl/issues/1722:10237,Performance,perform,performance,10237,"520 ms │ 20.519 ms │ 5.56 MiB │ 17974 │ 10 │; │ GPU │ (2, 5) │ 15.824 ms │ 21.211 ms │ 21.064 ms │ 24.897 ms │ 7.86 MiB │ 23938 │ 10 │; │ GPU │ (2, 10) │ 22.085 ms │ 27.236 ms │ 28.231 ms │ 38.295 ms │ 15.02 MiB │ 31086 │ 10 │; └───────────────┴─────────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┴─────────┘. Arbitrary tracers CPU to GPU speedup; ┌─────────┬─────────┬─────────┬─────────┐; │ tracers │ speedup │ memory │ allocs │; ├─────────┼─────────┼─────────┼─────────┤; │ (0, 0) │ 112.881 │ 1.78792 │ 7.44022 │; │ (0, 1) │ 112.761 │ 1.77743 │ 7.36045 │; │ (0, 2) │ 109.618 │ 1.6627 │ 6.96945 │; │ (1, 0) │ 110.717 │ 1.77723 │ 7.35221 │; │ (2, 0) │ 111.678 │ 1.66267 │ 6.91569 │; │ (2, 3) │ 118.737 │ 1.55043 │ 4.57587 │; │ (2, 5) │ 133.803 │ 1.5155 │ 4.87734 │; │ (2, 10) │ 137.615 │ 1.44535 │ 4.0466 │; └─────────┴─────────┴─────────┴─────────┘. Arbitrary tracers relative performance (CPU); ┌───────────────┬─────────┬──────────┬─────────┬─────────┐; │ Architectures │ tracers │ slowdown │ memory │ allocs │; ├───────────────┼─────────┼──────────┼─────────┼─────────┤; │ CPU │ (0, 0) │ 1.0 │ 1.0 │ 1.0 │; │ CPU │ (0, 1) │ 1.09293 │ 1.39873 │ 1.17271 │; │ CPU │ (0, 2) │ 1.15948 │ 1.99019 │ 1.38345 │; │ CPU │ (1, 0) │ 1.06409 │ 1.39873 │ 1.17271 │; │ CPU │ (2, 0) │ 1.17887 │ 1.99054 │ 1.38949 │; │ CPU │ (2, 3) │ 1.55493 │ 4.04677 │ 2.37198 │; │ CPU │ (2, 5) │ 1.97115 │ 5.84537 │ 2.96377 │; │ CPU │ (2, 10) │ 2.6031 │ 11.7179 │ 4.63889 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘. Arbitrary tracers relative performance (GPU); ┌───────────────┬─────────┬──────────┬─────────┬─────────┐; │ Architectures │ tracers │ slowdown │ memory │ allocs │; ├───────────────┼─────────┼──────────┼─────────┼─────────┤; │ GPU │ (0, 0) │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ (0, 1) │ 1.0941 │ 1.39053 │ 1.16013 │; │ GPU │ (0, 2) │ 1.19399 │ 1.85081 │ 1.29592 │; │ GPU │ (1, 0) │ 1.08489 │ 1.39037 │ 1.15883 │; │ GPU │ (2, 0) │ 1.19157 │ 1.85109 │ 1.29153 │; │ GPU │ (2, 3)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722
https://github.com/CliMA/Oceananigans.jl/issues/1722:10893,Performance,perform,performance,10893,"│ 7.35221 │; │ (2, 0) │ 111.678 │ 1.66267 │ 6.91569 │; │ (2, 3) │ 118.737 │ 1.55043 │ 4.57587 │; │ (2, 5) │ 133.803 │ 1.5155 │ 4.87734 │; │ (2, 10) │ 137.615 │ 1.44535 │ 4.0466 │; └─────────┴─────────┴─────────┴─────────┘. Arbitrary tracers relative performance (CPU); ┌───────────────┬─────────┬──────────┬─────────┬─────────┐; │ Architectures │ tracers │ slowdown │ memory │ allocs │; ├───────────────┼─────────┼──────────┼─────────┼─────────┤; │ CPU │ (0, 0) │ 1.0 │ 1.0 │ 1.0 │; │ CPU │ (0, 1) │ 1.09293 │ 1.39873 │ 1.17271 │; │ CPU │ (0, 2) │ 1.15948 │ 1.99019 │ 1.38345 │; │ CPU │ (1, 0) │ 1.06409 │ 1.39873 │ 1.17271 │; │ CPU │ (2, 0) │ 1.17887 │ 1.99054 │ 1.38949 │; │ CPU │ (2, 3) │ 1.55493 │ 4.04677 │ 2.37198 │; │ CPU │ (2, 5) │ 1.97115 │ 5.84537 │ 2.96377 │; │ CPU │ (2, 10) │ 2.6031 │ 11.7179 │ 4.63889 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘. Arbitrary tracers relative performance (GPU); ┌───────────────┬─────────┬──────────┬─────────┬─────────┐; │ Architectures │ tracers │ slowdown │ memory │ allocs │; ├───────────────┼─────────┼──────────┼─────────┼─────────┤; │ GPU │ (0, 0) │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ (0, 1) │ 1.0941 │ 1.39053 │ 1.16013 │; │ GPU │ (0, 2) │ 1.19399 │ 1.85081 │ 1.29592 │; │ GPU │ (1, 0) │ 1.08489 │ 1.39037 │ 1.15883 │; │ GPU │ (2, 0) │ 1.19157 │ 1.85109 │ 1.29153 │; │ GPU │ (2, 3) │ 1.47824 │ 3.50924 │ 1.45881 │; │ GPU │ (2, 5) │ 1.66293 │ 4.95474 │ 1.94286 │; │ GPU │ (2, 10) │ 2.13524 │ 9.47276 │ 2.52301 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘; ```; Some errors were encountered running the turbulence closure benchmark script with grid size 256 x 256 x 128.; There was an issue with the Nothing closure which was avoided by removing that type of closure from the closure array.; ```. Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: li",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722
https://github.com/CliMA/Oceananigans.jl/issues/1722:11691,Safety,avoid,avoided,11691,"7 │ 2.37198 │; │ CPU │ (2, 5) │ 1.97115 │ 5.84537 │ 2.96377 │; │ CPU │ (2, 10) │ 2.6031 │ 11.7179 │ 4.63889 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘. Arbitrary tracers relative performance (GPU); ┌───────────────┬─────────┬──────────┬─────────┬─────────┐; │ Architectures │ tracers │ slowdown │ memory │ allocs │; ├───────────────┼─────────┼──────────┼─────────┼─────────┤; │ GPU │ (0, 0) │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ (0, 1) │ 1.0941 │ 1.39053 │ 1.16013 │; │ GPU │ (0, 2) │ 1.19399 │ 1.85081 │ 1.29592 │; │ GPU │ (1, 0) │ 1.08489 │ 1.39037 │ 1.15883 │; │ GPU │ (2, 0) │ 1.19157 │ 1.85109 │ 1.29153 │; │ GPU │ (2, 3) │ 1.47824 │ 3.50924 │ 1.45881 │; │ GPU │ (2, 5) │ 1.66293 │ 4.95474 │ 1.94286 │; │ GPU │ (2, 10) │ 2.13524 │ 9.47276 │ 2.52301 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘; ```; Some errors were encountered running the turbulence closure benchmark script with grid size 256 x 256 x 128.; There was an issue with the Nothing closure which was avoided by removing that type of closure from the closure array.; ```. Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Turbulence closure benchmarks; ┌───────────────┬──────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ Architectures │ Closures │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼──────────────────────────────────┼───────────┼───────────┼──────────",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722
https://github.com/CliMA/Oceananigans.jl/issues/1722:46,Testability,benchmark,benchmark,46,"@francispoulin and I recently ran some of the benchmark scripts with Julia 1.6.0 and Oceananigans v0.58.1.; If these benchmarks differ enough from the ones currently shown on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/benchmarks.md) then I'll make a PR to update them. The hardware these new benchmarks were run on are mostly the exact as the old benchmarks save for a few that were ran on Titan V GPUs but are now run on Tesla V100 GPUs. The shallow water model benchmarks were run without problems. With CPU, when the grid size exceeded 2048 x 2048, only one sample could be benchmarked. Trying to get more samples benchmarked by increasing the sampling time limit resulted in out of memory exceptions.; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Shallow water model benchmarks; ┌───────────────┬─────────────┬──────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼──────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 2.041 ms │ 2.154 ms │ 2.246 ms │ 3.207 ms │ 1.36 MiB │ 2253 │ 10 │; │ CPU │ Float64 │ 64 │ 3.224 ms │ 3.367 ms │ 3.408 ms │ 4.031 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Float64 │ 128 │ 7.495 ms │ 7.620 ms │ 7.661 ms │ 8.193 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722
https://github.com/CliMA/Oceananigans.jl/issues/1722:117,Testability,benchmark,benchmarks,117,"@francispoulin and I recently ran some of the benchmark scripts with Julia 1.6.0 and Oceananigans v0.58.1.; If these benchmarks differ enough from the ones currently shown on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/benchmarks.md) then I'll make a PR to update them. The hardware these new benchmarks were run on are mostly the exact as the old benchmarks save for a few that were ran on Titan V GPUs but are now run on Tesla V100 GPUs. The shallow water model benchmarks were run without problems. With CPU, when the grid size exceeded 2048 x 2048, only one sample could be benchmarked. Trying to get more samples benchmarked by increasing the sampling time limit resulted in out of memory exceptions.; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Shallow water model benchmarks; ┌───────────────┬─────────────┬──────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼──────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 2.041 ms │ 2.154 ms │ 2.246 ms │ 3.207 ms │ 1.36 MiB │ 2253 │ 10 │; │ CPU │ Float64 │ 64 │ 3.224 ms │ 3.367 ms │ 3.408 ms │ 4.031 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Float64 │ 128 │ 7.495 ms │ 7.620 ms │ 7.661 ms │ 8.193 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722
https://github.com/CliMA/Oceananigans.jl/issues/1722:177,Testability,benchmark,benchmarks,177,"@francispoulin and I recently ran some of the benchmark scripts with Julia 1.6.0 and Oceananigans v0.58.1.; If these benchmarks differ enough from the ones currently shown on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/benchmarks.md) then I'll make a PR to update them. The hardware these new benchmarks were run on are mostly the exact as the old benchmarks save for a few that were ran on Titan V GPUs but are now run on Tesla V100 GPUs. The shallow water model benchmarks were run without problems. With CPU, when the grid size exceeded 2048 x 2048, only one sample could be benchmarked. Trying to get more samples benchmarked by increasing the sampling time limit resulted in out of memory exceptions.; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Shallow water model benchmarks; ┌───────────────┬─────────────┬──────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼──────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 2.041 ms │ 2.154 ms │ 2.246 ms │ 3.207 ms │ 1.36 MiB │ 2253 │ 10 │; │ CPU │ Float64 │ 64 │ 3.224 ms │ 3.367 ms │ 3.408 ms │ 4.031 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Float64 │ 128 │ 7.495 ms │ 7.620 ms │ 7.661 ms │ 8.193 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722
https://github.com/CliMA/Oceananigans.jl/issues/1722:255,Testability,benchmark,benchmarks,255,"@francispoulin and I recently ran some of the benchmark scripts with Julia 1.6.0 and Oceananigans v0.58.1.; If these benchmarks differ enough from the ones currently shown on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/benchmarks.md) then I'll make a PR to update them. The hardware these new benchmarks were run on are mostly the exact as the old benchmarks save for a few that were ran on Titan V GPUs but are now run on Tesla V100 GPUs. The shallow water model benchmarks were run without problems. With CPU, when the grid size exceeded 2048 x 2048, only one sample could be benchmarked. Trying to get more samples benchmarked by increasing the sampling time limit resulted in out of memory exceptions.; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Shallow water model benchmarks; ┌───────────────┬─────────────┬──────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼──────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 2.041 ms │ 2.154 ms │ 2.246 ms │ 3.207 ms │ 1.36 MiB │ 2253 │ 10 │; │ CPU │ Float64 │ 64 │ 3.224 ms │ 3.367 ms │ 3.408 ms │ 4.031 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Float64 │ 128 │ 7.495 ms │ 7.620 ms │ 7.661 ms │ 8.193 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722
https://github.com/CliMA/Oceananigans.jl/issues/1722:329,Testability,benchmark,benchmarks,329,"@francispoulin and I recently ran some of the benchmark scripts with Julia 1.6.0 and Oceananigans v0.58.1.; If these benchmarks differ enough from the ones currently shown on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/benchmarks.md) then I'll make a PR to update them. The hardware these new benchmarks were run on are mostly the exact as the old benchmarks save for a few that were ran on Titan V GPUs but are now run on Tesla V100 GPUs. The shallow water model benchmarks were run without problems. With CPU, when the grid size exceeded 2048 x 2048, only one sample could be benchmarked. Trying to get more samples benchmarked by increasing the sampling time limit resulted in out of memory exceptions.; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Shallow water model benchmarks; ┌───────────────┬─────────────┬──────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼──────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 2.041 ms │ 2.154 ms │ 2.246 ms │ 3.207 ms │ 1.36 MiB │ 2253 │ 10 │; │ CPU │ Float64 │ 64 │ 3.224 ms │ 3.367 ms │ 3.408 ms │ 4.031 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Float64 │ 128 │ 7.495 ms │ 7.620 ms │ 7.661 ms │ 8.193 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722
https://github.com/CliMA/Oceananigans.jl/issues/1722:384,Testability,benchmark,benchmarks,384,"@francispoulin and I recently ran some of the benchmark scripts with Julia 1.6.0 and Oceananigans v0.58.1.; If these benchmarks differ enough from the ones currently shown on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/benchmarks.md) then I'll make a PR to update them. The hardware these new benchmarks were run on are mostly the exact as the old benchmarks save for a few that were ran on Titan V GPUs but are now run on Tesla V100 GPUs. The shallow water model benchmarks were run without problems. With CPU, when the grid size exceeded 2048 x 2048, only one sample could be benchmarked. Trying to get more samples benchmarked by increasing the sampling time limit resulted in out of memory exceptions.; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Shallow water model benchmarks; ┌───────────────┬─────────────┬──────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼──────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 2.041 ms │ 2.154 ms │ 2.246 ms │ 3.207 ms │ 1.36 MiB │ 2253 │ 10 │; │ CPU │ Float64 │ 64 │ 3.224 ms │ 3.367 ms │ 3.408 ms │ 4.031 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Float64 │ 128 │ 7.495 ms │ 7.620 ms │ 7.661 ms │ 8.193 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722
https://github.com/CliMA/Oceananigans.jl/issues/1722:500,Testability,benchmark,benchmarks,500,"@francispoulin and I recently ran some of the benchmark scripts with Julia 1.6.0 and Oceananigans v0.58.1.; If these benchmarks differ enough from the ones currently shown on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/benchmarks.md) then I'll make a PR to update them. The hardware these new benchmarks were run on are mostly the exact as the old benchmarks save for a few that were ran on Titan V GPUs but are now run on Tesla V100 GPUs. The shallow water model benchmarks were run without problems. With CPU, when the grid size exceeded 2048 x 2048, only one sample could be benchmarked. Trying to get more samples benchmarked by increasing the sampling time limit resulted in out of memory exceptions.; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Shallow water model benchmarks; ┌───────────────┬─────────────┬──────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼──────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 2.041 ms │ 2.154 ms │ 2.246 ms │ 3.207 ms │ 1.36 MiB │ 2253 │ 10 │; │ CPU │ Float64 │ 64 │ 3.224 ms │ 3.367 ms │ 3.408 ms │ 4.031 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Float64 │ 128 │ 7.495 ms │ 7.620 ms │ 7.661 ms │ 8.193 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722
https://github.com/CliMA/Oceananigans.jl/issues/1722:614,Testability,benchmark,benchmarked,614,"@francispoulin and I recently ran some of the benchmark scripts with Julia 1.6.0 and Oceananigans v0.58.1.; If these benchmarks differ enough from the ones currently shown on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/benchmarks.md) then I'll make a PR to update them. The hardware these new benchmarks were run on are mostly the exact as the old benchmarks save for a few that were ran on Titan V GPUs but are now run on Tesla V100 GPUs. The shallow water model benchmarks were run without problems. With CPU, when the grid size exceeded 2048 x 2048, only one sample could be benchmarked. Trying to get more samples benchmarked by increasing the sampling time limit resulted in out of memory exceptions.; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Shallow water model benchmarks; ┌───────────────┬─────────────┬──────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼──────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 2.041 ms │ 2.154 ms │ 2.246 ms │ 3.207 ms │ 1.36 MiB │ 2253 │ 10 │; │ CPU │ Float64 │ 64 │ 3.224 ms │ 3.367 ms │ 3.408 ms │ 4.031 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Float64 │ 128 │ 7.495 ms │ 7.620 ms │ 7.661 ms │ 8.193 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722
https://github.com/CliMA/Oceananigans.jl/issues/1722:654,Testability,benchmark,benchmarked,654,"@francispoulin and I recently ran some of the benchmark scripts with Julia 1.6.0 and Oceananigans v0.58.1.; If these benchmarks differ enough from the ones currently shown on [`benchmarks.md`](https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/benchmarks.md) then I'll make a PR to update them. The hardware these new benchmarks were run on are mostly the exact as the old benchmarks save for a few that were ran on Titan V GPUs but are now run on Tesla V100 GPUs. The shallow water model benchmarks were run without problems. With CPU, when the grid size exceeded 2048 x 2048, only one sample could be benchmarked. Trying to get more samples benchmarked by increasing the sampling time limit resulted in out of memory exceptions.; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Shallow water model benchmarks; ┌───────────────┬─────────────┬──────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼──────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 2.041 ms │ 2.154 ms │ 2.246 ms │ 3.207 ms │ 1.36 MiB │ 2253 │ 10 │; │ CPU │ Float64 │ 64 │ 3.224 ms │ 3.367 ms │ 3.408 ms │ 4.031 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Float64 │ 128 │ 7.495 ms │ 7.620 ms │ 7.661 ms │ 8.193 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Flo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722
https://github.com/CliMA/Oceananigans.jl/issues/1722:1366,Testability,benchmark,benchmarks,1366,"CPU, when the grid size exceeded 2048 x 2048, only one sample could be benchmarked. Trying to get more samples benchmarked by increasing the sampling time limit resulted in out of memory exceptions.; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Shallow water model benchmarks; ┌───────────────┬─────────────┬──────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼──────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float64 │ 32 │ 2.041 ms │ 2.154 ms │ 2.246 ms │ 3.207 ms │ 1.36 MiB │ 2253 │ 10 │; │ CPU │ Float64 │ 64 │ 3.224 ms │ 3.367 ms │ 3.408 ms │ 4.031 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Float64 │ 128 │ 7.495 ms │ 7.620 ms │ 7.661 ms │ 8.193 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Float64 │ 256 │ 23.927 ms │ 24.030 ms │ 24.651 ms │ 28.232 ms │ 1.36 MiB │ 2255 │ 10 │; │ CPU │ Float64 │ 512 │ 91.065 ms │ 93.878 ms │ 93.733 ms │ 97.092 ms │ 1.36 MiB │ 2315 │ 10 │; │ CPU │ Float64 │ 1024 │ 388.387 ms │ 389.332 ms │ 390.035 ms │ 392.166 ms │ 1.36 MiB │ 2315 │ 10 │; │ CPU │ Float64 │ 2048 │ 1.584 s │ 1.584 s │ 1.584 s │ 1.585 s │ 1.36 MiB │ 2315 │ 4 │; │ CPU │ Float64 │ 4096 │ 6.337 s │ 6.337 s │ 6.337 s │ 6.337 s │ 1.36 MiB │ 2315 │ 1 │; │ CPU │ Float64 │ 8192 │ 25.696 s │ 25.696 s │ 25.696 s │ 25.696 s │ 1.36 MiB │ 2313",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722
https://github.com/CliMA/Oceananigans.jl/issues/1722:4468,Testability,Benchmark,Benchmarkable,4468,"ms │ 4.81 MiB │ 200327 │ 10 │; │ GPU │ Float64 │16384 │ 552.752 ms │ 552.786 ms │ 552.883 ms │ 553.533 ms │14.14 MiB │ 811831 │ 10 ; └───────────────┴─────────────┴──────┴────────────┴────────────┴────────────┴────────────┴──────────┴────────┴─────────┘. Shallow water model CPU to GPU speedup; ┌─────────────┬──────┬──────────┬─────────┬─────────┐; │ Float_types │ Ns │ speedup │ memory │ allocs │; ├─────────────┼──────┼──────────┼─────────┼─────────┤; │ Float64 │ 32 │ 0.635088 │ 1.34893 │ 2.54017 │; │ Float64 │ 64 │ 0.984322 │ 1.3489 │ 2.53792 │; │ Float64 │ 128 │ 2.2418 │ 1.3489 │ 2.53792 │; │ Float64 │ 256 │ 7.04691 │ 1.3489 │ 2.53792 │; │ Float64 │ 512 │ 27.1702 │ 1.34893 │ 2.50842 │; │ Float64 │ 1024 │ 110.972 │ 1.34931 │ 2.52311 │; │ Float64 │ 2048 │ 178.096 │ 1.43913 │ 5.98747 │; │ Float64 │ 4096 │ 185.419 │ 1.83529 │ 21.2678 │; │ Float64 │ 8192 │ 189.573 │ 3.52748 │ 86.6092 │; │ Float64 │16384 │ 193.026 │ 10.376 │ 350.986 │; └─────────────┴──────┴──────────┴─────────┴─────────┘; ```; Benchmarkable incompressible model:; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722
https://github.com/CliMA/Oceananigans.jl/issues/1722:5129,Testability,benchmark,benchmarks,5129,"4096 │ 185.419 │ 1.83529 │ 21.2678 │; │ Float64 │ 8192 │ 189.573 │ 3.52748 │ 86.6092 │; │ Float64 │16384 │ 193.026 │ 10.376 │ 350.986 │; └─────────────┴──────┴──────────┴─────────┴─────────┘; ```; Benchmarkable incompressible model:; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬──────────┬────────┬─────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼──────────┼────────┼─────────┤; │ CPU │ Float32 │ 32 │ 6.121 ms │ 6.225 ms │ 6.393 ms │ 7.995 ms │ 1.38 MiB │ 2301 │ 10 │; │ CPU │ Float32 │ 64 │ 39.352 ms │ 39.706 ms │ 39.950 ms │ 42.529 ms │ 1.38 MiB │ 2301 │ 10 │; │ CPU │ Float32 │ 128 │ 323.897 ms │ 325.763 ms │ 325.708 ms │ 327.232 ms │ 1.38 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 32 │ 6.517 ms │ 6.661 ms │ 6.892 ms │ 9.248 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 64 │ 45.077 ms │ 45.430 ms │ 45.821 ms │ 49.910 ms │ 1.77 MiB │ 2301 │ 10 │; │ CPU │ Float64 │ 128 │ 390.134 ms │ 390.948 ms │ 391.456 ms │ 395.682 ms │ 1.77 MiB │ 2301 │ 10 │; │ GPU │ Float32 │ 32 │ 3.543 ms │ 3.679 ms │ 3.813 ms │ 5.210 ms │ 2.23 MiB │ 6920 │ 10 │; │ GPU │ Float32 │ 64 │ 3.732 ms │ 3.782 ms │ 3.907 ms │ 4.982 ms │ 2.22 MiB │ 6939 │ 10 │; │ GPU │ Float32 │ 128 │ 3.940 ms │ 4.023 ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722
https://github.com/CliMA/Oceananigans.jl/issues/1722:7879,Testability,benchmark,benchmarks,7879,"2 │ 1.60842 │ 3.28596 │; │ Float64 │ 32 │ 1.72783 │ 1.58487 │ 3.00478 │; │ Float64 │ 64 │ 11.0611 │ 1.57428 │ 3.02521 │; │ Float64 │ 128 │ 84.2143 │ 1.5844 │ 3.53368 │; ```; Tracers, with grid size being 256 x 256 x 128:; ```; Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Arbitrary tracers benchmarks; ┌───────────────┬─────────┬───────────┬───────────┬───────────┬───────────┬────────────┬────────┬─────────┐; │ Architectures │ tracers │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────┼───────────┼───────────┼───────────┼───────────┼────────────┼────────┼─────────┤; │ CPU │ (0, 0) │ 1.439 s │ 1.440 s │ 1.440 s │ 1.441 s │ 908.03 KiB │ 1656 │ 4 │; │ CPU │ (0, 1) │ 1.539 s │ 1.574 s │ 1.575 s │ 1.613 s │ 1.24 MiB │ 1942 │ 4 │; │ CPU │ (0, 2) │ 1.668 s │ 1.669 s │ 1.670 s │ 1.671 s │ 1.76 MiB │ 2291 │ 3 │; │ CPU │ (1, 0) │ 1.527 s │ 1.532 s │ 1.532 s │ 1.536 s │ 1.24 MiB │ 1942 │ 4 │; │ CPU │ (2, 0) │ 1.690 s │ 1.697 s │ 1.695 s │ 1.698 s │ 1.77 MiB │ 2301 │ 3 │; │ CPU │ (2, 3) │ 2.234 s │ 2.239 s │ 2.241 s │ 2.251 s │ 3.59 MiB │ 3928 │ 3 │; │ CPU │ (2, 5) │ 2.755 s │ 2.838 s │ 2.838 s │ 2.921 s │ 5.18 MiB │ 4908 │ 2 │; │ CPU │ (2, 10) │ 3.588 s │ 3.748 s │ 3.748 s │ 3.908 s │ 10.39 MiB │ 7682 │ 2 │; │ GPU │ (0, 0) │ 9.702 ms │ 12.755 ms │ 12.458 ms │ 12.894 ms │ 1.59 MiB │ 12321 │ 10 │; │ GPU │ (0, 1) │ 13.863 ms │ 13.956 ms │ 14.184 ms │ 16.297 ms │ 2.20 MiB │ 14294 │ 10 │; │ GPU │ (0, 2) │ 15.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722
https://github.com/CliMA/Oceananigans.jl/issues/1722:11587,Testability,benchmark,benchmark,11587," 1.99019 │ 1.38345 │; │ CPU │ (1, 0) │ 1.06409 │ 1.39873 │ 1.17271 │; │ CPU │ (2, 0) │ 1.17887 │ 1.99054 │ 1.38949 │; │ CPU │ (2, 3) │ 1.55493 │ 4.04677 │ 2.37198 │; │ CPU │ (2, 5) │ 1.97115 │ 5.84537 │ 2.96377 │; │ CPU │ (2, 10) │ 2.6031 │ 11.7179 │ 4.63889 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘. Arbitrary tracers relative performance (GPU); ┌───────────────┬─────────┬──────────┬─────────┬─────────┐; │ Architectures │ tracers │ slowdown │ memory │ allocs │; ├───────────────┼─────────┼──────────┼─────────┼─────────┤; │ GPU │ (0, 0) │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ (0, 1) │ 1.0941 │ 1.39053 │ 1.16013 │; │ GPU │ (0, 2) │ 1.19399 │ 1.85081 │ 1.29592 │; │ GPU │ (1, 0) │ 1.08489 │ 1.39037 │ 1.15883 │; │ GPU │ (2, 0) │ 1.19157 │ 1.85109 │ 1.29153 │; │ GPU │ (2, 3) │ 1.47824 │ 3.50924 │ 1.45881 │; │ GPU │ (2, 5) │ 1.66293 │ 4.95474 │ 1.94286 │; │ GPU │ (2, 10) │ 2.13524 │ 9.47276 │ 2.52301 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘; ```; Some errors were encountered running the turbulence closure benchmark script with grid size 256 x 256 x 128.; There was an issue with the Nothing closure which was avoided by removing that type of closure from the closure array.; ```. Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Turbulence closure benchmarks; ┌───────────────┬──────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ Architectures │ Clo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722
https://github.com/CliMA/Oceananigans.jl/issues/1722:12379,Testability,benchmark,benchmarks,12379,"ulence closure benchmark script with grid size 256 x 256 x 128.; There was an issue with the Nothing closure which was avoided by removing that type of closure from the closure array.; ```. Oceananigans v0.58.1; Julia Version 1.6.0; Commit f9720dc2eb (2021-03-24 12:55 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4216 CPU @ 2.10GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.0; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.0/easybuild/avx2-Core-julia-1.6.0-easybuild-devel; JULIA_LOAD_PATH = :; GPU: Tesla V100-SXM2-32GB. Turbulence closure benchmarks; ┌───────────────┬──────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ Architectures │ Closures │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼──────────────────────────────────┼───────────┼───────────┼───────────┼───────────┼──────────┼────────┼─────────┤; │ CPU │ AnisotropicBiharmonicDiffusivity │ 3.634 s │ 3.637 s │ 3.637 s │ 3.639 s │ 1.77 MiB │ 2316 │ 2 │; │ CPU │ AnisotropicDiffusivity │ 2.045 s │ 2.052 s │ 2.059 s │ 2.079 s │ 1.77 MiB │ 2316 │ 3 │; │ CPU │ AnisotropicMinimumDissipation │ 3.240 s │ 3.240 s │ 3.240 s │ 3.241 s │ 2.09 MiB │ 2763 │ 2 │; │ CPU │ IsotropicDiffusivity │ 2.342 s │ 2.344 s │ 2.344 s │ 2.345 s │ 1.77 MiB │ 2316 │ 3 │; │ CPU │ SmagorinskyLilly │ 3.501 s │ 3.504 s │ 3.504 s │ 3.507 s │ 2.03 MiB │ 2486 │ 2 │; │ CPU │ TwoDimensionalLeith │ 4.813 s │ 4.820 s │ 4.820 s │ 4.828 s │ 1.88 MiB │ 2481 │ 2 │; │ GPU │ AnisotropicBiharmonicDiffusivity │ 24.699 ms │ 24.837 ms │ 26.946 ms │ 46.029 ms │ 3.16 MiB │ 29911 │ 10 │; │ GPU │ AnisotropicDiffusivity │ 16.115 ms │ 16.184 ms │ 16.454 ms │ 18.978 ms │ 2.97 MiB │ 17169 │ 10 │; │ GPU │ AnisotropicMinimumDi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722
https://github.com/CliMA/Oceananigans.jl/pull/1723:23,Security,validat,validation,23,Supercedes #1717 . The validation NaN's right now with the implemented immersed boundary. @christophernhill take over from here?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1723
https://github.com/CliMA/Oceananigans.jl/issues/1727:1047,Performance,optimiz,optimized,1047,"`HydrostaticFreeSurfaceModel` has two options for `free_surface`: `ExplicitFreeSurface` and `ImplicitFreeSurface`. Unfortunately, `ImplicitFreeSurface` using a `PreconditionedConjugateGradientSolver` incurs a significant cost (even relative to the cost of a _three-dimensional_ direct non hydrostatic pressure solve!), while `ExplicitFreeSurface` severely limits time-step with realistic `gravitational_acceleration` and velocity scales. For grids that are regular and rectilinear in the horizontal, there is a cure: we can implement a direct solve using the FFT based pressure solver either of the 2D barotropic poisson pressure equation, or for the 2D implicit free surface step. It will be interesting to compare the total cost of the barotropic integral + 2D solve, which requires integrals to extra the barotropic transport, with the 3D solve used by `IncompressibleModel`. The vertical FFT is _asymptotically_ more costly than the couple vertical integrals required for a barotropic pressure solve; but on the other hand the FFTs are highly optimized.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1727
https://github.com/CliMA/Oceananigans.jl/issues/1730:1196,Availability,error,error,1196,"g to set boundary conditions in a `ShallowWaterModel` example using `ImmersedBoundary`. The actual problem I want is more complicated then this but as a first step I thought I would just set the height to be a fixed value at the north and south boundaries. The immersed boundary creates a cap on the west. ```; using Oceananigans; using Oceananigans.Grids; using Oceananigans.Models; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. using Oceananigans.BoundaryConditions: NormalFlow, Value. grid = RegularRectilinearGrid(size=(16, 16), x=(-10, 10), y=(0, 5), topology=(Periodic, Bounded, Flat)). bump(x, y, z) = y < exp(-x^2). grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). @inline inflow(i, k, grid, clock, model_fields) = @inbounds model_fields.h[i, 1, 1]. @inline outflow(i, k, grid, clock, model_fields) = @inbounds model_fields.h[i, grid.Ny, 1]. h_bcs = TracerBoundaryConditions(grid;; north = BoundaryCondition(Value, 2.0),; south = BoundaryCondition(Value, 2.0),; ). model = ShallowWaterModel(grid=grid_with_bump, gravitational_acceleration=1, boundary_conditions=(h=h_bcs,)). set!(model, h=1); ```. The error that I get is copied below. Any one know why `set!` is trying to use `Δy`?. ```; ERROR: TaskFailedException. nested task error: MethodError: no method matching Δy(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Bounded, Flat, RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{typeof(bump)}}); Closest candidates are:; Δy(::Any, ::Any, ::Any, ::RegularRectilinearGrid{FT, TX, Flat, TZ, R} where {TZ, R}) where {FT, TX} at /home/fpoulin/software/Oceananigans.jl/src/Operators/spacings_and_areas_and_volumes.jl:58; Δy(::Any, ::Any, ::Any, ::AbstractRectilinearGrid) at /home/fpoulin/software/Oceananigans.jl/src/Operators/spacings_and_areas_and_volumes.jl:35; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730
https://github.com/CliMA/Oceananigans.jl/issues/1730:1283,Availability,ERROR,ERROR,1283,"g to set boundary conditions in a `ShallowWaterModel` example using `ImmersedBoundary`. The actual problem I want is more complicated then this but as a first step I thought I would just set the height to be a fixed value at the north and south boundaries. The immersed boundary creates a cap on the west. ```; using Oceananigans; using Oceananigans.Grids; using Oceananigans.Models; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. using Oceananigans.BoundaryConditions: NormalFlow, Value. grid = RegularRectilinearGrid(size=(16, 16), x=(-10, 10), y=(0, 5), topology=(Periodic, Bounded, Flat)). bump(x, y, z) = y < exp(-x^2). grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). @inline inflow(i, k, grid, clock, model_fields) = @inbounds model_fields.h[i, 1, 1]. @inline outflow(i, k, grid, clock, model_fields) = @inbounds model_fields.h[i, grid.Ny, 1]. h_bcs = TracerBoundaryConditions(grid;; north = BoundaryCondition(Value, 2.0),; south = BoundaryCondition(Value, 2.0),; ). model = ShallowWaterModel(grid=grid_with_bump, gravitational_acceleration=1, boundary_conditions=(h=h_bcs,)). set!(model, h=1); ```. The error that I get is copied below. Any one know why `set!` is trying to use `Δy`?. ```; ERROR: TaskFailedException. nested task error: MethodError: no method matching Δy(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Bounded, Flat, RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{typeof(bump)}}); Closest candidates are:; Δy(::Any, ::Any, ::Any, ::RegularRectilinearGrid{FT, TX, Flat, TZ, R} where {TZ, R}) where {FT, TX} at /home/fpoulin/software/Oceananigans.jl/src/Operators/spacings_and_areas_and_volumes.jl:58; Δy(::Any, ::Any, ::Any, ::AbstractRectilinearGrid) at /home/fpoulin/software/Oceananigans.jl/src/Operators/spacings_and_areas_and_volumes.jl:35; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730
https://github.com/CliMA/Oceananigans.jl/issues/1730:1323,Availability,error,error,1323,"g to set boundary conditions in a `ShallowWaterModel` example using `ImmersedBoundary`. The actual problem I want is more complicated then this but as a first step I thought I would just set the height to be a fixed value at the north and south boundaries. The immersed boundary creates a cap on the west. ```; using Oceananigans; using Oceananigans.Grids; using Oceananigans.Models; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. using Oceananigans.BoundaryConditions: NormalFlow, Value. grid = RegularRectilinearGrid(size=(16, 16), x=(-10, 10), y=(0, 5), topology=(Periodic, Bounded, Flat)). bump(x, y, z) = y < exp(-x^2). grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). @inline inflow(i, k, grid, clock, model_fields) = @inbounds model_fields.h[i, 1, 1]. @inline outflow(i, k, grid, clock, model_fields) = @inbounds model_fields.h[i, grid.Ny, 1]. h_bcs = TracerBoundaryConditions(grid;; north = BoundaryCondition(Value, 2.0),; south = BoundaryCondition(Value, 2.0),; ). model = ShallowWaterModel(grid=grid_with_bump, gravitational_acceleration=1, boundary_conditions=(h=h_bcs,)). set!(model, h=1); ```. The error that I get is copied below. Any one know why `set!` is trying to use `Δy`?. ```; ERROR: TaskFailedException. nested task error: MethodError: no method matching Δy(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Bounded, Flat, RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{typeof(bump)}}); Closest candidates are:; Δy(::Any, ::Any, ::Any, ::RegularRectilinearGrid{FT, TX, Flat, TZ, R} where {TZ, R}) where {FT, TX} at /home/fpoulin/software/Oceananigans.jl/src/Operators/spacings_and_areas_and_volumes.jl:58; Δy(::Any, ::Any, ::Any, ::AbstractRectilinearGrid) at /home/fpoulin/software/Oceananigans.jl/src/Operators/spacings_and_areas_and_volumes.jl:35; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730
https://github.com/CliMA/Oceananigans.jl/pull/1731:8,Deployability,update,updates,8,"This PR updates `fill_halo_regions!` to utilize `field.architecture` (so the `arch` requirement is no longer needed), and generalizes halo filling for `Value` and `Gradient` boundary conditions to curvilinear grids.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1731
https://github.com/CliMA/Oceananigans.jl/pull/1732:206,Availability,error,error,206,This long overdue PR implementations a validation step in the lowest-level outer constructor for `Field`. This resolves a number of issues but I need to find them. Couple todo's:; - [ ] tests; - [x] expand error message to help users choose valid boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1732
https://github.com/CliMA/Oceananigans.jl/pull/1732:212,Integrability,message,message,212,This long overdue PR implementations a validation step in the lowest-level outer constructor for `Field`. This resolves a number of issues but I need to find them. Couple todo's:; - [ ] tests; - [x] expand error message to help users choose valid boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1732
https://github.com/CliMA/Oceananigans.jl/pull/1732:39,Security,validat,validation,39,This long overdue PR implementations a validation step in the lowest-level outer constructor for `Field`. This resolves a number of issues but I need to find them. Couple todo's:; - [ ] tests; - [x] expand error message to help users choose valid boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1732
https://github.com/CliMA/Oceananigans.jl/pull/1732:186,Testability,test,tests,186,This long overdue PR implementations a validation step in the lowest-level outer constructor for `Field`. This resolves a number of issues but I need to find them. Couple todo's:; - [ ] tests; - [x] expand error message to help users choose valid boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1732
https://github.com/CliMA/Oceananigans.jl/pull/1733:874,Energy Efficiency,efficient,efficiently,874,"This somewhat large and WIP PR implements immersed boundary in the non-hydrostatic algorithm used by `IncompressibleModel`. . It also accelerates using `ImmersedBoundaryGrid` with high-order advection by encoding the ""boundary buffer"" (the number of grid points away from the boundary where second-order advection must be used) in the type signature of each advection scheme. This allows us to use dispatch to identify the correct criterion to use to determine whether a grid point is ""near boundary"" or not. It adds two validation tests: `shallow_water_flow_past_cape.jl` and `immersed_bickley_jet.jl`. The intent of `immersed_bickley_jet.jl` is to compare simulations with a ""native"" boundary and an immersed boundary with the same effective domain size, grid spacing, and numerics. @whitleyv I suggest that we merge this PR once we verify that the validation scripts run efficiently. After that we can work on careful testing and analysis of the validation case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733
https://github.com/CliMA/Oceananigans.jl/pull/1733:521,Security,validat,validation,521,"This somewhat large and WIP PR implements immersed boundary in the non-hydrostatic algorithm used by `IncompressibleModel`. . It also accelerates using `ImmersedBoundaryGrid` with high-order advection by encoding the ""boundary buffer"" (the number of grid points away from the boundary where second-order advection must be used) in the type signature of each advection scheme. This allows us to use dispatch to identify the correct criterion to use to determine whether a grid point is ""near boundary"" or not. It adds two validation tests: `shallow_water_flow_past_cape.jl` and `immersed_bickley_jet.jl`. The intent of `immersed_bickley_jet.jl` is to compare simulations with a ""native"" boundary and an immersed boundary with the same effective domain size, grid spacing, and numerics. @whitleyv I suggest that we merge this PR once we verify that the validation scripts run efficiently. After that we can work on careful testing and analysis of the validation case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733
https://github.com/CliMA/Oceananigans.jl/pull/1733:851,Security,validat,validation,851,"This somewhat large and WIP PR implements immersed boundary in the non-hydrostatic algorithm used by `IncompressibleModel`. . It also accelerates using `ImmersedBoundaryGrid` with high-order advection by encoding the ""boundary buffer"" (the number of grid points away from the boundary where second-order advection must be used) in the type signature of each advection scheme. This allows us to use dispatch to identify the correct criterion to use to determine whether a grid point is ""near boundary"" or not. It adds two validation tests: `shallow_water_flow_past_cape.jl` and `immersed_bickley_jet.jl`. The intent of `immersed_bickley_jet.jl` is to compare simulations with a ""native"" boundary and an immersed boundary with the same effective domain size, grid spacing, and numerics. @whitleyv I suggest that we merge this PR once we verify that the validation scripts run efficiently. After that we can work on careful testing and analysis of the validation case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733
https://github.com/CliMA/Oceananigans.jl/pull/1733:949,Security,validat,validation,949,"This somewhat large and WIP PR implements immersed boundary in the non-hydrostatic algorithm used by `IncompressibleModel`. . It also accelerates using `ImmersedBoundaryGrid` with high-order advection by encoding the ""boundary buffer"" (the number of grid points away from the boundary where second-order advection must be used) in the type signature of each advection scheme. This allows us to use dispatch to identify the correct criterion to use to determine whether a grid point is ""near boundary"" or not. It adds two validation tests: `shallow_water_flow_past_cape.jl` and `immersed_bickley_jet.jl`. The intent of `immersed_bickley_jet.jl` is to compare simulations with a ""native"" boundary and an immersed boundary with the same effective domain size, grid spacing, and numerics. @whitleyv I suggest that we merge this PR once we verify that the validation scripts run efficiently. After that we can work on careful testing and analysis of the validation case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733
https://github.com/CliMA/Oceananigans.jl/pull/1733:532,Testability,test,tests,532,"This somewhat large and WIP PR implements immersed boundary in the non-hydrostatic algorithm used by `IncompressibleModel`. . It also accelerates using `ImmersedBoundaryGrid` with high-order advection by encoding the ""boundary buffer"" (the number of grid points away from the boundary where second-order advection must be used) in the type signature of each advection scheme. This allows us to use dispatch to identify the correct criterion to use to determine whether a grid point is ""near boundary"" or not. It adds two validation tests: `shallow_water_flow_past_cape.jl` and `immersed_bickley_jet.jl`. The intent of `immersed_bickley_jet.jl` is to compare simulations with a ""native"" boundary and an immersed boundary with the same effective domain size, grid spacing, and numerics. @whitleyv I suggest that we merge this PR once we verify that the validation scripts run efficiently. After that we can work on careful testing and analysis of the validation case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733
https://github.com/CliMA/Oceananigans.jl/pull/1733:921,Testability,test,testing,921,"This somewhat large and WIP PR implements immersed boundary in the non-hydrostatic algorithm used by `IncompressibleModel`. . It also accelerates using `ImmersedBoundaryGrid` with high-order advection by encoding the ""boundary buffer"" (the number of grid points away from the boundary where second-order advection must be used) in the type signature of each advection scheme. This allows us to use dispatch to identify the correct criterion to use to determine whether a grid point is ""near boundary"" or not. It adds two validation tests: `shallow_water_flow_past_cape.jl` and `immersed_bickley_jet.jl`. The intent of `immersed_bickley_jet.jl` is to compare simulations with a ""native"" boundary and an immersed boundary with the same effective domain size, grid spacing, and numerics. @whitleyv I suggest that we merge this PR once we verify that the validation scripts run efficiently. After that we can work on careful testing and analysis of the validation case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733
https://github.com/CliMA/Oceananigans.jl/issues/1734:99,Availability,error,error,99,"When `NaNChecker` (included as a diagnostic in simulations by default) finds a `NaN`, it throws an error. In turn this produces a huge stack trace leading all the way to `src/Diagnostics/nan_checker.jl`. But this huge stacktrace isn't really necessary: NaNs are usually due to issues with the numerical / physical setup (too-long time-step, etc). The stacktrace is inconvenient because it requires scrolling / investigation to deduce that the problem is a NaN, rather than some other julia error associated with a script (or source code). What we really want is to do when we discover a NaN is to `stop(simulation)`. This would also allow code that occurs after `run!(simulation)` to be executed (often desired, if it contains analysis that would help deduce the cause of the NaN). This could be related to #1095; if we use exceptions in place of `stop(simulation)` then throwing an error after finding a NaN is the right thing to do.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1734
https://github.com/CliMA/Oceananigans.jl/issues/1734:490,Availability,error,error,490,"When `NaNChecker` (included as a diagnostic in simulations by default) finds a `NaN`, it throws an error. In turn this produces a huge stack trace leading all the way to `src/Diagnostics/nan_checker.jl`. But this huge stacktrace isn't really necessary: NaNs are usually due to issues with the numerical / physical setup (too-long time-step, etc). The stacktrace is inconvenient because it requires scrolling / investigation to deduce that the problem is a NaN, rather than some other julia error associated with a script (or source code). What we really want is to do when we discover a NaN is to `stop(simulation)`. This would also allow code that occurs after `run!(simulation)` to be executed (often desired, if it contains analysis that would help deduce the cause of the NaN). This could be related to #1095; if we use exceptions in place of `stop(simulation)` then throwing an error after finding a NaN is the right thing to do.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1734
https://github.com/CliMA/Oceananigans.jl/issues/1734:883,Availability,error,error,883,"When `NaNChecker` (included as a diagnostic in simulations by default) finds a `NaN`, it throws an error. In turn this produces a huge stack trace leading all the way to `src/Diagnostics/nan_checker.jl`. But this huge stacktrace isn't really necessary: NaNs are usually due to issues with the numerical / physical setup (too-long time-step, etc). The stacktrace is inconvenient because it requires scrolling / investigation to deduce that the problem is a NaN, rather than some other julia error associated with a script (or source code). What we really want is to do when we discover a NaN is to `stop(simulation)`. This would also allow code that occurs after `run!(simulation)` to be executed (often desired, if it contains analysis that would help deduce the cause of the NaN). This could be related to #1095; if we use exceptions in place of `stop(simulation)` then throwing an error after finding a NaN is the right thing to do.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1734
https://github.com/CliMA/Oceananigans.jl/pull/1735:67,Testability,benchmark,benchmarks,67,"With @henryg888, we made these changes to make these shallow water benchmarks. Next, we will introduce code to plot the results, as can be found in #1722",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1735
https://github.com/CliMA/Oceananigans.jl/pull/1737:127,Integrability,wrap,wrapped,127,This PR adds a set of changes so that needed dispatch paths for CubedSphereGrid are followed when CubedSphereFaceGrid tuple is wrapped in an ImmersedBoundary type. . With these changes the https://github.com/CliMA/Oceananigans.jl/blob/cnh-glw/immersed-cubed-sphere/validation/immersed_boundaries/immersed_cubed_sphere_rossby_haurwitz.jl code works identically for non-immersed and immersed cube sphere.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1737
https://github.com/CliMA/Oceananigans.jl/pull/1737:265,Security,validat,validation,265,This PR adds a set of changes so that needed dispatch paths for CubedSphereGrid are followed when CubedSphereFaceGrid tuple is wrapped in an ImmersedBoundary type. . With these changes the https://github.com/CliMA/Oceananigans.jl/blob/cnh-glw/immersed-cubed-sphere/validation/immersed_boundaries/immersed_cubed_sphere_rossby_haurwitz.jl code works identically for non-immersed and immersed cube sphere.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1737
https://github.com/CliMA/Oceananigans.jl/pull/1738:527,Security,validat,validation,527,"This PR implements a relatively simple convective adjustment scheme that provides the option for convective adjustment of both momentum and tracers. The closure scheme implements only a vertical diffusivity, and has a convenience ""background diffusivity"" in addition to a convective diffusivity that is active when the buoyancy gradient is unstable. Both the convective and background diffusivities may be functions of space and time, or may be discrete fields, and can be different for each tracer. Here's a result from a new validation test:. ![image](https://user-images.githubusercontent.com/15271942/120872660-cf88cc00-c54b-11eb-991a-8ff835bd3eb0.png). I also need to add unit tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1738
https://github.com/CliMA/Oceananigans.jl/pull/1738:538,Testability,test,test,538,"This PR implements a relatively simple convective adjustment scheme that provides the option for convective adjustment of both momentum and tracers. The closure scheme implements only a vertical diffusivity, and has a convenience ""background diffusivity"" in addition to a convective diffusivity that is active when the buoyancy gradient is unstable. Both the convective and background diffusivities may be functions of space and time, or may be discrete fields, and can be different for each tracer. Here's a result from a new validation test:. ![image](https://user-images.githubusercontent.com/15271942/120872660-cf88cc00-c54b-11eb-991a-8ff835bd3eb0.png). I also need to add unit tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1738
https://github.com/CliMA/Oceananigans.jl/pull/1738:682,Testability,test,tests,682,"This PR implements a relatively simple convective adjustment scheme that provides the option for convective adjustment of both momentum and tracers. The closure scheme implements only a vertical diffusivity, and has a convenience ""background diffusivity"" in addition to a convective diffusivity that is active when the buoyancy gradient is unstable. Both the convective and background diffusivities may be functions of space and time, or may be discrete fields, and can be different for each tracer. Here's a result from a new validation test:. ![image](https://user-images.githubusercontent.com/15271942/120872660-cf88cc00-c54b-11eb-991a-8ff835bd3eb0.png). I also need to add unit tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1738
https://github.com/CliMA/Oceananigans.jl/pull/1738:32,Usability,simpl,simple,32,"This PR implements a relatively simple convective adjustment scheme that provides the option for convective adjustment of both momentum and tracers. The closure scheme implements only a vertical diffusivity, and has a convenience ""background diffusivity"" in addition to a convective diffusivity that is active when the buoyancy gradient is unstable. Both the convective and background diffusivities may be functions of space and time, or may be discrete fields, and can be different for each tracer. Here's a result from a new validation test:. ![image](https://user-images.githubusercontent.com/15271942/120872660-cf88cc00-c54b-11eb-991a-8ff835bd3eb0.png). I also need to add unit tests.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1738
https://github.com/CliMA/Oceananigans.jl/issues/1739:244,Security,Validat,Validation,244,"In #1648 we introduced a script to show the convergence rates for the difference advection schemes. I just tried it and sadly it now gives bad results. I will workon fixing this. Also, it is probably a good idea to mention this in the docs in `Validation experiments`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1739
https://github.com/CliMA/Oceananigans.jl/issues/1741:243,Energy Efficiency,adapt,adaptive,243,"Hello everyone, I have tested ```VerticallyStretchedRectilinearGrid( )``` and found a hard time in setting up the time step for a stable solution. ; I will going to post the whole issue but before that I just want to know weather is there any adaptive time stepping method like we did have ```TimeStepWizard``` . I have searched and failed may be I might have missed it that's why I first ask this question.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741
https://github.com/CliMA/Oceananigans.jl/issues/1741:243,Modifiability,adapt,adaptive,243,"Hello everyone, I have tested ```VerticallyStretchedRectilinearGrid( )``` and found a hard time in setting up the time step for a stable solution. ; I will going to post the whole issue but before that I just want to know weather is there any adaptive time stepping method like we did have ```TimeStepWizard``` . I have searched and failed may be I might have missed it that's why I first ask this question.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741
https://github.com/CliMA/Oceananigans.jl/issues/1741:23,Testability,test,tested,23,"Hello everyone, I have tested ```VerticallyStretchedRectilinearGrid( )``` and found a hard time in setting up the time step for a stable solution. ; I will going to post the whole issue but before that I just want to know weather is there any adaptive time stepping method like we did have ```TimeStepWizard``` . I have searched and failed may be I might have missed it that's why I first ask this question.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741
https://github.com/CliMA/Oceananigans.jl/pull/1744:744,Availability,down,download,744,"This WIP PR implements an overturning, eddying channel example following [Abernathey et al. 2011](https://journals.ametsoc.org/view/journals/phoc/41/12/jpo-d-11-023.1.xml). This is a mesoscale turbulence problem in a channel geometry on a beta plane, forced by surface buoyancy flux and wind stress, damped by linear drag, and restored in a thin region near the northern boundary to a stable buoyancy profile, thereby forcing an overturning circulation. The script follows @sandreza's implementation at https://github.com/sandreza/Mesoscale/blob/master/oceananigans_scripts/oceananigans_makie.jl, updated for modern Oceananigans. Ultimately I hope we can run the example to equilibrium offline, on a GPU. Then, the example will use DataDeps to download a checkpoint and restart the simulation from a checkpoint, and make an animation of the turbulent, equilibrated flow integrated over a short window of time (feasible for an example). The example will thus illustrate:. * Checkpointing and picking up from a checkpoint; * Using HydrostaticFreeSurfaceModel, VerticallyStretchedRectilinearGrid, ConvectiveAdjustmentVerticalDiffusivity, channel topologies, Relaxation forcing, and BetaPlane Coriolis forcing; * using FieldTimeSeries and hopefully GLMakie to create a volume rendering of the flow",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744
https://github.com/CliMA/Oceananigans.jl/pull/1744:755,Availability,checkpoint,checkpoint,755,"This WIP PR implements an overturning, eddying channel example following [Abernathey et al. 2011](https://journals.ametsoc.org/view/journals/phoc/41/12/jpo-d-11-023.1.xml). This is a mesoscale turbulence problem in a channel geometry on a beta plane, forced by surface buoyancy flux and wind stress, damped by linear drag, and restored in a thin region near the northern boundary to a stable buoyancy profile, thereby forcing an overturning circulation. The script follows @sandreza's implementation at https://github.com/sandreza/Mesoscale/blob/master/oceananigans_scripts/oceananigans_makie.jl, updated for modern Oceananigans. Ultimately I hope we can run the example to equilibrium offline, on a GPU. Then, the example will use DataDeps to download a checkpoint and restart the simulation from a checkpoint, and make an animation of the turbulent, equilibrated flow integrated over a short window of time (feasible for an example). The example will thus illustrate:. * Checkpointing and picking up from a checkpoint; * Using HydrostaticFreeSurfaceModel, VerticallyStretchedRectilinearGrid, ConvectiveAdjustmentVerticalDiffusivity, channel topologies, Relaxation forcing, and BetaPlane Coriolis forcing; * using FieldTimeSeries and hopefully GLMakie to create a volume rendering of the flow",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744
https://github.com/CliMA/Oceananigans.jl/pull/1744:800,Availability,checkpoint,checkpoint,800,"This WIP PR implements an overturning, eddying channel example following [Abernathey et al. 2011](https://journals.ametsoc.org/view/journals/phoc/41/12/jpo-d-11-023.1.xml). This is a mesoscale turbulence problem in a channel geometry on a beta plane, forced by surface buoyancy flux and wind stress, damped by linear drag, and restored in a thin region near the northern boundary to a stable buoyancy profile, thereby forcing an overturning circulation. The script follows @sandreza's implementation at https://github.com/sandreza/Mesoscale/blob/master/oceananigans_scripts/oceananigans_makie.jl, updated for modern Oceananigans. Ultimately I hope we can run the example to equilibrium offline, on a GPU. Then, the example will use DataDeps to download a checkpoint and restart the simulation from a checkpoint, and make an animation of the turbulent, equilibrated flow integrated over a short window of time (feasible for an example). The example will thus illustrate:. * Checkpointing and picking up from a checkpoint; * Using HydrostaticFreeSurfaceModel, VerticallyStretchedRectilinearGrid, ConvectiveAdjustmentVerticalDiffusivity, channel topologies, Relaxation forcing, and BetaPlane Coriolis forcing; * using FieldTimeSeries and hopefully GLMakie to create a volume rendering of the flow",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744
https://github.com/CliMA/Oceananigans.jl/pull/1744:973,Availability,Checkpoint,Checkpointing,973,"This WIP PR implements an overturning, eddying channel example following [Abernathey et al. 2011](https://journals.ametsoc.org/view/journals/phoc/41/12/jpo-d-11-023.1.xml). This is a mesoscale turbulence problem in a channel geometry on a beta plane, forced by surface buoyancy flux and wind stress, damped by linear drag, and restored in a thin region near the northern boundary to a stable buoyancy profile, thereby forcing an overturning circulation. The script follows @sandreza's implementation at https://github.com/sandreza/Mesoscale/blob/master/oceananigans_scripts/oceananigans_makie.jl, updated for modern Oceananigans. Ultimately I hope we can run the example to equilibrium offline, on a GPU. Then, the example will use DataDeps to download a checkpoint and restart the simulation from a checkpoint, and make an animation of the turbulent, equilibrated flow integrated over a short window of time (feasible for an example). The example will thus illustrate:. * Checkpointing and picking up from a checkpoint; * Using HydrostaticFreeSurfaceModel, VerticallyStretchedRectilinearGrid, ConvectiveAdjustmentVerticalDiffusivity, channel topologies, Relaxation forcing, and BetaPlane Coriolis forcing; * using FieldTimeSeries and hopefully GLMakie to create a volume rendering of the flow",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744
https://github.com/CliMA/Oceananigans.jl/pull/1744:1009,Availability,checkpoint,checkpoint,1009,"This WIP PR implements an overturning, eddying channel example following [Abernathey et al. 2011](https://journals.ametsoc.org/view/journals/phoc/41/12/jpo-d-11-023.1.xml). This is a mesoscale turbulence problem in a channel geometry on a beta plane, forced by surface buoyancy flux and wind stress, damped by linear drag, and restored in a thin region near the northern boundary to a stable buoyancy profile, thereby forcing an overturning circulation. The script follows @sandreza's implementation at https://github.com/sandreza/Mesoscale/blob/master/oceananigans_scripts/oceananigans_makie.jl, updated for modern Oceananigans. Ultimately I hope we can run the example to equilibrium offline, on a GPU. Then, the example will use DataDeps to download a checkpoint and restart the simulation from a checkpoint, and make an animation of the turbulent, equilibrated flow integrated over a short window of time (feasible for an example). The example will thus illustrate:. * Checkpointing and picking up from a checkpoint; * Using HydrostaticFreeSurfaceModel, VerticallyStretchedRectilinearGrid, ConvectiveAdjustmentVerticalDiffusivity, channel topologies, Relaxation forcing, and BetaPlane Coriolis forcing; * using FieldTimeSeries and hopefully GLMakie to create a volume rendering of the flow",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744
https://github.com/CliMA/Oceananigans.jl/pull/1744:597,Deployability,update,updated,597,"This WIP PR implements an overturning, eddying channel example following [Abernathey et al. 2011](https://journals.ametsoc.org/view/journals/phoc/41/12/jpo-d-11-023.1.xml). This is a mesoscale turbulence problem in a channel geometry on a beta plane, forced by surface buoyancy flux and wind stress, damped by linear drag, and restored in a thin region near the northern boundary to a stable buoyancy profile, thereby forcing an overturning circulation. The script follows @sandreza's implementation at https://github.com/sandreza/Mesoscale/blob/master/oceananigans_scripts/oceananigans_makie.jl, updated for modern Oceananigans. Ultimately I hope we can run the example to equilibrium offline, on a GPU. Then, the example will use DataDeps to download a checkpoint and restart the simulation from a checkpoint, and make an animation of the turbulent, equilibrated flow integrated over a short window of time (feasible for an example). The example will thus illustrate:. * Checkpointing and picking up from a checkpoint; * Using HydrostaticFreeSurfaceModel, VerticallyStretchedRectilinearGrid, ConvectiveAdjustmentVerticalDiffusivity, channel topologies, Relaxation forcing, and BetaPlane Coriolis forcing; * using FieldTimeSeries and hopefully GLMakie to create a volume rendering of the flow",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744
https://github.com/CliMA/Oceananigans.jl/pull/1744:870,Deployability,integrat,integrated,870,"This WIP PR implements an overturning, eddying channel example following [Abernathey et al. 2011](https://journals.ametsoc.org/view/journals/phoc/41/12/jpo-d-11-023.1.xml). This is a mesoscale turbulence problem in a channel geometry on a beta plane, forced by surface buoyancy flux and wind stress, damped by linear drag, and restored in a thin region near the northern boundary to a stable buoyancy profile, thereby forcing an overturning circulation. The script follows @sandreza's implementation at https://github.com/sandreza/Mesoscale/blob/master/oceananigans_scripts/oceananigans_makie.jl, updated for modern Oceananigans. Ultimately I hope we can run the example to equilibrium offline, on a GPU. Then, the example will use DataDeps to download a checkpoint and restart the simulation from a checkpoint, and make an animation of the turbulent, equilibrated flow integrated over a short window of time (feasible for an example). The example will thus illustrate:. * Checkpointing and picking up from a checkpoint; * Using HydrostaticFreeSurfaceModel, VerticallyStretchedRectilinearGrid, ConvectiveAdjustmentVerticalDiffusivity, channel topologies, Relaxation forcing, and BetaPlane Coriolis forcing; * using FieldTimeSeries and hopefully GLMakie to create a volume rendering of the flow",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744
https://github.com/CliMA/Oceananigans.jl/pull/1744:870,Integrability,integrat,integrated,870,"This WIP PR implements an overturning, eddying channel example following [Abernathey et al. 2011](https://journals.ametsoc.org/view/journals/phoc/41/12/jpo-d-11-023.1.xml). This is a mesoscale turbulence problem in a channel geometry on a beta plane, forced by surface buoyancy flux and wind stress, damped by linear drag, and restored in a thin region near the northern boundary to a stable buoyancy profile, thereby forcing an overturning circulation. The script follows @sandreza's implementation at https://github.com/sandreza/Mesoscale/blob/master/oceananigans_scripts/oceananigans_makie.jl, updated for modern Oceananigans. Ultimately I hope we can run the example to equilibrium offline, on a GPU. Then, the example will use DataDeps to download a checkpoint and restart the simulation from a checkpoint, and make an animation of the turbulent, equilibrated flow integrated over a short window of time (feasible for an example). The example will thus illustrate:. * Checkpointing and picking up from a checkpoint; * Using HydrostaticFreeSurfaceModel, VerticallyStretchedRectilinearGrid, ConvectiveAdjustmentVerticalDiffusivity, channel topologies, Relaxation forcing, and BetaPlane Coriolis forcing; * using FieldTimeSeries and hopefully GLMakie to create a volume rendering of the flow",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744
https://github.com/CliMA/Oceananigans.jl/pull/1746:992,Deployability,configurat,configuration,992,"Plots were added for the following benchmarking scripts, so as to present the most important data found in the original output tables in a visual format that is easier to analyze:; ```; benchmark_shallow_water_model.jl; benchmark_incompressible_model.jl; strong_scaling_shallow_water_model.jl; weak_scaling_shallow_water_model.jl; strong_scaling_incompressible_model.jl; ```; The plotting requires the Plots and PyPlot packages. Additional fixes were also made. Three manual calls to the garbage collection function, `GC()` was added in `src/Benchmarks.jl` which enabled `benchmark_shallow_water_model.jl` and `benchmark_incompressible_model.jl` to run multiple benchmarking cases with large grids without running out of memory. One such call is `GC( true)` which triggers a ""full"" garbage collection that is able to remove younger unreferenced objects. For the _single files of the scaling benchmarking scripts, the `@benchmark` portion was adjusted to have `evals=1` on top of the original configuration of `samples=10`. This allowed larger ranks of CPUs to be benchmarked. Originally, without the configuration limiting evaluations to 1, as the number of CPUs increased and the time per evaluation decreased, the number of times the benchmarked bit of code was run became too great and caused deadlocks between the MPI processes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746
https://github.com/CliMA/Oceananigans.jl/pull/1746:1100,Deployability,configurat,configuration,1100,"Plots were added for the following benchmarking scripts, so as to present the most important data found in the original output tables in a visual format that is easier to analyze:; ```; benchmark_shallow_water_model.jl; benchmark_incompressible_model.jl; strong_scaling_shallow_water_model.jl; weak_scaling_shallow_water_model.jl; strong_scaling_incompressible_model.jl; ```; The plotting requires the Plots and PyPlot packages. Additional fixes were also made. Three manual calls to the garbage collection function, `GC()` was added in `src/Benchmarks.jl` which enabled `benchmark_shallow_water_model.jl` and `benchmark_incompressible_model.jl` to run multiple benchmarking cases with large grids without running out of memory. One such call is `GC( true)` which triggers a ""full"" garbage collection that is able to remove younger unreferenced objects. For the _single files of the scaling benchmarking scripts, the `@benchmark` portion was adjusted to have `evals=1` on top of the original configuration of `samples=10`. This allowed larger ranks of CPUs to be benchmarked. Originally, without the configuration limiting evaluations to 1, as the number of CPUs increased and the time per evaluation decreased, the number of times the benchmarked bit of code was run became too great and caused deadlocks between the MPI processes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746
https://github.com/CliMA/Oceananigans.jl/pull/1746:992,Modifiability,config,configuration,992,"Plots were added for the following benchmarking scripts, so as to present the most important data found in the original output tables in a visual format that is easier to analyze:; ```; benchmark_shallow_water_model.jl; benchmark_incompressible_model.jl; strong_scaling_shallow_water_model.jl; weak_scaling_shallow_water_model.jl; strong_scaling_incompressible_model.jl; ```; The plotting requires the Plots and PyPlot packages. Additional fixes were also made. Three manual calls to the garbage collection function, `GC()` was added in `src/Benchmarks.jl` which enabled `benchmark_shallow_water_model.jl` and `benchmark_incompressible_model.jl` to run multiple benchmarking cases with large grids without running out of memory. One such call is `GC( true)` which triggers a ""full"" garbage collection that is able to remove younger unreferenced objects. For the _single files of the scaling benchmarking scripts, the `@benchmark` portion was adjusted to have `evals=1` on top of the original configuration of `samples=10`. This allowed larger ranks of CPUs to be benchmarked. Originally, without the configuration limiting evaluations to 1, as the number of CPUs increased and the time per evaluation decreased, the number of times the benchmarked bit of code was run became too great and caused deadlocks between the MPI processes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746
https://github.com/CliMA/Oceananigans.jl/pull/1746:1100,Modifiability,config,configuration,1100,"Plots were added for the following benchmarking scripts, so as to present the most important data found in the original output tables in a visual format that is easier to analyze:; ```; benchmark_shallow_water_model.jl; benchmark_incompressible_model.jl; strong_scaling_shallow_water_model.jl; weak_scaling_shallow_water_model.jl; strong_scaling_incompressible_model.jl; ```; The plotting requires the Plots and PyPlot packages. Additional fixes were also made. Three manual calls to the garbage collection function, `GC()` was added in `src/Benchmarks.jl` which enabled `benchmark_shallow_water_model.jl` and `benchmark_incompressible_model.jl` to run multiple benchmarking cases with large grids without running out of memory. One such call is `GC( true)` which triggers a ""full"" garbage collection that is able to remove younger unreferenced objects. For the _single files of the scaling benchmarking scripts, the `@benchmark` portion was adjusted to have `evals=1` on top of the original configuration of `samples=10`. This allowed larger ranks of CPUs to be benchmarked. Originally, without the configuration limiting evaluations to 1, as the number of CPUs increased and the time per evaluation decreased, the number of times the benchmarked bit of code was run became too great and caused deadlocks between the MPI processes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746
https://github.com/CliMA/Oceananigans.jl/pull/1746:35,Testability,benchmark,benchmarking,35,"Plots were added for the following benchmarking scripts, so as to present the most important data found in the original output tables in a visual format that is easier to analyze:; ```; benchmark_shallow_water_model.jl; benchmark_incompressible_model.jl; strong_scaling_shallow_water_model.jl; weak_scaling_shallow_water_model.jl; strong_scaling_incompressible_model.jl; ```; The plotting requires the Plots and PyPlot packages. Additional fixes were also made. Three manual calls to the garbage collection function, `GC()` was added in `src/Benchmarks.jl` which enabled `benchmark_shallow_water_model.jl` and `benchmark_incompressible_model.jl` to run multiple benchmarking cases with large grids without running out of memory. One such call is `GC( true)` which triggers a ""full"" garbage collection that is able to remove younger unreferenced objects. For the _single files of the scaling benchmarking scripts, the `@benchmark` portion was adjusted to have `evals=1` on top of the original configuration of `samples=10`. This allowed larger ranks of CPUs to be benchmarked. Originally, without the configuration limiting evaluations to 1, as the number of CPUs increased and the time per evaluation decreased, the number of times the benchmarked bit of code was run became too great and caused deadlocks between the MPI processes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746
https://github.com/CliMA/Oceananigans.jl/pull/1746:542,Testability,Benchmark,Benchmarks,542,"Plots were added for the following benchmarking scripts, so as to present the most important data found in the original output tables in a visual format that is easier to analyze:; ```; benchmark_shallow_water_model.jl; benchmark_incompressible_model.jl; strong_scaling_shallow_water_model.jl; weak_scaling_shallow_water_model.jl; strong_scaling_incompressible_model.jl; ```; The plotting requires the Plots and PyPlot packages. Additional fixes were also made. Three manual calls to the garbage collection function, `GC()` was added in `src/Benchmarks.jl` which enabled `benchmark_shallow_water_model.jl` and `benchmark_incompressible_model.jl` to run multiple benchmarking cases with large grids without running out of memory. One such call is `GC( true)` which triggers a ""full"" garbage collection that is able to remove younger unreferenced objects. For the _single files of the scaling benchmarking scripts, the `@benchmark` portion was adjusted to have `evals=1` on top of the original configuration of `samples=10`. This allowed larger ranks of CPUs to be benchmarked. Originally, without the configuration limiting evaluations to 1, as the number of CPUs increased and the time per evaluation decreased, the number of times the benchmarked bit of code was run became too great and caused deadlocks between the MPI processes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746
https://github.com/CliMA/Oceananigans.jl/pull/1746:662,Testability,benchmark,benchmarking,662,"Plots were added for the following benchmarking scripts, so as to present the most important data found in the original output tables in a visual format that is easier to analyze:; ```; benchmark_shallow_water_model.jl; benchmark_incompressible_model.jl; strong_scaling_shallow_water_model.jl; weak_scaling_shallow_water_model.jl; strong_scaling_incompressible_model.jl; ```; The plotting requires the Plots and PyPlot packages. Additional fixes were also made. Three manual calls to the garbage collection function, `GC()` was added in `src/Benchmarks.jl` which enabled `benchmark_shallow_water_model.jl` and `benchmark_incompressible_model.jl` to run multiple benchmarking cases with large grids without running out of memory. One such call is `GC( true)` which triggers a ""full"" garbage collection that is able to remove younger unreferenced objects. For the _single files of the scaling benchmarking scripts, the `@benchmark` portion was adjusted to have `evals=1` on top of the original configuration of `samples=10`. This allowed larger ranks of CPUs to be benchmarked. Originally, without the configuration limiting evaluations to 1, as the number of CPUs increased and the time per evaluation decreased, the number of times the benchmarked bit of code was run became too great and caused deadlocks between the MPI processes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746
https://github.com/CliMA/Oceananigans.jl/pull/1746:891,Testability,benchmark,benchmarking,891,"Plots were added for the following benchmarking scripts, so as to present the most important data found in the original output tables in a visual format that is easier to analyze:; ```; benchmark_shallow_water_model.jl; benchmark_incompressible_model.jl; strong_scaling_shallow_water_model.jl; weak_scaling_shallow_water_model.jl; strong_scaling_incompressible_model.jl; ```; The plotting requires the Plots and PyPlot packages. Additional fixes were also made. Three manual calls to the garbage collection function, `GC()` was added in `src/Benchmarks.jl` which enabled `benchmark_shallow_water_model.jl` and `benchmark_incompressible_model.jl` to run multiple benchmarking cases with large grids without running out of memory. One such call is `GC( true)` which triggers a ""full"" garbage collection that is able to remove younger unreferenced objects. For the _single files of the scaling benchmarking scripts, the `@benchmark` portion was adjusted to have `evals=1` on top of the original configuration of `samples=10`. This allowed larger ranks of CPUs to be benchmarked. Originally, without the configuration limiting evaluations to 1, as the number of CPUs increased and the time per evaluation decreased, the number of times the benchmarked bit of code was run became too great and caused deadlocks between the MPI processes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746
https://github.com/CliMA/Oceananigans.jl/pull/1746:919,Testability,benchmark,benchmark,919,"Plots were added for the following benchmarking scripts, so as to present the most important data found in the original output tables in a visual format that is easier to analyze:; ```; benchmark_shallow_water_model.jl; benchmark_incompressible_model.jl; strong_scaling_shallow_water_model.jl; weak_scaling_shallow_water_model.jl; strong_scaling_incompressible_model.jl; ```; The plotting requires the Plots and PyPlot packages. Additional fixes were also made. Three manual calls to the garbage collection function, `GC()` was added in `src/Benchmarks.jl` which enabled `benchmark_shallow_water_model.jl` and `benchmark_incompressible_model.jl` to run multiple benchmarking cases with large grids without running out of memory. One such call is `GC( true)` which triggers a ""full"" garbage collection that is able to remove younger unreferenced objects. For the _single files of the scaling benchmarking scripts, the `@benchmark` portion was adjusted to have `evals=1` on top of the original configuration of `samples=10`. This allowed larger ranks of CPUs to be benchmarked. Originally, without the configuration limiting evaluations to 1, as the number of CPUs increased and the time per evaluation decreased, the number of times the benchmarked bit of code was run became too great and caused deadlocks between the MPI processes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746
https://github.com/CliMA/Oceananigans.jl/pull/1746:1063,Testability,benchmark,benchmarked,1063,"Plots were added for the following benchmarking scripts, so as to present the most important data found in the original output tables in a visual format that is easier to analyze:; ```; benchmark_shallow_water_model.jl; benchmark_incompressible_model.jl; strong_scaling_shallow_water_model.jl; weak_scaling_shallow_water_model.jl; strong_scaling_incompressible_model.jl; ```; The plotting requires the Plots and PyPlot packages. Additional fixes were also made. Three manual calls to the garbage collection function, `GC()` was added in `src/Benchmarks.jl` which enabled `benchmark_shallow_water_model.jl` and `benchmark_incompressible_model.jl` to run multiple benchmarking cases with large grids without running out of memory. One such call is `GC( true)` which triggers a ""full"" garbage collection that is able to remove younger unreferenced objects. For the _single files of the scaling benchmarking scripts, the `@benchmark` portion was adjusted to have `evals=1` on top of the original configuration of `samples=10`. This allowed larger ranks of CPUs to be benchmarked. Originally, without the configuration limiting evaluations to 1, as the number of CPUs increased and the time per evaluation decreased, the number of times the benchmarked bit of code was run became too great and caused deadlocks between the MPI processes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746
https://github.com/CliMA/Oceananigans.jl/pull/1746:1236,Testability,benchmark,benchmarked,1236,"Plots were added for the following benchmarking scripts, so as to present the most important data found in the original output tables in a visual format that is easier to analyze:; ```; benchmark_shallow_water_model.jl; benchmark_incompressible_model.jl; strong_scaling_shallow_water_model.jl; weak_scaling_shallow_water_model.jl; strong_scaling_incompressible_model.jl; ```; The plotting requires the Plots and PyPlot packages. Additional fixes were also made. Three manual calls to the garbage collection function, `GC()` was added in `src/Benchmarks.jl` which enabled `benchmark_shallow_water_model.jl` and `benchmark_incompressible_model.jl` to run multiple benchmarking cases with large grids without running out of memory. One such call is `GC( true)` which triggers a ""full"" garbage collection that is able to remove younger unreferenced objects. For the _single files of the scaling benchmarking scripts, the `@benchmark` portion was adjusted to have `evals=1` on top of the original configuration of `samples=10`. This allowed larger ranks of CPUs to be benchmarked. Originally, without the configuration limiting evaluations to 1, as the number of CPUs increased and the time per evaluation decreased, the number of times the benchmarked bit of code was run became too great and caused deadlocks between the MPI processes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746
https://github.com/CliMA/Oceananigans.jl/pull/1748:25,Integrability,contract,contraction,25,Changed units for haline contraction coefficients to match what's listed in table 1.2 of Vallis (from ppt to psu).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1748
https://github.com/CliMA/Oceananigans.jl/issues/1749:122,Availability,error,error,122,"When I try to get `DiffusiveCFL` for a simulation with a `VerticallyStretchedGrid` and an LES closure I get the following error message:. ```julia; julia> using Oceananigans. julia> Nx = Ny = Nz = 32; 32. julia> S = 0.8 # Stretching factor; 0.8. julia> hyperbolically_spaced_nodes(k) = -Lz-Lz*(tanh(S * ( (-(k-34) - 1) / Nz - 1)) / tanh(S)); hyperbolically_spaced_nodes (generic function with 1 method). julia> Lz = 32; 32. julia> grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz),; architecture = CPU(),; x = (0,64),; y = (0,64),; halo = (3, 3, 3),; z_faces = hyperbolically_spaced_nodes); VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 64.0], y ∈ [0.0, 64.0], z ∈ [-32.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (32, 32, 32); halo size (Hx, Hy, Hz): (3, 3, 3); grid spacing (Δx, Δy, Δz): (2.0, 2.0, [min=0.6847479408200634, max=1.2045016342496169]). julia> model = IncompressibleModel(grid=grid, closure=AnisotropicMinimumDissipation()); IncompressibleModel{CPU, Float64}(time = 0 seconds, iteration = 0) ; ├── grid: VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=32, Ny=32, Nz=32); ├── tracers: (:T, :S); ├── closure: AnisotropicMinimumDissipation{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, Nothing}; ├── buoyancy: SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}; └── coriolis: Nothing. julia> wizard = TimeStepWizard(cfl=1.0, Δt=10.0, max_change=1.1, max_Δt=1minute, min_Δt=0.1second); TimeStepWizard{Float64, typeof(Oceananigans.Utils.cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}(1.0, Inf, 1.1, 0.5, 60.0, 0.1, 10.0, Oceananigans.Utils.cell_advection_timescale, Oceananigans.Simulations.infinite_diffusion_timescale). julia> simulation = Simulation(model, Δt=wizard, stop_time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1749
https://github.com/CliMA/Oceananigans.jl/issues/1749:2910,Availability,ERROR,ERROR,2910,"zard, stop_time=40minutes, iteration_interval=10,); Simulation{typename(IncompressibleModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (TimeStepWizard{Float64, typeof(Oceananigans.Utils.cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}): 10 seconds ; ├── Iteration interval: 10; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 40 minutes, stop iteration: Inf; ├── Diagnostics: typename(OrderedCollections.OrderedDict) with 1 entry:; │ └── nan_checker => typename(NaNChecker); └── Output writers: typename(OrderedCollections.OrderedDict) with no entries. julia> AdvectiveCFL(simulation.Δt)(model); NaN. julia> DiffusiveCFL(simulation.Δt)(model); ERROR: type VerticallyStretchedRectilinearGrid has no field Δz; Stacktrace:; [1] getproperty(x::VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, f::Symbol); @ Base ./Base.jl:33; [2] min_Δxyz(grid::VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}); @ Oceananigans.TurbulenceClosures ~/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:12; [3] cell_diffusion_timescale(closure::AnisotropicMinimumDissipation{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, Float; ```; and the error continues. . Basically I think we just need to define `min_Δxyz` for `VerticallyStretchedGrid`s.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1749
https://github.com/CliMA/Oceananigans.jl/issues/1749:3884,Availability,error,error,3884,"zard, stop_time=40minutes, iteration_interval=10,); Simulation{typename(IncompressibleModel){typename(CPU), Float64}}; ├── Model clock: time = 0 seconds, iteration = 0 ; ├── Next time step (TimeStepWizard{Float64, typeof(Oceananigans.Utils.cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}): 10 seconds ; ├── Iteration interval: 10; ├── Stop criteria: Any[Oceananigans.Simulations.iteration_limit_exceeded, Oceananigans.Simulations.stop_time_exceeded, Oceananigans.Simulations.wall_time_limit_exceeded]; ├── Run time: 0 seconds, wall time limit: Inf; ├── Stop time: 40 minutes, stop iteration: Inf; ├── Diagnostics: typename(OrderedCollections.OrderedDict) with 1 entry:; │ └── nan_checker => typename(NaNChecker); └── Output writers: typename(OrderedCollections.OrderedDict) with no entries. julia> AdvectiveCFL(simulation.Δt)(model); NaN. julia> DiffusiveCFL(simulation.Δt)(model); ERROR: type VerticallyStretchedRectilinearGrid has no field Δz; Stacktrace:; [1] getproperty(x::VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, f::Symbol); @ Base ./Base.jl:33; [2] min_Δxyz(grid::VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}); @ Oceananigans.TurbulenceClosures ~/repos/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_diagnostics.jl:12; [3] cell_diffusion_timescale(closure::AnisotropicMinimumDissipation{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, Float; ```; and the error continues. . Basically I think we just need to define `min_Δxyz` for `VerticallyStretchedGrid`s.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1749
https://github.com/CliMA/Oceananigans.jl/issues/1749:128,Integrability,message,message,128,"When I try to get `DiffusiveCFL` for a simulation with a `VerticallyStretchedGrid` and an LES closure I get the following error message:. ```julia; julia> using Oceananigans. julia> Nx = Ny = Nz = 32; 32. julia> S = 0.8 # Stretching factor; 0.8. julia> hyperbolically_spaced_nodes(k) = -Lz-Lz*(tanh(S * ( (-(k-34) - 1) / Nz - 1)) / tanh(S)); hyperbolically_spaced_nodes (generic function with 1 method). julia> Lz = 32; 32. julia> grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz),; architecture = CPU(),; x = (0,64),; y = (0,64),; halo = (3, 3, 3),; z_faces = hyperbolically_spaced_nodes); VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 64.0], y ∈ [0.0, 64.0], z ∈ [-32.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (32, 32, 32); halo size (Hx, Hy, Hz): (3, 3, 3); grid spacing (Δx, Δy, Δz): (2.0, 2.0, [min=0.6847479408200634, max=1.2045016342496169]). julia> model = IncompressibleModel(grid=grid, closure=AnisotropicMinimumDissipation()); IncompressibleModel{CPU, Float64}(time = 0 seconds, iteration = 0) ; ├── grid: VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=32, Ny=32, Nz=32); ├── tracers: (:T, :S); ├── closure: AnisotropicMinimumDissipation{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, Nothing}; ├── buoyancy: SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}; └── coriolis: Nothing. julia> wizard = TimeStepWizard(cfl=1.0, Δt=10.0, max_change=1.1, max_Δt=1minute, min_Δt=0.1second); TimeStepWizard{Float64, typeof(Oceananigans.Utils.cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}(1.0, Inf, 1.1, 0.5, 60.0, 0.1, 10.0, Oceananigans.Utils.cell_advection_timescale, Oceananigans.Simulations.infinite_diffusion_timescale). julia> simulation = Simulation(model, Δt=wizard, stop_time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1749
https://github.com/CliMA/Oceananigans.jl/pull/1751:146,Availability,ERROR,ERROR,146,"Using `min_Δz(grid::VerticallyStretchedRectilinearGrid)` on GPU fails. The reason is that. ```julia; julia> minimum(view(grid.Δzᵃᵃᶜ, 1:grid.Nz)); ERROR: scalar getindex is disallowed; ```; fails on the GPU. The line should be `minimum(view(parent(grid.Δzᵃᵃᶜ), 1:grid.Nz))`. This error had been there all along but I guess no one caught it. This commit should fix it, but should we also include a test that would catch it?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1751
https://github.com/CliMA/Oceananigans.jl/pull/1751:279,Availability,error,error,279,"Using `min_Δz(grid::VerticallyStretchedRectilinearGrid)` on GPU fails. The reason is that. ```julia; julia> minimum(view(grid.Δzᵃᵃᶜ, 1:grid.Nz)); ERROR: scalar getindex is disallowed; ```; fails on the GPU. The line should be `minimum(view(parent(grid.Δzᵃᵃᶜ), 1:grid.Nz))`. This error had been there all along but I guess no one caught it. This commit should fix it, but should we also include a test that would catch it?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1751
https://github.com/CliMA/Oceananigans.jl/pull/1751:396,Testability,test,test,396,"Using `min_Δz(grid::VerticallyStretchedRectilinearGrid)` on GPU fails. The reason is that. ```julia; julia> minimum(view(grid.Δzᵃᵃᶜ, 1:grid.Nz)); ERROR: scalar getindex is disallowed; ```; fails on the GPU. The line should be `minimum(view(parent(grid.Δzᵃᵃᶜ), 1:grid.Nz))`. This error had been there all along but I guess no one caught it. This commit should fix it, but should we also include a test that would catch it?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1751
https://github.com/CliMA/Oceananigans.jl/issues/1753:269,Integrability,interface,interface,269,"The constructor for `VerticallyStretchedRectilinearGrid` contains:. https://github.com/CliMA/Oceananigans.jl/blob/55500496bc76e5870a0e455d1dda059793e827d3/src/Grids/vertically_stretched_rectilinear_grid.jl#L160-L162. which adjusts the vertical grid spacing at the cell interface just below the top boundary. This adjustment must then render grid calculations inaccurate, because none of the other metrics or node locations are adjusted. What's going on?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1753
https://github.com/CliMA/Oceananigans.jl/pull/1755:295,Integrability,interface,interfaces,295,"These lines should not be there and at the least lower the accuracy of calculations on stretched grids. We need tests that the metrics and grid geometry are correct for stretched grids (eg all the cell spacings added up gives the total domain size; cell centers are located halfway between cell interfaces, etc). . Not sure why these lines are there but it may have been necessary due to a serious bug with the vertically stretched Poisson solver that was fixed in https://github.com/CliMA/Oceananigans.jl/pull/1541. I'm not sure.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1755
https://github.com/CliMA/Oceananigans.jl/pull/1755:112,Testability,test,tests,112,"These lines should not be there and at the least lower the accuracy of calculations on stretched grids. We need tests that the metrics and grid geometry are correct for stretched grids (eg all the cell spacings added up gives the total domain size; cell centers are located halfway between cell interfaces, etc). . Not sure why these lines are there but it may have been necessary due to a serious bug with the vertically stretched Poisson solver that was fixed in https://github.com/CliMA/Oceananigans.jl/pull/1541. I'm not sure.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1755
https://github.com/CliMA/Oceananigans.jl/issues/1756:136,Testability,test,tested,136,Issues like the one fixed by #1755 suggest that the correctness or geometric consistency of `VerticallyStretchedRectilinearGrid` is not tested.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1756
https://github.com/CliMA/Oceananigans.jl/pull/1758:883,Availability,ERROR,ERROR,883,"First attempt at this. Still wasn't able to make sure the code in the example works. In fact, so far it has failed:. ```julia; julia> using Oceananigans.Operators. julia> using Oceananigans.Grids. julia> function isotropic_viscous_dissipation_rate_ccc(i, j, k, grid, u, v, w, ν); Σˣˣ² = ∂xᶜᵃᵃ(i, j, k, grid, u)^2; Σʸʸ² = ∂yᵃᶜᵃ(i, j, k, grid, v)^2; Σᶻᶻ² = ∂zᵃᵃᶜ(i, j, k, grid, w)^2. Σˣʸ² = ℑxyᶜᶜᵃ(i, j, k, grid, fψ_plus_gφ², ∂yᵃᶠᵃ, u, ∂xᶠᵃᵃ, v) / 4; Σˣᶻ² = ℑxzᶜᵃᶜ(i, j, k, grid, fψ_plus_gφ², ∂zᵃᵃᶠ, u, ∂xᶠᵃᵃ, w) / 4; Σʸᶻ² = ℑyzᵃᶜᶜ(i, j, k, grid, fψ_plus_gφ², ∂zᵃᵃᶠ, v, ∂yᵃᶠᵃ, w) / 4. ϵ[i, j, k] = ν[i, j, k] * 2 * (Σˣˣ² + Σʸʸ² + Σᶻᶻ² + 2 * (Σˣʸ² + Σˣᶻ² + Σʸᶻ²)); end; isotropic_viscous_dissipation_rate_ccc (generic function with 1 method). julia> ε = KernelFunctionOperation(Center, Center, Center, isotropic_viscous_dissipation_rate_ccc, grid;; computed_dependencies=(u, v, w, ν)); ERROR: MethodError: no method matching KernelFunctionOperation(::Type{Center}, ::Type{Center}, ::Type{Center}, ::typeof(isotropic_viscous_dissipation_rate_ccc), ::RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}; computed_dependencies=(Field located at (Face, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux), Field located at (Center, Face, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=ZeroFlux, top=ZeroFlux), Field located at (Center, Center, Face); ├── data: OffsetArra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1758
https://github.com/CliMA/Oceananigans.jl/pull/1761:3028,Availability,Error,Error,3028,"a> ν = model.closure.ν; 1.0e-6. julia> using Oceananigans.AbstractOperations: KernelFunctionOperation. julia> using Oceananigans.Operators. julia> @inline fψ_plus_gφ²(i, j, k, grid, f, ψ, g, φ) = @inbounds (f(i, j, k, grid, ψ) + g(i, j, k, grid, φ))^2; fψ_plus_gφ² (generic function with 1 method). julia> function isotropic_viscous_dissipation_rate_ccc(i, j, k, grid, u, v, w, ν); Σˣˣ² = ∂xᶜᵃᵃ(i, j, k, grid, u)^2; Σʸʸ² = ∂yᵃᶜᵃ(i, j, k, grid, v)^2; Σᶻᶻ² = ∂zᵃᵃᶜ(i, j, k, grid, w)^2; Σˣʸ² = ℑxyᶜᶜᵃ(i, j, k, grid, fψ_plus_gφ², ∂yᵃᶠᵃ, u, ∂xᶠᵃᵃ, v) / 4; Σˣᶻ² = ℑxzᶜᵃᶜ(i, j, k, grid, fψ_plus_gφ², ∂zᵃᵃᶠ, u, ∂xᶠᵃᵃ, w) / 4; Σʸᶻ² = ℑyzᵃᶜᶜ(i, j, k, grid, fψ_plus_gφ², ∂zᵃᵃᶠ, v, ∂yᵃᶠᵃ, w) / 4; ϵ[i, j, k] = ν[i, j, k] * 2 * (Σˣˣ² + Σʸʸ² + Σᶻᶻ² + 2 * (Σˣʸ² + Σˣᶻ² + Σʸᶻ²)); end; isotropic_viscous_dissipation_rate_ccc (generic function with 1 method). julia> ε_operation = KernelFunctionOperation{Center, Center, Center}(isotropic_viscous_dissipation_rate_ccc, grid;; computed_dependencies=(u, v, w, ν)); Error showing value of type KernelFunctionOperation{Center, Center, Center, Nothing, CPU, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, typeof(isotropic_viscous_dissipation_rate_ccc), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryCo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1761
https://github.com/CliMA/Oceananigans.jl/pull/1761:5834,Availability,ERROR,ERROR,5834,"x, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Field{Center, Center, Face, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.NormalFlow, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.NormalFlow, Nothing}}}}}, Float64}}:; ERROR: MethodError: no method matching operation_name(::KernelFunctionOperation{Center, Center, Center, Nothing, CPU, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, typeof(isotropic_viscous_dissipation_rate_ccc), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, Float64, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.Boun",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1761
https://github.com/CliMA/Oceananigans.jl/issues/1764:82,Deployability,upgrade,upgrade,82,"I've noticed a few weeks ago that my scripts were much slower after the Julia 1.6 upgrade (which is preventing me from upgrading). I thought it was due to my Julia 1.6 installation but after some tests I now think it's an Oceananigans issue, specifically with the WENO5 scheme. I ran the MWE below in both Julia 1.5 (with Oceananigans version 0.57.1) and Julia 1.6 (tried several Oceananigans versions but specifically for this example I'm using Oceananigans version 0.58.5) using GPUs and the speed difference is pretty huge. The interesting part is that this difference only happens if I use WENO5 with a GPU. If I use the 2nd order centered scheme there is no significant difference in time (I haven't tried other schemes) and if I run the script on CPUs the time difference also appears to be small. Here's the script:. ```julia; using Oceananigans; using Oceananigans.Units; using CUDA: has_cuda; Nx, Ny, Nz = 128, 1600, 64. if has_cuda(); arch = GPU(); else; arch = CPU(); Nx = Int(Nx/4); Ny = Int(Ny/4); Nz = Int(Nz/4); end . topology = (Periodic, Bounded, Bounded); grid = RegularRectilinearGrid(size=(Nx, Ny, Nz),; x=(0, 200),; y=(0, 2000),; z=(-100, 0),; topology=topology); println(""\n"", grid, ""\n""). model = IncompressibleModel(architecture = arch,; grid = grid,; advection = WENO5(),; timestepper = :RungeKutta3,; tracers=nothing,; buoyancy=nothing,; closure=nothing,; ); println(""\n"", model, ""\n""). start_time = 1e-9*time_ns(); using Oceanostics: SingleLineProgressMessenger; simulation = Simulation(model, Δt=10seconds,; stop_time=10hours,; wall_time_limit=23.5hours,; iteration_interval=5,; progress=SingleLineProgressMessenger(LES=false, initial_wall_time_seconds=start_time),; stop_iteration=Inf,). println(""\n"", simulation,""\n"",); @info ""---> Starting run!\n""; run!(simulation, pickup=false); ```. The output for Julia 1.5:. ```julia; [ Info: ---> Starting run!; [ Info: [000.14%] i: 5, time: 50.000 seconds, Δt: 10 seconds, wall time: 1.447 minutes, adv CFL: 0.00e+00, diff CFL: 0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764
https://github.com/CliMA/Oceananigans.jl/issues/1764:168,Deployability,install,installation,168,"I've noticed a few weeks ago that my scripts were much slower after the Julia 1.6 upgrade (which is preventing me from upgrading). I thought it was due to my Julia 1.6 installation but after some tests I now think it's an Oceananigans issue, specifically with the WENO5 scheme. I ran the MWE below in both Julia 1.5 (with Oceananigans version 0.57.1) and Julia 1.6 (tried several Oceananigans versions but specifically for this example I'm using Oceananigans version 0.58.5) using GPUs and the speed difference is pretty huge. The interesting part is that this difference only happens if I use WENO5 with a GPU. If I use the 2nd order centered scheme there is no significant difference in time (I haven't tried other schemes) and if I run the script on CPUs the time difference also appears to be small. Here's the script:. ```julia; using Oceananigans; using Oceananigans.Units; using CUDA: has_cuda; Nx, Ny, Nz = 128, 1600, 64. if has_cuda(); arch = GPU(); else; arch = CPU(); Nx = Int(Nx/4); Ny = Int(Ny/4); Nz = Int(Nz/4); end . topology = (Periodic, Bounded, Bounded); grid = RegularRectilinearGrid(size=(Nx, Ny, Nz),; x=(0, 200),; y=(0, 2000),; z=(-100, 0),; topology=topology); println(""\n"", grid, ""\n""). model = IncompressibleModel(architecture = arch,; grid = grid,; advection = WENO5(),; timestepper = :RungeKutta3,; tracers=nothing,; buoyancy=nothing,; closure=nothing,; ); println(""\n"", model, ""\n""). start_time = 1e-9*time_ns(); using Oceanostics: SingleLineProgressMessenger; simulation = Simulation(model, Δt=10seconds,; stop_time=10hours,; wall_time_limit=23.5hours,; iteration_interval=5,; progress=SingleLineProgressMessenger(LES=false, initial_wall_time_seconds=start_time),; stop_iteration=Inf,). println(""\n"", simulation,""\n"",); @info ""---> Starting run!\n""; run!(simulation, pickup=false); ```. The output for Julia 1.5:. ```julia; [ Info: ---> Starting run!; [ Info: [000.14%] i: 5, time: 50.000 seconds, Δt: 10 seconds, wall time: 1.447 minutes, adv CFL: 0.00e+00, diff CFL: 0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764
https://github.com/CliMA/Oceananigans.jl/issues/1764:7096,Deployability,upgrade,upgrade,7096,": [003.75%] i: 135, time: 22.500 minutes, Δt: 10 seconds, wall time: 5.087 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [003.89%] i: 140, time: 23.333 minutes, Δt: 10 seconds, wall time: 5.226 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [004.03%] i: 145, time: 24.167 minutes, Δt: 10 seconds, wall time: 5.365 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [004.17%] i: 150, time: 25.000 minutes, Δt: 10 seconds, wall time: 5.504 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [004.31%] i: 155, time: 25.833 minutes, Δt: 10 seconds, wall time: 5.643 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [004.44%] i: 160, time: 26.667 minutes, Δt: 10 seconds, wall time: 5.782 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [004.58%] i: 165, time: 27.500 minutes, Δt: 10 seconds, wall time: 5.921 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [004.72%] i: 170, time: 28.333 minutes, Δt: 10 seconds, wall time: 6.060 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [004.86%] i: 175, time: 29.167 minutes, Δt: 10 seconds, wall time: 6.199 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; ```. While for Julia 1.6 this is the output after the same amount of wall time:. ```julia; [ Info: ---> Starting run!; [ Info: [000.14%] i: 5, time: 50.000 seconds, Δt: 10 seconds, wall time: 3.453 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [000.28%] i: 10, time: 1.667 minutes, Δt: 10 seconds, wall time: 4.388 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [000.42%] i: 15, time: 2.500 minutes, Δt: 10 seconds, wall time: 5.269 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; [ Info: [000.56%] i: 20, time: 3.333 minutes, Δt: 10 seconds, wall time: 6.150 minutes, adv CFL: 0.00e+00, diff CFL: 0.00e+00; ```. Has someone else experienced this?. Any ideas as to what might be causing it? I really would like to upgrade my production ready scripts but there's no way I can do it until this issue is resolved unfortunately :/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764
https://github.com/CliMA/Oceananigans.jl/issues/1764:196,Testability,test,tests,196,"I've noticed a few weeks ago that my scripts were much slower after the Julia 1.6 upgrade (which is preventing me from upgrading). I thought it was due to my Julia 1.6 installation but after some tests I now think it's an Oceananigans issue, specifically with the WENO5 scheme. I ran the MWE below in both Julia 1.5 (with Oceananigans version 0.57.1) and Julia 1.6 (tried several Oceananigans versions but specifically for this example I'm using Oceananigans version 0.58.5) using GPUs and the speed difference is pretty huge. The interesting part is that this difference only happens if I use WENO5 with a GPU. If I use the 2nd order centered scheme there is no significant difference in time (I haven't tried other schemes) and if I run the script on CPUs the time difference also appears to be small. Here's the script:. ```julia; using Oceananigans; using Oceananigans.Units; using CUDA: has_cuda; Nx, Ny, Nz = 128, 1600, 64. if has_cuda(); arch = GPU(); else; arch = CPU(); Nx = Int(Nx/4); Ny = Int(Ny/4); Nz = Int(Nz/4); end . topology = (Periodic, Bounded, Bounded); grid = RegularRectilinearGrid(size=(Nx, Ny, Nz),; x=(0, 200),; y=(0, 2000),; z=(-100, 0),; topology=topology); println(""\n"", grid, ""\n""). model = IncompressibleModel(architecture = arch,; grid = grid,; advection = WENO5(),; timestepper = :RungeKutta3,; tracers=nothing,; buoyancy=nothing,; closure=nothing,; ); println(""\n"", model, ""\n""). start_time = 1e-9*time_ns(); using Oceanostics: SingleLineProgressMessenger; simulation = Simulation(model, Δt=10seconds,; stop_time=10hours,; wall_time_limit=23.5hours,; iteration_interval=5,; progress=SingleLineProgressMessenger(LES=false, initial_wall_time_seconds=start_time),; stop_iteration=Inf,). println(""\n"", simulation,""\n"",); @info ""---> Starting run!\n""; run!(simulation, pickup=false); ```. The output for Julia 1.5:. ```julia; [ Info: ---> Starting run!; [ Info: [000.14%] i: 5, time: 50.000 seconds, Δt: 10 seconds, wall time: 1.447 minutes, adv CFL: 0.00e+00, diff CFL: 0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764
https://github.com/CliMA/Oceananigans.jl/pull/1765:54,Usability,guid,guidelines,54,"This PR adds a few sections to `CONTRIBUTING.md` with guidelines for opening an issue, and for becoming an Oceananigans collaborator.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1765
https://github.com/CliMA/Oceananigans.jl/issues/1767:556,Energy Efficiency,reduce,reduced,556,"It seems that with Julia 1.6 and recent versions of CUDA.jl, the output of averaged fields is wrong. By inspection it seems that the output is being written to disk prematurely somehow as some grid points contain the sum instead of the mean. @xkykai and I have tried to reproduce in CUDA.jl but with no luck so far. I've tried adding a `CUDA.@sync blocking=true` to https://github.com/CliMA/Oceananigans.jl/blob/383173d11a0c96182a4349fc1e33755207bf0886/src/Fields/averaged_field.jl#L62 but that didn't help. Adding a `sleep(0.01)` afterwards helped a bit (reduced the number of occurences of this issue). It's not a useful hack but it may suggest that a race condition is involved?. X-Ref: This is a minimal reproduction of https://github.com/CliMA/LESbrary.jl/issues/118; X-Ref: https://github.com/JuliaGPU/CUDA.jl/issues/929 (Attempt at reproducing but turned out to be a REPL issue). # Minimal working example. ```julia; using Oceananigans. grid = RegularRectilinearGrid(size=(256, 256, 128), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); simulation = Simulation(model, Δt=1, stop_time=100). set!(model, u=1, v=1, T=1). U = AveragedField(model.velocities.u, dims=(1, 2)); V = AveragedField(model.velocities.v, dims=(1, 2)); T = AveragedField(model.tracers.T, dims=(1, 2)). simulation.output_writers[:jld2] =; JLD2OutputWriter(model, (; U, V, T),; prefix = ""stats"",; schedule = TimeInterval(10),; force = true). simulation.output_writers[:nc] =; NetCDFOutputWriter(model, (; U, V, T),; filepath = ""stats.nc"",; schedule = TimeInterval(10),; mode = ""c""). run!(simulation); ```. ## Looking at the NetCDF output. ```julia; using NCDatasets; ds = NCDataset(""stats.nc""); ds[""T""][:]; ```. ```; 128×11 Matrix{Float32}: ; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1767
https://github.com/CliMA/Oceananigans.jl/issues/1767:1402,Energy Efficiency,schedul,schedule,1402,"m/CliMA/Oceananigans.jl/blob/383173d11a0c96182a4349fc1e33755207bf0886/src/Fields/averaged_field.jl#L62 but that didn't help. Adding a `sleep(0.01)` afterwards helped a bit (reduced the number of occurences of this issue). It's not a useful hack but it may suggest that a race condition is involved?. X-Ref: This is a minimal reproduction of https://github.com/CliMA/LESbrary.jl/issues/118; X-Ref: https://github.com/JuliaGPU/CUDA.jl/issues/929 (Attempt at reproducing but turned out to be a REPL issue). # Minimal working example. ```julia; using Oceananigans. grid = RegularRectilinearGrid(size=(256, 256, 128), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); simulation = Simulation(model, Δt=1, stop_time=100). set!(model, u=1, v=1, T=1). U = AveragedField(model.velocities.u, dims=(1, 2)); V = AveragedField(model.velocities.v, dims=(1, 2)); T = AveragedField(model.tracers.T, dims=(1, 2)). simulation.output_writers[:jld2] =; JLD2OutputWriter(model, (; U, V, T),; prefix = ""stats"",; schedule = TimeInterval(10),; force = true). simulation.output_writers[:nc] =; NetCDFOutputWriter(model, (; U, V, T),; filepath = ""stats.nc"",; schedule = TimeInterval(10),; mode = ""c""). run!(simulation); ```. ## Looking at the NetCDF output. ```julia; using NCDatasets; ds = NCDataset(""stats.nc""); ds[""T""][:]; ```. ```; 128×11 Matrix{Float32}: ; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1767
https://github.com/CliMA/Oceananigans.jl/issues/1767:1545,Energy Efficiency,schedul,schedule,1545," the number of occurences of this issue). It's not a useful hack but it may suggest that a race condition is involved?. X-Ref: This is a minimal reproduction of https://github.com/CliMA/LESbrary.jl/issues/118; X-Ref: https://github.com/JuliaGPU/CUDA.jl/issues/929 (Attempt at reproducing but turned out to be a REPL issue). # Minimal working example. ```julia; using Oceananigans. grid = RegularRectilinearGrid(size=(256, 256, 128), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); simulation = Simulation(model, Δt=1, stop_time=100). set!(model, u=1, v=1, T=1). U = AveragedField(model.velocities.u, dims=(1, 2)); V = AveragedField(model.velocities.v, dims=(1, 2)); T = AveragedField(model.tracers.T, dims=(1, 2)). simulation.output_writers[:jld2] =; JLD2OutputWriter(model, (; U, V, T),; prefix = ""stats"",; schedule = TimeInterval(10),; force = true). simulation.output_writers[:nc] =; NetCDFOutputWriter(model, (; U, V, T),; filepath = ""stats.nc"",; schedule = TimeInterval(10),; mode = ""c""). run!(simulation); ```. ## Looking at the NetCDF output. ```julia; using NCDatasets; ds = NCDataset(""stats.nc""); ds[""T""][:]; ```. ```; 128×11 Matrix{Float32}: ; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 0.0 0.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1767
https://github.com/CliMA/Oceananigans.jl/issues/1767:654,Performance,race condition,race condition,654,"It seems that with Julia 1.6 and recent versions of CUDA.jl, the output of averaged fields is wrong. By inspection it seems that the output is being written to disk prematurely somehow as some grid points contain the sum instead of the mean. @xkykai and I have tried to reproduce in CUDA.jl but with no luck so far. I've tried adding a `CUDA.@sync blocking=true` to https://github.com/CliMA/Oceananigans.jl/blob/383173d11a0c96182a4349fc1e33755207bf0886/src/Fields/averaged_field.jl#L62 but that didn't help. Adding a `sleep(0.01)` afterwards helped a bit (reduced the number of occurences of this issue). It's not a useful hack but it may suggest that a race condition is involved?. X-Ref: This is a minimal reproduction of https://github.com/CliMA/LESbrary.jl/issues/118; X-Ref: https://github.com/JuliaGPU/CUDA.jl/issues/929 (Attempt at reproducing but turned out to be a REPL issue). # Minimal working example. ```julia; using Oceananigans. grid = RegularRectilinearGrid(size=(256, 256, 128), extent=(1, 1, 1)); model = IncompressibleModel(architecture=GPU(), grid=grid); simulation = Simulation(model, Δt=1, stop_time=100). set!(model, u=1, v=1, T=1). U = AveragedField(model.velocities.u, dims=(1, 2)); V = AveragedField(model.velocities.v, dims=(1, 2)); T = AveragedField(model.tracers.T, dims=(1, 2)). simulation.output_writers[:jld2] =; JLD2OutputWriter(model, (; U, V, T),; prefix = ""stats"",; schedule = TimeInterval(10),; force = true). simulation.output_writers[:nc] =; NetCDFOutputWriter(model, (; U, V, T),; filepath = ""stats.nc"",; schedule = TimeInterval(10),; mode = ""c""). run!(simulation); ```. ## Looking at the NetCDF output. ```julia; using NCDatasets; ds = NCDataset(""stats.nc""); ds[""T""][:]; ```. ```; 128×11 Matrix{Float32}: ; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0; 1.0 1.0 1.0 1.0 1.0 1.0 1.0 ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1767
https://github.com/CliMA/Oceananigans.jl/pull/1768:13,Deployability,hotfix,hotfix,13,This PR is a hotfix for https://github.com/CliMA/LESbrary.jl/issues/118 and https://github.com/CliMA/Oceananigans.jl/issues/1767. Seems to fix #1767 for me so we could use this branch temporarily if needed until we can actually fix #1767.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1768
https://github.com/CliMA/Oceananigans.jl/pull/1772:8,Deployability,update,updates,8,"This PR updates the instructions for building the docs locally. @tomchor, @francispoulin: could you let me know if these new instructions do the job for you? Please try on a fresh clone of the repo. Closes #1542. (Or at least that's the hope....)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1772
https://github.com/CliMA/Oceananigans.jl/pull/1774:155,Usability,simpl,simple,155,"I think we formally support Flat topologies now, so we should at least mention them in the page that teaches users about the grids. So I added a couple of simple sentences. I don't think we need much more for now (especially since all the 2D examples now use `Flat`).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1774
https://github.com/CliMA/Oceananigans.jl/issues/1775:161,Deployability,Continuous,ContinuousBoundaryFunction,161,"This warning appears in the log when we run the simulation:. ```Julia; ┌ Warning: some parameters could not be resolved for type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center,Center,Nothing,24,Main.__atexample__named__ocean_wind_mixing_and_convection.#Qˢ,Float64,Tuple{Symbol},Tuple{Int64},Tuple{typeof(Oceananigans.Operators.identity4)}}; reconstructing; └ @ JLD2 ~/.julia/packages/JLD2/1i6ZM/src/data/reconstructing_datatypes.jl:440; ```. See, e.g., https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/. Is this something we need to address or make the example better so that it does not appear? Users might be intimidated...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1775
https://github.com/CliMA/Oceananigans.jl/issues/1775:28,Testability,log,log,28,"This warning appears in the log when we run the simulation:. ```Julia; ┌ Warning: some parameters could not be resolved for type Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Center,Center,Nothing,24,Main.__atexample__named__ocean_wind_mixing_and_convection.#Qˢ,Float64,Tuple{Symbol},Tuple{Int64},Tuple{typeof(Oceananigans.Operators.identity4)}}; reconstructing; └ @ JLD2 ~/.julia/packages/JLD2/1i6ZM/src/data/reconstructing_datatypes.jl:440; ```. See, e.g., https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/. Is this something we need to address or make the example better so that it does not appear? Users might be intimidated...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1775
https://github.com/CliMA/Oceananigans.jl/issues/1777:605,Deployability,pipeline,pipeline,605,"I believe that . https://github.com/CliMA/Oceananigans.jl/blob/b22057a49dfe25b1b091d4d4c9cdb0e126bc0c62/docs/make.jl#L1. should be replaced with. ```julia; push!(LOAD_PATH, joinpath(@__DIR__, ""."")); ```. Supposedly `docs/make.jl` from the repo's home directory, right? Thus going a level up is not appropriate?. But a better way to do it is to delete `push!(LOAD_PATH...` from within `docs/make.jl` completely and make sure we include it in our workflow when building the docs locally or on servers, e.g., see . https://github.com/JuliaGPU/CUDA.jl/blob/96d6e11259053573ad8164f462d9f9eb8e204893/.buildkite/pipeline.yml#L338-L342. cc: @ali-ramadhan, @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1777
https://github.com/CliMA/Oceananigans.jl/issues/1779:146,Deployability,update,updated,146,"I think [Coordinate system and notation](https://clima.github.io/OceananigansDocumentation/stable/physics/notation/) page in the docs needs to be updated. . First, we don't only use a Cartesian grid anymore (we don't even use the word Cartesian for the `RegularRectilinearGrid` anymore). I'm not sure how you guys wanna adapt this page and notation for the spherical coordinate grid though. Second, a part of the math isn't rendering and I'm not sure why.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1779
https://github.com/CliMA/Oceananigans.jl/issues/1779:320,Energy Efficiency,adapt,adapt,320,"I think [Coordinate system and notation](https://clima.github.io/OceananigansDocumentation/stable/physics/notation/) page in the docs needs to be updated. . First, we don't only use a Cartesian grid anymore (we don't even use the word Cartesian for the `RegularRectilinearGrid` anymore). I'm not sure how you guys wanna adapt this page and notation for the spherical coordinate grid though. Second, a part of the math isn't rendering and I'm not sure why.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1779
https://github.com/CliMA/Oceananigans.jl/issues/1779:320,Modifiability,adapt,adapt,320,"I think [Coordinate system and notation](https://clima.github.io/OceananigansDocumentation/stable/physics/notation/) page in the docs needs to be updated. . First, we don't only use a Cartesian grid anymore (we don't even use the word Cartesian for the `RegularRectilinearGrid` anymore). I'm not sure how you guys wanna adapt this page and notation for the spherical coordinate grid though. Second, a part of the math isn't rendering and I'm not sure why.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1779
https://github.com/CliMA/Oceananigans.jl/issues/1780:346,Availability,error,error,346,"Inspired by the recent activity in #1770, @hennyg888 and I both tried running `benchmark_incompressible_model.jl` with advection set to `WENO5` to learn what the speed up is for this advection scheme from CPUS to GPUS. In the first resolution, `N=32`, it runs on a `CPU` without any problem. However, when it starts to run on a `GPU` there is an error, which is copied below. . When I copy the lines directly into `REPL` to define the grid, model and do one time step, I don't get an error. Any ideas what might be going wrong in this benchmarking example?. ```; [2021/06/28 09:40:32.366] INFO Benchmarking 1/16: (CPU, Float32, 32)...; [2021/06/28 09:40:38.930] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; [2021/06/28 09:42:28.384] INFO Benchmarking 2/16: (GPU, Float32, 32)...; [2021/06/28 09:42:32.299] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780
https://github.com/CliMA/Oceananigans.jl/issues/1780:484,Availability,error,error,484,"Inspired by the recent activity in #1770, @hennyg888 and I both tried running `benchmark_incompressible_model.jl` with advection set to `WENO5` to learn what the speed up is for this advection scheme from CPUS to GPUS. In the first resolution, `N=32`, it runs on a `CPU` without any problem. However, when it starts to run on a `GPU` there is an error, which is copied below. . When I copy the lines directly into `REPL` to define the grid, model and do one time step, I don't get an error. Any ideas what might be going wrong in this benchmarking example?. ```; [2021/06/28 09:40:32.366] INFO Benchmarking 1/16: (CPU, Float32, 32)...; [2021/06/28 09:40:38.930] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; [2021/06/28 09:42:28.384] INFO Benchmarking 2/16: (GPU, Float32, 32)...; [2021/06/28 09:42:32.299] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780
https://github.com/CliMA/Oceananigans.jl/issues/1780:1351,Availability,ERROR,ERROR,1351,"opy the lines directly into `REPL` to define the grid, model and do one time step, I don't get an error. Any ideas what might be going wrong in this benchmarking example?. ```; [2021/06/28 09:40:32.366] INFO Benchmarking 1/16: (CPU, Float32, 32)...; [2021/06/28 09:40:38.930] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; [2021/06/28 09:42:28.384] INFO Benchmarking 2/16: (GPU, Float32, 32)...; [2021/06/28 09:42:32.299] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}, RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, WENO5, Nothing, Nothing, Nothing, Buoyancy{SeawaterBuoyancy{Float32, LinearEquationOfState{Float32}, Nothing, Nothing}, Oceananigans.BuoyancyModels.ZDirection}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780
https://github.com/CliMA/Oceananigans.jl/issues/1780:1358,Performance,Load,LoadError,1358,"opy the lines directly into `REPL` to define the grid, model and do one time step, I don't get an error. Any ideas what might be going wrong in this benchmarking example?. ```; [2021/06/28 09:40:32.366] INFO Benchmarking 1/16: (CPU, Float32, 32)...; [2021/06/28 09:40:38.930] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; [2021/06/28 09:42:28.384] INFO Benchmarking 2/16: (GPU, Float32, 32)...; [2021/06/28 09:42:32.299] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}, RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, WENO5, Nothing, Nothing, Nothing, Buoyancy{SeawaterBuoyancy{Float32, LinearEquationOfState{Float32}, Nothing, Nothing}, Oceananigans.BuoyancyModels.ZDirection}, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780
https://github.com/CliMA/Oceananigans.jl/issues/1780:789,Safety,avoid,avoid,789,"Inspired by the recent activity in #1770, @hennyg888 and I both tried running `benchmark_incompressible_model.jl` with advection set to `WENO5` to learn what the speed up is for this advection scheme from CPUS to GPUS. In the first resolution, `N=32`, it runs on a `CPU` without any problem. However, when it starts to run on a `GPU` there is an error, which is copied below. . When I copy the lines directly into `REPL` to define the grid, model and do one time step, I don't get an error. Any ideas what might be going wrong in this benchmarking example?. ```; [2021/06/28 09:40:32.366] INFO Benchmarking 1/16: (CPU, Float32, 32)...; [2021/06/28 09:40:38.930] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; [2021/06/28 09:42:28.384] INFO Benchmarking 2/16: (GPU, Float32, 32)...; [2021/06/28 09:42:32.299] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780
https://github.com/CliMA/Oceananigans.jl/issues/1780:1183,Safety,avoid,avoid,1183,"PUS. In the first resolution, `N=32`, it runs on a `CPU` without any problem. However, when it starts to run on a `GPU` there is an error, which is copied below. . When I copy the lines directly into `REPL` to define the grid, model and do one time step, I don't get an error. Any ideas what might be going wrong in this benchmarking example?. ```; [2021/06/28 09:40:32.366] INFO Benchmarking 1/16: (CPU, Float32, 32)...; [2021/06/28 09:40:38.930] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; [2021/06/28 09:42:28.384] INFO Benchmarking 2/16: (GPU, Float32, 32)...; [2021/06/28 09:42:32.299] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}, RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}, WENO5, Nothing, Nothing, Nothing, Buoyancy{SeawaterBuoyancy{Float32, Line",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780
https://github.com/CliMA/Oceananigans.jl/issues/1780:535,Testability,benchmark,benchmarking,535,"Inspired by the recent activity in #1770, @hennyg888 and I both tried running `benchmark_incompressible_model.jl` with advection set to `WENO5` to learn what the speed up is for this advection scheme from CPUS to GPUS. In the first resolution, `N=32`, it runs on a `CPU` without any problem. However, when it starts to run on a `GPU` there is an error, which is copied below. . When I copy the lines directly into `REPL` to define the grid, model and do one time step, I don't get an error. Any ideas what might be going wrong in this benchmarking example?. ```; [2021/06/28 09:40:32.366] INFO Benchmarking 1/16: (CPU, Float32, 32)...; [2021/06/28 09:40:38.930] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; [2021/06/28 09:42:28.384] INFO Benchmarking 2/16: (GPU, Float32, 32)...; [2021/06/28 09:42:32.299] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780
https://github.com/CliMA/Oceananigans.jl/issues/1780:594,Testability,Benchmark,Benchmarking,594,"Inspired by the recent activity in #1770, @hennyg888 and I both tried running `benchmark_incompressible_model.jl` with advection set to `WENO5` to learn what the speed up is for this advection scheme from CPUS to GPUS. In the first resolution, `N=32`, it runs on a `CPU` without any problem. However, when it starts to run on a `GPU` there is an error, which is copied below. . When I copy the lines directly into `REPL` to define the grid, model and do one time step, I don't get an error. Any ideas what might be going wrong in this benchmarking example?. ```; [2021/06/28 09:40:32.366] INFO Benchmarking 1/16: (CPU, Float32, 32)...; [2021/06/28 09:40:38.930] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; [2021/06/28 09:42:28.384] INFO Benchmarking 2/16: (GPU, Float32, 32)...; [2021/06/28 09:42:32.299] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780
https://github.com/CliMA/Oceananigans.jl/issues/1780:988,Testability,Benchmark,Benchmarking,988,"spired by the recent activity in #1770, @hennyg888 and I both tried running `benchmark_incompressible_model.jl` with advection set to `WENO5` to learn what the speed up is for this advection scheme from CPUS to GPUS. In the first resolution, `N=32`, it runs on a `CPU` without any problem. However, when it starts to run on a `GPU` there is an error, which is copied below. . When I copy the lines directly into `REPL` to define the grid, model and do one time step, I don't get an error. Any ideas what might be going wrong in this benchmarking example?. ```; [2021/06/28 09:40:32.366] INFO Benchmarking 1/16: (CPU, Float32, 32)...; [2021/06/28 09:40:38.930] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; [2021/06/28 09:42:28.384] INFO Benchmarking 2/16: (GPU, Float32, 32)...; [2021/06/28 09:42:32.299] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780
https://github.com/CliMA/Oceananigans.jl/issues/1780:147,Usability,learn,learn,147,"Inspired by the recent activity in #1770, @hennyg888 and I both tried running `benchmark_incompressible_model.jl` with advection set to `WENO5` to learn what the speed up is for this advection scheme from CPUS to GPUS. In the first resolution, `N=32`, it runs on a `CPU` without any problem. However, when it starts to run on a `GPU` there is an error, which is copied below. . When I copy the lines directly into `REPL` to define the grid, model and do one time step, I don't get an error. Any ideas what might be going wrong in this benchmarking example?. ```; [2021/06/28 09:40:32.366] INFO Benchmarking 1/16: (CPU, Float32, 32)...; [2021/06/28 09:40:38.930] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; [2021/06/28 09:42:28.384] INFO Benchmarking 2/16: (GPU, Float32, 32)...; [2021/06/28 09:42:32.299] WARN Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid. -@-> /home/fpoulin/software/New_Oceananigans/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CuDeviceArray{Float32, 3, 1}}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780
https://github.com/CliMA/Oceananigans.jl/pull/1781:179,Testability,test,tested,179,"This pull request changes the compat entry for the `StructArrays` package from `0.4, 0.5` to `0.4, 0.5, 0.6`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1781
https://github.com/CliMA/Oceananigans.jl/pull/1781:284,Testability,test,tests,284,"This pull request changes the compat entry for the `StructArrays` package from `0.4, 0.5` to `0.4, 0.5, 0.6`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1781
https://github.com/CliMA/Oceananigans.jl/pull/1782:35,Testability,test,test,35,@francispoulin this will hopefully test the question you've raised on #1780 .,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1782
https://github.com/CliMA/Oceananigans.jl/pull/1784:19,Performance,race condition,race condition,19,Tries to catch the race condition that produces #1767 .,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1784
https://github.com/CliMA/Oceananigans.jl/pull/1786:199,Availability,redundant,redundant,199,"The floating point type can and should be determined from `eltype(grid)`, since `grid` is a required argument for constructing `IncompressibleModel`. An independent `float_type` argument is not only redundant but creates the possibility that models can have inconsistent float types. Eliminating this argument and using `eltype(grid)` as the source of knowledge re: floating point types solves this problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1786
https://github.com/CliMA/Oceananigans.jl/pull/1786:199,Safety,redund,redundant,199,"The floating point type can and should be determined from `eltype(grid)`, since `grid` is a required argument for constructing `IncompressibleModel`. An independent `float_type` argument is not only redundant but creates the possibility that models can have inconsistent float types. Eliminating this argument and using `eltype(grid)` as the source of knowledge re: floating point types solves this problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1786
https://github.com/CliMA/Oceananigans.jl/pull/1790:39,Testability,test,test,39,"@francispoulin @navidcy let's manually test whether this resolves #1780. (It'd be better to have a test that fails, but the tests #1782 stubbornly refuse to fail.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1790
https://github.com/CliMA/Oceananigans.jl/pull/1790:99,Testability,test,test,99,"@francispoulin @navidcy let's manually test whether this resolves #1780. (It'd be better to have a test that fails, but the tests #1782 stubbornly refuse to fail.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1790
https://github.com/CliMA/Oceananigans.jl/pull/1790:124,Testability,test,tests,124,"@francispoulin @navidcy let's manually test whether this resolves #1780. (It'd be better to have a test that fails, but the tests #1782 stubbornly refuse to fail.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1790
https://github.com/CliMA/Oceananigans.jl/pull/1790:136,Testability,stub,stubbornly,136,"@francispoulin @navidcy let's manually test whether this resolves #1780. (It'd be better to have a test that fails, but the tests #1782 stubbornly refuse to fail.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1790
https://github.com/CliMA/Oceananigans.jl/pull/1792:163,Testability,test,tested,163,"This pull request changes the compat entry for the `Tullio` package from `0.2` to `0.2, 0.3`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1792
https://github.com/CliMA/Oceananigans.jl/pull/1792:268,Testability,test,tests,268,"This pull request changes the compat entry for the `Tullio` package from `0.2` to `0.2, 0.3`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1792
https://github.com/CliMA/Oceananigans.jl/issues/1794:101,Testability,test,tests,101,Looking at the latest Buildkite build for the master branch it looks like GPU CI is only running CPU tests: https://buildkite.com/clima/oceananigans/builds/3045. Not sure why this would be the case... `CUDA.versioninfo()` seems to return the expected info on Sverdrup during initialization: https://buildkite.com/clima/oceananigans/builds/3045#ad4268d2-9b56-4cc0-ab46-ab9fdd61527b/31-253. I wonder if `CUDA.has_cuda()` is returning `false` on Sverdrup for some weird reason? https://github.com/CliMA/Oceananigans.jl/blob/dfc028667493bdd0eb1056d66d287c46e2591a7f/test/runtests.jl#L56,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1794
https://github.com/CliMA/Oceananigans.jl/issues/1794:562,Testability,test,test,562,Looking at the latest Buildkite build for the master branch it looks like GPU CI is only running CPU tests: https://buildkite.com/clima/oceananigans/builds/3045. Not sure why this would be the case... `CUDA.versioninfo()` seems to return the expected info on Sverdrup during initialization: https://buildkite.com/clima/oceananigans/builds/3045#ad4268d2-9b56-4cc0-ab46-ab9fdd61527b/31-253. I wonder if `CUDA.has_cuda()` is returning `false` on Sverdrup for some weird reason? https://github.com/CliMA/Oceananigans.jl/blob/dfc028667493bdd0eb1056d66d287c46e2591a7f/test/runtests.jl#L56,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1794
https://github.com/CliMA/Oceananigans.jl/pull/1797:49,Security,validat,validation,49,The Convergence tests and Couette flow pages (in validation) had missing figures that somehow got lost at some point. I was able to find the figures by going back to older versions of Oceananigans and reintroduced them. Resolves #1459. Resolves #1696.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797
https://github.com/CliMA/Oceananigans.jl/pull/1797:16,Testability,test,tests,16,The Convergence tests and Couette flow pages (in validation) had missing figures that somehow got lost at some point. I was able to find the figures by going back to older versions of Oceananigans and reintroduced them. Resolves #1459. Resolves #1696.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797
https://github.com/CliMA/Oceananigans.jl/pull/1799:142,Availability,error,error,142,Resolves #1794 . We should also come up with a more permanent solution (perhaps another environment variable to toggle GPU-CI) that throws an error if GPU tests can't run on the GPU.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1799
https://github.com/CliMA/Oceananigans.jl/pull/1799:112,Deployability,toggle,toggle,112,Resolves #1794 . We should also come up with a more permanent solution (perhaps another environment variable to toggle GPU-CI) that throws an error if GPU tests can't run on the GPU.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1799
https://github.com/CliMA/Oceananigans.jl/pull/1799:100,Modifiability,variab,variable,100,Resolves #1794 . We should also come up with a more permanent solution (perhaps another environment variable to toggle GPU-CI) that throws an error if GPU tests can't run on the GPU.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1799
https://github.com/CliMA/Oceananigans.jl/pull/1799:155,Testability,test,tests,155,Resolves #1794 . We should also come up with a more permanent solution (perhaps another environment variable to toggle GPU-CI) that throws an error if GPU tests can't run on the GPU.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1799
https://github.com/CliMA/Oceananigans.jl/pull/1802:29,Testability,test,test,29,I think we should also add a test for the case that `window` and time-interval of output are identical.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1802
https://github.com/CliMA/Oceananigans.jl/pull/1804:42,Availability,down,download,42,Sometimes different Buildkite jobs try to download the same file as the same time leading to freezes like in https://buildkite.com/clima/oceananigans/builds/3066#157d0809-a11d-476b-b78d-fc5b1a241286. This PR tries to avoid race conditions by just downloading the file once during the initialization stage. Doesn't always happen though so not sure when/how to merge.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1804
https://github.com/CliMA/Oceananigans.jl/pull/1804:247,Availability,down,downloading,247,Sometimes different Buildkite jobs try to download the same file as the same time leading to freezes like in https://buildkite.com/clima/oceananigans/builds/3066#157d0809-a11d-476b-b78d-fc5b1a241286. This PR tries to avoid race conditions by just downloading the file once during the initialization stage. Doesn't always happen though so not sure when/how to merge.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1804
https://github.com/CliMA/Oceananigans.jl/pull/1804:223,Performance,race condition,race conditions,223,Sometimes different Buildkite jobs try to download the same file as the same time leading to freezes like in https://buildkite.com/clima/oceananigans/builds/3066#157d0809-a11d-476b-b78d-fc5b1a241286. This PR tries to avoid race conditions by just downloading the file once during the initialization stage. Doesn't always happen though so not sure when/how to merge.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1804
https://github.com/CliMA/Oceananigans.jl/pull/1804:217,Safety,avoid,avoid,217,Sometimes different Buildkite jobs try to download the same file as the same time leading to freezes like in https://buildkite.com/clima/oceananigans/builds/3066#157d0809-a11d-476b-b78d-fc5b1a241286. This PR tries to avoid race conditions by just downloading the file once during the initialization stage. Doesn't always happen though so not sure when/how to merge.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1804
https://github.com/CliMA/Oceananigans.jl/pull/1807:16,Energy Efficiency,schedul,schedule,16,"This PR copies `schedule::AveragedTimeInterval` for each time-averaged output object when wrapping objects in `WindowedTimeInterval`. Independent copies of the schedule are needed when multiple outputs are time-averaged and then added to `simulation.diagnostics`, because each schedule has a mutable state that's specific to each output. When a single schedule is used for multiple outputs, the schedule's state is mangled for one or more of the outputs. This PR also extends the NetCDF time-averaging tests to test the case of multiple outputs in addition to the case of a single output. Resolves #1517 . cc @tomchor, @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1807
https://github.com/CliMA/Oceananigans.jl/pull/1807:160,Energy Efficiency,schedul,schedule,160,"This PR copies `schedule::AveragedTimeInterval` for each time-averaged output object when wrapping objects in `WindowedTimeInterval`. Independent copies of the schedule are needed when multiple outputs are time-averaged and then added to `simulation.diagnostics`, because each schedule has a mutable state that's specific to each output. When a single schedule is used for multiple outputs, the schedule's state is mangled for one or more of the outputs. This PR also extends the NetCDF time-averaging tests to test the case of multiple outputs in addition to the case of a single output. Resolves #1517 . cc @tomchor, @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1807
https://github.com/CliMA/Oceananigans.jl/pull/1807:277,Energy Efficiency,schedul,schedule,277,"This PR copies `schedule::AveragedTimeInterval` for each time-averaged output object when wrapping objects in `WindowedTimeInterval`. Independent copies of the schedule are needed when multiple outputs are time-averaged and then added to `simulation.diagnostics`, because each schedule has a mutable state that's specific to each output. When a single schedule is used for multiple outputs, the schedule's state is mangled for one or more of the outputs. This PR also extends the NetCDF time-averaging tests to test the case of multiple outputs in addition to the case of a single output. Resolves #1517 . cc @tomchor, @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1807
https://github.com/CliMA/Oceananigans.jl/pull/1807:352,Energy Efficiency,schedul,schedule,352,"This PR copies `schedule::AveragedTimeInterval` for each time-averaged output object when wrapping objects in `WindowedTimeInterval`. Independent copies of the schedule are needed when multiple outputs are time-averaged and then added to `simulation.diagnostics`, because each schedule has a mutable state that's specific to each output. When a single schedule is used for multiple outputs, the schedule's state is mangled for one or more of the outputs. This PR also extends the NetCDF time-averaging tests to test the case of multiple outputs in addition to the case of a single output. Resolves #1517 . cc @tomchor, @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1807
https://github.com/CliMA/Oceananigans.jl/pull/1807:395,Energy Efficiency,schedul,schedule,395,"This PR copies `schedule::AveragedTimeInterval` for each time-averaged output object when wrapping objects in `WindowedTimeInterval`. Independent copies of the schedule are needed when multiple outputs are time-averaged and then added to `simulation.diagnostics`, because each schedule has a mutable state that's specific to each output. When a single schedule is used for multiple outputs, the schedule's state is mangled for one or more of the outputs. This PR also extends the NetCDF time-averaging tests to test the case of multiple outputs in addition to the case of a single output. Resolves #1517 . cc @tomchor, @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1807
https://github.com/CliMA/Oceananigans.jl/pull/1807:90,Integrability,wrap,wrapping,90,"This PR copies `schedule::AveragedTimeInterval` for each time-averaged output object when wrapping objects in `WindowedTimeInterval`. Independent copies of the schedule are needed when multiple outputs are time-averaged and then added to `simulation.diagnostics`, because each schedule has a mutable state that's specific to each output. When a single schedule is used for multiple outputs, the schedule's state is mangled for one or more of the outputs. This PR also extends the NetCDF time-averaging tests to test the case of multiple outputs in addition to the case of a single output. Resolves #1517 . cc @tomchor, @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1807
https://github.com/CliMA/Oceananigans.jl/pull/1807:468,Modifiability,extend,extends,468,"This PR copies `schedule::AveragedTimeInterval` for each time-averaged output object when wrapping objects in `WindowedTimeInterval`. Independent copies of the schedule are needed when multiple outputs are time-averaged and then added to `simulation.diagnostics`, because each schedule has a mutable state that's specific to each output. When a single schedule is used for multiple outputs, the schedule's state is mangled for one or more of the outputs. This PR also extends the NetCDF time-averaging tests to test the case of multiple outputs in addition to the case of a single output. Resolves #1517 . cc @tomchor, @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1807
https://github.com/CliMA/Oceananigans.jl/pull/1807:502,Testability,test,tests,502,"This PR copies `schedule::AveragedTimeInterval` for each time-averaged output object when wrapping objects in `WindowedTimeInterval`. Independent copies of the schedule are needed when multiple outputs are time-averaged and then added to `simulation.diagnostics`, because each schedule has a mutable state that's specific to each output. When a single schedule is used for multiple outputs, the schedule's state is mangled for one or more of the outputs. This PR also extends the NetCDF time-averaging tests to test the case of multiple outputs in addition to the case of a single output. Resolves #1517 . cc @tomchor, @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1807
https://github.com/CliMA/Oceananigans.jl/pull/1807:511,Testability,test,test,511,"This PR copies `schedule::AveragedTimeInterval` for each time-averaged output object when wrapping objects in `WindowedTimeInterval`. Independent copies of the schedule are needed when multiple outputs are time-averaged and then added to `simulation.diagnostics`, because each schedule has a mutable state that's specific to each output. When a single schedule is used for multiple outputs, the schedule's state is mangled for one or more of the outputs. This PR also extends the NetCDF time-averaging tests to test the case of multiple outputs in addition to the case of a single output. Resolves #1517 . cc @tomchor, @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1807
https://github.com/CliMA/Oceananigans.jl/pull/1810:8,Deployability,update,updates,8,"This PR updates `examples/ocean_wind_mixing_and_convection.jl` with a new grid generating function that produces a constant grid spacing near the surface. A visualization of the grid spacing is. ![image](https://user-images.githubusercontent.com/15271942/124339919-d3ba0080-db6e-11eb-96f2-999856d9556d.png). @tomchor proposed this idea in #1762, but we couldn't find a suitable generating function and so a grid that becomes ever more refined toward the surface was used instead. I think a grid with constant near-surface spacing and bottom-intensified stretching will be useful for boundary layer turbulence experiments, so I thought it was worthwhile to spend a bit more time to come up with something. I thought the hyperbolic generating function was also useful, so I added it to the docstring for `VerticallyStretchedRectilinearGrid` as an example. This PR also fixes a typo in that docstring. Some notes:. I developed a two-parameter stretching function:. ```julia; ## Linear near-surface generator; ζ₀(k) = 1 + (h(k) - 1) / refinement. ## Bottom-intensified stretching function ; Σ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching)). ## Generating function; z_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1); ```. with `refinement` and `stretching` parameters`. Finding a suitable grid requires playing with both these parameters: perhaps counter-intuitively, when the `refinement` is weaker, the `stretching` has to be stronger to obtain a grid that's nearly constantly spaced near the surface. I think a slightly more convenient parameterization would use a ""transition"" parameter (controlling the depth at which the grid transitions from constant spacing to stretched) rather than a stretching parameter (there would also be a small parameter involved to control ""how close"" the spacing would be to constant at the transition depth). However I couldn't figure out how to implement such a parameterization without solving a transcendental equation. The idea I had was to set the slope of `Σ` to a",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1810
https://github.com/CliMA/Oceananigans.jl/pull/1810:2435,Integrability,depend,depend,2435,"-surface spacing and bottom-intensified stretching will be useful for boundary layer turbulence experiments, so I thought it was worthwhile to spend a bit more time to come up with something. I thought the hyperbolic generating function was also useful, so I added it to the docstring for `VerticallyStretchedRectilinearGrid` as an example. This PR also fixes a typo in that docstring. Some notes:. I developed a two-parameter stretching function:. ```julia; ## Linear near-surface generator; ζ₀(k) = 1 + (h(k) - 1) / refinement. ## Bottom-intensified stretching function ; Σ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching)). ## Generating function; z_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1); ```. with `refinement` and `stretching` parameters`. Finding a suitable grid requires playing with both these parameters: perhaps counter-intuitively, when the `refinement` is weaker, the `stretching` has to be stronger to obtain a grid that's nearly constantly spaced near the surface. I think a slightly more convenient parameterization would use a ""transition"" parameter (controlling the depth at which the grid transitions from constant spacing to stretched) rather than a stretching parameter (there would also be a small parameter involved to control ""how close"" the spacing would be to constant at the transition depth). However I couldn't figure out how to implement such a parameterization without solving a transcendental equation. The idea I had was to set the slope of `Σ` to a small number at a specified fraction of the domain height `hᵢ` by solving. ```julia; Σ′ = stretching * exp(-stretching * hᵢ) / (1 - exp(-stretching)) = ϵ; ```. for `stretching`. In the above, `ϵ` is a small parameter controlling the smallness of `Σ′` at the normalized height. Both `ϵ` and `hᵢ` are parameters. Aside from being not quite right, there's something a little off about this approach. I think `stretching` should somehow depend on `refinement`; eg when `refinement = 1` then no stretching is needed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1810
https://github.com/CliMA/Oceananigans.jl/pull/1810:1534,Modifiability,parameteriz,parameterization,1534,"-surface spacing and bottom-intensified stretching will be useful for boundary layer turbulence experiments, so I thought it was worthwhile to spend a bit more time to come up with something. I thought the hyperbolic generating function was also useful, so I added it to the docstring for `VerticallyStretchedRectilinearGrid` as an example. This PR also fixes a typo in that docstring. Some notes:. I developed a two-parameter stretching function:. ```julia; ## Linear near-surface generator; ζ₀(k) = 1 + (h(k) - 1) / refinement. ## Bottom-intensified stretching function ; Σ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching)). ## Generating function; z_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1); ```. with `refinement` and `stretching` parameters`. Finding a suitable grid requires playing with both these parameters: perhaps counter-intuitively, when the `refinement` is weaker, the `stretching` has to be stronger to obtain a grid that's nearly constantly spaced near the surface. I think a slightly more convenient parameterization would use a ""transition"" parameter (controlling the depth at which the grid transitions from constant spacing to stretched) rather than a stretching parameter (there would also be a small parameter involved to control ""how close"" the spacing would be to constant at the transition depth). However I couldn't figure out how to implement such a parameterization without solving a transcendental equation. The idea I had was to set the slope of `Σ` to a small number at a specified fraction of the domain height `hᵢ` by solving. ```julia; Σ′ = stretching * exp(-stretching * hᵢ) / (1 - exp(-stretching)) = ϵ; ```. for `stretching`. In the above, `ϵ` is a small parameter controlling the smallness of `Σ′` at the normalized height. Both `ϵ` and `hᵢ` are parameters. Aside from being not quite right, there's something a little off about this approach. I think `stretching` should somehow depend on `refinement`; eg when `refinement = 1` then no stretching is needed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1810
https://github.com/CliMA/Oceananigans.jl/pull/1810:1894,Modifiability,parameteriz,parameterization,1894,"-surface spacing and bottom-intensified stretching will be useful for boundary layer turbulence experiments, so I thought it was worthwhile to spend a bit more time to come up with something. I thought the hyperbolic generating function was also useful, so I added it to the docstring for `VerticallyStretchedRectilinearGrid` as an example. This PR also fixes a typo in that docstring. Some notes:. I developed a two-parameter stretching function:. ```julia; ## Linear near-surface generator; ζ₀(k) = 1 + (h(k) - 1) / refinement. ## Bottom-intensified stretching function ; Σ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching)). ## Generating function; z_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1); ```. with `refinement` and `stretching` parameters`. Finding a suitable grid requires playing with both these parameters: perhaps counter-intuitively, when the `refinement` is weaker, the `stretching` has to be stronger to obtain a grid that's nearly constantly spaced near the surface. I think a slightly more convenient parameterization would use a ""transition"" parameter (controlling the depth at which the grid transitions from constant spacing to stretched) rather than a stretching parameter (there would also be a small parameter involved to control ""how close"" the spacing would be to constant at the transition depth). However I couldn't figure out how to implement such a parameterization without solving a transcendental equation. The idea I had was to set the slope of `Σ` to a small number at a specified fraction of the domain height `hᵢ` by solving. ```julia; Σ′ = stretching * exp(-stretching * hᵢ) / (1 - exp(-stretching)) = ϵ; ```. for `stretching`. In the above, `ϵ` is a small parameter controlling the smallness of `Σ′` at the normalized height. Both `ϵ` and `hᵢ` are parameters. Aside from being not quite right, there's something a little off about this approach. I think `stretching` should somehow depend on `refinement`; eg when `refinement = 1` then no stretching is needed.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1810
https://github.com/CliMA/Oceananigans.jl/pull/1810:1350,Usability,intuit,intuitively,1350,"erating function and so a grid that becomes ever more refined toward the surface was used instead. I think a grid with constant near-surface spacing and bottom-intensified stretching will be useful for boundary layer turbulence experiments, so I thought it was worthwhile to spend a bit more time to come up with something. I thought the hyperbolic generating function was also useful, so I added it to the docstring for `VerticallyStretchedRectilinearGrid` as an example. This PR also fixes a typo in that docstring. Some notes:. I developed a two-parameter stretching function:. ```julia; ## Linear near-surface generator; ζ₀(k) = 1 + (h(k) - 1) / refinement. ## Bottom-intensified stretching function ; Σ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching)). ## Generating function; z_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1); ```. with `refinement` and `stretching` parameters`. Finding a suitable grid requires playing with both these parameters: perhaps counter-intuitively, when the `refinement` is weaker, the `stretching` has to be stronger to obtain a grid that's nearly constantly spaced near the surface. I think a slightly more convenient parameterization would use a ""transition"" parameter (controlling the depth at which the grid transitions from constant spacing to stretched) rather than a stretching parameter (there would also be a small parameter involved to control ""how close"" the spacing would be to constant at the transition depth). However I couldn't figure out how to implement such a parameterization without solving a transcendental equation. The idea I had was to set the slope of `Σ` to a small number at a specified fraction of the domain height `hᵢ` by solving. ```julia; Σ′ = stretching * exp(-stretching * hᵢ) / (1 - exp(-stretching)) = ϵ; ```. for `stretching`. In the above, `ϵ` is a small parameter controlling the smallness of `Σ′` at the normalized height. Both `ϵ` and `hᵢ` are parameters. Aside from being not quite right, there's something a little off abo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1810
https://github.com/CliMA/Oceananigans.jl/issues/1815:214,Safety,avoid,avoid,214,"https://github.com/CliMA/Oceananigans.jl/blob/e5a3d10df0d350af541613b5a47e963252f8f35d/src/Grids/regular_latitude_longitude_grid.jl#L33. What if we wanted to use `λ ∈ [-280, 80]`?. (Often people use this domain to avoid having the ""seam"" in the middle of the Pacific...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1815
https://github.com/CliMA/Oceananigans.jl/issues/1818:54,Energy Efficiency,energy,energy,54,"On a c-grid computing the Coriolis term could lead to energy/enstrophy loss. Schemes by Sadourny (1975) help alleviate this. These schemes are implemented on the sphere, e.g.,. https://github.com/CliMA/Oceananigans.jl/blob/master/src/Coriolis/hydrostatic_spherical_coriolis.jl. However, they are not implemented for `RegularRectilinearGrid`. cc: @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1818
https://github.com/CliMA/Oceananigans.jl/pull/1824:171,Modifiability,refactor,refactor,171,"Having `classification` (previously called ""`BCType`"") as a property of `BoundaryCondition` will allow data to be stored there. A future PR will leverage this property to refactor `Communication` boundary conditions for models with multiple grids or distributed across multiple nodes. It was also realized that `NormalFlow` is a special case of an ""Open"" boundary condition, where halo regions are ""directly"" determined by an array or function. True support for Open boundary conditions will be the subject of a future PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1824
https://github.com/CliMA/Oceananigans.jl/issues/1825:883,Availability,down,downside,883,"In the general case of a pre-computed grid or mesh, the `architecture` on which the grid is stored has be known. Thus in general, the `architecture` of a grid must be provided. The few special cases to this rule are grids with metrics that are either constant or can be computed on the fly, like `RegularRectilinearGrid`. Up to recently `RegularRectilinearGrid` was the only option, so we hadn't the motivation to ponder whether `architecture` belonged as a model property, field property, or grid property... Putting `architecture` in `grid` would mean that we don't have to specify it in model constructors. Since `grid` is so central we wouldn't really need `architecture` as a property anywhere else. For example, we wouldn't need to store `architecture` in every.single.field object, as we do now. Alleviating this boilerplate makes the change feel especially right... The main downside is a loss of flexibility for those grids that are truly architecture-independent, like `RegularRectilinearGrid` and `RegularLatitudeLongitudeGrid`. On the other hand, we have to specify `architecture` somewhere and rarely helpful to mix `CPU` and `GPU` computations using the same grid.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1825
https://github.com/CliMA/Oceananigans.jl/issues/1826:979,Availability,error,errors,979,"With a student, we are trying to initialize `IncompressibleModel` with a flow that is in thermal wind balance. We specify the velocity and then compute the buoyancy using the package `QuadGK`. The lines that we use are the following:. ```; parms = (f₀ = Coriolis.f, # s⁻¹, Coriolis parameter; N² = 1e-4, # s⁻¹, buoyancy frequency; D = grid.Lz, # m, ocean depth; L_y = Ly/2, # m, jet width scale; L_z = Lz/2, # m, jet depth scale; σz = 2, # jet width parameter; σy = 5, # jet depth parameter; γ = 1/2, # jet skew parameter; U_max = 2) # jet velocity scale. ū(x, y, z, t, p) = p.U_max * sech(p.σz * z/p.L_z - p.σy * ( y/p.L_y + p.γ * z/p.L_z)^2)^2. dudz(x, y, z, t, p) = 2*p.U_max/p.L_z * (2*p.γ*p.σy * (y/p.L_y + p.γ * z/p.L_z) - p.σz) * tanh(p.σz * z/p.L_z - p.σy * ( y/p.L_y + p.γ * z/p.L_z)^2) * sech(p.σz * z/p.L_z - p.σy * ( y/p.L_y + p.γ * z/p.L_z)^2)^2. b̄(x, y, z, t, p) = quadgk(yp -> p.N² * (z + p.D) - p.f₀*dudz(x, yp, z, t, p), -Ly/2, y)[1]; ```. It doesn't give any errors but seems to freeze when running the simulation. In the case of a 16x16 grid my student waited 4 hours and nothing. Any idea what the problem is?. There are a bunch of other ways for numerical integration that we can use but this does seem attractive. Any other suggestions would be appreciated.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1826
https://github.com/CliMA/Oceananigans.jl/issues/1826:1179,Deployability,integrat,integration,1179,"With a student, we are trying to initialize `IncompressibleModel` with a flow that is in thermal wind balance. We specify the velocity and then compute the buoyancy using the package `QuadGK`. The lines that we use are the following:. ```; parms = (f₀ = Coriolis.f, # s⁻¹, Coriolis parameter; N² = 1e-4, # s⁻¹, buoyancy frequency; D = grid.Lz, # m, ocean depth; L_y = Ly/2, # m, jet width scale; L_z = Lz/2, # m, jet depth scale; σz = 2, # jet width parameter; σy = 5, # jet depth parameter; γ = 1/2, # jet skew parameter; U_max = 2) # jet velocity scale. ū(x, y, z, t, p) = p.U_max * sech(p.σz * z/p.L_z - p.σy * ( y/p.L_y + p.γ * z/p.L_z)^2)^2. dudz(x, y, z, t, p) = 2*p.U_max/p.L_z * (2*p.γ*p.σy * (y/p.L_y + p.γ * z/p.L_z) - p.σz) * tanh(p.σz * z/p.L_z - p.σy * ( y/p.L_y + p.γ * z/p.L_z)^2) * sech(p.σz * z/p.L_z - p.σy * ( y/p.L_y + p.γ * z/p.L_z)^2)^2. b̄(x, y, z, t, p) = quadgk(yp -> p.N² * (z + p.D) - p.f₀*dudz(x, yp, z, t, p), -Ly/2, y)[1]; ```. It doesn't give any errors but seems to freeze when running the simulation. In the case of a 16x16 grid my student waited 4 hours and nothing. Any idea what the problem is?. There are a bunch of other ways for numerical integration that we can use but this does seem attractive. Any other suggestions would be appreciated.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1826
https://github.com/CliMA/Oceananigans.jl/issues/1826:1179,Integrability,integrat,integration,1179,"With a student, we are trying to initialize `IncompressibleModel` with a flow that is in thermal wind balance. We specify the velocity and then compute the buoyancy using the package `QuadGK`. The lines that we use are the following:. ```; parms = (f₀ = Coriolis.f, # s⁻¹, Coriolis parameter; N² = 1e-4, # s⁻¹, buoyancy frequency; D = grid.Lz, # m, ocean depth; L_y = Ly/2, # m, jet width scale; L_z = Lz/2, # m, jet depth scale; σz = 2, # jet width parameter; σy = 5, # jet depth parameter; γ = 1/2, # jet skew parameter; U_max = 2) # jet velocity scale. ū(x, y, z, t, p) = p.U_max * sech(p.σz * z/p.L_z - p.σy * ( y/p.L_y + p.γ * z/p.L_z)^2)^2. dudz(x, y, z, t, p) = 2*p.U_max/p.L_z * (2*p.γ*p.σy * (y/p.L_y + p.γ * z/p.L_z) - p.σz) * tanh(p.σz * z/p.L_z - p.σy * ( y/p.L_y + p.γ * z/p.L_z)^2) * sech(p.σz * z/p.L_z - p.σy * ( y/p.L_y + p.γ * z/p.L_z)^2)^2. b̄(x, y, z, t, p) = quadgk(yp -> p.N² * (z + p.D) - p.f₀*dudz(x, yp, z, t, p), -Ly/2, y)[1]; ```. It doesn't give any errors but seems to freeze when running the simulation. In the case of a 16x16 grid my student waited 4 hours and nothing. Any idea what the problem is?. There are a bunch of other ways for numerical integration that we can use but this does seem attractive. Any other suggestions would be appreciated.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1826
https://github.com/CliMA/Oceananigans.jl/issues/1827:442,Availability,mask,mask,442,"I've noticed that Oceananigans is _much_ slower when using forcing functions. As an example, I set-up a simulation without any forcing functions and I noticed that in the first minute (wall time) of the running simulation I complete 3.5% of the whole simulation period. However, if I include forcing functions as; ```julia; bot_mask = GaussianMask{:z}(center=minimum(znodes(Face, grid)), width=grid.Lz/10); mom_sponge = Relaxation(rate=1/10, mask=bot_mask, target=0); forcing = (u=mom_sponge, v=mom_sponge, w=mom_sponge); ```; then in the first (wall time) minute of running I complete only 0.15% of the simulation. Basically around 20 times slower!. I of course expected a slowdown after including forcing functions, but not by this much. Is this normal behavior?. So far I ran my tests only on CPUs, but I've observed similar behaviors on GPUs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827
https://github.com/CliMA/Oceananigans.jl/issues/1827:782,Testability,test,tests,782,"I've noticed that Oceananigans is _much_ slower when using forcing functions. As an example, I set-up a simulation without any forcing functions and I noticed that in the first minute (wall time) of the running simulation I complete 3.5% of the whole simulation period. However, if I include forcing functions as; ```julia; bot_mask = GaussianMask{:z}(center=minimum(znodes(Face, grid)), width=grid.Lz/10); mom_sponge = Relaxation(rate=1/10, mask=bot_mask, target=0); forcing = (u=mom_sponge, v=mom_sponge, w=mom_sponge); ```; then in the first (wall time) minute of running I complete only 0.15% of the simulation. Basically around 20 times slower!. I of course expected a slowdown after including forcing functions, but not by this much. Is this normal behavior?. So far I ran my tests only on CPUs, but I've observed similar behaviors on GPUs.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827
https://github.com/CliMA/Oceananigans.jl/pull/1828:168,Testability,test,tested,168,"This pull request changes the compat entry for the `CUDAKernels` package from `0.2` to `0.2, 0.3`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1828
https://github.com/CliMA/Oceananigans.jl/pull/1828:273,Testability,test,tests,273,"This pull request changes the compat entry for the `CUDAKernels` package from `0.2` to `0.2, 0.3`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1828
https://github.com/CliMA/Oceananigans.jl/pull/1829:175,Testability,test,tested,175,"This pull request changes the compat entry for the `KernelAbstractions` package from `0.6` to `0.6, 0.7`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1829
https://github.com/CliMA/Oceananigans.jl/pull/1829:280,Testability,test,tests,280,"This pull request changes the compat entry for the `KernelAbstractions` package from `0.6` to `0.6, 0.7`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1829
https://github.com/CliMA/Oceananigans.jl/issues/1832:247,Performance,perform,performance,247,"If you search for `grep -r ""\^2"" *` from Oceananigans' root dir, for example, you get many places where we exponentiate with an Int64. Per the discussion in https://github.com/CliMA/Oceananigans.jl/pull/1770 it seems that this causes a pretty big performance drawback in Julia 1.6 on GPUs. What should be our approach here? Do we wait for this to be resolved upstream or do we change all exponentiation in critical places to use `Int32`?. CC: @maleadt @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1832
https://github.com/CliMA/Oceananigans.jl/pull/1835:670,Safety,detect,detection,670,"Previously the functions viscous_flux_u* and diffusive_flux_* dispatched on AbstractPrimaryGrid. AbstractPrimaryGrid (now called AbstractUnderlyingGrid is an abstract type for distinguishing between ImmersedBoundaryGrid and the ""primitive"" / ""primary"" / ""underlying"" counterparts (I guess I'm still not sure what the best name is). As a result, flux calculations with ImmersedBoundaryGrid were hitting fallback flux functions that returned 0. This PR removes most instances dispatching on grid (except where necessary, where the dispatched type was changed from AbstractPrimaryGrid to AbstractGrid). It also nukes the fallbacks (which were the reason this issue escaped detection originally). This PR also adds a minimal test that _vertical_ diffusive and viscous fluxes work. It does not test the horizontal fluxes, but the test will catch egregious bugs like the one this PR fixes. The original motivation for dispatching on AbstractPrimaryGrid is not only wrong but also appears to be unnecessary, since the tests on this PR pass. For some reason TwoDimensionalLeith was also having trouble compiling on the GPU, so we're skipping those tests for now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1835
https://github.com/CliMA/Oceananigans.jl/pull/1835:721,Testability,test,test,721,"Previously the functions viscous_flux_u* and diffusive_flux_* dispatched on AbstractPrimaryGrid. AbstractPrimaryGrid (now called AbstractUnderlyingGrid is an abstract type for distinguishing between ImmersedBoundaryGrid and the ""primitive"" / ""primary"" / ""underlying"" counterparts (I guess I'm still not sure what the best name is). As a result, flux calculations with ImmersedBoundaryGrid were hitting fallback flux functions that returned 0. This PR removes most instances dispatching on grid (except where necessary, where the dispatched type was changed from AbstractPrimaryGrid to AbstractGrid). It also nukes the fallbacks (which were the reason this issue escaped detection originally). This PR also adds a minimal test that _vertical_ diffusive and viscous fluxes work. It does not test the horizontal fluxes, but the test will catch egregious bugs like the one this PR fixes. The original motivation for dispatching on AbstractPrimaryGrid is not only wrong but also appears to be unnecessary, since the tests on this PR pass. For some reason TwoDimensionalLeith was also having trouble compiling on the GPU, so we're skipping those tests for now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1835
https://github.com/CliMA/Oceananigans.jl/pull/1835:789,Testability,test,test,789,"Previously the functions viscous_flux_u* and diffusive_flux_* dispatched on AbstractPrimaryGrid. AbstractPrimaryGrid (now called AbstractUnderlyingGrid is an abstract type for distinguishing between ImmersedBoundaryGrid and the ""primitive"" / ""primary"" / ""underlying"" counterparts (I guess I'm still not sure what the best name is). As a result, flux calculations with ImmersedBoundaryGrid were hitting fallback flux functions that returned 0. This PR removes most instances dispatching on grid (except where necessary, where the dispatched type was changed from AbstractPrimaryGrid to AbstractGrid). It also nukes the fallbacks (which were the reason this issue escaped detection originally). This PR also adds a minimal test that _vertical_ diffusive and viscous fluxes work. It does not test the horizontal fluxes, but the test will catch egregious bugs like the one this PR fixes. The original motivation for dispatching on AbstractPrimaryGrid is not only wrong but also appears to be unnecessary, since the tests on this PR pass. For some reason TwoDimensionalLeith was also having trouble compiling on the GPU, so we're skipping those tests for now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1835
https://github.com/CliMA/Oceananigans.jl/pull/1835:825,Testability,test,test,825,"Previously the functions viscous_flux_u* and diffusive_flux_* dispatched on AbstractPrimaryGrid. AbstractPrimaryGrid (now called AbstractUnderlyingGrid is an abstract type for distinguishing between ImmersedBoundaryGrid and the ""primitive"" / ""primary"" / ""underlying"" counterparts (I guess I'm still not sure what the best name is). As a result, flux calculations with ImmersedBoundaryGrid were hitting fallback flux functions that returned 0. This PR removes most instances dispatching on grid (except where necessary, where the dispatched type was changed from AbstractPrimaryGrid to AbstractGrid). It also nukes the fallbacks (which were the reason this issue escaped detection originally). This PR also adds a minimal test that _vertical_ diffusive and viscous fluxes work. It does not test the horizontal fluxes, but the test will catch egregious bugs like the one this PR fixes. The original motivation for dispatching on AbstractPrimaryGrid is not only wrong but also appears to be unnecessary, since the tests on this PR pass. For some reason TwoDimensionalLeith was also having trouble compiling on the GPU, so we're skipping those tests for now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1835
https://github.com/CliMA/Oceananigans.jl/pull/1835:1011,Testability,test,tests,1011,"Previously the functions viscous_flux_u* and diffusive_flux_* dispatched on AbstractPrimaryGrid. AbstractPrimaryGrid (now called AbstractUnderlyingGrid is an abstract type for distinguishing between ImmersedBoundaryGrid and the ""primitive"" / ""primary"" / ""underlying"" counterparts (I guess I'm still not sure what the best name is). As a result, flux calculations with ImmersedBoundaryGrid were hitting fallback flux functions that returned 0. This PR removes most instances dispatching on grid (except where necessary, where the dispatched type was changed from AbstractPrimaryGrid to AbstractGrid). It also nukes the fallbacks (which were the reason this issue escaped detection originally). This PR also adds a minimal test that _vertical_ diffusive and viscous fluxes work. It does not test the horizontal fluxes, but the test will catch egregious bugs like the one this PR fixes. The original motivation for dispatching on AbstractPrimaryGrid is not only wrong but also appears to be unnecessary, since the tests on this PR pass. For some reason TwoDimensionalLeith was also having trouble compiling on the GPU, so we're skipping those tests for now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1835
https://github.com/CliMA/Oceananigans.jl/pull/1835:1140,Testability,test,tests,1140,"Previously the functions viscous_flux_u* and diffusive_flux_* dispatched on AbstractPrimaryGrid. AbstractPrimaryGrid (now called AbstractUnderlyingGrid is an abstract type for distinguishing between ImmersedBoundaryGrid and the ""primitive"" / ""primary"" / ""underlying"" counterparts (I guess I'm still not sure what the best name is). As a result, flux calculations with ImmersedBoundaryGrid were hitting fallback flux functions that returned 0. This PR removes most instances dispatching on grid (except where necessary, where the dispatched type was changed from AbstractPrimaryGrid to AbstractGrid). It also nukes the fallbacks (which were the reason this issue escaped detection originally). This PR also adds a minimal test that _vertical_ diffusive and viscous fluxes work. It does not test the horizontal fluxes, but the test will catch egregious bugs like the one this PR fixes. The original motivation for dispatching on AbstractPrimaryGrid is not only wrong but also appears to be unnecessary, since the tests on this PR pass. For some reason TwoDimensionalLeith was also having trouble compiling on the GPU, so we're skipping those tests for now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1835
https://github.com/CliMA/Oceananigans.jl/pull/1838:115,Testability,benchmark,benchmarks,115,"This is an attempt to make the left menu of the docs feel a bit more intuitive and organized. What I did:. - Moved benchmarks, function index and library to appendix. I think not many people need that information, so it makes sense put it there I think); - Moved appendix to be the last item on the menu (as is customary for most documents); - Moved gallery to after the contributor's guide (since I think contributor's guide is more important so it can come first). I know this is unprompted (nobody complained about the docs) but I think it's a positive change. Eager to hear opinions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1838
https://github.com/CliMA/Oceananigans.jl/pull/1838:69,Usability,intuit,intuitive,69,"This is an attempt to make the left menu of the docs feel a bit more intuitive and organized. What I did:. - Moved benchmarks, function index and library to appendix. I think not many people need that information, so it makes sense put it there I think); - Moved appendix to be the last item on the menu (as is customary for most documents); - Moved gallery to after the contributor's guide (since I think contributor's guide is more important so it can come first). I know this is unprompted (nobody complained about the docs) but I think it's a positive change. Eager to hear opinions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1838
https://github.com/CliMA/Oceananigans.jl/pull/1838:385,Usability,guid,guide,385,"This is an attempt to make the left menu of the docs feel a bit more intuitive and organized. What I did:. - Moved benchmarks, function index and library to appendix. I think not many people need that information, so it makes sense put it there I think); - Moved appendix to be the last item on the menu (as is customary for most documents); - Moved gallery to after the contributor's guide (since I think contributor's guide is more important so it can come first). I know this is unprompted (nobody complained about the docs) but I think it's a positive change. Eager to hear opinions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1838
https://github.com/CliMA/Oceananigans.jl/pull/1838:420,Usability,guid,guide,420,"This is an attempt to make the left menu of the docs feel a bit more intuitive and organized. What I did:. - Moved benchmarks, function index and library to appendix. I think not many people need that information, so it makes sense put it there I think); - Moved appendix to be the last item on the menu (as is customary for most documents); - Moved gallery to after the contributor's guide (since I think contributor's guide is more important so it can come first). I know this is unprompted (nobody complained about the docs) but I think it's a positive change. Eager to hear opinions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1838
https://github.com/CliMA/Oceananigans.jl/pull/1843:27,Modifiability,refactor,refactor,27,"This PR introduces a major refactor of `FieldBoundaryConditions` and changes the user API. The `grid` and field location are no longer necessary to build `FieldBoundaryConditions`. This means that the constructors `TracerBoundaryConditions`, `UVelocityBoundaryConditions`, etc, are gone. Instead we have only `FieldBoundaryConditions`, which is used like. ```julia; u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(-1e-4), bottom=FluxBoundaryCondition((x, y, t, u) = -1e-3 * u, field_dependencies=:u)). T_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(1e-8)); ```. There's also a new constructor `AuxiliaryFieldBoundaryConditions` which takes the place of `ComputedFieldBoundaryConditions` and is now the default for `Field` and `ComputedField`. The difference is that `AuxiliaryFieldBoundaryConditions` have `nothing` instead of an `ImpenetrableBoundaryCondition` in `Bounded` directions when they're located on faces. Under the hood the `FieldBoundaryConditions` struct is ""flattened"" so there's no more `CoordinateBoundaryConditions`. In addition, a new field `immersed` is added to `FieldBoundaryConditions` in addition to `east`, `west`, etc. This will be used to support boundary conditions on immersed boundaries in the future. There's still quite a few validation experiments to clean up and probably some lingering issues with tests, but I was able to get the examples to run so I thought it was the right time to open the PR. On the API changes: it seemed like a positive change that we don't need `grid` in the boundary conditions constructor, and that we only have one name `FieldBoundaryConditions` rather than 4. However, if others feel they liked the old API, we can add convenience functions `TracerBoundaryConditions`, etc back to the source.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1843
https://github.com/CliMA/Oceananigans.jl/pull/1843:1279,Security,validat,validation,1279,"This PR introduces a major refactor of `FieldBoundaryConditions` and changes the user API. The `grid` and field location are no longer necessary to build `FieldBoundaryConditions`. This means that the constructors `TracerBoundaryConditions`, `UVelocityBoundaryConditions`, etc, are gone. Instead we have only `FieldBoundaryConditions`, which is used like. ```julia; u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(-1e-4), bottom=FluxBoundaryCondition((x, y, t, u) = -1e-3 * u, field_dependencies=:u)). T_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(1e-8)); ```. There's also a new constructor `AuxiliaryFieldBoundaryConditions` which takes the place of `ComputedFieldBoundaryConditions` and is now the default for `Field` and `ComputedField`. The difference is that `AuxiliaryFieldBoundaryConditions` have `nothing` instead of an `ImpenetrableBoundaryCondition` in `Bounded` directions when they're located on faces. Under the hood the `FieldBoundaryConditions` struct is ""flattened"" so there's no more `CoordinateBoundaryConditions`. In addition, a new field `immersed` is added to `FieldBoundaryConditions` in addition to `east`, `west`, etc. This will be used to support boundary conditions on immersed boundaries in the future. There's still quite a few validation experiments to clean up and probably some lingering issues with tests, but I was able to get the examples to run so I thought it was the right time to open the PR. On the API changes: it seemed like a positive change that we don't need `grid` in the boundary conditions constructor, and that we only have one name `FieldBoundaryConditions` rather than 4. However, if others feel they liked the old API, we can add convenience functions `TracerBoundaryConditions`, etc back to the source.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1843
https://github.com/CliMA/Oceananigans.jl/pull/1843:1354,Testability,test,tests,1354,"This PR introduces a major refactor of `FieldBoundaryConditions` and changes the user API. The `grid` and field location are no longer necessary to build `FieldBoundaryConditions`. This means that the constructors `TracerBoundaryConditions`, `UVelocityBoundaryConditions`, etc, are gone. Instead we have only `FieldBoundaryConditions`, which is used like. ```julia; u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(-1e-4), bottom=FluxBoundaryCondition((x, y, t, u) = -1e-3 * u, field_dependencies=:u)). T_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(1e-8)); ```. There's also a new constructor `AuxiliaryFieldBoundaryConditions` which takes the place of `ComputedFieldBoundaryConditions` and is now the default for `Field` and `ComputedField`. The difference is that `AuxiliaryFieldBoundaryConditions` have `nothing` instead of an `ImpenetrableBoundaryCondition` in `Bounded` directions when they're located on faces. Under the hood the `FieldBoundaryConditions` struct is ""flattened"" so there's no more `CoordinateBoundaryConditions`. In addition, a new field `immersed` is added to `FieldBoundaryConditions` in addition to `east`, `west`, etc. This will be used to support boundary conditions on immersed boundaries in the future. There's still quite a few validation experiments to clean up and probably some lingering issues with tests, but I was able to get the examples to run so I thought it was the right time to open the PR. On the API changes: it seemed like a positive change that we don't need `grid` in the boundary conditions constructor, and that we only have one name `FieldBoundaryConditions` rather than 4. However, if others feel they liked the old API, we can add convenience functions `TracerBoundaryConditions`, etc back to the source.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1843
https://github.com/CliMA/Oceananigans.jl/pull/1844:0,Deployability,Release,Release,0,Release notes:. * Fixes a major bug with `ImmersedBoundaryGrid` that elided all viscous fluxes,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1844
https://github.com/CliMA/Oceananigans.jl/issues/1846:326,Energy Efficiency,efficient,efficiently,326,"The issue of calculating a thermally-wind-balanced background has popped up a couple times before (more recently [here](https://github.com/CliMA/Oceananigans.jl/issues/1826)) and I think it would be nice to have an example where `b` is computed from `u` for a general function. I myself don't know how to do that properly and efficiently (I think), so it would definitely be helpful for a larger audience I believe. @glwagner @francispoulin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1846
https://github.com/CliMA/Oceananigans.jl/issues/1850:146,Performance,load,loads,146,"The way examples are written now is that there is the there is a **part 1** that sets up and runs a simulation and saves output. Then, **part 2** loads the `.jld2`/`.nc` file and plots an animations or what not. However, the way part 2 is currently coded up in most examples *it requires that part 1 is run** as it references on things like `grid` or `fields` constructed by part 1. E.g., ; https://github.com/CliMA/Oceananigans.jl/blob/3c930b00f0ccfdcc20556a9b6ac888b63aeb58d2/examples/eady_turbulence.jl#L317-L324. Ideally, one would like to be able to run the ""load `.jld2` file and animate"" independently. That's the whole idea, right? At the moment the way I do it is that I have to run part 1 until **just before** the `run!(simulation)`, make sure I overwrite the `.jld2` placeholder file that is created with the one that has been populated by some other run previously, and then move on with loading output and animating. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1850
https://github.com/CliMA/Oceananigans.jl/issues/1850:564,Performance,load,load,564,"The way examples are written now is that there is the there is a **part 1** that sets up and runs a simulation and saves output. Then, **part 2** loads the `.jld2`/`.nc` file and plots an animations or what not. However, the way part 2 is currently coded up in most examples *it requires that part 1 is run** as it references on things like `grid` or `fields` constructed by part 1. E.g., ; https://github.com/CliMA/Oceananigans.jl/blob/3c930b00f0ccfdcc20556a9b6ac888b63aeb58d2/examples/eady_turbulence.jl#L317-L324. Ideally, one would like to be able to run the ""load `.jld2` file and animate"" independently. That's the whole idea, right? At the moment the way I do it is that I have to run part 1 until **just before** the `run!(simulation)`, make sure I overwrite the `.jld2` placeholder file that is created with the one that has been populated by some other run previously, and then move on with loading output and animating. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1850
https://github.com/CliMA/Oceananigans.jl/issues/1850:901,Performance,load,loading,901,"The way examples are written now is that there is the there is a **part 1** that sets up and runs a simulation and saves output. Then, **part 2** loads the `.jld2`/`.nc` file and plots an animations or what not. However, the way part 2 is currently coded up in most examples *it requires that part 1 is run** as it references on things like `grid` or `fields` constructed by part 1. E.g., ; https://github.com/CliMA/Oceananigans.jl/blob/3c930b00f0ccfdcc20556a9b6ac888b63aeb58d2/examples/eady_turbulence.jl#L317-L324. Ideally, one would like to be able to run the ""load `.jld2` file and animate"" independently. That's the whole idea, right? At the moment the way I do it is that I have to run part 1 until **just before** the `run!(simulation)`, make sure I overwrite the `.jld2` placeholder file that is created with the one that has been populated by some other run previously, and then move on with loading output and animating. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1850
https://github.com/CliMA/Oceananigans.jl/issues/1852:1290,Availability,down,down,1290,"f experience we've accumulated using Oceananigans to refactor the docs to make them more useful and practical. Here's the current structure:. 1. Home; 2. Installation instructions; 3. Using GPUs; 4. Examples; 5. Physics; 6. Numerical implementation; 7. Model setup; 8. Simulation tips; 9. Contributor's guide; 10. Gallery; 11. References; 12. Appendix. I propose refactoring this in a few ways:. * Adding a sort of ""quick start"" section (perhaps named just that) after ""Installation"". This will implement a similar simple example as `one_dimensional_diffusion.jl`, except with even more text, explaining basic important types and functions and providing links to other parts of the docs to obtain more information.; * ""Flattening"" the model setup section by bringing its sections out into the main list. I think this list should be refactored too according to what's important. For example, we don't need a whole section on `Clock`.; * Adding independent sections for each model type; * Moving ""Physics"" and ""Numerical implementation"" down in the docs to emphasize code documentation. The resulting structure might be something like. 1. What's Oceananigans?; 2. Installation; 3. Getting started; 4. Examples; 5. Grids; 6. Fields, BoundaryCondition, and AbstractOperations; 7. IncompressibleModel; 8. HydrostaticFreeSurfaceModel; 9. ShallowWaterModel; 10. Setting initial conditions; 11. Diffusion, viscosity, and TurbulenceClosures ; 12. Forcing functions; 13. Coriolis forces; 14. Buoyancy forces; 15. OutputWriters; 16. OutputReaders, post-processing, and plotting; 17. Using Graphics Processing Units (GPUs); 18. Useful tips and common pitfalls (from ""simulation tips""); 19. Contributor's guide; 20. Gallery (this should be way higher eventually, but we need more recent content to motivate that...); 22. Physics and numerical implementation; 23. References; 24. Appendix. It will take a few PRs to resolve this issue. It'd be great to incorporate feedback on the plan too before making any moves.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852
https://github.com/CliMA/Oceananigans.jl/issues/1852:409,Deployability,Install,Installation,409,"As HydrostaticFreeSurfaceModel is further developed we're going to have to restructure the docs significantly. In addition to that the docs have grown a bit stale and could probably use a refresh. I think it's a good time too to leverage the year or two of experience we've accumulated using Oceananigans to refactor the docs to make them more useful and practical. Here's the current structure:. 1. Home; 2. Installation instructions; 3. Using GPUs; 4. Examples; 5. Physics; 6. Numerical implementation; 7. Model setup; 8. Simulation tips; 9. Contributor's guide; 10. Gallery; 11. References; 12. Appendix. I propose refactoring this in a few ways:. * Adding a sort of ""quick start"" section (perhaps named just that) after ""Installation"". This will implement a similar simple example as `one_dimensional_diffusion.jl`, except with even more text, explaining basic important types and functions and providing links to other parts of the docs to obtain more information.; * ""Flattening"" the model setup section by bringing its sections out into the main list. I think this list should be refactored too according to what's important. For example, we don't need a whole section on `Clock`.; * Adding independent sections for each model type; * Moving ""Physics"" and ""Numerical implementation"" down in the docs to emphasize code documentation. The resulting structure might be something like. 1. What's Oceananigans?; 2. Installation; 3. Getting started; 4. Examples; 5. Grids; 6. Fields, BoundaryCondition, and AbstractOperations; 7. IncompressibleModel; 8. HydrostaticFreeSurfaceModel; 9. ShallowWaterModel; 10. Setting initial conditions; 11. Diffusion, viscosity, and TurbulenceClosures ; 12. Forcing functions; 13. Coriolis forces; 14. Buoyancy forces; 15. OutputWriters; 16. OutputReaders, post-processing, and plotting; 17. Using Graphics Processing Units (GPUs); 18. Useful tips and common pitfalls (from ""simulation tips""); 19. Contributor's guide; 20. Gallery (this should be way higher eventual",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852
https://github.com/CliMA/Oceananigans.jl/issues/1852:725,Deployability,Install,Installation,725,"As HydrostaticFreeSurfaceModel is further developed we're going to have to restructure the docs significantly. In addition to that the docs have grown a bit stale and could probably use a refresh. I think it's a good time too to leverage the year or two of experience we've accumulated using Oceananigans to refactor the docs to make them more useful and practical. Here's the current structure:. 1. Home; 2. Installation instructions; 3. Using GPUs; 4. Examples; 5. Physics; 6. Numerical implementation; 7. Model setup; 8. Simulation tips; 9. Contributor's guide; 10. Gallery; 11. References; 12. Appendix. I propose refactoring this in a few ways:. * Adding a sort of ""quick start"" section (perhaps named just that) after ""Installation"". This will implement a similar simple example as `one_dimensional_diffusion.jl`, except with even more text, explaining basic important types and functions and providing links to other parts of the docs to obtain more information.; * ""Flattening"" the model setup section by bringing its sections out into the main list. I think this list should be refactored too according to what's important. For example, we don't need a whole section on `Clock`.; * Adding independent sections for each model type; * Moving ""Physics"" and ""Numerical implementation"" down in the docs to emphasize code documentation. The resulting structure might be something like. 1. What's Oceananigans?; 2. Installation; 3. Getting started; 4. Examples; 5. Grids; 6. Fields, BoundaryCondition, and AbstractOperations; 7. IncompressibleModel; 8. HydrostaticFreeSurfaceModel; 9. ShallowWaterModel; 10. Setting initial conditions; 11. Diffusion, viscosity, and TurbulenceClosures ; 12. Forcing functions; 13. Coriolis forces; 14. Buoyancy forces; 15. OutputWriters; 16. OutputReaders, post-processing, and plotting; 17. Using Graphics Processing Units (GPUs); 18. Useful tips and common pitfalls (from ""simulation tips""); 19. Contributor's guide; 20. Gallery (this should be way higher eventual",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852
https://github.com/CliMA/Oceananigans.jl/issues/1852:1417,Deployability,Install,Installation,1417,"f experience we've accumulated using Oceananigans to refactor the docs to make them more useful and practical. Here's the current structure:. 1. Home; 2. Installation instructions; 3. Using GPUs; 4. Examples; 5. Physics; 6. Numerical implementation; 7. Model setup; 8. Simulation tips; 9. Contributor's guide; 10. Gallery; 11. References; 12. Appendix. I propose refactoring this in a few ways:. * Adding a sort of ""quick start"" section (perhaps named just that) after ""Installation"". This will implement a similar simple example as `one_dimensional_diffusion.jl`, except with even more text, explaining basic important types and functions and providing links to other parts of the docs to obtain more information.; * ""Flattening"" the model setup section by bringing its sections out into the main list. I think this list should be refactored too according to what's important. For example, we don't need a whole section on `Clock`.; * Adding independent sections for each model type; * Moving ""Physics"" and ""Numerical implementation"" down in the docs to emphasize code documentation. The resulting structure might be something like. 1. What's Oceananigans?; 2. Installation; 3. Getting started; 4. Examples; 5. Grids; 6. Fields, BoundaryCondition, and AbstractOperations; 7. IncompressibleModel; 8. HydrostaticFreeSurfaceModel; 9. ShallowWaterModel; 10. Setting initial conditions; 11. Diffusion, viscosity, and TurbulenceClosures ; 12. Forcing functions; 13. Coriolis forces; 14. Buoyancy forces; 15. OutputWriters; 16. OutputReaders, post-processing, and plotting; 17. Using Graphics Processing Units (GPUs); 18. Useful tips and common pitfalls (from ""simulation tips""); 19. Contributor's guide; 20. Gallery (this should be way higher eventually, but we need more recent content to motivate that...); 22. Physics and numerical implementation; 23. References; 24. Appendix. It will take a few PRs to resolve this issue. It'd be great to incorporate feedback on the plan too before making any moves.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852
https://github.com/CliMA/Oceananigans.jl/issues/1852:308,Modifiability,refactor,refactor,308,"As HydrostaticFreeSurfaceModel is further developed we're going to have to restructure the docs significantly. In addition to that the docs have grown a bit stale and could probably use a refresh. I think it's a good time too to leverage the year or two of experience we've accumulated using Oceananigans to refactor the docs to make them more useful and practical. Here's the current structure:. 1. Home; 2. Installation instructions; 3. Using GPUs; 4. Examples; 5. Physics; 6. Numerical implementation; 7. Model setup; 8. Simulation tips; 9. Contributor's guide; 10. Gallery; 11. References; 12. Appendix. I propose refactoring this in a few ways:. * Adding a sort of ""quick start"" section (perhaps named just that) after ""Installation"". This will implement a similar simple example as `one_dimensional_diffusion.jl`, except with even more text, explaining basic important types and functions and providing links to other parts of the docs to obtain more information.; * ""Flattening"" the model setup section by bringing its sections out into the main list. I think this list should be refactored too according to what's important. For example, we don't need a whole section on `Clock`.; * Adding independent sections for each model type; * Moving ""Physics"" and ""Numerical implementation"" down in the docs to emphasize code documentation. The resulting structure might be something like. 1. What's Oceananigans?; 2. Installation; 3. Getting started; 4. Examples; 5. Grids; 6. Fields, BoundaryCondition, and AbstractOperations; 7. IncompressibleModel; 8. HydrostaticFreeSurfaceModel; 9. ShallowWaterModel; 10. Setting initial conditions; 11. Diffusion, viscosity, and TurbulenceClosures ; 12. Forcing functions; 13. Coriolis forces; 14. Buoyancy forces; 15. OutputWriters; 16. OutputReaders, post-processing, and plotting; 17. Using Graphics Processing Units (GPUs); 18. Useful tips and common pitfalls (from ""simulation tips""); 19. Contributor's guide; 20. Gallery (this should be way higher eventual",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852
https://github.com/CliMA/Oceananigans.jl/issues/1852:618,Modifiability,refactor,refactoring,618,"As HydrostaticFreeSurfaceModel is further developed we're going to have to restructure the docs significantly. In addition to that the docs have grown a bit stale and could probably use a refresh. I think it's a good time too to leverage the year or two of experience we've accumulated using Oceananigans to refactor the docs to make them more useful and practical. Here's the current structure:. 1. Home; 2. Installation instructions; 3. Using GPUs; 4. Examples; 5. Physics; 6. Numerical implementation; 7. Model setup; 8. Simulation tips; 9. Contributor's guide; 10. Gallery; 11. References; 12. Appendix. I propose refactoring this in a few ways:. * Adding a sort of ""quick start"" section (perhaps named just that) after ""Installation"". This will implement a similar simple example as `one_dimensional_diffusion.jl`, except with even more text, explaining basic important types and functions and providing links to other parts of the docs to obtain more information.; * ""Flattening"" the model setup section by bringing its sections out into the main list. I think this list should be refactored too according to what's important. For example, we don't need a whole section on `Clock`.; * Adding independent sections for each model type; * Moving ""Physics"" and ""Numerical implementation"" down in the docs to emphasize code documentation. The resulting structure might be something like. 1. What's Oceananigans?; 2. Installation; 3. Getting started; 4. Examples; 5. Grids; 6. Fields, BoundaryCondition, and AbstractOperations; 7. IncompressibleModel; 8. HydrostaticFreeSurfaceModel; 9. ShallowWaterModel; 10. Setting initial conditions; 11. Diffusion, viscosity, and TurbulenceClosures ; 12. Forcing functions; 13. Coriolis forces; 14. Buoyancy forces; 15. OutputWriters; 16. OutputReaders, post-processing, and plotting; 17. Using Graphics Processing Units (GPUs); 18. Useful tips and common pitfalls (from ""simulation tips""); 19. Contributor's guide; 20. Gallery (this should be way higher eventual",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852
https://github.com/CliMA/Oceananigans.jl/issues/1852:1087,Modifiability,refactor,refactored,1087," significantly. In addition to that the docs have grown a bit stale and could probably use a refresh. I think it's a good time too to leverage the year or two of experience we've accumulated using Oceananigans to refactor the docs to make them more useful and practical. Here's the current structure:. 1. Home; 2. Installation instructions; 3. Using GPUs; 4. Examples; 5. Physics; 6. Numerical implementation; 7. Model setup; 8. Simulation tips; 9. Contributor's guide; 10. Gallery; 11. References; 12. Appendix. I propose refactoring this in a few ways:. * Adding a sort of ""quick start"" section (perhaps named just that) after ""Installation"". This will implement a similar simple example as `one_dimensional_diffusion.jl`, except with even more text, explaining basic important types and functions and providing links to other parts of the docs to obtain more information.; * ""Flattening"" the model setup section by bringing its sections out into the main list. I think this list should be refactored too according to what's important. For example, we don't need a whole section on `Clock`.; * Adding independent sections for each model type; * Moving ""Physics"" and ""Numerical implementation"" down in the docs to emphasize code documentation. The resulting structure might be something like. 1. What's Oceananigans?; 2. Installation; 3. Getting started; 4. Examples; 5. Grids; 6. Fields, BoundaryCondition, and AbstractOperations; 7. IncompressibleModel; 8. HydrostaticFreeSurfaceModel; 9. ShallowWaterModel; 10. Setting initial conditions; 11. Diffusion, viscosity, and TurbulenceClosures ; 12. Forcing functions; 13. Coriolis forces; 14. Buoyancy forces; 15. OutputWriters; 16. OutputReaders, post-processing, and plotting; 17. Using Graphics Processing Units (GPUs); 18. Useful tips and common pitfalls (from ""simulation tips""); 19. Contributor's guide; 20. Gallery (this should be way higher eventually, but we need more recent content to motivate that...); 22. Physics and numerical implementa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852
https://github.com/CliMA/Oceananigans.jl/issues/1852:558,Usability,guid,guide,558,"As HydrostaticFreeSurfaceModel is further developed we're going to have to restructure the docs significantly. In addition to that the docs have grown a bit stale and could probably use a refresh. I think it's a good time too to leverage the year or two of experience we've accumulated using Oceananigans to refactor the docs to make them more useful and practical. Here's the current structure:. 1. Home; 2. Installation instructions; 3. Using GPUs; 4. Examples; 5. Physics; 6. Numerical implementation; 7. Model setup; 8. Simulation tips; 9. Contributor's guide; 10. Gallery; 11. References; 12. Appendix. I propose refactoring this in a few ways:. * Adding a sort of ""quick start"" section (perhaps named just that) after ""Installation"". This will implement a similar simple example as `one_dimensional_diffusion.jl`, except with even more text, explaining basic important types and functions and providing links to other parts of the docs to obtain more information.; * ""Flattening"" the model setup section by bringing its sections out into the main list. I think this list should be refactored too according to what's important. For example, we don't need a whole section on `Clock`.; * Adding independent sections for each model type; * Moving ""Physics"" and ""Numerical implementation"" down in the docs to emphasize code documentation. The resulting structure might be something like. 1. What's Oceananigans?; 2. Installation; 3. Getting started; 4. Examples; 5. Grids; 6. Fields, BoundaryCondition, and AbstractOperations; 7. IncompressibleModel; 8. HydrostaticFreeSurfaceModel; 9. ShallowWaterModel; 10. Setting initial conditions; 11. Diffusion, viscosity, and TurbulenceClosures ; 12. Forcing functions; 13. Coriolis forces; 14. Buoyancy forces; 15. OutputWriters; 16. OutputReaders, post-processing, and plotting; 17. Using Graphics Processing Units (GPUs); 18. Useful tips and common pitfalls (from ""simulation tips""); 19. Contributor's guide; 20. Gallery (this should be way higher eventual",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852
https://github.com/CliMA/Oceananigans.jl/issues/1852:770,Usability,simpl,simple,770,"As HydrostaticFreeSurfaceModel is further developed we're going to have to restructure the docs significantly. In addition to that the docs have grown a bit stale and could probably use a refresh. I think it's a good time too to leverage the year or two of experience we've accumulated using Oceananigans to refactor the docs to make them more useful and practical. Here's the current structure:. 1. Home; 2. Installation instructions; 3. Using GPUs; 4. Examples; 5. Physics; 6. Numerical implementation; 7. Model setup; 8. Simulation tips; 9. Contributor's guide; 10. Gallery; 11. References; 12. Appendix. I propose refactoring this in a few ways:. * Adding a sort of ""quick start"" section (perhaps named just that) after ""Installation"". This will implement a similar simple example as `one_dimensional_diffusion.jl`, except with even more text, explaining basic important types and functions and providing links to other parts of the docs to obtain more information.; * ""Flattening"" the model setup section by bringing its sections out into the main list. I think this list should be refactored too according to what's important. For example, we don't need a whole section on `Clock`.; * Adding independent sections for each model type; * Moving ""Physics"" and ""Numerical implementation"" down in the docs to emphasize code documentation. The resulting structure might be something like. 1. What's Oceananigans?; 2. Installation; 3. Getting started; 4. Examples; 5. Grids; 6. Fields, BoundaryCondition, and AbstractOperations; 7. IncompressibleModel; 8. HydrostaticFreeSurfaceModel; 9. ShallowWaterModel; 10. Setting initial conditions; 11. Diffusion, viscosity, and TurbulenceClosures ; 12. Forcing functions; 13. Coriolis forces; 14. Buoyancy forces; 15. OutputWriters; 16. OutputReaders, post-processing, and plotting; 17. Using Graphics Processing Units (GPUs); 18. Useful tips and common pitfalls (from ""simulation tips""); 19. Contributor's guide; 20. Gallery (this should be way higher eventual",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852
https://github.com/CliMA/Oceananigans.jl/issues/1852:1947,Usability,guid,guide,1947,"f experience we've accumulated using Oceananigans to refactor the docs to make them more useful and practical. Here's the current structure:. 1. Home; 2. Installation instructions; 3. Using GPUs; 4. Examples; 5. Physics; 6. Numerical implementation; 7. Model setup; 8. Simulation tips; 9. Contributor's guide; 10. Gallery; 11. References; 12. Appendix. I propose refactoring this in a few ways:. * Adding a sort of ""quick start"" section (perhaps named just that) after ""Installation"". This will implement a similar simple example as `one_dimensional_diffusion.jl`, except with even more text, explaining basic important types and functions and providing links to other parts of the docs to obtain more information.; * ""Flattening"" the model setup section by bringing its sections out into the main list. I think this list should be refactored too according to what's important. For example, we don't need a whole section on `Clock`.; * Adding independent sections for each model type; * Moving ""Physics"" and ""Numerical implementation"" down in the docs to emphasize code documentation. The resulting structure might be something like. 1. What's Oceananigans?; 2. Installation; 3. Getting started; 4. Examples; 5. Grids; 6. Fields, BoundaryCondition, and AbstractOperations; 7. IncompressibleModel; 8. HydrostaticFreeSurfaceModel; 9. ShallowWaterModel; 10. Setting initial conditions; 11. Diffusion, viscosity, and TurbulenceClosures ; 12. Forcing functions; 13. Coriolis forces; 14. Buoyancy forces; 15. OutputWriters; 16. OutputReaders, post-processing, and plotting; 17. Using Graphics Processing Units (GPUs); 18. Useful tips and common pitfalls (from ""simulation tips""); 19. Contributor's guide; 20. Gallery (this should be way higher eventually, but we need more recent content to motivate that...); 22. Physics and numerical implementation; 23. References; 24. Appendix. It will take a few PRs to resolve this issue. It'd be great to incorporate feedback on the plan too before making any moves.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852
https://github.com/CliMA/Oceananigans.jl/issues/1852:2206,Usability,feedback,feedback,2206,"f experience we've accumulated using Oceananigans to refactor the docs to make them more useful and practical. Here's the current structure:. 1. Home; 2. Installation instructions; 3. Using GPUs; 4. Examples; 5. Physics; 6. Numerical implementation; 7. Model setup; 8. Simulation tips; 9. Contributor's guide; 10. Gallery; 11. References; 12. Appendix. I propose refactoring this in a few ways:. * Adding a sort of ""quick start"" section (perhaps named just that) after ""Installation"". This will implement a similar simple example as `one_dimensional_diffusion.jl`, except with even more text, explaining basic important types and functions and providing links to other parts of the docs to obtain more information.; * ""Flattening"" the model setup section by bringing its sections out into the main list. I think this list should be refactored too according to what's important. For example, we don't need a whole section on `Clock`.; * Adding independent sections for each model type; * Moving ""Physics"" and ""Numerical implementation"" down in the docs to emphasize code documentation. The resulting structure might be something like. 1. What's Oceananigans?; 2. Installation; 3. Getting started; 4. Examples; 5. Grids; 6. Fields, BoundaryCondition, and AbstractOperations; 7. IncompressibleModel; 8. HydrostaticFreeSurfaceModel; 9. ShallowWaterModel; 10. Setting initial conditions; 11. Diffusion, viscosity, and TurbulenceClosures ; 12. Forcing functions; 13. Coriolis forces; 14. Buoyancy forces; 15. OutputWriters; 16. OutputReaders, post-processing, and plotting; 17. Using Graphics Processing Units (GPUs); 18. Useful tips and common pitfalls (from ""simulation tips""); 19. Contributor's guide; 20. Gallery (this should be way higher eventually, but we need more recent content to motivate that...); 22. Physics and numerical implementation; 23. References; 24. Appendix. It will take a few PRs to resolve this issue. It'd be great to incorporate feedback on the plan too before making any moves.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852
https://github.com/CliMA/Oceananigans.jl/pull/1859:48,Deployability,Continuous,ContinuousBoundaryFunction,48,"This PR makes a few small changes needed to use ContinuousBoundaryFunction with auxiliary fields, which have no notion of ""time"" or other model fields. For this case; we want to be able to write something like. ```julia; c_surface(x, y) = cos(pi * x); c_bcs = FieldBoundaryConditions(grid, (Center, Center, Center), top = ValueBoundaryCondition(c_surface)); c = CenterField(grid, c_bcs); fill_halo_regions!(c.architecture, c); ```. Prior to this PR this would fail (we only supported constant boundary conditions on auxiliary fields). This PR also ""reduces"" the location at which the boundary condition is applied, so that `ReducedField`s might use something like. ```julia; r_surface(x) = cos(pi * x); r_bcs = FieldBoundaryConditions(grid, (Center, Nothing, Center), top = ValueBoundaryCondition(r_surface)); r = ReducedField(Center, Nothing, Center, grid, r_bcs); fill_halo_regions!(r.architecture, r); ```. if we eventually set the location of fields in `Flat` dimensions to `Nothing` this will also have an impact on syntax used for building models. This PR needs a test or two before merging. cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1859
https://github.com/CliMA/Oceananigans.jl/pull/1859:549,Energy Efficiency,reduce,reduces,549,"This PR makes a few small changes needed to use ContinuousBoundaryFunction with auxiliary fields, which have no notion of ""time"" or other model fields. For this case; we want to be able to write something like. ```julia; c_surface(x, y) = cos(pi * x); c_bcs = FieldBoundaryConditions(grid, (Center, Center, Center), top = ValueBoundaryCondition(c_surface)); c = CenterField(grid, c_bcs); fill_halo_regions!(c.architecture, c); ```. Prior to this PR this would fail (we only supported constant boundary conditions on auxiliary fields). This PR also ""reduces"" the location at which the boundary condition is applied, so that `ReducedField`s might use something like. ```julia; r_surface(x) = cos(pi * x); r_bcs = FieldBoundaryConditions(grid, (Center, Nothing, Center), top = ValueBoundaryCondition(r_surface)); r = ReducedField(Center, Nothing, Center, grid, r_bcs); fill_halo_regions!(r.architecture, r); ```. if we eventually set the location of fields in `Flat` dimensions to `Nothing` this will also have an impact on syntax used for building models. This PR needs a test or two before merging. cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1859
https://github.com/CliMA/Oceananigans.jl/pull/1859:624,Energy Efficiency,Reduce,ReducedField,624,"This PR makes a few small changes needed to use ContinuousBoundaryFunction with auxiliary fields, which have no notion of ""time"" or other model fields. For this case; we want to be able to write something like. ```julia; c_surface(x, y) = cos(pi * x); c_bcs = FieldBoundaryConditions(grid, (Center, Center, Center), top = ValueBoundaryCondition(c_surface)); c = CenterField(grid, c_bcs); fill_halo_regions!(c.architecture, c); ```. Prior to this PR this would fail (we only supported constant boundary conditions on auxiliary fields). This PR also ""reduces"" the location at which the boundary condition is applied, so that `ReducedField`s might use something like. ```julia; r_surface(x) = cos(pi * x); r_bcs = FieldBoundaryConditions(grid, (Center, Nothing, Center), top = ValueBoundaryCondition(r_surface)); r = ReducedField(Center, Nothing, Center, grid, r_bcs); fill_halo_regions!(r.architecture, r); ```. if we eventually set the location of fields in `Flat` dimensions to `Nothing` this will also have an impact on syntax used for building models. This PR needs a test or two before merging. cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1859
https://github.com/CliMA/Oceananigans.jl/pull/1859:814,Energy Efficiency,Reduce,ReducedField,814,"This PR makes a few small changes needed to use ContinuousBoundaryFunction with auxiliary fields, which have no notion of ""time"" or other model fields. For this case; we want to be able to write something like. ```julia; c_surface(x, y) = cos(pi * x); c_bcs = FieldBoundaryConditions(grid, (Center, Center, Center), top = ValueBoundaryCondition(c_surface)); c = CenterField(grid, c_bcs); fill_halo_regions!(c.architecture, c); ```. Prior to this PR this would fail (we only supported constant boundary conditions on auxiliary fields). This PR also ""reduces"" the location at which the boundary condition is applied, so that `ReducedField`s might use something like. ```julia; r_surface(x) = cos(pi * x); r_bcs = FieldBoundaryConditions(grid, (Center, Nothing, Center), top = ValueBoundaryCondition(r_surface)); r = ReducedField(Center, Nothing, Center, grid, r_bcs); fill_halo_regions!(r.architecture, r); ```. if we eventually set the location of fields in `Flat` dimensions to `Nothing` this will also have an impact on syntax used for building models. This PR needs a test or two before merging. cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1859
https://github.com/CliMA/Oceananigans.jl/pull/1859:1070,Testability,test,test,1070,"This PR makes a few small changes needed to use ContinuousBoundaryFunction with auxiliary fields, which have no notion of ""time"" or other model fields. For this case; we want to be able to write something like. ```julia; c_surface(x, y) = cos(pi * x); c_bcs = FieldBoundaryConditions(grid, (Center, Center, Center), top = ValueBoundaryCondition(c_surface)); c = CenterField(grid, c_bcs); fill_halo_regions!(c.architecture, c); ```. Prior to this PR this would fail (we only supported constant boundary conditions on auxiliary fields). This PR also ""reduces"" the location at which the boundary condition is applied, so that `ReducedField`s might use something like. ```julia; r_surface(x) = cos(pi * x); r_bcs = FieldBoundaryConditions(grid, (Center, Nothing, Center), top = ValueBoundaryCondition(r_surface)); r = ReducedField(Center, Nothing, Center, grid, r_bcs); fill_halo_regions!(r.architecture, r); ```. if we eventually set the location of fields in `Flat` dimensions to `Nothing` this will also have an impact on syntax used for building models. This PR needs a test or two before merging. cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1859
https://github.com/CliMA/Oceananigans.jl/pull/1860:787,Integrability,depend,depending,787,"This PR implements support for specifying non-zero fluxes across immersed boundaries via `FluxBoundaryCondition`. Currently, immersed boundaries are insulating (no flux / free-slip) via these pieces of code:. ```julia; # Calculate the (1, 1) component of the viscous flux tensor on a grid with an immersed boundary; @inline _viscous_flux_ux(i, j, k, ibg::GFIBG, args...) = conditional_flux_ccc(i, j, k, ibg, viscous_flux_ux, args...). # Return zero if solid or the viscous flux if fluid:; @inline conditional_flux_ccc(i, j, k, ibg::IBG{FT}, flux, args...) where FT = ifelse(solid_node(c, c, c, i, j, k, ibg), zero(FT), flux(i, j, k, ibg, args...)); ```. The implementation in this PR changes this code to:. 1. Calculate the immersed flux; 2. Compute the boundary normal (either +1 or -1 depending on the orientation of the immersed boundary); 3. If on a node that's a boundary between solid and fluid, insert the calculated immersed flux rather than the ""intrinsic"" viscous flux. It's a WIP, but opening now to get CI. cc @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1860
https://github.com/CliMA/Oceananigans.jl/issues/1861:3537,Deployability,update,update,3537,"096) │ 8 │ 2.178 s │ 2.198 s │ 2.218 s │ 2.280 s │ 17.82 MiB │ 987092 │ 3 │; │ (8192, 8192) │ 16 │ 2.201 s │ 2.218 s │ 2.216 s │ 2.230 s │ 18.33 MiB │ 922426 │ 3 │; │ (8192, 16384) │ 32 │ 2.598 s │ 2.615 s │ 2.615 s │ 2.632 s │ 24.29 MiB │ 1116849 │ 2 │; └───────────────┴─────────┴─────────┴─────────┴─────────┴─────────┴───────────┴─────────┴─────────┘. Shallow water model weak multithreading scaling speedup; ┌───────────────┬─────────┬──────────┬────────────┬─────────┬─────────┐; │ size │ threads │ slowdown │ efficiency │ memory │ allocs │; ├───────────────┼─────────┼──────────┼────────────┼─────────┼─────────┤; │ (8192, 512) │ 1 │ 1.0 │ 1.0 │ 1.0 │ 1.0 │; │ (8192, 1024) │ 2 │ 2.01669 │ 0.495862 │ 15.7412 │ 562.205 │; │ (8192, 2048) │ 4 │ 1.45397 │ 0.687771 │ 11.9861 │ 406.533 │; │ (8192, 4096) │ 8 │ 1.51106 │ 0.661786 │ 13.0337 │ 425.838 │; │ (8192, 8192) │ 16 │ 1.52536 │ 0.655582 │ 13.4078 │ 397.94 │; │ (8192, 16384) │ 32 │ 1.79793 │ 0.556195 │ 17.7701 │ 481.816 │; └───────────────┴─────────┴──────────┴────────────┴─────────┴─────────┘. ```; They're not terrific, but they're decent. I am running these on 32 CPUs, so what I assume is 1 thread per CPU up to 32 threads. The slight increase in efficiency going from 2 to 4 threads is likely some flat overhead being overcome by actual efficiency increase of multithreading. ; @christophernhill @glwagner is there anything we can do to improve multithreading efficiency for Oceananigans? It might not be as simple as adding `@threads` in front of the main for loops but with just a little bit of improvement then multithreading efficiency might just match MPI efficiency.; As it is, multithreading is already a worthwhile option to achieve speedups on systems with multiple CPUs but no MPI. So far I've only run the scripts on one node up to 32 threads and CPUs. I'll update this issue with the result of running it on multiple nodes going up to 64 or maybe 128 CPUs just to see if efficiency is affected going from one node to more.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861
https://github.com/CliMA/Oceananigans.jl/issues/1861:20,Testability,benchmark,benchmarks,20,"I recently ran some benchmarks on threading for Oceananigans based on scripts added by @francispoulin in an older branch.; https://github.com/CliMA/Oceananigans.jl/blob/fjp/multithreaded-benchmarks/benchmark/weak_scaling_shallow_water_model_threaded.jl; https://github.com/CliMA/Oceananigans.jl/blob/fjp/multithreaded-benchmarks/benchmark/weak_scaling_shallow_water_model_serial.jl; Besides the benchmark scripts themselves, everything else was up to date with the latest version of master. Here are the results:; ```; Oceananigans v0.58.8; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Platinum 8260 CPU @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model weak scaling with multithreading benchmark; ┌───────────────┬─────────┬─────────┬─────────┬─────────┬─────────┬───────────┬─────────┬─────────┐; │ size │ threads │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼─────────┼─────────┤; │ (8192, 512) │ 1 │ 1.453 s │ 1.454 s │ 1.454 s │ 1.456 s │ 1.37 MiB │ 2318 │ 4 │; │ (8192, 1024) │ 2 │ 2.909 s │ 2.933 s │ 2.933 s │ 2.956 s │ 21.52 MiB │ 1303192 │ 2 │; │ (8192, 2048) │ 4 │ 2.096 s │ 2.115 s │ 2.125 s │ 2.165 s │ 16.38 MiB │ 942343 │ 3 │; │ (8192, 4096) │ 8 │ 2.178 s │ 2.198 s │ 2.218 s │ 2.280 s │ 17.82 MiB │ 987092 │ 3 │; │ (8192, 8192) │ 16 │ 2.201 s │ 2.218 s │ 2.216 s │ 2.230 s │ 18.33 MiB │ 922426 │ 3 │; │ (8192, 16384) │ 32 │ 2.598 s │ 2.615 s │ 2.615 s │ 2.632 s │ 24.29 MiB │ 1116849 │ 2 │; └───────────────┴─────────┴─────────┴───────",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861
https://github.com/CliMA/Oceananigans.jl/issues/1861:187,Testability,benchmark,benchmarks,187,"I recently ran some benchmarks on threading for Oceananigans based on scripts added by @francispoulin in an older branch.; https://github.com/CliMA/Oceananigans.jl/blob/fjp/multithreaded-benchmarks/benchmark/weak_scaling_shallow_water_model_threaded.jl; https://github.com/CliMA/Oceananigans.jl/blob/fjp/multithreaded-benchmarks/benchmark/weak_scaling_shallow_water_model_serial.jl; Besides the benchmark scripts themselves, everything else was up to date with the latest version of master. Here are the results:; ```; Oceananigans v0.58.8; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Platinum 8260 CPU @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model weak scaling with multithreading benchmark; ┌───────────────┬─────────┬─────────┬─────────┬─────────┬─────────┬───────────┬─────────┬─────────┐; │ size │ threads │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼─────────┼─────────┤; │ (8192, 512) │ 1 │ 1.453 s │ 1.454 s │ 1.454 s │ 1.456 s │ 1.37 MiB │ 2318 │ 4 │; │ (8192, 1024) │ 2 │ 2.909 s │ 2.933 s │ 2.933 s │ 2.956 s │ 21.52 MiB │ 1303192 │ 2 │; │ (8192, 2048) │ 4 │ 2.096 s │ 2.115 s │ 2.125 s │ 2.165 s │ 16.38 MiB │ 942343 │ 3 │; │ (8192, 4096) │ 8 │ 2.178 s │ 2.198 s │ 2.218 s │ 2.280 s │ 17.82 MiB │ 987092 │ 3 │; │ (8192, 8192) │ 16 │ 2.201 s │ 2.218 s │ 2.216 s │ 2.230 s │ 18.33 MiB │ 922426 │ 3 │; │ (8192, 16384) │ 32 │ 2.598 s │ 2.615 s │ 2.615 s │ 2.632 s │ 24.29 MiB │ 1116849 │ 2 │; └───────────────┴─────────┴─────────┴───────",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861
https://github.com/CliMA/Oceananigans.jl/issues/1861:198,Testability,benchmark,benchmark,198,"I recently ran some benchmarks on threading for Oceananigans based on scripts added by @francispoulin in an older branch.; https://github.com/CliMA/Oceananigans.jl/blob/fjp/multithreaded-benchmarks/benchmark/weak_scaling_shallow_water_model_threaded.jl; https://github.com/CliMA/Oceananigans.jl/blob/fjp/multithreaded-benchmarks/benchmark/weak_scaling_shallow_water_model_serial.jl; Besides the benchmark scripts themselves, everything else was up to date with the latest version of master. Here are the results:; ```; Oceananigans v0.58.8; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Platinum 8260 CPU @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model weak scaling with multithreading benchmark; ┌───────────────┬─────────┬─────────┬─────────┬─────────┬─────────┬───────────┬─────────┬─────────┐; │ size │ threads │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼─────────┼─────────┤; │ (8192, 512) │ 1 │ 1.453 s │ 1.454 s │ 1.454 s │ 1.456 s │ 1.37 MiB │ 2318 │ 4 │; │ (8192, 1024) │ 2 │ 2.909 s │ 2.933 s │ 2.933 s │ 2.956 s │ 21.52 MiB │ 1303192 │ 2 │; │ (8192, 2048) │ 4 │ 2.096 s │ 2.115 s │ 2.125 s │ 2.165 s │ 16.38 MiB │ 942343 │ 3 │; │ (8192, 4096) │ 8 │ 2.178 s │ 2.198 s │ 2.218 s │ 2.280 s │ 17.82 MiB │ 987092 │ 3 │; │ (8192, 8192) │ 16 │ 2.201 s │ 2.218 s │ 2.216 s │ 2.230 s │ 18.33 MiB │ 922426 │ 3 │; │ (8192, 16384) │ 32 │ 2.598 s │ 2.615 s │ 2.615 s │ 2.632 s │ 24.29 MiB │ 1116849 │ 2 │; └───────────────┴─────────┴─────────┴───────",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861
https://github.com/CliMA/Oceananigans.jl/issues/1861:318,Testability,benchmark,benchmarks,318,"I recently ran some benchmarks on threading for Oceananigans based on scripts added by @francispoulin in an older branch.; https://github.com/CliMA/Oceananigans.jl/blob/fjp/multithreaded-benchmarks/benchmark/weak_scaling_shallow_water_model_threaded.jl; https://github.com/CliMA/Oceananigans.jl/blob/fjp/multithreaded-benchmarks/benchmark/weak_scaling_shallow_water_model_serial.jl; Besides the benchmark scripts themselves, everything else was up to date with the latest version of master. Here are the results:; ```; Oceananigans v0.58.8; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Platinum 8260 CPU @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model weak scaling with multithreading benchmark; ┌───────────────┬─────────┬─────────┬─────────┬─────────┬─────────┬───────────┬─────────┬─────────┐; │ size │ threads │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼─────────┼─────────┤; │ (8192, 512) │ 1 │ 1.453 s │ 1.454 s │ 1.454 s │ 1.456 s │ 1.37 MiB │ 2318 │ 4 │; │ (8192, 1024) │ 2 │ 2.909 s │ 2.933 s │ 2.933 s │ 2.956 s │ 21.52 MiB │ 1303192 │ 2 │; │ (8192, 2048) │ 4 │ 2.096 s │ 2.115 s │ 2.125 s │ 2.165 s │ 16.38 MiB │ 942343 │ 3 │; │ (8192, 4096) │ 8 │ 2.178 s │ 2.198 s │ 2.218 s │ 2.280 s │ 17.82 MiB │ 987092 │ 3 │; │ (8192, 8192) │ 16 │ 2.201 s │ 2.218 s │ 2.216 s │ 2.230 s │ 18.33 MiB │ 922426 │ 3 │; │ (8192, 16384) │ 32 │ 2.598 s │ 2.615 s │ 2.615 s │ 2.632 s │ 24.29 MiB │ 1116849 │ 2 │; └───────────────┴─────────┴─────────┴───────",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861
https://github.com/CliMA/Oceananigans.jl/issues/1861:329,Testability,benchmark,benchmark,329,"I recently ran some benchmarks on threading for Oceananigans based on scripts added by @francispoulin in an older branch.; https://github.com/CliMA/Oceananigans.jl/blob/fjp/multithreaded-benchmarks/benchmark/weak_scaling_shallow_water_model_threaded.jl; https://github.com/CliMA/Oceananigans.jl/blob/fjp/multithreaded-benchmarks/benchmark/weak_scaling_shallow_water_model_serial.jl; Besides the benchmark scripts themselves, everything else was up to date with the latest version of master. Here are the results:; ```; Oceananigans v0.58.8; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Platinum 8260 CPU @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model weak scaling with multithreading benchmark; ┌───────────────┬─────────┬─────────┬─────────┬─────────┬─────────┬───────────┬─────────┬─────────┐; │ size │ threads │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼─────────┼─────────┤; │ (8192, 512) │ 1 │ 1.453 s │ 1.454 s │ 1.454 s │ 1.456 s │ 1.37 MiB │ 2318 │ 4 │; │ (8192, 1024) │ 2 │ 2.909 s │ 2.933 s │ 2.933 s │ 2.956 s │ 21.52 MiB │ 1303192 │ 2 │; │ (8192, 2048) │ 4 │ 2.096 s │ 2.115 s │ 2.125 s │ 2.165 s │ 16.38 MiB │ 942343 │ 3 │; │ (8192, 4096) │ 8 │ 2.178 s │ 2.198 s │ 2.218 s │ 2.280 s │ 17.82 MiB │ 987092 │ 3 │; │ (8192, 8192) │ 16 │ 2.201 s │ 2.218 s │ 2.216 s │ 2.230 s │ 18.33 MiB │ 922426 │ 3 │; │ (8192, 16384) │ 32 │ 2.598 s │ 2.615 s │ 2.615 s │ 2.632 s │ 24.29 MiB │ 1116849 │ 2 │; └───────────────┴─────────┴─────────┴───────",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861
https://github.com/CliMA/Oceananigans.jl/issues/1861:395,Testability,benchmark,benchmark,395,"I recently ran some benchmarks on threading for Oceananigans based on scripts added by @francispoulin in an older branch.; https://github.com/CliMA/Oceananigans.jl/blob/fjp/multithreaded-benchmarks/benchmark/weak_scaling_shallow_water_model_threaded.jl; https://github.com/CliMA/Oceananigans.jl/blob/fjp/multithreaded-benchmarks/benchmark/weak_scaling_shallow_water_model_serial.jl; Besides the benchmark scripts themselves, everything else was up to date with the latest version of master. Here are the results:; ```; Oceananigans v0.58.8; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Platinum 8260 CPU @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model weak scaling with multithreading benchmark; ┌───────────────┬─────────┬─────────┬─────────┬─────────┬─────────┬───────────┬─────────┬─────────┐; │ size │ threads │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼─────────┼─────────┤; │ (8192, 512) │ 1 │ 1.453 s │ 1.454 s │ 1.454 s │ 1.456 s │ 1.37 MiB │ 2318 │ 4 │; │ (8192, 1024) │ 2 │ 2.909 s │ 2.933 s │ 2.933 s │ 2.956 s │ 21.52 MiB │ 1303192 │ 2 │; │ (8192, 2048) │ 4 │ 2.096 s │ 2.115 s │ 2.125 s │ 2.165 s │ 16.38 MiB │ 942343 │ 3 │; │ (8192, 4096) │ 8 │ 2.178 s │ 2.198 s │ 2.218 s │ 2.280 s │ 17.82 MiB │ 987092 │ 3 │; │ (8192, 8192) │ 16 │ 2.201 s │ 2.218 s │ 2.216 s │ 2.230 s │ 18.33 MiB │ 922426 │ 3 │; │ (8192, 16384) │ 32 │ 2.598 s │ 2.615 s │ 2.615 s │ 2.632 s │ 24.29 MiB │ 1116849 │ 2 │; └───────────────┴─────────┴─────────┴───────",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861
https://github.com/CliMA/Oceananigans.jl/issues/1861:1145,Testability,benchmark,benchmark,1145,"CliMA/Oceananigans.jl/blob/fjp/multithreaded-benchmarks/benchmark/weak_scaling_shallow_water_model_serial.jl; Besides the benchmark scripts themselves, everything else was up to date with the latest version of master. Here are the results:; ```; Oceananigans v0.58.8; Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Platinum 8260 CPU @ 2.40GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); Environment:; EBVERSIONJULIA = 1.6.1; JULIA_DEPOT_PATH = :; EBROOTJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1; EBDEVELJULIA = /cvmfs/soft.computecanada.ca/easybuild/software/2020/avx2/Core/julia/1.6.1/easybuild/avx2-Core-julia-1.6.1-easybuild-devel; JULIA_LOAD_PATH = :. Shallow water model weak scaling with multithreading benchmark; ┌───────────────┬─────────┬─────────┬─────────┬─────────┬─────────┬───────────┬─────────┬─────────┐; │ size │ threads │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼─────────┼─────────┼─────────┼─────────┼─────────┼───────────┼─────────┼─────────┤; │ (8192, 512) │ 1 │ 1.453 s │ 1.454 s │ 1.454 s │ 1.456 s │ 1.37 MiB │ 2318 │ 4 │; │ (8192, 1024) │ 2 │ 2.909 s │ 2.933 s │ 2.933 s │ 2.956 s │ 21.52 MiB │ 1303192 │ 2 │; │ (8192, 2048) │ 4 │ 2.096 s │ 2.115 s │ 2.125 s │ 2.165 s │ 16.38 MiB │ 942343 │ 3 │; │ (8192, 4096) │ 8 │ 2.178 s │ 2.198 s │ 2.218 s │ 2.280 s │ 17.82 MiB │ 987092 │ 3 │; │ (8192, 8192) │ 16 │ 2.201 s │ 2.218 s │ 2.216 s │ 2.230 s │ 18.33 MiB │ 922426 │ 3 │; │ (8192, 16384) │ 32 │ 2.598 s │ 2.615 s │ 2.615 s │ 2.632 s │ 24.29 MiB │ 1116849 │ 2 │; └───────────────┴─────────┴─────────┴─────────┴─────────┴─────────┴───────────┴─────────┴─────────┘. Shallow water model weak multithreading scaling speedup; ┌───────────────┬─────────┬──────────┬────────────┬─────────┬─────────┐; │ size │ threads │ slowdown │ efficiency │ memory │ allocs │; ├───────────────┼───────",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861
https://github.com/CliMA/Oceananigans.jl/issues/1861:3176,Usability,simpl,simple,3176,"096) │ 8 │ 2.178 s │ 2.198 s │ 2.218 s │ 2.280 s │ 17.82 MiB │ 987092 │ 3 │; │ (8192, 8192) │ 16 │ 2.201 s │ 2.218 s │ 2.216 s │ 2.230 s │ 18.33 MiB │ 922426 │ 3 │; │ (8192, 16384) │ 32 │ 2.598 s │ 2.615 s │ 2.615 s │ 2.632 s │ 24.29 MiB │ 1116849 │ 2 │; └───────────────┴─────────┴─────────┴─────────┴─────────┴─────────┴───────────┴─────────┴─────────┘. Shallow water model weak multithreading scaling speedup; ┌───────────────┬─────────┬──────────┬────────────┬─────────┬─────────┐; │ size │ threads │ slowdown │ efficiency │ memory │ allocs │; ├───────────────┼─────────┼──────────┼────────────┼─────────┼─────────┤; │ (8192, 512) │ 1 │ 1.0 │ 1.0 │ 1.0 │ 1.0 │; │ (8192, 1024) │ 2 │ 2.01669 │ 0.495862 │ 15.7412 │ 562.205 │; │ (8192, 2048) │ 4 │ 1.45397 │ 0.687771 │ 11.9861 │ 406.533 │; │ (8192, 4096) │ 8 │ 1.51106 │ 0.661786 │ 13.0337 │ 425.838 │; │ (8192, 8192) │ 16 │ 1.52536 │ 0.655582 │ 13.4078 │ 397.94 │; │ (8192, 16384) │ 32 │ 1.79793 │ 0.556195 │ 17.7701 │ 481.816 │; └───────────────┴─────────┴──────────┴────────────┴─────────┴─────────┘. ```; They're not terrific, but they're decent. I am running these on 32 CPUs, so what I assume is 1 thread per CPU up to 32 threads. The slight increase in efficiency going from 2 to 4 threads is likely some flat overhead being overcome by actual efficiency increase of multithreading. ; @christophernhill @glwagner is there anything we can do to improve multithreading efficiency for Oceananigans? It might not be as simple as adding `@threads` in front of the main for loops but with just a little bit of improvement then multithreading efficiency might just match MPI efficiency.; As it is, multithreading is already a worthwhile option to achieve speedups on systems with multiple CPUs but no MPI. So far I've only run the scripts on one node up to 32 threads and CPUs. I'll update this issue with the result of running it on multiple nodes going up to 64 or maybe 128 CPUs just to see if efficiency is affected going from one node to more.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861
https://github.com/CliMA/Oceananigans.jl/issues/1862:463,Deployability,configurat,configurations,463,"Adding this before I forget. It could be useful to have builtin support for getting wall clock time spent in key ""blocks"" of code during any; simulation. . For example knowing how long is spent in iterative solver, how long in I/O, how long in time stepping, how long in initialization, how long in dynamics computations, how long in tracer computations, how long in communication etc.. can be a useful check and help see what is requiring resources in different configurations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862
https://github.com/CliMA/Oceananigans.jl/issues/1862:463,Modifiability,config,configurations,463,"Adding this before I forget. It could be useful to have builtin support for getting wall clock time spent in key ""blocks"" of code during any; simulation. . For example knowing how long is spent in iterative solver, how long in I/O, how long in time stepping, how long in initialization, how long in dynamics computations, how long in tracer computations, how long in communication etc.. can be a useful check and help see what is requiring resources in different configurations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862
https://github.com/CliMA/Oceananigans.jl/pull/1865:52,Testability,test,tests,52,"This PR implements seven new internal wave dynamics tests that run for both `IncompressibleModel` and `HydrostaticFreeSurfaceModel`, on vertically-stretched grids, and on `Flat` topologies for both models and both regular and stretched grids. The tests show that `VerticallyStretchedRectilinearGrid` does not work with `Flat` dimensions. For `IncompressibleModel`, this usage produces a warning that ""`FourierTridiagonalPoissonSolver` is probably not correct."" Ironically, it's this warning thats _probably_ not correct: the issue with `Flat` and vertically-stretched grids appears to lie in the lack of flat grid metrics for any grid but `RegularRectilinearGrid` --- not the Poisson solver. We can fix this problem in this PR. In that case it will resolve #1849.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865
https://github.com/CliMA/Oceananigans.jl/pull/1865:247,Testability,test,tests,247,"This PR implements seven new internal wave dynamics tests that run for both `IncompressibleModel` and `HydrostaticFreeSurfaceModel`, on vertically-stretched grids, and on `Flat` topologies for both models and both regular and stretched grids. The tests show that `VerticallyStretchedRectilinearGrid` does not work with `Flat` dimensions. For `IncompressibleModel`, this usage produces a warning that ""`FourierTridiagonalPoissonSolver` is probably not correct."" Ironically, it's this warning thats _probably_ not correct: the issue with `Flat` and vertically-stretched grids appears to lie in the lack of flat grid metrics for any grid but `RegularRectilinearGrid` --- not the Poisson solver. We can fix this problem in this PR. In that case it will resolve #1849.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1865
https://github.com/CliMA/Oceananigans.jl/issues/1867:19,Testability,test,tests,19,"The poisson solver tests have a mysterious property:. https://github.com/CliMA/Oceananigans.jl/blob/5fbd8cd20c5db8e9b11b6175984e7592a08fc874/test/test_poisson_solvers.jl#L17-L20. whereby `CenterField` is used for `Ru`, `Rv`, and `Rw` --- fields that should be located on faces, and have boundary conditions appropriate for velocity fields. When these fields are merely relocated to the correct location, the tests fail. Since by all accounts the Poisson solver is correct, there is probably something wrong with the tests. But we can't really be sure about either while the tests contain an obvious inconsistency. We should probably fix these tests. @ali-ramadhan, do you remember why we use `CenterField` for `Ru`, `Rv`, and `Rw`? The code was added in this PR: https://github.com/CliMA/Oceananigans.jl/pull/834/.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1867
https://github.com/CliMA/Oceananigans.jl/issues/1867:141,Testability,test,test,141,"The poisson solver tests have a mysterious property:. https://github.com/CliMA/Oceananigans.jl/blob/5fbd8cd20c5db8e9b11b6175984e7592a08fc874/test/test_poisson_solvers.jl#L17-L20. whereby `CenterField` is used for `Ru`, `Rv`, and `Rw` --- fields that should be located on faces, and have boundary conditions appropriate for velocity fields. When these fields are merely relocated to the correct location, the tests fail. Since by all accounts the Poisson solver is correct, there is probably something wrong with the tests. But we can't really be sure about either while the tests contain an obvious inconsistency. We should probably fix these tests. @ali-ramadhan, do you remember why we use `CenterField` for `Ru`, `Rv`, and `Rw`? The code was added in this PR: https://github.com/CliMA/Oceananigans.jl/pull/834/.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1867
https://github.com/CliMA/Oceananigans.jl/issues/1867:408,Testability,test,tests,408,"The poisson solver tests have a mysterious property:. https://github.com/CliMA/Oceananigans.jl/blob/5fbd8cd20c5db8e9b11b6175984e7592a08fc874/test/test_poisson_solvers.jl#L17-L20. whereby `CenterField` is used for `Ru`, `Rv`, and `Rw` --- fields that should be located on faces, and have boundary conditions appropriate for velocity fields. When these fields are merely relocated to the correct location, the tests fail. Since by all accounts the Poisson solver is correct, there is probably something wrong with the tests. But we can't really be sure about either while the tests contain an obvious inconsistency. We should probably fix these tests. @ali-ramadhan, do you remember why we use `CenterField` for `Ru`, `Rv`, and `Rw`? The code was added in this PR: https://github.com/CliMA/Oceananigans.jl/pull/834/.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1867
https://github.com/CliMA/Oceananigans.jl/issues/1867:516,Testability,test,tests,516,"The poisson solver tests have a mysterious property:. https://github.com/CliMA/Oceananigans.jl/blob/5fbd8cd20c5db8e9b11b6175984e7592a08fc874/test/test_poisson_solvers.jl#L17-L20. whereby `CenterField` is used for `Ru`, `Rv`, and `Rw` --- fields that should be located on faces, and have boundary conditions appropriate for velocity fields. When these fields are merely relocated to the correct location, the tests fail. Since by all accounts the Poisson solver is correct, there is probably something wrong with the tests. But we can't really be sure about either while the tests contain an obvious inconsistency. We should probably fix these tests. @ali-ramadhan, do you remember why we use `CenterField` for `Ru`, `Rv`, and `Rw`? The code was added in this PR: https://github.com/CliMA/Oceananigans.jl/pull/834/.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1867
https://github.com/CliMA/Oceananigans.jl/issues/1867:574,Testability,test,tests,574,"The poisson solver tests have a mysterious property:. https://github.com/CliMA/Oceananigans.jl/blob/5fbd8cd20c5db8e9b11b6175984e7592a08fc874/test/test_poisson_solvers.jl#L17-L20. whereby `CenterField` is used for `Ru`, `Rv`, and `Rw` --- fields that should be located on faces, and have boundary conditions appropriate for velocity fields. When these fields are merely relocated to the correct location, the tests fail. Since by all accounts the Poisson solver is correct, there is probably something wrong with the tests. But we can't really be sure about either while the tests contain an obvious inconsistency. We should probably fix these tests. @ali-ramadhan, do you remember why we use `CenterField` for `Ru`, `Rv`, and `Rw`? The code was added in this PR: https://github.com/CliMA/Oceananigans.jl/pull/834/.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1867
https://github.com/CliMA/Oceananigans.jl/issues/1867:643,Testability,test,tests,643,"The poisson solver tests have a mysterious property:. https://github.com/CliMA/Oceananigans.jl/blob/5fbd8cd20c5db8e9b11b6175984e7592a08fc874/test/test_poisson_solvers.jl#L17-L20. whereby `CenterField` is used for `Ru`, `Rv`, and `Rw` --- fields that should be located on faces, and have boundary conditions appropriate for velocity fields. When these fields are merely relocated to the correct location, the tests fail. Since by all accounts the Poisson solver is correct, there is probably something wrong with the tests. But we can't really be sure about either while the tests contain an obvious inconsistency. We should probably fix these tests. @ali-ramadhan, do you remember why we use `CenterField` for `Ru`, `Rv`, and `Rw`? The code was added in this PR: https://github.com/CliMA/Oceananigans.jl/pull/834/.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1867
https://github.com/CliMA/Oceananigans.jl/pull/1869:174,Integrability,interface,interface,174,"This PR refactors the Poisson solvers so that:. 1. All our solvers (FFT-based, mixed FFT / tridiagonal, tridiagonal, and preconditioned conjugate gradient) have a consistent interface that's reminiscent of linear algebra solvers, eg we use the syntax. ```julia; solve!(x, solver, b); ```. which solves `A*x = b` for `x`, where `A` is described by `solver`. This resembles the syntax `ldiv!(x, A, b)` implemented by `LinearAlgebra.jl`. One exception is the mixed FFT / tridiagonal solver, which also permits `solve!(x, solver)` as an optimization. This extension is used because the ""source term"" is represented differently (eg in a way that depends on the vertical grid spacing) than the other Poisson solvers. The mixed solver also accepts `solve!(x, solver, b)` like the others; this will launch an extra kernel to copy and scale `b` appropriately. 2. The FFT-based solver supports the ""screened"" Poisson equation. ```; (∇² + m) ϕ = b; ```. via `solve!(x, solver, b, m)`, where `m` is a _constant_. This will allow us to solve the elliptic equation posed by an implicit time discretization of the free surface evolution equation. Todo:. - [x] Implement an FFT-based solver for the implicit free surface; - [x] Test demonstrating that the preconditioned conjugate gradient solver and FFT-based solver get the same answer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1869
https://github.com/CliMA/Oceananigans.jl/pull/1869:641,Integrability,depend,depends,641,"This PR refactors the Poisson solvers so that:. 1. All our solvers (FFT-based, mixed FFT / tridiagonal, tridiagonal, and preconditioned conjugate gradient) have a consistent interface that's reminiscent of linear algebra solvers, eg we use the syntax. ```julia; solve!(x, solver, b); ```. which solves `A*x = b` for `x`, where `A` is described by `solver`. This resembles the syntax `ldiv!(x, A, b)` implemented by `LinearAlgebra.jl`. One exception is the mixed FFT / tridiagonal solver, which also permits `solve!(x, solver)` as an optimization. This extension is used because the ""source term"" is represented differently (eg in a way that depends on the vertical grid spacing) than the other Poisson solvers. The mixed solver also accepts `solve!(x, solver, b)` like the others; this will launch an extra kernel to copy and scale `b` appropriately. 2. The FFT-based solver supports the ""screened"" Poisson equation. ```; (∇² + m) ϕ = b; ```. via `solve!(x, solver, b, m)`, where `m` is a _constant_. This will allow us to solve the elliptic equation posed by an implicit time discretization of the free surface evolution equation. Todo:. - [x] Implement an FFT-based solver for the implicit free surface; - [x] Test demonstrating that the preconditioned conjugate gradient solver and FFT-based solver get the same answer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1869
https://github.com/CliMA/Oceananigans.jl/pull/1869:8,Modifiability,refactor,refactors,8,"This PR refactors the Poisson solvers so that:. 1. All our solvers (FFT-based, mixed FFT / tridiagonal, tridiagonal, and preconditioned conjugate gradient) have a consistent interface that's reminiscent of linear algebra solvers, eg we use the syntax. ```julia; solve!(x, solver, b); ```. which solves `A*x = b` for `x`, where `A` is described by `solver`. This resembles the syntax `ldiv!(x, A, b)` implemented by `LinearAlgebra.jl`. One exception is the mixed FFT / tridiagonal solver, which also permits `solve!(x, solver)` as an optimization. This extension is used because the ""source term"" is represented differently (eg in a way that depends on the vertical grid spacing) than the other Poisson solvers. The mixed solver also accepts `solve!(x, solver, b)` like the others; this will launch an extra kernel to copy and scale `b` appropriately. 2. The FFT-based solver supports the ""screened"" Poisson equation. ```; (∇² + m) ϕ = b; ```. via `solve!(x, solver, b, m)`, where `m` is a _constant_. This will allow us to solve the elliptic equation posed by an implicit time discretization of the free surface evolution equation. Todo:. - [x] Implement an FFT-based solver for the implicit free surface; - [x] Test demonstrating that the preconditioned conjugate gradient solver and FFT-based solver get the same answer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1869
https://github.com/CliMA/Oceananigans.jl/pull/1869:533,Performance,optimiz,optimization,533,"This PR refactors the Poisson solvers so that:. 1. All our solvers (FFT-based, mixed FFT / tridiagonal, tridiagonal, and preconditioned conjugate gradient) have a consistent interface that's reminiscent of linear algebra solvers, eg we use the syntax. ```julia; solve!(x, solver, b); ```. which solves `A*x = b` for `x`, where `A` is described by `solver`. This resembles the syntax `ldiv!(x, A, b)` implemented by `LinearAlgebra.jl`. One exception is the mixed FFT / tridiagonal solver, which also permits `solve!(x, solver)` as an optimization. This extension is used because the ""source term"" is represented differently (eg in a way that depends on the vertical grid spacing) than the other Poisson solvers. The mixed solver also accepts `solve!(x, solver, b)` like the others; this will launch an extra kernel to copy and scale `b` appropriately. 2. The FFT-based solver supports the ""screened"" Poisson equation. ```; (∇² + m) ϕ = b; ```. via `solve!(x, solver, b, m)`, where `m` is a _constant_. This will allow us to solve the elliptic equation posed by an implicit time discretization of the free surface evolution equation. Todo:. - [x] Implement an FFT-based solver for the implicit free surface; - [x] Test demonstrating that the preconditioned conjugate gradient solver and FFT-based solver get the same answer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1869
https://github.com/CliMA/Oceananigans.jl/pull/1869:1212,Testability,Test,Test,1212,"This PR refactors the Poisson solvers so that:. 1. All our solvers (FFT-based, mixed FFT / tridiagonal, tridiagonal, and preconditioned conjugate gradient) have a consistent interface that's reminiscent of linear algebra solvers, eg we use the syntax. ```julia; solve!(x, solver, b); ```. which solves `A*x = b` for `x`, where `A` is described by `solver`. This resembles the syntax `ldiv!(x, A, b)` implemented by `LinearAlgebra.jl`. One exception is the mixed FFT / tridiagonal solver, which also permits `solve!(x, solver)` as an optimization. This extension is used because the ""source term"" is represented differently (eg in a way that depends on the vertical grid spacing) than the other Poisson solvers. The mixed solver also accepts `solve!(x, solver, b)` like the others; this will launch an extra kernel to copy and scale `b` appropriately. 2. The FFT-based solver supports the ""screened"" Poisson equation. ```; (∇² + m) ϕ = b; ```. via `solve!(x, solver, b, m)`, where `m` is a _constant_. This will allow us to solve the elliptic equation posed by an implicit time discretization of the free surface evolution equation. Todo:. - [x] Implement an FFT-based solver for the implicit free surface; - [x] Test demonstrating that the preconditioned conjugate gradient solver and FFT-based solver get the same answer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1869
https://github.com/CliMA/Oceananigans.jl/issues/1871:44,Usability,simpl,simplified,44,"Many of the examples could be shortened and simplified using `FieldTimeSeries` to post-process output. Even though `FieldTimeSeries` is not fully featured yet, it's still better than the many appearances of silly boiler plate like `iterations = parse.(Int, keys(file[""timeseries/t""]))`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1871
https://github.com/CliMA/Oceananigans.jl/issues/1873:672,Integrability,depend,dependencies,672,"Pasted from a slack discussion:. Hi, everyone. Can someone please give me a little push in the right direction? I'm trying to understand the calls to calculate_tracer_diffusivity but I can't make sense of them.; The relevant code is here:. ```julia; function calculate_diffusivities!(K, arch, grid, closure::AnisotropicMinimumDissipation, buoyancy, U, C); workgroup, worksize = work_layout(grid, :xyz); barrier = Event(device(arch)); viscosity_kernel! = calculate_viscosity!(device(arch), workgroup, worksize); diffusivity_kernel! = calculate_tracer_diffusivity!(device(arch), workgroup, worksize); viscosity_event = viscosity_kernel!(K.νₑ, grid, closure, buoyancy, U, C, dependencies=barrier); events = [viscosity_event]; for (tracer_index, κₑ) in enumerate(K.κₑ); @inbounds c = C[tracer_index]; event = diffusivity_kernel!(κₑ, grid, closure, c, Val(tracer_index), U, dependencies=barrier); push!(events, event); end; wait(device(arch), MultiEvent(Tuple(events))); return nothing; end; @kernel function calculate_viscosity!(νₑ, grid, closure::AnisotropicMinimumDissipation, buoyancy, U, C); i, j, k = @index(Global, NTuple); @inbounds νₑ[i, j, k] = νᶜᶜᶜ(i, j, k, grid, closure, buoyancy, U, C); end; @kernel function calculate_tracer_diffusivity!(κₑ, grid, closure, c, tracer_index, U); i, j, k = @index(Global, NTuple); @inbounds κₑ[i, j, k] = κᶜᶜᶜ(i, j, k, grid, closure, c, tracer_index, U); end; ```. So it seems that `calculate_tracer_diffusivity!` is defined with the signature `κₑ, grid, closure, c, tracer_index, U`, but is called with the signature `device(arch), workgroup, worksize`.; I can see that the `diffusivity_kernel!` is somehow what actually performs the ""correct"" signature call in the line `event = diffusivity_kernel!(κₑ, grid, closure, c, Val(tracer_index), U, dependencies=barrier)`, but I honestly can't understand why that's the case or even how that works. Could someone please shed some light?. CC @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1873
https://github.com/CliMA/Oceananigans.jl/issues/1873:869,Integrability,depend,dependencies,869,"Pasted from a slack discussion:. Hi, everyone. Can someone please give me a little push in the right direction? I'm trying to understand the calls to calculate_tracer_diffusivity but I can't make sense of them.; The relevant code is here:. ```julia; function calculate_diffusivities!(K, arch, grid, closure::AnisotropicMinimumDissipation, buoyancy, U, C); workgroup, worksize = work_layout(grid, :xyz); barrier = Event(device(arch)); viscosity_kernel! = calculate_viscosity!(device(arch), workgroup, worksize); diffusivity_kernel! = calculate_tracer_diffusivity!(device(arch), workgroup, worksize); viscosity_event = viscosity_kernel!(K.νₑ, grid, closure, buoyancy, U, C, dependencies=barrier); events = [viscosity_event]; for (tracer_index, κₑ) in enumerate(K.κₑ); @inbounds c = C[tracer_index]; event = diffusivity_kernel!(κₑ, grid, closure, c, Val(tracer_index), U, dependencies=barrier); push!(events, event); end; wait(device(arch), MultiEvent(Tuple(events))); return nothing; end; @kernel function calculate_viscosity!(νₑ, grid, closure::AnisotropicMinimumDissipation, buoyancy, U, C); i, j, k = @index(Global, NTuple); @inbounds νₑ[i, j, k] = νᶜᶜᶜ(i, j, k, grid, closure, buoyancy, U, C); end; @kernel function calculate_tracer_diffusivity!(κₑ, grid, closure, c, tracer_index, U); i, j, k = @index(Global, NTuple); @inbounds κₑ[i, j, k] = κᶜᶜᶜ(i, j, k, grid, closure, c, tracer_index, U); end; ```. So it seems that `calculate_tracer_diffusivity!` is defined with the signature `κₑ, grid, closure, c, tracer_index, U`, but is called with the signature `device(arch), workgroup, worksize`.; I can see that the `diffusivity_kernel!` is somehow what actually performs the ""correct"" signature call in the line `event = diffusivity_kernel!(κₑ, grid, closure, c, Val(tracer_index), U, dependencies=barrier)`, but I honestly can't understand why that's the case or even how that works. Could someone please shed some light?. CC @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1873
https://github.com/CliMA/Oceananigans.jl/issues/1873:1786,Integrability,depend,dependencies,1786,"Pasted from a slack discussion:. Hi, everyone. Can someone please give me a little push in the right direction? I'm trying to understand the calls to calculate_tracer_diffusivity but I can't make sense of them.; The relevant code is here:. ```julia; function calculate_diffusivities!(K, arch, grid, closure::AnisotropicMinimumDissipation, buoyancy, U, C); workgroup, worksize = work_layout(grid, :xyz); barrier = Event(device(arch)); viscosity_kernel! = calculate_viscosity!(device(arch), workgroup, worksize); diffusivity_kernel! = calculate_tracer_diffusivity!(device(arch), workgroup, worksize); viscosity_event = viscosity_kernel!(K.νₑ, grid, closure, buoyancy, U, C, dependencies=barrier); events = [viscosity_event]; for (tracer_index, κₑ) in enumerate(K.κₑ); @inbounds c = C[tracer_index]; event = diffusivity_kernel!(κₑ, grid, closure, c, Val(tracer_index), U, dependencies=barrier); push!(events, event); end; wait(device(arch), MultiEvent(Tuple(events))); return nothing; end; @kernel function calculate_viscosity!(νₑ, grid, closure::AnisotropicMinimumDissipation, buoyancy, U, C); i, j, k = @index(Global, NTuple); @inbounds νₑ[i, j, k] = νᶜᶜᶜ(i, j, k, grid, closure, buoyancy, U, C); end; @kernel function calculate_tracer_diffusivity!(κₑ, grid, closure, c, tracer_index, U); i, j, k = @index(Global, NTuple); @inbounds κₑ[i, j, k] = κᶜᶜᶜ(i, j, k, grid, closure, c, tracer_index, U); end; ```. So it seems that `calculate_tracer_diffusivity!` is defined with the signature `κₑ, grid, closure, c, tracer_index, U`, but is called with the signature `device(arch), workgroup, worksize`.; I can see that the `diffusivity_kernel!` is somehow what actually performs the ""correct"" signature call in the line `event = diffusivity_kernel!(κₑ, grid, closure, c, Val(tracer_index), U, dependencies=barrier)`, but I honestly can't understand why that's the case or even how that works. Could someone please shed some light?. CC @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1873
https://github.com/CliMA/Oceananigans.jl/issues/1873:1663,Performance,perform,performs,1663,"Pasted from a slack discussion:. Hi, everyone. Can someone please give me a little push in the right direction? I'm trying to understand the calls to calculate_tracer_diffusivity but I can't make sense of them.; The relevant code is here:. ```julia; function calculate_diffusivities!(K, arch, grid, closure::AnisotropicMinimumDissipation, buoyancy, U, C); workgroup, worksize = work_layout(grid, :xyz); barrier = Event(device(arch)); viscosity_kernel! = calculate_viscosity!(device(arch), workgroup, worksize); diffusivity_kernel! = calculate_tracer_diffusivity!(device(arch), workgroup, worksize); viscosity_event = viscosity_kernel!(K.νₑ, grid, closure, buoyancy, U, C, dependencies=barrier); events = [viscosity_event]; for (tracer_index, κₑ) in enumerate(K.κₑ); @inbounds c = C[tracer_index]; event = diffusivity_kernel!(κₑ, grid, closure, c, Val(tracer_index), U, dependencies=barrier); push!(events, event); end; wait(device(arch), MultiEvent(Tuple(events))); return nothing; end; @kernel function calculate_viscosity!(νₑ, grid, closure::AnisotropicMinimumDissipation, buoyancy, U, C); i, j, k = @index(Global, NTuple); @inbounds νₑ[i, j, k] = νᶜᶜᶜ(i, j, k, grid, closure, buoyancy, U, C); end; @kernel function calculate_tracer_diffusivity!(κₑ, grid, closure, c, tracer_index, U); i, j, k = @index(Global, NTuple); @inbounds κₑ[i, j, k] = κᶜᶜᶜ(i, j, k, grid, closure, c, tracer_index, U); end; ```. So it seems that `calculate_tracer_diffusivity!` is defined with the signature `κₑ, grid, closure, c, tracer_index, U`, but is called with the signature `device(arch), workgroup, worksize`.; I can see that the `diffusivity_kernel!` is somehow what actually performs the ""correct"" signature call in the line `event = diffusivity_kernel!(κₑ, grid, closure, c, Val(tracer_index), U, dependencies=barrier)`, but I honestly can't understand why that's the case or even how that works. Could someone please shed some light?. CC @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1873
https://github.com/CliMA/Oceananigans.jl/issues/1879:420,Integrability,depend,depends,420,"I couldn't find any page in docs that explains that the models can take a tuple of closures. I guess it should be [here](https://clima.github.io/OceananigansDocumentation/stable/model_setup/turbulent_diffusivity_closures_and_les_models/)?. PS:. - If it's there somewhere and I missed it, please let me know!; - I'm assuming passing a tuple as `closure` is okay, but maybe it's deprecated behavior or something? Possibly depends on https://github.com/CliMA/Oceananigans.jl/issues/1381",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1879
https://github.com/CliMA/Oceananigans.jl/pull/1880:83,Security,validat,validation,83,The following PR adds a new script with immersed boundaries on a lat-lon grid as a validation test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1880
https://github.com/CliMA/Oceananigans.jl/pull/1880:94,Testability,test,test,94,The following PR adds a new script with immersed boundaries on a lat-lon grid as a validation test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1880
https://github.com/CliMA/Oceananigans.jl/pull/1881:821,Availability,down,down,821,"Co-authored-by: Francis J. Poulin <fpoulin@uwaterloo.ca>. I've added back the threaded benchmark written by @francispoulin in an older branch. I also added plots to it.; There is actually already a threaded benchmark script:; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading.jl; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading_single.jl; They differ in that the one I'm adding is essentially weak scaling shallow water model, while the one that's already there is strong scaling nonhydrostatic model.; If everyone thinks that it's appropriate, then I'll likely change the name of the extant benchmarking scripts to more accurately reflect their content. ; I would likely also do some more minor changes such as changing the default grid size down from 512^3, adding in plots, and configuring the output tables a bit more.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881
https://github.com/CliMA/Oceananigans.jl/pull/1881:859,Modifiability,config,configuring,859,"Co-authored-by: Francis J. Poulin <fpoulin@uwaterloo.ca>. I've added back the threaded benchmark written by @francispoulin in an older branch. I also added plots to it.; There is actually already a threaded benchmark script:; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading.jl; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading_single.jl; They differ in that the one I'm adding is essentially weak scaling shallow water model, while the one that's already there is strong scaling nonhydrostatic model.; If everyone thinks that it's appropriate, then I'll likely change the name of the extant benchmarking scripts to more accurately reflect their content. ; I would likely also do some more minor changes such as changing the default grid size down from 512^3, adding in plots, and configuring the output tables a bit more.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881
https://github.com/CliMA/Oceananigans.jl/pull/1881:87,Testability,benchmark,benchmark,87,"Co-authored-by: Francis J. Poulin <fpoulin@uwaterloo.ca>. I've added back the threaded benchmark written by @francispoulin in an older branch. I also added plots to it.; There is actually already a threaded benchmark script:; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading.jl; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading_single.jl; They differ in that the one I'm adding is essentially weak scaling shallow water model, while the one that's already there is strong scaling nonhydrostatic model.; If everyone thinks that it's appropriate, then I'll likely change the name of the extant benchmarking scripts to more accurately reflect their content. ; I would likely also do some more minor changes such as changing the default grid size down from 512^3, adding in plots, and configuring the output tables a bit more.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881
https://github.com/CliMA/Oceananigans.jl/pull/1881:207,Testability,benchmark,benchmark,207,"Co-authored-by: Francis J. Poulin <fpoulin@uwaterloo.ca>. I've added back the threaded benchmark written by @francispoulin in an older branch. I also added plots to it.; There is actually already a threaded benchmark script:; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading.jl; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading_single.jl; They differ in that the one I'm adding is essentially weak scaling shallow water model, while the one that's already there is strong scaling nonhydrostatic model.; If everyone thinks that it's appropriate, then I'll likely change the name of the extant benchmarking scripts to more accurately reflect their content. ; I would likely also do some more minor changes such as changing the default grid size down from 512^3, adding in plots, and configuring the output tables a bit more.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881
https://github.com/CliMA/Oceananigans.jl/pull/1881:279,Testability,benchmark,benchmark,279,"Co-authored-by: Francis J. Poulin <fpoulin@uwaterloo.ca>. I've added back the threaded benchmark written by @francispoulin in an older branch. I also added plots to it.; There is actually already a threaded benchmark script:; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading.jl; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading_single.jl; They differ in that the one I'm adding is essentially weak scaling shallow water model, while the one that's already there is strong scaling nonhydrostatic model.; If everyone thinks that it's appropriate, then I'll likely change the name of the extant benchmarking scripts to more accurately reflect their content. ; I would likely also do some more minor changes such as changing the default grid size down from 512^3, adding in plots, and configuring the output tables a bit more.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881
https://github.com/CliMA/Oceananigans.jl/pull/1881:371,Testability,benchmark,benchmark,371,"Co-authored-by: Francis J. Poulin <fpoulin@uwaterloo.ca>. I've added back the threaded benchmark written by @francispoulin in an older branch. I also added plots to it.; There is actually already a threaded benchmark script:; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading.jl; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading_single.jl; They differ in that the one I'm adding is essentially weak scaling shallow water model, while the one that's already there is strong scaling nonhydrostatic model.; If everyone thinks that it's appropriate, then I'll likely change the name of the extant benchmarking scripts to more accurately reflect their content. ; I would likely also do some more minor changes such as changing the default grid size down from 512^3, adding in plots, and configuring the output tables a bit more.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881
https://github.com/CliMA/Oceananigans.jl/pull/1881:670,Testability,benchmark,benchmarking,670,"Co-authored-by: Francis J. Poulin <fpoulin@uwaterloo.ca>. I've added back the threaded benchmark written by @francispoulin in an older branch. I also added plots to it.; There is actually already a threaded benchmark script:; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading.jl; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading_single.jl; They differ in that the one I'm adding is essentially weak scaling shallow water model, while the one that's already there is strong scaling nonhydrostatic model.; If everyone thinks that it's appropriate, then I'll likely change the name of the extant benchmarking scripts to more accurately reflect their content. ; I would likely also do some more minor changes such as changing the default grid size down from 512^3, adding in plots, and configuring the output tables a bit more.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881
https://github.com/CliMA/Oceananigans.jl/issues/1882:1018,Performance,perform,performance,1018,"I recently ran the weak scaling shallow water model benchmark with the MultiGPU architecture on Satori, thanks to @christophernhill.; Here are the results:; <html>; <body>; <!--StartFragment-->. size | ranks | min | median | mean | max | memory | allocs | samples; -- | -- | -- | -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 2.765 ms | 2.786 ms | 2.849 ms | 3.374 ms | 2.03 MiB | 5535 | 10; (4096, 512) | (1, 2) | 6.932 ms | 7.081 ms | 8.037 ms | 26.174 ms | 2.03 MiB | 5859 | 20; (4096, 1024) | (1, 4) | 12.592 ms | 14.603 ms | 16.417 ms | 31.468 ms | 2.03 MiB | 5859 | 40. <!--EndFragment-->; </body>; </html>. <html>; <body>; <!--StartFragment-->. size | ranks | slowdown | efficiency | memory | allocs; -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 1.0 | 1.0 | 1.0 | 1.0; (4096, 512) | (1, 2) | 2.54127 | 0.393505 | 1.00271 | 1.05854; (4096, 1024) | (1, 4) | 5.24053 | 0.19082 | 1.00271 | 1.05854. <!--EndFragment-->; </body>; </html>. The results are not good but at least we can benchmark multi-GPU performance now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882
https://github.com/CliMA/Oceananigans.jl/issues/1882:52,Testability,benchmark,benchmark,52,"I recently ran the weak scaling shallow water model benchmark with the MultiGPU architecture on Satori, thanks to @christophernhill.; Here are the results:; <html>; <body>; <!--StartFragment-->. size | ranks | min | median | mean | max | memory | allocs | samples; -- | -- | -- | -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 2.765 ms | 2.786 ms | 2.849 ms | 3.374 ms | 2.03 MiB | 5535 | 10; (4096, 512) | (1, 2) | 6.932 ms | 7.081 ms | 8.037 ms | 26.174 ms | 2.03 MiB | 5859 | 20; (4096, 1024) | (1, 4) | 12.592 ms | 14.603 ms | 16.417 ms | 31.468 ms | 2.03 MiB | 5859 | 40. <!--EndFragment-->; </body>; </html>. <html>; <body>; <!--StartFragment-->. size | ranks | slowdown | efficiency | memory | allocs; -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 1.0 | 1.0 | 1.0 | 1.0; (4096, 512) | (1, 2) | 2.54127 | 0.393505 | 1.00271 | 1.05854; (4096, 1024) | (1, 4) | 5.24053 | 0.19082 | 1.00271 | 1.05854. <!--EndFragment-->; </body>; </html>. The results are not good but at least we can benchmark multi-GPU performance now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882
https://github.com/CliMA/Oceananigans.jl/issues/1882:998,Testability,benchmark,benchmark,998,"I recently ran the weak scaling shallow water model benchmark with the MultiGPU architecture on Satori, thanks to @christophernhill.; Here are the results:; <html>; <body>; <!--StartFragment-->. size | ranks | min | median | mean | max | memory | allocs | samples; -- | -- | -- | -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 2.765 ms | 2.786 ms | 2.849 ms | 3.374 ms | 2.03 MiB | 5535 | 10; (4096, 512) | (1, 2) | 6.932 ms | 7.081 ms | 8.037 ms | 26.174 ms | 2.03 MiB | 5859 | 20; (4096, 1024) | (1, 4) | 12.592 ms | 14.603 ms | 16.417 ms | 31.468 ms | 2.03 MiB | 5859 | 40. <!--EndFragment-->; </body>; </html>. <html>; <body>; <!--StartFragment-->. size | ranks | slowdown | efficiency | memory | allocs; -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 1.0 | 1.0 | 1.0 | 1.0; (4096, 512) | (1, 2) | 2.54127 | 0.393505 | 1.00271 | 1.05854; (4096, 1024) | (1, 4) | 5.24053 | 0.19082 | 1.00271 | 1.05854. <!--EndFragment-->; </body>; </html>. The results are not good but at least we can benchmark multi-GPU performance now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882
https://github.com/CliMA/Oceananigans.jl/pull/1883:302,Availability,robust,robust,302,This PR reformulates TKEBasedVerticalDiffusivity simply through a redefinition of parameters. It also makes a more important change to the code that passes `model.closure` and `model.buoyancy` to the kernels that evaluate boundary fluxes. This is necessary to make `TKEBasedVerticalDiffusivity` models robust against changes to parameters after model construction. The changes are made in a way that have no affect on the API or other models. Resolves #1695 . cc @adelinehillier,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1883
https://github.com/CliMA/Oceananigans.jl/pull/1883:49,Usability,simpl,simply,49,This PR reformulates TKEBasedVerticalDiffusivity simply through a redefinition of parameters. It also makes a more important change to the code that passes `model.closure` and `model.buoyancy` to the kernels that evaluate boundary fluxes. This is necessary to make `TKEBasedVerticalDiffusivity` models robust against changes to parameters after model construction. The changes are made in a way that have no affect on the API or other models. Resolves #1695 . cc @adelinehillier,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1883
https://github.com/CliMA/Oceananigans.jl/pull/1884:38,Testability,test,tests,38,"Closes #1878. I ran the most relevant tests locally and they all passed for me (didn't have time/resources to run all), but I'd appreciate some thorough reviews in this case since ""diffusivities"" is a word that happens a lot in the repo so it's easy to miss something when making such a change.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1884
https://github.com/CliMA/Oceananigans.jl/issues/1885:1054,Availability,error,error,1054,"fined functions into a model via `ContinuousForcing`, `DiscreteForcing`, `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction`. User functions are also permitted as input to some model terms: turbulence closures, Stokes drift, etc, and can be used in diagnostics and AbstractOperations. It's often necessary or convenient to formulate user functions in terms of global variables. For, example, a Gaussian surface cooling might be written as. ```julia; patch_width = 200meters; patch_amplitude = 1e-8 # m^3 s^-2; cooling_patch(x, y, t) = patch_amplitude * exp(-(x^2 + y^2) / 2patch_width^2). cooling_bc = FluxBoundaryCondition(cooling_patch); ```. Alas, this simple function will not compile on the GPU and is too slow on the CPU. To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885
https://github.com/CliMA/Oceananigans.jl/issues/1885:1114,Availability,error,error,1114,"fined functions into a model via `ContinuousForcing`, `DiscreteForcing`, `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction`. User functions are also permitted as input to some model terms: turbulence closures, Stokes drift, etc, and can be used in diagnostics and AbstractOperations. It's often necessary or convenient to formulate user functions in terms of global variables. For, example, a Gaussian surface cooling might be written as. ```julia; patch_width = 200meters; patch_amplitude = 1e-8 # m^3 s^-2; cooling_patch(x, y, t) = patch_amplitude * exp(-(x^2 + y^2) / 2patch_width^2). cooling_bc = FluxBoundaryCondition(cooling_patch); ```. Alas, this simple function will not compile on the GPU and is too slow on the CPU. To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885
https://github.com/CliMA/Oceananigans.jl/issues/1885:1381,Availability,recover,recover,1381,"variables. For, example, a Gaussian surface cooling might be written as. ```julia; patch_width = 200meters; patch_amplitude = 1e-8 # m^3 s^-2; cooling_patch(x, y, t) = patch_amplitude * exp(-(x^2 + y^2) / 2patch_width^2). cooling_bc = FluxBoundaryCondition(cooling_patch); ```. Alas, this simple function will not compile on the GPU and is too slow on the CPU. To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885
https://github.com/CliMA/Oceananigans.jl/issues/1885:1431,Availability,error,error,1431,"variables. For, example, a Gaussian surface cooling might be written as. ```julia; patch_width = 200meters; patch_amplitude = 1e-8 # m^3 s^-2; cooling_patch(x, y, t) = patch_amplitude * exp(-(x^2 + y^2) / 2patch_width^2). cooling_bc = FluxBoundaryCondition(cooling_patch); ```. Alas, this simple function will not compile on the GPU and is too slow on the CPU. To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885
https://github.com/CliMA/Oceananigans.jl/issues/1885:2026,Availability,ERROR,ERROR,2026,"ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L961) (maybe... I don't know how to use it 🥺 😄 ). A few things to consider about possible solutions:. 1. Speed. Type inference might be slow for very complicated user functions, or scenarios that involve recursion (eg AbstractOperations...). So we have to limit our scope (just forcing and boundary conditions?), and we need to provide an escape hatch that avoids the analysis / error. I think maybe this is ok since 1. forcing functions are the real problem and 2. complicated user functions => sophisticated users who know about the escape hatch. 2. Accuracy. It'd just be nice to throw an accurate error. With `@inferred` we don't r",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885
https://github.com/CliMA/Oceananigans.jl/issues/1885:2109,Availability,error,error,2109,"ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L961) (maybe... I don't know how to use it 🥺 😄 ). A few things to consider about possible solutions:. 1. Speed. Type inference might be slow for very complicated user functions, or scenarios that involve recursion (eg AbstractOperations...). So we have to limit our scope (just forcing and boundary conditions?), and we need to provide an escape hatch that avoids the analysis / error. I think maybe this is ok since 1. forcing functions are the real problem and 2. complicated user functions => sophisticated users who know about the escape hatch. 2. Accuracy. It'd just be nice to throw an accurate error. With `@inferred` we don't r",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885
https://github.com/CliMA/Oceananigans.jl/issues/1885:2136,Availability,error,error,2136,"t will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L961) (maybe... I don't know how to use it 🥺 😄 ). A few things to consider about possible solutions:. 1. Speed. Type inference might be slow for very complicated user functions, or scenarios that involve recursion (eg AbstractOperations...). So we have to limit our scope (just forcing and boundary conditions?), and we need to provide an escape hatch that avoids the analysis / error. I think maybe this is ok since 1. forcing functions are the real problem and 2. complicated user functions => sophisticated users who know about the escape hatch. 2. Accuracy. It'd just be nice to throw an accurate error. With `@inferred` we don't really know why there's an issue with type inference so we have to say ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885
https://github.com/CliMA/Oceananigans.jl/issues/1885:2813,Availability,error,error,2813,"of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L961) (maybe... I don't know how to use it 🥺 😄 ). A few things to consider about possible solutions:. 1. Speed. Type inference might be slow for very complicated user functions, or scenarios that involve recursion (eg AbstractOperations...). So we have to limit our scope (just forcing and boundary conditions?), and we need to provide an escape hatch that avoids the analysis / error. I think maybe this is ok since 1. forcing functions are the real problem and 2. complicated user functions => sophisticated users who know about the escape hatch. 2. Accuracy. It'd just be nice to throw an accurate error. With `@inferred` we don't really know why there's an issue with type inference so we have to say wishy washy things like ""maybe, just maybe you did this but I don't really know sorry just trying to help... !""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885
https://github.com/CliMA/Oceananigans.jl/issues/1885:3035,Availability,error,error,3035,"of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L961) (maybe... I don't know how to use it 🥺 😄 ). A few things to consider about possible solutions:. 1. Speed. Type inference might be slow for very complicated user functions, or scenarios that involve recursion (eg AbstractOperations...). So we have to limit our scope (just forcing and boundary conditions?), and we need to provide an escape hatch that avoids the analysis / error. I think maybe this is ok since 1. forcing functions are the real problem and 2. complicated user functions => sophisticated users who know about the escape hatch. 2. Accuracy. It'd just be nice to throw an accurate error. With `@inferred` we don't really know why there's an issue with type inference so we have to say wishy washy things like ""maybe, just maybe you did this but I don't really know sorry just trying to help... !""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885
https://github.com/CliMA/Oceananigans.jl/issues/1885:93,Deployability,Continuous,ContinuousForcing,93,"Oceananigans.jl supplies an interface for inserting user-defined functions into a model via `ContinuousForcing`, `DiscreteForcing`, `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction`. User functions are also permitted as input to some model terms: turbulence closures, Stokes drift, etc, and can be used in diagnostics and AbstractOperations. It's often necessary or convenient to formulate user functions in terms of global variables. For, example, a Gaussian surface cooling might be written as. ```julia; patch_width = 200meters; patch_amplitude = 1e-8 # m^3 s^-2; cooling_patch(x, y, t) = patch_amplitude * exp(-(x^2 + y^2) / 2patch_width^2). cooling_bc = FluxBoundaryCondition(cooling_patch); ```. Alas, this simple function will not compile on the GPU and is too slow on the CPU. To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885
https://github.com/CliMA/Oceananigans.jl/issues/1885:133,Deployability,Continuous,ContinuousBoundaryFunction,133,"Oceananigans.jl supplies an interface for inserting user-defined functions into a model via `ContinuousForcing`, `DiscreteForcing`, `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction`. User functions are also permitted as input to some model terms: turbulence closures, Stokes drift, etc, and can be used in diagnostics and AbstractOperations. It's often necessary or convenient to formulate user functions in terms of global variables. For, example, a Gaussian surface cooling might be written as. ```julia; patch_width = 200meters; patch_amplitude = 1e-8 # m^3 s^-2; cooling_patch(x, y, t) = patch_amplitude * exp(-(x^2 + y^2) / 2patch_width^2). cooling_bc = FluxBoundaryCondition(cooling_patch); ```. Alas, this simple function will not compile on the GPU and is too slow on the CPU. To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885
https://github.com/CliMA/Oceananigans.jl/issues/1885:28,Integrability,interface,interface,28,"Oceananigans.jl supplies an interface for inserting user-defined functions into a model via `ContinuousForcing`, `DiscreteForcing`, `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction`. User functions are also permitted as input to some model terms: turbulence closures, Stokes drift, etc, and can be used in diagnostics and AbstractOperations. It's often necessary or convenient to formulate user functions in terms of global variables. For, example, a Gaussian surface cooling might be written as. ```julia; patch_width = 200meters; patch_amplitude = 1e-8 # m^3 s^-2; cooling_patch(x, y, t) = patch_amplitude * exp(-(x^2 + y^2) / 2patch_width^2). cooling_bc = FluxBoundaryCondition(cooling_patch); ```. Alas, this simple function will not compile on the GPU and is too slow on the CPU. To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885
https://github.com/CliMA/Oceananigans.jl/issues/1885:434,Modifiability,variab,variables,434,"Oceananigans.jl supplies an interface for inserting user-defined functions into a model via `ContinuousForcing`, `DiscreteForcing`, `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction`. User functions are also permitted as input to some model terms: turbulence closures, Stokes drift, etc, and can be used in diagnostics and AbstractOperations. It's often necessary or convenient to formulate user functions in terms of global variables. For, example, a Gaussian surface cooling might be written as. ```julia; patch_width = 200meters; patch_amplitude = 1e-8 # m^3 s^-2; cooling_patch(x, y, t) = patch_amplitude * exp(-(x^2 + y^2) / 2patch_width^2). cooling_bc = FluxBoundaryCondition(cooling_patch); ```. Alas, this simple function will not compile on the GPU and is too slow on the CPU. To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885
https://github.com/CliMA/Oceananigans.jl/issues/1885:1381,Safety,recover,recover,1381,"variables. For, example, a Gaussian surface cooling might be written as. ```julia; patch_width = 200meters; patch_amplitude = 1e-8 # m^3 s^-2; cooling_patch(x, y, t) = patch_amplitude * exp(-(x^2 + y^2) / 2patch_width^2). cooling_bc = FluxBoundaryCondition(cooling_patch); ```. Alas, this simple function will not compile on the GPU and is too slow on the CPU. To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885
https://github.com/CliMA/Oceananigans.jl/issues/1885:2791,Safety,avoid,avoids,2791,"of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L961) (maybe... I don't know how to use it 🥺 😄 ). A few things to consider about possible solutions:. 1. Speed. Type inference might be slow for very complicated user functions, or scenarios that involve recursion (eg AbstractOperations...). So we have to limit our scope (just forcing and boundary conditions?), and we need to provide an escape hatch that avoids the analysis / error. I think maybe this is ok since 1. forcing functions are the real problem and 2. complicated user functions => sophisticated users who know about the escape hatch. 2. Accuracy. It'd just be nice to throw an accurate error. With `@inferred` we don't really know why there's an issue with type inference so we have to say wishy washy things like ""maybe, just maybe you did this but I don't really know sorry just trying to help... !""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885
https://github.com/CliMA/Oceananigans.jl/issues/1885:1756,Testability,Test,Test,1756,"n the GPU and is too slow on the CPU. To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L961) (maybe... I don't know how to use it 🥺 😄 ). A few things to consider about possible solutions:. 1. Speed. Type inference might be slow for very complicated user functions, or scenarios that involve recursion (eg AbstractOperations...). So we have to limit our scope (just forcing and boundary conditions?), and we need",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885
https://github.com/CliMA/Oceananigans.jl/issues/1885:1797,Testability,Test,Test,1797,". To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method). julia> @inferred f(1); ERROR: return type Int64 does not match inferred return type Any; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ REPL[50]:1; [3] top-level scope; @ ~/.julia/packages/CUDA/fRSUT/src/initialization.jl:52. julia> @inferred g(1); 2; ```. 3. [`Core.Compiler.return_type`](https://github.com/JuliaLang/julia/blob/2c02de80bd7ec2e33378e75be34635c072d06a60/base/compiler/typeinfer.jl#L961) (maybe... I don't know how to use it 🥺 😄 ). A few things to consider about possible solutions:. 1. Speed. Type inference might be slow for very complicated user functions, or scenarios that involve recursion (eg AbstractOperations...). So we have to limit our scope (just forcing and boundary conditions?), and we need to provide an escape hatch that av",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885
https://github.com/CliMA/Oceananigans.jl/issues/1885:723,Usability,simpl,simple,723,"Oceananigans.jl supplies an interface for inserting user-defined functions into a model via `ContinuousForcing`, `DiscreteForcing`, `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction`. User functions are also permitted as input to some model terms: turbulence closures, Stokes drift, etc, and can be used in diagnostics and AbstractOperations. It's often necessary or convenient to formulate user functions in terms of global variables. For, example, a Gaussian surface cooling might be written as. ```julia; patch_width = 200meters; patch_amplitude = 1e-8 # m^3 s^-2; cooling_patch(x, y, t) = patch_amplitude * exp(-(x^2 + y^2) / 2patch_width^2). cooling_bc = FluxBoundaryCondition(cooling_patch); ```. Alas, this simple function will not compile on the GPU and is too slow on the CPU. To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885
https://github.com/CliMA/Oceananigans.jl/issues/1886:567,Availability,ERROR,ERROR,567,"This is a summary of the current salient issues discussed on #1241. Much of that discussion is out of date; however one issue that remains is that complex GPU AbstractOperations can produce PTX code with function signatures that consume too much ""parameter space"". To reproduce this issue:. ```julia; using Oceananigans; model = NonhydrostaticModel(architecture=GPU(), grid=RegularRectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1))); u, v, w = model.velocities; ```. and then. ```julia; julia> compute!(ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: Failed to compile PTX code (ptxas exited with code 255); ptxas /tmp/jl_IGwXuE.ptx, line 1951; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Namevv14__PassType_257v12DisableHooksE14_gpu__compute_16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES5_I9_1__1__1_ES5_I9_1__1__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI6CenterS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE10_identity5vv22RegularRectilinearGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEES9_E5Int6410_identity110_identity2vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEE10_identity3vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_10_identity4S18_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S26_S28_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES29_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S18_S25_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_I",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1886
https://github.com/CliMA/Oceananigans.jl/issues/1886:668,Availability,error,error,668,"eld(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2 + ∂x(w)^2 + ∂y(w)^2)); ERROR: Failed to compile PTX code (ptxas exited with code 255); ptxas /tmp/jl_IGwXuE.ptx, line 1951; error : Entry function '_Z19julia_gpu__compute_7ContextI14__CUDACtx_Namevv14__PassType_257v12DisableHooksE14_gpu__compute_16CompilerMetadataI10StaticSizeI9_1__1__1_E12DynamicCheckvv7NDRangeILi3ES5_I9_1__1__1_ES5_I9_1__1__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE17MultiaryOperationI6CenterS12_S12_Li5E2__5TupleI15BinaryOperationIS12_S12_S12_S13_10DerivativeIS12_S12_S12_6__x___S8_IS9_Li3ES10_IS9_Li3ELi1EEE10_identity5vv22RegularRectilinearGridIS9_8PeriodicS20_7BoundedS8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES23_IS9_EEEES9_E5Int6410_identity110_identity2vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__y___S8_IS9_Li3ES10_IS9_Li3ELi1EEE10_identity3vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_10_identity4S18_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S26_S28_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES29_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S18_S25_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S27_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S28_S29_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_EES14_IS18_S25_S26_7__xz___7__yz___EvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_E' uses too much parameter space (0x1438 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. A possible solution is proposed at https://github.com/JuliaGPU/CUDA.jl/issues/267. ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1886
https://github.com/CliMA/Oceananigans.jl/issues/1886:2417,Availability,error,errors,2417,"ity3vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_10_identity4S18_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S26_S28_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES29_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S18_S25_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S27_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S28_S29_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_EES14_IS18_S25_S26_7__xz___7__yz___EvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_E' uses too much parameter space (0x1438 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. A possible solution is proposed at https://github.com/JuliaGPU/CUDA.jl/issues/267. One workaround within Oceananigans is to ""stage"" the computation:. ```julia; julia> uxvywz = ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2); ComputedField located at (Center, Center, Center) of MultiaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); ├── operand: MultiaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(ComputedField(uxvywz + ∂x(w)^2 + ∂y(w)^2, data=uxvywz.data)); ```. By sharing memory between the `ComputedField`s, we avoid allocating more memory in this solution. It may still be more computationally expensive however (though benchmarking is required to confirm that, as its not certain). Another solution is to hand-write the kernel operation using `KernelFunctionOpera",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1886
https://github.com/CliMA/Oceananigans.jl/issues/1886:2402,Safety,abort,aborted,2402,"ity3vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_10_identity4S18_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S26_S28_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES29_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S18_S25_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S27_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S28_S29_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_EES14_IS18_S25_S26_7__xz___7__yz___EvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_E' uses too much parameter space (0x1438 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. A possible solution is proposed at https://github.com/JuliaGPU/CUDA.jl/issues/267. One workaround within Oceananigans is to ""stage"" the computation:. ```julia; julia> uxvywz = ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2); ComputedField located at (Center, Center, Center) of MultiaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); ├── operand: MultiaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(ComputedField(uxvywz + ∂x(w)^2 + ∂y(w)^2, data=uxvywz.data)); ```. By sharing memory between the `ComputedField`s, we avoid allocating more memory in this solution. It may still be more computationally expensive however (though benchmarking is required to confirm that, as its not certain). Another solution is to hand-write the kernel operation using `KernelFunctionOpera",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1886
https://github.com/CliMA/Oceananigans.jl/issues/1886:3147,Safety,avoid,avoid,3147,"S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_10_identity4S18_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S26_S28_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES29_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S18_S25_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S27_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S28_S29_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_EES14_IS18_S25_S26_7__xz___7__yz___EvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_E' uses too much parameter space (0x1438 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. A possible solution is proposed at https://github.com/JuliaGPU/CUDA.jl/issues/267. One workaround within Oceananigans is to ""stage"" the computation:. ```julia; julia> uxvywz = ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2); ComputedField located at (Center, Center, Center) of MultiaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); ├── operand: MultiaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(ComputedField(uxvywz + ∂x(w)^2 + ∂y(w)^2, data=uxvywz.data)); ```. By sharing memory between the `ComputedField`s, we avoid allocating more memory in this solution. It may still be more computationally expensive however (though benchmarking is required to confirm that, as its not certain). Another solution is to hand-write the kernel operation using `KernelFunctionOperation`. cc @tomchor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1886
https://github.com/CliMA/Oceananigans.jl/issues/1886:3257,Testability,benchmark,benchmarking,3257,"S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_10_identity4S18_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S26_S28_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES29_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S18_S25_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S27_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S28_S29_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_EES14_IS18_S25_S26_7__xz___7__yz___EvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_E' uses too much parameter space (0x1438 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. A possible solution is proposed at https://github.com/JuliaGPU/CUDA.jl/issues/267. One workaround within Oceananigans is to ""stage"" the computation:. ```julia; julia> uxvywz = ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2); ComputedField located at (Center, Center, Center) of MultiaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); ├── operand: MultiaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(ComputedField(uxvywz + ∂x(w)^2 + ∂y(w)^2, data=uxvywz.data)); ```. By sharing memory between the `ComputedField`s, we avoid allocating more memory in this solution. It may still be more computationally expensive however (though benchmarking is required to confirm that, as its not certain). Another solution is to hand-write the kernel operation using `KernelFunctionOperation`. cc @tomchor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1886
https://github.com/CliMA/Oceananigans.jl/issues/1886:2597,Usability,ux,uxvywz,2597,"S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_10_identity4S18_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S26_S28_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES29_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S18_S25_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S27_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S28_S29_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_EES14_IS18_S25_S26_7__xz___7__yz___EvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_E' uses too much parameter space (0x1438 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. A possible solution is proposed at https://github.com/JuliaGPU/CUDA.jl/issues/267. One workaround within Oceananigans is to ""stage"" the computation:. ```julia; julia> uxvywz = ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2); ComputedField located at (Center, Center, Center) of MultiaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); ├── operand: MultiaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(ComputedField(uxvywz + ∂x(w)^2 + ∂y(w)^2, data=uxvywz.data)); ```. By sharing memory between the `ComputedField`s, we avoid allocating more memory in this solution. It may still be more computationally expensive however (though benchmarking is required to confirm that, as its not certain). Another solution is to hand-write the kernel operation using `KernelFunctionOperation`. cc @tomchor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1886
https://github.com/CliMA/Oceananigans.jl/issues/1886:3043,Usability,ux,uxvywz,3043,"S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_10_identity4S18_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S26_S28_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES29_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S18_S25_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S27_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S28_S29_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_EES14_IS18_S25_S26_7__xz___7__yz___EvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_E' uses too much parameter space (0x1438 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. A possible solution is proposed at https://github.com/JuliaGPU/CUDA.jl/issues/267. One workaround within Oceananigans is to ""stage"" the computation:. ```julia; julia> uxvywz = ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2); ComputedField located at (Center, Center, Center) of MultiaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); ├── operand: MultiaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(ComputedField(uxvywz + ∂x(w)^2 + ∂y(w)^2, data=uxvywz.data)); ```. By sharing memory between the `ComputedField`s, we avoid allocating more memory in this solution. It may still be more computationally expensive however (though benchmarking is required to confirm that, as its not certain). Another solution is to hand-write the kernel operation using `KernelFunctionOperation`. cc @tomchor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1886
https://github.com/CliMA/Oceananigans.jl/issues/1886:3076,Usability,ux,uxvywz,3076,"S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_10_identity4S18_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S12_S12_S13_S16_IS12_S12_S12_6__z___S8_IS9_Li3ES10_IS9_Li3ELi1EEES25_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S26_S28_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_I4FaceS12_S31_S13_S16_IS31_S12_S31_S17_S8_IS9_Li3ES10_IS9_Li3ELi1EEES29_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S18_S25_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES15_IS12_S31_S31_S13_S16_IS12_S31_S31_S27_S8_IS9_Li3ES10_IS9_Li3ELi1EEES26_vvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_ES24_S28_S29_vS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_EES14_IS18_S25_S26_7__xz___7__yz___EvS19_IS9_S20_S20_S21_S8_IS9_Li1ES22_IS9_S23_IS9_ES23_IS9_EEEES9_E' uses too much parameter space (0x1438 bytes, 0x1100 max).; ptxas fatal : Ptx assembly aborted due to errors; ```. A possible solution is proposed at https://github.com/JuliaGPU/CUDA.jl/issues/267. One workaround within Oceananigans is to ""stage"" the computation:. ```julia; julia> uxvywz = ComputedField(∂x(u)^2 + ∂y(v)^2 + ∂z(w)^2); ComputedField located at (Center, Center, Center) of MultiaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, size: (1, 1, 1); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=1, Nz=1); ├── operand: MultiaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(ComputedField(uxvywz + ∂x(w)^2 + ∂y(w)^2, data=uxvywz.data)); ```. By sharing memory between the `ComputedField`s, we avoid allocating more memory in this solution. It may still be more computationally expensive however (though benchmarking is required to confirm that, as its not certain). Another solution is to hand-write the kernel operation using `KernelFunctionOperation`. cc @tomchor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1886
https://github.com/CliMA/Oceananigans.jl/pull/1888:8,Availability,mask,masks,8,"This PR masks tracers inside immersed solids in the same way velocities are already being masked:. `mask_immersed_tracers!(tracers, arch, grid::GFIBG) = Tuple(mask_immersed_field!(c) for c in tracers)`. Tracers are masked in `update_state!` before filling tracer halos. This also updates the cylinder validation to run with this immersed boundary method with tracers and analysis. The analysis is mostly for no slip boundary conditions which are not implemented yet (just free slip). Includes visuals like,. https://user-images.githubusercontent.com/67593861/126657679-1daa523e-c1da-4097-b994-d16966a9b578.mp4. and analysis of the pressure and friction coefficient (known for no slip BC), the normal and tangential velocities, and the tracer conservation, taken as the leakage in the fluid as compared to the initial state. Right now the tracers won't look right. @glwagner has found some problems with the diffusivities and tracers to be fixed. ![analysis_cylinder_tracer_Nh_350_CenteredSecondOrder](https://user-images.githubusercontent.com/67593861/126657698-bbfec9bb-0820-4ed5-866d-54f9b3ac7dd5.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1888
https://github.com/CliMA/Oceananigans.jl/pull/1888:90,Availability,mask,masked,90,"This PR masks tracers inside immersed solids in the same way velocities are already being masked:. `mask_immersed_tracers!(tracers, arch, grid::GFIBG) = Tuple(mask_immersed_field!(c) for c in tracers)`. Tracers are masked in `update_state!` before filling tracer halos. This also updates the cylinder validation to run with this immersed boundary method with tracers and analysis. The analysis is mostly for no slip boundary conditions which are not implemented yet (just free slip). Includes visuals like,. https://user-images.githubusercontent.com/67593861/126657679-1daa523e-c1da-4097-b994-d16966a9b578.mp4. and analysis of the pressure and friction coefficient (known for no slip BC), the normal and tangential velocities, and the tracer conservation, taken as the leakage in the fluid as compared to the initial state. Right now the tracers won't look right. @glwagner has found some problems with the diffusivities and tracers to be fixed. ![analysis_cylinder_tracer_Nh_350_CenteredSecondOrder](https://user-images.githubusercontent.com/67593861/126657698-bbfec9bb-0820-4ed5-866d-54f9b3ac7dd5.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1888
https://github.com/CliMA/Oceananigans.jl/pull/1888:215,Availability,mask,masked,215,"This PR masks tracers inside immersed solids in the same way velocities are already being masked:. `mask_immersed_tracers!(tracers, arch, grid::GFIBG) = Tuple(mask_immersed_field!(c) for c in tracers)`. Tracers are masked in `update_state!` before filling tracer halos. This also updates the cylinder validation to run with this immersed boundary method with tracers and analysis. The analysis is mostly for no slip boundary conditions which are not implemented yet (just free slip). Includes visuals like,. https://user-images.githubusercontent.com/67593861/126657679-1daa523e-c1da-4097-b994-d16966a9b578.mp4. and analysis of the pressure and friction coefficient (known for no slip BC), the normal and tangential velocities, and the tracer conservation, taken as the leakage in the fluid as compared to the initial state. Right now the tracers won't look right. @glwagner has found some problems with the diffusivities and tracers to be fixed. ![analysis_cylinder_tracer_Nh_350_CenteredSecondOrder](https://user-images.githubusercontent.com/67593861/126657698-bbfec9bb-0820-4ed5-866d-54f9b3ac7dd5.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1888
https://github.com/CliMA/Oceananigans.jl/pull/1888:280,Deployability,update,updates,280,"This PR masks tracers inside immersed solids in the same way velocities are already being masked:. `mask_immersed_tracers!(tracers, arch, grid::GFIBG) = Tuple(mask_immersed_field!(c) for c in tracers)`. Tracers are masked in `update_state!` before filling tracer halos. This also updates the cylinder validation to run with this immersed boundary method with tracers and analysis. The analysis is mostly for no slip boundary conditions which are not implemented yet (just free slip). Includes visuals like,. https://user-images.githubusercontent.com/67593861/126657679-1daa523e-c1da-4097-b994-d16966a9b578.mp4. and analysis of the pressure and friction coefficient (known for no slip BC), the normal and tangential velocities, and the tracer conservation, taken as the leakage in the fluid as compared to the initial state. Right now the tracers won't look right. @glwagner has found some problems with the diffusivities and tracers to be fixed. ![analysis_cylinder_tracer_Nh_350_CenteredSecondOrder](https://user-images.githubusercontent.com/67593861/126657698-bbfec9bb-0820-4ed5-866d-54f9b3ac7dd5.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1888
https://github.com/CliMA/Oceananigans.jl/pull/1888:301,Security,validat,validation,301,"This PR masks tracers inside immersed solids in the same way velocities are already being masked:. `mask_immersed_tracers!(tracers, arch, grid::GFIBG) = Tuple(mask_immersed_field!(c) for c in tracers)`. Tracers are masked in `update_state!` before filling tracer halos. This also updates the cylinder validation to run with this immersed boundary method with tracers and analysis. The analysis is mostly for no slip boundary conditions which are not implemented yet (just free slip). Includes visuals like,. https://user-images.githubusercontent.com/67593861/126657679-1daa523e-c1da-4097-b994-d16966a9b578.mp4. and analysis of the pressure and friction coefficient (known for no slip BC), the normal and tangential velocities, and the tracer conservation, taken as the leakage in the fluid as compared to the initial state. Right now the tracers won't look right. @glwagner has found some problems with the diffusivities and tracers to be fixed. ![analysis_cylinder_tracer_Nh_350_CenteredSecondOrder](https://user-images.githubusercontent.com/67593861/126657698-bbfec9bb-0820-4ed5-866d-54f9b3ac7dd5.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1888
https://github.com/CliMA/Oceananigans.jl/pull/1893:130,Availability,checkpoint,checkpoint,130,"This long overdue PR nukes `restore_from_checkpoint` and all its tests. We've decided to support ""picking up"" a simulation from a checkpoint instead via `run!(simulation, pickup=true)`. The reason is that we can only restore a limited subset of models that don't utilize user-defined functions. ""Restoring"" a model from a checkpoint is an error-prone processes, and supporting `restore_from_checkpoint` has proven difficult. Picking up via `run!(simulation, pickup=true)` has the downside of requiring the original run script to restart a simulation, but the advantage of simplicity. I've also updated the checkpointer documentation to describe `run!(simulation, pickup=true)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1893
https://github.com/CliMA/Oceananigans.jl/pull/1893:322,Availability,checkpoint,checkpoint,322,"This long overdue PR nukes `restore_from_checkpoint` and all its tests. We've decided to support ""picking up"" a simulation from a checkpoint instead via `run!(simulation, pickup=true)`. The reason is that we can only restore a limited subset of models that don't utilize user-defined functions. ""Restoring"" a model from a checkpoint is an error-prone processes, and supporting `restore_from_checkpoint` has proven difficult. Picking up via `run!(simulation, pickup=true)` has the downside of requiring the original run script to restart a simulation, but the advantage of simplicity. I've also updated the checkpointer documentation to describe `run!(simulation, pickup=true)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1893
https://github.com/CliMA/Oceananigans.jl/pull/1893:339,Availability,error,error-prone,339,"This long overdue PR nukes `restore_from_checkpoint` and all its tests. We've decided to support ""picking up"" a simulation from a checkpoint instead via `run!(simulation, pickup=true)`. The reason is that we can only restore a limited subset of models that don't utilize user-defined functions. ""Restoring"" a model from a checkpoint is an error-prone processes, and supporting `restore_from_checkpoint` has proven difficult. Picking up via `run!(simulation, pickup=true)` has the downside of requiring the original run script to restart a simulation, but the advantage of simplicity. I've also updated the checkpointer documentation to describe `run!(simulation, pickup=true)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1893
https://github.com/CliMA/Oceananigans.jl/pull/1893:480,Availability,down,downside,480,"This long overdue PR nukes `restore_from_checkpoint` and all its tests. We've decided to support ""picking up"" a simulation from a checkpoint instead via `run!(simulation, pickup=true)`. The reason is that we can only restore a limited subset of models that don't utilize user-defined functions. ""Restoring"" a model from a checkpoint is an error-prone processes, and supporting `restore_from_checkpoint` has proven difficult. Picking up via `run!(simulation, pickup=true)` has the downside of requiring the original run script to restart a simulation, but the advantage of simplicity. I've also updated the checkpointer documentation to describe `run!(simulation, pickup=true)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1893
https://github.com/CliMA/Oceananigans.jl/pull/1893:606,Availability,checkpoint,checkpointer,606,"This long overdue PR nukes `restore_from_checkpoint` and all its tests. We've decided to support ""picking up"" a simulation from a checkpoint instead via `run!(simulation, pickup=true)`. The reason is that we can only restore a limited subset of models that don't utilize user-defined functions. ""Restoring"" a model from a checkpoint is an error-prone processes, and supporting `restore_from_checkpoint` has proven difficult. Picking up via `run!(simulation, pickup=true)` has the downside of requiring the original run script to restart a simulation, but the advantage of simplicity. I've also updated the checkpointer documentation to describe `run!(simulation, pickup=true)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1893
https://github.com/CliMA/Oceananigans.jl/pull/1893:594,Deployability,update,updated,594,"This long overdue PR nukes `restore_from_checkpoint` and all its tests. We've decided to support ""picking up"" a simulation from a checkpoint instead via `run!(simulation, pickup=true)`. The reason is that we can only restore a limited subset of models that don't utilize user-defined functions. ""Restoring"" a model from a checkpoint is an error-prone processes, and supporting `restore_from_checkpoint` has proven difficult. Picking up via `run!(simulation, pickup=true)` has the downside of requiring the original run script to restart a simulation, but the advantage of simplicity. I've also updated the checkpointer documentation to describe `run!(simulation, pickup=true)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1893
https://github.com/CliMA/Oceananigans.jl/pull/1893:65,Testability,test,tests,65,"This long overdue PR nukes `restore_from_checkpoint` and all its tests. We've decided to support ""picking up"" a simulation from a checkpoint instead via `run!(simulation, pickup=true)`. The reason is that we can only restore a limited subset of models that don't utilize user-defined functions. ""Restoring"" a model from a checkpoint is an error-prone processes, and supporting `restore_from_checkpoint` has proven difficult. Picking up via `run!(simulation, pickup=true)` has the downside of requiring the original run script to restart a simulation, but the advantage of simplicity. I've also updated the checkpointer documentation to describe `run!(simulation, pickup=true)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1893
https://github.com/CliMA/Oceananigans.jl/pull/1893:572,Usability,simpl,simplicity,572,"This long overdue PR nukes `restore_from_checkpoint` and all its tests. We've decided to support ""picking up"" a simulation from a checkpoint instead via `run!(simulation, pickup=true)`. The reason is that we can only restore a limited subset of models that don't utilize user-defined functions. ""Restoring"" a model from a checkpoint is an error-prone processes, and supporting `restore_from_checkpoint` has proven difficult. Picking up via `run!(simulation, pickup=true)` has the downside of requiring the original run script to restart a simulation, but the advantage of simplicity. I've also updated the checkpointer documentation to describe `run!(simulation, pickup=true)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1893
https://github.com/CliMA/Oceananigans.jl/pull/1894:642,Energy Efficiency,schedul,schedule,642,"This PR implements `Callback`, designed to be used with `Simulation`. Illustration:. ```julia; using Oceananigans. model = NonhydrostaticModel(grid = RegularRectilinearGrid(size=(128, 128), extent=(2π, 2π), topology=(Periodic, Periodic, Flat)),; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; buoyancy = nothing,; tracers = nothing). set!(model, u = (x, y, z) -> randn(), v = (x, y, z) -> randn()). simulation = Simulation(model, Δt=0.01, stop_iteration=100). print_progress(sim) = @info ""Iteration: $(sim.model.clock.iteration), time: $(sim.model.clock.time)""; simulation.callbacks[:progress] = Callback(print_progress, schedule=IterationInterval(10)). run!(simulation); ```. we get. ```julia; julia> run!(simulation); [ Info: Iteration: 0, time: 0.0; [ Info: Iteration: 10, time: 0.09999999999999999; [ Info: Iteration: 20, time: 0.19999999999999984; [ Info: Iteration: 30, time: 0.30000000000000004; [ Info: Iteration: 40, time: 0.4000000000000007; [ Info: Iteration: 50, time: 0.5000000000000013; [ Info: Iteration: 60, time: 0.6000000000000003; [ Info: Iteration: 70, time: 0.6999999999999993; [ Info: Iteration: 80, time: 0.7999999999999983; [ Info: Iteration: 90, time: 0.8999999999999972; [ Info: Iteration: 100, time: 0.9999999999999962; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; ```. We also support passing an iterable of callbacks to `run!`:. ```julia; progress_callback = Callback(print_progress, schedule=IterationInterval(10)); run!(simulation, callbacks=[progress_callback]); ```. just in case someone wants to do that... I think we could also redesign `TimeStepWizard` to be a special kind of `Callback`, and nuke the `progress` property. What do others think? Are they ok with this big change to the API?. cc @navidcy @ali-ramadhan @francispoulin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894
https://github.com/CliMA/Oceananigans.jl/pull/1894:1493,Energy Efficiency,schedul,schedule,1493,"This PR implements `Callback`, designed to be used with `Simulation`. Illustration:. ```julia; using Oceananigans. model = NonhydrostaticModel(grid = RegularRectilinearGrid(size=(128, 128), extent=(2π, 2π), topology=(Periodic, Periodic, Flat)),; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; buoyancy = nothing,; tracers = nothing). set!(model, u = (x, y, z) -> randn(), v = (x, y, z) -> randn()). simulation = Simulation(model, Δt=0.01, stop_iteration=100). print_progress(sim) = @info ""Iteration: $(sim.model.clock.iteration), time: $(sim.model.clock.time)""; simulation.callbacks[:progress] = Callback(print_progress, schedule=IterationInterval(10)). run!(simulation); ```. we get. ```julia; julia> run!(simulation); [ Info: Iteration: 0, time: 0.0; [ Info: Iteration: 10, time: 0.09999999999999999; [ Info: Iteration: 20, time: 0.19999999999999984; [ Info: Iteration: 30, time: 0.30000000000000004; [ Info: Iteration: 40, time: 0.4000000000000007; [ Info: Iteration: 50, time: 0.5000000000000013; [ Info: Iteration: 60, time: 0.6000000000000003; [ Info: Iteration: 70, time: 0.6999999999999993; [ Info: Iteration: 80, time: 0.7999999999999983; [ Info: Iteration: 90, time: 0.8999999999999972; [ Info: Iteration: 100, time: 0.9999999999999962; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; ```. We also support passing an iterable of callbacks to `run!`:. ```julia; progress_callback = Callback(print_progress, schedule=IterationInterval(10)); run!(simulation, callbacks=[progress_callback]); ```. just in case someone wants to do that... I think we could also redesign `TimeStepWizard` to be a special kind of `Callback`, and nuke the `progress` property. What do others think? Are they ok with this big change to the API?. cc @navidcy @ali-ramadhan @francispoulin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1894
https://github.com/CliMA/Oceananigans.jl/issues/1895:295,Deployability,integrat,integrator,295,"> @glwagner at some point it might good to think about whether exposing similar interfaces to DiffEq ( e.g. https://diffeq.sciml.ai/dev/features/callback_functions/#The-Callback-Types ) makes sense. Probably for the future.; > ; > Same could go for run! (e.g. https://diffeq.sciml.ai/dev/basics/integrator/#Initialization-and-Stepping ) too?. Ah wow, that is epic. I think what's implemented here is more or less analogous to `DiscreteCallback`. Reading over the features there makes me realize that we probably want to ""align"" the time-step (somehow, similar to the root finding feature that's provided for DiffEq) for callbacks. We align time-steps for output, but not for callbacks (yet). That would be nice to add. I think we could also add an analog of the ""continuous callback"" --- to the models, not the simulations --- that's executed during `update_state!`, and therefore can be thought of as a function that ""continuously"" (eg valid at every moment in time) modifies the state of the model. Perhaps `StateModifier` or something like that? These objects would not have a schedule since they'd always be executed. Initialization and finalization might be good wishlist features too for both. _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/1894#issuecomment-885979847_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895
https://github.com/CliMA/Oceananigans.jl/issues/1895:763,Deployability,continuous,continuous,763,"> @glwagner at some point it might good to think about whether exposing similar interfaces to DiffEq ( e.g. https://diffeq.sciml.ai/dev/features/callback_functions/#The-Callback-Types ) makes sense. Probably for the future.; > ; > Same could go for run! (e.g. https://diffeq.sciml.ai/dev/basics/integrator/#Initialization-and-Stepping ) too?. Ah wow, that is epic. I think what's implemented here is more or less analogous to `DiscreteCallback`. Reading over the features there makes me realize that we probably want to ""align"" the time-step (somehow, similar to the root finding feature that's provided for DiffEq) for callbacks. We align time-steps for output, but not for callbacks (yet). That would be nice to add. I think we could also add an analog of the ""continuous callback"" --- to the models, not the simulations --- that's executed during `update_state!`, and therefore can be thought of as a function that ""continuously"" (eg valid at every moment in time) modifies the state of the model. Perhaps `StateModifier` or something like that? These objects would not have a schedule since they'd always be executed. Initialization and finalization might be good wishlist features too for both. _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/1894#issuecomment-885979847_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895
https://github.com/CliMA/Oceananigans.jl/issues/1895:919,Deployability,continuous,continuously,919,"> @glwagner at some point it might good to think about whether exposing similar interfaces to DiffEq ( e.g. https://diffeq.sciml.ai/dev/features/callback_functions/#The-Callback-Types ) makes sense. Probably for the future.; > ; > Same could go for run! (e.g. https://diffeq.sciml.ai/dev/basics/integrator/#Initialization-and-Stepping ) too?. Ah wow, that is epic. I think what's implemented here is more or less analogous to `DiscreteCallback`. Reading over the features there makes me realize that we probably want to ""align"" the time-step (somehow, similar to the root finding feature that's provided for DiffEq) for callbacks. We align time-steps for output, but not for callbacks (yet). That would be nice to add. I think we could also add an analog of the ""continuous callback"" --- to the models, not the simulations --- that's executed during `update_state!`, and therefore can be thought of as a function that ""continuously"" (eg valid at every moment in time) modifies the state of the model. Perhaps `StateModifier` or something like that? These objects would not have a schedule since they'd always be executed. Initialization and finalization might be good wishlist features too for both. _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/1894#issuecomment-885979847_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895
https://github.com/CliMA/Oceananigans.jl/issues/1895:1080,Energy Efficiency,schedul,schedule,1080,"> @glwagner at some point it might good to think about whether exposing similar interfaces to DiffEq ( e.g. https://diffeq.sciml.ai/dev/features/callback_functions/#The-Callback-Types ) makes sense. Probably for the future.; > ; > Same could go for run! (e.g. https://diffeq.sciml.ai/dev/basics/integrator/#Initialization-and-Stepping ) too?. Ah wow, that is epic. I think what's implemented here is more or less analogous to `DiscreteCallback`. Reading over the features there makes me realize that we probably want to ""align"" the time-step (somehow, similar to the root finding feature that's provided for DiffEq) for callbacks. We align time-steps for output, but not for callbacks (yet). That would be nice to add. I think we could also add an analog of the ""continuous callback"" --- to the models, not the simulations --- that's executed during `update_state!`, and therefore can be thought of as a function that ""continuously"" (eg valid at every moment in time) modifies the state of the model. Perhaps `StateModifier` or something like that? These objects would not have a schedule since they'd always be executed. Initialization and finalization might be good wishlist features too for both. _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/1894#issuecomment-885979847_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895
https://github.com/CliMA/Oceananigans.jl/issues/1895:80,Integrability,interface,interfaces,80,"> @glwagner at some point it might good to think about whether exposing similar interfaces to DiffEq ( e.g. https://diffeq.sciml.ai/dev/features/callback_functions/#The-Callback-Types ) makes sense. Probably for the future.; > ; > Same could go for run! (e.g. https://diffeq.sciml.ai/dev/basics/integrator/#Initialization-and-Stepping ) too?. Ah wow, that is epic. I think what's implemented here is more or less analogous to `DiscreteCallback`. Reading over the features there makes me realize that we probably want to ""align"" the time-step (somehow, similar to the root finding feature that's provided for DiffEq) for callbacks. We align time-steps for output, but not for callbacks (yet). That would be nice to add. I think we could also add an analog of the ""continuous callback"" --- to the models, not the simulations --- that's executed during `update_state!`, and therefore can be thought of as a function that ""continuously"" (eg valid at every moment in time) modifies the state of the model. Perhaps `StateModifier` or something like that? These objects would not have a schedule since they'd always be executed. Initialization and finalization might be good wishlist features too for both. _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/1894#issuecomment-885979847_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895
https://github.com/CliMA/Oceananigans.jl/issues/1895:295,Integrability,integrat,integrator,295,"> @glwagner at some point it might good to think about whether exposing similar interfaces to DiffEq ( e.g. https://diffeq.sciml.ai/dev/features/callback_functions/#The-Callback-Types ) makes sense. Probably for the future.; > ; > Same could go for run! (e.g. https://diffeq.sciml.ai/dev/basics/integrator/#Initialization-and-Stepping ) too?. Ah wow, that is epic. I think what's implemented here is more or less analogous to `DiscreteCallback`. Reading over the features there makes me realize that we probably want to ""align"" the time-step (somehow, similar to the root finding feature that's provided for DiffEq) for callbacks. We align time-steps for output, but not for callbacks (yet). That would be nice to add. I think we could also add an analog of the ""continuous callback"" --- to the models, not the simulations --- that's executed during `update_state!`, and therefore can be thought of as a function that ""continuously"" (eg valid at every moment in time) modifies the state of the model. Perhaps `StateModifier` or something like that? These objects would not have a schedule since they'd always be executed. Initialization and finalization might be good wishlist features too for both. _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/1894#issuecomment-885979847_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895
https://github.com/CliMA/Oceananigans.jl/pull/1902:139,Performance,perform,performance,139,The results over at https://github.com/glwagner/multithreaded-stencils suggest that we could be leaving as much as 2x on the table for CPU performance by choosing a non-optimal group size for multithreading. This PR changes the group size on the CPU. @hennyg888 could be good to runs some benchmarks to see if this improves our CPU / multithreading situation!,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902
https://github.com/CliMA/Oceananigans.jl/pull/1902:289,Testability,benchmark,benchmarks,289,The results over at https://github.com/glwagner/multithreaded-stencils suggest that we could be leaving as much as 2x on the table for CPU performance by choosing a non-optimal group size for multithreading. This PR changes the group size on the CPU. @hennyg888 could be good to runs some benchmarks to see if this improves our CPU / multithreading situation!,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1902
https://github.com/CliMA/Oceananigans.jl/pull/1903:565,Deployability,patch,patch,565,"`Oceananigans.OutputReaders.FieldDataset` used to just be a `Dict{String,FieldTimeSeries}` but now it is a struct that also stores a dictionary metadata and a filepath. This PR also adds some quality of life features to `Oceananigans.OutputReaders.FieldDataset`:; 1. A list of metadata paths can be specified. Some scripts use `file[""metadata""]` but others might use `file[""parameters""]` (or potentially both).; 2. A `grid` and `ArrayType` may be specified at the `FieldDataset` level which is then passed to `FieldTimeSeries` constructors. Hoping to also bump the patch version along with this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1903
https://github.com/CliMA/Oceananigans.jl/pull/1906:54,Energy Efficiency,adapt,adapting,54,This is the latest attempt to preserve locations when adapting `Field` to the GPU.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1906
https://github.com/CliMA/Oceananigans.jl/pull/1906:54,Modifiability,adapt,adapting,54,This is the latest attempt to preserve locations when adapting `Field` to the GPU.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1906
https://github.com/CliMA/Oceananigans.jl/pull/1910:133,Deployability,integrat,integrating,133,"This PR inserts the vertical buoyant acceleration directly into the vertical momentum equation in `NonhydrostaticModel`, rather than integrating to find the hydrostatic pressure and inserting its gradient into the horizontal momentum equations. I just did the easiest thing right because I'm curious if regression tests pass. If they do, we can refactor `NonhydrostaticModel` to eliminate hydrostatic pressure, speed up the model, and reduce its memory footprint without too much pain (🎉). If the regression tests don't pass, we will unfortunately have slightly more pain ahead of us in refactoring the regression tests. In addition to the above advantages, we also need to eliminate vertical integrals in `NonhydrostaticModel` to permit 2D distributed memory parallelization. This is because `PencilFFTs` only allows parallelization across dimensions higher than 1 (or in other words, we cannot parallelize in `x`). Thus with a vertical integral, we can only parallelize easily across `y`. If we eliminate the vertical integral, we'll be able to parallelize in `y, z`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910
https://github.com/CliMA/Oceananigans.jl/pull/1910:435,Energy Efficiency,reduce,reduce,435,"This PR inserts the vertical buoyant acceleration directly into the vertical momentum equation in `NonhydrostaticModel`, rather than integrating to find the hydrostatic pressure and inserting its gradient into the horizontal momentum equations. I just did the easiest thing right because I'm curious if regression tests pass. If they do, we can refactor `NonhydrostaticModel` to eliminate hydrostatic pressure, speed up the model, and reduce its memory footprint without too much pain (🎉). If the regression tests don't pass, we will unfortunately have slightly more pain ahead of us in refactoring the regression tests. In addition to the above advantages, we also need to eliminate vertical integrals in `NonhydrostaticModel` to permit 2D distributed memory parallelization. This is because `PencilFFTs` only allows parallelization across dimensions higher than 1 (or in other words, we cannot parallelize in `x`). Thus with a vertical integral, we can only parallelize easily across `y`. If we eliminate the vertical integral, we'll be able to parallelize in `y, z`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910
https://github.com/CliMA/Oceananigans.jl/pull/1910:133,Integrability,integrat,integrating,133,"This PR inserts the vertical buoyant acceleration directly into the vertical momentum equation in `NonhydrostaticModel`, rather than integrating to find the hydrostatic pressure and inserting its gradient into the horizontal momentum equations. I just did the easiest thing right because I'm curious if regression tests pass. If they do, we can refactor `NonhydrostaticModel` to eliminate hydrostatic pressure, speed up the model, and reduce its memory footprint without too much pain (🎉). If the regression tests don't pass, we will unfortunately have slightly more pain ahead of us in refactoring the regression tests. In addition to the above advantages, we also need to eliminate vertical integrals in `NonhydrostaticModel` to permit 2D distributed memory parallelization. This is because `PencilFFTs` only allows parallelization across dimensions higher than 1 (or in other words, we cannot parallelize in `x`). Thus with a vertical integral, we can only parallelize easily across `y`. If we eliminate the vertical integral, we'll be able to parallelize in `y, z`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910
https://github.com/CliMA/Oceananigans.jl/pull/1910:345,Modifiability,refactor,refactor,345,"This PR inserts the vertical buoyant acceleration directly into the vertical momentum equation in `NonhydrostaticModel`, rather than integrating to find the hydrostatic pressure and inserting its gradient into the horizontal momentum equations. I just did the easiest thing right because I'm curious if regression tests pass. If they do, we can refactor `NonhydrostaticModel` to eliminate hydrostatic pressure, speed up the model, and reduce its memory footprint without too much pain (🎉). If the regression tests don't pass, we will unfortunately have slightly more pain ahead of us in refactoring the regression tests. In addition to the above advantages, we also need to eliminate vertical integrals in `NonhydrostaticModel` to permit 2D distributed memory parallelization. This is because `PencilFFTs` only allows parallelization across dimensions higher than 1 (or in other words, we cannot parallelize in `x`). Thus with a vertical integral, we can only parallelize easily across `y`. If we eliminate the vertical integral, we'll be able to parallelize in `y, z`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910
https://github.com/CliMA/Oceananigans.jl/pull/1910:587,Modifiability,refactor,refactoring,587,"This PR inserts the vertical buoyant acceleration directly into the vertical momentum equation in `NonhydrostaticModel`, rather than integrating to find the hydrostatic pressure and inserting its gradient into the horizontal momentum equations. I just did the easiest thing right because I'm curious if regression tests pass. If they do, we can refactor `NonhydrostaticModel` to eliminate hydrostatic pressure, speed up the model, and reduce its memory footprint without too much pain (🎉). If the regression tests don't pass, we will unfortunately have slightly more pain ahead of us in refactoring the regression tests. In addition to the above advantages, we also need to eliminate vertical integrals in `NonhydrostaticModel` to permit 2D distributed memory parallelization. This is because `PencilFFTs` only allows parallelization across dimensions higher than 1 (or in other words, we cannot parallelize in `x`). Thus with a vertical integral, we can only parallelize easily across `y`. If we eliminate the vertical integral, we'll be able to parallelize in `y, z`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910
https://github.com/CliMA/Oceananigans.jl/pull/1910:314,Testability,test,tests,314,"This PR inserts the vertical buoyant acceleration directly into the vertical momentum equation in `NonhydrostaticModel`, rather than integrating to find the hydrostatic pressure and inserting its gradient into the horizontal momentum equations. I just did the easiest thing right because I'm curious if regression tests pass. If they do, we can refactor `NonhydrostaticModel` to eliminate hydrostatic pressure, speed up the model, and reduce its memory footprint without too much pain (🎉). If the regression tests don't pass, we will unfortunately have slightly more pain ahead of us in refactoring the regression tests. In addition to the above advantages, we also need to eliminate vertical integrals in `NonhydrostaticModel` to permit 2D distributed memory parallelization. This is because `PencilFFTs` only allows parallelization across dimensions higher than 1 (or in other words, we cannot parallelize in `x`). Thus with a vertical integral, we can only parallelize easily across `y`. If we eliminate the vertical integral, we'll be able to parallelize in `y, z`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910
https://github.com/CliMA/Oceananigans.jl/pull/1910:508,Testability,test,tests,508,"This PR inserts the vertical buoyant acceleration directly into the vertical momentum equation in `NonhydrostaticModel`, rather than integrating to find the hydrostatic pressure and inserting its gradient into the horizontal momentum equations. I just did the easiest thing right because I'm curious if regression tests pass. If they do, we can refactor `NonhydrostaticModel` to eliminate hydrostatic pressure, speed up the model, and reduce its memory footprint without too much pain (🎉). If the regression tests don't pass, we will unfortunately have slightly more pain ahead of us in refactoring the regression tests. In addition to the above advantages, we also need to eliminate vertical integrals in `NonhydrostaticModel` to permit 2D distributed memory parallelization. This is because `PencilFFTs` only allows parallelization across dimensions higher than 1 (or in other words, we cannot parallelize in `x`). Thus with a vertical integral, we can only parallelize easily across `y`. If we eliminate the vertical integral, we'll be able to parallelize in `y, z`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910
https://github.com/CliMA/Oceananigans.jl/pull/1910:614,Testability,test,tests,614,"This PR inserts the vertical buoyant acceleration directly into the vertical momentum equation in `NonhydrostaticModel`, rather than integrating to find the hydrostatic pressure and inserting its gradient into the horizontal momentum equations. I just did the easiest thing right because I'm curious if regression tests pass. If they do, we can refactor `NonhydrostaticModel` to eliminate hydrostatic pressure, speed up the model, and reduce its memory footprint without too much pain (🎉). If the regression tests don't pass, we will unfortunately have slightly more pain ahead of us in refactoring the regression tests. In addition to the above advantages, we also need to eliminate vertical integrals in `NonhydrostaticModel` to permit 2D distributed memory parallelization. This is because `PencilFFTs` only allows parallelization across dimensions higher than 1 (or in other words, we cannot parallelize in `x`). Thus with a vertical integral, we can only parallelize easily across `y`. If we eliminate the vertical integral, we'll be able to parallelize in `y, z`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910
https://github.com/CliMA/Oceananigans.jl/pull/1911:187,Testability,test,tested,187,"This pull request changes the compat entry for the `MPI` package from `0.16, 0.17, 0.18` to `0.16, 0.17, 0.18, 0.19`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1911
https://github.com/CliMA/Oceananigans.jl/pull/1911:292,Testability,test,tests,292,"This pull request changes the compat entry for the `MPI` package from `0.16, 0.17, 0.18` to `0.16, 0.17, 0.18, 0.19`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1911
https://github.com/CliMA/Oceananigans.jl/issues/1912:1134,Availability,avail,available,1134,"ling process 104758, command: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project benchmarkable_incompressible_model.jl. Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.2.89, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.2; - CUFFT: 10.1.2; - CUSOLVER: 10.3.0; - CUSPARSE: 10.3.1; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.432 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); nothing. [2021/07/30 10:27:44.108] INFO Setting up benchmark: (GPU, Float64, 128)...; [2021/07/30 10:28:25.970] INFO warming up; [2021/07/30 10:29:55.456] WARN Calling CUDA.@profile only informs an external profiler to start.; The user is responsible for launching Julia under a CUDA profiler. It is recommended to use Nsight Systems, which supports interactive profiling:; $ nsys launch julia -@-> /home/henryguo/.julia/packages/CUDA/lwSps/lib/cudadrv/profile.jl:71; [2021/07/30 10:29:58.016] INFO done profiling (GPU, Float64, 128); ==104758== Profiling application: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project benchmarkable_incompressible_model.jl; ==104758== Profiling result:; Type Time(%) Time Calls Avg Min Max Name; GPU activities: 12.29% 502.36us 5 100.47us 94.015us 103.42us _Z25julia_gpu_ab2_step_field_7ContextI14__CUDACtx_Namevv14__PassType_257v12DisableHooksE20_gpu_ab2_step_field_16CompilerMe",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912
https://github.com/CliMA/Oceananigans.jl/issues/1912:1202,Availability,avail,available,1202,"projects/henry-test/julia-1.6.2/bin/julia --project benchmarkable_incompressible_model.jl. Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.2.89, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.2; - CUFFT: 10.1.2; - CUSOLVER: 10.3.0; - CUSPARSE: 10.3.1; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.432 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); nothing. [2021/07/30 10:27:44.108] INFO Setting up benchmark: (GPU, Float64, 128)...; [2021/07/30 10:28:25.970] INFO warming up; [2021/07/30 10:29:55.456] WARN Calling CUDA.@profile only informs an external profiler to start.; The user is responsible for launching Julia under a CUDA profiler. It is recommended to use Nsight Systems, which supports interactive profiling:; $ nsys launch julia -@-> /home/henryguo/.julia/packages/CUDA/lwSps/lib/cudadrv/profile.jl:71; [2021/07/30 10:29:58.016] INFO done profiling (GPU, Float64, 128); ==104758== Profiling application: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project benchmarkable_incompressible_model.jl; ==104758== Profiling result:; Type Time(%) Time Calls Avg Min Max Name; GPU activities: 12.29% 502.36us 5 100.47us 94.015us 103.42us _Z25julia_gpu_ab2_step_field_7ContextI14__CUDACtx_Namevv14__PassType_257v12DisableHooksE20_gpu_ab2_step_field_16CompilerMetadataI10StaticSizeI15_128__128__128_E12DynamicCheckvv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912
https://github.com/CliMA/Oceananigans.jl/issues/1912:583,Deployability,install,installation,583,"Here are some profiling results that were done on Satori with nvprof. This is a GPU profile of the nonhydrostatic model.; ```; ==104758== NVPROF is profiling process 104758, command: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project benchmarkable_incompressible_model.jl. Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.2.89, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.2; - CUFFT: 10.1.2; - CUSOLVER: 10.3.0; - CUSPARSE: 10.3.1; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.432 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); nothing. [2021/07/30 10:27:44.108] INFO Setting up benchmark: (GPU, Float64, 128)...; [2021/07/30 10:28:25.970] INFO warming up; [2021/07/30 10:29:55.456] WARN Calling CUDA.@profile only informs an external profiler to start.; The user is responsible for launching Julia under a CUDA profiler. It is recommended to use Nsight Systems, which supports interactive profiling:; $ nsys launch julia -@-> /home/henryguo/.julia/packages/CUDA/lwSps/lib/cudadrv/profile.jl:71; [2021/07/30 10:29:58.016] INFO done profiling (GPU, Float64, 128); ==104758== Profiling application: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project benchmarkable_incompressible_model.jl; ==104758== Profiling result:; Type Time(%) Time Calls Avg Min Max Name; GPU activities: 12.29% 502.36u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912
https://github.com/CliMA/Oceananigans.jl/issues/1912:223,Testability,test,test,223,"Here are some profiling results that were done on Satori with nvprof. This is a GPU profile of the nonhydrostatic model.; ```; ==104758== NVPROF is profiling process 104758, command: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project benchmarkable_incompressible_model.jl. Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.2.89, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.2; - CUFFT: 10.1.2; - CUSOLVER: 10.3.0; - CUSPARSE: 10.3.1; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.432 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); nothing. [2021/07/30 10:27:44.108] INFO Setting up benchmark: (GPU, Float64, 128)...; [2021/07/30 10:28:25.970] INFO warming up; [2021/07/30 10:29:55.456] WARN Calling CUDA.@profile only informs an external profiler to start.; The user is responsible for launching Julia under a CUDA profiler. It is recommended to use Nsight Systems, which supports interactive profiling:; $ nsys launch julia -@-> /home/henryguo/.julia/packages/CUDA/lwSps/lib/cudadrv/profile.jl:71; [2021/07/30 10:29:58.016] INFO done profiling (GPU, Float64, 128); ==104758== Profiling application: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project benchmarkable_incompressible_model.jl; ==104758== Profiling result:; Type Time(%) Time Calls Avg Min Max Name; GPU activities: 12.29% 502.36u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912
https://github.com/CliMA/Oceananigans.jl/issues/1912:1265,Testability,benchmark,benchmark,1265,"ble_incompressible_model.jl. Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.2.89, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0. Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.2; - CUFFT: 10.1.2; - CUSOLVER: 10.3.0; - CUSPARSE: 10.3.1; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.432 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); nothing. [2021/07/30 10:27:44.108] INFO Setting up benchmark: (GPU, Float64, 128)...; [2021/07/30 10:28:25.970] INFO warming up; [2021/07/30 10:29:55.456] WARN Calling CUDA.@profile only informs an external profiler to start.; The user is responsible for launching Julia under a CUDA profiler. It is recommended to use Nsight Systems, which supports interactive profiling:; $ nsys launch julia -@-> /home/henryguo/.julia/packages/CUDA/lwSps/lib/cudadrv/profile.jl:71; [2021/07/30 10:29:58.016] INFO done profiling (GPU, Float64, 128); ==104758== Profiling application: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project benchmarkable_incompressible_model.jl; ==104758== Profiling result:; Type Time(%) Time Calls Avg Min Max Name; GPU activities: 12.29% 502.36us 5 100.47us 94.015us 103.42us _Z25julia_gpu_ab2_step_field_7ContextI14__CUDACtx_Namevv14__PassType_257v12DisableHooksE20_gpu_ab2_step_field_16CompilerMetadataI10StaticSizeI15_128__128__128_E12DynamicCheckvv7NDRangeILi3ES5_I11_8__8__128_ES5_I11_16__16__1_EvvEE11OffsetA",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912
https://github.com/CliMA/Oceananigans.jl/issues/1912:1823,Testability,test,test,1823,"L: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing. Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4, 6.5; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75. 2 devices:; 0: Tesla V100-SXM2-32GB (sm_70, 31.432 GiB / 31.749 GiB available); 1: Tesla V100-SXM2-32GB (sm_70, 31.738 GiB / 31.749 GiB available); nothing. [2021/07/30 10:27:44.108] INFO Setting up benchmark: (GPU, Float64, 128)...; [2021/07/30 10:28:25.970] INFO warming up; [2021/07/30 10:29:55.456] WARN Calling CUDA.@profile only informs an external profiler to start.; The user is responsible for launching Julia under a CUDA profiler. It is recommended to use Nsight Systems, which supports interactive profiling:; $ nsys launch julia -@-> /home/henryguo/.julia/packages/CUDA/lwSps/lib/cudadrv/profile.jl:71; [2021/07/30 10:29:58.016] INFO done profiling (GPU, Float64, 128); ==104758== Profiling application: /nobackup/users/henryguo/projects/henry-test/julia-1.6.2/bin/julia --project benchmarkable_incompressible_model.jl; ==104758== Profiling result:; Type Time(%) Time Calls Avg Min Max Name; GPU activities: 12.29% 502.36us 5 100.47us 94.015us 103.42us _Z25julia_gpu_ab2_step_field_7ContextI14__CUDACtx_Namevv14__PassType_257v12DisableHooksE20_gpu_ab2_step_field_16CompilerMetadataI10StaticSizeI15_128__128__128_E12DynamicCheckvv7NDRangeILi3ES5_I11_8__8__128_ES5_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE5Int64S9_S8_IS9_Li3ES10_IS9_Li3ELi1EEES8_IS9_Li3ES10_IS9_Li3ELi1EEE; 9.47% 386.91us 4 96.727us 88.672us 105.02us void regular_fft<unsigned int=128, unsigned int=8, unsigned int=16, padding_t=1, twiddle_t=0, loadstore_modifier_t=2, layout_t=1, unsigned int, double>(kernel_arguments_t<unsigned int>); 6.69% 273.47us 5 54.694us 53.503us 56.800us _Z33julia_gpu_store_field_tendencies_7ContextI14__CUDACtx_Namevv14__PassType_257v12DisableHooksE28_gpu_store_f",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912
https://github.com/CliMA/Oceananigans.jl/pull/1916:2105,Integrability,interface,interface,2105,"); return nothing; end; ```. Air-sea fluxes are computed in `update_state!`:. ```julia; # Use broadcasting to compute bulk formula for surface wind stress; topo = topology(atmos_grid); Nx, Ny, Nz = size(atmos_grid); Hx, Hy, Hz = atmos_grid.Hx, atmos_grid.Hy, atmos_grid.Hz; ii = Hx+1:Hx+Nx; jj = topo[2]() isa Flat ? 1 : Hy+1:Hy+Ny # hack because 2D can be fun; k = atmos_grid.Hz+1 # surface atmospheric velocity; ua₁ = view(parent(ua), ii, jj, k:k); va₁ = view(parent(va), ii, jj, k:k). @. atmos_surface_flux_u = - cᴰ * ua₁ * sqrt(ua₁^2 + va₁^2); @. atmos_surface_flux_v = - cᴰ * va₁ * sqrt(ua₁^2 + va₁^2). @. ocean_surface_flux_u = ρ_atmos / ρ_ocean * atmos_surface_flux_u; @. ocean_surface_flux_v = ρ_atmos / ρ_ocean * atmos_surface_flux_v; ```. A few tweaks to how output writers work (making them function more like callbacks) makes output work with the coupled models, too. This PR also contributes a simple boundary layer turbulence example. The setup is not very user-friendly right now, but this PR shows that this sort of science is possible. In short, this is accomplished by building two Oceananigans models and passing them to `CoupledAtmosphereOceanModel`. ## Notes on how development could proceed . To make the setup more user friendly, this abstraction should probably include:. * more automated grid creation that ensure horizontal domains are the same extent; * better bulk formulae that include heat fluxes, salt fluxes, and trace gas fluxes; * automated generation + checking of interface boundary condition arrays. A short feature wish list might be. * budget preserving interpolation between horizontal grids of different resolution; * multi-rate time-stepping / sub-stepping of 'fast' model components; * compressible atmospheric model (:-D). Once I get this going on the GPU and tweak parameters I'll post a visualization. For now we'll have to be satisfied with. ![image](https://user-images.githubusercontent.com/15271942/127759981-e9b15398-8484-4e63-ad29-3ef7f9462472.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1916
https://github.com/CliMA/Oceananigans.jl/pull/1916:100,Usability,simpl,simple,100,"This PR prototypes a concept for a coupled atmosphere-ocean model. This introduces a new relatively simple `AbstractModel` type:. ```julia; struct CoupledAtmosphereOceanModel{O, A, C, P} <: AbstractModel{Nothing}; atmos :: A; ocean :: O; clock :: C; air_sea_flux_parameters :: P; end; ```. which defines a new `update_state!` that computes bulk formulae, and a `time_step!` that looks like. ```julia; function time_step!(coupled_model::CoupledAtmosphereOceanModel, Δt; euler=false); time_step!(coupled_model.ocean, Δt; euler); time_step!(coupled_model.atmos, Δt; euler); update_state!(coupled_model, false); return nothing; end; ```. Air-sea fluxes are computed in `update_state!`:. ```julia; # Use broadcasting to compute bulk formula for surface wind stress; topo = topology(atmos_grid); Nx, Ny, Nz = size(atmos_grid); Hx, Hy, Hz = atmos_grid.Hx, atmos_grid.Hy, atmos_grid.Hz; ii = Hx+1:Hx+Nx; jj = topo[2]() isa Flat ? 1 : Hy+1:Hy+Ny # hack because 2D can be fun; k = atmos_grid.Hz+1 # surface atmospheric velocity; ua₁ = view(parent(ua), ii, jj, k:k); va₁ = view(parent(va), ii, jj, k:k). @. atmos_surface_flux_u = - cᴰ * ua₁ * sqrt(ua₁^2 + va₁^2); @. atmos_surface_flux_v = - cᴰ * va₁ * sqrt(ua₁^2 + va₁^2). @. ocean_surface_flux_u = ρ_atmos / ρ_ocean * atmos_surface_flux_u; @. ocean_surface_flux_v = ρ_atmos / ρ_ocean * atmos_surface_flux_v; ```. A few tweaks to how output writers work (making them function more like callbacks) makes output work with the coupled models, too. This PR also contributes a simple boundary layer turbulence example. The setup is not very user-friendly right now, but this PR shows that this sort of science is possible. In short, this is accomplished by building two Oceananigans models and passing them to `CoupledAtmosphereOceanModel`. ## Notes on how development could proceed . To make the setup more user friendly, this abstraction should probably include:. * more automated grid creation that ensure horizontal domains are the same extent; * better bulk for",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1916
https://github.com/CliMA/Oceananigans.jl/pull/1916:1512,Usability,simpl,simple,1512," euler); time_step!(coupled_model.atmos, Δt; euler); update_state!(coupled_model, false); return nothing; end; ```. Air-sea fluxes are computed in `update_state!`:. ```julia; # Use broadcasting to compute bulk formula for surface wind stress; topo = topology(atmos_grid); Nx, Ny, Nz = size(atmos_grid); Hx, Hy, Hz = atmos_grid.Hx, atmos_grid.Hy, atmos_grid.Hz; ii = Hx+1:Hx+Nx; jj = topo[2]() isa Flat ? 1 : Hy+1:Hy+Ny # hack because 2D can be fun; k = atmos_grid.Hz+1 # surface atmospheric velocity; ua₁ = view(parent(ua), ii, jj, k:k); va₁ = view(parent(va), ii, jj, k:k). @. atmos_surface_flux_u = - cᴰ * ua₁ * sqrt(ua₁^2 + va₁^2); @. atmos_surface_flux_v = - cᴰ * va₁ * sqrt(ua₁^2 + va₁^2). @. ocean_surface_flux_u = ρ_atmos / ρ_ocean * atmos_surface_flux_u; @. ocean_surface_flux_v = ρ_atmos / ρ_ocean * atmos_surface_flux_v; ```. A few tweaks to how output writers work (making them function more like callbacks) makes output work with the coupled models, too. This PR also contributes a simple boundary layer turbulence example. The setup is not very user-friendly right now, but this PR shows that this sort of science is possible. In short, this is accomplished by building two Oceananigans models and passing them to `CoupledAtmosphereOceanModel`. ## Notes on how development could proceed . To make the setup more user friendly, this abstraction should probably include:. * more automated grid creation that ensure horizontal domains are the same extent; * better bulk formulae that include heat fluxes, salt fluxes, and trace gas fluxes; * automated generation + checking of interface boundary condition arrays. A short feature wish list might be. * budget preserving interpolation between horizontal grids of different resolution; * multi-rate time-stepping / sub-stepping of 'fast' model components; * compressible atmospheric model (:-D). Once I get this going on the GPU and tweak parameters I'll post a visualization. For now we'll have to be satisfied with. ![image](https://user-ima",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1916
https://github.com/CliMA/Oceananigans.jl/pull/1916:1576,Usability,user-friendly,user-friendly,1576,"); return nothing; end; ```. Air-sea fluxes are computed in `update_state!`:. ```julia; # Use broadcasting to compute bulk formula for surface wind stress; topo = topology(atmos_grid); Nx, Ny, Nz = size(atmos_grid); Hx, Hy, Hz = atmos_grid.Hx, atmos_grid.Hy, atmos_grid.Hz; ii = Hx+1:Hx+Nx; jj = topo[2]() isa Flat ? 1 : Hy+1:Hy+Ny # hack because 2D can be fun; k = atmos_grid.Hz+1 # surface atmospheric velocity; ua₁ = view(parent(ua), ii, jj, k:k); va₁ = view(parent(va), ii, jj, k:k). @. atmos_surface_flux_u = - cᴰ * ua₁ * sqrt(ua₁^2 + va₁^2); @. atmos_surface_flux_v = - cᴰ * va₁ * sqrt(ua₁^2 + va₁^2). @. ocean_surface_flux_u = ρ_atmos / ρ_ocean * atmos_surface_flux_u; @. ocean_surface_flux_v = ρ_atmos / ρ_ocean * atmos_surface_flux_v; ```. A few tweaks to how output writers work (making them function more like callbacks) makes output work with the coupled models, too. This PR also contributes a simple boundary layer turbulence example. The setup is not very user-friendly right now, but this PR shows that this sort of science is possible. In short, this is accomplished by building two Oceananigans models and passing them to `CoupledAtmosphereOceanModel`. ## Notes on how development could proceed . To make the setup more user friendly, this abstraction should probably include:. * more automated grid creation that ensure horizontal domains are the same extent; * better bulk formulae that include heat fluxes, salt fluxes, and trace gas fluxes; * automated generation + checking of interface boundary condition arrays. A short feature wish list might be. * budget preserving interpolation between horizontal grids of different resolution; * multi-rate time-stepping / sub-stepping of 'fast' model components; * compressible atmospheric model (:-D). Once I get this going on the GPU and tweak parameters I'll post a visualization. For now we'll have to be satisfied with. ![image](https://user-images.githubusercontent.com/15271942/127759981-e9b15398-8484-4e63-ad29-3ef7f9462472.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1916
https://github.com/CliMA/Oceananigans.jl/pull/1917:68,Availability,robust,robust,68,"This PR initializes `u` and `v` separately and in a way that's more robust to user changes to the script (for example, if users change the grid topology). Resolves #1656 . Thanks @jmbeckers for pointing out this issue (apologies it took so long to resolve!)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1917
https://github.com/CliMA/Oceananigans.jl/issues/1918:260,Availability,down,down,260,"For complicated models and examples, user-defined forcing functions can impose significant penalties on simulation performance. In addition to that, models with extensive and complicated diagnostics (especially those involving time-averaging) can further slow down time-to-science. It thus might be useful to provide some utilities that make benchmarking forcing functions, boundary condition functions, and diagnostics a bit easier. For forcing functions, I think a utility that benchmarks time-stepping for two models that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918
https://github.com/CliMA/Oceananigans.jl/issues/1918:1009,Integrability,wrap,wrapper,1009,"icant penalties on simulation performance. In addition to that, models with extensive and complicated diagnostics (especially those involving time-averaging) can further slow down time-to-science. It thus might be useful to provide some utilities that make benchmarking forcing functions, boundary condition functions, and diagnostics a bit easier. For forcing functions, I think a utility that benchmarks time-stepping for two models that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/jld2_output_writer.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918
https://github.com/CliMA/Oceananigans.jl/issues/1918:2423,Integrability,message,message,2423,"odels that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/jld2_output_writer.jl#L217. and by `NetCDFOutputWriter` (though a bit differently since it gives a timing for each output):. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/netcdf_output_writer.jl#L459-L463. so we may not actually have to provide tools for benchmarking those. The `NetCDFOutputWriter` message is wrong in general because output is not always ""computed"" --- we should fix that.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918
https://github.com/CliMA/Oceananigans.jl/issues/1918:115,Performance,perform,performance,115,"For complicated models and examples, user-defined forcing functions can impose significant penalties on simulation performance. In addition to that, models with extensive and complicated diagnostics (especially those involving time-averaging) can further slow down time-to-science. It thus might be useful to provide some utilities that make benchmarking forcing functions, boundary condition functions, and diagnostics a bit easier. For forcing functions, I think a utility that benchmarks time-stepping for two models that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918
https://github.com/CliMA/Oceananigans.jl/issues/1918:1518,Safety,avoid,avoid,1518,"odels that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/jld2_output_writer.jl#L217. and by `NetCDFOutputWriter` (though a bit differently since it gives a timing for each output):. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/netcdf_output_writer.jl#L459-L463. so we may not actually have to provide tools for benchmarking those. The `NetCDFOutputWriter` message is wrong in general because output is not always ""computed"" --- we should fix that.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918
https://github.com/CliMA/Oceananigans.jl/issues/1918:342,Testability,benchmark,benchmarking,342,"For complicated models and examples, user-defined forcing functions can impose significant penalties on simulation performance. In addition to that, models with extensive and complicated diagnostics (especially those involving time-averaging) can further slow down time-to-science. It thus might be useful to provide some utilities that make benchmarking forcing functions, boundary condition functions, and diagnostics a bit easier. For forcing functions, I think a utility that benchmarks time-stepping for two models that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918
https://github.com/CliMA/Oceananigans.jl/issues/1918:480,Testability,benchmark,benchmarks,480,"For complicated models and examples, user-defined forcing functions can impose significant penalties on simulation performance. In addition to that, models with extensive and complicated diagnostics (especially those involving time-averaging) can further slow down time-to-science. It thus might be useful to provide some utilities that make benchmarking forcing functions, boundary condition functions, and diagnostics a bit easier. For forcing functions, I think a utility that benchmarks time-stepping for two models that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918
https://github.com/CliMA/Oceananigans.jl/issues/1918:1173,Testability,Benchmark,Benchmarking,1173,"diagnostics (especially those involving time-averaging) can further slow down time-to-science. It thus might be useful to provide some utilities that make benchmarking forcing functions, boundary condition functions, and diagnostics a bit easier. For forcing functions, I think a utility that benchmarks time-stepping for two models that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/jld2_output_writer.jl#L217. and by `NetCDFOutputWriter` (though a bit differently since it gives a timing for each output):.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918
https://github.com/CliMA/Oceananigans.jl/issues/1918:1251,Testability,Benchmark,Benchmarking,1251,"me-to-science. It thus might be useful to provide some utilities that make benchmarking forcing functions, boundary condition functions, and diagnostics a bit easier. For forcing functions, I think a utility that benchmarks time-stepping for two models that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/jld2_output_writer.jl#L217. and by `NetCDFOutputWriter` (though a bit differently since it gives a timing for each output):. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918
https://github.com/CliMA/Oceananigans.jl/issues/1918:1705,Testability,benchmark,benchmark,1705,"odels that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/jld2_output_writer.jl#L217. and by `NetCDFOutputWriter` (though a bit differently since it gives a timing for each output):. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/netcdf_output_writer.jl#L459-L463. so we may not actually have to provide tools for benchmarking those. The `NetCDFOutputWriter` message is wrong in general because output is not always ""computed"" --- we should fix that.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918
https://github.com/CliMA/Oceananigans.jl/issues/1918:2378,Testability,benchmark,benchmarking,2378,"odels that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/jld2_output_writer.jl#L217. and by `NetCDFOutputWriter` (though a bit differently since it gives a timing for each output):. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/netcdf_output_writer.jl#L459-L463. so we may not actually have to provide tools for benchmarking those. The `NetCDFOutputWriter` message is wrong in general because output is not always ""computed"" --- we should fix that.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918
https://github.com/CliMA/Oceananigans.jl/issues/1919:1751,Deployability,configurat,configuration,1751,"= RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 allocations: 45.68 MiB); * `xz_grid`: 531.077 ms (637499 allocations: 53.51 MiB); * `yz_grid`: 147.963 ms (166797 allocations: 46.33 MiB). and therefore an even larger (10x) performance difference, though allocations are more under control. I ran the benchmarks for a few different topologies to see if the pressure solver was the culprit. But I noticed similar behavior whether or not `y` or `z` was `Periodic` or `Bounded`. I also tested whether the vertical integral for hydrostatic pressure was a problem by updating and then running code from #1910 . This didn't fix the problem either. I'm perplexed, so I think we should drill into this a bit more. Or --- am I misinterpreting or setting up the benchmarks incorrectly?. @ali-ramadhan @christophernhill",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919
https://github.com/CliMA/Oceananigans.jl/issues/1919:1797,Deployability,configurat,configuration,1797,"= RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 allocations: 45.68 MiB); * `xz_grid`: 531.077 ms (637499 allocations: 53.51 MiB); * `yz_grid`: 147.963 ms (166797 allocations: 46.33 MiB). and therefore an even larger (10x) performance difference, though allocations are more under control. I ran the benchmarks for a few different topologies to see if the pressure solver was the culprit. But I noticed similar behavior whether or not `y` or `z` was `Periodic` or `Bounded`. I also tested whether the vertical integral for hydrostatic pressure was a problem by updating and then running code from #1910 . This didn't fix the problem either. I'm perplexed, so I think we should drill into this a bit more. Or --- am I misinterpreting or setting up the benchmarks incorrectly?. @ali-ramadhan @christophernhill",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919
https://github.com/CliMA/Oceananigans.jl/issues/1919:1751,Modifiability,config,configuration,1751,"= RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 allocations: 45.68 MiB); * `xz_grid`: 531.077 ms (637499 allocations: 53.51 MiB); * `yz_grid`: 147.963 ms (166797 allocations: 46.33 MiB). and therefore an even larger (10x) performance difference, though allocations are more under control. I ran the benchmarks for a few different topologies to see if the pressure solver was the culprit. But I noticed similar behavior whether or not `y` or `z` was `Periodic` or `Bounded`. I also tested whether the vertical integral for hydrostatic pressure was a problem by updating and then running code from #1910 . This didn't fix the problem either. I'm perplexed, so I think we should drill into this a bit more. Or --- am I misinterpreting or setting up the benchmarks incorrectly?. @ali-ramadhan @christophernhill",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919
https://github.com/CliMA/Oceananigans.jl/issues/1919:1797,Modifiability,config,configuration,1797,"= RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 allocations: 45.68 MiB); * `xz_grid`: 531.077 ms (637499 allocations: 53.51 MiB); * `yz_grid`: 147.963 ms (166797 allocations: 46.33 MiB). and therefore an even larger (10x) performance difference, though allocations are more under control. I ran the benchmarks for a few different topologies to see if the pressure solver was the culprit. But I noticed similar behavior whether or not `y` or `z` was `Periodic` or `Bounded`. I also tested whether the vertical integral for hydrostatic pressure was a problem by updating and then running code from #1910 . This didn't fix the problem either. I'm perplexed, so I think we should drill into this a bit more. Or --- am I misinterpreting or setting up the benchmarks incorrectly?. @ali-ramadhan @christophernhill",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919
https://github.com/CliMA/Oceananigans.jl/issues/1919:114,Performance,perform,performant,114,"When attempting to run the problem in #1916 I noticed something alarming: models that are 2D in ""xz"" are far less performant than models that are 2D in ""xy"" on both the CPU and the GPU. On the CPU, 2D models in ""xz"" have alarmingly high memory allocation (allocations also seem high for ""xy"", something it seems we've lost track of). I tested this on a number of branches / versions and found similar behavior on all them, so it doesn't seem there's been a performance regression (at least not recently). I haven't tested any branches requiring julia 1.5 --- I'd like to try that too. To illustrate this I put together a small benchmarking script:. ```julia; using Oceananigans; using Oceananigans.TimeSteppers: time_step!; using BenchmarkTools. xy_grid = RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 alloc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919
https://github.com/CliMA/Oceananigans.jl/issues/1919:457,Performance,perform,performance,457,"When attempting to run the problem in #1916 I noticed something alarming: models that are 2D in ""xz"" are far less performant than models that are 2D in ""xy"" on both the CPU and the GPU. On the CPU, 2D models in ""xz"" have alarmingly high memory allocation (allocations also seem high for ""xy"", something it seems we've lost track of). I tested this on a number of branches / versions and found similar behavior on all them, so it doesn't seem there's been a performance regression (at least not recently). I haven't tested any branches requiring julia 1.5 --- I'd like to try that too. To illustrate this I put together a small benchmarking script:. ```julia; using Oceananigans; using Oceananigans.TimeSteppers: time_step!; using BenchmarkTools. xy_grid = RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 alloc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919
https://github.com/CliMA/Oceananigans.jl/issues/1919:2170,Performance,perform,performance,2170,"= RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 allocations: 45.68 MiB); * `xz_grid`: 531.077 ms (637499 allocations: 53.51 MiB); * `yz_grid`: 147.963 ms (166797 allocations: 46.33 MiB). and therefore an even larger (10x) performance difference, though allocations are more under control. I ran the benchmarks for a few different topologies to see if the pressure solver was the culprit. But I noticed similar behavior whether or not `y` or `z` was `Periodic` or `Bounded`. I also tested whether the vertical integral for hydrostatic pressure was a problem by updating and then running code from #1910 . This didn't fix the problem either. I'm perplexed, so I think we should drill into this a bit more. Or --- am I misinterpreting or setting up the benchmarks incorrectly?. @ali-ramadhan @christophernhill",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919
https://github.com/CliMA/Oceananigans.jl/issues/1919:336,Testability,test,tested,336,"When attempting to run the problem in #1916 I noticed something alarming: models that are 2D in ""xz"" are far less performant than models that are 2D in ""xy"" on both the CPU and the GPU. On the CPU, 2D models in ""xz"" have alarmingly high memory allocation (allocations also seem high for ""xy"", something it seems we've lost track of). I tested this on a number of branches / versions and found similar behavior on all them, so it doesn't seem there's been a performance regression (at least not recently). I haven't tested any branches requiring julia 1.5 --- I'd like to try that too. To illustrate this I put together a small benchmarking script:. ```julia; using Oceananigans; using Oceananigans.TimeSteppers: time_step!; using BenchmarkTools. xy_grid = RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 alloc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919
https://github.com/CliMA/Oceananigans.jl/issues/1919:515,Testability,test,tested,515,"When attempting to run the problem in #1916 I noticed something alarming: models that are 2D in ""xz"" are far less performant than models that are 2D in ""xy"" on both the CPU and the GPU. On the CPU, 2D models in ""xz"" have alarmingly high memory allocation (allocations also seem high for ""xy"", something it seems we've lost track of). I tested this on a number of branches / versions and found similar behavior on all them, so it doesn't seem there's been a performance regression (at least not recently). I haven't tested any branches requiring julia 1.5 --- I'd like to try that too. To illustrate this I put together a small benchmarking script:. ```julia; using Oceananigans; using Oceananigans.TimeSteppers: time_step!; using BenchmarkTools. xy_grid = RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 alloc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919
https://github.com/CliMA/Oceananigans.jl/issues/1919:627,Testability,benchmark,benchmarking,627,"When attempting to run the problem in #1916 I noticed something alarming: models that are 2D in ""xz"" are far less performant than models that are 2D in ""xy"" on both the CPU and the GPU. On the CPU, 2D models in ""xz"" have alarmingly high memory allocation (allocations also seem high for ""xy"", something it seems we've lost track of). I tested this on a number of branches / versions and found similar behavior on all them, so it doesn't seem there's been a performance regression (at least not recently). I haven't tested any branches requiring julia 1.5 --- I'd like to try that too. To illustrate this I put together a small benchmarking script:. ```julia; using Oceananigans; using Oceananigans.TimeSteppers: time_step!; using BenchmarkTools. xy_grid = RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 alloc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919
https://github.com/CliMA/Oceananigans.jl/issues/1919:730,Testability,Benchmark,BenchmarkTools,730,"When attempting to run the problem in #1916 I noticed something alarming: models that are 2D in ""xz"" are far less performant than models that are 2D in ""xy"" on both the CPU and the GPU. On the CPU, 2D models in ""xz"" have alarmingly high memory allocation (allocations also seem high for ""xy"", something it seems we've lost track of). I tested this on a number of branches / versions and found similar behavior on all them, so it doesn't seem there's been a performance regression (at least not recently). I haven't tested any branches requiring julia 1.5 --- I'd like to try that too. To illustrate this I put together a small benchmarking script:. ```julia; using Oceananigans; using Oceananigans.TimeSteppers: time_step!; using BenchmarkTools. xy_grid = RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 alloc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919
https://github.com/CliMA/Oceananigans.jl/issues/1919:1458,Testability,Benchmark,Benchmarking,1458,"ance regression (at least not recently). I haven't tested any branches requiring julia 1.5 --- I'd like to try that too. To illustrate this I put together a small benchmarking script:. ```julia; using Oceananigans; using Oceananigans.TimeSteppers: time_step!; using BenchmarkTools. xy_grid = RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 allocations: 45.68 MiB); * `xz_grid`: 531.077 ms (637499 allocations: 53.51 MiB); * `yz_grid`: 147.963 ms (166797 allocations: 46.33 MiB). and therefore an even larger (10x) performance difference, though allocations are more under control. I ran the benchmarks for a few different topologies to see if the pressure solver was the culprit. But I noticed similar behavior whether or not `y` or `z` was `Periodic` or `Bounded`. I also tested whether the vertical integra",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919
https://github.com/CliMA/Oceananigans.jl/issues/1919:1913,Testability,benchmark,benchmark,1913,"= RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 allocations: 45.68 MiB); * `xz_grid`: 531.077 ms (637499 allocations: 53.51 MiB); * `yz_grid`: 147.963 ms (166797 allocations: 46.33 MiB). and therefore an even larger (10x) performance difference, though allocations are more under control. I ran the benchmarks for a few different topologies to see if the pressure solver was the culprit. But I noticed similar behavior whether or not `y` or `z` was `Periodic` or `Bounded`. I also tested whether the vertical integral for hydrostatic pressure was a problem by updating and then running code from #1910 . This didn't fix the problem either. I'm perplexed, so I think we should drill into this a bit more. Or --- am I misinterpreting or setting up the benchmarks incorrectly?. @ali-ramadhan @christophernhill",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919
https://github.com/CliMA/Oceananigans.jl/issues/1919:1923,Testability,test,tests,1923,"= RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 allocations: 45.68 MiB); * `xz_grid`: 531.077 ms (637499 allocations: 53.51 MiB); * `yz_grid`: 147.963 ms (166797 allocations: 46.33 MiB). and therefore an even larger (10x) performance difference, though allocations are more under control. I ran the benchmarks for a few different topologies to see if the pressure solver was the culprit. But I noticed similar behavior whether or not `y` or `z` was `Periodic` or `Bounded`. I also tested whether the vertical integral for hydrostatic pressure was a problem by updating and then running code from #1910 . This didn't fix the problem either. I'm perplexed, so I think we should drill into this a bit more. Or --- am I misinterpreting or setting up the benchmarks incorrectly?. @ali-ramadhan @christophernhill",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919
https://github.com/CliMA/Oceananigans.jl/issues/1919:2247,Testability,benchmark,benchmarks,2247,"= RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 allocations: 45.68 MiB); * `xz_grid`: 531.077 ms (637499 allocations: 53.51 MiB); * `yz_grid`: 147.963 ms (166797 allocations: 46.33 MiB). and therefore an even larger (10x) performance difference, though allocations are more under control. I ran the benchmarks for a few different topologies to see if the pressure solver was the culprit. But I noticed similar behavior whether or not `y` or `z` was `Periodic` or `Bounded`. I also tested whether the vertical integral for hydrostatic pressure was a problem by updating and then running code from #1910 . This didn't fix the problem either. I'm perplexed, so I think we should drill into this a bit more. Or --- am I misinterpreting or setting up the benchmarks incorrectly?. @ali-ramadhan @christophernhill",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919
https://github.com/CliMA/Oceananigans.jl/issues/1919:2429,Testability,test,tested,2429,"= RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 allocations: 45.68 MiB); * `xz_grid`: 531.077 ms (637499 allocations: 53.51 MiB); * `yz_grid`: 147.963 ms (166797 allocations: 46.33 MiB). and therefore an even larger (10x) performance difference, though allocations are more under control. I ran the benchmarks for a few different topologies to see if the pressure solver was the culprit. But I noticed similar behavior whether or not `y` or `z` was `Periodic` or `Bounded`. I also tested whether the vertical integral for hydrostatic pressure was a problem by updating and then running code from #1910 . This didn't fix the problem either. I'm perplexed, so I think we should drill into this a bit more. Or --- am I misinterpreting or setting up the benchmarks incorrectly?. @ali-ramadhan @christophernhill",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919
https://github.com/CliMA/Oceananigans.jl/issues/1919:2698,Testability,benchmark,benchmarks,2698,"= RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 allocations: 45.68 MiB); * `xz_grid`: 531.077 ms (637499 allocations: 53.51 MiB); * `yz_grid`: 147.963 ms (166797 allocations: 46.33 MiB). and therefore an even larger (10x) performance difference, though allocations are more under control. I ran the benchmarks for a few different topologies to see if the pressure solver was the culprit. But I noticed similar behavior whether or not `y` or `z` was `Periodic` or `Bounded`. I also tested whether the vertical integral for hydrostatic pressure was a problem by updating and then running code from #1910 . This didn't fix the problem either. I'm perplexed, so I think we should drill into this a bit more. Or --- am I misinterpreting or setting up the benchmarks incorrectly?. @ali-ramadhan @christophernhill",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919
https://github.com/CliMA/Oceananigans.jl/pull/1923:861,Deployability,configurat,configuration,861,"This PR overhauls halo filling to improve performance, especially for models that are ""thin"" in one direction (meaning that halo filling in the ""fat"" directions is expensive). It combines halo filling for opposing boundaries when possible (this is almost always possible except when using value / gradient boundary conditions). Notably it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923
https://github.com/CliMA/Oceananigans.jl/pull/1923:861,Modifiability,config,configuration,861,"This PR overhauls halo filling to improve performance, especially for models that are ""thin"" in one direction (meaning that halo filling in the ""fat"" directions is expensive). It combines halo filling for opposing boundaries when possible (this is almost always possible except when using value / gradient boundary conditions). Notably it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923
https://github.com/CliMA/Oceananigans.jl/pull/1923:42,Performance,perform,performance,42,"This PR overhauls halo filling to improve performance, especially for models that are ""thin"" in one direction (meaning that halo filling in the ""fat"" directions is expensive). It combines halo filling for opposing boundaries when possible (this is almost always possible except when using value / gradient boundary conditions). Notably it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923
https://github.com/CliMA/Oceananigans.jl/pull/1923:466,Performance,perform,performance,466,"This PR overhauls halo filling to improve performance, especially for models that are ""thin"" in one direction (meaning that halo filling in the ""fat"" directions is expensive). It combines halo filling for opposing boundaries when possible (this is almost always possible except when using value / gradient boundary conditions). Notably it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923
https://github.com/CliMA/Oceananigans.jl/pull/1923:770,Performance,optimiz,optimization,770,"This PR overhauls halo filling to improve performance, especially for models that are ""thin"" in one direction (meaning that halo filling in the ""fat"" directions is expensive). It combines halo filling for opposing boundaries when possible (this is almost always possible except when using value / gradient boundary conditions). Notably it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923
https://github.com/CliMA/Oceananigans.jl/pull/1923:1550,Performance,perform,performance,1550,"ly it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 175.995 ms (281950 allocations: 91.17 MiB); ```. The discrepencies are more extreme for larger models as noted on #1919. I think we should also do GPU benchmarks. @hennyg888 if you have anything to add please feel free...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923
https://github.com/CliMA/Oceananigans.jl/pull/1923:1011,Testability,Benchmark,Benchmarking,1011," improve performance, especially for models that are ""thin"" in one direction (meaning that halo filling in the ""fat"" directions is expensive). It combines halo filling for opposing boundaries when possible (this is almost always possible except when using value / gradient boundary conditions). Notably it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info: Benchmarking model with Regular",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923
https://github.com/CliMA/Oceananigans.jl/pull/1923:1173,Testability,Benchmark,Benchmarking,1173,"ndaries when possible (this is almost always possible except when using value / gradient boundary conditions). Notably it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 175.995 ms (281950 allocations: 91.17 MiB); ```. The discrepencies are more extreme for larger models as ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923
https://github.com/CliMA/Oceananigans.jl/pull/1923:1335,Testability,Benchmark,Benchmarking,1335,"ly it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 175.995 ms (281950 allocations: 91.17 MiB); ```. The discrepencies are more extreme for larger models as noted on #1919. I think we should also do GPU benchmarks. @hennyg888 if you have anything to add please feel free...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923
https://github.com/CliMA/Oceananigans.jl/pull/1923:1534,Testability,benchmark,benchmark,1534,"ly it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 175.995 ms (281950 allocations: 91.17 MiB); ```. The discrepencies are more extreme for larger models as noted on #1919. I think we should also do GPU benchmarks. @hennyg888 if you have anything to add please feel free...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923
https://github.com/CliMA/Oceananigans.jl/pull/1923:1679,Testability,Benchmark,Benchmarking,1679,"ly it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 175.995 ms (281950 allocations: 91.17 MiB); ```. The discrepencies are more extreme for larger models as noted on #1919. I think we should also do GPU benchmarks. @hennyg888 if you have anything to add please feel free...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923
https://github.com/CliMA/Oceananigans.jl/pull/1923:1841,Testability,Benchmark,Benchmarking,1841,"ly it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 175.995 ms (281950 allocations: 91.17 MiB); ```. The discrepencies are more extreme for larger models as noted on #1919. I think we should also do GPU benchmarks. @hennyg888 if you have anything to add please feel free...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923
https://github.com/CliMA/Oceananigans.jl/pull/1923:2003,Testability,Benchmark,Benchmarking,2003,"ly it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 175.995 ms (281950 allocations: 91.17 MiB); ```. The discrepencies are more extreme for larger models as noted on #1919. I think we should also do GPU benchmarks. @hennyg888 if you have anything to add please feel free...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923
https://github.com/CliMA/Oceananigans.jl/pull/1923:2263,Testability,benchmark,benchmarks,2263,"ly it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 175.995 ms (281950 allocations: 91.17 MiB); ```. The discrepencies are more extreme for larger models as noted on #1919. I think we should also do GPU benchmarks. @hennyg888 if you have anything to add please feel free...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923
https://github.com/CliMA/Oceananigans.jl/pull/1924:844,Energy Efficiency,efficient,efficiently,844,"This PR makes some changes to the `HydrostaticFreeSurfaceModel` to permit the simulation of an ""ensemble of columns"". This abstraction uses a `Flat, Flat, Bounded` topology but non-zero resolution in `x, y`, leading to a model of `Nx, Ny` independent, non-communicating columns. In addition, we support using a 2D array of turbulence closures with this ""column ensemble"" abstraction (but only with this abstraction, not generally, to hopefully minimize unexpected behavior) so that each column can simulate a different surface boundary condition and parameterization independently. An example of usage is implemented in `validation/vertical_mixing_closures/many_tke_based_free_convection.jl` and `validation/vertical_mixing_closures/gpu_tkevd_ensemble.jl`. The result is a model that can simulate thousands of columns simultaneously on the GPU efficiently. A small benchmark for an ensemble of 8000 columns (400 by 20) achieves. ```julia; [ Info: Benchmarking...; 3.265 ms (6015 allocations: 2.54 MiB); ```. per time-step on a Titan V. This is a speed up of 1800x over a single column simulation with Oceananigans. This will hopefully prove useful for calibrating boundary layer parameterizations. @xiaozhour we can use a similar ""slice ensemble"" abstraction to simulate independent 2D slices for the purpose of calibrating mesoscale parameterizations, potentially.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1924
https://github.com/CliMA/Oceananigans.jl/pull/1924:550,Modifiability,parameteriz,parameterization,550,"This PR makes some changes to the `HydrostaticFreeSurfaceModel` to permit the simulation of an ""ensemble of columns"". This abstraction uses a `Flat, Flat, Bounded` topology but non-zero resolution in `x, y`, leading to a model of `Nx, Ny` independent, non-communicating columns. In addition, we support using a 2D array of turbulence closures with this ""column ensemble"" abstraction (but only with this abstraction, not generally, to hopefully minimize unexpected behavior) so that each column can simulate a different surface boundary condition and parameterization independently. An example of usage is implemented in `validation/vertical_mixing_closures/many_tke_based_free_convection.jl` and `validation/vertical_mixing_closures/gpu_tkevd_ensemble.jl`. The result is a model that can simulate thousands of columns simultaneously on the GPU efficiently. A small benchmark for an ensemble of 8000 columns (400 by 20) achieves. ```julia; [ Info: Benchmarking...; 3.265 ms (6015 allocations: 2.54 MiB); ```. per time-step on a Titan V. This is a speed up of 1800x over a single column simulation with Oceananigans. This will hopefully prove useful for calibrating boundary layer parameterizations. @xiaozhour we can use a similar ""slice ensemble"" abstraction to simulate independent 2D slices for the purpose of calibrating mesoscale parameterizations, potentially.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1924
https://github.com/CliMA/Oceananigans.jl/pull/1924:1179,Modifiability,parameteriz,parameterizations,1179,"This PR makes some changes to the `HydrostaticFreeSurfaceModel` to permit the simulation of an ""ensemble of columns"". This abstraction uses a `Flat, Flat, Bounded` topology but non-zero resolution in `x, y`, leading to a model of `Nx, Ny` independent, non-communicating columns. In addition, we support using a 2D array of turbulence closures with this ""column ensemble"" abstraction (but only with this abstraction, not generally, to hopefully minimize unexpected behavior) so that each column can simulate a different surface boundary condition and parameterization independently. An example of usage is implemented in `validation/vertical_mixing_closures/many_tke_based_free_convection.jl` and `validation/vertical_mixing_closures/gpu_tkevd_ensemble.jl`. The result is a model that can simulate thousands of columns simultaneously on the GPU efficiently. A small benchmark for an ensemble of 8000 columns (400 by 20) achieves. ```julia; [ Info: Benchmarking...; 3.265 ms (6015 allocations: 2.54 MiB); ```. per time-step on a Titan V. This is a speed up of 1800x over a single column simulation with Oceananigans. This will hopefully prove useful for calibrating boundary layer parameterizations. @xiaozhour we can use a similar ""slice ensemble"" abstraction to simulate independent 2D slices for the purpose of calibrating mesoscale parameterizations, potentially.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1924
https://github.com/CliMA/Oceananigans.jl/pull/1924:1334,Modifiability,parameteriz,parameterizations,1334,"This PR makes some changes to the `HydrostaticFreeSurfaceModel` to permit the simulation of an ""ensemble of columns"". This abstraction uses a `Flat, Flat, Bounded` topology but non-zero resolution in `x, y`, leading to a model of `Nx, Ny` independent, non-communicating columns. In addition, we support using a 2D array of turbulence closures with this ""column ensemble"" abstraction (but only with this abstraction, not generally, to hopefully minimize unexpected behavior) so that each column can simulate a different surface boundary condition and parameterization independently. An example of usage is implemented in `validation/vertical_mixing_closures/many_tke_based_free_convection.jl` and `validation/vertical_mixing_closures/gpu_tkevd_ensemble.jl`. The result is a model that can simulate thousands of columns simultaneously on the GPU efficiently. A small benchmark for an ensemble of 8000 columns (400 by 20) achieves. ```julia; [ Info: Benchmarking...; 3.265 ms (6015 allocations: 2.54 MiB); ```. per time-step on a Titan V. This is a speed up of 1800x over a single column simulation with Oceananigans. This will hopefully prove useful for calibrating boundary layer parameterizations. @xiaozhour we can use a similar ""slice ensemble"" abstraction to simulate independent 2D slices for the purpose of calibrating mesoscale parameterizations, potentially.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1924
https://github.com/CliMA/Oceananigans.jl/pull/1924:621,Security,validat,validation,621,"This PR makes some changes to the `HydrostaticFreeSurfaceModel` to permit the simulation of an ""ensemble of columns"". This abstraction uses a `Flat, Flat, Bounded` topology but non-zero resolution in `x, y`, leading to a model of `Nx, Ny` independent, non-communicating columns. In addition, we support using a 2D array of turbulence closures with this ""column ensemble"" abstraction (but only with this abstraction, not generally, to hopefully minimize unexpected behavior) so that each column can simulate a different surface boundary condition and parameterization independently. An example of usage is implemented in `validation/vertical_mixing_closures/many_tke_based_free_convection.jl` and `validation/vertical_mixing_closures/gpu_tkevd_ensemble.jl`. The result is a model that can simulate thousands of columns simultaneously on the GPU efficiently. A small benchmark for an ensemble of 8000 columns (400 by 20) achieves. ```julia; [ Info: Benchmarking...; 3.265 ms (6015 allocations: 2.54 MiB); ```. per time-step on a Titan V. This is a speed up of 1800x over a single column simulation with Oceananigans. This will hopefully prove useful for calibrating boundary layer parameterizations. @xiaozhour we can use a similar ""slice ensemble"" abstraction to simulate independent 2D slices for the purpose of calibrating mesoscale parameterizations, potentially.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1924
https://github.com/CliMA/Oceananigans.jl/pull/1924:697,Security,validat,validation,697,"This PR makes some changes to the `HydrostaticFreeSurfaceModel` to permit the simulation of an ""ensemble of columns"". This abstraction uses a `Flat, Flat, Bounded` topology but non-zero resolution in `x, y`, leading to a model of `Nx, Ny` independent, non-communicating columns. In addition, we support using a 2D array of turbulence closures with this ""column ensemble"" abstraction (but only with this abstraction, not generally, to hopefully minimize unexpected behavior) so that each column can simulate a different surface boundary condition and parameterization independently. An example of usage is implemented in `validation/vertical_mixing_closures/many_tke_based_free_convection.jl` and `validation/vertical_mixing_closures/gpu_tkevd_ensemble.jl`. The result is a model that can simulate thousands of columns simultaneously on the GPU efficiently. A small benchmark for an ensemble of 8000 columns (400 by 20) achieves. ```julia; [ Info: Benchmarking...; 3.265 ms (6015 allocations: 2.54 MiB); ```. per time-step on a Titan V. This is a speed up of 1800x over a single column simulation with Oceananigans. This will hopefully prove useful for calibrating boundary layer parameterizations. @xiaozhour we can use a similar ""slice ensemble"" abstraction to simulate independent 2D slices for the purpose of calibrating mesoscale parameterizations, potentially.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1924
https://github.com/CliMA/Oceananigans.jl/pull/1924:865,Testability,benchmark,benchmark,865,"This PR makes some changes to the `HydrostaticFreeSurfaceModel` to permit the simulation of an ""ensemble of columns"". This abstraction uses a `Flat, Flat, Bounded` topology but non-zero resolution in `x, y`, leading to a model of `Nx, Ny` independent, non-communicating columns. In addition, we support using a 2D array of turbulence closures with this ""column ensemble"" abstraction (but only with this abstraction, not generally, to hopefully minimize unexpected behavior) so that each column can simulate a different surface boundary condition and parameterization independently. An example of usage is implemented in `validation/vertical_mixing_closures/many_tke_based_free_convection.jl` and `validation/vertical_mixing_closures/gpu_tkevd_ensemble.jl`. The result is a model that can simulate thousands of columns simultaneously on the GPU efficiently. A small benchmark for an ensemble of 8000 columns (400 by 20) achieves. ```julia; [ Info: Benchmarking...; 3.265 ms (6015 allocations: 2.54 MiB); ```. per time-step on a Titan V. This is a speed up of 1800x over a single column simulation with Oceananigans. This will hopefully prove useful for calibrating boundary layer parameterizations. @xiaozhour we can use a similar ""slice ensemble"" abstraction to simulate independent 2D slices for the purpose of calibrating mesoscale parameterizations, potentially.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1924
https://github.com/CliMA/Oceananigans.jl/pull/1924:947,Testability,Benchmark,Benchmarking,947,"This PR makes some changes to the `HydrostaticFreeSurfaceModel` to permit the simulation of an ""ensemble of columns"". This abstraction uses a `Flat, Flat, Bounded` topology but non-zero resolution in `x, y`, leading to a model of `Nx, Ny` independent, non-communicating columns. In addition, we support using a 2D array of turbulence closures with this ""column ensemble"" abstraction (but only with this abstraction, not generally, to hopefully minimize unexpected behavior) so that each column can simulate a different surface boundary condition and parameterization independently. An example of usage is implemented in `validation/vertical_mixing_closures/many_tke_based_free_convection.jl` and `validation/vertical_mixing_closures/gpu_tkevd_ensemble.jl`. The result is a model that can simulate thousands of columns simultaneously on the GPU efficiently. A small benchmark for an ensemble of 8000 columns (400 by 20) achieves. ```julia; [ Info: Benchmarking...; 3.265 ms (6015 allocations: 2.54 MiB); ```. per time-step on a Titan V. This is a speed up of 1800x over a single column simulation with Oceananigans. This will hopefully prove useful for calibrating boundary layer parameterizations. @xiaozhour we can use a similar ""slice ensemble"" abstraction to simulate independent 2D slices for the purpose of calibrating mesoscale parameterizations, potentially.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1924
https://github.com/CliMA/Oceananigans.jl/pull/1926:588,Integrability,interface,interface,588,"This PR renames `TKEBasedVerticalDiffusivity` as `CATKEVerticalDiffusivity`, and implements the _triple max_ CATKE formulation that involves a ""convective mixing length"", in addition to the grid-proportional mixing length, and stably stratified mixing length. This formulation is described here (missing some context):. ![image](https://user-images.githubusercontent.com/15271942/128558326-5ee9e1dd-9f0e-4c98-91ee-694b4e9d72c4.png). This requires some minor modifications to the `HydrostaticFreeSurfaceModel` time-stepping algorithm and also refactoring of the `calculate_diffusivities!` interface. cc @adelinehillier",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1926
https://github.com/CliMA/Oceananigans.jl/pull/1926:542,Modifiability,refactor,refactoring,542,"This PR renames `TKEBasedVerticalDiffusivity` as `CATKEVerticalDiffusivity`, and implements the _triple max_ CATKE formulation that involves a ""convective mixing length"", in addition to the grid-proportional mixing length, and stably stratified mixing length. This formulation is described here (missing some context):. ![image](https://user-images.githubusercontent.com/15271942/128558326-5ee9e1dd-9f0e-4c98-91ee-694b4e9d72c4.png). This requires some minor modifications to the `HydrostaticFreeSurfaceModel` time-stepping algorithm and also refactoring of the `calculate_diffusivities!` interface. cc @adelinehillier",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1926
https://github.com/CliMA/Oceananigans.jl/pull/1928:25,Availability,error,error,25,"This test is to stop the error below from reappearing (once the test is fixed!). . ```; nested task error: MethodError: no method matching (::Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#surface_wind_stress#28"", NamedTuple{(:τ₀, :Lφ, :φ₀), Tuple{Float64, Float64, Int64}}, Tuple{}, Tuple{}, Tuple{}})(::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, ::Clock{Float64}, ::NamedTuple{(:u, :v, :η), Tuple{Field{Face, Center, Center, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, FieldBoundaryConditions{BoundaryCondition{Open, Nothing}, BoundaryCondition{Open, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Float64, var""#u_bottom_drag#29""}}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#surface_wind_stress#28"", NamedTuple{(:τ₀, :Lφ, :φ₀), Tuple{Float64, Float64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Flux, Nothing}}}, Field{Center, Face, Center, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1928
https://github.com/CliMA/Oceananigans.jl/pull/1928:100,Availability,error,error,100,"This test is to stop the error below from reappearing (once the test is fixed!). . ```; nested task error: MethodError: no method matching (::Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#surface_wind_stress#28"", NamedTuple{(:τ₀, :Lφ, :φ₀), Tuple{Float64, Float64, Int64}}, Tuple{}, Tuple{}, Tuple{}})(::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, ::Clock{Float64}, ::NamedTuple{(:u, :v, :η), Tuple{Field{Face, Center, Center, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, FieldBoundaryConditions{BoundaryCondition{Open, Nothing}, BoundaryCondition{Open, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Float64, var""#u_bottom_drag#29""}}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#surface_wind_stress#28"", NamedTuple{(:τ₀, :Lφ, :φ₀), Tuple{Float64, Float64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Flux, Nothing}}}, Field{Center, Face, Center, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1928
https://github.com/CliMA/Oceananigans.jl/pull/1928:174,Deployability,Continuous,ContinuousBoundaryFunction,174,"This test is to stop the error below from reappearing (once the test is fixed!). . ```; nested task error: MethodError: no method matching (::Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#surface_wind_stress#28"", NamedTuple{(:τ₀, :Lφ, :φ₀), Tuple{Float64, Float64, Int64}}, Tuple{}, Tuple{}, Tuple{}})(::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, ::Clock{Float64}, ::NamedTuple{(:u, :v, :η), Tuple{Field{Face, Center, Center, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, FieldBoundaryConditions{BoundaryCondition{Open, Nothing}, BoundaryCondition{Open, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Float64, var""#u_bottom_drag#29""}}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#surface_wind_stress#28"", NamedTuple{(:τ₀, :Lφ, :φ₀), Tuple{Float64, Float64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Flux, Nothing}}}, Field{Center, Face, Center, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1928
https://github.com/CliMA/Oceananigans.jl/pull/1928:1415,Deployability,Continuous,ContinuousBoundaryFunction,1415,"depth#27""}}, ::Clock{Float64}, ::NamedTuple{(:u, :v, :η), Tuple{Field{Face, Center, Center, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, FieldBoundaryConditions{BoundaryCondition{Open, Nothing}, BoundaryCondition{Open, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Float64, var""#u_bottom_drag#29""}}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#surface_wind_stress#28"", NamedTuple{(:τ₀, :Lφ, :φ₀), Tuple{Float64, Float64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Flux, Nothing}}}, Field{Center, Face, Center, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, FieldBoundaryConditions{BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Open, Nothing}, BoundaryCondition{Open, Nothing}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Float64, var""#v_bottom_drag#30""}}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}}, ReducedField{Center, Center, Nothing, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePreci",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1928
https://github.com/CliMA/Oceananigans.jl/pull/1928:3200,Deployability,Continuous,ContinuousBoundaryFunction,3200,"{Face, Center, Nothing, 1, var""#surface_wind_stress#28"", NamedTuple{(:τ₀, :Lφ, :φ₀), Tuple{Float64, Float64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Flux, Nothing}}}, Field{Center, Face, Center, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, FieldBoundaryConditions{BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Open, Nothing}, BoundaryCondition{Open, Nothing}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Float64, var""#v_bottom_drag#30""}}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}}, ReducedField{Center, Center, Nothing, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, 1, FieldBoundaryConditions{BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Flux, Nothing}}}}}, ::HorizontallyCurvilinearAnisotropicDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, Float64, NamedTuple{(), Tuple{}}, NamedTuple{(), Tuple{}}}, ::Nothing); Closest candidates are:; (::Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{LX, LY, Nothing, k, F, P, D, N, ℑ} where {F, P, D, N, ℑ})(::Any, ::Any, ::Any, ::Any, ::Any) where {LX, LY, k} at /home/chris/projects/onan-2021-08-06/src/BoundaryConditions/continuous_boundary_function.jl:117. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1928
https://github.com/CliMA/Oceananigans.jl/pull/1928:2346,Energy Efficiency,Reduce,ReducedField,2346,"ions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#surface_wind_stress#28"", NamedTuple{(:τ₀, :Lφ, :φ₀), Tuple{Float64, Float64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Flux, Nothing}}}, Field{Center, Face, Center, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, FieldBoundaryConditions{BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Open, Nothing}, BoundaryCondition{Open, Nothing}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Float64, var""#v_bottom_drag#30""}}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}}, ReducedField{Center, Center, Nothing, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, 1, FieldBoundaryConditions{BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, Nothing, Nothing, BoundaryCondition{Flux, Nothing}}}}}, ::HorizontallyCurvilinearAnisotropicDiffusivity{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Float64, Float64, NamedTuple{(), Tuple{}}, NamedTuple{(), Tuple{}}}, ::Nothing); Closest candidates are:; (::Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{LX, LY, Nothing, k, F, P, D, N, ℑ} where {F, P, D, N, ℑ})(::Any, ::Any, ::Any, ::Any, ::Any) where {LX, LY, k} at /home/chris/projects/onan-2021-08-06/src/BoundaryConditions/continuou",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1928
https://github.com/CliMA/Oceananigans.jl/pull/1928:5,Testability,test,test,5,"This test is to stop the error below from reappearing (once the test is fixed!). . ```; nested task error: MethodError: no method matching (::Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#surface_wind_stress#28"", NamedTuple{(:τ₀, :Lφ, :φ₀), Tuple{Float64, Float64, Int64}}, Tuple{}, Tuple{}, Tuple{}})(::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, ::Clock{Float64}, ::NamedTuple{(:u, :v, :η), Tuple{Field{Face, Center, Center, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, FieldBoundaryConditions{BoundaryCondition{Open, Nothing}, BoundaryCondition{Open, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Float64, var""#u_bottom_drag#29""}}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#surface_wind_stress#28"", NamedTuple{(:τ₀, :Lφ, :φ₀), Tuple{Float64, Float64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Flux, Nothing}}}, Field{Center, Face, Center, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1928
https://github.com/CliMA/Oceananigans.jl/pull/1928:64,Testability,test,test,64,"This test is to stop the error below from reappearing (once the test is fixed!). . ```; nested task error: MethodError: no method matching (::Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#surface_wind_stress#28"", NamedTuple{(:τ₀, :Lφ, :φ₀), Tuple{Float64, Float64, Int64}}, Tuple{}, Tuple{}, Tuple{}})(::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, ::Clock{Float64}, ::NamedTuple{(:u, :v, :η), Tuple{Field{Face, Center, Center, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, FieldBoundaryConditions{BoundaryCondition{Open, Nothing}, BoundaryCondition{Open, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Float64, var""#u_bottom_drag#29""}}, BoundaryCondition{Flux, Oceananigans.BoundaryConditions.ContinuousBoundaryFunction{Face, Center, Nothing, 1, var""#surface_wind_stress#28"", NamedTuple{(:τ₀, :Lφ, :φ₀), Tuple{Float64, Float64, Int64}}, Tuple{}, Tuple{}, Tuple{}}}, BoundaryCondition{Flux, Nothing}}}, Field{Center, Face, Center, CPU, OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Bounded, Bounded, Bounded, RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{RasterDepthMask, var""#raster_depth#27""}}, Float64, F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1928
https://github.com/CliMA/Oceananigans.jl/issues/1929:116,Availability,checkpoint,checkpointer,116,"Greetings everyone,; I was recently started writing my outputs into a NetCDF file. Now I realize that I have to use checkpointer that can checkpoint the model to a NetCDF files, But I haven't found any method. There is for JLD2 files. So can you please look into this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929
https://github.com/CliMA/Oceananigans.jl/issues/1929:138,Availability,checkpoint,checkpoint,138,"Greetings everyone,; I was recently started writing my outputs into a NetCDF file. Now I realize that I have to use checkpointer that can checkpoint the model to a NetCDF files, But I haven't found any method. There is for JLD2 files. So can you please look into this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1929
https://github.com/CliMA/Oceananigans.jl/pull/1930:31,Deployability,update,updated,31,"This is the first draft of the updated benchmark docs. There are still many things to add in such as the weak and strong scaling benchmarks, but as of now it would be greatly appreciated if I can get some feedback on suggestions on the formatting and descriptions. A few questions and notes:; 1. I do not know what the static ocean benchmark results are. There is no longer a script for it in the benchmarks folder since all the results are quite old. I feel like I should replace it with the nonhydrostatic model benchmarks if that is what makes sense.; 2. I do not know what the channel benchmark results are either. Either the script was removed, or the form of it that produced these old results have been lost under a lot of renames and refactors. ; 3. The tracers and turbulence closures benchmarks still have corresponding scripts in the benchmarks folder. They were simply replaced with newer results. The newer results also includes CPU to GPU speedup analysis, unlike the old results.; 4. The shallow water model benchmark results are the best looking ones with maximum 400 times speedup using WENO5. Graphs are also included with a quick one sentence analysis.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1930
https://github.com/CliMA/Oceananigans.jl/pull/1930:742,Modifiability,refactor,refactors,742,"This is the first draft of the updated benchmark docs. There are still many things to add in such as the weak and strong scaling benchmarks, but as of now it would be greatly appreciated if I can get some feedback on suggestions on the formatting and descriptions. A few questions and notes:; 1. I do not know what the static ocean benchmark results are. There is no longer a script for it in the benchmarks folder since all the results are quite old. I feel like I should replace it with the nonhydrostatic model benchmarks if that is what makes sense.; 2. I do not know what the channel benchmark results are either. Either the script was removed, or the form of it that produced these old results have been lost under a lot of renames and refactors. ; 3. The tracers and turbulence closures benchmarks still have corresponding scripts in the benchmarks folder. They were simply replaced with newer results. The newer results also includes CPU to GPU speedup analysis, unlike the old results.; 4. The shallow water model benchmark results are the best looking ones with maximum 400 times speedup using WENO5. Graphs are also included with a quick one sentence analysis.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1930
https://github.com/CliMA/Oceananigans.jl/pull/1930:39,Testability,benchmark,benchmark,39,"This is the first draft of the updated benchmark docs. There are still many things to add in such as the weak and strong scaling benchmarks, but as of now it would be greatly appreciated if I can get some feedback on suggestions on the formatting and descriptions. A few questions and notes:; 1. I do not know what the static ocean benchmark results are. There is no longer a script for it in the benchmarks folder since all the results are quite old. I feel like I should replace it with the nonhydrostatic model benchmarks if that is what makes sense.; 2. I do not know what the channel benchmark results are either. Either the script was removed, or the form of it that produced these old results have been lost under a lot of renames and refactors. ; 3. The tracers and turbulence closures benchmarks still have corresponding scripts in the benchmarks folder. They were simply replaced with newer results. The newer results also includes CPU to GPU speedup analysis, unlike the old results.; 4. The shallow water model benchmark results are the best looking ones with maximum 400 times speedup using WENO5. Graphs are also included with a quick one sentence analysis.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1930
https://github.com/CliMA/Oceananigans.jl/pull/1930:129,Testability,benchmark,benchmarks,129,"This is the first draft of the updated benchmark docs. There are still many things to add in such as the weak and strong scaling benchmarks, but as of now it would be greatly appreciated if I can get some feedback on suggestions on the formatting and descriptions. A few questions and notes:; 1. I do not know what the static ocean benchmark results are. There is no longer a script for it in the benchmarks folder since all the results are quite old. I feel like I should replace it with the nonhydrostatic model benchmarks if that is what makes sense.; 2. I do not know what the channel benchmark results are either. Either the script was removed, or the form of it that produced these old results have been lost under a lot of renames and refactors. ; 3. The tracers and turbulence closures benchmarks still have corresponding scripts in the benchmarks folder. They were simply replaced with newer results. The newer results also includes CPU to GPU speedup analysis, unlike the old results.; 4. The shallow water model benchmark results are the best looking ones with maximum 400 times speedup using WENO5. Graphs are also included with a quick one sentence analysis.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1930
https://github.com/CliMA/Oceananigans.jl/pull/1930:332,Testability,benchmark,benchmark,332,"This is the first draft of the updated benchmark docs. There are still many things to add in such as the weak and strong scaling benchmarks, but as of now it would be greatly appreciated if I can get some feedback on suggestions on the formatting and descriptions. A few questions and notes:; 1. I do not know what the static ocean benchmark results are. There is no longer a script for it in the benchmarks folder since all the results are quite old. I feel like I should replace it with the nonhydrostatic model benchmarks if that is what makes sense.; 2. I do not know what the channel benchmark results are either. Either the script was removed, or the form of it that produced these old results have been lost under a lot of renames and refactors. ; 3. The tracers and turbulence closures benchmarks still have corresponding scripts in the benchmarks folder. They were simply replaced with newer results. The newer results also includes CPU to GPU speedup analysis, unlike the old results.; 4. The shallow water model benchmark results are the best looking ones with maximum 400 times speedup using WENO5. Graphs are also included with a quick one sentence analysis.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1930
https://github.com/CliMA/Oceananigans.jl/pull/1930:397,Testability,benchmark,benchmarks,397,"This is the first draft of the updated benchmark docs. There are still many things to add in such as the weak and strong scaling benchmarks, but as of now it would be greatly appreciated if I can get some feedback on suggestions on the formatting and descriptions. A few questions and notes:; 1. I do not know what the static ocean benchmark results are. There is no longer a script for it in the benchmarks folder since all the results are quite old. I feel like I should replace it with the nonhydrostatic model benchmarks if that is what makes sense.; 2. I do not know what the channel benchmark results are either. Either the script was removed, or the form of it that produced these old results have been lost under a lot of renames and refactors. ; 3. The tracers and turbulence closures benchmarks still have corresponding scripts in the benchmarks folder. They were simply replaced with newer results. The newer results also includes CPU to GPU speedup analysis, unlike the old results.; 4. The shallow water model benchmark results are the best looking ones with maximum 400 times speedup using WENO5. Graphs are also included with a quick one sentence analysis.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1930
https://github.com/CliMA/Oceananigans.jl/pull/1930:514,Testability,benchmark,benchmarks,514,"This is the first draft of the updated benchmark docs. There are still many things to add in such as the weak and strong scaling benchmarks, but as of now it would be greatly appreciated if I can get some feedback on suggestions on the formatting and descriptions. A few questions and notes:; 1. I do not know what the static ocean benchmark results are. There is no longer a script for it in the benchmarks folder since all the results are quite old. I feel like I should replace it with the nonhydrostatic model benchmarks if that is what makes sense.; 2. I do not know what the channel benchmark results are either. Either the script was removed, or the form of it that produced these old results have been lost under a lot of renames and refactors. ; 3. The tracers and turbulence closures benchmarks still have corresponding scripts in the benchmarks folder. They were simply replaced with newer results. The newer results also includes CPU to GPU speedup analysis, unlike the old results.; 4. The shallow water model benchmark results are the best looking ones with maximum 400 times speedup using WENO5. Graphs are also included with a quick one sentence analysis.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1930
https://github.com/CliMA/Oceananigans.jl/pull/1930:589,Testability,benchmark,benchmark,589,"This is the first draft of the updated benchmark docs. There are still many things to add in such as the weak and strong scaling benchmarks, but as of now it would be greatly appreciated if I can get some feedback on suggestions on the formatting and descriptions. A few questions and notes:; 1. I do not know what the static ocean benchmark results are. There is no longer a script for it in the benchmarks folder since all the results are quite old. I feel like I should replace it with the nonhydrostatic model benchmarks if that is what makes sense.; 2. I do not know what the channel benchmark results are either. Either the script was removed, or the form of it that produced these old results have been lost under a lot of renames and refactors. ; 3. The tracers and turbulence closures benchmarks still have corresponding scripts in the benchmarks folder. They were simply replaced with newer results. The newer results also includes CPU to GPU speedup analysis, unlike the old results.; 4. The shallow water model benchmark results are the best looking ones with maximum 400 times speedup using WENO5. Graphs are also included with a quick one sentence analysis.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1930
https://github.com/CliMA/Oceananigans.jl/pull/1930:794,Testability,benchmark,benchmarks,794,"This is the first draft of the updated benchmark docs. There are still many things to add in such as the weak and strong scaling benchmarks, but as of now it would be greatly appreciated if I can get some feedback on suggestions on the formatting and descriptions. A few questions and notes:; 1. I do not know what the static ocean benchmark results are. There is no longer a script for it in the benchmarks folder since all the results are quite old. I feel like I should replace it with the nonhydrostatic model benchmarks if that is what makes sense.; 2. I do not know what the channel benchmark results are either. Either the script was removed, or the form of it that produced these old results have been lost under a lot of renames and refactors. ; 3. The tracers and turbulence closures benchmarks still have corresponding scripts in the benchmarks folder. They were simply replaced with newer results. The newer results also includes CPU to GPU speedup analysis, unlike the old results.; 4. The shallow water model benchmark results are the best looking ones with maximum 400 times speedup using WENO5. Graphs are also included with a quick one sentence analysis.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1930
https://github.com/CliMA/Oceananigans.jl/pull/1930:845,Testability,benchmark,benchmarks,845,"This is the first draft of the updated benchmark docs. There are still many things to add in such as the weak and strong scaling benchmarks, but as of now it would be greatly appreciated if I can get some feedback on suggestions on the formatting and descriptions. A few questions and notes:; 1. I do not know what the static ocean benchmark results are. There is no longer a script for it in the benchmarks folder since all the results are quite old. I feel like I should replace it with the nonhydrostatic model benchmarks if that is what makes sense.; 2. I do not know what the channel benchmark results are either. Either the script was removed, or the form of it that produced these old results have been lost under a lot of renames and refactors. ; 3. The tracers and turbulence closures benchmarks still have corresponding scripts in the benchmarks folder. They were simply replaced with newer results. The newer results also includes CPU to GPU speedup analysis, unlike the old results.; 4. The shallow water model benchmark results are the best looking ones with maximum 400 times speedup using WENO5. Graphs are also included with a quick one sentence analysis.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1930
https://github.com/CliMA/Oceananigans.jl/pull/1930:1023,Testability,benchmark,benchmark,1023,"This is the first draft of the updated benchmark docs. There are still many things to add in such as the weak and strong scaling benchmarks, but as of now it would be greatly appreciated if I can get some feedback on suggestions on the formatting and descriptions. A few questions and notes:; 1. I do not know what the static ocean benchmark results are. There is no longer a script for it in the benchmarks folder since all the results are quite old. I feel like I should replace it with the nonhydrostatic model benchmarks if that is what makes sense.; 2. I do not know what the channel benchmark results are either. Either the script was removed, or the form of it that produced these old results have been lost under a lot of renames and refactors. ; 3. The tracers and turbulence closures benchmarks still have corresponding scripts in the benchmarks folder. They were simply replaced with newer results. The newer results also includes CPU to GPU speedup analysis, unlike the old results.; 4. The shallow water model benchmark results are the best looking ones with maximum 400 times speedup using WENO5. Graphs are also included with a quick one sentence analysis.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1930
https://github.com/CliMA/Oceananigans.jl/pull/1930:205,Usability,feedback,feedback,205,"This is the first draft of the updated benchmark docs. There are still many things to add in such as the weak and strong scaling benchmarks, but as of now it would be greatly appreciated if I can get some feedback on suggestions on the formatting and descriptions. A few questions and notes:; 1. I do not know what the static ocean benchmark results are. There is no longer a script for it in the benchmarks folder since all the results are quite old. I feel like I should replace it with the nonhydrostatic model benchmarks if that is what makes sense.; 2. I do not know what the channel benchmark results are either. Either the script was removed, or the form of it that produced these old results have been lost under a lot of renames and refactors. ; 3. The tracers and turbulence closures benchmarks still have corresponding scripts in the benchmarks folder. They were simply replaced with newer results. The newer results also includes CPU to GPU speedup analysis, unlike the old results.; 4. The shallow water model benchmark results are the best looking ones with maximum 400 times speedup using WENO5. Graphs are also included with a quick one sentence analysis.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1930
https://github.com/CliMA/Oceananigans.jl/pull/1930:874,Usability,simpl,simply,874,"This is the first draft of the updated benchmark docs. There are still many things to add in such as the weak and strong scaling benchmarks, but as of now it would be greatly appreciated if I can get some feedback on suggestions on the formatting and descriptions. A few questions and notes:; 1. I do not know what the static ocean benchmark results are. There is no longer a script for it in the benchmarks folder since all the results are quite old. I feel like I should replace it with the nonhydrostatic model benchmarks if that is what makes sense.; 2. I do not know what the channel benchmark results are either. Either the script was removed, or the form of it that produced these old results have been lost under a lot of renames and refactors. ; 3. The tracers and turbulence closures benchmarks still have corresponding scripts in the benchmarks folder. They were simply replaced with newer results. The newer results also includes CPU to GPU speedup analysis, unlike the old results.; 4. The shallow water model benchmark results are the best looking ones with maximum 400 times speedup using WENO5. Graphs are also included with a quick one sentence analysis.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1930
https://github.com/CliMA/Oceananigans.jl/pull/1932:0,Usability,Simpl,Simple,0,"Simple fix to use the cell-centered vertical spacing (face-to-face distance) in the continuity equation for determining w in the hydrostatic model. The code currently uses the face-centered spacing (center-to-center distance), which is the same for the uniform grid but not for the vertically stretched grid. With help from @sandreza and @jm-c.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1932
https://github.com/CliMA/Oceananigans.jl/pull/1933:0,Deployability,Update,Updated,0,Updated the basic _mpi_shallow_water_ example to work with the latest Oceananigans.jl version,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1933
https://github.com/CliMA/Oceananigans.jl/pull/1935:406,Security,validat,validation,406,"This PR fixes the diffusive flux argument in the divergence of diffusive flux, `∇_dot_qᶜ`,; https://github.com/CliMA/Oceananigans.jl/blob/e929631eb3a233ae3f3358d2146e5d6004f9a06c/src/TurbulenceClosures/diffusion_operators.jl#L47 to allow for the immersed boundary version using `_diffusive_flux_x`. This will make the tracer equations feel the immersed boundaries correctly. This also adds a very small 1D validation to test this. With a uniform buoyancy, validation checks if the buoyancy changes in time (it shouldn't). Below are the results before and after the fix. We can, of course, not include the validation and instead add a test for this.; ![b_plot1D_tracertest_bad](https://user-images.githubusercontent.com/67593861/129624223-70449ca0-5efb-4037-914a-20e1b565d4ca.png); ![b_plot1D_tracertest](https://user-images.githubusercontent.com/67593861/129624224-1eac8bae-7e78-4cc2-8b39-a202def6e975.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935
https://github.com/CliMA/Oceananigans.jl/pull/1935:456,Security,validat,validation,456,"This PR fixes the diffusive flux argument in the divergence of diffusive flux, `∇_dot_qᶜ`,; https://github.com/CliMA/Oceananigans.jl/blob/e929631eb3a233ae3f3358d2146e5d6004f9a06c/src/TurbulenceClosures/diffusion_operators.jl#L47 to allow for the immersed boundary version using `_diffusive_flux_x`. This will make the tracer equations feel the immersed boundaries correctly. This also adds a very small 1D validation to test this. With a uniform buoyancy, validation checks if the buoyancy changes in time (it shouldn't). Below are the results before and after the fix. We can, of course, not include the validation and instead add a test for this.; ![b_plot1D_tracertest_bad](https://user-images.githubusercontent.com/67593861/129624223-70449ca0-5efb-4037-914a-20e1b565d4ca.png); ![b_plot1D_tracertest](https://user-images.githubusercontent.com/67593861/129624224-1eac8bae-7e78-4cc2-8b39-a202def6e975.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935
https://github.com/CliMA/Oceananigans.jl/pull/1935:605,Security,validat,validation,605,"This PR fixes the diffusive flux argument in the divergence of diffusive flux, `∇_dot_qᶜ`,; https://github.com/CliMA/Oceananigans.jl/blob/e929631eb3a233ae3f3358d2146e5d6004f9a06c/src/TurbulenceClosures/diffusion_operators.jl#L47 to allow for the immersed boundary version using `_diffusive_flux_x`. This will make the tracer equations feel the immersed boundaries correctly. This also adds a very small 1D validation to test this. With a uniform buoyancy, validation checks if the buoyancy changes in time (it shouldn't). Below are the results before and after the fix. We can, of course, not include the validation and instead add a test for this.; ![b_plot1D_tracertest_bad](https://user-images.githubusercontent.com/67593861/129624223-70449ca0-5efb-4037-914a-20e1b565d4ca.png); ![b_plot1D_tracertest](https://user-images.githubusercontent.com/67593861/129624224-1eac8bae-7e78-4cc2-8b39-a202def6e975.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935
https://github.com/CliMA/Oceananigans.jl/pull/1935:420,Testability,test,test,420,"This PR fixes the diffusive flux argument in the divergence of diffusive flux, `∇_dot_qᶜ`,; https://github.com/CliMA/Oceananigans.jl/blob/e929631eb3a233ae3f3358d2146e5d6004f9a06c/src/TurbulenceClosures/diffusion_operators.jl#L47 to allow for the immersed boundary version using `_diffusive_flux_x`. This will make the tracer equations feel the immersed boundaries correctly. This also adds a very small 1D validation to test this. With a uniform buoyancy, validation checks if the buoyancy changes in time (it shouldn't). Below are the results before and after the fix. We can, of course, not include the validation and instead add a test for this.; ![b_plot1D_tracertest_bad](https://user-images.githubusercontent.com/67593861/129624223-70449ca0-5efb-4037-914a-20e1b565d4ca.png); ![b_plot1D_tracertest](https://user-images.githubusercontent.com/67593861/129624224-1eac8bae-7e78-4cc2-8b39-a202def6e975.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935
https://github.com/CliMA/Oceananigans.jl/pull/1935:634,Testability,test,test,634,"This PR fixes the diffusive flux argument in the divergence of diffusive flux, `∇_dot_qᶜ`,; https://github.com/CliMA/Oceananigans.jl/blob/e929631eb3a233ae3f3358d2146e5d6004f9a06c/src/TurbulenceClosures/diffusion_operators.jl#L47 to allow for the immersed boundary version using `_diffusive_flux_x`. This will make the tracer equations feel the immersed boundaries correctly. This also adds a very small 1D validation to test this. With a uniform buoyancy, validation checks if the buoyancy changes in time (it shouldn't). Below are the results before and after the fix. We can, of course, not include the validation and instead add a test for this.; ![b_plot1D_tracertest_bad](https://user-images.githubusercontent.com/67593861/129624223-70449ca0-5efb-4037-914a-20e1b565d4ca.png); ![b_plot1D_tracertest](https://user-images.githubusercontent.com/67593861/129624224-1eac8bae-7e78-4cc2-8b39-a202def6e975.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1935
https://github.com/CliMA/Oceananigans.jl/pull/1936:215,Performance,perform,perform,215,"This PR ""unrestricts"" (removes type annotations) from second and fourth derivative operators. These annotations are unnecessary, since the second and fourth derivative operators call first-derivative operators that perform appropriate dispatch. Also, the second vertical derivative operators are general (within the scope of current Oceananigans code) and should not be restricted. @jm-c does this fix your problem?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1936
https://github.com/CliMA/Oceananigans.jl/issues/1937:138,Testability,test,test,138,"PRs #1935 and #1936 fix bugs associated with `ImmersedBoundaryGrid`: the first is a functionality bug that needs a detailed functionality test to catch (for example, testing that budgets are correct with immersed boundaries); the second fixes a more trivial issue with dispatch. We have a small number of immersed boundary tests; however we need a more comprehensive suite of tests to ensure that immersed boundaries are compatible with various closures and advection schemes. I think we should use the hydrostatic model for these tests for the time being, because immersed boundaries with non hydrostatic models are still experimental and under development. cc @whitleyv @jm-c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1937
https://github.com/CliMA/Oceananigans.jl/issues/1937:166,Testability,test,testing,166,"PRs #1935 and #1936 fix bugs associated with `ImmersedBoundaryGrid`: the first is a functionality bug that needs a detailed functionality test to catch (for example, testing that budgets are correct with immersed boundaries); the second fixes a more trivial issue with dispatch. We have a small number of immersed boundary tests; however we need a more comprehensive suite of tests to ensure that immersed boundaries are compatible with various closures and advection schemes. I think we should use the hydrostatic model for these tests for the time being, because immersed boundaries with non hydrostatic models are still experimental and under development. cc @whitleyv @jm-c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1937
https://github.com/CliMA/Oceananigans.jl/issues/1937:323,Testability,test,tests,323,"PRs #1935 and #1936 fix bugs associated with `ImmersedBoundaryGrid`: the first is a functionality bug that needs a detailed functionality test to catch (for example, testing that budgets are correct with immersed boundaries); the second fixes a more trivial issue with dispatch. We have a small number of immersed boundary tests; however we need a more comprehensive suite of tests to ensure that immersed boundaries are compatible with various closures and advection schemes. I think we should use the hydrostatic model for these tests for the time being, because immersed boundaries with non hydrostatic models are still experimental and under development. cc @whitleyv @jm-c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1937
https://github.com/CliMA/Oceananigans.jl/issues/1937:376,Testability,test,tests,376,"PRs #1935 and #1936 fix bugs associated with `ImmersedBoundaryGrid`: the first is a functionality bug that needs a detailed functionality test to catch (for example, testing that budgets are correct with immersed boundaries); the second fixes a more trivial issue with dispatch. We have a small number of immersed boundary tests; however we need a more comprehensive suite of tests to ensure that immersed boundaries are compatible with various closures and advection schemes. I think we should use the hydrostatic model for these tests for the time being, because immersed boundaries with non hydrostatic models are still experimental and under development. cc @whitleyv @jm-c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1937
https://github.com/CliMA/Oceananigans.jl/issues/1937:531,Testability,test,tests,531,"PRs #1935 and #1936 fix bugs associated with `ImmersedBoundaryGrid`: the first is a functionality bug that needs a detailed functionality test to catch (for example, testing that budgets are correct with immersed boundaries); the second fixes a more trivial issue with dispatch. We have a small number of immersed boundary tests; however we need a more comprehensive suite of tests to ensure that immersed boundaries are compatible with various closures and advection schemes. I think we should use the hydrostatic model for these tests for the time being, because immersed boundaries with non hydrostatic models are still experimental and under development. cc @whitleyv @jm-c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1937
https://github.com/CliMA/Oceananigans.jl/issues/1938:53,Performance,race condition,race condition,53,"There appears to be the possibility of a write/write race condition at the corners in this case. Discovered with @sandreza. No bug has yet been detected, however.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1938
https://github.com/CliMA/Oceananigans.jl/issues/1938:144,Safety,detect,detected,144,"There appears to be the possibility of a write/write race condition at the corners in this case. Discovered with @sandreza. No bug has yet been detected, however.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1938
https://github.com/CliMA/Oceananigans.jl/pull/1940:18,Deployability,patch,patch,18,"This PR bumps the patch version in order to deploy docs, now that the `DOCUMENTER_KEY` environment variable should be correctly set for the tartarus buildkite agent. Resolves #1909",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1940
https://github.com/CliMA/Oceananigans.jl/pull/1940:44,Deployability,deploy,deploy,44,"This PR bumps the patch version in order to deploy docs, now that the `DOCUMENTER_KEY` environment variable should be correctly set for the tartarus buildkite agent. Resolves #1909",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1940
https://github.com/CliMA/Oceananigans.jl/pull/1940:99,Modifiability,variab,variable,99,"This PR bumps the patch version in order to deploy docs, now that the `DOCUMENTER_KEY` environment variable should be correctly set for the tartarus buildkite agent. Resolves #1909",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1940
https://github.com/CliMA/Oceananigans.jl/issues/1941:190,Energy Efficiency,allocate,allocate,190,Right now we are wasting memory and time computing free surface tendencies when `free_surface isa ImplicitFreeSurface` with `HydrostaticFreeSurfaceModel`. A minor optimization would neither allocate memory for the free surface tendencies or calculate them in this case.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1941
https://github.com/CliMA/Oceananigans.jl/issues/1941:163,Performance,optimiz,optimization,163,Right now we are wasting memory and time computing free surface tendencies when `free_surface isa ImplicitFreeSurface` with `HydrostaticFreeSurfaceModel`. A minor optimization would neither allocate memory for the free surface tendencies or calculate them in this case.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1941
https://github.com/CliMA/Oceananigans.jl/issues/1942:1783,Usability,simpl,simple,1783," 2), extent=(1, 1, 1)); RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (2, 2, 2); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.5, 0.5, 0.5). julia> c = CenterField(CPU(), grid); Field located at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (2, 2, 2); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> c0 = reshape(rand(2), 1, 1, 2); 1×1×2 Array{Float64, 3}:; [:, :, 1] =; 0.8285541189507857. [:, :, 2] =; 0.4097696419875272. julia> c .= c0 # should fill every c-column with identical values. julia> c[1, 1, :]; 4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:; 0.0; 0.8285541189507857; 0.4097696419875272; 0.0. julia> c[1, 2, :]; 4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:; 0.0; 0.4097696419875272; 2.3732366066e-314; 0.0. julia> c[2, 2, :]; 4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:; 0.0; 2.3732366066e-314; 2.2804048985e-314; 0.0. julia> c[2, 1, :]; 4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:; 0.0; 0.4097696419875272; 2.3732366066e-314; 0.0; ```. The column `c[1, 1, :]` is correct, but the others are not. We shouldn't work too hard here since something as simple as . ```julia; julia> interior(c) .= c0; 2×2×2 view(::Array{Float64, 3}, 2:3, 2:3, 2:3) with eltype Float64:; [:, :, 1] =; 0.828554 0.828554; 0.828554 0.828554. [:, :, 2] =; 0.40977 0.40977; 0.40977 0.40977. julia> c[2, 1, :]; 4-element OffsetArray(::Vector{Float64}, 0:3) with eltype Float64 with indices 0:3:; 0.0; 0.8285541189507857; 0.4097696419875272; 0.0; ```. is fine...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1942
https://github.com/CliMA/Oceananigans.jl/pull/1943:157,Deployability,update,updated,157,"I noticed some pages listed in library.mb didn't quite match the pages that are currently in `src`, mist notably (for me) `kernel_function_operation.jl`, so updated it. There probably are more discrepancies, but I also think we don't wanna list some of the more experimental features, so I left the rest as it was.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1943
https://github.com/CliMA/Oceananigans.jl/pull/1944:101,Performance,race condition,race conditions,101,"This changes the threading structure in a kernel launch to only launch over the i,j indices to avoid race conditions",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1944
https://github.com/CliMA/Oceananigans.jl/pull/1944:95,Safety,avoid,avoid,95,"This changes the threading structure in a kernel launch to only launch over the i,j indices to avoid race conditions",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1944
https://github.com/CliMA/Oceananigans.jl/issues/1946:386,Availability,error,error,386,"I am facing some issue with `TimeStepWizard`. It is saying that there is no method like `TimeStepWizard` , I have also faced this issue in previous version of `Oceananigans` but that time after updating `Oceananigans` resolved it. ; This time these are the information of version-; `Oceananigans` = `v0.61.3`; `julia` = `1.6.1`. I am pasting me whole code so that you can reproduce the error-; ```; using Printf; using Plots; using Oceananigans; using Oceananigans.Utils; using Oceananigans.Units: minutes, hour, hours, day; using Oceananigans.Grids: nodes; using Oceananigans.Diagnostics; using Oceananigans.OutputWriters: JLD2OutputWriter, FieldSlicer, TimeInterval; using Oceananigans.Diagnostics: accurate_cell_advection_timescale. #Defining Grid; #number of grid spacing in south,north and vertical direction; const Nx=256; const Ny=256; const Nz=64. #Length of grid in south, north and vertical direction; const Lx=4; const Ly=4; const Lz=0.1. const S = 1.6 # Stretching factor; hyperbolically_spaced_nodes(k) = -Lz-Lz*(tanh(S * ( (-(k-Nz-1) ) / Nz - 1)) / tanh(S)); computational_grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; architecture = CPU(),; x = (0,Lx),; y = (0,Ly),; halo = (3, 3, 3),; z_faces = hyperbolically_spaced_nodes). #Governing parameters ; #Coefficient of Thermal expansion; const alpha= 2e-4. #Coefficient of Salinity; const beta=8e-4. #diffusive viscocity; const v=1e-5 ; #diffusivity; const k=2e-6 . const f=0 #coriolis parameter; ; g = 300. #Temperature(Tracer) boundary condition ; Amplitude = 950 # Amplitude (W/m²) of Heat flux. Q_cool = -143.1092 # (W/m²) {due to Longwave + Latent heat + Sensible Heat}. gausian(t) = exp(-((t)^2)/(0.025*(86400)^2)) . # These are the times during which peak of the heat flux can be observed; peak1 = 0.56day; peak2 = 1.56day; peak3 = 2.56day; peak4 = 3.56day; peak5 = 4.56day; peak6 = 5.56day. # Heat absorbed due to shortwave; Q_sh(t) = Amplitude*(gausian(t-peak1) + gausian(t-peak2) + gausian(t-peak3) + gausian(t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946
https://github.com/CliMA/Oceananigans.jl/issues/1946:5468,Availability,error,error,5468,"n_timescale; wizard = TimeStepWizard(cfl=0.5,Δt=0.1, max_change=1.1, max_Δt=1minutes,cell_advection_timescale = accurate_cell_advection_timescale); start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model,; Δt = wizard,; stop_time = 6day,; iteration_interval = 1,; progress = progress_message; ); #Output; fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w, ""T"" => model.tracers.T). simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath=""DevangSetup.nc"",; schedule=TimeInterval(6) ); run!(simulation); ```. And the error message is following (I am pasting partially) -; ```; MethodError: no method matching zero(::TimeStepWizard{Float64, typeof(accurate_cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); Closest candidates are:; zero(::Union{Type{P}, P}) where P<:Dates.Period at C:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.6\Dates\src\periods.jl:53; zero(::Colorant) at C:\Users\My Account\.julia\packages\ColorTypes\6m8P7\src\traits.jl:477; zero(::TaylorSeries.Taylor1) at C:\Users\My Account\.julia\packages\TaylorSeries\tveWm\src\arithmetic.jl:37; ... Stacktrace:; [1] iszero(x::TimeStepWizard{Float64, typeof(accurate_cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); @ Base .\number.jl:40; [2] prettytime(t::TimeStepWizard{Float64, typeof(accurate_cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); @ Oceananigans.Utils C:\Users\My Account\.julia\packages\Oceananigans\To7WB\src\Utils\pretty_time.jl:18; ```; I am attaching the file of Initial data whi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946
https://github.com/CliMA/Oceananigans.jl/issues/1946:5409,Energy Efficiency,schedul,schedule,5409,"nstants:; set!(model, T = itemp, S = isal). #Setting up a simulation ; using Oceananigans.Diagnostics: accurate_cell_advection_timescale; wizard = TimeStepWizard(cfl=0.5,Δt=0.1, max_change=1.1, max_Δt=1minutes,cell_advection_timescale = accurate_cell_advection_timescale); start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model,; Δt = wizard,; stop_time = 6day,; iteration_interval = 1,; progress = progress_message; ); #Output; fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w, ""T"" => model.tracers.T). simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath=""DevangSetup.nc"",; schedule=TimeInterval(6) ); run!(simulation); ```. And the error message is following (I am pasting partially) -; ```; MethodError: no method matching zero(::TimeStepWizard{Float64, typeof(accurate_cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); Closest candidates are:; zero(::Union{Type{P}, P}) where P<:Dates.Period at C:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.6\Dates\src\periods.jl:53; zero(::Colorant) at C:\Users\My Account\.julia\packages\ColorTypes\6m8P7\src\traits.jl:477; zero(::TaylorSeries.Taylor1) at C:\Users\My Account\.julia\packages\TaylorSeries\tveWm\src\arithmetic.jl:37; ... Stacktrace:; [1] iszero(x::TimeStepWizard{Float64, typeof(accurate_cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); @ Base .\number.jl:40; [2] prettytime(t::TimeStepWizard{Float64, typeof(accurate_cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); @ Oceananigans.Utils C:\Use",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946
https://github.com/CliMA/Oceananigans.jl/issues/1946:3396,Integrability,depend,depends,3396,"lier = 0; else; bias = 0; multiplier = 1; end; ; Q_band1(z) = (params.Ι/params.λ1)*exp(-z/params.λ1) ; Q_band2(z) = (params.Ι/params.λ2)*exp(-z/params.λ2); ; if z >= computational_grid.zᵃᵃᶜ[Nz]; cooling_source = multiplier*Q_cool/(params.ρ*params.Cp*computational_grid.Δzᵃᵃᶜ[Nz]); return Q_sh(t) * (Q_band1(z) + Q_band2(z))/(params.ρ*params.Cp) + (cooling_source*computational_grid.Δzᵃᵃᶜ[Nz]). else ; return Q_sh(t) * (Q_band1(z) + Q_band2(z))/(params.ρ*params.Cp); end. end; ShortWavePenetration_parameters = (ρ = 1000,; Cp = 4182,; λ1 = 0.35,; λ2 = 23.0,; Ι = 0.58; ); heat_source_term = Forcing(ShortWavePenetration,; parameters = ShortWavePenetration_parameters). #Velocity Boundary conditions ; const Qᵘ=0; u_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ), bottom=ValueBoundaryCondition(0.0)); v_bcs = FieldBoundaryConditions(top = FluxBoundaryCondition(Qᵘ), bottom=ValueBoundaryCondition(0.0)). #Buoyancy that depends on temperature and salinity ; buoyancy = SeawaterBuoyancy(gravitational_acceleration = g,equation_of_state=LinearEquationOfState(α=alpha, β=beta)). #Model instantiation ; using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = NonhydrostaticModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; tracers = (:T, :S),; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; forcing = (T=heat_source_term,),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)). #Setting Initial Conditions ; using CSV; using DataFrames; initial_temperature = Matrix(CSV.read(""initial_temperature.csv"", DataFrame)); itemp = zeros(Nx, Ny, Nz); for x ∈ 1:Nx; for y ∈ 1:Ny; itemp[x,y,:] = initial_temperature; end; end. initial_salinity = Matrix(CSV.read(""initial_salinity.csv"", DataFrame)); isal = zeros(Nx, Ny, Nz); for x ∈ 1:Nx; for y ∈ 1:Ny; isal[x,y,:] = initial_salinity; end; end. # `set!` the `model` fields using functions or constants:; set!(model, T = itemp, S ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946
https://github.com/CliMA/Oceananigans.jl/issues/1946:4793,Integrability,message,message,4793,"= FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; forcing = (T=heat_source_term,),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)). #Setting Initial Conditions ; using CSV; using DataFrames; initial_temperature = Matrix(CSV.read(""initial_temperature.csv"", DataFrame)); itemp = zeros(Nx, Ny, Nz); for x ∈ 1:Nx; for y ∈ 1:Ny; itemp[x,y,:] = initial_temperature; end; end. initial_salinity = Matrix(CSV.read(""initial_salinity.csv"", DataFrame)); isal = zeros(Nx, Ny, Nz); for x ∈ 1:Nx; for y ∈ 1:Ny; isal[x,y,:] = initial_salinity; end; end. # `set!` the `model` fields using functions or constants:; set!(model, T = itemp, S = isal). #Setting up a simulation ; using Oceananigans.Diagnostics: accurate_cell_advection_timescale; wizard = TimeStepWizard(cfl=0.5,Δt=0.1, max_change=1.1, max_Δt=1minutes,cell_advection_timescale = accurate_cell_advection_timescale); start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model,; Δt = wizard,; stop_time = 6day,; iteration_interval = 1,; progress = progress_message; ); #Output; fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w, ""T"" => model.tracers.T). simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath=""DevangSetup.nc"",; schedule=TimeInterval(6) ); run!(simulation); ```. And the error message is following (I am pasting partially) -; ```; MethodError: no method matching zero(::TimeStepWizard{Float64, typeof(accurate_cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); Closest candidates are:; zero(::Union{Type{P}, P}) where P<:Dates.Period at C:\buildbot\worker\package_win64\build\usr\sha",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946
https://github.com/CliMA/Oceananigans.jl/issues/1946:5474,Integrability,message,message,5474,"n_timescale; wizard = TimeStepWizard(cfl=0.5,Δt=0.1, max_change=1.1, max_Δt=1minutes,cell_advection_timescale = accurate_cell_advection_timescale); start_time = time_ns() # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model,; Δt = wizard,; stop_time = 6day,; iteration_interval = 1,; progress = progress_message; ); #Output; fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w, ""T"" => model.tracers.T). simulation.output_writers[:fields] =; NetCDFOutputWriter(model, fields, filepath=""DevangSetup.nc"",; schedule=TimeInterval(6) ); run!(simulation); ```. And the error message is following (I am pasting partially) -; ```; MethodError: no method matching zero(::TimeStepWizard{Float64, typeof(accurate_cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); Closest candidates are:; zero(::Union{Type{P}, P}) where P<:Dates.Period at C:\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.6\Dates\src\periods.jl:53; zero(::Colorant) at C:\Users\My Account\.julia\packages\ColorTypes\6m8P7\src\traits.jl:477; zero(::TaylorSeries.Taylor1) at C:\Users\My Account\.julia\packages\TaylorSeries\tveWm\src\arithmetic.jl:37; ... Stacktrace:; [1] iszero(x::TimeStepWizard{Float64, typeof(accurate_cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); @ Base .\number.jl:40; [2] prettytime(t::TimeStepWizard{Float64, typeof(accurate_cell_advection_timescale), typeof(Oceananigans.Simulations.infinite_diffusion_timescale)}); @ Oceananigans.Utils C:\Users\My Account\.julia\packages\Oceananigans\To7WB\src\Utils\pretty_time.jl:18; ```; I am attaching the file of Initial data whi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1946
https://github.com/CliMA/Oceananigans.jl/pull/1947:12,Testability,test,test,12,"This adds a test that should fail; but we should be able to fix it by defining . ```julia; @inline Base.Broadcast.materialize!(dest::AbstractField, bc::Broadcasted{<:DefaultArrayStyle}) =; Base.Broadcast.materialize!(interior(dest), bc); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1947
https://github.com/CliMA/Oceananigans.jl/issues/1948:534,Availability,down,down,534,"Thanks to @hennyg888 , we now have scalings results for the distributed shallow water and nonhydrostatic models for both weak and strong scaling going up to 128 cores. . https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/appendix/benchmarks.md. The good news is that the `ShallowWaterModel`, in both weak and strong scaling, reaches efficienties of around 80% on 128 cores. This is something we can probably make better but not the first concern. The not so good news is that the `NonhydrostaticModel`, the efficiency goes down close to 10%. I don't know why but wanted to mention it as it's something that we should be able to do much better with. Thoughts? @christophernhill @glwagner @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1948
https://github.com/CliMA/Oceananigans.jl/issues/1948:344,Energy Efficiency,efficient,efficienties,344,"Thanks to @hennyg888 , we now have scalings results for the distributed shallow water and nonhydrostatic models for both weak and strong scaling going up to 128 cores. . https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/appendix/benchmarks.md. The good news is that the `ShallowWaterModel`, in both weak and strong scaling, reaches efficienties of around 80% on 128 cores. This is something we can probably make better but not the first concern. The not so good news is that the `NonhydrostaticModel`, the efficiency goes down close to 10%. I don't know why but wanted to mention it as it's something that we should be able to do much better with. Thoughts? @christophernhill @glwagner @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1948
https://github.com/CliMA/Oceananigans.jl/issues/1948:241,Testability,benchmark,benchmarks,241,"Thanks to @hennyg888 , we now have scalings results for the distributed shallow water and nonhydrostatic models for both weak and strong scaling going up to 128 cores. . https://github.com/CliMA/Oceananigans.jl/blob/master/docs/src/appendix/benchmarks.md. The good news is that the `ShallowWaterModel`, in both weak and strong scaling, reaches efficienties of around 80% on 128 cores. This is something we can probably make better but not the first concern. The not so good news is that the `NonhydrostaticModel`, the efficiency goes down close to 10%. I don't know why but wanted to mention it as it's something that we should be able to do much better with. Thoughts? @christophernhill @glwagner @ali-ramadhan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1948
https://github.com/CliMA/Oceananigans.jl/pull/1952:123,Deployability,update,updated,123,I created a clean branch from the latest version of master that passed the documentation buildkite test. Looking at my old updated `benchmarks.md` through a markdown viewer/editor and I saw that a table that's written in HTML might be causing trouble so I replaced it with a code block quote table.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1952
https://github.com/CliMA/Oceananigans.jl/pull/1952:99,Testability,test,test,99,I created a clean branch from the latest version of master that passed the documentation buildkite test. Looking at my old updated `benchmarks.md` through a markdown viewer/editor and I saw that a table that's written in HTML might be causing trouble so I replaced it with a code block quote table.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1952
https://github.com/CliMA/Oceananigans.jl/pull/1952:132,Testability,benchmark,benchmarks,132,I created a clean branch from the latest version of master that passed the documentation buildkite test. Looking at my old updated `benchmarks.md` through a markdown viewer/editor and I saw that a table that's written in HTML might be causing trouble so I replaced it with a code block quote table.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1952
https://github.com/CliMA/Oceananigans.jl/pull/1953:4,Testability,benchmark,benchmark,4,fix benchmark link,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1953
https://github.com/CliMA/Oceananigans.jl/issues/1956:847,Safety,avoid,avoid,847,"https://github.com/CliMA/Oceananigans.jl/blob/2bb159c74774309ca1c80004e8cf5b5ae195d9f8/src/Grids/automatic_halo_sizing.jl#L40-L44. For example. ```Julia; julia> using Oceananigans; [ Info: Oceananigans will use 12 threads. julia> grid = RegularRectilinearGrid(size = (10, 20), extent=(1, 2), topology=(Bounded, Bounded, Flat)); RegularRectilinearGrid{Float64, Bounded, Bounded, Flat}; domain: x ∈ [-1.6190752442450216e-17, 0.9999999999999999], y ∈ [0.0, 2.0], z ∈ [0.0, 0.0]; topology: (Bounded, Bounded, Flat); resolution (Nx, Ny, Nz): (10, 20, 1); halo size (Hx, Hy, Hz): (1, 1, 0); grid spacing (Δx, Δy, Δz): (0.1, 0.1, 0.0). julia> model = NonhydrostaticModel(grid=grid, advection = UpwindBiasedFifthOrder()); ┌ Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids ~/.julia/packages/Oceananigans/9o1xJ/src/Grids/automatic_halo_sizing.jl:41; NonhydrostaticModel{CPU, Float64}(time = 0 seconds, iteration = 0); ├── grid: RegularRectilinearGrid{Float64, Bounded, Bounded, Flat}(Nx=10, Ny=20, Nz=1); ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: SeawaterBuoyancy{Float64, LinearEquationOfState{Float64}, Nothing, Nothing}; └── coriolis: Nothing; ```; while, because `topology=(Bounded, Bounded, Flat)` we need to pass `halo=(3, 3)` to grid.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1956
https://github.com/CliMA/Oceananigans.jl/pull/1957:210,Deployability,update,updated,210,"This introduces `UpwindBiasedFirstOrder` advection, and is in part inspired by #1955. This scheme is first order accurate but has the advantage of preserving positivity and extrema. The plot for convergence is updated and we see that it does have the slope that is predicted from the theory. ![convergence_rates](https://user-images.githubusercontent.com/8239041/130524906-d3afbae0-651d-4c9a-aee8-b0fb4d9dc856.png). I set the `symmetric_interpolate`'s to zero, which I think is true, but not sure if anything else should be done here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957
https://github.com/CliMA/Oceananigans.jl/pull/1957:265,Safety,predict,predicted,265,"This introduces `UpwindBiasedFirstOrder` advection, and is in part inspired by #1955. This scheme is first order accurate but has the advantage of preserving positivity and extrema. The plot for convergence is updated and we see that it does have the slope that is predicted from the theory. ![convergence_rates](https://user-images.githubusercontent.com/8239041/130524906-d3afbae0-651d-4c9a-aee8-b0fb4d9dc856.png). I set the `symmetric_interpolate`'s to zero, which I think is true, but not sure if anything else should be done here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1957
https://github.com/CliMA/Oceananigans.jl/issues/1958:873,Availability,error,error,873,"This is a rather minimal example that tries to use `PrescribedVelocityFields` in the `ImmersedBoundaryMethod`,. ```; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. grid = RegularRectilinearGrid(size=(16, 8),; y=(-1, 1), z=(-1, 0), ; topology=(Flat, Periodic, Bounded)). seamount(x, y, z) = z < - 1 + 0.1*exp(-y^2/0.25^2) . grid_with_seamount = ImmersedBoundaryGrid(grid, GridFittedBoundary(seamount)). U(x, y, z) = 0.; V(x, y, z) = 0.; W(x, y, z) = 0. velocities = PrescribedVelocityFields(u=U, v=V, w=W). model = HydrostaticFreeSurfaceModel(architecture = CPU(), ; grid = grid_with_seamount,; momentum_advection = CenteredSecondOrder(), ; free_surface = ImplicitFreeSurface(),; closure = nothing, ; tracers = :b,; velocities = velocities,; buoyancy = BuoyancyTracer()); ```. Unfortunately, it fails with the following error,. ```; ERROR: LoadError: MethodError: no method matching device(::Nothing); Closest candidates are:; device(::Oceananigans.Architectures.AbstractCPUArchitecture) at /home/fpoulin/.julia/packages/Oceananigans/X0YQn/src/Architectures.jl:50; device(::Oceananigans.Architectures.AbstractGPUArchitecture) at /home/fpoulin/.julia/packages/Oceananigans/X0YQn/src/Architectures.jl:51; Stacktrace:; [1] device_event(arch::Nothing); @ Oceananigans.Architectures ~/.julia/packages/Oceananigans/X0YQn/src/Architectures.jl:75; [2] mask_immersed_field!(field::Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, Nothing, typeof(U), ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64}, grid::ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1958:886,Availability,ERROR,ERROR,886,"This is a rather minimal example that tries to use `PrescribedVelocityFields` in the `ImmersedBoundaryMethod`,. ```; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. grid = RegularRectilinearGrid(size=(16, 8),; y=(-1, 1), z=(-1, 0), ; topology=(Flat, Periodic, Bounded)). seamount(x, y, z) = z < - 1 + 0.1*exp(-y^2/0.25^2) . grid_with_seamount = ImmersedBoundaryGrid(grid, GridFittedBoundary(seamount)). U(x, y, z) = 0.; V(x, y, z) = 0.; W(x, y, z) = 0. velocities = PrescribedVelocityFields(u=U, v=V, w=W). model = HydrostaticFreeSurfaceModel(architecture = CPU(), ; grid = grid_with_seamount,; momentum_advection = CenteredSecondOrder(), ; free_surface = ImplicitFreeSurface(),; closure = nothing, ; tracers = :b,; velocities = velocities,; buoyancy = BuoyancyTracer()); ```. Unfortunately, it fails with the following error,. ```; ERROR: LoadError: MethodError: no method matching device(::Nothing); Closest candidates are:; device(::Oceananigans.Architectures.AbstractCPUArchitecture) at /home/fpoulin/.julia/packages/Oceananigans/X0YQn/src/Architectures.jl:50; device(::Oceananigans.Architectures.AbstractGPUArchitecture) at /home/fpoulin/.julia/packages/Oceananigans/X0YQn/src/Architectures.jl:51; Stacktrace:; [1] device_event(arch::Nothing); @ Oceananigans.Architectures ~/.julia/packages/Oceananigans/X0YQn/src/Architectures.jl:75; [2] mask_immersed_field!(field::Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, Nothing, typeof(U), ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64}, grid::ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1958:31229,Availability,Down,Downloads,31229,"oundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Nothing, NamedTuple{(), Tuple{}}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/X0YQn/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:18; [10] HydrostaticFreeSurfaceModel(; grid::ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, architecture::CPU, clock::Clock{Float64}, momentum_advection::CenteredSecondOrder, tracer_advection::CenteredSecondOrder, buoyancy::BuoyancyTracer, coriolis::Nothing, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Symbol, particles::Nothing, velocities::PrescribedVelocityFields{typeof(U), typeof(V), typeof(W), Nothing}, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/X0YQn/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:182; [11] top-level scope; @ ~/Downloads/test_prescribed.jl:19; [12] include(fname::String); @ Base.MainInclude ./client.jl:444; [13] top-level scope; @ REPL[1]:1; [14] top-level scope; @ ~/.julia/packages/CUDA/VGl9W/src/initialization.jl:66; in expression starting at /home/fpoulin/Downloads/test_prescribed.jl:19; ```. cc: @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1958:31481,Availability,Down,Downloads,31481,"oundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Nothing, NamedTuple{(), Tuple{}}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/X0YQn/src/Models/HydrostaticFreeSurfaceModels/update_hydrostatic_free_surface_model_state.jl:18; [10] HydrostaticFreeSurfaceModel(; grid::ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, architecture::CPU, clock::Clock{Float64}, momentum_advection::CenteredSecondOrder, tracer_advection::CenteredSecondOrder, buoyancy::BuoyancyTracer, coriolis::Nothing, free_surface::ImplicitFreeSurface{Nothing, Float64, Nothing, Nothing, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, forcing::NamedTuple{(), Tuple{}}, closure::Nothing, boundary_conditions::NamedTuple{(), Tuple{}}, tracers::Symbol, particles::Nothing, velocities::PrescribedVelocityFields{typeof(U), typeof(V), typeof(W), Nothing}, pressure::Nothing, diffusivity_fields::Nothing, auxiliary_fields::NamedTuple{(), Tuple{}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/X0YQn/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:182; [11] top-level scope; @ ~/Downloads/test_prescribed.jl:19; [12] include(fname::String); @ Base.MainInclude ./client.jl:444; [13] top-level scope; @ REPL[1]:1; [14] top-level scope; @ ~/.julia/packages/CUDA/VGl9W/src/initialization.jl:66; in expression starting at /home/fpoulin/Downloads/test_prescribed.jl:19; ```. cc: @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1958:3747,Energy Efficiency,Reduce,ReducedField,3747,"packages/Oceananigans/X0YQn/src/ImmersedBoundaries/mask_immersed_field.jl:6; [4] iterate; @ ./generator.jl:47 [inlined]; [5] collect(itr::Base.Generator{NamedTuple{(:u, :v, :η, :b), Tuple{Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, Nothing, typeof(U), ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64}, Oceananigans.Fields.FunctionField{Center, Face, Center, Clock{Float64}, Nothing, typeof(V), ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64}, Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Field{Center, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1958:6091,Energy Efficiency,Reduce,ReducedField,6091,"{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, typeof(mask_immersed_field!)}); @ Base ./array.jl:678; [6] _totuple(::Type{Tuple}, ::Base.Generator{NamedTuple{(:u, :v, :η, :b), Tuple{Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, Nothing, typeof(U), ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64}, Oceananigans.Fields.FunctionField{Center, Face, Center, Clock{Float64}, Nothing, typeof(V), ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64}, Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Field{Center, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1958:8420,Energy Efficiency,Reduce,ReducedField,8420,"undaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, typeof(mask_immersed_field!)}); @ Base ./tuple.jl:331; [7] Tuple(itr::Base.Generator{NamedTuple{(:u, :v, :η, :b), Tuple{Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, Nothing, typeof(U), ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64}, Oceananigans.Fields.FunctionField{Center, Face, Center, Clock{Float64}, Nothing, typeof(V), ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64}, Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Field{Center, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1958:10911,Energy Efficiency,Reduce,ReducedField,10911,"eSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :b), Tuple{Nothing, Nothing, Nothing, Field{Center, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Nothing}, Nothing, CPU, ImplicitFreeSurface{Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Float64, NamedTuple{(:u, :v), Tuple{Oceananigans.Fields.ReducedField{Face, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePreci",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1958:11627,Energy Efficiency,Reduce,ReducedField,11627,"ondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Nothing}, Nothing, CPU, ImplicitFreeSurface{Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Float64, NamedTuple{(:u, :v), Tuple{Oceananigans.Fields.ReducedField{Face, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Oceananigans.Fields.ReducedField{Center, Face, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1958:12305,Energy Efficiency,Reduce,ReducedField,12305,"ng, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Float64, NamedTuple{(:u, :v), Tuple{Oceananigans.Fields.ReducedField{Face, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Oceananigans.Fields.ReducedField{Center, Face, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Oceananigans.Models.HydrostaticFreeSurfaceModels.PCGImplicitFreeSurfaceSolver{NamedTuple{(:xᶠᶜᶜ, :yᶜᶠᶜ), Tuple{Oceananigans.Fields.ReducedField{Face, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1958:13096,Energy Efficiency,Reduce,ReducedField,13096,"ing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Oceananigans.Fields.ReducedField{Center, Face, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Oceananigans.Models.HydrostaticFreeSurfaceModels.PCGImplicitFreeSurfaceSolver{NamedTuple{(:xᶠᶜᶜ, :yᶜᶠᶜ), Tuple{Oceananigans.Fields.ReducedField{Face, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Oceananigans.Fields.ReducedField{Center, Face, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1958:13774,Energy Efficiency,Reduce,ReducedField,13774,"ing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Oceananigans.Models.HydrostaticFreeSurfaceModels.PCGImplicitFreeSurfaceSolver{NamedTuple{(:xᶠᶜᶜ, :yᶜᶠᶜ), Tuple{Oceananigans.Fields.ReducedField{Face, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Oceananigans.Fields.ReducedField{Center, Face, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Oceananigans.Solvers.PreconditionedConjugateGradientSolver{CPU, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, typeof(Oceananigans.Mod",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1958:14905,Energy Efficiency,Reduce,ReducedField,14905,"rRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Oceananigans.Solvers.PreconditionedConjugateGradientSolver{CPU, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.implicit_free_surface_linear_operation!), Float64, Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Nothing, Nothing}, Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1958:15604,Energy Efficiency,Reduce,ReducedField,15604,"tor{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.implicit_free_surface_linear_operation!), Float64, Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Nothing, Nothing}, Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1958:21148,Energy Efficiency,Reduce,ReducedField,21148,"eSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :b), Tuple{Nothing, Nothing, Nothing, Field{Center, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Nothing}, Nothing, CPU, ImplicitFreeSurface{Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Float64, NamedTuple{(:u, :v), Tuple{Oceananigans.Fields.ReducedField{Face, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePreci",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1958:21864,Energy Efficiency,Reduce,ReducedField,21864,"ondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Nothing}, Nothing, CPU, ImplicitFreeSurface{Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Float64, NamedTuple{(:u, :v), Tuple{Oceananigans.Fields.ReducedField{Face, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Oceananigans.Fields.ReducedField{Center, Face, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1958:22542,Energy Efficiency,Reduce,ReducedField,22542,"ng, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Float64, NamedTuple{(:u, :v), Tuple{Oceananigans.Fields.ReducedField{Face, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Oceananigans.Fields.ReducedField{Center, Face, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Oceananigans.Models.HydrostaticFreeSurfaceModels.PCGImplicitFreeSurfaceSolver{NamedTuple{(:xᶠᶜᶜ, :yᶜᶠᶜ), Tuple{Oceananigans.Fields.ReducedField{Face, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1958:23333,Energy Efficiency,Reduce,ReducedField,23333,"ing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Oceananigans.Fields.ReducedField{Center, Face, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Oceananigans.Models.HydrostaticFreeSurfaceModels.PCGImplicitFreeSurfaceSolver{NamedTuple{(:xᶠᶜᶜ, :yᶜᶠᶜ), Tuple{Oceananigans.Fields.ReducedField{Face, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Oceananigans.Fields.ReducedField{Center, Face, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1958:24011,Energy Efficiency,Reduce,ReducedField,24011,"ing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Oceananigans.Models.HydrostaticFreeSurfaceModels.PCGImplicitFreeSurfaceSolver{NamedTuple{(:xᶠᶜᶜ, :yᶜᶠᶜ), Tuple{Oceananigans.Fields.ReducedField{Face, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Oceananigans.Fields.ReducedField{Center, Face, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Oceananigans.Solvers.PreconditionedConjugateGradientSolver{CPU, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, typeof(Oceananigans.Mod",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1958:25142,Energy Efficiency,Reduce,ReducedField,25142,"rRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}, Oceananigans.Solvers.PreconditionedConjugateGradientSolver{CPU, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.implicit_free_surface_linear_operation!), Float64, Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Nothing, Nothing}, Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1958:25841,Energy Efficiency,Reduce,ReducedField,25841,"tor{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.implicit_free_surface_linear_operation!), Float64, Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, Nothing, Nothing}, Oceananigans.Fields.ReducedField{Center, Center, Nothing, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64, 1, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}, Symbol, Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}}, ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1958:893,Performance,Load,LoadError,893,"This is a rather minimal example that tries to use `PrescribedVelocityFields` in the `ImmersedBoundaryMethod`,. ```; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. grid = RegularRectilinearGrid(size=(16, 8),; y=(-1, 1), z=(-1, 0), ; topology=(Flat, Periodic, Bounded)). seamount(x, y, z) = z < - 1 + 0.1*exp(-y^2/0.25^2) . grid_with_seamount = ImmersedBoundaryGrid(grid, GridFittedBoundary(seamount)). U(x, y, z) = 0.; V(x, y, z) = 0.; W(x, y, z) = 0. velocities = PrescribedVelocityFields(u=U, v=V, w=W). model = HydrostaticFreeSurfaceModel(architecture = CPU(), ; grid = grid_with_seamount,; momentum_advection = CenteredSecondOrder(), ; free_surface = ImplicitFreeSurface(),; closure = nothing, ; tracers = :b,; velocities = velocities,; buoyancy = BuoyancyTracer()); ```. Unfortunately, it fails with the following error,. ```; ERROR: LoadError: MethodError: no method matching device(::Nothing); Closest candidates are:; device(::Oceananigans.Architectures.AbstractCPUArchitecture) at /home/fpoulin/.julia/packages/Oceananigans/X0YQn/src/Architectures.jl:50; device(::Oceananigans.Architectures.AbstractGPUArchitecture) at /home/fpoulin/.julia/packages/Oceananigans/X0YQn/src/Architectures.jl:51; Stacktrace:; [1] device_event(arch::Nothing); @ Oceananigans.Architectures ~/.julia/packages/Oceananigans/X0YQn/src/Architectures.jl:75; [2] mask_immersed_field!(field::Oceananigans.Fields.FunctionField{Face, Center, Center, Clock{Float64}, Nothing, typeof(U), ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{Nothing, typeof(seamount)}}, Float64}, grid::ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded, RegularRectilinearGrid{Float64, Flat, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1958
https://github.com/CliMA/Oceananigans.jl/issues/1965:25,Usability,clear,clear,25,"The doc does not make it clear to me how to know which input is expected when using `AveragedField`. E.g. the following line. How do I decide what dims() should be?. `T_avg = AveragedField(model.tracers.T, dims=(1, 2))`. The [library](https://clima.github.io/OceananigansDocumentation/stable/appendix/library/#Output-writers) search for `AveragedField` doesn't give away much information either.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1965
https://github.com/CliMA/Oceananigans.jl/issues/1968:771,Availability,error,error,771,"`FieldBoundaryConditions` has two constructors: one for ""prognostic"" fields and one for ""auxiliary"" fields:. 1. `FieldBoundaryCondition(; kwargs...)` for prognostic fields;; 2. `FieldBoundaryCondition(grid, location; kwargs...)` for auxiliary fields.; ; The distinction is that boundary conditions on _prognostic_ fields are ""regularized"" within a model constructor, and can be complex (can depend nonlinearly on other fields). Boundary conditions on auxiliary fields must be simpler and are not regularized, which is why `grid` and `location` are required for auxiliary boundary conditions. It's easy for a user to mistakenly apply prognostic boundary conditions to an auxiliary field by using the wrong constructor. To help users fix this issue, we should throw a nice error when `fill_side_halo!` (where `side = (east, west, north, south, top, bottom))` is called with the ""specification"" type `DefaultPrognosticFieldBoundaryCondition` rather than a ""real"" (regularized or simple) `BoundaryCondition`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1968
https://github.com/CliMA/Oceananigans.jl/issues/1968:391,Integrability,depend,depend,391,"`FieldBoundaryConditions` has two constructors: one for ""prognostic"" fields and one for ""auxiliary"" fields:. 1. `FieldBoundaryCondition(; kwargs...)` for prognostic fields;; 2. `FieldBoundaryCondition(grid, location; kwargs...)` for auxiliary fields.; ; The distinction is that boundary conditions on _prognostic_ fields are ""regularized"" within a model constructor, and can be complex (can depend nonlinearly on other fields). Boundary conditions on auxiliary fields must be simpler and are not regularized, which is why `grid` and `location` are required for auxiliary boundary conditions. It's easy for a user to mistakenly apply prognostic boundary conditions to an auxiliary field by using the wrong constructor. To help users fix this issue, we should throw a nice error when `fill_side_halo!` (where `side = (east, west, north, south, top, bottom))` is called with the ""specification"" type `DefaultPrognosticFieldBoundaryCondition` rather than a ""real"" (regularized or simple) `BoundaryCondition`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1968
https://github.com/CliMA/Oceananigans.jl/issues/1968:476,Usability,simpl,simpler,476,"`FieldBoundaryConditions` has two constructors: one for ""prognostic"" fields and one for ""auxiliary"" fields:. 1. `FieldBoundaryCondition(; kwargs...)` for prognostic fields;; 2. `FieldBoundaryCondition(grid, location; kwargs...)` for auxiliary fields.; ; The distinction is that boundary conditions on _prognostic_ fields are ""regularized"" within a model constructor, and can be complex (can depend nonlinearly on other fields). Boundary conditions on auxiliary fields must be simpler and are not regularized, which is why `grid` and `location` are required for auxiliary boundary conditions. It's easy for a user to mistakenly apply prognostic boundary conditions to an auxiliary field by using the wrong constructor. To help users fix this issue, we should throw a nice error when `fill_side_halo!` (where `side = (east, west, north, south, top, bottom))` is called with the ""specification"" type `DefaultPrognosticFieldBoundaryCondition` rather than a ""real"" (regularized or simple) `BoundaryCondition`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1968
https://github.com/CliMA/Oceananigans.jl/issues/1968:976,Usability,simpl,simple,976,"`FieldBoundaryConditions` has two constructors: one for ""prognostic"" fields and one for ""auxiliary"" fields:. 1. `FieldBoundaryCondition(; kwargs...)` for prognostic fields;; 2. `FieldBoundaryCondition(grid, location; kwargs...)` for auxiliary fields.; ; The distinction is that boundary conditions on _prognostic_ fields are ""regularized"" within a model constructor, and can be complex (can depend nonlinearly on other fields). Boundary conditions on auxiliary fields must be simpler and are not regularized, which is why `grid` and `location` are required for auxiliary boundary conditions. It's easy for a user to mistakenly apply prognostic boundary conditions to an auxiliary field by using the wrong constructor. To help users fix this issue, we should throw a nice error when `fill_side_halo!` (where `side = (east, west, north, south, top, bottom))` is called with the ""specification"" type `DefaultPrognosticFieldBoundaryCondition` rather than a ""real"" (regularized or simple) `BoundaryCondition`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1968
https://github.com/CliMA/Oceananigans.jl/pull/1970:49,Availability,mask,mask,49,"This optional positional argument can be used to mask a field with a value other than 0. The syntax is supposed to be. ```julia; mask_immersed_field!(c, NaN); ```. to mask a field to `NaN`, for example. cc @francispoulin @fadaie91",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1970
https://github.com/CliMA/Oceananigans.jl/pull/1970:167,Availability,mask,mask,167,"This optional positional argument can be used to mask a field with a value other than 0. The syntax is supposed to be. ```julia; mask_immersed_field!(c, NaN); ```. to mask a field to `NaN`, for example. cc @francispoulin @fadaie91",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1970
https://github.com/CliMA/Oceananigans.jl/pull/1971:1353,Deployability,update,updated,1353,"This PR overhauls the API for `Simulation`, `TimeStepWizard`, and printing of progress. It also simplifies the implementation of `run!`. After this PR, `Simulation` no longer accepts the keyword arguments `iteration_interval` or `progress`. Instead, progress printing is achieved with callbacks, eg:. ```julia; progress(sim) = @info ""Iteration: $(iteration(sim)), time: $(time(sim))""; simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)); ```. It also refactors the `TimeStepWizard` so that it can be used as a callback, eg. ```julia; wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=2minutes); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)); ```. This is a better design for a few reasons:. 1. Adaptive time-stepping and progress printing are not longer arbitrarily constrained to occur on the same iteration interval.; 2. Both progress printing and adaptive time-stepping can use any `schedule` (rather than only `IterationInterval`).; 3. The simulation time-step is always `simulation.Δt`. No more shenanigans like `simulation.Δt.Δt`. Eventually, we should also eliminate the ""diagnostics"" list so that we have only two lists of callback-like objects: `simulation.callbacks` and `simulation.output_writers`. I think this resolves an issue or two but I need to find them. Also, I've so far only updated the examples. There are probably tests and validation cases that need to be updated for the new API as well. This PR is an important step toward generalizing `Oceananigans.Simulation` so that it can be used by [`ClimaAtmos.jl`](https://github.com/CliMA/ClimaAtmos.jl). cc @bischtob @akshaysridhar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971
https://github.com/CliMA/Oceananigans.jl/pull/1971:1437,Deployability,update,updated,1437,"This PR overhauls the API for `Simulation`, `TimeStepWizard`, and printing of progress. It also simplifies the implementation of `run!`. After this PR, `Simulation` no longer accepts the keyword arguments `iteration_interval` or `progress`. Instead, progress printing is achieved with callbacks, eg:. ```julia; progress(sim) = @info ""Iteration: $(iteration(sim)), time: $(time(sim))""; simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)); ```. It also refactors the `TimeStepWizard` so that it can be used as a callback, eg. ```julia; wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=2minutes); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)); ```. This is a better design for a few reasons:. 1. Adaptive time-stepping and progress printing are not longer arbitrarily constrained to occur on the same iteration interval.; 2. Both progress printing and adaptive time-stepping can use any `schedule` (rather than only `IterationInterval`).; 3. The simulation time-step is always `simulation.Δt`. No more shenanigans like `simulation.Δt.Δt`. Eventually, we should also eliminate the ""diagnostics"" list so that we have only two lists of callback-like objects: `simulation.callbacks` and `simulation.output_writers`. I think this resolves an issue or two but I need to find them. Also, I've so far only updated the examples. There are probably tests and validation cases that need to be updated for the new API as well. This PR is an important step toward generalizing `Oceananigans.Simulation` so that it can be used by [`ClimaAtmos.jl`](https://github.com/CliMA/ClimaAtmos.jl). cc @bischtob @akshaysridhar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971
https://github.com/CliMA/Oceananigans.jl/pull/1971:751,Energy Efficiency,Adapt,Adaptive,751,"This PR overhauls the API for `Simulation`, `TimeStepWizard`, and printing of progress. It also simplifies the implementation of `run!`. After this PR, `Simulation` no longer accepts the keyword arguments `iteration_interval` or `progress`. Instead, progress printing is achieved with callbacks, eg:. ```julia; progress(sim) = @info ""Iteration: $(iteration(sim)), time: $(time(sim))""; simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)); ```. It also refactors the `TimeStepWizard` so that it can be used as a callback, eg. ```julia; wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=2minutes); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)); ```. This is a better design for a few reasons:. 1. Adaptive time-stepping and progress printing are not longer arbitrarily constrained to occur on the same iteration interval.; 2. Both progress printing and adaptive time-stepping can use any `schedule` (rather than only `IterationInterval`).; 3. The simulation time-step is always `simulation.Δt`. No more shenanigans like `simulation.Δt.Δt`. Eventually, we should also eliminate the ""diagnostics"" list so that we have only two lists of callback-like objects: `simulation.callbacks` and `simulation.output_writers`. I think this resolves an issue or two but I need to find them. Also, I've so far only updated the examples. There are probably tests and validation cases that need to be updated for the new API as well. This PR is an important step toward generalizing `Oceananigans.Simulation` so that it can be used by [`ClimaAtmos.jl`](https://github.com/CliMA/ClimaAtmos.jl). cc @bischtob @akshaysridhar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971
https://github.com/CliMA/Oceananigans.jl/pull/1971:907,Energy Efficiency,adapt,adaptive,907,"This PR overhauls the API for `Simulation`, `TimeStepWizard`, and printing of progress. It also simplifies the implementation of `run!`. After this PR, `Simulation` no longer accepts the keyword arguments `iteration_interval` or `progress`. Instead, progress printing is achieved with callbacks, eg:. ```julia; progress(sim) = @info ""Iteration: $(iteration(sim)), time: $(time(sim))""; simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)); ```. It also refactors the `TimeStepWizard` so that it can be used as a callback, eg. ```julia; wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=2minutes); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)); ```. This is a better design for a few reasons:. 1. Adaptive time-stepping and progress printing are not longer arbitrarily constrained to occur on the same iteration interval.; 2. Both progress printing and adaptive time-stepping can use any `schedule` (rather than only `IterationInterval`).; 3. The simulation time-step is always `simulation.Δt`. No more shenanigans like `simulation.Δt.Δt`. Eventually, we should also eliminate the ""diagnostics"" list so that we have only two lists of callback-like objects: `simulation.callbacks` and `simulation.output_writers`. I think this resolves an issue or two but I need to find them. Also, I've so far only updated the examples. There are probably tests and validation cases that need to be updated for the new API as well. This PR is an important step toward generalizing `Oceananigans.Simulation` so that it can be used by [`ClimaAtmos.jl`](https://github.com/CliMA/ClimaAtmos.jl). cc @bischtob @akshaysridhar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971
https://github.com/CliMA/Oceananigans.jl/pull/1971:943,Energy Efficiency,schedul,schedule,943,"This PR overhauls the API for `Simulation`, `TimeStepWizard`, and printing of progress. It also simplifies the implementation of `run!`. After this PR, `Simulation` no longer accepts the keyword arguments `iteration_interval` or `progress`. Instead, progress printing is achieved with callbacks, eg:. ```julia; progress(sim) = @info ""Iteration: $(iteration(sim)), time: $(time(sim))""; simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)); ```. It also refactors the `TimeStepWizard` so that it can be used as a callback, eg. ```julia; wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=2minutes); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)); ```. This is a better design for a few reasons:. 1. Adaptive time-stepping and progress printing are not longer arbitrarily constrained to occur on the same iteration interval.; 2. Both progress printing and adaptive time-stepping can use any `schedule` (rather than only `IterationInterval`).; 3. The simulation time-step is always `simulation.Δt`. No more shenanigans like `simulation.Δt.Δt`. Eventually, we should also eliminate the ""diagnostics"" list so that we have only two lists of callback-like objects: `simulation.callbacks` and `simulation.output_writers`. I think this resolves an issue or two but I need to find them. Also, I've so far only updated the examples. There are probably tests and validation cases that need to be updated for the new API as well. This PR is an important step toward generalizing `Oceananigans.Simulation` so that it can be used by [`ClimaAtmos.jl`](https://github.com/CliMA/ClimaAtmos.jl). cc @bischtob @akshaysridhar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971
https://github.com/CliMA/Oceananigans.jl/pull/1971:476,Modifiability,refactor,refactors,476,"This PR overhauls the API for `Simulation`, `TimeStepWizard`, and printing of progress. It also simplifies the implementation of `run!`. After this PR, `Simulation` no longer accepts the keyword arguments `iteration_interval` or `progress`. Instead, progress printing is achieved with callbacks, eg:. ```julia; progress(sim) = @info ""Iteration: $(iteration(sim)), time: $(time(sim))""; simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)); ```. It also refactors the `TimeStepWizard` so that it can be used as a callback, eg. ```julia; wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=2minutes); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)); ```. This is a better design for a few reasons:. 1. Adaptive time-stepping and progress printing are not longer arbitrarily constrained to occur on the same iteration interval.; 2. Both progress printing and adaptive time-stepping can use any `schedule` (rather than only `IterationInterval`).; 3. The simulation time-step is always `simulation.Δt`. No more shenanigans like `simulation.Δt.Δt`. Eventually, we should also eliminate the ""diagnostics"" list so that we have only two lists of callback-like objects: `simulation.callbacks` and `simulation.output_writers`. I think this resolves an issue or two but I need to find them. Also, I've so far only updated the examples. There are probably tests and validation cases that need to be updated for the new API as well. This PR is an important step toward generalizing `Oceananigans.Simulation` so that it can be used by [`ClimaAtmos.jl`](https://github.com/CliMA/ClimaAtmos.jl). cc @bischtob @akshaysridhar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971
https://github.com/CliMA/Oceananigans.jl/pull/1971:751,Modifiability,Adapt,Adaptive,751,"This PR overhauls the API for `Simulation`, `TimeStepWizard`, and printing of progress. It also simplifies the implementation of `run!`. After this PR, `Simulation` no longer accepts the keyword arguments `iteration_interval` or `progress`. Instead, progress printing is achieved with callbacks, eg:. ```julia; progress(sim) = @info ""Iteration: $(iteration(sim)), time: $(time(sim))""; simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)); ```. It also refactors the `TimeStepWizard` so that it can be used as a callback, eg. ```julia; wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=2minutes); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)); ```. This is a better design for a few reasons:. 1. Adaptive time-stepping and progress printing are not longer arbitrarily constrained to occur on the same iteration interval.; 2. Both progress printing and adaptive time-stepping can use any `schedule` (rather than only `IterationInterval`).; 3. The simulation time-step is always `simulation.Δt`. No more shenanigans like `simulation.Δt.Δt`. Eventually, we should also eliminate the ""diagnostics"" list so that we have only two lists of callback-like objects: `simulation.callbacks` and `simulation.output_writers`. I think this resolves an issue or two but I need to find them. Also, I've so far only updated the examples. There are probably tests and validation cases that need to be updated for the new API as well. This PR is an important step toward generalizing `Oceananigans.Simulation` so that it can be used by [`ClimaAtmos.jl`](https://github.com/CliMA/ClimaAtmos.jl). cc @bischtob @akshaysridhar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971
https://github.com/CliMA/Oceananigans.jl/pull/1971:907,Modifiability,adapt,adaptive,907,"This PR overhauls the API for `Simulation`, `TimeStepWizard`, and printing of progress. It also simplifies the implementation of `run!`. After this PR, `Simulation` no longer accepts the keyword arguments `iteration_interval` or `progress`. Instead, progress printing is achieved with callbacks, eg:. ```julia; progress(sim) = @info ""Iteration: $(iteration(sim)), time: $(time(sim))""; simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)); ```. It also refactors the `TimeStepWizard` so that it can be used as a callback, eg. ```julia; wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=2minutes); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)); ```. This is a better design for a few reasons:. 1. Adaptive time-stepping and progress printing are not longer arbitrarily constrained to occur on the same iteration interval.; 2. Both progress printing and adaptive time-stepping can use any `schedule` (rather than only `IterationInterval`).; 3. The simulation time-step is always `simulation.Δt`. No more shenanigans like `simulation.Δt.Δt`. Eventually, we should also eliminate the ""diagnostics"" list so that we have only two lists of callback-like objects: `simulation.callbacks` and `simulation.output_writers`. I think this resolves an issue or two but I need to find them. Also, I've so far only updated the examples. There are probably tests and validation cases that need to be updated for the new API as well. This PR is an important step toward generalizing `Oceananigans.Simulation` so that it can be used by [`ClimaAtmos.jl`](https://github.com/CliMA/ClimaAtmos.jl). cc @bischtob @akshaysridhar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971
https://github.com/CliMA/Oceananigans.jl/pull/1971:1404,Security,validat,validation,1404,"This PR overhauls the API for `Simulation`, `TimeStepWizard`, and printing of progress. It also simplifies the implementation of `run!`. After this PR, `Simulation` no longer accepts the keyword arguments `iteration_interval` or `progress`. Instead, progress printing is achieved with callbacks, eg:. ```julia; progress(sim) = @info ""Iteration: $(iteration(sim)), time: $(time(sim))""; simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)); ```. It also refactors the `TimeStepWizard` so that it can be used as a callback, eg. ```julia; wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=2minutes); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)); ```. This is a better design for a few reasons:. 1. Adaptive time-stepping and progress printing are not longer arbitrarily constrained to occur on the same iteration interval.; 2. Both progress printing and adaptive time-stepping can use any `schedule` (rather than only `IterationInterval`).; 3. The simulation time-step is always `simulation.Δt`. No more shenanigans like `simulation.Δt.Δt`. Eventually, we should also eliminate the ""diagnostics"" list so that we have only two lists of callback-like objects: `simulation.callbacks` and `simulation.output_writers`. I think this resolves an issue or two but I need to find them. Also, I've so far only updated the examples. There are probably tests and validation cases that need to be updated for the new API as well. This PR is an important step toward generalizing `Oceananigans.Simulation` so that it can be used by [`ClimaAtmos.jl`](https://github.com/CliMA/ClimaAtmos.jl). cc @bischtob @akshaysridhar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971
https://github.com/CliMA/Oceananigans.jl/pull/1971:1394,Testability,test,tests,1394,"This PR overhauls the API for `Simulation`, `TimeStepWizard`, and printing of progress. It also simplifies the implementation of `run!`. After this PR, `Simulation` no longer accepts the keyword arguments `iteration_interval` or `progress`. Instead, progress printing is achieved with callbacks, eg:. ```julia; progress(sim) = @info ""Iteration: $(iteration(sim)), time: $(time(sim))""; simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)); ```. It also refactors the `TimeStepWizard` so that it can be used as a callback, eg. ```julia; wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=2minutes); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)); ```. This is a better design for a few reasons:. 1. Adaptive time-stepping and progress printing are not longer arbitrarily constrained to occur on the same iteration interval.; 2. Both progress printing and adaptive time-stepping can use any `schedule` (rather than only `IterationInterval`).; 3. The simulation time-step is always `simulation.Δt`. No more shenanigans like `simulation.Δt.Δt`. Eventually, we should also eliminate the ""diagnostics"" list so that we have only two lists of callback-like objects: `simulation.callbacks` and `simulation.output_writers`. I think this resolves an issue or two but I need to find them. Also, I've so far only updated the examples. There are probably tests and validation cases that need to be updated for the new API as well. This PR is an important step toward generalizing `Oceananigans.Simulation` so that it can be used by [`ClimaAtmos.jl`](https://github.com/CliMA/ClimaAtmos.jl). cc @bischtob @akshaysridhar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971
https://github.com/CliMA/Oceananigans.jl/pull/1971:96,Usability,simpl,simplifies,96,"This PR overhauls the API for `Simulation`, `TimeStepWizard`, and printing of progress. It also simplifies the implementation of `run!`. After this PR, `Simulation` no longer accepts the keyword arguments `iteration_interval` or `progress`. Instead, progress printing is achieved with callbacks, eg:. ```julia; progress(sim) = @info ""Iteration: $(iteration(sim)), time: $(time(sim))""; simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)); ```. It also refactors the `TimeStepWizard` so that it can be used as a callback, eg. ```julia; wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=2minutes); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)); ```. This is a better design for a few reasons:. 1. Adaptive time-stepping and progress printing are not longer arbitrarily constrained to occur on the same iteration interval.; 2. Both progress printing and adaptive time-stepping can use any `schedule` (rather than only `IterationInterval`).; 3. The simulation time-step is always `simulation.Δt`. No more shenanigans like `simulation.Δt.Δt`. Eventually, we should also eliminate the ""diagnostics"" list so that we have only two lists of callback-like objects: `simulation.callbacks` and `simulation.output_writers`. I think this resolves an issue or two but I need to find them. Also, I've so far only updated the examples. There are probably tests and validation cases that need to be updated for the new API as well. This PR is an important step toward generalizing `Oceananigans.Simulation` so that it can be used by [`ClimaAtmos.jl`](https://github.com/CliMA/ClimaAtmos.jl). cc @bischtob @akshaysridhar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971
https://github.com/CliMA/Oceananigans.jl/issues/1972:276,Usability,simpl,simplifying,276,"To implement the ""Gent-McWilliams"" turbulence closure (and variants of this closure) we need a turbulence closure that accepts skew and symmetric diffusivity components (?), and rotates the diffusive / viscous fluxes into the isopycnal coordinate frame. I think this requires simplifying the already-implemented `TwoDimensionalLeith` closure, which defines functions like. ```julia; # Components of the Redi rotation tensor. @inline function Redi_tensor_xz_fcc(i, j, k, grid::AbstractGrid{FT}, buoyancy, C) where FT; bx = ∂x_b(i, j, k, grid, buoyancy, C); bz = ℑxzᶠᵃᶜ(i, j, k, grid, ∂z_b, buoyancy, C); return ifelse(bx == 0 && bz == 0, zero(FT), - bx / bz); end. @inline function Redi_tensor_xz_ccf(i, j, k, grid::AbstractGrid{FT}, buoyancy, C) where FT; bx = ℑxzᶜᵃᶠ(i, j, k, grid, ∂x_b, buoyancy, C); bz = ∂z_b(i, j, k, grid, buoyancy, C); return ifelse(bx == 0 && bz == 0, zero(FT), - bx / bz); end. @inline function Redi_tensor_yz_cfc(i, j, k, grid::AbstractGrid{FT}, buoyancy, C) where FT; by = ∂y_b(i, j, k, grid, buoyancy, C); bz = ℑyzᵃᶠᶜ(i, j, k, grid, ∂z_b, buoyancy, C); return ifelse(by == 0 && bz == 0, zero(FT), - by / bz); end. @inline function Redi_tensor_yz_ccf(i, j, k, grid::AbstractGrid{FT}, buoyancy, C) where FT; by = ℑyzᵃᶜᶠ(i, j, k, grid, ∂y_b, buoyancy, C); bz = ∂z_b(i, j, k, grid, buoyancy, C); return ifelse(by == 0 && bz == 0, zero(FT), - by / bz); end. @inline function Redi_tensor_zz_ccf(i, j, k, grid::AbstractGrid{FT}, buoyancy, C) where FT; bx = ℑxzᶜᵃᶠ(i, j, k, grid, ∂x_b, buoyancy, C); by = ℑyzᵃᶜᶠ(i, j, k, grid, ∂y_b, buoyancy, C); bz = ∂z_b(i, j, k, grid, buoyancy, C); return ifelse(by == 0 && bx == 0 && bz == 0, zero(FT), (bx^2 + by^2) / bz^2); end; ```. The users most interested in this feature in the immediate future are @sandreza and @xiaozhour . @sandreza and @xiaozhour , can you provide a mathematical description of the closure you would like implemented? Are the Redi tensor functions defined above sufficient? I think they make a small-angle approxima",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1972
https://github.com/CliMA/Oceananigans.jl/issues/1974:87,Security,validat,validation,87,https://github.com/CliMA/Oceananigans.jl/blob/bb35dcbefad63c038cd311c5eed43ac5326bb824/validation/mesoscale_turbulence/eddying_channel.jl#L96-L97,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1974
https://github.com/CliMA/Oceananigans.jl/issues/1981:323,Availability,error,error,323,"Dear Oceananigans team,. I am new to Julia and Oceananigans.; I installed Julia version 1.6.2 (2021-07-14) on Ubuntu 20.04 LTS, then Oceananigans v0.62.1 as instructed. I am interested in ""stratified plane Couette flow"" .; When I run the case using ""julia run_stratified_couette_flow_simulations.jl"", I am having following error;. **""; ERROR: LoadError: UndefVarError: Value not defined; Stacktrace:; [1] simulate_stratified_couette_flow(; Nxy::Int64, Nz::Int64, arch::GPU, h::Int64, U_wall::Int64, Re::Int64, Pr::Float64, Ri::Int64, Ni::Int64, end_time::Int64); @ Main ~/Desktop/stratified_couette_flow/stratified_couette_flow.jl:103; [2] top-level scope; @ ~/Desktop/stratified_couette_flow/run_stratified_couette_flow_simulations.jl:3; in expression starting at /home/ilyas/Desktop/stratified_couette_flow/run_stratified_couette_flow_simulations.jl:3; ""****. It complaints about undefined Boundary Condition Value (stratified_couette_flow.jl:103).; Can you help me to fix it?. Please forgive me if I missed something obvious or made a trivial mistake.; Thanks,. Ilyas",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1981
https://github.com/CliMA/Oceananigans.jl/issues/1981:336,Availability,ERROR,ERROR,336,"Dear Oceananigans team,. I am new to Julia and Oceananigans.; I installed Julia version 1.6.2 (2021-07-14) on Ubuntu 20.04 LTS, then Oceananigans v0.62.1 as instructed. I am interested in ""stratified plane Couette flow"" .; When I run the case using ""julia run_stratified_couette_flow_simulations.jl"", I am having following error;. **""; ERROR: LoadError: UndefVarError: Value not defined; Stacktrace:; [1] simulate_stratified_couette_flow(; Nxy::Int64, Nz::Int64, arch::GPU, h::Int64, U_wall::Int64, Re::Int64, Pr::Float64, Ri::Int64, Ni::Int64, end_time::Int64); @ Main ~/Desktop/stratified_couette_flow/stratified_couette_flow.jl:103; [2] top-level scope; @ ~/Desktop/stratified_couette_flow/run_stratified_couette_flow_simulations.jl:3; in expression starting at /home/ilyas/Desktop/stratified_couette_flow/run_stratified_couette_flow_simulations.jl:3; ""****. It complaints about undefined Boundary Condition Value (stratified_couette_flow.jl:103).; Can you help me to fix it?. Please forgive me if I missed something obvious or made a trivial mistake.; Thanks,. Ilyas",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1981
https://github.com/CliMA/Oceananigans.jl/issues/1981:64,Deployability,install,installed,64,"Dear Oceananigans team,. I am new to Julia and Oceananigans.; I installed Julia version 1.6.2 (2021-07-14) on Ubuntu 20.04 LTS, then Oceananigans v0.62.1 as instructed. I am interested in ""stratified plane Couette flow"" .; When I run the case using ""julia run_stratified_couette_flow_simulations.jl"", I am having following error;. **""; ERROR: LoadError: UndefVarError: Value not defined; Stacktrace:; [1] simulate_stratified_couette_flow(; Nxy::Int64, Nz::Int64, arch::GPU, h::Int64, U_wall::Int64, Re::Int64, Pr::Float64, Ri::Int64, Ni::Int64, end_time::Int64); @ Main ~/Desktop/stratified_couette_flow/stratified_couette_flow.jl:103; [2] top-level scope; @ ~/Desktop/stratified_couette_flow/run_stratified_couette_flow_simulations.jl:3; in expression starting at /home/ilyas/Desktop/stratified_couette_flow/run_stratified_couette_flow_simulations.jl:3; ""****. It complaints about undefined Boundary Condition Value (stratified_couette_flow.jl:103).; Can you help me to fix it?. Please forgive me if I missed something obvious or made a trivial mistake.; Thanks,. Ilyas",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1981
https://github.com/CliMA/Oceananigans.jl/issues/1981:343,Performance,Load,LoadError,343,"Dear Oceananigans team,. I am new to Julia and Oceananigans.; I installed Julia version 1.6.2 (2021-07-14) on Ubuntu 20.04 LTS, then Oceananigans v0.62.1 as instructed. I am interested in ""stratified plane Couette flow"" .; When I run the case using ""julia run_stratified_couette_flow_simulations.jl"", I am having following error;. **""; ERROR: LoadError: UndefVarError: Value not defined; Stacktrace:; [1] simulate_stratified_couette_flow(; Nxy::Int64, Nz::Int64, arch::GPU, h::Int64, U_wall::Int64, Re::Int64, Pr::Float64, Ri::Int64, Ni::Int64, end_time::Int64); @ Main ~/Desktop/stratified_couette_flow/stratified_couette_flow.jl:103; [2] top-level scope; @ ~/Desktop/stratified_couette_flow/run_stratified_couette_flow_simulations.jl:3; in expression starting at /home/ilyas/Desktop/stratified_couette_flow/run_stratified_couette_flow_simulations.jl:3; ""****. It complaints about undefined Boundary Condition Value (stratified_couette_flow.jl:103).; Can you help me to fix it?. Please forgive me if I missed something obvious or made a trivial mistake.; Thanks,. Ilyas",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1981
https://github.com/CliMA/Oceananigans.jl/pull/1985:86,Performance,race condition,race condition,86,Testing with validation/mesoscale/baroclinic_adjustment.jl seems to indicate that the race condition is eliminated from the changes to the fill_halo_region! function,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985
https://github.com/CliMA/Oceananigans.jl/pull/1985:13,Security,validat,validation,13,Testing with validation/mesoscale/baroclinic_adjustment.jl seems to indicate that the race condition is eliminated from the changes to the fill_halo_region! function,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985
https://github.com/CliMA/Oceananigans.jl/pull/1985:0,Testability,Test,Testing,0,Testing with validation/mesoscale/baroclinic_adjustment.jl seems to indicate that the race condition is eliminated from the changes to the fill_halo_region! function,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985
https://github.com/CliMA/Oceananigans.jl/pull/1987:41,Testability,test,tests,41,This PR adds a vertical regrid feature + tests. cc @adelinehillier,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1987
https://github.com/CliMA/Oceananigans.jl/issues/1990:799,Performance,perform,performance,799,"I was going quickly through some tests for a PR and found more than one instance of something like this:. https://github.com/CliMA/Oceananigans.jl/blob/93c497a5f78a9a422d8f597dbd5406ccc0c09ceb/test/test_output_writers.jl#L181-L213. Where, unless I'm missing something we run a couple of unnecessary loops. In this case I believe we're creating 4 models, when we could be creating only two. Since the tests are taking a considerable amount of time to run (I think something around 2 hours on the CI servers) I think it'd be a good idea for us to tackle these as time permits. Not necessarily all at once, which would take a huge amount of effort, but maybe one PR here and there when we catch these things. (Although I'm also not opposed to re-organizing all the tests if it'll significantly improve performance.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990
https://github.com/CliMA/Oceananigans.jl/issues/1990:33,Testability,test,tests,33,"I was going quickly through some tests for a PR and found more than one instance of something like this:. https://github.com/CliMA/Oceananigans.jl/blob/93c497a5f78a9a422d8f597dbd5406ccc0c09ceb/test/test_output_writers.jl#L181-L213. Where, unless I'm missing something we run a couple of unnecessary loops. In this case I believe we're creating 4 models, when we could be creating only two. Since the tests are taking a considerable amount of time to run (I think something around 2 hours on the CI servers) I think it'd be a good idea for us to tackle these as time permits. Not necessarily all at once, which would take a huge amount of effort, but maybe one PR here and there when we catch these things. (Although I'm also not opposed to re-organizing all the tests if it'll significantly improve performance.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990
https://github.com/CliMA/Oceananigans.jl/issues/1990:193,Testability,test,test,193,"I was going quickly through some tests for a PR and found more than one instance of something like this:. https://github.com/CliMA/Oceananigans.jl/blob/93c497a5f78a9a422d8f597dbd5406ccc0c09ceb/test/test_output_writers.jl#L181-L213. Where, unless I'm missing something we run a couple of unnecessary loops. In this case I believe we're creating 4 models, when we could be creating only two. Since the tests are taking a considerable amount of time to run (I think something around 2 hours on the CI servers) I think it'd be a good idea for us to tackle these as time permits. Not necessarily all at once, which would take a huge amount of effort, but maybe one PR here and there when we catch these things. (Although I'm also not opposed to re-organizing all the tests if it'll significantly improve performance.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990
https://github.com/CliMA/Oceananigans.jl/issues/1990:400,Testability,test,tests,400,"I was going quickly through some tests for a PR and found more than one instance of something like this:. https://github.com/CliMA/Oceananigans.jl/blob/93c497a5f78a9a422d8f597dbd5406ccc0c09ceb/test/test_output_writers.jl#L181-L213. Where, unless I'm missing something we run a couple of unnecessary loops. In this case I believe we're creating 4 models, when we could be creating only two. Since the tests are taking a considerable amount of time to run (I think something around 2 hours on the CI servers) I think it'd be a good idea for us to tackle these as time permits. Not necessarily all at once, which would take a huge amount of effort, but maybe one PR here and there when we catch these things. (Although I'm also not opposed to re-organizing all the tests if it'll significantly improve performance.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990
https://github.com/CliMA/Oceananigans.jl/issues/1990:762,Testability,test,tests,762,"I was going quickly through some tests for a PR and found more than one instance of something like this:. https://github.com/CliMA/Oceananigans.jl/blob/93c497a5f78a9a422d8f597dbd5406ccc0c09ceb/test/test_output_writers.jl#L181-L213. Where, unless I'm missing something we run a couple of unnecessary loops. In this case I believe we're creating 4 models, when we could be creating only two. Since the tests are taking a considerable amount of time to run (I think something around 2 hours on the CI servers) I think it'd be a good idea for us to tackle these as time permits. Not necessarily all at once, which would take a huge amount of effort, but maybe one PR here and there when we catch these things. (Although I'm also not opposed to re-organizing all the tests if it'll significantly improve performance.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990
https://github.com/CliMA/Oceananigans.jl/issues/1991:168,Safety,avoid,avoid,168,"Some suggestions on regriding:. - Add brief docstrings with a quick example; - Change the names from `u` and `v` in the functions to something more general in order to avoid confusion. Maybe `a`, `b` or some greek letters.; - ~Export `regrid!`?~. cc: @glwagner, @tomchor",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1991
https://github.com/CliMA/Oceananigans.jl/pull/1994:207,Modifiability,extend,extend,207,"This PR adds an `IsopycnalSkewSymmetricDiffusivity` turbulence closure. This is otherwise knows as Gent-McWilliams parametrization but here we chose the more descriptive name. Also plans include to possibly extend this closure for turbulent viscosity. joint work with @glwagner . Resolves #1492, resolves #1972. This PR further enhances `FieldTimeSeries` to allow building `FieldTimeSeries` for data without halos.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994
https://github.com/CliMA/Oceananigans.jl/pull/1994:328,Modifiability,enhance,enhances,328,"This PR adds an `IsopycnalSkewSymmetricDiffusivity` turbulence closure. This is otherwise knows as Gent-McWilliams parametrization but here we chose the more descriptive name. Also plans include to possibly extend this closure for turbulent viscosity. joint work with @glwagner . Resolves #1492, resolves #1972. This PR further enhances `FieldTimeSeries` to allow building `FieldTimeSeries` for data without halos.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994
https://github.com/CliMA/Oceananigans.jl/issues/1995:850,Availability,error,error,850,"Underlying cause seems to be https://github.com/JuliaGPU/CUDA.jl/issues/1169 so we should probably not update CUDA.jl until it's fixed. We could also pin the current version of CUDA.jl (a change which should propagate to users I think?). cc @Yixiao-Zhang. ---. **Minimal working example**. ```julia; using Oceananigans. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Bounded), size=(85, 1320, 100), extent=(1, 1, 1)); model = NonhydrostaticModel(architecture=GPU(); grid); simulation = Simulation(model, Δt=1, stop_time=10, progress = sim -> @info ""iteration $(sim.model.clock.iteration)""). V = AveragedField(model.velocities.v, dims=1); simulation.output_writers[:zonal_averages] =; NetCDFOutputWriter(model, (; V), filepath=""zonal_averages.nc"", schedule=TimeInterval(1), verbose=true). run!(simulation); ```. produces this GPU compiler error. ```julia; ERROR: LoadError: InvalidIRError: compiling kernel broadcast_kernel(CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to julia.gpu.state_getter); Stacktrace:; [1] kernel_state_pointer; @ ~/.julia/packages/GPUCompiler/j0ybe/src/irgen.jl:695; [2] kernel_state; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:31; [3] exception_flag; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:33; [4] signal_exception; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:36; [5] multiple call sites; @ unknown:0; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{G",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995
https://github.com/CliMA/Oceananigans.jl/issues/1995:867,Availability,ERROR,ERROR,867,"Underlying cause seems to be https://github.com/JuliaGPU/CUDA.jl/issues/1169 so we should probably not update CUDA.jl until it's fixed. We could also pin the current version of CUDA.jl (a change which should propagate to users I think?). cc @Yixiao-Zhang. ---. **Minimal working example**. ```julia; using Oceananigans. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Bounded), size=(85, 1320, 100), extent=(1, 1, 1)); model = NonhydrostaticModel(architecture=GPU(); grid); simulation = Simulation(model, Δt=1, stop_time=10, progress = sim -> @info ""iteration $(sim.model.clock.iteration)""). V = AveragedField(model.velocities.v, dims=1); simulation.output_writers[:zonal_averages] =; NetCDFOutputWriter(model, (; V), filepath=""zonal_averages.nc"", schedule=TimeInterval(1), verbose=true). run!(simulation); ```. produces this GPU compiler error. ```julia; ERROR: LoadError: InvalidIRError: compiling kernel broadcast_kernel(CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to julia.gpu.state_getter); Stacktrace:; [1] kernel_state_pointer; @ ~/.julia/packages/GPUCompiler/j0ybe/src/irgen.jl:695; [2] kernel_state; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:31; [3] exception_flag; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:33; [4] signal_exception; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:36; [5] multiple call sites; @ unknown:0; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{G",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995
https://github.com/CliMA/Oceananigans.jl/issues/1995:103,Deployability,update,update,103,"Underlying cause seems to be https://github.com/JuliaGPU/CUDA.jl/issues/1169 so we should probably not update CUDA.jl until it's fixed. We could also pin the current version of CUDA.jl (a change which should propagate to users I think?). cc @Yixiao-Zhang. ---. **Minimal working example**. ```julia; using Oceananigans. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Bounded), size=(85, 1320, 100), extent=(1, 1, 1)); model = NonhydrostaticModel(architecture=GPU(); grid); simulation = Simulation(model, Δt=1, stop_time=10, progress = sim -> @info ""iteration $(sim.model.clock.iteration)""). V = AveragedField(model.velocities.v, dims=1); simulation.output_writers[:zonal_averages] =; NetCDFOutputWriter(model, (; V), filepath=""zonal_averages.nc"", schedule=TimeInterval(1), verbose=true). run!(simulation); ```. produces this GPU compiler error. ```julia; ERROR: LoadError: InvalidIRError: compiling kernel broadcast_kernel(CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to julia.gpu.state_getter); Stacktrace:; [1] kernel_state_pointer; @ ~/.julia/packages/GPUCompiler/j0ybe/src/irgen.jl:695; [2] kernel_state; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:31; [3] exception_flag; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:33; [4] signal_exception; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:36; [5] multiple call sites; @ unknown:0; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{G",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995
https://github.com/CliMA/Oceananigans.jl/issues/1995:759,Energy Efficiency,schedul,schedule,759,"Underlying cause seems to be https://github.com/JuliaGPU/CUDA.jl/issues/1169 so we should probably not update CUDA.jl until it's fixed. We could also pin the current version of CUDA.jl (a change which should propagate to users I think?). cc @Yixiao-Zhang. ---. **Minimal working example**. ```julia; using Oceananigans. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Bounded), size=(85, 1320, 100), extent=(1, 1, 1)); model = NonhydrostaticModel(architecture=GPU(); grid); simulation = Simulation(model, Δt=1, stop_time=10, progress = sim -> @info ""iteration $(sim.model.clock.iteration)""). V = AveragedField(model.velocities.v, dims=1); simulation.output_writers[:zonal_averages] =; NetCDFOutputWriter(model, (; V), filepath=""zonal_averages.nc"", schedule=TimeInterval(1), verbose=true). run!(simulation); ```. produces this GPU compiler error. ```julia; ERROR: LoadError: InvalidIRError: compiling kernel broadcast_kernel(CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to julia.gpu.state_getter); Stacktrace:; [1] kernel_state_pointer; @ ~/.julia/packages/GPUCompiler/j0ybe/src/irgen.jl:695; [2] kernel_state; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:31; [3] exception_flag; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:33; [4] signal_exception; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:36; [5] multiple call sites; @ unknown:0; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{G",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995
https://github.com/CliMA/Oceananigans.jl/issues/1995:874,Performance,Load,LoadError,874,"Underlying cause seems to be https://github.com/JuliaGPU/CUDA.jl/issues/1169 so we should probably not update CUDA.jl until it's fixed. We could also pin the current version of CUDA.jl (a change which should propagate to users I think?). cc @Yixiao-Zhang. ---. **Minimal working example**. ```julia; using Oceananigans. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Bounded), size=(85, 1320, 100), extent=(1, 1, 1)); model = NonhydrostaticModel(architecture=GPU(); grid); simulation = Simulation(model, Δt=1, stop_time=10, progress = sim -> @info ""iteration $(sim.model.clock.iteration)""). V = AveragedField(model.velocities.v, dims=1); simulation.output_writers[:zonal_averages] =; NetCDFOutputWriter(model, (; V), filepath=""zonal_averages.nc"", schedule=TimeInterval(1), verbose=true). run!(simulation); ```. produces this GPU compiler error. ```julia; ERROR: LoadError: InvalidIRError: compiling kernel broadcast_kernel(CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64) resulted in invalid LLVM IR; Reason: unsupported call to an unknown function (call to julia.gpu.state_getter); Stacktrace:; [1] kernel_state_pointer; @ ~/.julia/packages/GPUCompiler/j0ybe/src/irgen.jl:695; [2] kernel_state; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:31; [3] exception_flag; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:33; [4] signal_exception; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:36; [5] multiple call sites; @ unknown:0; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{G",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995
https://github.com/CliMA/Oceananigans.jl/issues/1995:3364,Performance,cache,cache,3364,"nt64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64}}}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/validation.jl:111; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:319 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/ZQ0rt/src/TimerOutput.jl:236 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:317 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/utils.jl:62; [6] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:317; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/cache.jl:89; [8] cufunction(f::GPUArrays.var""#broadcast_kernel#16"", tt::Type{Tuple{CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64}}; name::Nothing, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ CUDA ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:288; [9] cufunction; @ ~/.julia/pa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995
https://github.com/CliMA/Oceananigans.jl/issues/1995:3556,Performance,cache,cache,3556,".OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64}}}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/validation.jl:111; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:319 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/ZQ0rt/src/TimerOutput.jl:236 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:317 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/utils.jl:62; [6] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:317; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/cache.jl:89; [8] cufunction(f::GPUArrays.var""#broadcast_kernel#16"", tt::Type{Tuple{CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64}}; name::Nothing, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ CUDA ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:288; [9] cufunction; @ ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:282 [inlined]; [10] macro expansion; @ ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:102 [inlined]; [11] #launch_heuri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995
https://github.com/CliMA/Oceananigans.jl/issues/1995:2736,Security,validat,validation,2736,"X/src/device/runtime.jl:31; [3] exception_flag; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:33; [4] signal_exception; @ ~/.julia/packages/CUDA/dNx3X/src/device/runtime.jl:36; [5] multiple call sites; @ unknown:0; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{GPUArrays.var""#broadcast_kernel#16"", Tuple{CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64}}}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/validation.jl:111; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:319 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/ZQ0rt/src/TimerOutput.jl:236 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:317 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/utils.jl:62; [6] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:317; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/cache.jl:89; [8] cufunction(f::GPUArrays.var""#broadcast_kernel#16"", tt::Type{Tuple{CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995
https://github.com/CliMA/Oceananigans.jl/issues/1995:3098,Security,validat,validate,3098,"ast_kernel#16"", Tuple{CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64}}}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/validation.jl:111; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:319 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/ZQ0rt/src/TimerOutput.jl:236 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:317 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/utils.jl:62; [6] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:317; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/cache.jl:89; [8] cufunction(f::GPUArrays.var""#broadcast_kernel#16"", tt::Type{Tuple{CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995
https://github.com/CliMA/Oceananigans.jl/issues/1996:286,Deployability,install,installs,286,"It appears that CUDA 3.4 has a [bug](https://github.com/JuliaGPU/CUDA.jl/issues/1169), which apparently caused some trouble in https://github.com/CliMA/Oceananigans.jl/issues/1995 and https://github.com/CliMA/Oceananigans.jl/pull/1988. At the moment, however, adding Oceananigans still installs the latest CUDA version since CUDA's `compat` entry just specifies version 3:. https://github.com/CliMA/Oceananigans.jl/blob/73be08d708131a66402eb8fc0086c47ef80a2d0e/Project.toml#L36. It seems like the bug was merged upstream but they still haven't tagged a new release. Should we change the compat entry to protect users in the meantime? I'm not sure if the best way is to cap the version at 3.3 or if it's possible to exclude version 3.4.2 specifically, but I feel like it's best to act on this, no?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996
https://github.com/CliMA/Oceananigans.jl/issues/1996:557,Deployability,release,release,557,"It appears that CUDA 3.4 has a [bug](https://github.com/JuliaGPU/CUDA.jl/issues/1169), which apparently caused some trouble in https://github.com/CliMA/Oceananigans.jl/issues/1995 and https://github.com/CliMA/Oceananigans.jl/pull/1988. At the moment, however, adding Oceananigans still installs the latest CUDA version since CUDA's `compat` entry just specifies version 3:. https://github.com/CliMA/Oceananigans.jl/blob/73be08d708131a66402eb8fc0086c47ef80a2d0e/Project.toml#L36. It seems like the bug was merged upstream but they still haven't tagged a new release. Should we change the compat entry to protect users in the meantime? I'm not sure if the best way is to cap the version at 3.3 or if it's possible to exclude version 3.4.2 specifically, but I feel like it's best to act on this, no?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996
https://github.com/CliMA/Oceananigans.jl/pull/1997:255,Deployability,release,release,255,"Closes #1995 and closes #1996. (I'm not sure when the bug was introduced, so I capped the version up to 3.3.6. Feel free to change if there's a newer version that's also safe.). Also we need to remember to remove this after the bug gets put into a tagged release. (Can we exclude only version 3.4.2 using compat?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997
https://github.com/CliMA/Oceananigans.jl/pull/1997:170,Safety,safe,safe,170,"Closes #1995 and closes #1996. (I'm not sure when the bug was introduced, so I capped the version up to 3.3.6. Feel free to change if there's a newer version that's also safe.). Also we need to remember to remove this after the bug gets put into a tagged release. (Can we exclude only version 3.4.2 using compat?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997
https://github.com/CliMA/Oceananigans.jl/pull/1998:1112,Energy Efficiency,reduce,reduce,1112,"This PR adds an `architecture` property to the `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. Eventually, this PR will remove the `architecture` property from all models and fields. The new API will require `architecture` to be specified once when building the grid and never thereafter. This major change to the API is crucial for supporting a clean, simple API for grid metrics stored in arrays (all cases except the edge case of a fully regular grid). In the new API, both the architecture and floating point type are exclusive properties of `grid`. In addition this change will simplify the construction of models on distributed architectures and will eliminate the need for special model constructors for that case. Ultimately, we hope to go beyond this change to support just three grids:. 1. `RectilinearGrid`; 2. `LatitudeLongitudeGrid`; 3. `OrthogonalSphericalShellGrid`. In the first two cases, ""regularity"" is established if the grid metrics are numbers (rather than arrays or functions). This is another major change to the API (and a major internal refactor) that will hopefully reduce, simplify, and generalize grid constructors and applications. Closes #1825.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1998
https://github.com/CliMA/Oceananigans.jl/pull/1998:1082,Modifiability,refactor,refactor,1082,"This PR adds an `architecture` property to the `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. Eventually, this PR will remove the `architecture` property from all models and fields. The new API will require `architecture` to be specified once when building the grid and never thereafter. This major change to the API is crucial for supporting a clean, simple API for grid metrics stored in arrays (all cases except the edge case of a fully regular grid). In the new API, both the architecture and floating point type are exclusive properties of `grid`. In addition this change will simplify the construction of models on distributed architectures and will eliminate the need for special model constructors for that case. Ultimately, we hope to go beyond this change to support just three grids:. 1. `RectilinearGrid`; 2. `LatitudeLongitudeGrid`; 3. `OrthogonalSphericalShellGrid`. In the first two cases, ""regularity"" is established if the grid metrics are numbers (rather than arrays or functions). This is another major change to the API (and a major internal refactor) that will hopefully reduce, simplify, and generalize grid constructors and applications. Closes #1825.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1998
https://github.com/CliMA/Oceananigans.jl/pull/1998:372,Usability,simpl,simple,372,"This PR adds an `architecture` property to the `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. Eventually, this PR will remove the `architecture` property from all models and fields. The new API will require `architecture` to be specified once when building the grid and never thereafter. This major change to the API is crucial for supporting a clean, simple API for grid metrics stored in arrays (all cases except the edge case of a fully regular grid). In the new API, both the architecture and floating point type are exclusive properties of `grid`. In addition this change will simplify the construction of models on distributed architectures and will eliminate the need for special model constructors for that case. Ultimately, we hope to go beyond this change to support just three grids:. 1. `RectilinearGrid`; 2. `LatitudeLongitudeGrid`; 3. `OrthogonalSphericalShellGrid`. In the first two cases, ""regularity"" is established if the grid metrics are numbers (rather than arrays or functions). This is another major change to the API (and a major internal refactor) that will hopefully reduce, simplify, and generalize grid constructors and applications. Closes #1825.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1998
https://github.com/CliMA/Oceananigans.jl/pull/1998:602,Usability,simpl,simplify,602,"This PR adds an `architecture` property to the `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. Eventually, this PR will remove the `architecture` property from all models and fields. The new API will require `architecture` to be specified once when building the grid and never thereafter. This major change to the API is crucial for supporting a clean, simple API for grid metrics stored in arrays (all cases except the edge case of a fully regular grid). In the new API, both the architecture and floating point type are exclusive properties of `grid`. In addition this change will simplify the construction of models on distributed architectures and will eliminate the need for special model constructors for that case. Ultimately, we hope to go beyond this change to support just three grids:. 1. `RectilinearGrid`; 2. `LatitudeLongitudeGrid`; 3. `OrthogonalSphericalShellGrid`. In the first two cases, ""regularity"" is established if the grid metrics are numbers (rather than arrays or functions). This is another major change to the API (and a major internal refactor) that will hopefully reduce, simplify, and generalize grid constructors and applications. Closes #1825.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1998
https://github.com/CliMA/Oceananigans.jl/pull/1998:1120,Usability,simpl,simplify,1120,"This PR adds an `architecture` property to the `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. Eventually, this PR will remove the `architecture` property from all models and fields. The new API will require `architecture` to be specified once when building the grid and never thereafter. This major change to the API is crucial for supporting a clean, simple API for grid metrics stored in arrays (all cases except the edge case of a fully regular grid). In the new API, both the architecture and floating point type are exclusive properties of `grid`. In addition this change will simplify the construction of models on distributed architectures and will eliminate the need for special model constructors for that case. Ultimately, we hope to go beyond this change to support just three grids:. 1. `RectilinearGrid`; 2. `LatitudeLongitudeGrid`; 3. `OrthogonalSphericalShellGrid`. In the first two cases, ""regularity"" is established if the grid metrics are numbers (rather than arrays or functions). This is another major change to the API (and a major internal refactor) that will hopefully reduce, simplify, and generalize grid constructors and applications. Closes #1825.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1998
https://github.com/CliMA/Oceananigans.jl/pull/1999:180,Testability,test,tested,180,"This pull request changes the compat entry for the `CUDA` package from `3.0.0 - 3.3.6` to `3.0.0 - 3.3.6, 3`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1999
https://github.com/CliMA/Oceananigans.jl/pull/1999:286,Testability,test,tests,286,"This pull request changes the compat entry for the `CUDA` package from `3.0.0 - 3.3.6` to `3.0.0 - 3.3.6, 3`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1999
https://github.com/CliMA/Oceananigans.jl/pull/2002:180,Testability,test,tested,180,"This pull request changes the compat entry for the `CUDA` package from `3.0.0 - 3.3.6` to `3.0.0 - 3.3.6, 3`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2002
https://github.com/CliMA/Oceananigans.jl/pull/2002:286,Testability,test,tests,286,"This pull request changes the compat entry for the `CUDA` package from `3.0.0 - 3.3.6` to `3.0.0 - 3.3.6, 3`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2002
https://github.com/CliMA/Oceananigans.jl/issues/2012:27,Energy Efficiency,efficient,efficient,27,A longer-term solution for efficient global ocean simulations is to implement a split-explicit time-stepping scheme. The first step should involve a simple but stable method where efficiency/accuracy tests can be performed,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2012
https://github.com/CliMA/Oceananigans.jl/issues/2012:213,Performance,perform,performed,213,A longer-term solution for efficient global ocean simulations is to implement a split-explicit time-stepping scheme. The first step should involve a simple but stable method where efficiency/accuracy tests can be performed,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2012
https://github.com/CliMA/Oceananigans.jl/issues/2012:200,Testability,test,tests,200,A longer-term solution for efficient global ocean simulations is to implement a split-explicit time-stepping scheme. The first step should involve a simple but stable method where efficiency/accuracy tests can be performed,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2012
https://github.com/CliMA/Oceananigans.jl/issues/2012:149,Usability,simpl,simple,149,A longer-term solution for efficient global ocean simulations is to implement a split-explicit time-stepping scheme. The first step should involve a simple but stable method where efficiency/accuracy tests can be performed,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2012
https://github.com/CliMA/Oceananigans.jl/pull/2013:100,Performance,perform,performance,100,This is the first step towards #2012. The goal is to test the method with a flat-bottom and compare performance / stability with respect to the other free-surface implementations.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2013
https://github.com/CliMA/Oceananigans.jl/pull/2013:53,Testability,test,test,53,This is the first step towards #2012. The goal is to test the method with a flat-bottom and compare performance / stability with respect to the other free-surface implementations.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2013
https://github.com/CliMA/Oceananigans.jl/issues/2017:368,Usability,simpl,simpler,368,"This is a minor thing but I just noticed that the package's description is this:. ![Screenshot_20211016_073544](https://user-images.githubusercontent.com/13205162/137591563-50280525-ffbd-46cf-b838-b0983a7ed0d2.png). Maybe it's because I'm not a native English speaker, but ""oceanic library"" reads pretty weird to me. Maybe ""ocean-focused"" lilbrary? Or maybe something simpler but a bit more verbose: ""A library for fast, friendly, data-driven fluid dynamics on CPUs and GPUs with a focus on the ocean"".",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017
https://github.com/CliMA/Oceananigans.jl/issues/2018:102,Availability,error,error,102,"I'm finding that simulations with `VerticallyStretchedGrid`s don't get picked up and instead throw an error saying that the grid doesn't match. Here's a MWE:. ```julia; using Oceananigans. grid = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). model = NonhydrostaticModel(grid=grid). progress(sim) = @info ""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, Δt=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```. This fails with:. ```; [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 400.714 μs.; [ Info: Executing first time step...; [ Info: Iteration: 1, time: 1; [ Info: Iteration: 2, time: 2; [ Info: Iteration: 3, time: 3; [ Info: Iteration: 4, time: 4; [ Info: Iteration: 5, time: 5; [ Info: Iteration: 6, time: 6; [ Info: Iteration: 7, time: 7; [ Info: Iteration: 8, time: 8; [ Info: Iteration: 9, time: 9; [ Info: Iteration: 10, time: 10; [ Info: Simulation is stopping. Model time 10 seconds has hit or exceeded simulation stop time 10 seconds.; ERROR: LoadError: The grid associated with ./mwe_iteration10.jld2 and model.grid are not the same!; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.OutputWriters.var""#52#53""{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018
https://github.com/CliMA/Oceananigans.jl/issues/2018:563,Availability,Checkpoint,Checkpointer,563,"I'm finding that simulations with `VerticallyStretchedGrid`s don't get picked up and instead throw an error saying that the grid doesn't match. Here's a MWE:. ```julia; using Oceananigans. grid = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). model = NonhydrostaticModel(grid=grid). progress(sim) = @info ""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, Δt=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```. This fails with:. ```; [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 400.714 μs.; [ Info: Executing first time step...; [ Info: Iteration: 1, time: 1; [ Info: Iteration: 2, time: 2; [ Info: Iteration: 3, time: 3; [ Info: Iteration: 4, time: 4; [ Info: Iteration: 5, time: 5; [ Info: Iteration: 6, time: 6; [ Info: Iteration: 7, time: 7; [ Info: Iteration: 8, time: 8; [ Info: Iteration: 9, time: 9; [ Info: Iteration: 10, time: 10; [ Info: Simulation is stopping. Model time 10 seconds has hit or exceeded simulation stop time 10 seconds.; ERROR: LoadError: The grid associated with ./mwe_iteration10.jld2 and model.grid are not the same!; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.OutputWriters.var""#52#53""{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018
https://github.com/CliMA/Oceananigans.jl/issues/2018:1344,Availability,ERROR,ERROR,1344,"""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, Δt=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```. This fails with:. ```; [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 400.714 μs.; [ Info: Executing first time step...; [ Info: Iteration: 1, time: 1; [ Info: Iteration: 2, time: 2; [ Info: Iteration: 3, time: 3; [ Info: Iteration: 4, time: 4; [ Info: Iteration: 5, time: 5; [ Info: Iteration: 6, time: 6; [ Info: Iteration: 7, time: 7; [ Info: Iteration: 8, time: 8; [ Info: Iteration: 9, time: 9; [ Info: Iteration: 10, time: 10; [ Info: Simulation is stopping. Model time 10 seconds has hit or exceeded simulation stop time 10 seconds.; ERROR: LoadError: The grid associated with ./mwe_iteration10.jld2 and model.grid are not the same!; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.OutputWriters.var""#52#53""{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.Boundar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018
https://github.com/CliMA/Oceananigans.jl/issues/2018:1461,Availability,error,error,1461,"mulation = Simulation(model, Δt=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```. This fails with:. ```; [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 400.714 μs.; [ Info: Executing first time step...; [ Info: Iteration: 1, time: 1; [ Info: Iteration: 2, time: 2; [ Info: Iteration: 3, time: 3; [ Info: Iteration: 4, time: 4; [ Info: Iteration: 5, time: 5; [ Info: Iteration: 6, time: 6; [ Info: Iteration: 7, time: 7; [ Info: Iteration: 8, time: 8; [ Info: Iteration: 9, time: 9; [ Info: Iteration: 10, time: 10; [ Info: Simulation is stopping. Model time 10 seconds has hit or exceeded simulation stop time 10 seconds.; ERROR: LoadError: The grid associated with ./mwe_iteration10.jld2 and model.grid are not the same!; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.OutputWriters.var""#52#53""{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018
https://github.com/CliMA/Oceananigans.jl/issues/2018:1488,Availability,error,error,1488,"op_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```. This fails with:. ```; [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 400.714 μs.; [ Info: Executing first time step...; [ Info: Iteration: 1, time: 1; [ Info: Iteration: 2, time: 2; [ Info: Iteration: 3, time: 3; [ Info: Iteration: 4, time: 4; [ Info: Iteration: 5, time: 5; [ Info: Iteration: 6, time: 6; [ Info: Iteration: 7, time: 7; [ Info: Iteration: 8, time: 8; [ Info: Iteration: 9, time: 9; [ Info: Iteration: 10, time: 10; [ Info: Simulation is stopping. Model time 10 seconds has hit or exceeded simulation stop time 10 seconds.; ERROR: LoadError: The grid associated with ./mwe_iteration10.jld2 and model.grid are not the same!; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.OutputWriters.var""#52#53""{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.B",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018
https://github.com/CliMA/Oceananigans.jl/issues/2018:14880,Availability,checkpoint,checkpointer,14880,".ScaledPlan{ComplexF64, FFTW.cFFTWPlan{ComplexF64, 1, true, 3, Vector{Int64}}, Float64}, Oceananigans.Solvers.Backward, CPU, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Vector{Int64}, Vector{Periodic}, Int64, Nothing, Nothing}, Oceananigans.Solvers.DiscreteTransform{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, NamedTuple{(:T, :S), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}}}, Nothing, Nothing, NamedTuple{(), Tuple{}}}, String})(file::JLD2.JLDFile{JLD2.MmapIO}); @ Oceananigans.OutputWriters /glade/work/tomasc/.julia_bkp/packages/Oceananigans/52CTk/src/OutputWriters/checkpointer.jl:197; [3] jldopen(::Oceananigans.OutputWriters.var""#52#53""{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Not",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018
https://github.com/CliMA/Oceananigans.jl/issues/2018:28525,Availability,checkpoint,checkpointer,28525,"angeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Vector{Int64}, Vector{Periodic}, Int64, Nothing, Nothing}, Oceananigans.Solvers.DiscreteTransform{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, NamedTuple{(:T, :S), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}}}, Nothing, Nothing, NamedTuple{(), Tuple{}}}, String}, ::String, ::Vararg{String, N} where N; kws::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ JLD2 /glade/work/tomasc/.julia_bkp/packages/JLD2/DcnTD/src/loadsave.jl:4; [4] jldopen; @ /glade/work/tomasc/.julia_bkp/packages/JLD2/DcnTD/src/loadsave.jl:2 [inlined]; [5] set!; @ /glade/work/tomasc/.julia_bkp/packages/Oceananigans/52CTk/src/OutputWriters/checkpointer.jl:193 [inlined]; [6] run!(sim::Simulation{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCon",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018
https://github.com/CliMA/Oceananigans.jl/issues/2018:862,Deployability,update,updated,862,"I'm finding that simulations with `VerticallyStretchedGrid`s don't get picked up and instead throw an error saying that the grid doesn't match. Here's a MWE:. ```julia; using Oceananigans. grid = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). model = NonhydrostaticModel(grid=grid). progress(sim) = @info ""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, Δt=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```. This fails with:. ```; [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 400.714 μs.; [ Info: Executing first time step...; [ Info: Iteration: 1, time: 1; [ Info: Iteration: 2, time: 2; [ Info: Iteration: 3, time: 3; [ Info: Iteration: 4, time: 4; [ Info: Iteration: 5, time: 5; [ Info: Iteration: 6, time: 6; [ Info: Iteration: 7, time: 7; [ Info: Iteration: 8, time: 8; [ Info: Iteration: 9, time: 9; [ Info: Iteration: 10, time: 10; [ Info: Simulation is stopping. Model time 10 seconds has hit or exceeded simulation stop time 10 seconds.; ERROR: LoadError: The grid associated with ./mwe_iteration10.jld2 and model.grid are not the same!; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.OutputWriters.var""#52#53""{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018
https://github.com/CliMA/Oceananigans.jl/issues/2018:611,Energy Efficiency,schedul,schedule,611,"I'm finding that simulations with `VerticallyStretchedGrid`s don't get picked up and instead throw an error saying that the grid doesn't match. Here's a MWE:. ```julia; using Oceananigans. grid = VerticallyStretchedRectilinearGrid(size=(2, 2, 2),; x=(0, 1), y=(0, 1), z_faces=k -> k,; halo=(3,3,3),; ). model = NonhydrostaticModel(grid=grid). progress(sim) = @info ""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, Δt=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```. This fails with:. ```; [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 400.714 μs.; [ Info: Executing first time step...; [ Info: Iteration: 1, time: 1; [ Info: Iteration: 2, time: 2; [ Info: Iteration: 3, time: 3; [ Info: Iteration: 4, time: 4; [ Info: Iteration: 5, time: 5; [ Info: Iteration: 6, time: 6; [ Info: Iteration: 7, time: 7; [ Info: Iteration: 8, time: 8; [ Info: Iteration: 9, time: 9; [ Info: Iteration: 10, time: 10; [ Info: Simulation is stopping. Model time 10 seconds has hit or exceeded simulation stop time 10 seconds.; ERROR: LoadError: The grid associated with ./mwe_iteration10.jld2 and model.grid are not the same!; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.OutputWriters.var""#52#53""{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Floa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018
https://github.com/CliMA/Oceananigans.jl/issues/2018:1351,Performance,Load,LoadError,1351,"""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, Δt=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```. This fails with:. ```; [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 400.714 μs.; [ Info: Executing first time step...; [ Info: Iteration: 1, time: 1; [ Info: Iteration: 2, time: 2; [ Info: Iteration: 3, time: 3; [ Info: Iteration: 4, time: 4; [ Info: Iteration: 5, time: 5; [ Info: Iteration: 6, time: 6; [ Info: Iteration: 7, time: 7; [ Info: Iteration: 8, time: 8; [ Info: Iteration: 9, time: 9; [ Info: Iteration: 10, time: 10; [ Info: Simulation is stopping. Model time 10 seconds has hit or exceeded simulation stop time 10 seconds.; ERROR: LoadError: The grid associated with ./mwe_iteration10.jld2 and model.grid are not the same!; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.OutputWriters.var""#52#53""{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.Boundar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018
https://github.com/CliMA/Oceananigans.jl/issues/2018:28328,Performance,load,loadsave,28328," 1, true, 3, Vector{Int64}}, Float64}, Oceananigans.Solvers.Backward, CPU, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Vector{Int64}, Vector{Periodic}, Int64, Nothing, Nothing}, Oceananigans.Solvers.DiscreteTransform{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, NamedTuple{(:T, :S), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}}}, Nothing, Nothing, NamedTuple{(), Tuple{}}}, String}, ::String, ::Vararg{String, N} where N; kws::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ JLD2 /glade/work/tomasc/.julia_bkp/packages/JLD2/DcnTD/src/loadsave.jl:4; [4] jldopen; @ /glade/work/tomasc/.julia_bkp/packages/JLD2/DcnTD/src/loadsave.jl:2 [inlined]; [5] set!; @ /glade/work/tomasc/.julia_bkp/packages/Oceananigans/52CTk/src/OutputWriters/checkpointer.jl:193 [inlined]; [6] run!(sim::Simulation{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceanan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018
https://github.com/CliMA/Oceananigans.jl/issues/2018:28412,Performance,load,loadsave,28412,"yStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Vector{Int64}, Vector{Periodic}, Int64, Nothing, Nothing}, Oceananigans.Solvers.DiscreteTransform{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, NamedTuple{(:T, :S), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}}}, Nothing, Nothing, NamedTuple{(), Tuple{}}}, String}, ::String, ::Vararg{String, N} where N; kws::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ JLD2 /glade/work/tomasc/.julia_bkp/packages/JLD2/DcnTD/src/loadsave.jl:4; [4] jldopen; @ /glade/work/tomasc/.julia_bkp/packages/JLD2/DcnTD/src/loadsave.jl:2 [inlined]; [5] set!; @ /glade/work/tomasc/.julia_bkp/packages/Oceananigans/52CTk/src/OutputWriters/checkpointer.jl:193 [inlined]; [6] run!(sim::Simulation{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.Boundary",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018
https://github.com/CliMA/Oceananigans.jl/pull/2021:169,Testability,test,tested,169,"This pull request changes the compat entry for the `CubedSphere` package from `0.1` to `0.1, 0.2`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2021
https://github.com/CliMA/Oceananigans.jl/pull/2021:275,Testability,test,tests,275,"This pull request changes the compat entry for the `CubedSphere` package from `0.1` to `0.1, 0.2`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2021
https://github.com/CliMA/Oceananigans.jl/pull/2023:985,Deployability,integrat,integrated,985,"This PR implements a validation experiment on a latitude-longitude grid that spans from 84 S to 84 N, thus ""nearly"" covering the globe. Here's some stats:. * 128 by 60 by 18 resolution, and therefore 2.8 deg grid spacing in the horizontal with 200 m spacing in the vertical; * Realistic bathymetry with solid northern wall; * Prescribed wind stress and temperature flux that relaxes sea surface temperature to a target distribution; * Convective adjustment vertical diffusivity and laplacian background horizontal and vertical diffusivities. ### Yet to be implemented for this setup:. * Annual cycle for wind stress and target sea surface temperature (derived from monthly averaged data, not implemented yet); * Bottom drag (requires capability for immersed boundary fluxes, not implemented); * Gent-McWilliams and skew diffusivity and Redi symmetric isopycnal diffusivity; * CATKE vertical diffusivity (may come in future PR). ## Some visualization. ### Setup: bathymetry, vertically-integrated lateral areas used in free surface solver, boundary conditions. ![image](https://user-images.githubusercontent.com/15271942/138298149-3123d9aa-6b93-4dc7-a811-4e4d0330d686.png). ### Solution after 1 day with 20 second time-step. ![image](https://user-images.githubusercontent.com/15271942/138451026-0d74946b-a5d0-428f-aa15-5743ab05a282.png). We need a bit more work (perhaps a better vertical mixing scheme and stretched grid) to obtain better results at long times. ## Notes. * The implicit free surface solver is the major performance bottleneck for this setup; * With a 20 second time-step and max iterations of 10 for free surface solver, 100 years can be simulated in about 21 hours",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2023
https://github.com/CliMA/Oceananigans.jl/pull/2023:985,Integrability,integrat,integrated,985,"This PR implements a validation experiment on a latitude-longitude grid that spans from 84 S to 84 N, thus ""nearly"" covering the globe. Here's some stats:. * 128 by 60 by 18 resolution, and therefore 2.8 deg grid spacing in the horizontal with 200 m spacing in the vertical; * Realistic bathymetry with solid northern wall; * Prescribed wind stress and temperature flux that relaxes sea surface temperature to a target distribution; * Convective adjustment vertical diffusivity and laplacian background horizontal and vertical diffusivities. ### Yet to be implemented for this setup:. * Annual cycle for wind stress and target sea surface temperature (derived from monthly averaged data, not implemented yet); * Bottom drag (requires capability for immersed boundary fluxes, not implemented); * Gent-McWilliams and skew diffusivity and Redi symmetric isopycnal diffusivity; * CATKE vertical diffusivity (may come in future PR). ## Some visualization. ### Setup: bathymetry, vertically-integrated lateral areas used in free surface solver, boundary conditions. ![image](https://user-images.githubusercontent.com/15271942/138298149-3123d9aa-6b93-4dc7-a811-4e4d0330d686.png). ### Solution after 1 day with 20 second time-step. ![image](https://user-images.githubusercontent.com/15271942/138451026-0d74946b-a5d0-428f-aa15-5743ab05a282.png). We need a bit more work (perhaps a better vertical mixing scheme and stretched grid) to obtain better results at long times. ## Notes. * The implicit free surface solver is the major performance bottleneck for this setup; * With a 20 second time-step and max iterations of 10 for free surface solver, 100 years can be simulated in about 21 hours",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2023
https://github.com/CliMA/Oceananigans.jl/pull/2023:1520,Performance,perform,performance,1520,"This PR implements a validation experiment on a latitude-longitude grid that spans from 84 S to 84 N, thus ""nearly"" covering the globe. Here's some stats:. * 128 by 60 by 18 resolution, and therefore 2.8 deg grid spacing in the horizontal with 200 m spacing in the vertical; * Realistic bathymetry with solid northern wall; * Prescribed wind stress and temperature flux that relaxes sea surface temperature to a target distribution; * Convective adjustment vertical diffusivity and laplacian background horizontal and vertical diffusivities. ### Yet to be implemented for this setup:. * Annual cycle for wind stress and target sea surface temperature (derived from monthly averaged data, not implemented yet); * Bottom drag (requires capability for immersed boundary fluxes, not implemented); * Gent-McWilliams and skew diffusivity and Redi symmetric isopycnal diffusivity; * CATKE vertical diffusivity (may come in future PR). ## Some visualization. ### Setup: bathymetry, vertically-integrated lateral areas used in free surface solver, boundary conditions. ![image](https://user-images.githubusercontent.com/15271942/138298149-3123d9aa-6b93-4dc7-a811-4e4d0330d686.png). ### Solution after 1 day with 20 second time-step. ![image](https://user-images.githubusercontent.com/15271942/138451026-0d74946b-a5d0-428f-aa15-5743ab05a282.png). We need a bit more work (perhaps a better vertical mixing scheme and stretched grid) to obtain better results at long times. ## Notes. * The implicit free surface solver is the major performance bottleneck for this setup; * With a 20 second time-step and max iterations of 10 for free surface solver, 100 years can be simulated in about 21 hours",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2023
https://github.com/CliMA/Oceananigans.jl/pull/2023:1532,Performance,bottleneck,bottleneck,1532,"This PR implements a validation experiment on a latitude-longitude grid that spans from 84 S to 84 N, thus ""nearly"" covering the globe. Here's some stats:. * 128 by 60 by 18 resolution, and therefore 2.8 deg grid spacing in the horizontal with 200 m spacing in the vertical; * Realistic bathymetry with solid northern wall; * Prescribed wind stress and temperature flux that relaxes sea surface temperature to a target distribution; * Convective adjustment vertical diffusivity and laplacian background horizontal and vertical diffusivities. ### Yet to be implemented for this setup:. * Annual cycle for wind stress and target sea surface temperature (derived from monthly averaged data, not implemented yet); * Bottom drag (requires capability for immersed boundary fluxes, not implemented); * Gent-McWilliams and skew diffusivity and Redi symmetric isopycnal diffusivity; * CATKE vertical diffusivity (may come in future PR). ## Some visualization. ### Setup: bathymetry, vertically-integrated lateral areas used in free surface solver, boundary conditions. ![image](https://user-images.githubusercontent.com/15271942/138298149-3123d9aa-6b93-4dc7-a811-4e4d0330d686.png). ### Solution after 1 day with 20 second time-step. ![image](https://user-images.githubusercontent.com/15271942/138451026-0d74946b-a5d0-428f-aa15-5743ab05a282.png). We need a bit more work (perhaps a better vertical mixing scheme and stretched grid) to obtain better results at long times. ## Notes. * The implicit free surface solver is the major performance bottleneck for this setup; * With a 20 second time-step and max iterations of 10 for free surface solver, 100 years can be simulated in about 21 hours",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2023
https://github.com/CliMA/Oceananigans.jl/pull/2023:21,Security,validat,validation,21,"This PR implements a validation experiment on a latitude-longitude grid that spans from 84 S to 84 N, thus ""nearly"" covering the globe. Here's some stats:. * 128 by 60 by 18 resolution, and therefore 2.8 deg grid spacing in the horizontal with 200 m spacing in the vertical; * Realistic bathymetry with solid northern wall; * Prescribed wind stress and temperature flux that relaxes sea surface temperature to a target distribution; * Convective adjustment vertical diffusivity and laplacian background horizontal and vertical diffusivities. ### Yet to be implemented for this setup:. * Annual cycle for wind stress and target sea surface temperature (derived from monthly averaged data, not implemented yet); * Bottom drag (requires capability for immersed boundary fluxes, not implemented); * Gent-McWilliams and skew diffusivity and Redi symmetric isopycnal diffusivity; * CATKE vertical diffusivity (may come in future PR). ## Some visualization. ### Setup: bathymetry, vertically-integrated lateral areas used in free surface solver, boundary conditions. ![image](https://user-images.githubusercontent.com/15271942/138298149-3123d9aa-6b93-4dc7-a811-4e4d0330d686.png). ### Solution after 1 day with 20 second time-step. ![image](https://user-images.githubusercontent.com/15271942/138451026-0d74946b-a5d0-428f-aa15-5743ab05a282.png). We need a bit more work (perhaps a better vertical mixing scheme and stretched grid) to obtain better results at long times. ## Notes. * The implicit free surface solver is the major performance bottleneck for this setup; * With a 20 second time-step and max iterations of 10 for free surface solver, 100 years can be simulated in about 21 hours",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2023
https://github.com/CliMA/Oceananigans.jl/issues/2024:1144,Deployability,update,updated,1144,"iven abstract operation (2D flow speed) and then calculates its x-average by using both a ` WindowedSpatialverage` and `AveragedField`:. ```julia; using Oceananigans. grid = RegularRectilinearGrid(size=(64, 64), extent=(2π, 2π),; topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(architecture = CPU(),; grid = grid,; buoyancy = nothing,; tracers = nothing,; closure = nothing,; ). using Oceananigans.Diagnostics: WindowedSpatialAverage; u, v, w = model.velocities; s = sqrt(u^2 + v^2). s_wind = WindowedSpatialAverage(ComputedField(s), dims=(1,)); s_avgf = AveragedField(s, dims=(1,)). simulation = Simulation(model, Δt=0.2, stop_time=4). simulation.output_writers[:fields] = NetCDFOutputWriter(model, (; s_wind, s_avgf),; schedule = TimeInterval(2),; filepath = ""2drot.nc"",; mode = ""c"",; verbose=true,; ); run!(simulation); ```. When I run this example I get:. ```; julia> include(""2drot.jl""); [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 283.373 μs.; [ Info: Writing to NetCDF: 2drot.nc...; [ Info: Computing NetCDF outputs for time index 1: [""s_wind"", ""s_avgf""]...; [ Info: Computing s_wind done: time=1.592 seconds; [ Info: Computing s_avgf done: time=10.888 seconds; [ Info: Writing done: time=12.480 seconds, size=14.5 KiB, Δsize=0.0 B; [ Info: Executing first time step...; [ Info: Writing to NetCDF: 2drot.nc...; [ Info: Computing NetCDF outputs for time index 2: [""s_wind"", ""s_avgf""]...; [ Info: Computing s_wind done: time=378.512 μs; [ Info: Computing s_avgf done: time=6.476 seconds; [ Info: Writing done: time=6.477 seconds, size=27.1 KiB, Δsize=0.0 B; [ Info: Writing to NetCDF: 2drot.nc...; [ Info: Computing NetCDF outputs for time index 3: [""s_wind"", ""s_avgf""]...; [ Info: Computing s_wind done: time=322.307 μs; [ Info: Computing s_avgf done: time=6.301 seconds; [ Info: Writing done: time=6.301 seconds, size=27.6 KiB, Δsize=0.0 B; [ Info: Simulation is stopping. Model time 4 seconds has hit or exceeded simulation s",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024
https://github.com/CliMA/Oceananigans.jl/issues/2024:2549,Deployability,update,updated,2549,"tCDF outputs for time index 2: [""s_wind"", ""s_avgf""]...; [ Info: Computing s_wind done: time=378.512 μs; [ Info: Computing s_avgf done: time=6.476 seconds; [ Info: Writing done: time=6.477 seconds, size=27.1 KiB, Δsize=0.0 B; [ Info: Writing to NetCDF: 2drot.nc...; [ Info: Computing NetCDF outputs for time index 3: [""s_wind"", ""s_avgf""]...; [ Info: Computing s_wind done: time=322.307 μs; [ Info: Computing s_avgf done: time=6.301 seconds; [ Info: Writing done: time=6.301 seconds, size=27.6 KiB, Δsize=0.0 B; [ Info: Simulation is stopping. Model time 4 seconds has hit or exceeded simulation stop time 4 seconds.; ```. So basically the `AveragedField` version takes _much_ longer than the `WindowedSpatialAverage` version. I noticed that as you increase the size of the domain the difference gets smaller, but it seems to still be there. This is the output for a 512^2 grid:. ```; julia> include(""2drot.jl""); [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 580.342 μs.; [ Info: Writing to NetCDF: 2drot.nc...; [ Info: Computing NetCDF outputs for time index 1: [""s_wind"", ""s_avgf""]...; [ Info: Computing s_wind done: time=3.796 seconds; [ Info: Computing s_avgf done: time=12.948 seconds; [ Info: Writing done: time=16.744 seconds, size=22.5 KiB, Δsize=0.0 B; [ Info: Executing first time step...; [ Info: Writing to NetCDF: 2drot.nc...; [ Info: Computing NetCDF outputs for time index 2: [""s_wind"", ""s_avgf""]...; [ Info: Computing s_wind done: time=2.321 ms; [ Info: Computing s_avgf done: time=7.525 seconds; [ Info: Writing done: time=7.528 seconds, size=38.6 KiB, Δsize=0.0 B; [ Info: Writing to NetCDF: 2drot.nc...; [ Info: Computing NetCDF outputs for time index 3: [""s_wind"", ""s_avgf""]...; [ Info: Computing s_wind done: time=1.707 ms; [ Info: Computing s_avgf done: time=7.579 seconds; [ Info: Writing done: time=7.581 seconds, size=42.6 KiB, Δsize=0.0 B; [ Info: Simulation is stopping. Model time 4 seconds has hit or exceeded simulation stop ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024
https://github.com/CliMA/Oceananigans.jl/issues/2024:890,Energy Efficiency,schedul,schedule,890,"I haven't had a chance to calculate this for GPUs yet, but I just wanted to open this for the time being. . Consider the following MWE that creates a given abstract operation (2D flow speed) and then calculates its x-average by using both a ` WindowedSpatialverage` and `AveragedField`:. ```julia; using Oceananigans. grid = RegularRectilinearGrid(size=(64, 64), extent=(2π, 2π),; topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(architecture = CPU(),; grid = grid,; buoyancy = nothing,; tracers = nothing,; closure = nothing,; ). using Oceananigans.Diagnostics: WindowedSpatialAverage; u, v, w = model.velocities; s = sqrt(u^2 + v^2). s_wind = WindowedSpatialAverage(ComputedField(s), dims=(1,)); s_avgf = AveragedField(s, dims=(1,)). simulation = Simulation(model, Δt=0.2, stop_time=4). simulation.output_writers[:fields] = NetCDFOutputWriter(model, (; s_wind, s_avgf),; schedule = TimeInterval(2),; filepath = ""2drot.nc"",; mode = ""c"",; verbose=true,; ); run!(simulation); ```. When I run this example I get:. ```; julia> include(""2drot.jl""); [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 283.373 μs.; [ Info: Writing to NetCDF: 2drot.nc...; [ Info: Computing NetCDF outputs for time index 1: [""s_wind"", ""s_avgf""]...; [ Info: Computing s_wind done: time=1.592 seconds; [ Info: Computing s_avgf done: time=10.888 seconds; [ Info: Writing done: time=12.480 seconds, size=14.5 KiB, Δsize=0.0 B; [ Info: Executing first time step...; [ Info: Writing to NetCDF: 2drot.nc...; [ Info: Computing NetCDF outputs for time index 2: [""s_wind"", ""s_avgf""]...; [ Info: Computing s_wind done: time=378.512 μs; [ Info: Computing s_avgf done: time=6.476 seconds; [ Info: Writing done: time=6.477 seconds, size=27.1 KiB, Δsize=0.0 B; [ Info: Writing to NetCDF: 2drot.nc...; [ Info: Computing NetCDF outputs for time index 3: [""s_wind"", ""s_avgf""]...; [ Info: Computing s_wind done: time=322.307 μs; [ Info: Computing s_avgf done: time=6.301 seconds; [ Inf",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024
https://github.com/CliMA/Oceananigans.jl/pull/2030:423,Availability,error,error,423,"For some reason when I tested the code after merging https://github.com/CliMA/Oceananigans.jl/pull/2028 it didn't really work on my main code for GPUs. . It worked for a MWE when I tested it [here](https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-952089949) but I guess I must have done something wrong? In any case, I apologize!. I also expanded the test to test grids on GPUs (which would have caught this error) so I think this'll help. Given that we _just_ released a new version, I didn't bump this to 0.63.4 here. But let me know if I should do that. CC: @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030
https://github.com/CliMA/Oceananigans.jl/pull/2030:476,Deployability,release,released,476,"For some reason when I tested the code after merging https://github.com/CliMA/Oceananigans.jl/pull/2028 it didn't really work on my main code for GPUs. . It worked for a MWE when I tested it [here](https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-952089949) but I guess I must have done something wrong? In any case, I apologize!. I also expanded the test to test grids on GPUs (which would have caught this error) so I think this'll help. Given that we _just_ released a new version, I didn't bump this to 0.63.4 here. But let me know if I should do that. CC: @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030
https://github.com/CliMA/Oceananigans.jl/pull/2030:23,Testability,test,tested,23,"For some reason when I tested the code after merging https://github.com/CliMA/Oceananigans.jl/pull/2028 it didn't really work on my main code for GPUs. . It worked for a MWE when I tested it [here](https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-952089949) but I guess I must have done something wrong? In any case, I apologize!. I also expanded the test to test grids on GPUs (which would have caught this error) so I think this'll help. Given that we _just_ released a new version, I didn't bump this to 0.63.4 here. But let me know if I should do that. CC: @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030
https://github.com/CliMA/Oceananigans.jl/pull/2030:181,Testability,test,tested,181,"For some reason when I tested the code after merging https://github.com/CliMA/Oceananigans.jl/pull/2028 it didn't really work on my main code for GPUs. . It worked for a MWE when I tested it [here](https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-952089949) but I guess I must have done something wrong? In any case, I apologize!. I also expanded the test to test grids on GPUs (which would have caught this error) so I think this'll help. Given that we _just_ released a new version, I didn't bump this to 0.63.4 here. But let me know if I should do that. CC: @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030
https://github.com/CliMA/Oceananigans.jl/pull/2030:366,Testability,test,test,366,"For some reason when I tested the code after merging https://github.com/CliMA/Oceananigans.jl/pull/2028 it didn't really work on my main code for GPUs. . It worked for a MWE when I tested it [here](https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-952089949) but I guess I must have done something wrong? In any case, I apologize!. I also expanded the test to test grids on GPUs (which would have caught this error) so I think this'll help. Given that we _just_ released a new version, I didn't bump this to 0.63.4 here. But let me know if I should do that. CC: @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030
https://github.com/CliMA/Oceananigans.jl/pull/2030:374,Testability,test,test,374,"For some reason when I tested the code after merging https://github.com/CliMA/Oceananigans.jl/pull/2028 it didn't really work on my main code for GPUs. . It worked for a MWE when I tested it [here](https://github.com/CliMA/Oceananigans.jl/pull/2028#issuecomment-952089949) but I guess I must have done something wrong? In any case, I apologize!. I also expanded the test to test grids on GPUs (which would have caught this error) so I think this'll help. Given that we _just_ released a new version, I didn't bump this to 0.63.4 here. But let me know if I should do that. CC: @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030
https://github.com/CliMA/Oceananigans.jl/pull/2031:328,Performance,load,load,328,Regression test on the latitude longitude grid ; - Hydrostatic free surface model; - only tested the explicit free surface ; - both periodic and bounded latitude topology tested. Comments; - at the moment the data is generated on the fly at tests/test_regression.jl on the CPU() and tested on the GPU(); - explore the option to load the data in OceananigansArtifacts.jl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2031
https://github.com/CliMA/Oceananigans.jl/pull/2031:11,Testability,test,test,11,Regression test on the latitude longitude grid ; - Hydrostatic free surface model; - only tested the explicit free surface ; - both periodic and bounded latitude topology tested. Comments; - at the moment the data is generated on the fly at tests/test_regression.jl on the CPU() and tested on the GPU(); - explore the option to load the data in OceananigansArtifacts.jl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2031
https://github.com/CliMA/Oceananigans.jl/pull/2031:90,Testability,test,tested,90,Regression test on the latitude longitude grid ; - Hydrostatic free surface model; - only tested the explicit free surface ; - both periodic and bounded latitude topology tested. Comments; - at the moment the data is generated on the fly at tests/test_regression.jl on the CPU() and tested on the GPU(); - explore the option to load the data in OceananigansArtifacts.jl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2031
https://github.com/CliMA/Oceananigans.jl/pull/2031:171,Testability,test,tested,171,Regression test on the latitude longitude grid ; - Hydrostatic free surface model; - only tested the explicit free surface ; - both periodic and bounded latitude topology tested. Comments; - at the moment the data is generated on the fly at tests/test_regression.jl on the CPU() and tested on the GPU(); - explore the option to load the data in OceananigansArtifacts.jl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2031
https://github.com/CliMA/Oceananigans.jl/pull/2031:241,Testability,test,tests,241,Regression test on the latitude longitude grid ; - Hydrostatic free surface model; - only tested the explicit free surface ; - both periodic and bounded latitude topology tested. Comments; - at the moment the data is generated on the fly at tests/test_regression.jl on the CPU() and tested on the GPU(); - explore the option to load the data in OceananigansArtifacts.jl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2031
https://github.com/CliMA/Oceananigans.jl/pull/2031:283,Testability,test,tested,283,Regression test on the latitude longitude grid ; - Hydrostatic free surface model; - only tested the explicit free surface ; - both periodic and bounded latitude topology tested. Comments; - at the moment the data is generated on the fly at tests/test_regression.jl on the CPU() and tested on the GPU(); - explore the option to load the data in OceananigansArtifacts.jl,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2031
https://github.com/CliMA/Oceananigans.jl/pull/2033:22,Performance,optimiz,optimization,22,Reusing the fill_halo optimization done in glw/performance,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2033
https://github.com/CliMA/Oceananigans.jl/pull/2033:47,Performance,perform,performance,47,Reusing the fill_halo optimization done in glw/performance,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2033
https://github.com/CliMA/Oceananigans.jl/issues/2034:755,Availability,down,down,755,"This is related to [this PR](https://github.com/CliMA/Oceananigans.jl/pull/2029). To summarize:. - I have a production-ready research code (that's far too complicated to post here) that does sines/cosines calculations for a background field; - If these sine/consine calculations are performed inside the background field function the code is about 100x slowed than if I perform these calculations outside the function, and just pass the pre-calculated sine and cosine; - I tried making a MWE to reproduce this behavior but failed, which indicates that it's not _just_ the trig functions that are causing the slowdown. It's the trig functions plus something else (I have no idea what). So that's the state of things. I'll try to start from my code and cut down on things one by one to try and post a small MWE whenever I have time. CC: @glwagner @navidcy @francispoulin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2034
https://github.com/CliMA/Oceananigans.jl/issues/2034:283,Performance,perform,performed,283,"This is related to [this PR](https://github.com/CliMA/Oceananigans.jl/pull/2029). To summarize:. - I have a production-ready research code (that's far too complicated to post here) that does sines/cosines calculations for a background field; - If these sine/consine calculations are performed inside the background field function the code is about 100x slowed than if I perform these calculations outside the function, and just pass the pre-calculated sine and cosine; - I tried making a MWE to reproduce this behavior but failed, which indicates that it's not _just_ the trig functions that are causing the slowdown. It's the trig functions plus something else (I have no idea what). So that's the state of things. I'll try to start from my code and cut down on things one by one to try and post a small MWE whenever I have time. CC: @glwagner @navidcy @francispoulin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2034
https://github.com/CliMA/Oceananigans.jl/issues/2034:370,Performance,perform,perform,370,"This is related to [this PR](https://github.com/CliMA/Oceananigans.jl/pull/2029). To summarize:. - I have a production-ready research code (that's far too complicated to post here) that does sines/cosines calculations for a background field; - If these sine/consine calculations are performed inside the background field function the code is about 100x slowed than if I perform these calculations outside the function, and just pass the pre-calculated sine and cosine; - I tried making a MWE to reproduce this behavior but failed, which indicates that it's not _just_ the trig functions that are causing the slowdown. It's the trig functions plus something else (I have no idea what). So that's the state of things. I'll try to start from my code and cut down on things one by one to try and post a small MWE whenever I have time. CC: @glwagner @navidcy @francispoulin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2034
https://github.com/CliMA/Oceananigans.jl/pull/2035:1249,Availability,error,error,1249,"This PR is created to solve the boundary condition race condition that occurs when trying to fill in the halo corner nodes. It is basically just an integration of PR #1985 that runs the halo filling sequentially to avoid unsynchronized execution and PR #1923 to fill left and right halos together which should increase performance. IMPORTANT NOTE:. This PR will fail the ocean large eddy simulation regression tests when lines (50-53) in BoundaryConditions/fill_halo_regions.jl are uncommented. The only thing that these lines do is a reordering of halo filling order such that the periodic boundary conditions are calculated after all the ""Bounded type"" boundary conditions. This is needed since periodic boundary conditions require previous evaluation of boundary conditions in other directions to fill the corner nodes (see PR #1985). It is possible that the ocean-large-eddy-simulation-regression-data has been generated with periodic boundary conditions (west-east, north-south) which are evaluated before the bounded ones (top-bottom) (see the fill_halo_regions! function in main). As such the issue with the test failing when uncommenting lines (50-53) would not be a bug in the code but a bug in the previous generated regression data. This error is quite small (as the corners would be updated based on the previous step ""bounded type"" boundary conditions) but still enough to make the test fail. (I leave this to you to confirm :)). Resolves #1179",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035
https://github.com/CliMA/Oceananigans.jl/pull/2035:148,Deployability,integrat,integration,148,"This PR is created to solve the boundary condition race condition that occurs when trying to fill in the halo corner nodes. It is basically just an integration of PR #1985 that runs the halo filling sequentially to avoid unsynchronized execution and PR #1923 to fill left and right halos together which should increase performance. IMPORTANT NOTE:. This PR will fail the ocean large eddy simulation regression tests when lines (50-53) in BoundaryConditions/fill_halo_regions.jl are uncommented. The only thing that these lines do is a reordering of halo filling order such that the periodic boundary conditions are calculated after all the ""Bounded type"" boundary conditions. This is needed since periodic boundary conditions require previous evaluation of boundary conditions in other directions to fill the corner nodes (see PR #1985). It is possible that the ocean-large-eddy-simulation-regression-data has been generated with periodic boundary conditions (west-east, north-south) which are evaluated before the bounded ones (top-bottom) (see the fill_halo_regions! function in main). As such the issue with the test failing when uncommenting lines (50-53) would not be a bug in the code but a bug in the previous generated regression data. This error is quite small (as the corners would be updated based on the previous step ""bounded type"" boundary conditions) but still enough to make the test fail. (I leave this to you to confirm :)). Resolves #1179",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035
https://github.com/CliMA/Oceananigans.jl/pull/2035:1295,Deployability,update,updated,1295,"This PR is created to solve the boundary condition race condition that occurs when trying to fill in the halo corner nodes. It is basically just an integration of PR #1985 that runs the halo filling sequentially to avoid unsynchronized execution and PR #1923 to fill left and right halos together which should increase performance. IMPORTANT NOTE:. This PR will fail the ocean large eddy simulation regression tests when lines (50-53) in BoundaryConditions/fill_halo_regions.jl are uncommented. The only thing that these lines do is a reordering of halo filling order such that the periodic boundary conditions are calculated after all the ""Bounded type"" boundary conditions. This is needed since periodic boundary conditions require previous evaluation of boundary conditions in other directions to fill the corner nodes (see PR #1985). It is possible that the ocean-large-eddy-simulation-regression-data has been generated with periodic boundary conditions (west-east, north-south) which are evaluated before the bounded ones (top-bottom) (see the fill_halo_regions! function in main). As such the issue with the test failing when uncommenting lines (50-53) would not be a bug in the code but a bug in the previous generated regression data. This error is quite small (as the corners would be updated based on the previous step ""bounded type"" boundary conditions) but still enough to make the test fail. (I leave this to you to confirm :)). Resolves #1179",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035
https://github.com/CliMA/Oceananigans.jl/pull/2035:148,Integrability,integrat,integration,148,"This PR is created to solve the boundary condition race condition that occurs when trying to fill in the halo corner nodes. It is basically just an integration of PR #1985 that runs the halo filling sequentially to avoid unsynchronized execution and PR #1923 to fill left and right halos together which should increase performance. IMPORTANT NOTE:. This PR will fail the ocean large eddy simulation regression tests when lines (50-53) in BoundaryConditions/fill_halo_regions.jl are uncommented. The only thing that these lines do is a reordering of halo filling order such that the periodic boundary conditions are calculated after all the ""Bounded type"" boundary conditions. This is needed since periodic boundary conditions require previous evaluation of boundary conditions in other directions to fill the corner nodes (see PR #1985). It is possible that the ocean-large-eddy-simulation-regression-data has been generated with periodic boundary conditions (west-east, north-south) which are evaluated before the bounded ones (top-bottom) (see the fill_halo_regions! function in main). As such the issue with the test failing when uncommenting lines (50-53) would not be a bug in the code but a bug in the previous generated regression data. This error is quite small (as the corners would be updated based on the previous step ""bounded type"" boundary conditions) but still enough to make the test fail. (I leave this to you to confirm :)). Resolves #1179",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035
https://github.com/CliMA/Oceananigans.jl/pull/2035:51,Performance,race condition,race condition,51,"This PR is created to solve the boundary condition race condition that occurs when trying to fill in the halo corner nodes. It is basically just an integration of PR #1985 that runs the halo filling sequentially to avoid unsynchronized execution and PR #1923 to fill left and right halos together which should increase performance. IMPORTANT NOTE:. This PR will fail the ocean large eddy simulation regression tests when lines (50-53) in BoundaryConditions/fill_halo_regions.jl are uncommented. The only thing that these lines do is a reordering of halo filling order such that the periodic boundary conditions are calculated after all the ""Bounded type"" boundary conditions. This is needed since periodic boundary conditions require previous evaluation of boundary conditions in other directions to fill the corner nodes (see PR #1985). It is possible that the ocean-large-eddy-simulation-regression-data has been generated with periodic boundary conditions (west-east, north-south) which are evaluated before the bounded ones (top-bottom) (see the fill_halo_regions! function in main). As such the issue with the test failing when uncommenting lines (50-53) would not be a bug in the code but a bug in the previous generated regression data. This error is quite small (as the corners would be updated based on the previous step ""bounded type"" boundary conditions) but still enough to make the test fail. (I leave this to you to confirm :)). Resolves #1179",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035
https://github.com/CliMA/Oceananigans.jl/pull/2035:319,Performance,perform,performance,319,"This PR is created to solve the boundary condition race condition that occurs when trying to fill in the halo corner nodes. It is basically just an integration of PR #1985 that runs the halo filling sequentially to avoid unsynchronized execution and PR #1923 to fill left and right halos together which should increase performance. IMPORTANT NOTE:. This PR will fail the ocean large eddy simulation regression tests when lines (50-53) in BoundaryConditions/fill_halo_regions.jl are uncommented. The only thing that these lines do is a reordering of halo filling order such that the periodic boundary conditions are calculated after all the ""Bounded type"" boundary conditions. This is needed since periodic boundary conditions require previous evaluation of boundary conditions in other directions to fill the corner nodes (see PR #1985). It is possible that the ocean-large-eddy-simulation-regression-data has been generated with periodic boundary conditions (west-east, north-south) which are evaluated before the bounded ones (top-bottom) (see the fill_halo_regions! function in main). As such the issue with the test failing when uncommenting lines (50-53) would not be a bug in the code but a bug in the previous generated regression data. This error is quite small (as the corners would be updated based on the previous step ""bounded type"" boundary conditions) but still enough to make the test fail. (I leave this to you to confirm :)). Resolves #1179",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035
https://github.com/CliMA/Oceananigans.jl/pull/2035:215,Safety,avoid,avoid,215,"This PR is created to solve the boundary condition race condition that occurs when trying to fill in the halo corner nodes. It is basically just an integration of PR #1985 that runs the halo filling sequentially to avoid unsynchronized execution and PR #1923 to fill left and right halos together which should increase performance. IMPORTANT NOTE:. This PR will fail the ocean large eddy simulation regression tests when lines (50-53) in BoundaryConditions/fill_halo_regions.jl are uncommented. The only thing that these lines do is a reordering of halo filling order such that the periodic boundary conditions are calculated after all the ""Bounded type"" boundary conditions. This is needed since periodic boundary conditions require previous evaluation of boundary conditions in other directions to fill the corner nodes (see PR #1985). It is possible that the ocean-large-eddy-simulation-regression-data has been generated with periodic boundary conditions (west-east, north-south) which are evaluated before the bounded ones (top-bottom) (see the fill_halo_regions! function in main). As such the issue with the test failing when uncommenting lines (50-53) would not be a bug in the code but a bug in the previous generated regression data. This error is quite small (as the corners would be updated based on the previous step ""bounded type"" boundary conditions) but still enough to make the test fail. (I leave this to you to confirm :)). Resolves #1179",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035
https://github.com/CliMA/Oceananigans.jl/pull/2035:410,Testability,test,tests,410,"This PR is created to solve the boundary condition race condition that occurs when trying to fill in the halo corner nodes. It is basically just an integration of PR #1985 that runs the halo filling sequentially to avoid unsynchronized execution and PR #1923 to fill left and right halos together which should increase performance. IMPORTANT NOTE:. This PR will fail the ocean large eddy simulation regression tests when lines (50-53) in BoundaryConditions/fill_halo_regions.jl are uncommented. The only thing that these lines do is a reordering of halo filling order such that the periodic boundary conditions are calculated after all the ""Bounded type"" boundary conditions. This is needed since periodic boundary conditions require previous evaluation of boundary conditions in other directions to fill the corner nodes (see PR #1985). It is possible that the ocean-large-eddy-simulation-regression-data has been generated with periodic boundary conditions (west-east, north-south) which are evaluated before the bounded ones (top-bottom) (see the fill_halo_regions! function in main). As such the issue with the test failing when uncommenting lines (50-53) would not be a bug in the code but a bug in the previous generated regression data. This error is quite small (as the corners would be updated based on the previous step ""bounded type"" boundary conditions) but still enough to make the test fail. (I leave this to you to confirm :)). Resolves #1179",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035
https://github.com/CliMA/Oceananigans.jl/pull/2035:1115,Testability,test,test,1115,"This PR is created to solve the boundary condition race condition that occurs when trying to fill in the halo corner nodes. It is basically just an integration of PR #1985 that runs the halo filling sequentially to avoid unsynchronized execution and PR #1923 to fill left and right halos together which should increase performance. IMPORTANT NOTE:. This PR will fail the ocean large eddy simulation regression tests when lines (50-53) in BoundaryConditions/fill_halo_regions.jl are uncommented. The only thing that these lines do is a reordering of halo filling order such that the periodic boundary conditions are calculated after all the ""Bounded type"" boundary conditions. This is needed since periodic boundary conditions require previous evaluation of boundary conditions in other directions to fill the corner nodes (see PR #1985). It is possible that the ocean-large-eddy-simulation-regression-data has been generated with periodic boundary conditions (west-east, north-south) which are evaluated before the bounded ones (top-bottom) (see the fill_halo_regions! function in main). As such the issue with the test failing when uncommenting lines (50-53) would not be a bug in the code but a bug in the previous generated regression data. This error is quite small (as the corners would be updated based on the previous step ""bounded type"" boundary conditions) but still enough to make the test fail. (I leave this to you to confirm :)). Resolves #1179",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035
https://github.com/CliMA/Oceananigans.jl/pull/2035:1395,Testability,test,test,1395,"This PR is created to solve the boundary condition race condition that occurs when trying to fill in the halo corner nodes. It is basically just an integration of PR #1985 that runs the halo filling sequentially to avoid unsynchronized execution and PR #1923 to fill left and right halos together which should increase performance. IMPORTANT NOTE:. This PR will fail the ocean large eddy simulation regression tests when lines (50-53) in BoundaryConditions/fill_halo_regions.jl are uncommented. The only thing that these lines do is a reordering of halo filling order such that the periodic boundary conditions are calculated after all the ""Bounded type"" boundary conditions. This is needed since periodic boundary conditions require previous evaluation of boundary conditions in other directions to fill the corner nodes (see PR #1985). It is possible that the ocean-large-eddy-simulation-regression-data has been generated with periodic boundary conditions (west-east, north-south) which are evaluated before the bounded ones (top-bottom) (see the fill_halo_regions! function in main). As such the issue with the test failing when uncommenting lines (50-53) would not be a bug in the code but a bug in the previous generated regression data. This error is quite small (as the corners would be updated based on the previous step ""bounded type"" boundary conditions) but still enough to make the test fail. (I leave this to you to confirm :)). Resolves #1179",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035
https://github.com/CliMA/Oceananigans.jl/pull/2036:69,Availability,down,downloads,69,"This PR stops generating the regression test data in-CI, and instead downloads regression data from `OceananigansArtifacts.jl` to compare against the CI-generated data. With @simone-silvestri . Resolves #2031",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2036
https://github.com/CliMA/Oceananigans.jl/pull/2036:40,Testability,test,test,40,"This PR stops generating the regression test data in-CI, and instead downloads regression data from `OceananigansArtifacts.jl` to compare against the CI-generated data. With @simone-silvestri . Resolves #2031",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2036
https://github.com/CliMA/Oceananigans.jl/issues/2037:2615,Integrability,interface,interface,2615,"ctive) on stretched grids. I think we can replace this with . ```julia; using Oceananigans.AbstractOperations: Δx, Δy, Δz. function cell_advection_timescale(grid, u, v, w); arch = architecture(u); ; max_u_Δx = maximum(abs, u / Δx); max_v_Δy = maximum(abs, v / Δy); max_w_Δz = maximum(abs, w / Δz). return 1 / max(max_u_Δx, max_v_Δy, max_w_Δz); end; ```. Then we can delete the infamous ""`accurate_cell_advection_timescale`"":. https://github.com/CliMA/Oceananigans.jl/blob/2d6ccfe94ce2c68857f70b2f8839020049932e00/src/Diagnostics/cfl.jl#L83-L102. For reference, the new implementation of `cell_advection_timescale` uses `GridMetricOperation` via. ```julia; julia> using Oceananigans.AbstractOperations: Δx; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 8 threads. julia> using Oceananigans. julia> grid = RegularRectilinearGrid(size=(2, 2, 2), extent=(1, 1, 1)); RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); size (Nx, Ny, Nz): (2, 2, 2); halo (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.5, 0.5, 0.5). julia> u = XFaceField(grid); Field located at (Face, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, size: (2, 2, 2); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2); └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux. julia> u / Δx; BinaryOperation at (Face, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=2, Ny=2, Nz=2); │ └── domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; └── tree: ; / at (Face, Center, Center);    ├── Field located at (Face, Center, Center);    └── Δxᶠᶜᵃ at (Face, Center, Center); ```. @navidcy and @tomchor might have something to add about this change to the user interface.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037
https://github.com/CliMA/Oceananigans.jl/pull/2038:8,Availability,down,down,8,Bumping down to 0.64.0 since #1971 accidentally bumped too far to 0.65.0.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2038
https://github.com/CliMA/Oceananigans.jl/pull/2039:353,Energy Efficiency,reduce,reduce,353,"This PR makes a few improvements to reductions of `AbstractField` and `AbstractOperation`. These changes were inspired by the discussion on #2024 (though we don't resolve that issue here). To do:. - [ ] Tests that allocating reductions of abstract operations work (`maximum(a * b)`, etc); - [ ] Test that allocating reductions are correct (eg they only reduce over the interior of an array); - [ ] Benchmark?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2039
https://github.com/CliMA/Oceananigans.jl/pull/2039:203,Testability,Test,Tests,203,"This PR makes a few improvements to reductions of `AbstractField` and `AbstractOperation`. These changes were inspired by the discussion on #2024 (though we don't resolve that issue here). To do:. - [ ] Tests that allocating reductions of abstract operations work (`maximum(a * b)`, etc); - [ ] Test that allocating reductions are correct (eg they only reduce over the interior of an array); - [ ] Benchmark?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2039
https://github.com/CliMA/Oceananigans.jl/pull/2039:295,Testability,Test,Test,295,"This PR makes a few improvements to reductions of `AbstractField` and `AbstractOperation`. These changes were inspired by the discussion on #2024 (though we don't resolve that issue here). To do:. - [ ] Tests that allocating reductions of abstract operations work (`maximum(a * b)`, etc); - [ ] Test that allocating reductions are correct (eg they only reduce over the interior of an array); - [ ] Benchmark?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2039
https://github.com/CliMA/Oceananigans.jl/pull/2039:398,Testability,Benchmark,Benchmark,398,"This PR makes a few improvements to reductions of `AbstractField` and `AbstractOperation`. These changes were inspired by the discussion on #2024 (though we don't resolve that issue here). To do:. - [ ] Tests that allocating reductions of abstract operations work (`maximum(a * b)`, etc); - [ ] Test that allocating reductions are correct (eg they only reduce over the interior of an array); - [ ] Benchmark?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2039
https://github.com/CliMA/Oceananigans.jl/pull/2040:639,Energy Efficiency,reduce,reduce,639,"This PR makes a few improvements to reductions of `AbstractField` and `AbstractOperation`. ~~One change is to perform in-place reductions of `AbstractDataField` (fields backed by data) using the parent arrays (this is much faster as those arrays are contiguous).~~ (This doesn't work, obviously in hindsight) We also try to support allocating reductions of `AbstractOperations` like `maximum(a * b)`. These changes were inspired by the discussion on #2024 (though we don't resolve that issue here). To do:. - [x] Tests that allocating reductions of abstract operations work; - [x] Test that allocating reductions are correct (eg they only reduce over the interior of an array); ~~- [ ] Benchmark?~~",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2040
https://github.com/CliMA/Oceananigans.jl/pull/2040:110,Performance,perform,perform,110,"This PR makes a few improvements to reductions of `AbstractField` and `AbstractOperation`. ~~One change is to perform in-place reductions of `AbstractDataField` (fields backed by data) using the parent arrays (this is much faster as those arrays are contiguous).~~ (This doesn't work, obviously in hindsight) We also try to support allocating reductions of `AbstractOperations` like `maximum(a * b)`. These changes were inspired by the discussion on #2024 (though we don't resolve that issue here). To do:. - [x] Tests that allocating reductions of abstract operations work; - [x] Test that allocating reductions are correct (eg they only reduce over the interior of an array); ~~- [ ] Benchmark?~~",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2040
https://github.com/CliMA/Oceananigans.jl/pull/2040:513,Testability,Test,Tests,513,"This PR makes a few improvements to reductions of `AbstractField` and `AbstractOperation`. ~~One change is to perform in-place reductions of `AbstractDataField` (fields backed by data) using the parent arrays (this is much faster as those arrays are contiguous).~~ (This doesn't work, obviously in hindsight) We also try to support allocating reductions of `AbstractOperations` like `maximum(a * b)`. These changes were inspired by the discussion on #2024 (though we don't resolve that issue here). To do:. - [x] Tests that allocating reductions of abstract operations work; - [x] Test that allocating reductions are correct (eg they only reduce over the interior of an array); ~~- [ ] Benchmark?~~",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2040
https://github.com/CliMA/Oceananigans.jl/pull/2040:581,Testability,Test,Test,581,"This PR makes a few improvements to reductions of `AbstractField` and `AbstractOperation`. ~~One change is to perform in-place reductions of `AbstractDataField` (fields backed by data) using the parent arrays (this is much faster as those arrays are contiguous).~~ (This doesn't work, obviously in hindsight) We also try to support allocating reductions of `AbstractOperations` like `maximum(a * b)`. These changes were inspired by the discussion on #2024 (though we don't resolve that issue here). To do:. - [x] Tests that allocating reductions of abstract operations work; - [x] Test that allocating reductions are correct (eg they only reduce over the interior of an array); ~~- [ ] Benchmark?~~",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2040
https://github.com/CliMA/Oceananigans.jl/pull/2040:686,Testability,Benchmark,Benchmark,686,"This PR makes a few improvements to reductions of `AbstractField` and `AbstractOperation`. ~~One change is to perform in-place reductions of `AbstractDataField` (fields backed by data) using the parent arrays (this is much faster as those arrays are contiguous).~~ (This doesn't work, obviously in hindsight) We also try to support allocating reductions of `AbstractOperations` like `maximum(a * b)`. These changes were inspired by the discussion on #2024 (though we don't resolve that issue here). To do:. - [x] Tests that allocating reductions of abstract operations work; - [x] Test that allocating reductions are correct (eg they only reduce over the interior of an array); ~~- [ ] Benchmark?~~",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2040
https://github.com/CliMA/Oceananigans.jl/issues/2041:225,Security,validat,validate,225,"Unlike the `NonhydrostaticModel`, which has these lines:. https://github.com/CliMA/Oceananigans.jl/blob/1c96350d03e1ee066d5c9060089e043e15f711d6/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L120-L122. It's nice to validate the halos, because sometimes there are non-intuitive constraints (eg on #1994 we may have discovered that isopycnal closures need halos of size 2). cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2041
https://github.com/CliMA/Oceananigans.jl/issues/2041:277,Usability,intuit,intuitive,277,"Unlike the `NonhydrostaticModel`, which has these lines:. https://github.com/CliMA/Oceananigans.jl/blob/1c96350d03e1ee066d5c9060089e043e15f711d6/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L120-L122. It's nice to validate the halos, because sometimes there are non-intuitive constraints (eg on #1994 we may have discovered that isopycnal closures need halos of size 2). cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2041
https://github.com/CliMA/Oceananigans.jl/issues/2043:192,Usability,simpl,simpler,192,"I noticed that the [Ocean wind mixing and convection](https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/#The-grid) example now went back to a simpler `VerticallyStretchedGrid` that's hyberbolically-spaced. This is mostly fine, but just to give a bit of context: originally that example had a simple hyperbolic function, but that meant that the spacing in the mixed layer changed relatively fast, which is numerically undesirable. Because of that, we had changed that to a more complex function that preserved approximately constant spacing near the top, where we care more about the dynamics: https://github.com/CliMA/Oceananigans.jl/pull/1810. For some reason this was changed back to a simple function here: https://github.com/CliMA/Oceananigans.jl/commit/335e47659a11b92df32bf844cebe6e518dec9fc8; It was a pretty big PR so I didn't notice it at the time and couldn't comment on it. I also don't understand why this was changed in that PR, since it doesn't seem to relate to the PR title. In any case, I was wondering if we should again change the vertical spacing function the a function that approximately preserves constant spacing in the mixing layer. Unless there's a reason to keep the hyperbolic function, I don't see why not.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2043
https://github.com/CliMA/Oceananigans.jl/issues/2043:342,Usability,simpl,simple,342,"I noticed that the [Ocean wind mixing and convection](https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/#The-grid) example now went back to a simpler `VerticallyStretchedGrid` that's hyberbolically-spaced. This is mostly fine, but just to give a bit of context: originally that example had a simple hyperbolic function, but that meant that the spacing in the mixed layer changed relatively fast, which is numerically undesirable. Because of that, we had changed that to a more complex function that preserved approximately constant spacing near the top, where we care more about the dynamics: https://github.com/CliMA/Oceananigans.jl/pull/1810. For some reason this was changed back to a simple function here: https://github.com/CliMA/Oceananigans.jl/commit/335e47659a11b92df32bf844cebe6e518dec9fc8; It was a pretty big PR so I didn't notice it at the time and couldn't comment on it. I also don't understand why this was changed in that PR, since it doesn't seem to relate to the PR title. In any case, I was wondering if we should again change the vertical spacing function the a function that approximately preserves constant spacing in the mixing layer. Unless there's a reason to keep the hyperbolic function, I don't see why not.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2043
https://github.com/CliMA/Oceananigans.jl/issues/2043:738,Usability,simpl,simple,738,"I noticed that the [Ocean wind mixing and convection](https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/#The-grid) example now went back to a simpler `VerticallyStretchedGrid` that's hyberbolically-spaced. This is mostly fine, but just to give a bit of context: originally that example had a simple hyperbolic function, but that meant that the spacing in the mixed layer changed relatively fast, which is numerically undesirable. Because of that, we had changed that to a more complex function that preserved approximately constant spacing near the top, where we care more about the dynamics: https://github.com/CliMA/Oceananigans.jl/pull/1810. For some reason this was changed back to a simple function here: https://github.com/CliMA/Oceananigans.jl/commit/335e47659a11b92df32bf844cebe6e518dec9fc8; It was a pretty big PR so I didn't notice it at the time and couldn't comment on it. I also don't understand why this was changed in that PR, since it doesn't seem to relate to the PR title. In any case, I was wondering if we should again change the vertical spacing function the a function that approximately preserves constant spacing in the mixing layer. Unless there's a reason to keep the hyperbolic function, I don't see why not.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2043
https://github.com/CliMA/Oceananigans.jl/issues/2047:115,Testability,test,test,115,"E.g., in addition of this:; https://github.com/CliMA/Oceananigans.jl/blob/057e25cea75a0da5e2e0f2328d39205ebaf2b0dc/test/test_time_stepping.jl#L25-L40; we also have tests using, e.g., `closure = (AnisotropicDiffusivity(FT), Closure(FT))` and also some tests using, e.g., `HydrostaticFreeSurfaceModel`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2047
https://github.com/CliMA/Oceananigans.jl/issues/2047:164,Testability,test,tests,164,"E.g., in addition of this:; https://github.com/CliMA/Oceananigans.jl/blob/057e25cea75a0da5e2e0f2328d39205ebaf2b0dc/test/test_time_stepping.jl#L25-L40; we also have tests using, e.g., `closure = (AnisotropicDiffusivity(FT), Closure(FT))` and also some tests using, e.g., `HydrostaticFreeSurfaceModel`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2047
https://github.com/CliMA/Oceananigans.jl/issues/2047:251,Testability,test,tests,251,"E.g., in addition of this:; https://github.com/CliMA/Oceananigans.jl/blob/057e25cea75a0da5e2e0f2328d39205ebaf2b0dc/test/test_time_stepping.jl#L25-L40; we also have tests using, e.g., `closure = (AnisotropicDiffusivity(FT), Closure(FT))` and also some tests using, e.g., `HydrostaticFreeSurfaceModel`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2047
https://github.com/CliMA/Oceananigans.jl/pull/2048:1327,Availability,error,error,1327,"This PR converts `Simulation.stop_criteria` to `Callback`s. This change allows users to more easily add their own custom stop criteria as callbacks. ### Example. We're interested in running a suite of turbulence simulations involving a transition to turbulence. For this purpose, we'd like to stop a simulation whenever the turbulent kinetic energy exceeds some multiple of its initial value (since I'm interested mainly in the _transition_ to turbulence, rather than the ensuing dynamics. After this PR, this can be implemented by writing. ```julia; # Build a simulation. function turbulent_kinetic_energy_threshold_exceeded(sim). mean_tke = mean(tke_operation) # tke_operation is an `AbstractOperation` that computes turbulent kinetic energy. if mean_tke > 1e-6 # arbitrary threshold for this example!; @info ""Simulation is stopping because the turbulent kinetic energy threshold has been exceeded.""; sim.running = false; end. return nothing; end. # Because this computation is relatively expensive, we perform it every 100 iterations; simulation.callbacks[:tke_threshold] = Callback(turbulent_kinetic_energy_threshold_exceeded, IterationInterval(100)); ```. Previously, it wasn't useful to modify `sim.running` because it would be overwritten immediately. So before this PR, the only way to stop a simulation is to throw an error. This PR _could_ also convert the `NaNChecker` to a stop criterion. In fact we should probably do that. But feedback is welcome beforehand.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2048
https://github.com/CliMA/Oceananigans.jl/pull/2048:342,Energy Efficiency,energy,energy,342,"This PR converts `Simulation.stop_criteria` to `Callback`s. This change allows users to more easily add their own custom stop criteria as callbacks. ### Example. We're interested in running a suite of turbulence simulations involving a transition to turbulence. For this purpose, we'd like to stop a simulation whenever the turbulent kinetic energy exceeds some multiple of its initial value (since I'm interested mainly in the _transition_ to turbulence, rather than the ensuing dynamics. After this PR, this can be implemented by writing. ```julia; # Build a simulation. function turbulent_kinetic_energy_threshold_exceeded(sim). mean_tke = mean(tke_operation) # tke_operation is an `AbstractOperation` that computes turbulent kinetic energy. if mean_tke > 1e-6 # arbitrary threshold for this example!; @info ""Simulation is stopping because the turbulent kinetic energy threshold has been exceeded.""; sim.running = false; end. return nothing; end. # Because this computation is relatively expensive, we perform it every 100 iterations; simulation.callbacks[:tke_threshold] = Callback(turbulent_kinetic_energy_threshold_exceeded, IterationInterval(100)); ```. Previously, it wasn't useful to modify `sim.running` because it would be overwritten immediately. So before this PR, the only way to stop a simulation is to throw an error. This PR _could_ also convert the `NaNChecker` to a stop criterion. In fact we should probably do that. But feedback is welcome beforehand.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2048
https://github.com/CliMA/Oceananigans.jl/pull/2048:737,Energy Efficiency,energy,energy,737,"This PR converts `Simulation.stop_criteria` to `Callback`s. This change allows users to more easily add their own custom stop criteria as callbacks. ### Example. We're interested in running a suite of turbulence simulations involving a transition to turbulence. For this purpose, we'd like to stop a simulation whenever the turbulent kinetic energy exceeds some multiple of its initial value (since I'm interested mainly in the _transition_ to turbulence, rather than the ensuing dynamics. After this PR, this can be implemented by writing. ```julia; # Build a simulation. function turbulent_kinetic_energy_threshold_exceeded(sim). mean_tke = mean(tke_operation) # tke_operation is an `AbstractOperation` that computes turbulent kinetic energy. if mean_tke > 1e-6 # arbitrary threshold for this example!; @info ""Simulation is stopping because the turbulent kinetic energy threshold has been exceeded.""; sim.running = false; end. return nothing; end. # Because this computation is relatively expensive, we perform it every 100 iterations; simulation.callbacks[:tke_threshold] = Callback(turbulent_kinetic_energy_threshold_exceeded, IterationInterval(100)); ```. Previously, it wasn't useful to modify `sim.running` because it would be overwritten immediately. So before this PR, the only way to stop a simulation is to throw an error. This PR _could_ also convert the `NaNChecker` to a stop criterion. In fact we should probably do that. But feedback is welcome beforehand.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2048
https://github.com/CliMA/Oceananigans.jl/pull/2048:865,Energy Efficiency,energy,energy,865,"This PR converts `Simulation.stop_criteria` to `Callback`s. This change allows users to more easily add their own custom stop criteria as callbacks. ### Example. We're interested in running a suite of turbulence simulations involving a transition to turbulence. For this purpose, we'd like to stop a simulation whenever the turbulent kinetic energy exceeds some multiple of its initial value (since I'm interested mainly in the _transition_ to turbulence, rather than the ensuing dynamics. After this PR, this can be implemented by writing. ```julia; # Build a simulation. function turbulent_kinetic_energy_threshold_exceeded(sim). mean_tke = mean(tke_operation) # tke_operation is an `AbstractOperation` that computes turbulent kinetic energy. if mean_tke > 1e-6 # arbitrary threshold for this example!; @info ""Simulation is stopping because the turbulent kinetic energy threshold has been exceeded.""; sim.running = false; end. return nothing; end. # Because this computation is relatively expensive, we perform it every 100 iterations; simulation.callbacks[:tke_threshold] = Callback(turbulent_kinetic_energy_threshold_exceeded, IterationInterval(100)); ```. Previously, it wasn't useful to modify `sim.running` because it would be overwritten immediately. So before this PR, the only way to stop a simulation is to throw an error. This PR _could_ also convert the `NaNChecker` to a stop criterion. In fact we should probably do that. But feedback is welcome beforehand.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2048
https://github.com/CliMA/Oceananigans.jl/pull/2048:1005,Performance,perform,perform,1005,"This PR converts `Simulation.stop_criteria` to `Callback`s. This change allows users to more easily add their own custom stop criteria as callbacks. ### Example. We're interested in running a suite of turbulence simulations involving a transition to turbulence. For this purpose, we'd like to stop a simulation whenever the turbulent kinetic energy exceeds some multiple of its initial value (since I'm interested mainly in the _transition_ to turbulence, rather than the ensuing dynamics. After this PR, this can be implemented by writing. ```julia; # Build a simulation. function turbulent_kinetic_energy_threshold_exceeded(sim). mean_tke = mean(tke_operation) # tke_operation is an `AbstractOperation` that computes turbulent kinetic energy. if mean_tke > 1e-6 # arbitrary threshold for this example!; @info ""Simulation is stopping because the turbulent kinetic energy threshold has been exceeded.""; sim.running = false; end. return nothing; end. # Because this computation is relatively expensive, we perform it every 100 iterations; simulation.callbacks[:tke_threshold] = Callback(turbulent_kinetic_energy_threshold_exceeded, IterationInterval(100)); ```. Previously, it wasn't useful to modify `sim.running` because it would be overwritten immediately. So before this PR, the only way to stop a simulation is to throw an error. This PR _could_ also convert the `NaNChecker` to a stop criterion. In fact we should probably do that. But feedback is welcome beforehand.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2048
https://github.com/CliMA/Oceananigans.jl/pull/2048:1441,Usability,feedback,feedback,1441,"This PR converts `Simulation.stop_criteria` to `Callback`s. This change allows users to more easily add their own custom stop criteria as callbacks. ### Example. We're interested in running a suite of turbulence simulations involving a transition to turbulence. For this purpose, we'd like to stop a simulation whenever the turbulent kinetic energy exceeds some multiple of its initial value (since I'm interested mainly in the _transition_ to turbulence, rather than the ensuing dynamics. After this PR, this can be implemented by writing. ```julia; # Build a simulation. function turbulent_kinetic_energy_threshold_exceeded(sim). mean_tke = mean(tke_operation) # tke_operation is an `AbstractOperation` that computes turbulent kinetic energy. if mean_tke > 1e-6 # arbitrary threshold for this example!; @info ""Simulation is stopping because the turbulent kinetic energy threshold has been exceeded.""; sim.running = false; end. return nothing; end. # Because this computation is relatively expensive, we perform it every 100 iterations; simulation.callbacks[:tke_threshold] = Callback(turbulent_kinetic_energy_threshold_exceeded, IterationInterval(100)); ```. Previously, it wasn't useful to modify `sim.running` because it would be overwritten immediately. So before this PR, the only way to stop a simulation is to throw an error. This PR _could_ also convert the `NaNChecker` to a stop criterion. In fact we should probably do that. But feedback is welcome beforehand.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2048
https://github.com/CliMA/Oceananigans.jl/issues/2049:79,Integrability,depend,depend,79,"They don't right now, even though right now the lateral areas `Ax` and `Ay` do depend on horizontal location:. https://github.com/CliMA/Oceananigans.jl/blob/24e766481cebbc8f61099b386623d175218acedb/src/Operators/spacings_and_areas_and_volumes.jl#L151. Though our underlying grids are ""extruded"" in the vertical (put another way, we make the thin shell approximation for spherical shell grids), vertical spacings may in principle need to depend on horizontal location to accurately represent bathymetry. Another way to see this is that the vertical spacings for `GridFittedBottom` (implemented in #2023) are. https://github.com/CliMA/Oceananigans.jl/blob/8eadc493e04002066448323573edcfde046b9c30/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl#L56-L62. thus conditioning on the function `is_immersed`. But `is_immersed` is evaluated at `(Center, Center, Center)`. But more general operators such as `Δzᶠᶜᶜ` may be needed for correct bathymetry representation. Note that we might need this note only to compute depths correctly, but also for correct diagnostics. cc @sandreza @jm-c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049
https://github.com/CliMA/Oceananigans.jl/issues/2049:437,Integrability,depend,depend,437,"They don't right now, even though right now the lateral areas `Ax` and `Ay` do depend on horizontal location:. https://github.com/CliMA/Oceananigans.jl/blob/24e766481cebbc8f61099b386623d175218acedb/src/Operators/spacings_and_areas_and_volumes.jl#L151. Though our underlying grids are ""extruded"" in the vertical (put another way, we make the thin shell approximation for spherical shell grids), vertical spacings may in principle need to depend on horizontal location to accurately represent bathymetry. Another way to see this is that the vertical spacings for `GridFittedBottom` (implemented in #2023) are. https://github.com/CliMA/Oceananigans.jl/blob/8eadc493e04002066448323573edcfde046b9c30/src/ImmersedBoundaries/grid_fitted_immersed_boundaries.jl#L56-L62. thus conditioning on the function `is_immersed`. But `is_immersed` is evaluated at `(Center, Center, Center)`. But more general operators such as `Δzᶠᶜᶜ` may be needed for correct bathymetry representation. Note that we might need this note only to compute depths correctly, but also for correct diagnostics. cc @sandreza @jm-c",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2049
https://github.com/CliMA/Oceananigans.jl/pull/2050:670,Energy Efficiency,adapt,adapt,670,Eliminate the previous rectilinear grids in favour of a general RectilinearGrid that is optionally stretched in any direction. Should be ready to merge.... Comments and to-do (in a future PR); - All grids except for `ConformalCubedSphereGrid` have an architecture field which means we should (a) include architecture in `ConformalCubedSphereGrid` and (b) remove architecture from all Models and Fields and let it be inferred by the grid (this might be a lot of work); - Nonhydrostatic Pressure solver is specified only for HRegRectilinearGrid (horizontally regular) and RegRectilinearGrid (fully regular). Specify pressure solver also for a non-regular grid? ; - Maybe: adapt the FFTTridiagonalSolver to grids with X and Z regular or Y and Z regular (might be useless because if a simulation requires a non-uniform direction that can just be set to be the z direction and would save us some coding),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050
https://github.com/CliMA/Oceananigans.jl/pull/2050:670,Modifiability,adapt,adapt,670,Eliminate the previous rectilinear grids in favour of a general RectilinearGrid that is optionally stretched in any direction. Should be ready to merge.... Comments and to-do (in a future PR); - All grids except for `ConformalCubedSphereGrid` have an architecture field which means we should (a) include architecture in `ConformalCubedSphereGrid` and (b) remove architecture from all Models and Fields and let it be inferred by the grid (this might be a lot of work); - Nonhydrostatic Pressure solver is specified only for HRegRectilinearGrid (horizontally regular) and RegRectilinearGrid (fully regular). Specify pressure solver also for a non-regular grid? ; - Maybe: adapt the FFTTridiagonalSolver to grids with X and Z regular or Y and Z regular (might be useless because if a simulation requires a non-uniform direction that can just be set to be the z direction and would save us some coding),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050
https://github.com/CliMA/Oceananigans.jl/issues/2051:268,Deployability,integrat,integrate,268,"Right now `AveragedField` is not correct on stretched grids, because we just compute a naive `mean!` over the grid. https://github.com/CliMA/Oceananigans.jl/blob/24e766481cebbc8f61099b386623d175218acedb/src/Fields/averaged_field.jl#L107. But what we really want is to integrate the field over the averaging dimension(s), and then divide by the total size of the dimension. For example, in the absence of immersed boundaries we can do something like. ```julia; using Oceananigans.AbstractOperations: Δz; u_Δz = u * Δz; U = ReducedField{Face, Center, Nothing}(arch, grid, dims=3); sum!(U, u_Δz); U .=/ grid.Lz; ```. In the presence of immersed boundaries, we actually have to calculate the total length of the dimension (eg, the total depth). We can possibly reduced `GridMetricOperation` for that purpose too. For `IntegratedField`, we simply avoid the final division by `Lz`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2051
https://github.com/CliMA/Oceananigans.jl/issues/2051:814,Deployability,Integrat,IntegratedField,814,"Right now `AveragedField` is not correct on stretched grids, because we just compute a naive `mean!` over the grid. https://github.com/CliMA/Oceananigans.jl/blob/24e766481cebbc8f61099b386623d175218acedb/src/Fields/averaged_field.jl#L107. But what we really want is to integrate the field over the averaging dimension(s), and then divide by the total size of the dimension. For example, in the absence of immersed boundaries we can do something like. ```julia; using Oceananigans.AbstractOperations: Δz; u_Δz = u * Δz; U = ReducedField{Face, Center, Nothing}(arch, grid, dims=3); sum!(U, u_Δz); U .=/ grid.Lz; ```. In the presence of immersed boundaries, we actually have to calculate the total length of the dimension (eg, the total depth). We can possibly reduced `GridMetricOperation` for that purpose too. For `IntegratedField`, we simply avoid the final division by `Lz`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2051
https://github.com/CliMA/Oceananigans.jl/issues/2051:522,Energy Efficiency,Reduce,ReducedField,522,"Right now `AveragedField` is not correct on stretched grids, because we just compute a naive `mean!` over the grid. https://github.com/CliMA/Oceananigans.jl/blob/24e766481cebbc8f61099b386623d175218acedb/src/Fields/averaged_field.jl#L107. But what we really want is to integrate the field over the averaging dimension(s), and then divide by the total size of the dimension. For example, in the absence of immersed boundaries we can do something like. ```julia; using Oceananigans.AbstractOperations: Δz; u_Δz = u * Δz; U = ReducedField{Face, Center, Nothing}(arch, grid, dims=3); sum!(U, u_Δz); U .=/ grid.Lz; ```. In the presence of immersed boundaries, we actually have to calculate the total length of the dimension (eg, the total depth). We can possibly reduced `GridMetricOperation` for that purpose too. For `IntegratedField`, we simply avoid the final division by `Lz`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2051
https://github.com/CliMA/Oceananigans.jl/issues/2051:757,Energy Efficiency,reduce,reduced,757,"Right now `AveragedField` is not correct on stretched grids, because we just compute a naive `mean!` over the grid. https://github.com/CliMA/Oceananigans.jl/blob/24e766481cebbc8f61099b386623d175218acedb/src/Fields/averaged_field.jl#L107. But what we really want is to integrate the field over the averaging dimension(s), and then divide by the total size of the dimension. For example, in the absence of immersed boundaries we can do something like. ```julia; using Oceananigans.AbstractOperations: Δz; u_Δz = u * Δz; U = ReducedField{Face, Center, Nothing}(arch, grid, dims=3); sum!(U, u_Δz); U .=/ grid.Lz; ```. In the presence of immersed boundaries, we actually have to calculate the total length of the dimension (eg, the total depth). We can possibly reduced `GridMetricOperation` for that purpose too. For `IntegratedField`, we simply avoid the final division by `Lz`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2051
https://github.com/CliMA/Oceananigans.jl/issues/2051:268,Integrability,integrat,integrate,268,"Right now `AveragedField` is not correct on stretched grids, because we just compute a naive `mean!` over the grid. https://github.com/CliMA/Oceananigans.jl/blob/24e766481cebbc8f61099b386623d175218acedb/src/Fields/averaged_field.jl#L107. But what we really want is to integrate the field over the averaging dimension(s), and then divide by the total size of the dimension. For example, in the absence of immersed boundaries we can do something like. ```julia; using Oceananigans.AbstractOperations: Δz; u_Δz = u * Δz; U = ReducedField{Face, Center, Nothing}(arch, grid, dims=3); sum!(U, u_Δz); U .=/ grid.Lz; ```. In the presence of immersed boundaries, we actually have to calculate the total length of the dimension (eg, the total depth). We can possibly reduced `GridMetricOperation` for that purpose too. For `IntegratedField`, we simply avoid the final division by `Lz`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2051
https://github.com/CliMA/Oceananigans.jl/issues/2051:814,Integrability,Integrat,IntegratedField,814,"Right now `AveragedField` is not correct on stretched grids, because we just compute a naive `mean!` over the grid. https://github.com/CliMA/Oceananigans.jl/blob/24e766481cebbc8f61099b386623d175218acedb/src/Fields/averaged_field.jl#L107. But what we really want is to integrate the field over the averaging dimension(s), and then divide by the total size of the dimension. For example, in the absence of immersed boundaries we can do something like. ```julia; using Oceananigans.AbstractOperations: Δz; u_Δz = u * Δz; U = ReducedField{Face, Center, Nothing}(arch, grid, dims=3); sum!(U, u_Δz); U .=/ grid.Lz; ```. In the presence of immersed boundaries, we actually have to calculate the total length of the dimension (eg, the total depth). We can possibly reduced `GridMetricOperation` for that purpose too. For `IntegratedField`, we simply avoid the final division by `Lz`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2051
https://github.com/CliMA/Oceananigans.jl/issues/2051:842,Safety,avoid,avoid,842,"Right now `AveragedField` is not correct on stretched grids, because we just compute a naive `mean!` over the grid. https://github.com/CliMA/Oceananigans.jl/blob/24e766481cebbc8f61099b386623d175218acedb/src/Fields/averaged_field.jl#L107. But what we really want is to integrate the field over the averaging dimension(s), and then divide by the total size of the dimension. For example, in the absence of immersed boundaries we can do something like. ```julia; using Oceananigans.AbstractOperations: Δz; u_Δz = u * Δz; U = ReducedField{Face, Center, Nothing}(arch, grid, dims=3); sum!(U, u_Δz); U .=/ grid.Lz; ```. In the presence of immersed boundaries, we actually have to calculate the total length of the dimension (eg, the total depth). We can possibly reduced `GridMetricOperation` for that purpose too. For `IntegratedField`, we simply avoid the final division by `Lz`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2051
https://github.com/CliMA/Oceananigans.jl/issues/2051:835,Usability,simpl,simply,835,"Right now `AveragedField` is not correct on stretched grids, because we just compute a naive `mean!` over the grid. https://github.com/CliMA/Oceananigans.jl/blob/24e766481cebbc8f61099b386623d175218acedb/src/Fields/averaged_field.jl#L107. But what we really want is to integrate the field over the averaging dimension(s), and then divide by the total size of the dimension. For example, in the absence of immersed boundaries we can do something like. ```julia; using Oceananigans.AbstractOperations: Δz; u_Δz = u * Δz; U = ReducedField{Face, Center, Nothing}(arch, grid, dims=3); sum!(U, u_Δz); U .=/ grid.Lz; ```. In the presence of immersed boundaries, we actually have to calculate the total length of the dimension (eg, the total depth). We can possibly reduced `GridMetricOperation` for that purpose too. For `IntegratedField`, we simply avoid the final division by `Lz`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2051
https://github.com/CliMA/Oceananigans.jl/issues/2052:119,Availability,redundant,redundant,119,"It's been pointed out several times (most recently by @sandreza) that the many different `Field` types are potentially redundant, or that we might get away with one 'general' definition. One general definition might be something like. ```julia; struct Field{X, Y, Z, ...}; data; grid; architecture; boundary_conditions; operand; status; end; ```. more or less mirroring [`ComputedField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Fields/computed_field.jl). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052
https://github.com/CliMA/Oceananigans.jl/issues/2052:588,Availability,recover,recovers,588,"It's been pointed out several times (most recently by @sandreza) that the many different `Field` types are potentially redundant, or that we might get away with one 'general' definition. One general definition might be something like. ```julia; struct Field{X, Y, Z, ...}; data; grid; architecture; boundary_conditions; operand; status; end; ```. more or less mirroring [`ComputedField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Fields/computed_field.jl). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052
https://github.com/CliMA/Oceananigans.jl/issues/2052:640,Availability,recover,recovers,640,"It's been pointed out several times (most recently by @sandreza) that the many different `Field` types are potentially redundant, or that we might get away with one 'general' definition. One general definition might be something like. ```julia; struct Field{X, Y, Z, ...}; data; grid; architecture; boundary_conditions; operand; status; end; ```. more or less mirroring [`ComputedField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Fields/computed_field.jl). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052
https://github.com/CliMA/Oceananigans.jl/issues/2052:849,Deployability,Integrat,Integrated,849,"It's been pointed out several times (most recently by @sandreza) that the many different `Field` types are potentially redundant, or that we might get away with one 'general' definition. One general definition might be something like. ```julia; struct Field{X, Y, Z, ...}; data; grid; architecture; boundary_conditions; operand; status; end; ```. more or less mirroring [`ComputedField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Fields/computed_field.jl). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052
https://github.com/CliMA/Oceananigans.jl/issues/2052:727,Energy Efficiency,reduce,reduced,727,"It's been pointed out several times (most recently by @sandreza) that the many different `Field` types are potentially redundant, or that we might get away with one 'general' definition. One general definition might be something like. ```julia; struct Field{X, Y, Z, ...}; data; grid; architecture; boundary_conditions; operand; status; end; ```. more or less mirroring [`ComputedField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Fields/computed_field.jl). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052
https://github.com/CliMA/Oceananigans.jl/issues/2052:1035,Energy Efficiency,reduce,reduce,1035,"t `Field` types are potentially redundant, or that we might get away with one 'general' definition. One general definition might be something like. ```julia; struct Field{X, Y, Z, ...}; data; grid; architecture; boundary_conditions; operand; status; end; ```. more or less mirroring [`ComputedField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Fields/computed_field.jl). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is one example of a pervasive problem in the source, but that's a topic for another issue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052
https://github.com/CliMA/Oceananigans.jl/issues/2052:2185,Energy Efficiency,adapt,adapting,2185,"). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is one example of a pervasive problem in the source, but that's a topic for another issue). Note that previously this was deemed difficult because we typically throw away locations when adapting `Field` to the GPU (see eg #746), which means that the above solution might break broadcasting with reduced fields. But I only realized (duh...) that we can easily add special `adapt_structure` methods for the case that some locations are reduced, which solves the problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052
https://github.com/CliMA/Oceananigans.jl/issues/2052:2294,Energy Efficiency,reduce,reduced,2294,"). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is one example of a pervasive problem in the source, but that's a topic for another issue). Note that previously this was deemed difficult because we typically throw away locations when adapting `Field` to the GPU (see eg #746), which means that the above solution might break broadcasting with reduced fields. But I only realized (duh...) that we can easily add special `adapt_structure` methods for the case that some locations are reduced, which solves the problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052
https://github.com/CliMA/Oceananigans.jl/issues/2052:2433,Energy Efficiency,reduce,reduced,2433,"). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is one example of a pervasive problem in the source, but that's a topic for another issue). Note that previously this was deemed difficult because we typically throw away locations when adapting `Field` to the GPU (see eg #746), which means that the above solution might break broadcasting with reduced fields. But I only realized (duh...) that we can easily add special `adapt_structure` methods for the case that some locations are reduced, which solves the problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052
https://github.com/CliMA/Oceananigans.jl/issues/2052:819,Integrability,wrap,wrappers,819,"It's been pointed out several times (most recently by @sandreza) that the many different `Field` types are potentially redundant, or that we might get away with one 'general' definition. One general definition might be something like. ```julia; struct Field{X, Y, Z, ...}; data; grid; architecture; boundary_conditions; operand; status; end; ```. more or less mirroring [`ComputedField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Fields/computed_field.jl). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052
https://github.com/CliMA/Oceananigans.jl/issues/2052:849,Integrability,Integrat,Integrated,849,"It's been pointed out several times (most recently by @sandreza) that the many different `Field` types are potentially redundant, or that we might get away with one 'general' definition. One general definition might be something like. ```julia; struct Field{X, Y, Z, ...}; data; grid; architecture; boundary_conditions; operand; status; end; ```. more or less mirroring [`ComputedField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Fields/computed_field.jl). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052
https://github.com/CliMA/Oceananigans.jl/issues/2052:1540,Integrability,interface,interface,1540,"). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is one example of a pervasive problem in the source, but that's a topic for another issue). Note that previously this was deemed difficult because we typically throw away locations when adapting `Field` to the GPU (see eg #746), which means that the above solution might break broadcasting with reduced fields. But I only realized (duh...) that we can easily add special `adapt_structure` methods for the case that some locations are reduced, which solves the problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052
https://github.com/CliMA/Oceananigans.jl/issues/2052:2185,Modifiability,adapt,adapting,2185,"). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is one example of a pervasive problem in the source, but that's a topic for another issue). Note that previously this was deemed difficult because we typically throw away locations when adapting `Field` to the GPU (see eg #746), which means that the above solution might break broadcasting with reduced fields. But I only realized (duh...) that we can easily add special `adapt_structure` methods for the case that some locations are reduced, which solves the problem.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052
https://github.com/CliMA/Oceananigans.jl/issues/2052:119,Safety,redund,redundant,119,"It's been pointed out several times (most recently by @sandreza) that the many different `Field` types are potentially redundant, or that we might get away with one 'general' definition. One general definition might be something like. ```julia; struct Field{X, Y, Z, ...}; data; grid; architecture; boundary_conditions; operand; status; end; ```. more or less mirroring [`ComputedField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Fields/computed_field.jl). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052
https://github.com/CliMA/Oceananigans.jl/issues/2052:588,Safety,recover,recovers,588,"It's been pointed out several times (most recently by @sandreza) that the many different `Field` types are potentially redundant, or that we might get away with one 'general' definition. One general definition might be something like. ```julia; struct Field{X, Y, Z, ...}; data; grid; architecture; boundary_conditions; operand; status; end; ```. more or less mirroring [`ComputedField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Fields/computed_field.jl). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052
https://github.com/CliMA/Oceananigans.jl/issues/2052:640,Safety,recover,recovers,640,"It's been pointed out several times (most recently by @sandreza) that the many different `Field` types are potentially redundant, or that we might get away with one 'general' definition. One general definition might be something like. ```julia; struct Field{X, Y, Z, ...}; data; grid; architecture; boundary_conditions; operand; status; end; ```. more or less mirroring [`ComputedField`](https://github.com/CliMA/Oceananigans.jl/blob/main/src/Fields/computed_field.jl). We then have the following equivalencies to existing data structures:. * `isnothing(operand)` and `isnothing(status)` recovers `Field`; * `operand isa AbstractOperation` recovers `ComputedField`; * one or more of `X, Y, Z` is `Nothing` implies the field is reduced along the `Nothing` dimension. For ""computed reductions"", we can define new operand wrappers like `Averaged` and `Integrated` with `dims` properties (maybe `Average`, or tense other than past or present, is better). We'll probably want to retain `KernelComputedField` and `FunctionField`. This would reduce the number of `struct`s we define significantly and might otherwise result in a significant reduction of code. It also clarifies how custom computed fields are defined: basically we might have something like. ```julia; compute!(field::Field) = compute!(field, field.operand); ```. This falls back to a no-op when `operand::Nothing`, but supports other behavior is `operand::AbstractOperation`, `operand::Average{<:AbstractOperation}`, or some other user-defined type. We can keep the existing user interface if we want, or we can change it. I'm less sure about what's best there. We probably wouldn't have a use for `ComputedField`, but for averages we could have. ```julia; avg_c = Field(Average(c, dims=1)); ```. or. ```julia; avg_c = Field(c, Average(dims=1)); ```. or, as before,. ```julia; avg_c = AveragedField(c, dims=1); ```. The last seems like the most readable, but obfuscates the source since there'd no longer be a struct `AveragedField` (this is",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2052
https://github.com/CliMA/Oceananigans.jl/issues/2058:24,Integrability,interface,interface,24,We should figure out an interface to help users access grid metrics. We shouldn't have to write things like `grid.Δxᵃᵃᶜ` in the examples. _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/2050#issuecomment-967266791_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058
https://github.com/CliMA/Oceananigans.jl/issues/2058:48,Security,access,access,48,We should figure out an interface to help users access grid metrics. We shouldn't have to write things like `grid.Δxᵃᵃᶜ` in the examples. _Originally posted by @glwagner in https://github.com/CliMA/Oceananigans.jl/issues/2050#issuecomment-967266791_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058
https://github.com/CliMA/Oceananigans.jl/pull/2059:858,Security,validat,validation,858,"Added a new type WENO5S which allows the execution of the WENO scheme on stretched and uniform grids alike. . In practice:. if the direction is uniform (`typeof(Δc) <: Number`) the scheme defaults to the usual 5th order interpolation coefficients (""uniform setting""). otherwise if the grid is stretched:. - `WENO5S(grid = grid)` will precompute the WENO coefficients for the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation is: it is way too expensive!); - `WENO5s()` will default to the uniform 5th order coefficients (""uniform"" setting); - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; `WENO5()` is obsolete as all the functionalities of `WENO5()` are included in `WENO5S()`, on the other hand, I kept this type for the moment for validation and benchmark purposes. When the `WENO5S(args...)` scheme is approved we can refractor it to `WENO5(args...)` and delete `src/Advection/weno_fifth_order.jl`. The `test/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D tracer advection simulation. Blow outputs when the grid is fairly coarse (`Nx=20`); ```; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420889, ; │ WENO5S uniform setting : 9.677123910420574, ; └ WENO5 (only uniform) : 9.677123910420574; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : 15.327517291492; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420846, ; │ WENO5S uniform setting : 9.677123910420608, ; └ WENO5 (only uniform) : 9.677123910420608; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is stretched; │ ; │ WENO5S str",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2059
https://github.com/CliMA/Oceananigans.jl/pull/2059:426,Testability,test,tested,426,"Added a new type WENO5S which allows the execution of the WENO scheme on stretched and uniform grids alike. . In practice:. if the direction is uniform (`typeof(Δc) <: Number`) the scheme defaults to the usual 5th order interpolation coefficients (""uniform setting""). otherwise if the grid is stretched:. - `WENO5S(grid = grid)` will precompute the WENO coefficients for the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation is: it is way too expensive!); - `WENO5s()` will default to the uniform 5th order coefficients (""uniform"" setting); - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; `WENO5()` is obsolete as all the functionalities of `WENO5()` are included in `WENO5S()`, on the other hand, I kept this type for the moment for validation and benchmark purposes. When the `WENO5S(args...)` scheme is approved we can refractor it to `WENO5(args...)` and delete `src/Advection/weno_fifth_order.jl`. The `test/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D tracer advection simulation. Blow outputs when the grid is fairly coarse (`Nx=20`); ```; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420889, ; │ WENO5S uniform setting : 9.677123910420574, ; └ WENO5 (only uniform) : 9.677123910420574; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : 15.327517291492; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420846, ; │ WENO5S uniform setting : 9.677123910420608, ; └ WENO5 (only uniform) : 9.677123910420608; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is stretched; │ ; │ WENO5S str",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2059
https://github.com/CliMA/Oceananigans.jl/pull/2059:873,Testability,benchmark,benchmark,873,"Added a new type WENO5S which allows the execution of the WENO scheme on stretched and uniform grids alike. . In practice:. if the direction is uniform (`typeof(Δc) <: Number`) the scheme defaults to the usual 5th order interpolation coefficients (""uniform setting""). otherwise if the grid is stretched:. - `WENO5S(grid = grid)` will precompute the WENO coefficients for the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation is: it is way too expensive!); - `WENO5s()` will default to the uniform 5th order coefficients (""uniform"" setting); - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; `WENO5()` is obsolete as all the functionalities of `WENO5()` are included in `WENO5S()`, on the other hand, I kept this type for the moment for validation and benchmark purposes. When the `WENO5S(args...)` scheme is approved we can refractor it to `WENO5(args...)` and delete `src/Advection/weno_fifth_order.jl`. The `test/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D tracer advection simulation. Blow outputs when the grid is fairly coarse (`Nx=20`); ```; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420889, ; │ WENO5S uniform setting : 9.677123910420574, ; └ WENO5 (only uniform) : 9.677123910420574; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : 15.327517291492; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420846, ; │ WENO5S uniform setting : 9.677123910420608, ; └ WENO5 (only uniform) : 9.677123910420608; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is stretched; │ ; │ WENO5S str",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2059
https://github.com/CliMA/Oceananigans.jl/pull/2059:1032,Testability,test,test,1032,"xecution of the WENO scheme on stretched and uniform grids alike. . In practice:. if the direction is uniform (`typeof(Δc) <: Number`) the scheme defaults to the usual 5th order interpolation coefficients (""uniform setting""). otherwise if the grid is stretched:. - `WENO5S(grid = grid)` will precompute the WENO coefficients for the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation is: it is way too expensive!); - `WENO5s()` will default to the uniform 5th order coefficients (""uniform"" setting); - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; `WENO5()` is obsolete as all the functionalities of `WENO5()` are included in `WENO5S()`, on the other hand, I kept this type for the moment for validation and benchmark purposes. When the `WENO5S(args...)` scheme is approved we can refractor it to `WENO5(args...)` and delete `src/Advection/weno_fifth_order.jl`. The `test/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D tracer advection simulation. Blow outputs when the grid is fairly coarse (`Nx=20`); ```; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420889, ; │ WENO5S uniform setting : 9.677123910420574, ; └ WENO5 (only uniform) : 9.677123910420574; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : 15.327517291492; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420846, ; │ WENO5S uniform setting : 9.677123910420608, ; └ WENO5 (only uniform) : 9.677123910420608; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ W",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2059
https://github.com/CliMA/Oceananigans.jl/pull/2059:2135,Testability,benchmark,benchmark,2135,"rgs...)` and delete `src/Advection/weno_fifth_order.jl`. The `test/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D tracer advection simulation. Blow outputs when the grid is fairly coarse (`Nx=20`); ```; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420889, ; │ WENO5S uniform setting : 9.677123910420574, ; └ WENO5 (only uniform) : 9.677123910420574; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : 15.327517291492; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420846, ; │ WENO5S uniform setting : 9.677123910420608, ; └ WENO5 (only uniform) : 9.677123910420608; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : 15.327517291492. ┌ Info: benchmark for settings; │ architecture is GPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 0.016049044, ; │ WENO5S uniform setting : 0.015951728, ; └ WENO5 (only uniform) : 0.015978376; ┌ Info: benchmark for settings; │ architecture is GPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 0.016095937, ; │ WENO5S uniform setting : 0.015944528, ; └ WENO5 (only uniform) : 0.015961198; ┌ Info: benchmark for settings; │ architecture is CPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 0.005800518, ; │ WENO5S uniform setting : 0.005535015, ; └ WENO5 (only uniform) : 0.006188944; ┌ Info: benchmark for settings; │ architecture is CPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 0.005982374, ; │ WENO5S uniform setting : 0.005827935, ; └ WENO5 (only uniform) : 0.006182819. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2059
https://github.com/CliMA/Oceananigans.jl/pull/2059:2344,Testability,benchmark,benchmark,2344,"rgs...)` and delete `src/Advection/weno_fifth_order.jl`. The `test/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D tracer advection simulation. Blow outputs when the grid is fairly coarse (`Nx=20`); ```; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420889, ; │ WENO5S uniform setting : 9.677123910420574, ; └ WENO5 (only uniform) : 9.677123910420574; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : 15.327517291492; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420846, ; │ WENO5S uniform setting : 9.677123910420608, ; └ WENO5 (only uniform) : 9.677123910420608; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : 15.327517291492. ┌ Info: benchmark for settings; │ architecture is GPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 0.016049044, ; │ WENO5S uniform setting : 0.015951728, ; └ WENO5 (only uniform) : 0.015978376; ┌ Info: benchmark for settings; │ architecture is GPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 0.016095937, ; │ WENO5S uniform setting : 0.015944528, ; └ WENO5 (only uniform) : 0.015961198; ┌ Info: benchmark for settings; │ architecture is CPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 0.005800518, ; │ WENO5S uniform setting : 0.005535015, ; └ WENO5 (only uniform) : 0.006188944; ┌ Info: benchmark for settings; │ architecture is CPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 0.005982374, ; │ WENO5S uniform setting : 0.005827935, ; └ WENO5 (only uniform) : 0.006182819. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2059
https://github.com/CliMA/Oceananigans.jl/pull/2059:2555,Testability,benchmark,benchmark,2555,"rgs...)` and delete `src/Advection/weno_fifth_order.jl`. The `test/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D tracer advection simulation. Blow outputs when the grid is fairly coarse (`Nx=20`); ```; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420889, ; │ WENO5S uniform setting : 9.677123910420574, ; └ WENO5 (only uniform) : 9.677123910420574; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : 15.327517291492; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420846, ; │ WENO5S uniform setting : 9.677123910420608, ; └ WENO5 (only uniform) : 9.677123910420608; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : 15.327517291492. ┌ Info: benchmark for settings; │ architecture is GPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 0.016049044, ; │ WENO5S uniform setting : 0.015951728, ; └ WENO5 (only uniform) : 0.015978376; ┌ Info: benchmark for settings; │ architecture is GPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 0.016095937, ; │ WENO5S uniform setting : 0.015944528, ; └ WENO5 (only uniform) : 0.015961198; ┌ Info: benchmark for settings; │ architecture is CPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 0.005800518, ; │ WENO5S uniform setting : 0.005535015, ; └ WENO5 (only uniform) : 0.006188944; ┌ Info: benchmark for settings; │ architecture is CPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 0.005982374, ; │ WENO5S uniform setting : 0.005827935, ; └ WENO5 (only uniform) : 0.006182819. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2059
https://github.com/CliMA/Oceananigans.jl/pull/2059:2764,Testability,benchmark,benchmark,2764,"rgs...)` and delete `src/Advection/weno_fifth_order.jl`. The `test/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D tracer advection simulation. Blow outputs when the grid is fairly coarse (`Nx=20`); ```; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420889, ; │ WENO5S uniform setting : 9.677123910420574, ; └ WENO5 (only uniform) : 9.677123910420574; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : 15.327517291492; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420846, ; │ WENO5S uniform setting : 9.677123910420608, ; └ WENO5 (only uniform) : 9.677123910420608; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : 15.327517291492. ┌ Info: benchmark for settings; │ architecture is GPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 0.016049044, ; │ WENO5S uniform setting : 0.015951728, ; └ WENO5 (only uniform) : 0.015978376; ┌ Info: benchmark for settings; │ architecture is GPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 0.016095937, ; │ WENO5S uniform setting : 0.015944528, ; └ WENO5 (only uniform) : 0.015961198; ┌ Info: benchmark for settings; │ architecture is CPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 0.005800518, ; │ WENO5S uniform setting : 0.005535015, ; └ WENO5 (only uniform) : 0.006188944; ┌ Info: benchmark for settings; │ architecture is CPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 0.005982374, ; │ WENO5S uniform setting : 0.005827935, ; └ WENO5 (only uniform) : 0.006182819. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2059
https://github.com/CliMA/Oceananigans.jl/pull/2059:1124,Usability,simpl,simple,1124,"In practice:. if the direction is uniform (`typeof(Δc) <: Number`) the scheme defaults to the usual 5th order interpolation coefficients (""uniform setting""). otherwise if the grid is stretched:. - `WENO5S(grid = grid)` will precompute the WENO coefficients for the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation is: it is way too expensive!); - `WENO5s()` will default to the uniform 5th order coefficients (""uniform"" setting); - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; `WENO5()` is obsolete as all the functionalities of `WENO5()` are included in `WENO5S()`, on the other hand, I kept this type for the moment for validation and benchmark purposes. When the `WENO5S(args...)` scheme is approved we can refractor it to `WENO5(args...)` and delete `src/Advection/weno_fifth_order.jl`. The `test/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D tracer advection simulation. Blow outputs when the grid is fairly coarse (`Nx=20`); ```; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420889, ; │ WENO5S uniform setting : 9.677123910420574, ; └ WENO5 (only uniform) : 9.677123910420574; ┌ Info: residuals for settings; │ architecture is GPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : 15.327517291492; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is regular; │ ; │ WENO5S stretched setting : 9.677123910420846, ; │ WENO5S uniform setting : 9.677123910420608, ; └ WENO5 (only uniform) : 9.677123910420608; ┌ Info: residuals for settings; │ architecture is CPU; │ the spacing is stretched; │ ; │ WENO5S stretched setting : 6.757165351716798, ; │ WENO5S uniform setting : 15.327517291492, ; └ WENO5 (only uniform) : ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2059
https://github.com/CliMA/Oceananigans.jl/pull/2060:0,Modifiability,Extend,Extended,0,"Extended the type WENO5 to allow the execution of the WENO scheme on stretched and uniform grids alike. . In practice:. - `WENO5()` will default to the uniform 5th order coefficients (""uniform"" setting) in all directions with a JS-WENO formulation; - `WENO5(grid = grid)` will default to uniform interpolation coefficient if the direction is uniform (`typeof(Δc) <: Number`) and will precompute the ENO coefficients for reconstruction in the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation for stretched directions and it is way too expensive! therefore, useless to keep as a possibility); - `WENO5(grid = grid, stretched_smoothness=true)` will compute coefficients for the smoothness indicators `β₀, β₁` and `β₂` to account for stretched grid; - `WENO5(zweno = true)` will implement a Z-WENO formulation for the weno weight calculation; - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; Despite the fact that all methods have the same execution speed, `stretched_smoothness` requires more memory (and slightly more computation time) and is not much impactful. As such, most of the time it is better to use just the `WENO5(grid = grid)` keyword argument as it does not decrease accuracy but decreases memory utilization (and speed up slightly). (I haven't tried all types of grids, so maybe it is good to check before performing a large simulation on a weird stretched grid); On the other hand, a Z-WENO formulation is always beneficial (also in case of a uniform mesh) with no major decrease in performance. The same can be said for the stretched `WENO5(grid=grid)` formulation in case of stretched grids. `validation/advection/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D and 2D tracer advection simulations. Below some animations showing the performance of the three methods for a ""center coarsened"" grid type (`grid_str2`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060
https://github.com/CliMA/Oceananigans.jl/pull/2060:1442,Performance,perform,performing,1442,"the ENO coefficients for reconstruction in the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation for stretched directions and it is way too expensive! therefore, useless to keep as a possibility); - `WENO5(grid = grid, stretched_smoothness=true)` will compute coefficients for the smoothness indicators `β₀, β₁` and `β₂` to account for stretched grid; - `WENO5(zweno = true)` will implement a Z-WENO formulation for the weno weight calculation; - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; Despite the fact that all methods have the same execution speed, `stretched_smoothness` requires more memory (and slightly more computation time) and is not much impactful. As such, most of the time it is better to use just the `WENO5(grid = grid)` keyword argument as it does not decrease accuracy but decreases memory utilization (and speed up slightly). (I haven't tried all types of grids, so maybe it is good to check before performing a large simulation on a weird stretched grid); On the other hand, a Z-WENO formulation is always beneficial (also in case of a uniform mesh) with no major decrease in performance. The same can be said for the stretched `WENO5(grid=grid)` formulation in case of stretched grids. `validation/advection/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D and 2D tracer advection simulations. Below some animations showing the performance of the three methods for a ""center coarsened"" grid type (`grid_str2`); `U` => `WENO5()` ; `S` => `WENO5(grid = grid)` ; `β` => `WENO5(grid = grid, stretched_smoothness=true)` ; `Z` => `WENO5(grid = grid, stretched_smoothness=true, zweno=true)` . https://user-images.githubusercontent.com/7112768/142819747-4e4083cf-d725-4f1a-bac7-4fb10800ecc7.mp4. https://user-images.githubusercontent.com/7112768/142819755-fec13fb6-684f-4f1a-b7ec-78d9768c4ff7.mp4. Closes #1704",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060
https://github.com/CliMA/Oceananigans.jl/pull/2060:1620,Performance,perform,performance,1620,"the ENO coefficients for reconstruction in the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation for stretched directions and it is way too expensive! therefore, useless to keep as a possibility); - `WENO5(grid = grid, stretched_smoothness=true)` will compute coefficients for the smoothness indicators `β₀, β₁` and `β₂` to account for stretched grid; - `WENO5(zweno = true)` will implement a Z-WENO formulation for the weno weight calculation; - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; Despite the fact that all methods have the same execution speed, `stretched_smoothness` requires more memory (and slightly more computation time) and is not much impactful. As such, most of the time it is better to use just the `WENO5(grid = grid)` keyword argument as it does not decrease accuracy but decreases memory utilization (and speed up slightly). (I haven't tried all types of grids, so maybe it is good to check before performing a large simulation on a weird stretched grid); On the other hand, a Z-WENO formulation is always beneficial (also in case of a uniform mesh) with no major decrease in performance. The same can be said for the stretched `WENO5(grid=grid)` formulation in case of stretched grids. `validation/advection/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D and 2D tracer advection simulations. Below some animations showing the performance of the three methods for a ""center coarsened"" grid type (`grid_str2`); `U` => `WENO5()` ; `S` => `WENO5(grid = grid)` ; `β` => `WENO5(grid = grid, stretched_smoothness=true)` ; `Z` => `WENO5(grid = grid, stretched_smoothness=true, zweno=true)` . https://user-images.githubusercontent.com/7112768/142819747-4e4083cf-d725-4f1a-bac7-4fb10800ecc7.mp4. https://user-images.githubusercontent.com/7112768/142819755-fec13fb6-684f-4f1a-b7ec-78d9768c4ff7.mp4. Closes #1704",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060
https://github.com/CliMA/Oceananigans.jl/pull/2060:1921,Performance,perform,performance,1921,"the ENO coefficients for reconstruction in the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation for stretched directions and it is way too expensive! therefore, useless to keep as a possibility); - `WENO5(grid = grid, stretched_smoothness=true)` will compute coefficients for the smoothness indicators `β₀, β₁` and `β₂` to account for stretched grid; - `WENO5(zweno = true)` will implement a Z-WENO formulation for the weno weight calculation; - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; Despite the fact that all methods have the same execution speed, `stretched_smoothness` requires more memory (and slightly more computation time) and is not much impactful. As such, most of the time it is better to use just the `WENO5(grid = grid)` keyword argument as it does not decrease accuracy but decreases memory utilization (and speed up slightly). (I haven't tried all types of grids, so maybe it is good to check before performing a large simulation on a weird stretched grid); On the other hand, a Z-WENO formulation is always beneficial (also in case of a uniform mesh) with no major decrease in performance. The same can be said for the stretched `WENO5(grid=grid)` formulation in case of stretched grids. `validation/advection/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D and 2D tracer advection simulations. Below some animations showing the performance of the three methods for a ""center coarsened"" grid type (`grid_str2`); `U` => `WENO5()` ; `S` => `WENO5(grid = grid)` ; `β` => `WENO5(grid = grid, stretched_smoothness=true)` ; `Z` => `WENO5(grid = grid, stretched_smoothness=true, zweno=true)` . https://user-images.githubusercontent.com/7112768/142819747-4e4083cf-d725-4f1a-bac7-4fb10800ecc7.mp4. https://user-images.githubusercontent.com/7112768/142819755-fec13fb6-684f-4f1a-b7ec-78d9768c4ff7.mp4. Closes #1704",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060
https://github.com/CliMA/Oceananigans.jl/pull/2060:1732,Security,validat,validation,1732,"the ENO coefficients for reconstruction in the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation for stretched directions and it is way too expensive! therefore, useless to keep as a possibility); - `WENO5(grid = grid, stretched_smoothness=true)` will compute coefficients for the smoothness indicators `β₀, β₁` and `β₂` to account for stretched grid; - `WENO5(zweno = true)` will implement a Z-WENO formulation for the weno weight calculation; - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; Despite the fact that all methods have the same execution speed, `stretched_smoothness` requires more memory (and slightly more computation time) and is not much impactful. As such, most of the time it is better to use just the `WENO5(grid = grid)` keyword argument as it does not decrease accuracy but decreases memory utilization (and speed up slightly). (I haven't tried all types of grids, so maybe it is good to check before performing a large simulation on a weird stretched grid); On the other hand, a Z-WENO formulation is always beneficial (also in case of a uniform mesh) with no major decrease in performance. The same can be said for the stretched `WENO5(grid=grid)` formulation in case of stretched grids. `validation/advection/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D and 2D tracer advection simulations. Below some animations showing the performance of the three methods for a ""center coarsened"" grid type (`grid_str2`); `U` => `WENO5()` ; `S` => `WENO5(grid = grid)` ; `β` => `WENO5(grid = grid, stretched_smoothness=true)` ; `Z` => `WENO5(grid = grid, stretched_smoothness=true, zweno=true)` . https://user-images.githubusercontent.com/7112768/142819747-4e4083cf-d725-4f1a-bac7-4fb10800ecc7.mp4. https://user-images.githubusercontent.com/7112768/142819755-fec13fb6-684f-4f1a-b7ec-78d9768c4ff7.mp4. Closes #1704",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060
https://github.com/CliMA/Oceananigans.jl/pull/2060:493,Testability,test,tested,493,"Extended the type WENO5 to allow the execution of the WENO scheme on stretched and uniform grids alike. . In practice:. - `WENO5()` will default to the uniform 5th order coefficients (""uniform"" setting) in all directions with a JS-WENO formulation; - `WENO5(grid = grid)` will default to uniform interpolation coefficient if the direction is uniform (`typeof(Δc) <: Number`) and will precompute the ENO coefficients for reconstruction in the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation for stretched directions and it is way too expensive! therefore, useless to keep as a possibility); - `WENO5(grid = grid, stretched_smoothness=true)` will compute coefficients for the smoothness indicators `β₀, β₁` and `β₂` to account for stretched grid; - `WENO5(zweno = true)` will implement a Z-WENO formulation for the weno weight calculation; - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; Despite the fact that all methods have the same execution speed, `stretched_smoothness` requires more memory (and slightly more computation time) and is not much impactful. As such, most of the time it is better to use just the `WENO5(grid = grid)` keyword argument as it does not decrease accuracy but decreases memory utilization (and speed up slightly). (I haven't tried all types of grids, so maybe it is good to check before performing a large simulation on a weird stretched grid); On the other hand, a Z-WENO formulation is always beneficial (also in case of a uniform mesh) with no major decrease in performance. The same can be said for the stretched `WENO5(grid=grid)` formulation in case of stretched grids. `validation/advection/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D and 2D tracer advection simulations. Below some animations showing the performance of the three methods for a ""center coarsened"" grid type (`grid_str2`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060
https://github.com/CliMA/Oceananigans.jl/pull/2060:1840,Usability,simpl,simple,1840,"the ENO coefficients for reconstruction in the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation for stretched directions and it is way too expensive! therefore, useless to keep as a possibility); - `WENO5(grid = grid, stretched_smoothness=true)` will compute coefficients for the smoothness indicators `β₀, β₁` and `β₂` to account for stretched grid; - `WENO5(zweno = true)` will implement a Z-WENO formulation for the weno weight calculation; - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; Despite the fact that all methods have the same execution speed, `stretched_smoothness` requires more memory (and slightly more computation time) and is not much impactful. As such, most of the time it is better to use just the `WENO5(grid = grid)` keyword argument as it does not decrease accuracy but decreases memory utilization (and speed up slightly). (I haven't tried all types of grids, so maybe it is good to check before performing a large simulation on a weird stretched grid); On the other hand, a Z-WENO formulation is always beneficial (also in case of a uniform mesh) with no major decrease in performance. The same can be said for the stretched `WENO5(grid=grid)` formulation in case of stretched grids. `validation/advection/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D and 2D tracer advection simulations. Below some animations showing the performance of the three methods for a ""center coarsened"" grid type (`grid_str2`); `U` => `WENO5()` ; `S` => `WENO5(grid = grid)` ; `β` => `WENO5(grid = grid, stretched_smoothness=true)` ; `Z` => `WENO5(grid = grid, stretched_smoothness=true, zweno=true)` . https://user-images.githubusercontent.com/7112768/142819747-4e4083cf-d725-4f1a-bac7-4fb10800ecc7.mp4. https://user-images.githubusercontent.com/7112768/142819755-fec13fb6-684f-4f1a-b7ec-78d9768c4ff7.mp4. Closes #1704",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060
https://github.com/CliMA/Oceananigans.jl/pull/2062:36,Testability,test,test,36,Resolves #2061 . Todo:. - [x] Add a test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2062
https://github.com/CliMA/Oceananigans.jl/pull/2063:580,Performance,perform,performance,580,"This is a (somewhat minor) convenience for parameter studies, because it means that if `u` was constructed with. ```julia; u_boundary_conditions = FieldBoundaryConditions(top = FluxBoundaryCondition(1.0)); ```. we can later write things like. ```julia; u.boundary_conditions.top = FluxBoundaryCondition(2.0); ```. to change the value of the boundary condition. Note that the _type_ of the boundary condition can't change. . Just opening this PR to see if tests pass with this change. If so it seem positive to me (I don't think `FieldBoundaryConditions` needs to be immutable for performance reasons, but please speak up if anyone thinks/knows otherwise).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2063
https://github.com/CliMA/Oceananigans.jl/pull/2063:455,Testability,test,tests,455,"This is a (somewhat minor) convenience for parameter studies, because it means that if `u` was constructed with. ```julia; u_boundary_conditions = FieldBoundaryConditions(top = FluxBoundaryCondition(1.0)); ```. we can later write things like. ```julia; u.boundary_conditions.top = FluxBoundaryCondition(2.0); ```. to change the value of the boundary condition. Note that the _type_ of the boundary condition can't change. . Just opening this PR to see if tests pass with this change. If so it seem positive to me (I don't think `FieldBoundaryConditions` needs to be immutable for performance reasons, but please speak up if anyone thinks/knows otherwise).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2063
https://github.com/CliMA/Oceananigans.jl/issues/2064:1971,Security,access,access,1971,"ze=3, z=(0, 1), topology=(Flat, Flat, Bounded)); RectilinearGrid{Float64, Flat, Flat, Bounded} on the CPU(); domain: x ∈ [1.0, 1.0], y ∈ [1.0, 1.0], z ∈ [0.0, 1.0]; topology: (Flat, Flat, Bounded); size (Nx, Ny, Nz): (1, 1, 3); halo (Hx, Hy, Hz): (0, 0, 1); grid in x: Flattened; grid in y: Flattened; grid in z: Regular, with spacing 0.3333333333333333; ```. so `grid in x:` isn't aligned with the rest of the ""data table"". Here's what we get when `z` is stretched:. ```julia; julia> grid = RectilinearGrid(size=3, z=[0.0, 0.2, 0.5, 1.0], topology=(Flat, Flat, Bounded)); RectilinearGrid{Float64, Flat, Flat, Bounded} on the CPU(); domain: x ∈ [1.0, 1.0], y ∈ [1.0, 1.0], z ∈ [0.0, 1.0]; topology: (Flat, Flat, Bounded); size (Nx, Ny, Nz): (1, 1, 3); halo (Hx, Hy, Hz): (0, 0, 1); grid in x: Flattened; grid in y: Flattened; grid in z: Stretched, with spacing min=0.2, max=0.5; ```. So here's a few ideas:. #### Include ""spacing"" information under the `domain` row?. One idea would be to show something like. ```julia; x: Flat; y: Flat; z: [0.0, 1.0], Δz: 0.33; ```. instead of `domain:` (for the regularly-spaced case), and. ```julia; x: Flat; y: Flat; z: [0.0, 1.0], extrema(Δz): (0.2, 0.5); ```. for the stretched case. We could also increase the length of the table and put the spacings on their own lines, eg. ```julia; x: Flat; y: Flat; z: [0.0, 1.0]; extrema(Δz): (0.2, 0.5); ```. We might also just hide flattened directions (we already express that the directions are `Flat` so why print this again?). #### Eliminate `topology` row because this information is already printed in the type signature. #### Compactify how we show the size + halo. I've always found the way we write `(Nx, Ny, Nz)` to negatively impact readability. . I think it's ok to just write `size`, because we want to move towards providing a function-based API rather than expecting users to access struct properties directly. Eg we could have just. ```julia; size: (1, 1, 1); halo: (0, 0, 1); ```. What do others think?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2064
https://github.com/CliMA/Oceananigans.jl/issues/2065:378,Usability,clear,clear,378,"It seems that the ivd_diagonal (main diagnonal) has not the right 1/ Δz factor:; idv_diagonal(k) should only be function of Δz_c(k) and also Δz_f(k) & Δz_f(k+1); I think by switching k_f & k_c in the definition of ""kappa_ Δz^2"" it should fix this (to check).; This problem should only shows up with vertically streched grid. For the 2 other diagonals ((upper & lower), it's not clear to me because I don't really know what this comment: ""# Shift to adjust for Tridiagonal indexing convenction"" means: Does this means that we don't pick one of the 2 simpler conventions for indexing the tri-diagonal coeff, i.e, either by line/row or by columns ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2065
https://github.com/CliMA/Oceananigans.jl/issues/2065:549,Usability,simpl,simpler,549,"It seems that the ivd_diagonal (main diagnonal) has not the right 1/ Δz factor:; idv_diagonal(k) should only be function of Δz_c(k) and also Δz_f(k) & Δz_f(k+1); I think by switching k_f & k_c in the definition of ""kappa_ Δz^2"" it should fix this (to check).; This problem should only shows up with vertically streched grid. For the 2 other diagonals ((upper & lower), it's not clear to me because I don't really know what this comment: ""# Shift to adjust for Tridiagonal indexing convenction"" means: Does this means that we don't pick one of the 2 simpler conventions for indexing the tri-diagonal coeff, i.e, either by line/row or by columns ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2065
https://github.com/CliMA/Oceananigans.jl/pull/2070:67,Deployability,install,installing,67,At the moment it was there but never used. So only wasting time by installing and precompiling when building the docs.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2070
https://github.com/CliMA/Oceananigans.jl/pull/2073:201,Energy Efficiency,Reduce,Reduced,201,Till now the distributed module was the last module loaded in Oceananigans :(; For this reason it depended on the Models module. It should definitely be the other way around!. Therefore in this PR:. - Reduced `MultiCPU` and `MultiGPU` to just one type `MultiArch`; - `MultiArch` can infer the underlying architecture by looking at its local grid which is built upon construction; - the local grid can accept rectilinear and lat-lon grids and uniform and stretched domains; - Made Models depend on Distributed and not the other way around; - deleted a bunch of files which were not required anymore. with this infrastructure in place the following steps will be; - make the `BoundaryConditions` module depend on `Distributed` (and not the other way around); - implement GPU halo passing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073
https://github.com/CliMA/Oceananigans.jl/pull/2073:98,Integrability,depend,depended,98,Till now the distributed module was the last module loaded in Oceananigans :(; For this reason it depended on the Models module. It should definitely be the other way around!. Therefore in this PR:. - Reduced `MultiCPU` and `MultiGPU` to just one type `MultiArch`; - `MultiArch` can infer the underlying architecture by looking at its local grid which is built upon construction; - the local grid can accept rectilinear and lat-lon grids and uniform and stretched domains; - Made Models depend on Distributed and not the other way around; - deleted a bunch of files which were not required anymore. with this infrastructure in place the following steps will be; - make the `BoundaryConditions` module depend on `Distributed` (and not the other way around); - implement GPU halo passing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073
https://github.com/CliMA/Oceananigans.jl/pull/2073:487,Integrability,depend,depend,487,Till now the distributed module was the last module loaded in Oceananigans :(; For this reason it depended on the Models module. It should definitely be the other way around!. Therefore in this PR:. - Reduced `MultiCPU` and `MultiGPU` to just one type `MultiArch`; - `MultiArch` can infer the underlying architecture by looking at its local grid which is built upon construction; - the local grid can accept rectilinear and lat-lon grids and uniform and stretched domains; - Made Models depend on Distributed and not the other way around; - deleted a bunch of files which were not required anymore. with this infrastructure in place the following steps will be; - make the `BoundaryConditions` module depend on `Distributed` (and not the other way around); - implement GPU halo passing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073
https://github.com/CliMA/Oceananigans.jl/pull/2073:701,Integrability,depend,depend,701,Till now the distributed module was the last module loaded in Oceananigans :(; For this reason it depended on the Models module. It should definitely be the other way around!. Therefore in this PR:. - Reduced `MultiCPU` and `MultiGPU` to just one type `MultiArch`; - `MultiArch` can infer the underlying architecture by looking at its local grid which is built upon construction; - the local grid can accept rectilinear and lat-lon grids and uniform and stretched domains; - Made Models depend on Distributed and not the other way around; - deleted a bunch of files which were not required anymore. with this infrastructure in place the following steps will be; - make the `BoundaryConditions` module depend on `Distributed` (and not the other way around); - implement GPU halo passing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073
https://github.com/CliMA/Oceananigans.jl/pull/2073:52,Performance,load,loaded,52,Till now the distributed module was the last module loaded in Oceananigans :(; For this reason it depended on the Models module. It should definitely be the other way around!. Therefore in this PR:. - Reduced `MultiCPU` and `MultiGPU` to just one type `MultiArch`; - `MultiArch` can infer the underlying architecture by looking at its local grid which is built upon construction; - the local grid can accept rectilinear and lat-lon grids and uniform and stretched domains; - Made Models depend on Distributed and not the other way around; - deleted a bunch of files which were not required anymore. with this infrastructure in place the following steps will be; - make the `BoundaryConditions` module depend on `Distributed` (and not the other way around); - implement GPU halo passing,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073
https://github.com/CliMA/Oceananigans.jl/issues/2074:292,Performance,perform,performance,292,"Seems like the Distributed Poisson solver would work only when `grid.Nx == grid.Ny` and `ranks[1] == 1`. Should we maybe implement a transpose to allow different grid sizes in Nx and Ny and 2D parallelization in case of vertically stretched domains?. On the other hand, this might hinder the performance quite a bit...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2074
https://github.com/CliMA/Oceananigans.jl/issues/2077:44,Availability,error,error,44,"I just updated my packages and now I get an error .... UndefVarError: RectilinearGrid not defined; Stacktrace:; [1] top-level scope; @ In[8]:18; [2] eval; @ .\boot.jl:360 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base .\loading.jl:1116. ....with even the simples grid-defenition, e.g. ; ```; Nz = 24 # number of points in the vertical direction; Lz = 32 # domain depth; grid = RectilinearGrid(size = (32, 32, Nz),; x = (0, 64),; y = (0, 64),; z = (-64, 0)); ```; What am I doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2077
https://github.com/CliMA/Oceananigans.jl/issues/2077:7,Deployability,update,updated,7,"I just updated my packages and now I get an error .... UndefVarError: RectilinearGrid not defined; Stacktrace:; [1] top-level scope; @ In[8]:18; [2] eval; @ .\boot.jl:360 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base .\loading.jl:1116. ....with even the simples grid-defenition, e.g. ; ```; Nz = 24 # number of points in the vertical direction; Lz = 32 # domain depth; grid = RectilinearGrid(size = (32, 32, Nz),; x = (0, 64),; y = (0, 64),; z = (-64, 0)); ```; What am I doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2077
https://github.com/CliMA/Oceananigans.jl/issues/2077:289,Performance,load,loading,289,"I just updated my packages and now I get an error .... UndefVarError: RectilinearGrid not defined; Stacktrace:; [1] top-level scope; @ In[8]:18; [2] eval; @ .\boot.jl:360 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base .\loading.jl:1116. ....with even the simples grid-defenition, e.g. ; ```; Nz = 24 # number of points in the vertical direction; Lz = 32 # domain depth; grid = RectilinearGrid(size = (32, 32, Nz),; x = (0, 64),; y = (0, 64),; z = (-64, 0)); ```; What am I doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2077
https://github.com/CliMA/Oceananigans.jl/issues/2077:324,Usability,simpl,simples,324,"I just updated my packages and now I get an error .... UndefVarError: RectilinearGrid not defined; Stacktrace:; [1] top-level scope; @ In[8]:18; [2] eval; @ .\boot.jl:360 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base .\loading.jl:1116. ....with even the simples grid-defenition, e.g. ; ```; Nz = 24 # number of points in the vertical direction; Lz = 32 # domain depth; grid = RectilinearGrid(size = (32, 32, Nz),; x = (0, 64),; y = (0, 64),; z = (-64, 0)); ```; What am I doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2077
https://github.com/CliMA/Oceananigans.jl/pull/2078:66,Integrability,depend,depend,66,"In this PR some structures are refractored such that; - all grids depend on the architecture; - the models takes only the grid as an input. To do so, the architecture is now a positional argument of the grid constructor (so it can be extended by `MultiArch`) as @glwagner suggested. The flow of the script will be something like this now:; ```; arch = ...; grid = Grid(arch, FT; kwargs...); model = NonhydrostaticModel(grid = grid, kwargs...); ```; Some comments on the `MultiArch` architecture...; - `MultiArch` has now a `child_architecture ` field specified on construction; - `MultiArch` still depends on a topology, so, a way to go about it it is to first define a topology and then ; `arch = MultiArch(CPU(), ranks=ranks, topology=topology); grid = (arch, topology=topology, kwargs...)` or to define an architecture without topology and then pass it to the grid. Take care that in this second case it is not guaranteed that `arch == grid.architecture` as the architecture in the grid is constructed from `topology(grid)`; - the grid constructed by `grid(arch::MultiArch; kwargs...)` will be a local grid. To reconstruct the global grid use `reconstruct_global_grid(grid)`. To do; - as of now a field, given `grid(arch::MultiArch; kwargs...)` as an argument, is constructed locally, which is no problem if you `set!` a field from a function but will create problems if you want to `set!` from a global array; - Explore new FFT options to allow more flexibility in the distributed NonhydrostaticModel; - allow GPU halo_passing to support `MultiArch(GPU(); kwargs...)`. Closes #2073 ; Closes #1825",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2078
https://github.com/CliMA/Oceananigans.jl/pull/2078:598,Integrability,depend,depends,598,"In this PR some structures are refractored such that; - all grids depend on the architecture; - the models takes only the grid as an input. To do so, the architecture is now a positional argument of the grid constructor (so it can be extended by `MultiArch`) as @glwagner suggested. The flow of the script will be something like this now:; ```; arch = ...; grid = Grid(arch, FT; kwargs...); model = NonhydrostaticModel(grid = grid, kwargs...); ```; Some comments on the `MultiArch` architecture...; - `MultiArch` has now a `child_architecture ` field specified on construction; - `MultiArch` still depends on a topology, so, a way to go about it it is to first define a topology and then ; `arch = MultiArch(CPU(), ranks=ranks, topology=topology); grid = (arch, topology=topology, kwargs...)` or to define an architecture without topology and then pass it to the grid. Take care that in this second case it is not guaranteed that `arch == grid.architecture` as the architecture in the grid is constructed from `topology(grid)`; - the grid constructed by `grid(arch::MultiArch; kwargs...)` will be a local grid. To reconstruct the global grid use `reconstruct_global_grid(grid)`. To do; - as of now a field, given `grid(arch::MultiArch; kwargs...)` as an argument, is constructed locally, which is no problem if you `set!` a field from a function but will create problems if you want to `set!` from a global array; - Explore new FFT options to allow more flexibility in the distributed NonhydrostaticModel; - allow GPU halo_passing to support `MultiArch(GPU(); kwargs...)`. Closes #2073 ; Closes #1825",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2078
https://github.com/CliMA/Oceananigans.jl/pull/2078:234,Modifiability,extend,extended,234,"In this PR some structures are refractored such that; - all grids depend on the architecture; - the models takes only the grid as an input. To do so, the architecture is now a positional argument of the grid constructor (so it can be extended by `MultiArch`) as @glwagner suggested. The flow of the script will be something like this now:; ```; arch = ...; grid = Grid(arch, FT; kwargs...); model = NonhydrostaticModel(grid = grid, kwargs...); ```; Some comments on the `MultiArch` architecture...; - `MultiArch` has now a `child_architecture ` field specified on construction; - `MultiArch` still depends on a topology, so, a way to go about it it is to first define a topology and then ; `arch = MultiArch(CPU(), ranks=ranks, topology=topology); grid = (arch, topology=topology, kwargs...)` or to define an architecture without topology and then pass it to the grid. Take care that in this second case it is not guaranteed that `arch == grid.architecture` as the architecture in the grid is constructed from `topology(grid)`; - the grid constructed by `grid(arch::MultiArch; kwargs...)` will be a local grid. To reconstruct the global grid use `reconstruct_global_grid(grid)`. To do; - as of now a field, given `grid(arch::MultiArch; kwargs...)` as an argument, is constructed locally, which is no problem if you `set!` a field from a function but will create problems if you want to `set!` from a global array; - Explore new FFT options to allow more flexibility in the distributed NonhydrostaticModel; - allow GPU halo_passing to support `MultiArch(GPU(); kwargs...)`. Closes #2073 ; Closes #1825",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2078
https://github.com/CliMA/Oceananigans.jl/pull/2082:100,Modifiability,enhance,enhances,100,"This PR simplifies the Docs/Appandix/Library and also adds missing modules in it. . Furthermore, it enhances formatting in several docstrings and converts some examples to doctests. Closes #2080. For example, regarding 2 vs 4 spaces in markdown formatting,. **before this PR**. <img width=""994"" alt=""Screen Shot 2021-11-25 at 4 03 01 pm"" src=""https://user-images.githubusercontent.com/7112768/143382619-b30f8312-fd64-4240-a59a-d8b3d6e50484.png"">. while **after this PR**. <img width=""861"" alt=""Screen Shot 2021-11-25 at 4 02 41 pm"" src=""https://user-images.githubusercontent.com/7112768/143382640-469f9d58-07cc-4a42-97f4-1c6c4bdeb43b.png"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2082
https://github.com/CliMA/Oceananigans.jl/pull/2082:8,Usability,simpl,simplifies,8,"This PR simplifies the Docs/Appandix/Library and also adds missing modules in it. . Furthermore, it enhances formatting in several docstrings and converts some examples to doctests. Closes #2080. For example, regarding 2 vs 4 spaces in markdown formatting,. **before this PR**. <img width=""994"" alt=""Screen Shot 2021-11-25 at 4 03 01 pm"" src=""https://user-images.githubusercontent.com/7112768/143382619-b30f8312-fd64-4240-a59a-d8b3d6e50484.png"">. while **after this PR**. <img width=""861"" alt=""Screen Shot 2021-11-25 at 4 02 41 pm"" src=""https://user-images.githubusercontent.com/7112768/143382640-469f9d58-07cc-4a42-97f4-1c6c4bdeb43b.png"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2082
https://github.com/CliMA/Oceananigans.jl/issues/2086:69,Availability,error,error,69,"Before the recent overhaul to callbacks, `NaNChecker` exited with an error. While I agree that exiting without an error is convenient at times, it would be good to have the built-in option to keep the original behavior. For example, consider a code that runs a simulation and then writes a checkpointer after it's done running. The legacy behavior was that if the simulation blew up, `run!` threw an error and the rest of the script (including the checkpointing) wouldn't happen. That would allow the user to restart the simulation from the latest checkpointer (possibly with a lower cfl threshold). Now if the simulation blows up, a checkpointer (full of NaNs) is still written, possibly overwriting the previous checkpointer. I know we can cook up a callback that manually throws an error, but this seems like a common enough case that there should be a built-in option for it. (Or maybe it's just me?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086
https://github.com/CliMA/Oceananigans.jl/issues/2086:114,Availability,error,error,114,"Before the recent overhaul to callbacks, `NaNChecker` exited with an error. While I agree that exiting without an error is convenient at times, it would be good to have the built-in option to keep the original behavior. For example, consider a code that runs a simulation and then writes a checkpointer after it's done running. The legacy behavior was that if the simulation blew up, `run!` threw an error and the rest of the script (including the checkpointing) wouldn't happen. That would allow the user to restart the simulation from the latest checkpointer (possibly with a lower cfl threshold). Now if the simulation blows up, a checkpointer (full of NaNs) is still written, possibly overwriting the previous checkpointer. I know we can cook up a callback that manually throws an error, but this seems like a common enough case that there should be a built-in option for it. (Or maybe it's just me?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086
https://github.com/CliMA/Oceananigans.jl/issues/2086:290,Availability,checkpoint,checkpointer,290,"Before the recent overhaul to callbacks, `NaNChecker` exited with an error. While I agree that exiting without an error is convenient at times, it would be good to have the built-in option to keep the original behavior. For example, consider a code that runs a simulation and then writes a checkpointer after it's done running. The legacy behavior was that if the simulation blew up, `run!` threw an error and the rest of the script (including the checkpointing) wouldn't happen. That would allow the user to restart the simulation from the latest checkpointer (possibly with a lower cfl threshold). Now if the simulation blows up, a checkpointer (full of NaNs) is still written, possibly overwriting the previous checkpointer. I know we can cook up a callback that manually throws an error, but this seems like a common enough case that there should be a built-in option for it. (Or maybe it's just me?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086
https://github.com/CliMA/Oceananigans.jl/issues/2086:400,Availability,error,error,400,"Before the recent overhaul to callbacks, `NaNChecker` exited with an error. While I agree that exiting without an error is convenient at times, it would be good to have the built-in option to keep the original behavior. For example, consider a code that runs a simulation and then writes a checkpointer after it's done running. The legacy behavior was that if the simulation blew up, `run!` threw an error and the rest of the script (including the checkpointing) wouldn't happen. That would allow the user to restart the simulation from the latest checkpointer (possibly with a lower cfl threshold). Now if the simulation blows up, a checkpointer (full of NaNs) is still written, possibly overwriting the previous checkpointer. I know we can cook up a callback that manually throws an error, but this seems like a common enough case that there should be a built-in option for it. (Or maybe it's just me?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086
https://github.com/CliMA/Oceananigans.jl/issues/2086:448,Availability,checkpoint,checkpointing,448,"Before the recent overhaul to callbacks, `NaNChecker` exited with an error. While I agree that exiting without an error is convenient at times, it would be good to have the built-in option to keep the original behavior. For example, consider a code that runs a simulation and then writes a checkpointer after it's done running. The legacy behavior was that if the simulation blew up, `run!` threw an error and the rest of the script (including the checkpointing) wouldn't happen. That would allow the user to restart the simulation from the latest checkpointer (possibly with a lower cfl threshold). Now if the simulation blows up, a checkpointer (full of NaNs) is still written, possibly overwriting the previous checkpointer. I know we can cook up a callback that manually throws an error, but this seems like a common enough case that there should be a built-in option for it. (Or maybe it's just me?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086
https://github.com/CliMA/Oceananigans.jl/issues/2086:548,Availability,checkpoint,checkpointer,548,"Before the recent overhaul to callbacks, `NaNChecker` exited with an error. While I agree that exiting without an error is convenient at times, it would be good to have the built-in option to keep the original behavior. For example, consider a code that runs a simulation and then writes a checkpointer after it's done running. The legacy behavior was that if the simulation blew up, `run!` threw an error and the rest of the script (including the checkpointing) wouldn't happen. That would allow the user to restart the simulation from the latest checkpointer (possibly with a lower cfl threshold). Now if the simulation blows up, a checkpointer (full of NaNs) is still written, possibly overwriting the previous checkpointer. I know we can cook up a callback that manually throws an error, but this seems like a common enough case that there should be a built-in option for it. (Or maybe it's just me?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086
https://github.com/CliMA/Oceananigans.jl/issues/2086:634,Availability,checkpoint,checkpointer,634,"Before the recent overhaul to callbacks, `NaNChecker` exited with an error. While I agree that exiting without an error is convenient at times, it would be good to have the built-in option to keep the original behavior. For example, consider a code that runs a simulation and then writes a checkpointer after it's done running. The legacy behavior was that if the simulation blew up, `run!` threw an error and the rest of the script (including the checkpointing) wouldn't happen. That would allow the user to restart the simulation from the latest checkpointer (possibly with a lower cfl threshold). Now if the simulation blows up, a checkpointer (full of NaNs) is still written, possibly overwriting the previous checkpointer. I know we can cook up a callback that manually throws an error, but this seems like a common enough case that there should be a built-in option for it. (Or maybe it's just me?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086
https://github.com/CliMA/Oceananigans.jl/issues/2086:714,Availability,checkpoint,checkpointer,714,"Before the recent overhaul to callbacks, `NaNChecker` exited with an error. While I agree that exiting without an error is convenient at times, it would be good to have the built-in option to keep the original behavior. For example, consider a code that runs a simulation and then writes a checkpointer after it's done running. The legacy behavior was that if the simulation blew up, `run!` threw an error and the rest of the script (including the checkpointing) wouldn't happen. That would allow the user to restart the simulation from the latest checkpointer (possibly with a lower cfl threshold). Now if the simulation blows up, a checkpointer (full of NaNs) is still written, possibly overwriting the previous checkpointer. I know we can cook up a callback that manually throws an error, but this seems like a common enough case that there should be a built-in option for it. (Or maybe it's just me?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086
https://github.com/CliMA/Oceananigans.jl/issues/2086:785,Availability,error,error,785,"Before the recent overhaul to callbacks, `NaNChecker` exited with an error. While I agree that exiting without an error is convenient at times, it would be good to have the built-in option to keep the original behavior. For example, consider a code that runs a simulation and then writes a checkpointer after it's done running. The legacy behavior was that if the simulation blew up, `run!` threw an error and the rest of the script (including the checkpointing) wouldn't happen. That would allow the user to restart the simulation from the latest checkpointer (possibly with a lower cfl threshold). Now if the simulation blows up, a checkpointer (full of NaNs) is still written, possibly overwriting the previous checkpointer. I know we can cook up a callback that manually throws an error, but this seems like a common enough case that there should be a built-in option for it. (Or maybe it's just me?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2086
https://github.com/CliMA/Oceananigans.jl/pull/2087:22,Availability,error,erroring,22,"This PR adds a field `erroring` to the `NaNChecker`, and also makes the `NaNChecker` mutable. This means that the default `NaNChecker` can be converted to an erroring `NaNChecker` by writing. ```julia; simulation.callbacks[:nan_checker].func.erroring = true; ```. or. ```julia; erroring_NaNChecker!(simulation); ```. TODO. - [x] Test. Resolves #2086 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2087
https://github.com/CliMA/Oceananigans.jl/pull/2087:158,Availability,error,erroring,158,"This PR adds a field `erroring` to the `NaNChecker`, and also makes the `NaNChecker` mutable. This means that the default `NaNChecker` can be converted to an erroring `NaNChecker` by writing. ```julia; simulation.callbacks[:nan_checker].func.erroring = true; ```. or. ```julia; erroring_NaNChecker!(simulation); ```. TODO. - [x] Test. Resolves #2086 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2087
https://github.com/CliMA/Oceananigans.jl/pull/2087:242,Availability,error,erroring,242,"This PR adds a field `erroring` to the `NaNChecker`, and also makes the `NaNChecker` mutable. This means that the default `NaNChecker` can be converted to an erroring `NaNChecker` by writing. ```julia; simulation.callbacks[:nan_checker].func.erroring = true; ```. or. ```julia; erroring_NaNChecker!(simulation); ```. TODO. - [x] Test. Resolves #2086 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2087
https://github.com/CliMA/Oceananigans.jl/pull/2087:329,Testability,Test,Test,329,"This PR adds a field `erroring` to the `NaNChecker`, and also makes the `NaNChecker` mutable. This means that the default `NaNChecker` can be converted to an erroring `NaNChecker` by writing. ```julia; simulation.callbacks[:nan_checker].func.erroring = true; ```. or. ```julia; erroring_NaNChecker!(simulation); ```. TODO. - [x] Test. Resolves #2086 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2087
https://github.com/CliMA/Oceananigans.jl/pull/2088:19,Energy Efficiency,schedul,schedule,19,"This PR adds a new schedule called `AllSchedule` that allows scheduling based on multiple criterion. It also adds a `hasnan(model::AbstractModel)` that checks for a NaN in a model's first field. Together this allows schedules that avoid actuating if NaNs are detected via. ```julia; schedule = AllSchedule(TimeInterval(100), !hasnan); ```. for example. Note that `all` is short-circuiting, so order matters. Putting `!hasnan` second means that `hasnan` will not be called unless `TimeInterval(100)(model)` returns `true` first (this matters for avoiding `hasnan` calls on every time-step). TODO:. - [x] better name than `MultiSchedule` perhaps `AllSchedules`?; - [x] Also have `AnySchedule` that actuates if _any_ schedules actuate?; - [x] Tests. This feature was discussed on #2086 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2088
https://github.com/CliMA/Oceananigans.jl/pull/2088:61,Energy Efficiency,schedul,scheduling,61,"This PR adds a new schedule called `AllSchedule` that allows scheduling based on multiple criterion. It also adds a `hasnan(model::AbstractModel)` that checks for a NaN in a model's first field. Together this allows schedules that avoid actuating if NaNs are detected via. ```julia; schedule = AllSchedule(TimeInterval(100), !hasnan); ```. for example. Note that `all` is short-circuiting, so order matters. Putting `!hasnan` second means that `hasnan` will not be called unless `TimeInterval(100)(model)` returns `true` first (this matters for avoiding `hasnan` calls on every time-step). TODO:. - [x] better name than `MultiSchedule` perhaps `AllSchedules`?; - [x] Also have `AnySchedule` that actuates if _any_ schedules actuate?; - [x] Tests. This feature was discussed on #2086 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2088
https://github.com/CliMA/Oceananigans.jl/pull/2088:216,Energy Efficiency,schedul,schedules,216,"This PR adds a new schedule called `AllSchedule` that allows scheduling based on multiple criterion. It also adds a `hasnan(model::AbstractModel)` that checks for a NaN in a model's first field. Together this allows schedules that avoid actuating if NaNs are detected via. ```julia; schedule = AllSchedule(TimeInterval(100), !hasnan); ```. for example. Note that `all` is short-circuiting, so order matters. Putting `!hasnan` second means that `hasnan` will not be called unless `TimeInterval(100)(model)` returns `true` first (this matters for avoiding `hasnan` calls on every time-step). TODO:. - [x] better name than `MultiSchedule` perhaps `AllSchedules`?; - [x] Also have `AnySchedule` that actuates if _any_ schedules actuate?; - [x] Tests. This feature was discussed on #2086 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2088
https://github.com/CliMA/Oceananigans.jl/pull/2088:283,Energy Efficiency,schedul,schedule,283,"This PR adds a new schedule called `AllSchedule` that allows scheduling based on multiple criterion. It also adds a `hasnan(model::AbstractModel)` that checks for a NaN in a model's first field. Together this allows schedules that avoid actuating if NaNs are detected via. ```julia; schedule = AllSchedule(TimeInterval(100), !hasnan); ```. for example. Note that `all` is short-circuiting, so order matters. Putting `!hasnan` second means that `hasnan` will not be called unless `TimeInterval(100)(model)` returns `true` first (this matters for avoiding `hasnan` calls on every time-step). TODO:. - [x] better name than `MultiSchedule` perhaps `AllSchedules`?; - [x] Also have `AnySchedule` that actuates if _any_ schedules actuate?; - [x] Tests. This feature was discussed on #2086 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2088
https://github.com/CliMA/Oceananigans.jl/pull/2088:714,Energy Efficiency,schedul,schedules,714,"This PR adds a new schedule called `AllSchedule` that allows scheduling based on multiple criterion. It also adds a `hasnan(model::AbstractModel)` that checks for a NaN in a model's first field. Together this allows schedules that avoid actuating if NaNs are detected via. ```julia; schedule = AllSchedule(TimeInterval(100), !hasnan); ```. for example. Note that `all` is short-circuiting, so order matters. Putting `!hasnan` second means that `hasnan` will not be called unless `TimeInterval(100)(model)` returns `true` first (this matters for avoiding `hasnan` calls on every time-step). TODO:. - [x] better name than `MultiSchedule` perhaps `AllSchedules`?; - [x] Also have `AnySchedule` that actuates if _any_ schedules actuate?; - [x] Tests. This feature was discussed on #2086 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2088
https://github.com/CliMA/Oceananigans.jl/pull/2088:231,Safety,avoid,avoid,231,"This PR adds a new schedule called `AllSchedule` that allows scheduling based on multiple criterion. It also adds a `hasnan(model::AbstractModel)` that checks for a NaN in a model's first field. Together this allows schedules that avoid actuating if NaNs are detected via. ```julia; schedule = AllSchedule(TimeInterval(100), !hasnan); ```. for example. Note that `all` is short-circuiting, so order matters. Putting `!hasnan` second means that `hasnan` will not be called unless `TimeInterval(100)(model)` returns `true` first (this matters for avoiding `hasnan` calls on every time-step). TODO:. - [x] better name than `MultiSchedule` perhaps `AllSchedules`?; - [x] Also have `AnySchedule` that actuates if _any_ schedules actuate?; - [x] Tests. This feature was discussed on #2086 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2088
https://github.com/CliMA/Oceananigans.jl/pull/2088:259,Safety,detect,detected,259,"This PR adds a new schedule called `AllSchedule` that allows scheduling based on multiple criterion. It also adds a `hasnan(model::AbstractModel)` that checks for a NaN in a model's first field. Together this allows schedules that avoid actuating if NaNs are detected via. ```julia; schedule = AllSchedule(TimeInterval(100), !hasnan); ```. for example. Note that `all` is short-circuiting, so order matters. Putting `!hasnan` second means that `hasnan` will not be called unless `TimeInterval(100)(model)` returns `true` first (this matters for avoiding `hasnan` calls on every time-step). TODO:. - [x] better name than `MultiSchedule` perhaps `AllSchedules`?; - [x] Also have `AnySchedule` that actuates if _any_ schedules actuate?; - [x] Tests. This feature was discussed on #2086 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2088
https://github.com/CliMA/Oceananigans.jl/pull/2088:545,Safety,avoid,avoiding,545,"This PR adds a new schedule called `AllSchedule` that allows scheduling based on multiple criterion. It also adds a `hasnan(model::AbstractModel)` that checks for a NaN in a model's first field. Together this allows schedules that avoid actuating if NaNs are detected via. ```julia; schedule = AllSchedule(TimeInterval(100), !hasnan); ```. for example. Note that `all` is short-circuiting, so order matters. Putting `!hasnan` second means that `hasnan` will not be called unless `TimeInterval(100)(model)` returns `true` first (this matters for avoiding `hasnan` calls on every time-step). TODO:. - [x] better name than `MultiSchedule` perhaps `AllSchedules`?; - [x] Also have `AnySchedule` that actuates if _any_ schedules actuate?; - [x] Tests. This feature was discussed on #2086 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2088
https://github.com/CliMA/Oceananigans.jl/pull/2088:740,Testability,Test,Tests,740,"This PR adds a new schedule called `AllSchedule` that allows scheduling based on multiple criterion. It also adds a `hasnan(model::AbstractModel)` that checks for a NaN in a model's first field. Together this allows schedules that avoid actuating if NaNs are detected via. ```julia; schedule = AllSchedule(TimeInterval(100), !hasnan); ```. for example. Note that `all` is short-circuiting, so order matters. Putting `!hasnan` second means that `hasnan` will not be called unless `TimeInterval(100)(model)` returns `true` first (this matters for avoiding `hasnan` calls on every time-step). TODO:. - [x] better name than `MultiSchedule` perhaps `AllSchedules`?; - [x] Also have `AnySchedule` that actuates if _any_ schedules actuate?; - [x] Tests. This feature was discussed on #2086 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2088
https://github.com/CliMA/Oceananigans.jl/pull/2090:36,Deployability,pipeline,pipelines,36,"This PR makes tests and validations pipelines to run using Julia v1.7.; Furthermore, it updates `Manifest.toml` files from v1.0 to v2.0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2090
https://github.com/CliMA/Oceananigans.jl/pull/2090:88,Deployability,update,updates,88,"This PR makes tests and validations pipelines to run using Julia v1.7.; Furthermore, it updates `Manifest.toml` files from v1.0 to v2.0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2090
https://github.com/CliMA/Oceananigans.jl/pull/2090:24,Security,validat,validations,24,"This PR makes tests and validations pipelines to run using Julia v1.7.; Furthermore, it updates `Manifest.toml` files from v1.0 to v2.0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2090
https://github.com/CliMA/Oceananigans.jl/pull/2090:14,Testability,test,tests,14,"This PR makes tests and validations pipelines to run using Julia v1.7.; Furthermore, it updates `Manifest.toml` files from v1.0 to v2.0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2090
https://github.com/CliMA/Oceananigans.jl/issues/2091:124,Testability,test,test,124,I noticed this deprecated warning... https://github.com/CliMA/Oceananigans.jl/blob/d9e2c31e20e78f1b1dcb4d9bd01a959c51bcb60e/test/test_boundary_conditions_integration.jl#L139-L140,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2091
https://github.com/CliMA/Oceananigans.jl/pull/2099:0,Modifiability,Extend,Extended,0,"Extended the print function so that ; string(::AdvectionScheme) = ""AdvectionScheme"". closes #2098",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099
https://github.com/CliMA/Oceananigans.jl/pull/2100:25,Energy Efficiency,schedul,schedule,25,"This PR implements a new schedule called `ConsecutiveIterations`. This schedule is constructed with a ""parent schedule"" as an argument and an optional second argument specifying the ""number"" of consecutive iterations to actuate for:. ```julia; schedule = ConsecutiveIterations(TimeInterval(100)). schedule = ConsecutiveIterations(IterationInterval(4)). schedule = ConsecutiveIterations(IterationInterval(20), 3); ```. The schedule will then actuated (ie, triggering output writing or callback execution) at _both_ the moment specified by the parent schedule, and for `N` iterations consecutive to that one, where `N=1` by default. This PR also adds a property `offset` to `IterationInterval`. Together, this allows one to compute time-derivatives (either forward derivative, or, if using `IterationInterval(N, offset=-1)`, a centered difference). cc @whitleyv . TODO. - [ ] Test. This could also maybe be called `SubsequentIterations`... ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100
https://github.com/CliMA/Oceananigans.jl/pull/2100:71,Energy Efficiency,schedul,schedule,71,"This PR implements a new schedule called `ConsecutiveIterations`. This schedule is constructed with a ""parent schedule"" as an argument and an optional second argument specifying the ""number"" of consecutive iterations to actuate for:. ```julia; schedule = ConsecutiveIterations(TimeInterval(100)). schedule = ConsecutiveIterations(IterationInterval(4)). schedule = ConsecutiveIterations(IterationInterval(20), 3); ```. The schedule will then actuated (ie, triggering output writing or callback execution) at _both_ the moment specified by the parent schedule, and for `N` iterations consecutive to that one, where `N=1` by default. This PR also adds a property `offset` to `IterationInterval`. Together, this allows one to compute time-derivatives (either forward derivative, or, if using `IterationInterval(N, offset=-1)`, a centered difference). cc @whitleyv . TODO. - [ ] Test. This could also maybe be called `SubsequentIterations`... ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100
https://github.com/CliMA/Oceananigans.jl/pull/2100:110,Energy Efficiency,schedul,schedule,110,"This PR implements a new schedule called `ConsecutiveIterations`. This schedule is constructed with a ""parent schedule"" as an argument and an optional second argument specifying the ""number"" of consecutive iterations to actuate for:. ```julia; schedule = ConsecutiveIterations(TimeInterval(100)). schedule = ConsecutiveIterations(IterationInterval(4)). schedule = ConsecutiveIterations(IterationInterval(20), 3); ```. The schedule will then actuated (ie, triggering output writing or callback execution) at _both_ the moment specified by the parent schedule, and for `N` iterations consecutive to that one, where `N=1` by default. This PR also adds a property `offset` to `IterationInterval`. Together, this allows one to compute time-derivatives (either forward derivative, or, if using `IterationInterval(N, offset=-1)`, a centered difference). cc @whitleyv . TODO. - [ ] Test. This could also maybe be called `SubsequentIterations`... ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100
https://github.com/CliMA/Oceananigans.jl/pull/2100:244,Energy Efficiency,schedul,schedule,244,"This PR implements a new schedule called `ConsecutiveIterations`. This schedule is constructed with a ""parent schedule"" as an argument and an optional second argument specifying the ""number"" of consecutive iterations to actuate for:. ```julia; schedule = ConsecutiveIterations(TimeInterval(100)). schedule = ConsecutiveIterations(IterationInterval(4)). schedule = ConsecutiveIterations(IterationInterval(20), 3); ```. The schedule will then actuated (ie, triggering output writing or callback execution) at _both_ the moment specified by the parent schedule, and for `N` iterations consecutive to that one, where `N=1` by default. This PR also adds a property `offset` to `IterationInterval`. Together, this allows one to compute time-derivatives (either forward derivative, or, if using `IterationInterval(N, offset=-1)`, a centered difference). cc @whitleyv . TODO. - [ ] Test. This could also maybe be called `SubsequentIterations`... ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100
https://github.com/CliMA/Oceananigans.jl/pull/2100:297,Energy Efficiency,schedul,schedule,297,"This PR implements a new schedule called `ConsecutiveIterations`. This schedule is constructed with a ""parent schedule"" as an argument and an optional second argument specifying the ""number"" of consecutive iterations to actuate for:. ```julia; schedule = ConsecutiveIterations(TimeInterval(100)). schedule = ConsecutiveIterations(IterationInterval(4)). schedule = ConsecutiveIterations(IterationInterval(20), 3); ```. The schedule will then actuated (ie, triggering output writing or callback execution) at _both_ the moment specified by the parent schedule, and for `N` iterations consecutive to that one, where `N=1` by default. This PR also adds a property `offset` to `IterationInterval`. Together, this allows one to compute time-derivatives (either forward derivative, or, if using `IterationInterval(N, offset=-1)`, a centered difference). cc @whitleyv . TODO. - [ ] Test. This could also maybe be called `SubsequentIterations`... ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100
https://github.com/CliMA/Oceananigans.jl/pull/2100:353,Energy Efficiency,schedul,schedule,353,"This PR implements a new schedule called `ConsecutiveIterations`. This schedule is constructed with a ""parent schedule"" as an argument and an optional second argument specifying the ""number"" of consecutive iterations to actuate for:. ```julia; schedule = ConsecutiveIterations(TimeInterval(100)). schedule = ConsecutiveIterations(IterationInterval(4)). schedule = ConsecutiveIterations(IterationInterval(20), 3); ```. The schedule will then actuated (ie, triggering output writing or callback execution) at _both_ the moment specified by the parent schedule, and for `N` iterations consecutive to that one, where `N=1` by default. This PR also adds a property `offset` to `IterationInterval`. Together, this allows one to compute time-derivatives (either forward derivative, or, if using `IterationInterval(N, offset=-1)`, a centered difference). cc @whitleyv . TODO. - [ ] Test. This could also maybe be called `SubsequentIterations`... ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100
https://github.com/CliMA/Oceananigans.jl/pull/2100:422,Energy Efficiency,schedul,schedule,422,"This PR implements a new schedule called `ConsecutiveIterations`. This schedule is constructed with a ""parent schedule"" as an argument and an optional second argument specifying the ""number"" of consecutive iterations to actuate for:. ```julia; schedule = ConsecutiveIterations(TimeInterval(100)). schedule = ConsecutiveIterations(IterationInterval(4)). schedule = ConsecutiveIterations(IterationInterval(20), 3); ```. The schedule will then actuated (ie, triggering output writing or callback execution) at _both_ the moment specified by the parent schedule, and for `N` iterations consecutive to that one, where `N=1` by default. This PR also adds a property `offset` to `IterationInterval`. Together, this allows one to compute time-derivatives (either forward derivative, or, if using `IterationInterval(N, offset=-1)`, a centered difference). cc @whitleyv . TODO. - [ ] Test. This could also maybe be called `SubsequentIterations`... ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100
https://github.com/CliMA/Oceananigans.jl/pull/2100:549,Energy Efficiency,schedul,schedule,549,"This PR implements a new schedule called `ConsecutiveIterations`. This schedule is constructed with a ""parent schedule"" as an argument and an optional second argument specifying the ""number"" of consecutive iterations to actuate for:. ```julia; schedule = ConsecutiveIterations(TimeInterval(100)). schedule = ConsecutiveIterations(IterationInterval(4)). schedule = ConsecutiveIterations(IterationInterval(20), 3); ```. The schedule will then actuated (ie, triggering output writing or callback execution) at _both_ the moment specified by the parent schedule, and for `N` iterations consecutive to that one, where `N=1` by default. This PR also adds a property `offset` to `IterationInterval`. Together, this allows one to compute time-derivatives (either forward derivative, or, if using `IterationInterval(N, offset=-1)`, a centered difference). cc @whitleyv . TODO. - [ ] Test. This could also maybe be called `SubsequentIterations`... ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100
https://github.com/CliMA/Oceananigans.jl/pull/2100:874,Testability,Test,Test,874,"This PR implements a new schedule called `ConsecutiveIterations`. This schedule is constructed with a ""parent schedule"" as an argument and an optional second argument specifying the ""number"" of consecutive iterations to actuate for:. ```julia; schedule = ConsecutiveIterations(TimeInterval(100)). schedule = ConsecutiveIterations(IterationInterval(4)). schedule = ConsecutiveIterations(IterationInterval(20), 3); ```. The schedule will then actuated (ie, triggering output writing or callback execution) at _both_ the moment specified by the parent schedule, and for `N` iterations consecutive to that one, where `N=1` by default. This PR also adds a property `offset` to `IterationInterval`. Together, this allows one to compute time-derivatives (either forward derivative, or, if using `IterationInterval(N, offset=-1)`, a centered difference). cc @whitleyv . TODO. - [ ] Test. This could also maybe be called `SubsequentIterations`... ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2100
https://github.com/CliMA/Oceananigans.jl/issues/2101:1477,Availability,error,error,1477,"ently, this recursion starts with. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L45-L47. which calls itself and terminates at the end points. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L33-L34. and. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L36-L38. However, this pattern does _not_ compile on the GPU (which is why we hard code the 2- and 3-tuple cases to support these on the GPU). The reason is a compiler heuristic that aborts inlining when self-recursion is encountered (eg a function is called within itself). To avoid this, I think we can use an ""outer-inner"" form whereby the outer function. ```julia; ∇_dot_qᶜ(i, j, k, grid::AbstractGrid, closures::Tuple, c, iᶜ, clock, Ks, args...); ```. unpacks one element, calls itself,. ```julia; ∇_dot_qᶜ(i, j, k, grid, closures[1], c, iᶜ, clock, Ks[1], args...); ```. and handles the rest of the elements with an inner function. ```julia; inner_∇_dot_qᶜ(i, j, k, grid, closures[2:end], c, iᶜ, clock, Ks[2:end], args...); ```. Or, something like that... getting this right might require a little trial and error. This is similar to [a pattern implemented in `ClimaCore.jl`](https://github.com/CliMA/ClimaCore.jl/blob/f804a86de772437e93c82d2c3dfc56920a94d433/src/interface.jl#L31):. ```julia; @inline column(x, inds...) = x; @inline column(tup::Tuple, inds...) = column_args(tup, inds...). # Recursively call column() on broadcast arguments in a way that is statically reducible by the optimizer; # see Base.Broadcast.preprocess_args; @inline column_args(args::Tuple, inds...) =; (column(args[1], inds...), column_args(Base.tail(args), inds...)...); @inline column_args(args::Tuple{Any}, inds...) = (column(args[1], inds...),); @inline column_args(args::Tuple{}, inds...) = (); ```. cc @jakebolewski",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2101
https://github.com/CliMA/Oceananigans.jl/issues/2101:1633,Integrability,interface,interface,1633,"ently, this recursion starts with. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L45-L47. which calls itself and terminates at the end points. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L33-L34. and. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L36-L38. However, this pattern does _not_ compile on the GPU (which is why we hard code the 2- and 3-tuple cases to support these on the GPU). The reason is a compiler heuristic that aborts inlining when self-recursion is encountered (eg a function is called within itself). To avoid this, I think we can use an ""outer-inner"" form whereby the outer function. ```julia; ∇_dot_qᶜ(i, j, k, grid::AbstractGrid, closures::Tuple, c, iᶜ, clock, Ks, args...); ```. unpacks one element, calls itself,. ```julia; ∇_dot_qᶜ(i, j, k, grid, closures[1], c, iᶜ, clock, Ks[1], args...); ```. and handles the rest of the elements with an inner function. ```julia; inner_∇_dot_qᶜ(i, j, k, grid, closures[2:end], c, iᶜ, clock, Ks[2:end], args...); ```. Or, something like that... getting this right might require a little trial and error. This is similar to [a pattern implemented in `ClimaCore.jl`](https://github.com/CliMA/ClimaCore.jl/blob/f804a86de772437e93c82d2c3dfc56920a94d433/src/interface.jl#L31):. ```julia; @inline column(x, inds...) = x; @inline column(tup::Tuple, inds...) = column_args(tup, inds...). # Recursively call column() on broadcast arguments in a way that is statically reducible by the optimizer; # see Base.Broadcast.preprocess_args; @inline column_args(args::Tuple, inds...) =; (column(args[1], inds...), column_args(Base.tail(args), inds...)...); @inline column_args(args::Tuple{Any}, inds...) = (column(args[1], inds...),); @inline column_args(args::Tuple{}, inds...) = (); ```. cc @jakebolewski",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2101
https://github.com/CliMA/Oceananigans.jl/issues/2101:1856,Performance,optimiz,optimizer,1856,"ently, this recursion starts with. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L45-L47. which calls itself and terminates at the end points. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L33-L34. and. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L36-L38. However, this pattern does _not_ compile on the GPU (which is why we hard code the 2- and 3-tuple cases to support these on the GPU). The reason is a compiler heuristic that aborts inlining when self-recursion is encountered (eg a function is called within itself). To avoid this, I think we can use an ""outer-inner"" form whereby the outer function. ```julia; ∇_dot_qᶜ(i, j, k, grid::AbstractGrid, closures::Tuple, c, iᶜ, clock, Ks, args...); ```. unpacks one element, calls itself,. ```julia; ∇_dot_qᶜ(i, j, k, grid, closures[1], c, iᶜ, clock, Ks[1], args...); ```. and handles the rest of the elements with an inner function. ```julia; inner_∇_dot_qᶜ(i, j, k, grid, closures[2:end], c, iᶜ, clock, Ks[2:end], args...); ```. Or, something like that... getting this right might require a little trial and error. This is similar to [a pattern implemented in `ClimaCore.jl`](https://github.com/CliMA/ClimaCore.jl/blob/f804a86de772437e93c82d2c3dfc56920a94d433/src/interface.jl#L31):. ```julia; @inline column(x, inds...) = x; @inline column(tup::Tuple, inds...) = column_args(tup, inds...). # Recursively call column() on broadcast arguments in a way that is statically reducible by the optimizer; # see Base.Broadcast.preprocess_args; @inline column_args(args::Tuple, inds...) =; (column(args[1], inds...), column_args(Base.tail(args), inds...)...); @inline column_args(args::Tuple{Any}, inds...) = (column(args[1], inds...),); @inline column_args(args::Tuple{}, inds...) = (); ```. cc @jakebolewski",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2101
https://github.com/CliMA/Oceananigans.jl/issues/2101:847,Safety,abort,aborts,847,"When using a tuple of closures, evaluation of the diffusive flux divergence for an arbitrary number of closures requires recursing into the diffusive flux operator. Currently, this recursion starts with. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L45-L47. which calls itself and terminates at the end points. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L33-L34. and. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L36-L38. However, this pattern does _not_ compile on the GPU (which is why we hard code the 2- and 3-tuple cases to support these on the GPU). The reason is a compiler heuristic that aborts inlining when self-recursion is encountered (eg a function is called within itself). To avoid this, I think we can use an ""outer-inner"" form whereby the outer function. ```julia; ∇_dot_qᶜ(i, j, k, grid::AbstractGrid, closures::Tuple, c, iᶜ, clock, Ks, args...); ```. unpacks one element, calls itself,. ```julia; ∇_dot_qᶜ(i, j, k, grid, closures[1], c, iᶜ, clock, Ks[1], args...); ```. and handles the rest of the elements with an inner function. ```julia; inner_∇_dot_qᶜ(i, j, k, grid, closures[2:end], c, iᶜ, clock, Ks[2:end], args...); ```. Or, something like that... getting this right might require a little trial and error. This is similar to [a pattern implemented in `ClimaCore.jl`](https://github.com/CliMA/ClimaCore.jl/blob/f804a86de772437e93c82d2c3dfc56920a94d433/src/interface.jl#L31):. ```julia; @inline column(x, inds...) = x; @inline column(tup::Tuple, inds...) = column_args(tup, inds...). # Recursively call column() on broadcast arguments in a way that is statically reducible by the optimizer; # see Base.Broadcast.preprocess_args; @inline column_args(args::Tuple, inds...) =; (column(args[1], inds...), column_args(Base.tail(ar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2101
https://github.com/CliMA/Oceananigans.jl/issues/2101:942,Safety,avoid,avoid,942,"When using a tuple of closures, evaluation of the diffusive flux divergence for an arbitrary number of closures requires recursing into the diffusive flux operator. Currently, this recursion starts with. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L45-L47. which calls itself and terminates at the end points. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L33-L34. and. https://github.com/CliMA/Oceananigans.jl/blob/3c86d8f37a3bf5ff050e233f7b946685f9057c26/src/TurbulenceClosures/closure_tuples.jl#L36-L38. However, this pattern does _not_ compile on the GPU (which is why we hard code the 2- and 3-tuple cases to support these on the GPU). The reason is a compiler heuristic that aborts inlining when self-recursion is encountered (eg a function is called within itself). To avoid this, I think we can use an ""outer-inner"" form whereby the outer function. ```julia; ∇_dot_qᶜ(i, j, k, grid::AbstractGrid, closures::Tuple, c, iᶜ, clock, Ks, args...); ```. unpacks one element, calls itself,. ```julia; ∇_dot_qᶜ(i, j, k, grid, closures[1], c, iᶜ, clock, Ks[1], args...); ```. and handles the rest of the elements with an inner function. ```julia; inner_∇_dot_qᶜ(i, j, k, grid, closures[2:end], c, iᶜ, clock, Ks[2:end], args...); ```. Or, something like that... getting this right might require a little trial and error. This is similar to [a pattern implemented in `ClimaCore.jl`](https://github.com/CliMA/ClimaCore.jl/blob/f804a86de772437e93c82d2c3dfc56920a94d433/src/interface.jl#L31):. ```julia; @inline column(x, inds...) = x; @inline column(tup::Tuple, inds...) = column_args(tup, inds...). # Recursively call column() on broadcast arguments in a way that is statically reducible by the optimizer; # see Base.Broadcast.preprocess_args; @inline column_args(args::Tuple, inds...) =; (column(args[1], inds...), column_args(Base.tail(ar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2101
https://github.com/CliMA/Oceananigans.jl/pull/2105:2186,Availability,toler,tolerance,2186,"Delta t^2 ) \eta_{ijk} = b_{ijk}""> . the coefficients are specified as 3D arrays (also fields should be good). To solve for a `Center, Center, Center` value, `Ax` should be on `Face, Center, Center`, `Ay` should be on `Center, Face, Center`, `Az` on `Center, Center, Face` and `C` and `D` on `Center, Center, Center`. . `b` (the rhs) is specified as a 1D `Array` (or `CuArray` on GPUs). Example: coefficients to solve a Poisson equation of the form <img src=""https://render.githubusercontent.com/render/math?math=\nabla^2 \eta = b""> in a finite volume framework <img src=""https://render.githubusercontent.com/render/math?math=\sum_k A_k \nabla \eta = b \cdot V""> are shown in `test/test_matrix_poisson_solver.jl`. to construct the type, a part from the coefficients it is possible to specify; - the type of `iterative_solver` desired (`cg` is the default) ; - `reduced_dim::Tuple(Bool, Bool, Bool)` to have a lower-dimensional solve (a reduced dimension will mean that the matrix will be filled with the coefficients of index 1 in that direction, as an example, if `reduced_dim=(false, true, false)`, the matrix will be filled with `Ax[i, 1, k], Az[i, 1, k], C[i, 1, k]` and `D[i, 1, k]`) ; - `settings` which include `maximum_iterations`, `tolerance`, `precondition` (`false` or `true`). The preconditioner employed on the CPU is the (always perfect) ILU factorization (from the IncompleteLU.jl package); On the GPU, using a direct preconditioning technique is always detrimental because it requires a solution to the `P \ r` problem which is inherently non-parallelizable (in case of a LU would be a forward followed by a backward substitution).; For this reason a sparse approximate inverse method is implemented which iteratively calculates `M ≈ A⁻¹` based on the minimization of the Frobenius norm of `AM - I`. This leads to very good results as in this case the preconditioner is applied with just a matrix-vector multiplication `M * r`. Unfortunately, the initialization of this preconditioner ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105
https://github.com/CliMA/Oceananigans.jl/pull/2105:384,Energy Efficiency,efficient,efficient,384,"This PR introduces a new ""Matrix based"" implicit solver `Oceananigans/Solvers/matrix_iterative_solver` that uses the package IterativeSolvers.jl to solve a linear system of equation based on a sparse matrix formulation. This has a couple of advantages in terms of performance; - there is no need to `fill_halo_regions!` on the residuals while iterating; - it is possible to implement efficient preconditioning techniques. the `MatrixIterativeSolver` accepts a tuple of coefficients `Ax, Ay, Az, C, D` as inputs and creates the associated matrix to solve the following ; <img src=""https://render.githubusercontent.com/render/math?math=Ax_{i%2B 1jk} \eta_{i%2B 1jk} %2B Ax_{ijk} \eta_{i-1jk} %2B Ay_{ij%2B 1k} \eta_{ij%2B 1k} %2B Ay_{ijk} \eta_{ij-1k} %2B Az_{ijk%2B 1} \eta_{ijk%2B 1} %2B Az_{ijk} \eta_{ijk-1} - 2 (Ax_{i%2B 1jk} %2B Ax_{ijk} %2B Ay_{ij%2B 1k} %2B Ay_{ijk} %2B Az_{ijk%2B 1} %2B Az_{ijk} ) \eta_{ijk} %2B ( C_{ijk} %2B D_{ijk} /\Delta t^2 ) \eta_{ijk} = b_{ijk}""> . the coefficients are specified as 3D arrays (also fields should be good). To solve for a `Center, Center, Center` value, `Ax` should be on `Face, Center, Center`, `Ay` should be on `Center, Face, Center`, `Az` on `Center, Center, Face` and `C` and `D` on `Center, Center, Center`. . `b` (the rhs) is specified as a 1D `Array` (or `CuArray` on GPUs). Example: coefficients to solve a Poisson equation of the form <img src=""https://render.githubusercontent.com/render/math?math=\nabla^2 \eta = b""> in a finite volume framework <img src=""https://render.githubusercontent.com/render/math?math=\sum_k A_k \nabla \eta = b \cdot V""> are shown in `test/test_matrix_poisson_solver.jl`. to construct the type, a part from the coefficients it is possible to specify; - the type of `iterative_solver` desired (`cg` is the default) ; - `reduced_dim::Tuple(Bool, Bool, Bool)` to have a lower-dimensional solve (a reduced dimension will mean that the matrix will be filled with the coefficients of index 1 in that direction, as an exa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105
https://github.com/CliMA/Oceananigans.jl/pull/2105:1881,Energy Efficiency,reduce,reduced,1881,"Delta t^2 ) \eta_{ijk} = b_{ijk}""> . the coefficients are specified as 3D arrays (also fields should be good). To solve for a `Center, Center, Center` value, `Ax` should be on `Face, Center, Center`, `Ay` should be on `Center, Face, Center`, `Az` on `Center, Center, Face` and `C` and `D` on `Center, Center, Center`. . `b` (the rhs) is specified as a 1D `Array` (or `CuArray` on GPUs). Example: coefficients to solve a Poisson equation of the form <img src=""https://render.githubusercontent.com/render/math?math=\nabla^2 \eta = b""> in a finite volume framework <img src=""https://render.githubusercontent.com/render/math?math=\sum_k A_k \nabla \eta = b \cdot V""> are shown in `test/test_matrix_poisson_solver.jl`. to construct the type, a part from the coefficients it is possible to specify; - the type of `iterative_solver` desired (`cg` is the default) ; - `reduced_dim::Tuple(Bool, Bool, Bool)` to have a lower-dimensional solve (a reduced dimension will mean that the matrix will be filled with the coefficients of index 1 in that direction, as an example, if `reduced_dim=(false, true, false)`, the matrix will be filled with `Ax[i, 1, k], Az[i, 1, k], C[i, 1, k]` and `D[i, 1, k]`) ; - `settings` which include `maximum_iterations`, `tolerance`, `precondition` (`false` or `true`). The preconditioner employed on the CPU is the (always perfect) ILU factorization (from the IncompleteLU.jl package); On the GPU, using a direct preconditioning technique is always detrimental because it requires a solution to the `P \ r` problem which is inherently non-parallelizable (in case of a LU would be a forward followed by a backward substitution).; For this reason a sparse approximate inverse method is implemented which iteratively calculates `M ≈ A⁻¹` based on the minimization of the Frobenius norm of `AM - I`. This leads to very good results as in this case the preconditioner is applied with just a matrix-vector multiplication `M * r`. Unfortunately, the initialization of this preconditioner ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105
https://github.com/CliMA/Oceananigans.jl/pull/2105:264,Performance,perform,performance,264,"This PR introduces a new ""Matrix based"" implicit solver `Oceananigans/Solvers/matrix_iterative_solver` that uses the package IterativeSolvers.jl to solve a linear system of equation based on a sparse matrix formulation. This has a couple of advantages in terms of performance; - there is no need to `fill_halo_regions!` on the residuals while iterating; - it is possible to implement efficient preconditioning techniques. the `MatrixIterativeSolver` accepts a tuple of coefficients `Ax, Ay, Az, C, D` as inputs and creates the associated matrix to solve the following ; <img src=""https://render.githubusercontent.com/render/math?math=Ax_{i%2B 1jk} \eta_{i%2B 1jk} %2B Ax_{ijk} \eta_{i-1jk} %2B Ay_{ij%2B 1k} \eta_{ij%2B 1k} %2B Ay_{ijk} \eta_{ij-1k} %2B Az_{ijk%2B 1} \eta_{ijk%2B 1} %2B Az_{ijk} \eta_{ijk-1} - 2 (Ax_{i%2B 1jk} %2B Ax_{ijk} %2B Ay_{ij%2B 1k} %2B Ay_{ijk} %2B Az_{ijk%2B 1} %2B Az_{ijk} ) \eta_{ijk} %2B ( C_{ijk} %2B D_{ijk} /\Delta t^2 ) \eta_{ijk} = b_{ijk}""> . the coefficients are specified as 3D arrays (also fields should be good). To solve for a `Center, Center, Center` value, `Ax` should be on `Face, Center, Center`, `Ay` should be on `Center, Face, Center`, `Az` on `Center, Center, Face` and `C` and `D` on `Center, Center, Center`. . `b` (the rhs) is specified as a 1D `Array` (or `CuArray` on GPUs). Example: coefficients to solve a Poisson equation of the form <img src=""https://render.githubusercontent.com/render/math?math=\nabla^2 \eta = b""> in a finite volume framework <img src=""https://render.githubusercontent.com/render/math?math=\sum_k A_k \nabla \eta = b \cdot V""> are shown in `test/test_matrix_poisson_solver.jl`. to construct the type, a part from the coefficients it is possible to specify; - the type of `iterative_solver` desired (`cg` is the default) ; - `reduced_dim::Tuple(Bool, Bool, Bool)` to have a lower-dimensional solve (a reduced dimension will mean that the matrix will be filled with the coefficients of index 1 in that direction, as an exa",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105
https://github.com/CliMA/Oceananigans.jl/pull/2105:3282,Security,validat,validation,3282,"m the IncompleteLU.jl package); On the GPU, using a direct preconditioning technique is always detrimental because it requires a solution to the `P \ r` problem which is inherently non-parallelizable (in case of a LU would be a forward followed by a backward substitution).; For this reason a sparse approximate inverse method is implemented which iteratively calculates `M ≈ A⁻¹` based on the minimization of the Frobenius norm of `AM - I`. This leads to very good results as in this case the preconditioner is applied with just a matrix-vector multiplication `M * r`. Unfortunately, the initialization of this preconditioner scales with `n²` so it might be very expensive if very large grid sizes want to be empoloyed (I have tested it up to `512 x 256` grid and still it was ok, but anyways, I will provide some benchmarking below). This matrix based solver is used in the free surface `MatrixImplicitFreeSurface` to solve implicitly for the free surface. The validation of the method has been included in tests `test_matrix_poisson_solver.jl`, `test_hydrostatic_free_surface_models.jl`, `test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl` and `test_implicit_free_surface_solvers.jl` . Benchmarks in `benchmark_hydrostatic_model.jl` (grid size of `256 x 128`) show how the method compares with other free-surfaces methods, the preconditioner settings used where; - `τ = 0.001` for the `CPU()` preconditioner; - `ε = 0.1` and `nzrel = 1.0` for the `GPU()` preconditioner. ```. ┌───────────────┬───────────────────────┬───────────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼───────────────────────┼───────────────────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ RectilinearGrid │ ExplicitFreeSurface │ 4.866 ms │ 5.112 ms │ 5.161 ms │ 6.002",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105
https://github.com/CliMA/Oceananigans.jl/pull/2105:1622,Testability,test,test,1622,"sercontent.com/render/math?math=Ax_{i%2B 1jk} \eta_{i%2B 1jk} %2B Ax_{ijk} \eta_{i-1jk} %2B Ay_{ij%2B 1k} \eta_{ij%2B 1k} %2B Ay_{ijk} \eta_{ij-1k} %2B Az_{ijk%2B 1} \eta_{ijk%2B 1} %2B Az_{ijk} \eta_{ijk-1} - 2 (Ax_{i%2B 1jk} %2B Ax_{ijk} %2B Ay_{ij%2B 1k} %2B Ay_{ijk} %2B Az_{ijk%2B 1} %2B Az_{ijk} ) \eta_{ijk} %2B ( C_{ijk} %2B D_{ijk} /\Delta t^2 ) \eta_{ijk} = b_{ijk}""> . the coefficients are specified as 3D arrays (also fields should be good). To solve for a `Center, Center, Center` value, `Ax` should be on `Face, Center, Center`, `Ay` should be on `Center, Face, Center`, `Az` on `Center, Center, Face` and `C` and `D` on `Center, Center, Center`. . `b` (the rhs) is specified as a 1D `Array` (or `CuArray` on GPUs). Example: coefficients to solve a Poisson equation of the form <img src=""https://render.githubusercontent.com/render/math?math=\nabla^2 \eta = b""> in a finite volume framework <img src=""https://render.githubusercontent.com/render/math?math=\sum_k A_k \nabla \eta = b \cdot V""> are shown in `test/test_matrix_poisson_solver.jl`. to construct the type, a part from the coefficients it is possible to specify; - the type of `iterative_solver` desired (`cg` is the default) ; - `reduced_dim::Tuple(Bool, Bool, Bool)` to have a lower-dimensional solve (a reduced dimension will mean that the matrix will be filled with the coefficients of index 1 in that direction, as an example, if `reduced_dim=(false, true, false)`, the matrix will be filled with `Ax[i, 1, k], Az[i, 1, k], C[i, 1, k]` and `D[i, 1, k]`) ; - `settings` which include `maximum_iterations`, `tolerance`, `precondition` (`false` or `true`). The preconditioner employed on the CPU is the (always perfect) ILU factorization (from the IncompleteLU.jl package); On the GPU, using a direct preconditioning technique is always detrimental because it requires a solution to the `P \ r` problem which is inherently non-parallelizable (in case of a LU would be a forward followed by a backward substitution).; For this",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105
https://github.com/CliMA/Oceananigans.jl/pull/2105:3047,Testability,test,tested,3047,"m=(false, true, false)`, the matrix will be filled with `Ax[i, 1, k], Az[i, 1, k], C[i, 1, k]` and `D[i, 1, k]`) ; - `settings` which include `maximum_iterations`, `tolerance`, `precondition` (`false` or `true`). The preconditioner employed on the CPU is the (always perfect) ILU factorization (from the IncompleteLU.jl package); On the GPU, using a direct preconditioning technique is always detrimental because it requires a solution to the `P \ r` problem which is inherently non-parallelizable (in case of a LU would be a forward followed by a backward substitution).; For this reason a sparse approximate inverse method is implemented which iteratively calculates `M ≈ A⁻¹` based on the minimization of the Frobenius norm of `AM - I`. This leads to very good results as in this case the preconditioner is applied with just a matrix-vector multiplication `M * r`. Unfortunately, the initialization of this preconditioner scales with `n²` so it might be very expensive if very large grid sizes want to be empoloyed (I have tested it up to `512 x 256` grid and still it was ok, but anyways, I will provide some benchmarking below). This matrix based solver is used in the free surface `MatrixImplicitFreeSurface` to solve implicitly for the free surface. The validation of the method has been included in tests `test_matrix_poisson_solver.jl`, `test_hydrostatic_free_surface_models.jl`, `test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl` and `test_implicit_free_surface_solvers.jl` . Benchmarks in `benchmark_hydrostatic_model.jl` (grid size of `256 x 128`) show how the method compares with other free-surfaces methods, the preconditioner settings used where; - `τ = 0.001` for the `CPU()` preconditioner; - `ε = 0.1` and `nzrel = 1.0` for the `GPU()` preconditioner. ```. ┌───────────────┬───────────────────────┬───────────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105
https://github.com/CliMA/Oceananigans.jl/pull/2105:3134,Testability,benchmark,benchmarking,3134,"m=(false, true, false)`, the matrix will be filled with `Ax[i, 1, k], Az[i, 1, k], C[i, 1, k]` and `D[i, 1, k]`) ; - `settings` which include `maximum_iterations`, `tolerance`, `precondition` (`false` or `true`). The preconditioner employed on the CPU is the (always perfect) ILU factorization (from the IncompleteLU.jl package); On the GPU, using a direct preconditioning technique is always detrimental because it requires a solution to the `P \ r` problem which is inherently non-parallelizable (in case of a LU would be a forward followed by a backward substitution).; For this reason a sparse approximate inverse method is implemented which iteratively calculates `M ≈ A⁻¹` based on the minimization of the Frobenius norm of `AM - I`. This leads to very good results as in this case the preconditioner is applied with just a matrix-vector multiplication `M * r`. Unfortunately, the initialization of this preconditioner scales with `n²` so it might be very expensive if very large grid sizes want to be empoloyed (I have tested it up to `512 x 256` grid and still it was ok, but anyways, I will provide some benchmarking below). This matrix based solver is used in the free surface `MatrixImplicitFreeSurface` to solve implicitly for the free surface. The validation of the method has been included in tests `test_matrix_poisson_solver.jl`, `test_hydrostatic_free_surface_models.jl`, `test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl` and `test_implicit_free_surface_solvers.jl` . Benchmarks in `benchmark_hydrostatic_model.jl` (grid size of `256 x 128`) show how the method compares with other free-surfaces methods, the preconditioner settings used where; - `τ = 0.001` for the `CPU()` preconditioner; - `ε = 0.1` and `nzrel = 1.0` for the `GPU()` preconditioner. ```. ┌───────────────┬───────────────────────┬───────────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105
https://github.com/CliMA/Oceananigans.jl/pull/2105:3328,Testability,test,tests,3328,"m the IncompleteLU.jl package); On the GPU, using a direct preconditioning technique is always detrimental because it requires a solution to the `P \ r` problem which is inherently non-parallelizable (in case of a LU would be a forward followed by a backward substitution).; For this reason a sparse approximate inverse method is implemented which iteratively calculates `M ≈ A⁻¹` based on the minimization of the Frobenius norm of `AM - I`. This leads to very good results as in this case the preconditioner is applied with just a matrix-vector multiplication `M * r`. Unfortunately, the initialization of this preconditioner scales with `n²` so it might be very expensive if very large grid sizes want to be empoloyed (I have tested it up to `512 x 256` grid and still it was ok, but anyways, I will provide some benchmarking below). This matrix based solver is used in the free surface `MatrixImplicitFreeSurface` to solve implicitly for the free surface. The validation of the method has been included in tests `test_matrix_poisson_solver.jl`, `test_hydrostatic_free_surface_models.jl`, `test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl` and `test_implicit_free_surface_solvers.jl` . Benchmarks in `benchmark_hydrostatic_model.jl` (grid size of `256 x 128`) show how the method compares with other free-surfaces methods, the preconditioner settings used where; - `τ = 0.001` for the `CPU()` preconditioner; - `ε = 0.1` and `nzrel = 1.0` for the `GPU()` preconditioner. ```. ┌───────────────┬───────────────────────┬───────────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼───────────────────────┼───────────────────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ RectilinearGrid │ ExplicitFreeSurface │ 4.866 ms │ 5.112 ms │ 5.161 ms │ 6.002",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105
https://github.com/CliMA/Oceananigans.jl/pull/2105:3525,Testability,Benchmark,Benchmarks,3525," forward followed by a backward substitution).; For this reason a sparse approximate inverse method is implemented which iteratively calculates `M ≈ A⁻¹` based on the minimization of the Frobenius norm of `AM - I`. This leads to very good results as in this case the preconditioner is applied with just a matrix-vector multiplication `M * r`. Unfortunately, the initialization of this preconditioner scales with `n²` so it might be very expensive if very large grid sizes want to be empoloyed (I have tested it up to `512 x 256` grid and still it was ok, but anyways, I will provide some benchmarking below). This matrix based solver is used in the free surface `MatrixImplicitFreeSurface` to solve implicitly for the free surface. The validation of the method has been included in tests `test_matrix_poisson_solver.jl`, `test_hydrostatic_free_surface_models.jl`, `test_hydrostatic_free_surface_immersed_boundaries_congrad_solve.jl` and `test_implicit_free_surface_solvers.jl` . Benchmarks in `benchmark_hydrostatic_model.jl` (grid size of `256 x 128`) show how the method compares with other free-surfaces methods, the preconditioner settings used where; - `τ = 0.001` for the `CPU()` preconditioner; - `ε = 0.1` and `nzrel = 1.0` for the `GPU()` preconditioner. ```. ┌───────────────┬───────────────────────┬───────────────────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┬─────────┐; │ Architectures │ grid_types │ free_surface_types │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼───────────────────────┼───────────────────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┼─────────┤; │ CPU │ RectilinearGrid │ ExplicitFreeSurface │ 4.866 ms │ 5.112 ms │ 5.161 ms │ 6.002 ms │ 881.88 KiB │ 1514 │ 10 │; │ CPU │ RectilinearGrid │ FFTImplicitFreeSurface │ 7.747 ms │ 7.970 ms │ 8.234 ms │ 10.968 ms │ 1.28 MiB │ 2103 │ 10 │; │ CPU │ RectilinearGrid │ ImplicitFreeSurface │ 151.499 ms │ 165.772 ms │ ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105
https://github.com/CliMA/Oceananigans.jl/pull/2105:6386,Testability,benchmark,benchmarks,6386,"s │ 39.898 ms │ 40.168 ms │ 42.705 ms │ 2.67 MiB │ 2185 │ 10 │; │ GPU │ LatitudeLongitudeGrid │ ExplicitFreeSurface │ 2.183 ms │ 2.413 ms │ 2.607 ms │ 4.697 ms │ 2.79 MiB │ 4336 │ 10 │; │ GPU │ LatitudeLongitudeGrid │ ImplicitFreeSurface │ 210.184 ms │ 222.141 ms │ 245.991 ms │ 324.810 ms │ 124.16 MiB │ 463523 │ 10 │; │ GPU │ LatitudeLongitudeGrid │ MatrixImplicitFreeSurface │ 24.591 ms │ 24.738 ms │ 25.103 ms │ 28.283 ms │ 4.93 MiB │ 31007 │ 10 │; └───────────────┴───────────────────────┴───────────────────────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┴─────────┘. ```. The price you have to pay for the initialization of a GPU preconditioner is shown below in terms of `N` (where the grid is `N²`), `ε` and `nzrel` . These are outputs of `benchamarks/benchmark_spai_preconditioner.jl`. ```; SPAI preconditioner benchmarks; ┌─────┬─────┬───────┬────────────┬────────────┬────────────┬────────────┬────────────┬───────────┬─────────┐; │ N │ ε │ nzrel │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├─────┼─────┼───────┼────────────┼────────────┼────────────┼────────────┼────────────┼───────────┼─────────┤; │ 64 │ 0.1 │ 0.5 │ 1.733 s │ 1.873 s │ 1.884 s │ 2.046 s │ 1.73 GiB │ 8969362 │ 3 │; │ 64 │ 0.3 │ 0.5 │ 1.559 s │ 1.779 s │ 1.722 s │ 1.828 s │ 1.73 GiB │ 8969362 │ 3 │; │ 64 │ 0.6 │ 0.5 │ 411.863 ms │ 430.678 ms │ 425.296 ms │ 433.009 ms │ 478.89 MiB │ 1296680 │ 5 │; │ 64 │ 0.1 │ 2.0 │ 4.711 s │ 4.748 s │ 4.748 s │ 4.786 s │ 5.20 GiB │ 40335010 │ 2 │; │ 64 │ 0.3 │ 2.0 │ 1.326 s │ 1.341 s │ 1.344 s │ 1.368 s │ 1.73 GiB │ 8969362 │ 4 │; │ 64 │ 0.6 │ 2.0 │ 388.265 ms │ 414.406 ms │ 413.665 ms │ 449.928 ms │ 478.89 MiB │ 1296680 │ 5 │; │ 64 │ 0.1 │ 1.0 │ 1.328 s │ 1.354 s │ 1.356 s │ 1.387 s │ 1.73 GiB │ 8969362 │ 4 │; │ 64 │ 0.3 │ 1.0 │ 1.283 s │ 1.290 s │ 1.310 s │ 1.376 s │ 1.73 GiB │ 8969362 │ 4 │; │ 64 │ 0.6 │ 1.0 │ 387.341 ms │ 389.817 ms │ 395.236 ms │ 411.333 ms │ 478.89 MiB │ 1296680 │ 5 │; │ 128 │ 0.1 │ 0.5 │ 13.551 s │",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2105
https://github.com/CliMA/Oceananigans.jl/issues/2106:95,Availability,error,error,95,"Yesterday, with @glwagner, we discovered that using higher order advection schemes gave larger error when you don't set the halo to be the large size. . How about we check the halo size we give an error?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2106
https://github.com/CliMA/Oceananigans.jl/issues/2106:197,Availability,error,error,197,"Yesterday, with @glwagner, we discovered that using higher order advection schemes gave larger error when you don't set the halo to be the large size. . How about we check the halo size we give an error?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2106
https://github.com/CliMA/Oceananigans.jl/issues/2107:934,Availability,error,error,934,"Right now in the `NonhydrostaticModel`, we remake a user-provided `grid` if the halos are not big enough:. https://github.com/CliMA/Oceananigans.jl/blob/04ca8e2f143afd53fd60bdaeb885a4dc1ed5825c/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L127. This is a nice convenience for users experimenting with different advection schemes, closures, etc. One major caveat, however, is that models that incorporate user-created fields, when those fields are provided at the time of model construction, may have been created on the ""wrong"" grid. This problem is most acute for `PrescribedVelocityFields` with the `HydrostaticFreeSurfaceModel`; however the issue is generic. It doesn't appear to be very common for users to create their own fields, which is perhaps why no great problems have been detected. Nevertheless, this is an insidious ""gotcha"" that could lead to hard to define or undetectable bugs. One solution is to throw an error if the grid's halos are not big enough, rather than recreating it. The error will instruct the user to specify larger halos. This damages usability (since users need to know and care about their halos) but makes user experiments more resilient against bugs. In the future, if we also use large halos by default (eg `(3, 3, 3)` as proposed by #1245) then such an error would be encountered only rarely.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2107
https://github.com/CliMA/Oceananigans.jl/issues/2107:1011,Availability,error,error,1011,"Right now in the `NonhydrostaticModel`, we remake a user-provided `grid` if the halos are not big enough:. https://github.com/CliMA/Oceananigans.jl/blob/04ca8e2f143afd53fd60bdaeb885a4dc1ed5825c/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L127. This is a nice convenience for users experimenting with different advection schemes, closures, etc. One major caveat, however, is that models that incorporate user-created fields, when those fields are provided at the time of model construction, may have been created on the ""wrong"" grid. This problem is most acute for `PrescribedVelocityFields` with the `HydrostaticFreeSurfaceModel`; however the issue is generic. It doesn't appear to be very common for users to create their own fields, which is perhaps why no great problems have been detected. Nevertheless, this is an insidious ""gotcha"" that could lead to hard to define or undetectable bugs. One solution is to throw an error if the grid's halos are not big enough, rather than recreating it. The error will instruct the user to specify larger halos. This damages usability (since users need to know and care about their halos) but makes user experiments more resilient against bugs. In the future, if we also use large halos by default (eg `(3, 3, 3)` as proposed by #1245) then such an error would be encountered only rarely.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2107
https://github.com/CliMA/Oceananigans.jl/issues/2107:1174,Availability,resilien,resilient,1174,"Right now in the `NonhydrostaticModel`, we remake a user-provided `grid` if the halos are not big enough:. https://github.com/CliMA/Oceananigans.jl/blob/04ca8e2f143afd53fd60bdaeb885a4dc1ed5825c/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L127. This is a nice convenience for users experimenting with different advection schemes, closures, etc. One major caveat, however, is that models that incorporate user-created fields, when those fields are provided at the time of model construction, may have been created on the ""wrong"" grid. This problem is most acute for `PrescribedVelocityFields` with the `HydrostaticFreeSurfaceModel`; however the issue is generic. It doesn't appear to be very common for users to create their own fields, which is perhaps why no great problems have been detected. Nevertheless, this is an insidious ""gotcha"" that could lead to hard to define or undetectable bugs. One solution is to throw an error if the grid's halos are not big enough, rather than recreating it. The error will instruct the user to specify larger halos. This damages usability (since users need to know and care about their halos) but makes user experiments more resilient against bugs. In the future, if we also use large halos by default (eg `(3, 3, 3)` as proposed by #1245) then such an error would be encountered only rarely.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2107
https://github.com/CliMA/Oceananigans.jl/issues/2107:1302,Availability,error,error,1302,"Right now in the `NonhydrostaticModel`, we remake a user-provided `grid` if the halos are not big enough:. https://github.com/CliMA/Oceananigans.jl/blob/04ca8e2f143afd53fd60bdaeb885a4dc1ed5825c/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L127. This is a nice convenience for users experimenting with different advection schemes, closures, etc. One major caveat, however, is that models that incorporate user-created fields, when those fields are provided at the time of model construction, may have been created on the ""wrong"" grid. This problem is most acute for `PrescribedVelocityFields` with the `HydrostaticFreeSurfaceModel`; however the issue is generic. It doesn't appear to be very common for users to create their own fields, which is perhaps why no great problems have been detected. Nevertheless, this is an insidious ""gotcha"" that could lead to hard to define or undetectable bugs. One solution is to throw an error if the grid's halos are not big enough, rather than recreating it. The error will instruct the user to specify larger halos. This damages usability (since users need to know and care about their halos) but makes user experiments more resilient against bugs. In the future, if we also use large halos by default (eg `(3, 3, 3)` as proposed by #1245) then such an error would be encountered only rarely.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2107
https://github.com/CliMA/Oceananigans.jl/issues/2107:796,Safety,detect,detected,796,"Right now in the `NonhydrostaticModel`, we remake a user-provided `grid` if the halos are not big enough:. https://github.com/CliMA/Oceananigans.jl/blob/04ca8e2f143afd53fd60bdaeb885a4dc1ed5825c/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L127. This is a nice convenience for users experimenting with different advection schemes, closures, etc. One major caveat, however, is that models that incorporate user-created fields, when those fields are provided at the time of model construction, may have been created on the ""wrong"" grid. This problem is most acute for `PrescribedVelocityFields` with the `HydrostaticFreeSurfaceModel`; however the issue is generic. It doesn't appear to be very common for users to create their own fields, which is perhaps why no great problems have been detected. Nevertheless, this is an insidious ""gotcha"" that could lead to hard to define or undetectable bugs. One solution is to throw an error if the grid's halos are not big enough, rather than recreating it. The error will instruct the user to specify larger halos. This damages usability (since users need to know and care about their halos) but makes user experiments more resilient against bugs. In the future, if we also use large halos by default (eg `(3, 3, 3)` as proposed by #1245) then such an error would be encountered only rarely.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2107
https://github.com/CliMA/Oceananigans.jl/issues/2107:1078,Usability,usab,usability,1078,"Right now in the `NonhydrostaticModel`, we remake a user-provided `grid` if the halos are not big enough:. https://github.com/CliMA/Oceananigans.jl/blob/04ca8e2f143afd53fd60bdaeb885a4dc1ed5825c/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl#L127. This is a nice convenience for users experimenting with different advection schemes, closures, etc. One major caveat, however, is that models that incorporate user-created fields, when those fields are provided at the time of model construction, may have been created on the ""wrong"" grid. This problem is most acute for `PrescribedVelocityFields` with the `HydrostaticFreeSurfaceModel`; however the issue is generic. It doesn't appear to be very common for users to create their own fields, which is perhaps why no great problems have been detected. Nevertheless, this is an insidious ""gotcha"" that could lead to hard to define or undetectable bugs. One solution is to throw an error if the grid's halos are not big enough, rather than recreating it. The error will instruct the user to specify larger halos. This damages usability (since users need to know and care about their halos) but makes user experiments more resilient against bugs. In the future, if we also use large halos by default (eg `(3, 3, 3)` as proposed by #1245) then such an error would be encountered only rarely.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2107
https://github.com/CliMA/Oceananigans.jl/pull/2108:30,Testability,Test,Test,30,Resolves #2106 . TODO:. - [x] Test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2108
https://github.com/CliMA/Oceananigans.jl/pull/2110:208,Availability,error,error,208,"This PR adds a new constructor for `RectilinearGrid` that looks something like. ```julia; grid = RectilinearGrid(Float64, size = (1, 1, 1), ...); ```. that defaults to `architecture = CPU()`. This avoids the error observed on #2103. Since users _rarely_ change the floating point type, this alternative constructor probably won't be used all that much. So it's not crucial, but might help a few people. If others (@navidcy, @simone-silvestri ?) think this is a good idea, I'll add the same for other grid constructors. If we don't merge this PR, we should probably still validate the positional inputs to grid constructors to make sure they are valid (eg `architecture` needs to be `AbstractArchitecture`, etc).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2110
https://github.com/CliMA/Oceananigans.jl/pull/2110:197,Safety,avoid,avoids,197,"This PR adds a new constructor for `RectilinearGrid` that looks something like. ```julia; grid = RectilinearGrid(Float64, size = (1, 1, 1), ...); ```. that defaults to `architecture = CPU()`. This avoids the error observed on #2103. Since users _rarely_ change the floating point type, this alternative constructor probably won't be used all that much. So it's not crucial, but might help a few people. If others (@navidcy, @simone-silvestri ?) think this is a good idea, I'll add the same for other grid constructors. If we don't merge this PR, we should probably still validate the positional inputs to grid constructors to make sure they are valid (eg `architecture` needs to be `AbstractArchitecture`, etc).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2110
https://github.com/CliMA/Oceananigans.jl/pull/2110:571,Security,validat,validate,571,"This PR adds a new constructor for `RectilinearGrid` that looks something like. ```julia; grid = RectilinearGrid(Float64, size = (1, 1, 1), ...); ```. that defaults to `architecture = CPU()`. This avoids the error observed on #2103. Since users _rarely_ change the floating point type, this alternative constructor probably won't be used all that much. So it's not crucial, but might help a few people. If others (@navidcy, @simone-silvestri ?) think this is a good idea, I'll add the same for other grid constructors. If we don't merge this PR, we should probably still validate the positional inputs to grid constructors to make sure they are valid (eg `architecture` needs to be `AbstractArchitecture`, etc).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2110
https://github.com/CliMA/Oceananigans.jl/issues/2113:8,Usability,simpl,simpler,8,"It'd be simpler to maintain just one 2nd order and 4th order diffusivity implementation. Also, `HorizontallyCurvilinearAnisotropicBiharmonicDiffusivity` is _truly_ biharmonic, whereas `AnisotropicBiharmonicDiffusivity` is not. Deletion of the existing schemes and renaming of the curvilinear-friendly schemes will easily resolve this issue.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2113
https://github.com/CliMA/Oceananigans.jl/issues/2116:420,Availability,mask,mask,420,"Right now the functions that calculate implicit vertical diffusion coefficients don't know about a field's horizontal location:. https://github.com/CliMA/Oceananigans.jl/blob/11727d66587e01067bf1ac24e2655e593e98fe9e/src/TurbulenceClosures/vertically_implicit_diffusion_solver.jl#L41-L44. except implicitly through `κ⁻⁻ᶠ`. However, when using an immersed boundary, we need the _horizontal_ location in order to correctly mask the coefficients of the implicit vertical diffusion tridiagonal matrix. So, rather than passing the function `κ⁻⁻ᶠ`, we should pass the field's location here. This will also mean that we only need one `ivd_upper_diagonal`, and we can dispatch on the special case that a field is located at cell interfaces in the vertical.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2116
https://github.com/CliMA/Oceananigans.jl/issues/2116:720,Integrability,interface,interfaces,720,"Right now the functions that calculate implicit vertical diffusion coefficients don't know about a field's horizontal location:. https://github.com/CliMA/Oceananigans.jl/blob/11727d66587e01067bf1ac24e2655e593e98fe9e/src/TurbulenceClosures/vertically_implicit_diffusion_solver.jl#L41-L44. except implicitly through `κ⁻⁻ᶠ`. However, when using an immersed boundary, we need the _horizontal_ location in order to correctly mask the coefficients of the implicit vertical diffusion tridiagonal matrix. So, rather than passing the function `κ⁻⁻ᶠ`, we should pass the field's location here. This will also mean that we only need one `ivd_upper_diagonal`, and we can dispatch on the special case that a field is located at cell interfaces in the vertical.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2116
https://github.com/CliMA/Oceananigans.jl/pull/2121:96,Energy Efficiency,Reduce,ReducedField,96,"This PR resolves #2052 by consolidating `Field` to encompass:; - `Field`; - `ComputedField`; - `ReducedField`; - `AveragedField`. In addition, it gets rid of `KernelComputedField` since that functionality is now covered by `KernelComputedOperation` + `Field`. `Field` will no longer explicitly keep track of `architecture`, because `architecture` belongs to `grid` now. This PR also change the API for constructing fields:. ```julia; a = Field{Face, Face, Center}(grid) # constructs a field at `(Face, Face, Center)`; b = Field{Nothing, Face, Center}(grid) # constructs a field that is reduced in the x-direction at `(Face, Center)` in `y, z`; c = Field{Center, Center, Center}(grid); csq = Field(c^2) # constructs a ""computed field"" that calculates and stores c^2 via `compute!(c_sq)`; ```. There are also convenience constructors that take a tuple of locations:. ```julia; loc = (Face, Face, Center); a = Field(loc, grid); ```. `AveragedField` functionality is now wrapped into `Field`. Rather than writing `c_sq_avg = AveragedField(c^2, dims=(1, 2))`, we now write. ```julia; c_sq_avg = Field(Average(c^2, dims=(1, 2))); ```. There is also an interface for generic reductions, so another possibility is. ```julia; c_sq_max = Field(Reduction(maximum!, c^2, dims=(1, 2))); compute!(c_sq_max); ```. It was already possible to compute `maximum!` with a `ReducedField` and an `AbstractField`; this interface simply provides a way to compute these things on the fly for diagnostics purposes while running simulations. In summary, this PR is meant to reduce the amount of code we have to maintain, significantly declutter our `Field` implementations, clean up the API, and hopefully make it easier to extend `Field` implementations in the future, especially regarding reductions of operations such as `SummedField`, `SlicedField`, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2121
https://github.com/CliMA/Oceananigans.jl/pull/2121:586,Energy Efficiency,reduce,reduced,586,"This PR resolves #2052 by consolidating `Field` to encompass:; - `Field`; - `ComputedField`; - `ReducedField`; - `AveragedField`. In addition, it gets rid of `KernelComputedField` since that functionality is now covered by `KernelComputedOperation` + `Field`. `Field` will no longer explicitly keep track of `architecture`, because `architecture` belongs to `grid` now. This PR also change the API for constructing fields:. ```julia; a = Field{Face, Face, Center}(grid) # constructs a field at `(Face, Face, Center)`; b = Field{Nothing, Face, Center}(grid) # constructs a field that is reduced in the x-direction at `(Face, Center)` in `y, z`; c = Field{Center, Center, Center}(grid); csq = Field(c^2) # constructs a ""computed field"" that calculates and stores c^2 via `compute!(c_sq)`; ```. There are also convenience constructors that take a tuple of locations:. ```julia; loc = (Face, Face, Center); a = Field(loc, grid); ```. `AveragedField` functionality is now wrapped into `Field`. Rather than writing `c_sq_avg = AveragedField(c^2, dims=(1, 2))`, we now write. ```julia; c_sq_avg = Field(Average(c^2, dims=(1, 2))); ```. There is also an interface for generic reductions, so another possibility is. ```julia; c_sq_max = Field(Reduction(maximum!, c^2, dims=(1, 2))); compute!(c_sq_max); ```. It was already possible to compute `maximum!` with a `ReducedField` and an `AbstractField`; this interface simply provides a way to compute these things on the fly for diagnostics purposes while running simulations. In summary, this PR is meant to reduce the amount of code we have to maintain, significantly declutter our `Field` implementations, clean up the API, and hopefully make it easier to extend `Field` implementations in the future, especially regarding reductions of operations such as `SummedField`, `SlicedField`, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2121
https://github.com/CliMA/Oceananigans.jl/pull/2121:1353,Energy Efficiency,Reduce,ReducedField,1353,"This PR resolves #2052 by consolidating `Field` to encompass:; - `Field`; - `ComputedField`; - `ReducedField`; - `AveragedField`. In addition, it gets rid of `KernelComputedField` since that functionality is now covered by `KernelComputedOperation` + `Field`. `Field` will no longer explicitly keep track of `architecture`, because `architecture` belongs to `grid` now. This PR also change the API for constructing fields:. ```julia; a = Field{Face, Face, Center}(grid) # constructs a field at `(Face, Face, Center)`; b = Field{Nothing, Face, Center}(grid) # constructs a field that is reduced in the x-direction at `(Face, Center)` in `y, z`; c = Field{Center, Center, Center}(grid); csq = Field(c^2) # constructs a ""computed field"" that calculates and stores c^2 via `compute!(c_sq)`; ```. There are also convenience constructors that take a tuple of locations:. ```julia; loc = (Face, Face, Center); a = Field(loc, grid); ```. `AveragedField` functionality is now wrapped into `Field`. Rather than writing `c_sq_avg = AveragedField(c^2, dims=(1, 2))`, we now write. ```julia; c_sq_avg = Field(Average(c^2, dims=(1, 2))); ```. There is also an interface for generic reductions, so another possibility is. ```julia; c_sq_max = Field(Reduction(maximum!, c^2, dims=(1, 2))); compute!(c_sq_max); ```. It was already possible to compute `maximum!` with a `ReducedField` and an `AbstractField`; this interface simply provides a way to compute these things on the fly for diagnostics purposes while running simulations. In summary, this PR is meant to reduce the amount of code we have to maintain, significantly declutter our `Field` implementations, clean up the API, and hopefully make it easier to extend `Field` implementations in the future, especially regarding reductions of operations such as `SummedField`, `SlicedField`, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2121
https://github.com/CliMA/Oceananigans.jl/pull/2121:1547,Energy Efficiency,reduce,reduce,1547,"This PR resolves #2052 by consolidating `Field` to encompass:; - `Field`; - `ComputedField`; - `ReducedField`; - `AveragedField`. In addition, it gets rid of `KernelComputedField` since that functionality is now covered by `KernelComputedOperation` + `Field`. `Field` will no longer explicitly keep track of `architecture`, because `architecture` belongs to `grid` now. This PR also change the API for constructing fields:. ```julia; a = Field{Face, Face, Center}(grid) # constructs a field at `(Face, Face, Center)`; b = Field{Nothing, Face, Center}(grid) # constructs a field that is reduced in the x-direction at `(Face, Center)` in `y, z`; c = Field{Center, Center, Center}(grid); csq = Field(c^2) # constructs a ""computed field"" that calculates and stores c^2 via `compute!(c_sq)`; ```. There are also convenience constructors that take a tuple of locations:. ```julia; loc = (Face, Face, Center); a = Field(loc, grid); ```. `AveragedField` functionality is now wrapped into `Field`. Rather than writing `c_sq_avg = AveragedField(c^2, dims=(1, 2))`, we now write. ```julia; c_sq_avg = Field(Average(c^2, dims=(1, 2))); ```. There is also an interface for generic reductions, so another possibility is. ```julia; c_sq_max = Field(Reduction(maximum!, c^2, dims=(1, 2))); compute!(c_sq_max); ```. It was already possible to compute `maximum!` with a `ReducedField` and an `AbstractField`; this interface simply provides a way to compute these things on the fly for diagnostics purposes while running simulations. In summary, this PR is meant to reduce the amount of code we have to maintain, significantly declutter our `Field` implementations, clean up the API, and hopefully make it easier to extend `Field` implementations in the future, especially regarding reductions of operations such as `SummedField`, `SlicedField`, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2121
https://github.com/CliMA/Oceananigans.jl/pull/2121:967,Integrability,wrap,wrapped,967,"This PR resolves #2052 by consolidating `Field` to encompass:; - `Field`; - `ComputedField`; - `ReducedField`; - `AveragedField`. In addition, it gets rid of `KernelComputedField` since that functionality is now covered by `KernelComputedOperation` + `Field`. `Field` will no longer explicitly keep track of `architecture`, because `architecture` belongs to `grid` now. This PR also change the API for constructing fields:. ```julia; a = Field{Face, Face, Center}(grid) # constructs a field at `(Face, Face, Center)`; b = Field{Nothing, Face, Center}(grid) # constructs a field that is reduced in the x-direction at `(Face, Center)` in `y, z`; c = Field{Center, Center, Center}(grid); csq = Field(c^2) # constructs a ""computed field"" that calculates and stores c^2 via `compute!(c_sq)`; ```. There are also convenience constructors that take a tuple of locations:. ```julia; loc = (Face, Face, Center); a = Field(loc, grid); ```. `AveragedField` functionality is now wrapped into `Field`. Rather than writing `c_sq_avg = AveragedField(c^2, dims=(1, 2))`, we now write. ```julia; c_sq_avg = Field(Average(c^2, dims=(1, 2))); ```. There is also an interface for generic reductions, so another possibility is. ```julia; c_sq_max = Field(Reduction(maximum!, c^2, dims=(1, 2))); compute!(c_sq_max); ```. It was already possible to compute `maximum!` with a `ReducedField` and an `AbstractField`; this interface simply provides a way to compute these things on the fly for diagnostics purposes while running simulations. In summary, this PR is meant to reduce the amount of code we have to maintain, significantly declutter our `Field` implementations, clean up the API, and hopefully make it easier to extend `Field` implementations in the future, especially regarding reductions of operations such as `SummedField`, `SlicedField`, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2121
https://github.com/CliMA/Oceananigans.jl/pull/2121:1146,Integrability,interface,interface,1146,"This PR resolves #2052 by consolidating `Field` to encompass:; - `Field`; - `ComputedField`; - `ReducedField`; - `AveragedField`. In addition, it gets rid of `KernelComputedField` since that functionality is now covered by `KernelComputedOperation` + `Field`. `Field` will no longer explicitly keep track of `architecture`, because `architecture` belongs to `grid` now. This PR also change the API for constructing fields:. ```julia; a = Field{Face, Face, Center}(grid) # constructs a field at `(Face, Face, Center)`; b = Field{Nothing, Face, Center}(grid) # constructs a field that is reduced in the x-direction at `(Face, Center)` in `y, z`; c = Field{Center, Center, Center}(grid); csq = Field(c^2) # constructs a ""computed field"" that calculates and stores c^2 via `compute!(c_sq)`; ```. There are also convenience constructors that take a tuple of locations:. ```julia; loc = (Face, Face, Center); a = Field(loc, grid); ```. `AveragedField` functionality is now wrapped into `Field`. Rather than writing `c_sq_avg = AveragedField(c^2, dims=(1, 2))`, we now write. ```julia; c_sq_avg = Field(Average(c^2, dims=(1, 2))); ```. There is also an interface for generic reductions, so another possibility is. ```julia; c_sq_max = Field(Reduction(maximum!, c^2, dims=(1, 2))); compute!(c_sq_max); ```. It was already possible to compute `maximum!` with a `ReducedField` and an `AbstractField`; this interface simply provides a way to compute these things on the fly for diagnostics purposes while running simulations. In summary, this PR is meant to reduce the amount of code we have to maintain, significantly declutter our `Field` implementations, clean up the API, and hopefully make it easier to extend `Field` implementations in the future, especially regarding reductions of operations such as `SummedField`, `SlicedField`, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2121
https://github.com/CliMA/Oceananigans.jl/pull/2121:1396,Integrability,interface,interface,1396,"This PR resolves #2052 by consolidating `Field` to encompass:; - `Field`; - `ComputedField`; - `ReducedField`; - `AveragedField`. In addition, it gets rid of `KernelComputedField` since that functionality is now covered by `KernelComputedOperation` + `Field`. `Field` will no longer explicitly keep track of `architecture`, because `architecture` belongs to `grid` now. This PR also change the API for constructing fields:. ```julia; a = Field{Face, Face, Center}(grid) # constructs a field at `(Face, Face, Center)`; b = Field{Nothing, Face, Center}(grid) # constructs a field that is reduced in the x-direction at `(Face, Center)` in `y, z`; c = Field{Center, Center, Center}(grid); csq = Field(c^2) # constructs a ""computed field"" that calculates and stores c^2 via `compute!(c_sq)`; ```. There are also convenience constructors that take a tuple of locations:. ```julia; loc = (Face, Face, Center); a = Field(loc, grid); ```. `AveragedField` functionality is now wrapped into `Field`. Rather than writing `c_sq_avg = AveragedField(c^2, dims=(1, 2))`, we now write. ```julia; c_sq_avg = Field(Average(c^2, dims=(1, 2))); ```. There is also an interface for generic reductions, so another possibility is. ```julia; c_sq_max = Field(Reduction(maximum!, c^2, dims=(1, 2))); compute!(c_sq_max); ```. It was already possible to compute `maximum!` with a `ReducedField` and an `AbstractField`; this interface simply provides a way to compute these things on the fly for diagnostics purposes while running simulations. In summary, this PR is meant to reduce the amount of code we have to maintain, significantly declutter our `Field` implementations, clean up the API, and hopefully make it easier to extend `Field` implementations in the future, especially regarding reductions of operations such as `SummedField`, `SlicedField`, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2121
https://github.com/CliMA/Oceananigans.jl/pull/2121:1697,Modifiability,extend,extend,1697,"This PR resolves #2052 by consolidating `Field` to encompass:; - `Field`; - `ComputedField`; - `ReducedField`; - `AveragedField`. In addition, it gets rid of `KernelComputedField` since that functionality is now covered by `KernelComputedOperation` + `Field`. `Field` will no longer explicitly keep track of `architecture`, because `architecture` belongs to `grid` now. This PR also change the API for constructing fields:. ```julia; a = Field{Face, Face, Center}(grid) # constructs a field at `(Face, Face, Center)`; b = Field{Nothing, Face, Center}(grid) # constructs a field that is reduced in the x-direction at `(Face, Center)` in `y, z`; c = Field{Center, Center, Center}(grid); csq = Field(c^2) # constructs a ""computed field"" that calculates and stores c^2 via `compute!(c_sq)`; ```. There are also convenience constructors that take a tuple of locations:. ```julia; loc = (Face, Face, Center); a = Field(loc, grid); ```. `AveragedField` functionality is now wrapped into `Field`. Rather than writing `c_sq_avg = AveragedField(c^2, dims=(1, 2))`, we now write. ```julia; c_sq_avg = Field(Average(c^2, dims=(1, 2))); ```. There is also an interface for generic reductions, so another possibility is. ```julia; c_sq_max = Field(Reduction(maximum!, c^2, dims=(1, 2))); compute!(c_sq_max); ```. It was already possible to compute `maximum!` with a `ReducedField` and an `AbstractField`; this interface simply provides a way to compute these things on the fly for diagnostics purposes while running simulations. In summary, this PR is meant to reduce the amount of code we have to maintain, significantly declutter our `Field` implementations, clean up the API, and hopefully make it easier to extend `Field` implementations in the future, especially regarding reductions of operations such as `SummedField`, `SlicedField`, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2121
https://github.com/CliMA/Oceananigans.jl/pull/2121:1406,Usability,simpl,simply,1406,"This PR resolves #2052 by consolidating `Field` to encompass:; - `Field`; - `ComputedField`; - `ReducedField`; - `AveragedField`. In addition, it gets rid of `KernelComputedField` since that functionality is now covered by `KernelComputedOperation` + `Field`. `Field` will no longer explicitly keep track of `architecture`, because `architecture` belongs to `grid` now. This PR also change the API for constructing fields:. ```julia; a = Field{Face, Face, Center}(grid) # constructs a field at `(Face, Face, Center)`; b = Field{Nothing, Face, Center}(grid) # constructs a field that is reduced in the x-direction at `(Face, Center)` in `y, z`; c = Field{Center, Center, Center}(grid); csq = Field(c^2) # constructs a ""computed field"" that calculates and stores c^2 via `compute!(c_sq)`; ```. There are also convenience constructors that take a tuple of locations:. ```julia; loc = (Face, Face, Center); a = Field(loc, grid); ```. `AveragedField` functionality is now wrapped into `Field`. Rather than writing `c_sq_avg = AveragedField(c^2, dims=(1, 2))`, we now write. ```julia; c_sq_avg = Field(Average(c^2, dims=(1, 2))); ```. There is also an interface for generic reductions, so another possibility is. ```julia; c_sq_max = Field(Reduction(maximum!, c^2, dims=(1, 2))); compute!(c_sq_max); ```. It was already possible to compute `maximum!` with a `ReducedField` and an `AbstractField`; this interface simply provides a way to compute these things on the fly for diagnostics purposes while running simulations. In summary, this PR is meant to reduce the amount of code we have to maintain, significantly declutter our `Field` implementations, clean up the API, and hopefully make it easier to extend `Field` implementations in the future, especially regarding reductions of operations such as `SummedField`, `SlicedField`, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2121
https://github.com/CliMA/Oceananigans.jl/pull/2122:147,Testability,test,test,147,"This lets me do . export TEST_GROUP=""none""; export TEST_FILE=""test_matrix_poisson_solver.jl"". so I don't have to edit runtest to try a single file test. Not sure if its good idea???",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2122
https://github.com/CliMA/Oceananigans.jl/pull/2123:404,Availability,down,downstream,404,"This pull request sets the compat entry for the `IterativeSolvers` package to `0.9`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2123
https://github.com/CliMA/Oceananigans.jl/pull/2123:342,Deployability,release,release,342,"This pull request sets the compat entry for the `IterativeSolvers` package to `0.9`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2123
https://github.com/CliMA/Oceananigans.jl/pull/2123:428,Integrability,depend,depend,428,"This pull request sets the compat entry for the `IterativeSolvers` package to `0.9`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2123
https://github.com/CliMA/Oceananigans.jl/pull/2123:155,Testability,test,tested,155,"This pull request sets the compat entry for the `IterativeSolvers` package to `0.9`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2123
https://github.com/CliMA/Oceananigans.jl/pull/2123:261,Testability,test,tests,261,"This pull request sets the compat entry for the `IterativeSolvers` package to `0.9`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.; Note: Consider registering a new release of your package immediately after merging this PR, as downstream packages may depend on this for tests to pass.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2123
