id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://root.cern/doc/master/TTree_8cxx_source.html:443232,Modifiability,variab,variable,443232,"nstReturn a pointer to the TTree friend whose name or alias is friendname.Definition TTree.cxx:5975; TTree::SetNotifyvirtual void SetNotify(TObject *obj)Sets the address of the object to be notified when the tree is loaded.Definition TTree.cxx:9231; TTree::GetMaximumvirtual Double_t GetMaximum(const char *columname)Return maximum of column with name columname.Definition TTree.cxx:6235; TTree::GetEntryNumberWithBestIndexvirtual Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor=0) constReturn entry number corresponding to major and minor number.Definition TTree.cxx:5890; TTree::SetMaxTreeSizestatic void SetMaxTreeSize(Long64_t maxsize=100000000000LL)Set the maximum size in bytes of a Tree file (static function).Definition TTree.cxx:9197; TTree::Printvoid Print(Option_t *option="""") const overridePrint a summary of the tree contents.Definition TTree.cxx:7219; TTree::UnbinnedFitvirtual Int_t UnbinnedFit(const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Unbinned fit of one or more variable(s) from a tree.Definition TTree.cxx:9702; TTree::fNClusterRangeInt_t fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'.Definition TTree.h:95; TTree::PrintCacheStatsvirtual void PrintCacheStats(Option_t *option="""") constPrint statistics about the TreeCache for this tree.Definition TTree.cxx:7370; TTree::BuildIndexvirtual Int_t BuildIndex(const char *majorname, const char *minorname=""0"")Build a Tree Index (default is TTreeIndex).Definition TTree.cxx:2637; TTree::fPlayerTVirtualTreePlayer * fPlayer! Pointer to current Tree playerDefinition TTree.h:134; TTree::GetIteratorOnAllLeavesvirtual TIterator * GetIteratorOnAllLeaves(bool dir=kIterForward)Creates a new iterator that will go through all the leaves on the tree itself and its friend.Definition TTree.cxx:6082; TTree::SetMakeClassvirtual void SetMakeClass(Int_t make)Set all the branches in this TT",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:449477,Modifiability,variab,variable,449477,"ze, Int_t splitlevel)Same as TTree::Branch but automatic detection of the class name.Definition TTree.cxx:1635; TTree::SetEventListvirtual void SetEventList(TEventList *list)This function transfroms the given TEventList into a TEntryList The new TEntryList is owned by the TT...Definition TTree.cxx:9069; TTree::MoveReadCachevoid MoveReadCache(TFile *src, TDirectory *dir)Move a cache from a file to the current file in dir.Definition TTree.cxx:6983; TTree::fAutoFlushLong64_t fAutoFlushAuto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced.Definition TTree.h:101; TTree::fUpdateInt_t fUpdateUpdate frequency for EntryLoop.Definition TTree.h:93; TTree::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Resets the state of this TTree after a merge (keep the customization but forget the data).Definition TTree.cxx:8034; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::SetEstimatevirtual void SetEstimate(Long64_t nentries=1000000)Set number of entries to estimate variable limits.Definition TTree.cxx:9110; TTree::fTimerIntervalInt_t fTimerIntervalTimer interval in milliseconds.Definition TTree.h:91; TTree::fDebugInt_t fDebug! Debug levelDefinition TTree.h:111; TTree::SetCacheSizeAuxInt_t SetCacheSizeAux(bool autocache=true, Long64_t cacheSize=0)Set the size of the file cache and create it if possible.Definition TTree.cxx:8711; TTree::AutoSavevirtual Long64_t AutoSave(Option_t *option="""")AutoSave tree header every fAutoSave bytes.Definition TTree.cxx:1500; TTree::GetEntryNumbervirtual Long64_t GetEntryNumber(Long64_t entry) constReturn entry number corresponding to entry.Definition TTree.cxx:5865; TTree::CloneTreevirtual TTree * CloneTree(Long64_t nentries=-1, Option_t *option="""")Create a clone of this tree and copy nentries.Definition TTree.cxx:3139; TTree::fFileNumberInt_t fFileNumber! current file number (if file extensions)Definition TTree.h:116; TTree::GetLeafvirtual TLeaf * GetLeaf(const char *",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:461206,Modifiability,variab,variable,461206,"ay be called after having filled some entries in a Tree.Definition TTree.cxx:7057; TTree::Projectvirtual Long64_t Project(const char *hname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Make a projection of a tree using selections.Definition TTree.cxx:7498; TTree::SetCacheEntryRangevirtual Int_t SetCacheEntryRange(Long64_t first, Long64_t last)interface to TTreeCache to set the cache entry rangeDefinition TTree.cxx:8831; TTree::GetMaxTreeSizestatic Long64_t GetMaxTreeSize()Static function which returns the tree file size limit in bytes.Definition TTree.cxx:6265; TTree::fCacheDoClusterPrefetchbool fCacheDoClusterPrefetch! true if cache is prefetching whole clustersDefinition TTree.h:140; TTree::SetBranchAddressImpInt_t SetBranchAddressImp(TBranch *branch, void *addr, TBranch **ptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8445; TTree::SetAliasvirtual bool SetAlias(const char *aliasName, const char *aliasFormula)Set a tree variable alias.Definition TTree.cxx:8141; TTree::CopyAddressesvirtual void CopyAddresses(TTree *, bool undo=false)Set branch addresses of passed tree equal to ours.Definition TTree.cxx:3299; TTree::fMaxEntriesLong64_t fMaxEntriesMaximum number of entries in case of circular buffers.Definition TTree.h:97; TTree::DropBuffersvirtual void DropBuffers(Int_t nbytes)Drop branch buffers to accommodate nbytes below MaxVirtualsize.Definition TTree.cxx:4531; TTree::GetListOfFriendsvirtual TList * GetListOfFriends() constDefinition TTree.h:530; TTree::Refreshvirtual void Refresh()Refresh contents of this tree and its branches from the current status on disk.Definition TTree.cxx:7916; TTree::SetAutoFlushvirtual void SetAutoFlush(Long64_t autof=-30000000)This function may be called at the start of a program to change the default value for fAutoFlush.Definition TTree.cxx:8196; TTree::fgMaxTreeSizestatic Long64_t fgMaxTreeSizeMaximum size of a file containi",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:469585,Modifiability,plugin,plugins,469585,"erface for Tree Index.Definition TVirtualIndex.h:30; TVirtualIndex::GetMajorNamevirtual const char * GetMajorName() const =0; TVirtualIndex::GetEntryNumberWithIndexvirtual Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const =0; TVirtualIndex::GetEntryNumberFriendvirtual Long64_t GetEntryNumberFriend(const TTree *)=0; TVirtualIndex::Appendvirtual void Append(const TVirtualIndex *, bool delaySort=false)=0; TVirtualIndex::GetMinorNamevirtual const char * GetMinorName() const =0; TVirtualIndex::SetTreevirtual void SetTree(TTree *T)=0; TVirtualIndex::GetNvirtual Long64_t GetN() const =0; TVirtualIndex::IsValidForvirtual bool IsValidFor(const TTree *parent)=0; TVirtualIndex::GetEntryNumberWithBestIndexvirtual Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const =0; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; TVirtualTreePlayerAbstract base class defining the interface for the plugins that implement Draw, Scan,...Definition TVirtualTreePlayer.h:38; TVirtualTreePlayer::Scanvirtual Long64_t Scan(const char *varexp, const char *selection, Option_t *option, Long64_t nentries, Long64_t firstentry)=0; TVirtualTreePlayer::UpdateFormulaLeavesvirtual void UpdateFormulaLeaves()=0; TVirtualTreePlayer::DrawSelectvirtual Long64_t DrawSelect(const char *varexp, const char *selection, Option_t *option, Long64_t nentries, Long64_t firstentry)=0; TVirtualTreePlayer::MakeCodevirtual Int_t MakeCode(const char *filename)=0; TVirtualTreePlayer::UnbinnedFitvirtual Int_t UnbinnedFit(const char *formula, const char *varexp, const char *selection, Option_t *option, Long64_t nentries, Long64_t firstentry)=0; TVirtualTreePlayer::GetEntriesvirtual Long64_t GetEntries(const char *)=0; TVirtualTreePlayer::MakeProxyvirtual Int_t MakeProxy(const char *classname, const char *macrofilename=nullptr, const char *cutfilename=nullptr, const char *option=nullptr, Int_t maxUnro",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:474292,Modifiability,inherit,inherited,474292,".h:33; ROOT::kSTLmultimap@ kSTLmultimapDefinition ESTLType.h:34; ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; ROOT::ToHumanReadableSizevoid ToHumanReadableSize(value_type bytes, Bool_t si, Double_t *coeff, const char **units)Return the size expressed in 'human readable' format.Definition StringConv.hxx:38; ROOT::FromHumanReadableSizeEFromHumanReadableSize FromHumanReadableSize(std::string_view str, T &value)Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB,...Definition StringConv.hxx:86; ROOT::EFromHumanReadableSize::kParseFail@ kParseFail; ROOT::EFromHumanReadableSize::kOverflow@ kOverflow; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::MedianDouble_t Median(Long64_t n, const T *a, const Double_t *w=nullptr, Long64_t *work=nullptr)Same as RMS.Definition TMath.h:1272; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::BinarySearchLong64_t BinarySearch(Long64_t n, const T *array, T value)Binary search in an array of n values to locate value.Definition TMathBase.h:347; slashTCanvas * slash()Definition slash.C:1; ROOT::RCompressionSetting::EAlgorithm::kUseGlobal@ kUseGlobalUse the global compression algorithm.Definition Compression.h:93; ROOT::RCompressionSetting::EAlgorithm::kInherit@ kInheritSome objects use this value to denote that the compression algorithm should be inherited from the par...Definition Compression.h:91; ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault@ kUseCompiledDefaultUse the compile-time default setting.Definition Compression.h:53; Drawth1 Draw(); mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4. treetreesrcTTree.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:05 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:1005,Performance,optimiz,optimized,1005," ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TTree.cxx. Go to the documentation of this file. 1// @(#)root/tree:$Id$; 2// Author: Rene Brun 12/01/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11/**; 12 \defgroup tree Tree Library; 13 ; 14 In order to store columnar datasets, ROOT provides the TTree, TChain,; 15 TNtuple and TNtupleD classes.; 16 The TTree class represents a columnar dataset. Any C++ type can be stored in the; 17 columns. The TTree has allowed to store about **1 EB** of data coming from the LHC alone:; 18 it is demonstrated to scale and it's battle tested. It has been optimized during the years; 19 to reduce dataset sizes on disk and to deliver excellent runtime performance.; 20 It allows to access only part of the columns of the datasets, too.; 21 The TNtuple and TNtupleD classes are specialisations of the TTree class which can; 22 only hold single precision and double precision floating-point numbers respectively;; 23 The TChain is a collection of TTrees, which can be located also in different files.; 24 ; 25*/; 26 ; 27/** \class TTree; 28\ingroup tree; 29 ; 30A TTree represents a columnar dataset. Any C++ type can be stored in its columns.; 31 ; 32A TTree, often called in jargon *tree*, consists of a list of independent columns or *branches*,; 33represented by the TBranch class.; 34Behind each branch, buffers are allocated automatically by ROOT.; 35Such buffers are automatically written to disk or kept in memory until the size stored in the; 36attribute fMaxVirtualSize is reached.; 37Variables of one branch are written to the same buffer. A branch buffer is; 38automatically compressed if the f",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:1101,Performance,perform,performance,1101," ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TTree.cxx. Go to the documentation of this file. 1// @(#)root/tree:$Id$; 2// Author: Rene Brun 12/01/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11/**; 12 \defgroup tree Tree Library; 13 ; 14 In order to store columnar datasets, ROOT provides the TTree, TChain,; 15 TNtuple and TNtupleD classes.; 16 The TTree class represents a columnar dataset. Any C++ type can be stored in the; 17 columns. The TTree has allowed to store about **1 EB** of data coming from the LHC alone:; 18 it is demonstrated to scale and it's battle tested. It has been optimized during the years; 19 to reduce dataset sizes on disk and to deliver excellent runtime performance.; 20 It allows to access only part of the columns of the datasets, too.; 21 The TNtuple and TNtupleD classes are specialisations of the TTree class which can; 22 only hold single precision and double precision floating-point numbers respectively;; 23 The TChain is a collection of TTrees, which can be located also in different files.; 24 ; 25*/; 26 ; 27/** \class TTree; 28\ingroup tree; 29 ; 30A TTree represents a columnar dataset. Any C++ type can be stored in its columns.; 31 ; 32A TTree, often called in jargon *tree*, consists of a list of independent columns or *branches*,; 33represented by the TBranch class.; 34Behind each branch, buffers are allocated automatically by ROOT.; 35Such buffers are automatically written to disk or kept in memory until the size stored in the; 36attribute fMaxVirtualSize is reached.; 37Variables of one branch are written to the same buffer. A branch buffer is; 38automatically compressed if the f",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:20202,Performance,multi-thread,multi-thread,20202," 480 case kLong_t: return 'G';; 481 case kULong_t: return 'g';; 482 case kchar: return 0; // unsupported; 483 case kLong64_t: return 'L';; 484 case kULong64_t: return 'l';; 485 ; 486 case kCharStar: return 'C';; 487 case kBits: return 0; //unsupported; 488 ; 489 case kOther_t:; 490 case kNoType_t:; 491 default:; 492 return 0;; 493 }; 494 return 0;; 495}; 496 ; 497////////////////////////////////////////////////////////////////////////////////; 498/// \class TTree::TFriendLock; 499/// Helper class to prevent infinite recursion in the usage of TTree Friends.; 500 ; 501////////////////////////////////////////////////////////////////////////////////; 502/// Record in tree that it has been used while recursively looks through the friends.; 503 ; 504TTree::TFriendLock::TFriendLock(TTree* tree, UInt_t methodbit); 505: fTree(tree); 506{; 507 // We could also add some code to acquire an actual; 508 // lock to prevent multi-thread issues; 509 fMethodBit = methodbit;; 510 if (fTree) {; 511 fPrevious = fTree->fFriendLockStatus & fMethodBit;; 512 fTree->fFriendLockStatus |= fMethodBit;; 513 } else {; 514 fPrevious = false;; 515 }; 516}; 517 ; 518////////////////////////////////////////////////////////////////////////////////; 519/// Copy constructor.; 520 ; 521TTree::TFriendLock::TFriendLock(const TFriendLock& tfl) :; 522 fTree(tfl.fTree),; 523 fMethodBit(tfl.fMethodBit),; 524 fPrevious(tfl.fPrevious); 525{; 526}; 527 ; 528////////////////////////////////////////////////////////////////////////////////; 529/// Assignment operator.; 530 ; 531TTree::TFriendLock& TTree::TFriendLock::operator=(const TTree::TFriendLock& tfl); 532{; 533 if(this!=&tfl) {; 534 fTree=tfl.fTree;; 535 fMethodBit=tfl.fMethodBit;; 536 fPrevious=tfl.fPrevious;; 537 }; 538 return *this;; 539}; 540 ; 541////////////////////////////////////////////////////////////////////////////////; 542/// Restore the state of tree the same as before we set the lock.; 543 ; 544TTree::TFriendLock::~TFriendLock(); 545{; 546 if (",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:23800,Performance,cache,cache,23800,"81 if (fClusterRange == fTree->fNClusterRange) {; 582 autoflush = fTree->fAutoFlush;; 583 } else {; 584 autoflush = fTree->fClusterSize[fClusterRange];; 585 }; 586 if (autoflush <= 0) {; 587 autoflush = GetEstimatedClusterSize();; 588 }; 589 fStartEntry = pedestal + entryInRange - entryInRange%autoflush;; 590 } else if ( fTree->GetAutoFlush() <= 0 ) {; 591 // Case of old files before November 9 2009 *or* small tree where AutoFlush was never set.; 592 fStartEntry = firstEntry;; 593 } else {; 594 fStartEntry = firstEntry - firstEntry%fTree->GetAutoFlush();; 595 }; 596 fNextEntry = fStartEntry; // Position correctly for the first call to Next(); 597}; 598 ; 599////////////////////////////////////////////////////////////////////////////////; 600/// Estimate the cluster size.; 601///; 602/// In almost all cases, this quickly returns the size of the auto-flush; 603/// in the TTree.; 604///; 605/// However, in the case where the cluster size was not fixed (old files and; 606/// case where autoflush was explicitly set to zero), we need estimate; 607/// a cluster size in relation to the size of the cache.; 608///; 609/// After this value is calculated once for the TClusterIterator, it is; 610/// cached and reused in future calls.; 611 ; 612Long64_t TTree::TClusterIterator::GetEstimatedClusterSize(); 613{; 614 auto autoFlush = fTree->GetAutoFlush();; 615 if (autoFlush > 0) return autoFlush;; 616 if (fEstimatedSize > 0) return fEstimatedSize;; 617 ; 618 Long64_t zipBytes = fTree->GetZipBytes();; 619 if (zipBytes == 0) {; 620 fEstimatedSize = fTree->GetEntries() - 1;; 621 if (fEstimatedSize <= 0); 622 fEstimatedSize = 1;; 623 } else {; 624 Long64_t clusterEstimate = 1;; 625 Long64_t cacheSize = fTree->GetCacheSize();; 626 if (cacheSize == 0) {; 627 // Humm ... let's double check on the file.; 628 TFile *file = fTree->GetCurrentFile();; 629 if (file) {; 630 TFileCacheRead *cache = fTree->GetReadCache(file);; 631 if (cache) {; 632 cacheSize = cache->GetBufferSize();; 633 }; 634 };",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:23899,Performance,cache,cached,23899,"h <= 0) {; 587 autoflush = GetEstimatedClusterSize();; 588 }; 589 fStartEntry = pedestal + entryInRange - entryInRange%autoflush;; 590 } else if ( fTree->GetAutoFlush() <= 0 ) {; 591 // Case of old files before November 9 2009 *or* small tree where AutoFlush was never set.; 592 fStartEntry = firstEntry;; 593 } else {; 594 fStartEntry = firstEntry - firstEntry%fTree->GetAutoFlush();; 595 }; 596 fNextEntry = fStartEntry; // Position correctly for the first call to Next(); 597}; 598 ; 599////////////////////////////////////////////////////////////////////////////////; 600/// Estimate the cluster size.; 601///; 602/// In almost all cases, this quickly returns the size of the auto-flush; 603/// in the TTree.; 604///; 605/// However, in the case where the cluster size was not fixed (old files and; 606/// case where autoflush was explicitly set to zero), we need estimate; 607/// a cluster size in relation to the size of the cache.; 608///; 609/// After this value is calculated once for the TClusterIterator, it is; 610/// cached and reused in future calls.; 611 ; 612Long64_t TTree::TClusterIterator::GetEstimatedClusterSize(); 613{; 614 auto autoFlush = fTree->GetAutoFlush();; 615 if (autoFlush > 0) return autoFlush;; 616 if (fEstimatedSize > 0) return fEstimatedSize;; 617 ; 618 Long64_t zipBytes = fTree->GetZipBytes();; 619 if (zipBytes == 0) {; 620 fEstimatedSize = fTree->GetEntries() - 1;; 621 if (fEstimatedSize <= 0); 622 fEstimatedSize = 1;; 623 } else {; 624 Long64_t clusterEstimate = 1;; 625 Long64_t cacheSize = fTree->GetCacheSize();; 626 if (cacheSize == 0) {; 627 // Humm ... let's double check on the file.; 628 TFile *file = fTree->GetCurrentFile();; 629 if (file) {; 630 TFileCacheRead *cache = fTree->GetReadCache(file);; 631 if (cache) {; 632 cacheSize = cache->GetBufferSize();; 633 }; 634 }; 635 }; 636 // If neither file nor tree has a cache, use the current default.; 637 if (cacheSize <= 0) {; 638 cacheSize = 30000000;; 639 }; 640 clusterEstimate = fTree->GetEntr",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:24393,Performance,cache,cacheSize,24393,"try = firstEntry - firstEntry%fTree->GetAutoFlush();; 595 }; 596 fNextEntry = fStartEntry; // Position correctly for the first call to Next(); 597}; 598 ; 599////////////////////////////////////////////////////////////////////////////////; 600/// Estimate the cluster size.; 601///; 602/// In almost all cases, this quickly returns the size of the auto-flush; 603/// in the TTree.; 604///; 605/// However, in the case where the cluster size was not fixed (old files and; 606/// case where autoflush was explicitly set to zero), we need estimate; 607/// a cluster size in relation to the size of the cache.; 608///; 609/// After this value is calculated once for the TClusterIterator, it is; 610/// cached and reused in future calls.; 611 ; 612Long64_t TTree::TClusterIterator::GetEstimatedClusterSize(); 613{; 614 auto autoFlush = fTree->GetAutoFlush();; 615 if (autoFlush > 0) return autoFlush;; 616 if (fEstimatedSize > 0) return fEstimatedSize;; 617 ; 618 Long64_t zipBytes = fTree->GetZipBytes();; 619 if (zipBytes == 0) {; 620 fEstimatedSize = fTree->GetEntries() - 1;; 621 if (fEstimatedSize <= 0); 622 fEstimatedSize = 1;; 623 } else {; 624 Long64_t clusterEstimate = 1;; 625 Long64_t cacheSize = fTree->GetCacheSize();; 626 if (cacheSize == 0) {; 627 // Humm ... let's double check on the file.; 628 TFile *file = fTree->GetCurrentFile();; 629 if (file) {; 630 TFileCacheRead *cache = fTree->GetReadCache(file);; 631 if (cache) {; 632 cacheSize = cache->GetBufferSize();; 633 }; 634 }; 635 }; 636 // If neither file nor tree has a cache, use the current default.; 637 if (cacheSize <= 0) {; 638 cacheSize = 30000000;; 639 }; 640 clusterEstimate = fTree->GetEntries() * cacheSize / zipBytes;; 641 // If there are no entries, then just default to 1.; 642 fEstimatedSize = clusterEstimate ? clusterEstimate : 1;; 643 }; 644 return fEstimatedSize;; 645}; 646 ; 647////////////////////////////////////////////////////////////////////////////////; 648/// Move on to the next cluster and return the ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:24437,Performance,cache,cacheSize,24437,"try = firstEntry - firstEntry%fTree->GetAutoFlush();; 595 }; 596 fNextEntry = fStartEntry; // Position correctly for the first call to Next(); 597}; 598 ; 599////////////////////////////////////////////////////////////////////////////////; 600/// Estimate the cluster size.; 601///; 602/// In almost all cases, this quickly returns the size of the auto-flush; 603/// in the TTree.; 604///; 605/// However, in the case where the cluster size was not fixed (old files and; 606/// case where autoflush was explicitly set to zero), we need estimate; 607/// a cluster size in relation to the size of the cache.; 608///; 609/// After this value is calculated once for the TClusterIterator, it is; 610/// cached and reused in future calls.; 611 ; 612Long64_t TTree::TClusterIterator::GetEstimatedClusterSize(); 613{; 614 auto autoFlush = fTree->GetAutoFlush();; 615 if (autoFlush > 0) return autoFlush;; 616 if (fEstimatedSize > 0) return fEstimatedSize;; 617 ; 618 Long64_t zipBytes = fTree->GetZipBytes();; 619 if (zipBytes == 0) {; 620 fEstimatedSize = fTree->GetEntries() - 1;; 621 if (fEstimatedSize <= 0); 622 fEstimatedSize = 1;; 623 } else {; 624 Long64_t clusterEstimate = 1;; 625 Long64_t cacheSize = fTree->GetCacheSize();; 626 if (cacheSize == 0) {; 627 // Humm ... let's double check on the file.; 628 TFile *file = fTree->GetCurrentFile();; 629 if (file) {; 630 TFileCacheRead *cache = fTree->GetReadCache(file);; 631 if (cache) {; 632 cacheSize = cache->GetBufferSize();; 633 }; 634 }; 635 }; 636 // If neither file nor tree has a cache, use the current default.; 637 if (cacheSize <= 0) {; 638 cacheSize = 30000000;; 639 }; 640 clusterEstimate = fTree->GetEntries() * cacheSize / zipBytes;; 641 // If there are no entries, then just default to 1.; 642 fEstimatedSize = clusterEstimate ? clusterEstimate : 1;; 643 }; 644 return fEstimatedSize;; 645}; 646 ; 647////////////////////////////////////////////////////////////////////////////////; 648/// Move on to the next cluster and return the ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:24586,Performance,cache,cache,24586,"size was not fixed (old files and; 606/// case where autoflush was explicitly set to zero), we need estimate; 607/// a cluster size in relation to the size of the cache.; 608///; 609/// After this value is calculated once for the TClusterIterator, it is; 610/// cached and reused in future calls.; 611 ; 612Long64_t TTree::TClusterIterator::GetEstimatedClusterSize(); 613{; 614 auto autoFlush = fTree->GetAutoFlush();; 615 if (autoFlush > 0) return autoFlush;; 616 if (fEstimatedSize > 0) return fEstimatedSize;; 617 ; 618 Long64_t zipBytes = fTree->GetZipBytes();; 619 if (zipBytes == 0) {; 620 fEstimatedSize = fTree->GetEntries() - 1;; 621 if (fEstimatedSize <= 0); 622 fEstimatedSize = 1;; 623 } else {; 624 Long64_t clusterEstimate = 1;; 625 Long64_t cacheSize = fTree->GetCacheSize();; 626 if (cacheSize == 0) {; 627 // Humm ... let's double check on the file.; 628 TFile *file = fTree->GetCurrentFile();; 629 if (file) {; 630 TFileCacheRead *cache = fTree->GetReadCache(file);; 631 if (cache) {; 632 cacheSize = cache->GetBufferSize();; 633 }; 634 }; 635 }; 636 // If neither file nor tree has a cache, use the current default.; 637 if (cacheSize <= 0) {; 638 cacheSize = 30000000;; 639 }; 640 clusterEstimate = fTree->GetEntries() * cacheSize / zipBytes;; 641 // If there are no entries, then just default to 1.; 642 fEstimatedSize = clusterEstimate ? clusterEstimate : 1;; 643 }; 644 return fEstimatedSize;; 645}; 646 ; 647////////////////////////////////////////////////////////////////////////////////; 648/// Move on to the next cluster and return the starting entry; 649/// of this next cluster; 650 ; 651Long64_t TTree::TClusterIterator::Next(); 652{; 653 fStartEntry = fNextEntry;; 654 if (fTree->fNClusterRange || fTree->GetAutoFlush() > 0) {; 655 if (fClusterRange == fTree->fNClusterRange) {; 656 // We are looking at a range which size; 657 // is defined by AutoFlush itself and goes to the GetEntries.; 658 fNextEntry += GetEstimatedClusterSize();; 659 } else {; 660 if (fStartEnt",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:24630,Performance,cache,cache,24630,"size was not fixed (old files and; 606/// case where autoflush was explicitly set to zero), we need estimate; 607/// a cluster size in relation to the size of the cache.; 608///; 609/// After this value is calculated once for the TClusterIterator, it is; 610/// cached and reused in future calls.; 611 ; 612Long64_t TTree::TClusterIterator::GetEstimatedClusterSize(); 613{; 614 auto autoFlush = fTree->GetAutoFlush();; 615 if (autoFlush > 0) return autoFlush;; 616 if (fEstimatedSize > 0) return fEstimatedSize;; 617 ; 618 Long64_t zipBytes = fTree->GetZipBytes();; 619 if (zipBytes == 0) {; 620 fEstimatedSize = fTree->GetEntries() - 1;; 621 if (fEstimatedSize <= 0); 622 fEstimatedSize = 1;; 623 } else {; 624 Long64_t clusterEstimate = 1;; 625 Long64_t cacheSize = fTree->GetCacheSize();; 626 if (cacheSize == 0) {; 627 // Humm ... let's double check on the file.; 628 TFile *file = fTree->GetCurrentFile();; 629 if (file) {; 630 TFileCacheRead *cache = fTree->GetReadCache(file);; 631 if (cache) {; 632 cacheSize = cache->GetBufferSize();; 633 }; 634 }; 635 }; 636 // If neither file nor tree has a cache, use the current default.; 637 if (cacheSize <= 0) {; 638 cacheSize = 30000000;; 639 }; 640 clusterEstimate = fTree->GetEntries() * cacheSize / zipBytes;; 641 // If there are no entries, then just default to 1.; 642 fEstimatedSize = clusterEstimate ? clusterEstimate : 1;; 643 }; 644 return fEstimatedSize;; 645}; 646 ; 647////////////////////////////////////////////////////////////////////////////////; 648/// Move on to the next cluster and return the starting entry; 649/// of this next cluster; 650 ; 651Long64_t TTree::TClusterIterator::Next(); 652{; 653 fStartEntry = fNextEntry;; 654 if (fTree->fNClusterRange || fTree->GetAutoFlush() > 0) {; 655 if (fClusterRange == fTree->fNClusterRange) {; 656 // We are looking at a range which size; 657 // is defined by AutoFlush itself and goes to the GetEntries.; 658 fNextEntry += GetEstimatedClusterSize();; 659 } else {; 660 if (fStartEnt",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:24644,Performance,cache,cacheSize,24644,"size was not fixed (old files and; 606/// case where autoflush was explicitly set to zero), we need estimate; 607/// a cluster size in relation to the size of the cache.; 608///; 609/// After this value is calculated once for the TClusterIterator, it is; 610/// cached and reused in future calls.; 611 ; 612Long64_t TTree::TClusterIterator::GetEstimatedClusterSize(); 613{; 614 auto autoFlush = fTree->GetAutoFlush();; 615 if (autoFlush > 0) return autoFlush;; 616 if (fEstimatedSize > 0) return fEstimatedSize;; 617 ; 618 Long64_t zipBytes = fTree->GetZipBytes();; 619 if (zipBytes == 0) {; 620 fEstimatedSize = fTree->GetEntries() - 1;; 621 if (fEstimatedSize <= 0); 622 fEstimatedSize = 1;; 623 } else {; 624 Long64_t clusterEstimate = 1;; 625 Long64_t cacheSize = fTree->GetCacheSize();; 626 if (cacheSize == 0) {; 627 // Humm ... let's double check on the file.; 628 TFile *file = fTree->GetCurrentFile();; 629 if (file) {; 630 TFileCacheRead *cache = fTree->GetReadCache(file);; 631 if (cache) {; 632 cacheSize = cache->GetBufferSize();; 633 }; 634 }; 635 }; 636 // If neither file nor tree has a cache, use the current default.; 637 if (cacheSize <= 0) {; 638 cacheSize = 30000000;; 639 }; 640 clusterEstimate = fTree->GetEntries() * cacheSize / zipBytes;; 641 // If there are no entries, then just default to 1.; 642 fEstimatedSize = clusterEstimate ? clusterEstimate : 1;; 643 }; 644 return fEstimatedSize;; 645}; 646 ; 647////////////////////////////////////////////////////////////////////////////////; 648/// Move on to the next cluster and return the starting entry; 649/// of this next cluster; 650 ; 651Long64_t TTree::TClusterIterator::Next(); 652{; 653 fStartEntry = fNextEntry;; 654 if (fTree->fNClusterRange || fTree->GetAutoFlush() > 0) {; 655 if (fClusterRange == fTree->fNClusterRange) {; 656 // We are looking at a range which size; 657 // is defined by AutoFlush itself and goes to the GetEntries.; 658 fNextEntry += GetEstimatedClusterSize();; 659 } else {; 660 if (fStartEnt",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:24656,Performance,cache,cache,24656,"size was not fixed (old files and; 606/// case where autoflush was explicitly set to zero), we need estimate; 607/// a cluster size in relation to the size of the cache.; 608///; 609/// After this value is calculated once for the TClusterIterator, it is; 610/// cached and reused in future calls.; 611 ; 612Long64_t TTree::TClusterIterator::GetEstimatedClusterSize(); 613{; 614 auto autoFlush = fTree->GetAutoFlush();; 615 if (autoFlush > 0) return autoFlush;; 616 if (fEstimatedSize > 0) return fEstimatedSize;; 617 ; 618 Long64_t zipBytes = fTree->GetZipBytes();; 619 if (zipBytes == 0) {; 620 fEstimatedSize = fTree->GetEntries() - 1;; 621 if (fEstimatedSize <= 0); 622 fEstimatedSize = 1;; 623 } else {; 624 Long64_t clusterEstimate = 1;; 625 Long64_t cacheSize = fTree->GetCacheSize();; 626 if (cacheSize == 0) {; 627 // Humm ... let's double check on the file.; 628 TFile *file = fTree->GetCurrentFile();; 629 if (file) {; 630 TFileCacheRead *cache = fTree->GetReadCache(file);; 631 if (cache) {; 632 cacheSize = cache->GetBufferSize();; 633 }; 634 }; 635 }; 636 // If neither file nor tree has a cache, use the current default.; 637 if (cacheSize <= 0) {; 638 cacheSize = 30000000;; 639 }; 640 clusterEstimate = fTree->GetEntries() * cacheSize / zipBytes;; 641 // If there are no entries, then just default to 1.; 642 fEstimatedSize = clusterEstimate ? clusterEstimate : 1;; 643 }; 644 return fEstimatedSize;; 645}; 646 ; 647////////////////////////////////////////////////////////////////////////////////; 648/// Move on to the next cluster and return the starting entry; 649/// of this next cluster; 650 ; 651Long64_t TTree::TClusterIterator::Next(); 652{; 653 fStartEntry = fNextEntry;; 654 if (fTree->fNClusterRange || fTree->GetAutoFlush() > 0) {; 655 if (fClusterRange == fTree->fNClusterRange) {; 656 // We are looking at a range which size; 657 // is defined by AutoFlush itself and goes to the GetEntries.; 658 fNextEntry += GetEstimatedClusterSize();; 659 } else {; 660 if (fStartEnt",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:24740,Performance,cache,cache,24740,"size was not fixed (old files and; 606/// case where autoflush was explicitly set to zero), we need estimate; 607/// a cluster size in relation to the size of the cache.; 608///; 609/// After this value is calculated once for the TClusterIterator, it is; 610/// cached and reused in future calls.; 611 ; 612Long64_t TTree::TClusterIterator::GetEstimatedClusterSize(); 613{; 614 auto autoFlush = fTree->GetAutoFlush();; 615 if (autoFlush > 0) return autoFlush;; 616 if (fEstimatedSize > 0) return fEstimatedSize;; 617 ; 618 Long64_t zipBytes = fTree->GetZipBytes();; 619 if (zipBytes == 0) {; 620 fEstimatedSize = fTree->GetEntries() - 1;; 621 if (fEstimatedSize <= 0); 622 fEstimatedSize = 1;; 623 } else {; 624 Long64_t clusterEstimate = 1;; 625 Long64_t cacheSize = fTree->GetCacheSize();; 626 if (cacheSize == 0) {; 627 // Humm ... let's double check on the file.; 628 TFile *file = fTree->GetCurrentFile();; 629 if (file) {; 630 TFileCacheRead *cache = fTree->GetReadCache(file);; 631 if (cache) {; 632 cacheSize = cache->GetBufferSize();; 633 }; 634 }; 635 }; 636 // If neither file nor tree has a cache, use the current default.; 637 if (cacheSize <= 0) {; 638 cacheSize = 30000000;; 639 }; 640 clusterEstimate = fTree->GetEntries() * cacheSize / zipBytes;; 641 // If there are no entries, then just default to 1.; 642 fEstimatedSize = clusterEstimate ? clusterEstimate : 1;; 643 }; 644 return fEstimatedSize;; 645}; 646 ; 647////////////////////////////////////////////////////////////////////////////////; 648/// Move on to the next cluster and return the starting entry; 649/// of this next cluster; 650 ; 651Long64_t TTree::TClusterIterator::Next(); 652{; 653 fStartEntry = fNextEntry;; 654 if (fTree->fNClusterRange || fTree->GetAutoFlush() > 0) {; 655 if (fClusterRange == fTree->fNClusterRange) {; 656 // We are looking at a range which size; 657 // is defined by AutoFlush itself and goes to the GetEntries.; 658 fNextEntry += GetEstimatedClusterSize();; 659 } else {; 660 if (fStartEnt",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:24781,Performance,cache,cacheSize,24781,"the TClusterIterator, it is; 610/// cached and reused in future calls.; 611 ; 612Long64_t TTree::TClusterIterator::GetEstimatedClusterSize(); 613{; 614 auto autoFlush = fTree->GetAutoFlush();; 615 if (autoFlush > 0) return autoFlush;; 616 if (fEstimatedSize > 0) return fEstimatedSize;; 617 ; 618 Long64_t zipBytes = fTree->GetZipBytes();; 619 if (zipBytes == 0) {; 620 fEstimatedSize = fTree->GetEntries() - 1;; 621 if (fEstimatedSize <= 0); 622 fEstimatedSize = 1;; 623 } else {; 624 Long64_t clusterEstimate = 1;; 625 Long64_t cacheSize = fTree->GetCacheSize();; 626 if (cacheSize == 0) {; 627 // Humm ... let's double check on the file.; 628 TFile *file = fTree->GetCurrentFile();; 629 if (file) {; 630 TFileCacheRead *cache = fTree->GetReadCache(file);; 631 if (cache) {; 632 cacheSize = cache->GetBufferSize();; 633 }; 634 }; 635 }; 636 // If neither file nor tree has a cache, use the current default.; 637 if (cacheSize <= 0) {; 638 cacheSize = 30000000;; 639 }; 640 clusterEstimate = fTree->GetEntries() * cacheSize / zipBytes;; 641 // If there are no entries, then just default to 1.; 642 fEstimatedSize = clusterEstimate ? clusterEstimate : 1;; 643 }; 644 return fEstimatedSize;; 645}; 646 ; 647////////////////////////////////////////////////////////////////////////////////; 648/// Move on to the next cluster and return the starting entry; 649/// of this next cluster; 650 ; 651Long64_t TTree::TClusterIterator::Next(); 652{; 653 fStartEntry = fNextEntry;; 654 if (fTree->fNClusterRange || fTree->GetAutoFlush() > 0) {; 655 if (fClusterRange == fTree->fNClusterRange) {; 656 // We are looking at a range which size; 657 // is defined by AutoFlush itself and goes to the GetEntries.; 658 fNextEntry += GetEstimatedClusterSize();; 659 } else {; 660 if (fStartEntry > fTree->fClusterRangeEnd[fClusterRange]) {; 661 ++fClusterRange;; 662 }; 663 if (fClusterRange == fTree->fNClusterRange) {; 664 // We are looking at the last range which size; 665 // is defined by AutoFlush itself and goes ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:24804,Performance,cache,cacheSize,24804,"the TClusterIterator, it is; 610/// cached and reused in future calls.; 611 ; 612Long64_t TTree::TClusterIterator::GetEstimatedClusterSize(); 613{; 614 auto autoFlush = fTree->GetAutoFlush();; 615 if (autoFlush > 0) return autoFlush;; 616 if (fEstimatedSize > 0) return fEstimatedSize;; 617 ; 618 Long64_t zipBytes = fTree->GetZipBytes();; 619 if (zipBytes == 0) {; 620 fEstimatedSize = fTree->GetEntries() - 1;; 621 if (fEstimatedSize <= 0); 622 fEstimatedSize = 1;; 623 } else {; 624 Long64_t clusterEstimate = 1;; 625 Long64_t cacheSize = fTree->GetCacheSize();; 626 if (cacheSize == 0) {; 627 // Humm ... let's double check on the file.; 628 TFile *file = fTree->GetCurrentFile();; 629 if (file) {; 630 TFileCacheRead *cache = fTree->GetReadCache(file);; 631 if (cache) {; 632 cacheSize = cache->GetBufferSize();; 633 }; 634 }; 635 }; 636 // If neither file nor tree has a cache, use the current default.; 637 if (cacheSize <= 0) {; 638 cacheSize = 30000000;; 639 }; 640 clusterEstimate = fTree->GetEntries() * cacheSize / zipBytes;; 641 // If there are no entries, then just default to 1.; 642 fEstimatedSize = clusterEstimate ? clusterEstimate : 1;; 643 }; 644 return fEstimatedSize;; 645}; 646 ; 647////////////////////////////////////////////////////////////////////////////////; 648/// Move on to the next cluster and return the starting entry; 649/// of this next cluster; 650 ; 651Long64_t TTree::TClusterIterator::Next(); 652{; 653 fStartEntry = fNextEntry;; 654 if (fTree->fNClusterRange || fTree->GetAutoFlush() > 0) {; 655 if (fClusterRange == fTree->fNClusterRange) {; 656 // We are looking at a range which size; 657 // is defined by AutoFlush itself and goes to the GetEntries.; 658 fNextEntry += GetEstimatedClusterSize();; 659 } else {; 660 if (fStartEntry > fTree->fClusterRangeEnd[fClusterRange]) {; 661 ++fClusterRange;; 662 }; 663 if (fClusterRange == fTree->fNClusterRange) {; 664 // We are looking at the last range which size; 665 // is defined by AutoFlush itself and goes ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:24878,Performance,cache,cacheSize,24878,"the TClusterIterator, it is; 610/// cached and reused in future calls.; 611 ; 612Long64_t TTree::TClusterIterator::GetEstimatedClusterSize(); 613{; 614 auto autoFlush = fTree->GetAutoFlush();; 615 if (autoFlush > 0) return autoFlush;; 616 if (fEstimatedSize > 0) return fEstimatedSize;; 617 ; 618 Long64_t zipBytes = fTree->GetZipBytes();; 619 if (zipBytes == 0) {; 620 fEstimatedSize = fTree->GetEntries() - 1;; 621 if (fEstimatedSize <= 0); 622 fEstimatedSize = 1;; 623 } else {; 624 Long64_t clusterEstimate = 1;; 625 Long64_t cacheSize = fTree->GetCacheSize();; 626 if (cacheSize == 0) {; 627 // Humm ... let's double check on the file.; 628 TFile *file = fTree->GetCurrentFile();; 629 if (file) {; 630 TFileCacheRead *cache = fTree->GetReadCache(file);; 631 if (cache) {; 632 cacheSize = cache->GetBufferSize();; 633 }; 634 }; 635 }; 636 // If neither file nor tree has a cache, use the current default.; 637 if (cacheSize <= 0) {; 638 cacheSize = 30000000;; 639 }; 640 clusterEstimate = fTree->GetEntries() * cacheSize / zipBytes;; 641 // If there are no entries, then just default to 1.; 642 fEstimatedSize = clusterEstimate ? clusterEstimate : 1;; 643 }; 644 return fEstimatedSize;; 645}; 646 ; 647////////////////////////////////////////////////////////////////////////////////; 648/// Move on to the next cluster and return the starting entry; 649/// of this next cluster; 650 ; 651Long64_t TTree::TClusterIterator::Next(); 652{; 653 fStartEntry = fNextEntry;; 654 if (fTree->fNClusterRange || fTree->GetAutoFlush() > 0) {; 655 if (fClusterRange == fTree->fNClusterRange) {; 656 // We are looking at a range which size; 657 // is defined by AutoFlush itself and goes to the GetEntries.; 658 fNextEntry += GetEstimatedClusterSize();; 659 } else {; 660 if (fStartEntry > fTree->fClusterRangeEnd[fClusterRange]) {; 661 ++fClusterRange;; 662 }; 663 if (fClusterRange == fTree->fNClusterRange) {; 664 // We are looking at the last range which size; 665 // is defined by AutoFlush itself and goes ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:33483,Performance,load,load,33483,"xEntryLoop = 1000000000;; 898 fMaxEntryLoop *= 1000;; 899 ; 900 // Insert ourself into the current directory.; 901 // FIXME: This is very annoying behaviour, we should; 902 // be able to choose to not do this like we; 903 // can with a histogram.; 904 if (fDirectory) fDirectory->Append(this);; 905 ; 906 fBranches.SetOwner(true);; 907 ; 908 // If title starts with ""/"" and is a valid folder name, a superbranch; 909 // is created.; 910 // FIXME: Why?; 911 if (strlen(title) > 2) {; 912 if (title[0] == '/') {; 913 Branch(title+1,32000,splitlevel);; 914 }; 915 }; 916}; 917 ; 918////////////////////////////////////////////////////////////////////////////////; 919/// Destructor.; 920 ; 921TTree::~TTree(); 922{; 923 if (auto link = dynamic_cast<TNotifyLinkBase*>(fNotify)) {; 924 link->Clear();; 925 }; 926 if (fAllocationCount && (gDebug > 0)) {; 927 Info(""TTree::~TTree"", ""For tree %s, allocation count is %u."", GetName(), fAllocationCount.load());; 928#ifdef R__TRACK_BASKET_ALLOC_TIME; 929 Info(""TTree::~TTree"", ""For tree %s, allocation time is %lluus."", GetName(), fAllocationTime.load());; 930#endif; 931 }; 932 ; 933 if (fDirectory) {; 934 // We are in a directory, which may possibly be a file.; 935 if (fDirectory->GetList()) {; 936 // Remove us from the directory listing.; 937 fDirectory->Remove(this);; 938 }; 939 //delete the file cache if it points to this Tree; 940 TFile *file = fDirectory->GetFile();; 941 MoveReadCache(file,nullptr);; 942 }; 943 ; 944 // Remove the TTree from any list (linked to to the list of Cleanups) to avoid the unnecessary call to; 945 // this RecursiveRemove while we delete our content.; 946 ROOT::CallRecursiveRemoveIfNeeded(*this);; 947 ResetBit(kMustCleanup); // Don't redo it.; 948 ; 949 // We don't own the leaves in fLeaves, the branches do.; 950 fLeaves.Clear();; 951 // I'm ready to destroy any objects allocated by; 952 // SetAddress() by my branches. If I have clones,; 953 // tell them to zero their pointers to this shared; 954 // memory.; 955",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:33627,Performance,load,load,33627,"g behaviour, we should; 902 // be able to choose to not do this like we; 903 // can with a histogram.; 904 if (fDirectory) fDirectory->Append(this);; 905 ; 906 fBranches.SetOwner(true);; 907 ; 908 // If title starts with ""/"" and is a valid folder name, a superbranch; 909 // is created.; 910 // FIXME: Why?; 911 if (strlen(title) > 2) {; 912 if (title[0] == '/') {; 913 Branch(title+1,32000,splitlevel);; 914 }; 915 }; 916}; 917 ; 918////////////////////////////////////////////////////////////////////////////////; 919/// Destructor.; 920 ; 921TTree::~TTree(); 922{; 923 if (auto link = dynamic_cast<TNotifyLinkBase*>(fNotify)) {; 924 link->Clear();; 925 }; 926 if (fAllocationCount && (gDebug > 0)) {; 927 Info(""TTree::~TTree"", ""For tree %s, allocation count is %u."", GetName(), fAllocationCount.load());; 928#ifdef R__TRACK_BASKET_ALLOC_TIME; 929 Info(""TTree::~TTree"", ""For tree %s, allocation time is %lluus."", GetName(), fAllocationTime.load());; 930#endif; 931 }; 932 ; 933 if (fDirectory) {; 934 // We are in a directory, which may possibly be a file.; 935 if (fDirectory->GetList()) {; 936 // Remove us from the directory listing.; 937 fDirectory->Remove(this);; 938 }; 939 //delete the file cache if it points to this Tree; 940 TFile *file = fDirectory->GetFile();; 941 MoveReadCache(file,nullptr);; 942 }; 943 ; 944 // Remove the TTree from any list (linked to to the list of Cleanups) to avoid the unnecessary call to; 945 // this RecursiveRemove while we delete our content.; 946 ROOT::CallRecursiveRemoveIfNeeded(*this);; 947 ResetBit(kMustCleanup); // Don't redo it.; 948 ; 949 // We don't own the leaves in fLeaves, the branches do.; 950 fLeaves.Clear();; 951 // I'm ready to destroy any objects allocated by; 952 // SetAddress() by my branches. If I have clones,; 953 // tell them to zero their pointers to this shared; 954 // memory.; 955 if (fClones && fClones->GetEntries()) {; 956 // I have clones.; 957 // I am about to delete the objects created by; 958 // SetAddress() which we",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:33885,Performance,cache,cache,33885,"if (strlen(title) > 2) {; 912 if (title[0] == '/') {; 913 Branch(title+1,32000,splitlevel);; 914 }; 915 }; 916}; 917 ; 918////////////////////////////////////////////////////////////////////////////////; 919/// Destructor.; 920 ; 921TTree::~TTree(); 922{; 923 if (auto link = dynamic_cast<TNotifyLinkBase*>(fNotify)) {; 924 link->Clear();; 925 }; 926 if (fAllocationCount && (gDebug > 0)) {; 927 Info(""TTree::~TTree"", ""For tree %s, allocation count is %u."", GetName(), fAllocationCount.load());; 928#ifdef R__TRACK_BASKET_ALLOC_TIME; 929 Info(""TTree::~TTree"", ""For tree %s, allocation time is %lluus."", GetName(), fAllocationTime.load());; 930#endif; 931 }; 932 ; 933 if (fDirectory) {; 934 // We are in a directory, which may possibly be a file.; 935 if (fDirectory->GetList()) {; 936 // Remove us from the directory listing.; 937 fDirectory->Remove(this);; 938 }; 939 //delete the file cache if it points to this Tree; 940 TFile *file = fDirectory->GetFile();; 941 MoveReadCache(file,nullptr);; 942 }; 943 ; 944 // Remove the TTree from any list (linked to to the list of Cleanups) to avoid the unnecessary call to; 945 // this RecursiveRemove while we delete our content.; 946 ROOT::CallRecursiveRemoveIfNeeded(*this);; 947 ResetBit(kMustCleanup); // Don't redo it.; 948 ; 949 // We don't own the leaves in fLeaves, the branches do.; 950 fLeaves.Clear();; 951 // I'm ready to destroy any objects allocated by; 952 // SetAddress() by my branches. If I have clones,; 953 // tell them to zero their pointers to this shared; 954 // memory.; 955 if (fClones && fClones->GetEntries()) {; 956 // I have clones.; 957 // I am about to delete the objects created by; 958 // SetAddress() which we are sharing, so tell; 959 // the clones to release their pointers to them.; 960 for (TObjLink* lnk = fClones->FirstLink(); lnk; lnk = lnk->Next()) {; 961 TTree* clone = (TTree*) lnk->GetObject();; 962 // clone->ResetBranchAddresses();; 963 ; 964 // Reset only the branch we have set the address of.; 965 CopyAdd",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:37778,Performance,cache,cache,37778,"; 1014 // owned by a directory. (Otherwise we would need to make sure that a; 1015 // TDirectoryFile that has a TTree in it does a 'slow' TList::Delete.; 1016 delete fEntryList;; 1017 fEntryList=nullptr;; 1018 }; 1019 }; 1020 delete fTreeIndex;; 1021 fTreeIndex = nullptr;; 1022 delete fBranchRef;; 1023 fBranchRef = nullptr;; 1024 delete [] fClusterRangeEnd;; 1025 fClusterRangeEnd = nullptr;; 1026 delete [] fClusterSize;; 1027 fClusterSize = nullptr;; 1028 ; 1029 if (fTransientBuffer) {; 1030 delete fTransientBuffer;; 1031 fTransientBuffer = nullptr;; 1032 }; 1033}; 1034 ; 1035////////////////////////////////////////////////////////////////////////////////; 1036/// Returns the transient buffer currently used by this TTree for reading/writing baskets.; 1037 ; 1038TBuffer* TTree::GetTransientBuffer(Int_t size); 1039{; 1040 if (fTransientBuffer) {; 1041 if (fTransientBuffer->BufferSize() < size) {; 1042 fTransientBuffer->Expand(size);; 1043 }; 1044 return fTransientBuffer;; 1045 }; 1046 fTransientBuffer = new TBufferFile(TBuffer::kRead, size);; 1047 return fTransientBuffer;; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051/// Add branch with name bname to the Tree cache.; 1052/// If bname=""*"" all branches are added to the cache.; 1053/// if subbranches is true all the branches of the subbranches are; 1054/// also put to the cache.; 1055///; 1056/// Returns:; 1057/// - 0 branch added or already included; 1058/// - -1 on error; 1059 ; 1060Int_t TTree::AddBranchToCache(const char*bname, bool subbranches); 1061{; 1062 if (!GetTree()) {; 1063 if (LoadTree(0)<0) {; 1064 Error(""AddBranchToCache"",""Could not load a tree"");; 1065 return -1;; 1066 }; 1067 }; 1068 if (GetTree()) {; 1069 if (GetTree() != this) {; 1070 return GetTree()->AddBranchToCache(bname, subbranches);; 1071 }; 1072 } else {; 1073 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFil",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:37837,Performance,cache,cache,37837,"r;; 1022 delete fBranchRef;; 1023 fBranchRef = nullptr;; 1024 delete [] fClusterRangeEnd;; 1025 fClusterRangeEnd = nullptr;; 1026 delete [] fClusterSize;; 1027 fClusterSize = nullptr;; 1028 ; 1029 if (fTransientBuffer) {; 1030 delete fTransientBuffer;; 1031 fTransientBuffer = nullptr;; 1032 }; 1033}; 1034 ; 1035////////////////////////////////////////////////////////////////////////////////; 1036/// Returns the transient buffer currently used by this TTree for reading/writing baskets.; 1037 ; 1038TBuffer* TTree::GetTransientBuffer(Int_t size); 1039{; 1040 if (fTransientBuffer) {; 1041 if (fTransientBuffer->BufferSize() < size) {; 1042 fTransientBuffer->Expand(size);; 1043 }; 1044 return fTransientBuffer;; 1045 }; 1046 fTransientBuffer = new TBufferFile(TBuffer::kRead, size);; 1047 return fTransientBuffer;; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051/// Add branch with name bname to the Tree cache.; 1052/// If bname=""*"" all branches are added to the cache.; 1053/// if subbranches is true all the branches of the subbranches are; 1054/// also put to the cache.; 1055///; 1056/// Returns:; 1057/// - 0 branch added or already included; 1058/// - -1 on error; 1059 ; 1060Int_t TTree::AddBranchToCache(const char*bname, bool subbranches); 1061{; 1062 if (!GetTree()) {; 1063 if (LoadTree(0)<0) {; 1064 Error(""AddBranchToCache"",""Could not load a tree"");; 1065 return -1;; 1066 }; 1067 }; 1068 if (GetTree()) {; 1069 if (GetTree() != this) {; 1070 return GetTree()->AddBranchToCache(bname, subbranches);; 1071 }; 1072 } else {; 1073 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFile *f = GetCurrentFile();; 1078 if (!f) {; 1079 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1080 return -1;; 1081 }; 1082 TTreeCache *tc = GetReadCache(f,true);; 1083 if (!tc) {; 1084 Error(""AddBranchToCache"", ""No cache is availa",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:37941,Performance,cache,cache,37941,"ngeEnd;; 1025 fClusterRangeEnd = nullptr;; 1026 delete [] fClusterSize;; 1027 fClusterSize = nullptr;; 1028 ; 1029 if (fTransientBuffer) {; 1030 delete fTransientBuffer;; 1031 fTransientBuffer = nullptr;; 1032 }; 1033}; 1034 ; 1035////////////////////////////////////////////////////////////////////////////////; 1036/// Returns the transient buffer currently used by this TTree for reading/writing baskets.; 1037 ; 1038TBuffer* TTree::GetTransientBuffer(Int_t size); 1039{; 1040 if (fTransientBuffer) {; 1041 if (fTransientBuffer->BufferSize() < size) {; 1042 fTransientBuffer->Expand(size);; 1043 }; 1044 return fTransientBuffer;; 1045 }; 1046 fTransientBuffer = new TBufferFile(TBuffer::kRead, size);; 1047 return fTransientBuffer;; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051/// Add branch with name bname to the Tree cache.; 1052/// If bname=""*"" all branches are added to the cache.; 1053/// if subbranches is true all the branches of the subbranches are; 1054/// also put to the cache.; 1055///; 1056/// Returns:; 1057/// - 0 branch added or already included; 1058/// - -1 on error; 1059 ; 1060Int_t TTree::AddBranchToCache(const char*bname, bool subbranches); 1061{; 1062 if (!GetTree()) {; 1063 if (LoadTree(0)<0) {; 1064 Error(""AddBranchToCache"",""Could not load a tree"");; 1065 return -1;; 1066 }; 1067 }; 1068 if (GetTree()) {; 1069 if (GetTree() != this) {; 1070 return GetTree()->AddBranchToCache(bname, subbranches);; 1071 }; 1072 } else {; 1073 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFile *f = GetCurrentFile();; 1078 if (!f) {; 1079 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1080 return -1;; 1081 }; 1082 TTreeCache *tc = GetReadCache(f,true);; 1083 if (!tc) {; 1084 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1085 return -1;; 1086 }; 1087 return tc->AddBranch(bnam",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:38222,Performance,load,load,38222,"/; 1036/// Returns the transient buffer currently used by this TTree for reading/writing baskets.; 1037 ; 1038TBuffer* TTree::GetTransientBuffer(Int_t size); 1039{; 1040 if (fTransientBuffer) {; 1041 if (fTransientBuffer->BufferSize() < size) {; 1042 fTransientBuffer->Expand(size);; 1043 }; 1044 return fTransientBuffer;; 1045 }; 1046 fTransientBuffer = new TBufferFile(TBuffer::kRead, size);; 1047 return fTransientBuffer;; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051/// Add branch with name bname to the Tree cache.; 1052/// If bname=""*"" all branches are added to the cache.; 1053/// if subbranches is true all the branches of the subbranches are; 1054/// also put to the cache.; 1055///; 1056/// Returns:; 1057/// - 0 branch added or already included; 1058/// - -1 on error; 1059 ; 1060Int_t TTree::AddBranchToCache(const char*bname, bool subbranches); 1061{; 1062 if (!GetTree()) {; 1063 if (LoadTree(0)<0) {; 1064 Error(""AddBranchToCache"",""Could not load a tree"");; 1065 return -1;; 1066 }; 1067 }; 1068 if (GetTree()) {; 1069 if (GetTree() != this) {; 1070 return GetTree()->AddBranchToCache(bname, subbranches);; 1071 }; 1072 } else {; 1073 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFile *f = GetCurrentFile();; 1078 if (!f) {; 1079 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1080 return -1;; 1081 }; 1082 TTreeCache *tc = GetReadCache(f,true);; 1083 if (!tc) {; 1084 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1085 return -1;; 1086 }; 1087 return tc->AddBranch(bname,subbranches);; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Add branch b to the Tree cache.; 1092/// if subbranches is true all the branches of the subbranches are; 1093/// also put to the cache.; 1094///; 1095/// Returns:; 1096/// - 0 branch ad",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:38492,Performance,cache,cache,38492,"tBuffer = new TBufferFile(TBuffer::kRead, size);; 1047 return fTransientBuffer;; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051/// Add branch with name bname to the Tree cache.; 1052/// If bname=""*"" all branches are added to the cache.; 1053/// if subbranches is true all the branches of the subbranches are; 1054/// also put to the cache.; 1055///; 1056/// Returns:; 1057/// - 0 branch added or already included; 1058/// - -1 on error; 1059 ; 1060Int_t TTree::AddBranchToCache(const char*bname, bool subbranches); 1061{; 1062 if (!GetTree()) {; 1063 if (LoadTree(0)<0) {; 1064 Error(""AddBranchToCache"",""Could not load a tree"");; 1065 return -1;; 1066 }; 1067 }; 1068 if (GetTree()) {; 1069 if (GetTree() != this) {; 1070 return GetTree()->AddBranchToCache(bname, subbranches);; 1071 }; 1072 } else {; 1073 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFile *f = GetCurrentFile();; 1078 if (!f) {; 1079 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1080 return -1;; 1081 }; 1082 TTreeCache *tc = GetReadCache(f,true);; 1083 if (!tc) {; 1084 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1085 return -1;; 1086 }; 1087 return tc->AddBranch(bname,subbranches);; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Add branch b to the Tree cache.; 1092/// if subbranches is true all the branches of the subbranches are; 1093/// also put to the cache.; 1094///; 1095/// Returns:; 1096/// - 0 branch added or already included; 1097/// - -1 on error; 1098 ; 1099Int_t TTree::AddBranchToCache(TBranch *b, bool subbranches); 1100{; 1101 if (!GetTree()) {; 1102 if (LoadTree(0)<0) {; 1103 Error(""AddBranchToCache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:38667,Performance,cache,cache,38667," 1053/// if subbranches is true all the branches of the subbranches are; 1054/// also put to the cache.; 1055///; 1056/// Returns:; 1057/// - 0 branch added or already included; 1058/// - -1 on error; 1059 ; 1060Int_t TTree::AddBranchToCache(const char*bname, bool subbranches); 1061{; 1062 if (!GetTree()) {; 1063 if (LoadTree(0)<0) {; 1064 Error(""AddBranchToCache"",""Could not load a tree"");; 1065 return -1;; 1066 }; 1067 }; 1068 if (GetTree()) {; 1069 if (GetTree() != this) {; 1070 return GetTree()->AddBranchToCache(bname, subbranches);; 1071 }; 1072 } else {; 1073 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFile *f = GetCurrentFile();; 1078 if (!f) {; 1079 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1080 return -1;; 1081 }; 1082 TTreeCache *tc = GetReadCache(f,true);; 1083 if (!tc) {; 1084 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1085 return -1;; 1086 }; 1087 return tc->AddBranch(bname,subbranches);; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Add branch b to the Tree cache.; 1092/// if subbranches is true all the branches of the subbranches are; 1093/// also put to the cache.; 1094///; 1095/// Returns:; 1096/// - 0 branch added or already included; 1097/// - -1 on error; 1098 ; 1099Int_t TTree::AddBranchToCache(TBranch *b, bool subbranches); 1100{; 1101 if (!GetTree()) {; 1102 if (LoadTree(0)<0) {; 1103 Error(""AddBranchToCache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree()->AddBranchToCache(b, subbranches);; 1110 if (res<0) {; 1111 Error(""AddBranchToCache"", ""Error adding branch"");; 1112 }; 1113 return res;; 1114 }; 1115 } else {; 1116 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1117 return -1;; 1118 }; 1119 ; 1120 TF",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:38799,Performance,cache,cache,38799," 1053/// if subbranches is true all the branches of the subbranches are; 1054/// also put to the cache.; 1055///; 1056/// Returns:; 1057/// - 0 branch added or already included; 1058/// - -1 on error; 1059 ; 1060Int_t TTree::AddBranchToCache(const char*bname, bool subbranches); 1061{; 1062 if (!GetTree()) {; 1063 if (LoadTree(0)<0) {; 1064 Error(""AddBranchToCache"",""Could not load a tree"");; 1065 return -1;; 1066 }; 1067 }; 1068 if (GetTree()) {; 1069 if (GetTree() != this) {; 1070 return GetTree()->AddBranchToCache(bname, subbranches);; 1071 }; 1072 } else {; 1073 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFile *f = GetCurrentFile();; 1078 if (!f) {; 1079 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1080 return -1;; 1081 }; 1082 TTreeCache *tc = GetReadCache(f,true);; 1083 if (!tc) {; 1084 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1085 return -1;; 1086 }; 1087 return tc->AddBranch(bname,subbranches);; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Add branch b to the Tree cache.; 1092/// if subbranches is true all the branches of the subbranches are; 1093/// also put to the cache.; 1094///; 1095/// Returns:; 1096/// - 0 branch added or already included; 1097/// - -1 on error; 1098 ; 1099Int_t TTree::AddBranchToCache(TBranch *b, bool subbranches); 1100{; 1101 if (!GetTree()) {; 1102 if (LoadTree(0)<0) {; 1103 Error(""AddBranchToCache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree()->AddBranchToCache(b, subbranches);; 1110 if (res<0) {; 1111 Error(""AddBranchToCache"", ""Error adding branch"");; 1112 }; 1113 return res;; 1114 }; 1115 } else {; 1116 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1117 return -1;; 1118 }; 1119 ; 1120 TF",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:39045,Performance,cache,cache,39045," 1053/// if subbranches is true all the branches of the subbranches are; 1054/// also put to the cache.; 1055///; 1056/// Returns:; 1057/// - 0 branch added or already included; 1058/// - -1 on error; 1059 ; 1060Int_t TTree::AddBranchToCache(const char*bname, bool subbranches); 1061{; 1062 if (!GetTree()) {; 1063 if (LoadTree(0)<0) {; 1064 Error(""AddBranchToCache"",""Could not load a tree"");; 1065 return -1;; 1066 }; 1067 }; 1068 if (GetTree()) {; 1069 if (GetTree() != this) {; 1070 return GetTree()->AddBranchToCache(bname, subbranches);; 1071 }; 1072 } else {; 1073 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFile *f = GetCurrentFile();; 1078 if (!f) {; 1079 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1080 return -1;; 1081 }; 1082 TTreeCache *tc = GetReadCache(f,true);; 1083 if (!tc) {; 1084 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1085 return -1;; 1086 }; 1087 return tc->AddBranch(bname,subbranches);; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Add branch b to the Tree cache.; 1092/// if subbranches is true all the branches of the subbranches are; 1093/// also put to the cache.; 1094///; 1095/// Returns:; 1096/// - 0 branch added or already included; 1097/// - -1 on error; 1098 ; 1099Int_t TTree::AddBranchToCache(TBranch *b, bool subbranches); 1100{; 1101 if (!GetTree()) {; 1102 if (LoadTree(0)<0) {; 1103 Error(""AddBranchToCache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree()->AddBranchToCache(b, subbranches);; 1110 if (res<0) {; 1111 Error(""AddBranchToCache"", ""Error adding branch"");; 1112 }; 1113 return res;; 1114 }; 1115 } else {; 1116 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1117 return -1;; 1118 }; 1119 ; 1120 TF",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:39149,Performance,cache,cache,39149," bool subbranches); 1061{; 1062 if (!GetTree()) {; 1063 if (LoadTree(0)<0) {; 1064 Error(""AddBranchToCache"",""Could not load a tree"");; 1065 return -1;; 1066 }; 1067 }; 1068 if (GetTree()) {; 1069 if (GetTree() != this) {; 1070 return GetTree()->AddBranchToCache(bname, subbranches);; 1071 }; 1072 } else {; 1073 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFile *f = GetCurrentFile();; 1078 if (!f) {; 1079 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1080 return -1;; 1081 }; 1082 TTreeCache *tc = GetReadCache(f,true);; 1083 if (!tc) {; 1084 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1085 return -1;; 1086 }; 1087 return tc->AddBranch(bname,subbranches);; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Add branch b to the Tree cache.; 1092/// if subbranches is true all the branches of the subbranches are; 1093/// also put to the cache.; 1094///; 1095/// Returns:; 1096/// - 0 branch added or already included; 1097/// - -1 on error; 1098 ; 1099Int_t TTree::AddBranchToCache(TBranch *b, bool subbranches); 1100{; 1101 if (!GetTree()) {; 1102 if (LoadTree(0)<0) {; 1103 Error(""AddBranchToCache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree()->AddBranchToCache(b, subbranches);; 1110 if (res<0) {; 1111 Error(""AddBranchToCache"", ""Error adding branch"");; 1112 }; 1113 return res;; 1114 }; 1115 } else {; 1116 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1117 return -1;; 1118 }; 1119 ; 1120 TFile *f = GetCurrentFile();; 1121 if (!f) {; 1122 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1123 return -1;; 1124 }; 1125 TTreeCache *tc = GetReadCache(f,true);; 1126 if (!tc) {; 1127 Error(""AddBranchToCache"", ""No ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:39424,Performance,load,load,39424,"e. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFile *f = GetCurrentFile();; 1078 if (!f) {; 1079 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1080 return -1;; 1081 }; 1082 TTreeCache *tc = GetReadCache(f,true);; 1083 if (!tc) {; 1084 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1085 return -1;; 1086 }; 1087 return tc->AddBranch(bname,subbranches);; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Add branch b to the Tree cache.; 1092/// if subbranches is true all the branches of the subbranches are; 1093/// also put to the cache.; 1094///; 1095/// Returns:; 1096/// - 0 branch added or already included; 1097/// - -1 on error; 1098 ; 1099Int_t TTree::AddBranchToCache(TBranch *b, bool subbranches); 1100{; 1101 if (!GetTree()) {; 1102 if (LoadTree(0)<0) {; 1103 Error(""AddBranchToCache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree()->AddBranchToCache(b, subbranches);; 1110 if (res<0) {; 1111 Error(""AddBranchToCache"", ""Error adding branch"");; 1112 }; 1113 return res;; 1114 }; 1115 } else {; 1116 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1117 return -1;; 1118 }; 1119 ; 1120 TFile *f = GetCurrentFile();; 1121 if (!f) {; 1122 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1123 return -1;; 1124 }; 1125 TTreeCache *tc = GetReadCache(f,true);; 1126 if (!tc) {; 1127 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1128 return -1;; 1129 }; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranch",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:39796,Performance,cache,cache,39796,";; 1086 }; 1087 return tc->AddBranch(bname,subbranches);; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Add branch b to the Tree cache.; 1092/// if subbranches is true all the branches of the subbranches are; 1093/// also put to the cache.; 1094///; 1095/// Returns:; 1096/// - 0 branch added or already included; 1097/// - -1 on error; 1098 ; 1099Int_t TTree::AddBranchToCache(TBranch *b, bool subbranches); 1100{; 1101 if (!GetTree()) {; 1102 if (LoadTree(0)<0) {; 1103 Error(""AddBranchToCache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree()->AddBranchToCache(b, subbranches);; 1110 if (res<0) {; 1111 Error(""AddBranchToCache"", ""Error adding branch"");; 1112 }; 1113 return res;; 1114 }; 1115 } else {; 1116 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1117 return -1;; 1118 }; 1119 ; 1120 TFile *f = GetCurrentFile();; 1121 if (!f) {; 1122 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1123 return -1;; 1124 }; 1125 TTreeCache *tc = GetReadCache(f,true);; 1126 if (!tc) {; 1127 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1128 return -1;; 1129 }; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranches is true all the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:39971,Performance,cache,cache,39971,"94///; 1095/// Returns:; 1096/// - 0 branch added or already included; 1097/// - -1 on error; 1098 ; 1099Int_t TTree::AddBranchToCache(TBranch *b, bool subbranches); 1100{; 1101 if (!GetTree()) {; 1102 if (LoadTree(0)<0) {; 1103 Error(""AddBranchToCache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree()->AddBranchToCache(b, subbranches);; 1110 if (res<0) {; 1111 Error(""AddBranchToCache"", ""Error adding branch"");; 1112 }; 1113 return res;; 1114 }; 1115 } else {; 1116 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1117 return -1;; 1118 }; 1119 ; 1120 TFile *f = GetCurrentFile();; 1121 if (!f) {; 1122 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1123 return -1;; 1124 }; 1125 TTreeCache *tc = GetReadCache(f,true);; 1126 if (!tc) {; 1127 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1128 return -1;; 1129 }; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranches is true all the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFil",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:40103,Performance,cache,cache,40103,"94///; 1095/// Returns:; 1096/// - 0 branch added or already included; 1097/// - -1 on error; 1098 ; 1099Int_t TTree::AddBranchToCache(TBranch *b, bool subbranches); 1100{; 1101 if (!GetTree()) {; 1102 if (LoadTree(0)<0) {; 1103 Error(""AddBranchToCache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree()->AddBranchToCache(b, subbranches);; 1110 if (res<0) {; 1111 Error(""AddBranchToCache"", ""Error adding branch"");; 1112 }; 1113 return res;; 1114 }; 1115 } else {; 1116 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1117 return -1;; 1118 }; 1119 ; 1120 TFile *f = GetCurrentFile();; 1121 if (!f) {; 1122 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1123 return -1;; 1124 }; 1125 TTreeCache *tc = GetReadCache(f,true);; 1126 if (!tc) {; 1127 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1128 return -1;; 1129 }; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranches is true all the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFil",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:40370,Performance,cache,cache,40370,"94///; 1095/// Returns:; 1096/// - 0 branch added or already included; 1097/// - -1 on error; 1098 ; 1099Int_t TTree::AddBranchToCache(TBranch *b, bool subbranches); 1100{; 1101 if (!GetTree()) {; 1102 if (LoadTree(0)<0) {; 1103 Error(""AddBranchToCache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree()->AddBranchToCache(b, subbranches);; 1110 if (res<0) {; 1111 Error(""AddBranchToCache"", ""Error adding branch"");; 1112 }; 1113 return res;; 1114 }; 1115 } else {; 1116 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1117 return -1;; 1118 }; 1119 ; 1120 TFile *f = GetCurrentFile();; 1121 if (!f) {; 1122 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1123 return -1;; 1124 }; 1125 TTreeCache *tc = GetReadCache(f,true);; 1126 if (!tc) {; 1127 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1128 return -1;; 1129 }; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranches is true all the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFil",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:40433,Performance,cache,cache,40433,"ache"",""Could not load a tree"");; 1104 return -1;; 1105 }; 1106 }; 1107 if (GetTree()) {; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree()->AddBranchToCache(b, subbranches);; 1110 if (res<0) {; 1111 Error(""AddBranchToCache"", ""Error adding branch"");; 1112 }; 1113 return res;; 1114 }; 1115 } else {; 1116 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1117 return -1;; 1118 }; 1119 ; 1120 TFile *f = GetCurrentFile();; 1121 if (!f) {; 1122 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1123 return -1;; 1124 }; 1125 TTreeCache *tc = GetReadCache(f,true);; 1126 if (!tc) {; 1127 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1128 return -1;; 1129 }; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranches is true all the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranc",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:40543,Performance,cache,cache,40543,"; 1108 if (GetTree() != this) {; 1109 Int_t res = GetTree()->AddBranchToCache(b, subbranches);; 1110 if (res<0) {; 1111 Error(""AddBranchToCache"", ""Error adding branch"");; 1112 }; 1113 return res;; 1114 }; 1115 } else {; 1116 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1117 return -1;; 1118 }; 1119 ; 1120 TFile *f = GetCurrentFile();; 1121 if (!f) {; 1122 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1123 return -1;; 1124 }; 1125 TTreeCache *tc = GetReadCache(f,true);; 1126 if (!tc) {; 1127 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1128 return -1;; 1129 }; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranches is true all the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1168 return -1;; 1169 }; 1",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:40615,Performance,cache,cache,40615,"eturn -1;; 1118 }; 1119 ; 1120 TFile *f = GetCurrentFile();; 1121 if (!f) {; 1122 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1123 return -1;; 1124 }; 1125 TTreeCache *tc = GetReadCache(f,true);; 1126 if (!tc) {; 1127 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1128 return -1;; 1129 }; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranches is true all the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1168 return -1;; 1169 }; 1170 return tc->DropBranch(bname,subbranches);; 1171}; 1172 ; 1173////////////////////////////////////////////////////////////////////////////////; 1174/// Remove the branch b from the Tree cache.; 1175/// if subbranches is true all the branches of the subbranches are; 1176/// also removed from the cache.; 1177///; 11",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:40828,Performance,load,load,40828,"eturn -1;; 1118 }; 1119 ; 1120 TFile *f = GetCurrentFile();; 1121 if (!f) {; 1122 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1123 return -1;; 1124 }; 1125 TTreeCache *tc = GetReadCache(f,true);; 1126 if (!tc) {; 1127 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1128 return -1;; 1129 }; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranches is true all the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1168 return -1;; 1169 }; 1170 return tc->DropBranch(bname,subbranches);; 1171}; 1172 ; 1173////////////////////////////////////////////////////////////////////////////////; 1174/// Remove the branch b from the Tree cache.; 1175/// if subbranches is true all the branches of the subbranches are; 1176/// also removed from the cache.; 1177///; 11",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:41108,Performance,cache,cache,41108,"}; 1130 return tc->AddBranch(b,subbranches);; 1131}; 1132 ; 1133////////////////////////////////////////////////////////////////////////////////; 1134/// Remove the branch with name 'bname' from the Tree cache.; 1135/// If bname=""*"" all branches are removed from the cache.; 1136/// if subbranches is true all the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1168 return -1;; 1169 }; 1170 return tc->DropBranch(bname,subbranches);; 1171}; 1172 ; 1173////////////////////////////////////////////////////////////////////////////////; 1174/// Remove the branch b from the Tree cache.; 1175/// if subbranches is true all the branches of the subbranches are; 1176/// also removed from the cache.; 1177///; 1178/// Returns:; 1179/// - 0 branch dropped or not in cache; 1180/// - -1 on error; 1181 ; 1182Int_t TTree::DropBranchFromCache(TBranch *b, bool subbranches); 1183{; 1184 if (!GetTree()) {; 1185 if (LoadTree(0)<0) {; 1186 Error(""DropBranchFromCache"",""Could not load a tree"");; 1187 return -1;; 1188 }; 1189 }; 1190 if (GetTree()) {; 1191 if (GetTree() != ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:41290,Performance,cache,cache,41290,"ll the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1168 return -1;; 1169 }; 1170 return tc->DropBranch(bname,subbranches);; 1171}; 1172 ; 1173////////////////////////////////////////////////////////////////////////////////; 1174/// Remove the branch b from the Tree cache.; 1175/// if subbranches is true all the branches of the subbranches are; 1176/// also removed from the cache.; 1177///; 1178/// Returns:; 1179/// - 0 branch dropped or not in cache; 1180/// - -1 on error; 1181 ; 1182Int_t TTree::DropBranchFromCache(TBranch *b, bool subbranches); 1183{; 1184 if (!GetTree()) {; 1185 if (LoadTree(0)<0) {; 1186 Error(""DropBranchFromCache"",""Could not load a tree"");; 1187 return -1;; 1188 }; 1189 }; 1190 if (GetTree()) {; 1191 if (GetTree() != this) {; 1192 Int_t res = GetTree()->DropBranchFromCache(b, subbranches);; 1193 if (res<0) {; 1194 Error(""DropBranchFromCache"", ""Error dropping branch"");; 1195 }; 1196 return res;; 1197 }; 1198 } else {; 1199 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1200",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:41425,Performance,cache,cache,41425,"ll the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1168 return -1;; 1169 }; 1170 return tc->DropBranch(bname,subbranches);; 1171}; 1172 ; 1173////////////////////////////////////////////////////////////////////////////////; 1174/// Remove the branch b from the Tree cache.; 1175/// if subbranches is true all the branches of the subbranches are; 1176/// also removed from the cache.; 1177///; 1178/// Returns:; 1179/// - 0 branch dropped or not in cache; 1180/// - -1 on error; 1181 ; 1182Int_t TTree::DropBranchFromCache(TBranch *b, bool subbranches); 1183{; 1184 if (!GetTree()) {; 1185 if (LoadTree(0)<0) {; 1186 Error(""DropBranchFromCache"",""Could not load a tree"");; 1187 return -1;; 1188 }; 1189 }; 1190 if (GetTree()) {; 1191 if (GetTree() != this) {; 1192 Int_t res = GetTree()->DropBranchFromCache(b, subbranches);; 1193 if (res<0) {; 1194 Error(""DropBranchFromCache"", ""Error dropping branch"");; 1195 }; 1196 return res;; 1197 }; 1198 } else {; 1199 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1200",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:41683,Performance,cache,cache,41683,"ll the branches of the subbranches are; 1137/// also removed from the cache.; 1138///; 1139/// Returns:; 1140/// - 0 branch dropped or not in cache; 1141/// - -1 on error; 1142 ; 1143Int_t TTree::DropBranchFromCache(const char*bname, bool subbranches); 1144{; 1145 if (!GetTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1168 return -1;; 1169 }; 1170 return tc->DropBranch(bname,subbranches);; 1171}; 1172 ; 1173////////////////////////////////////////////////////////////////////////////////; 1174/// Remove the branch b from the Tree cache.; 1175/// if subbranches is true all the branches of the subbranches are; 1176/// also removed from the cache.; 1177///; 1178/// Returns:; 1179/// - 0 branch dropped or not in cache; 1180/// - -1 on error; 1181 ; 1182Int_t TTree::DropBranchFromCache(TBranch *b, bool subbranches); 1183{; 1184 if (!GetTree()) {; 1185 if (LoadTree(0)<0) {; 1186 Error(""DropBranchFromCache"",""Could not load a tree"");; 1187 return -1;; 1188 }; 1189 }; 1190 if (GetTree()) {; 1191 if (GetTree() != this) {; 1192 Int_t res = GetTree()->DropBranchFromCache(b, subbranches);; 1193 if (res<0) {; 1194 Error(""DropBranchFromCache"", ""Error dropping branch"");; 1195 }; 1196 return res;; 1197 }; 1198 } else {; 1199 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1200",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:41793,Performance,cache,cache,41793,"etTree()) {; 1146 if (LoadTree(0)<0) {; 1147 Error(""DropBranchFromCache"",""Could not load a tree"");; 1148 return -1;; 1149 }; 1150 }; 1151 if (GetTree()) {; 1152 if (GetTree() != this) {; 1153 return GetTree()->DropBranchFromCache(bname, subbranches);; 1154 }; 1155 } else {; 1156 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1168 return -1;; 1169 }; 1170 return tc->DropBranch(bname,subbranches);; 1171}; 1172 ; 1173////////////////////////////////////////////////////////////////////////////////; 1174/// Remove the branch b from the Tree cache.; 1175/// if subbranches is true all the branches of the subbranches are; 1176/// also removed from the cache.; 1177///; 1178/// Returns:; 1179/// - 0 branch dropped or not in cache; 1180/// - -1 on error; 1181 ; 1182Int_t TTree::DropBranchFromCache(TBranch *b, bool subbranches); 1183{; 1184 if (!GetTree()) {; 1185 if (LoadTree(0)<0) {; 1186 Error(""DropBranchFromCache"",""Could not load a tree"");; 1187 return -1;; 1188 }; 1189 }; 1190 if (GetTree()) {; 1191 if (GetTree() != this) {; 1192 Int_t res = GetTree()->DropBranchFromCache(b, subbranches);; 1193 if (res<0) {; 1194 Error(""DropBranchFromCache"", ""Error dropping branch"");; 1195 }; 1196 return res;; 1197 }; 1198 } else {; 1199 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1200 return -1;; 1201 }; 1202 ; 1203 TFile *f = GetCurrentFile();; 1204 if (!f) {; 1205 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1206 return -1;; 1207 }; 1208 TTreeCache *tc = GetReadCache(f,true);; 1209 if (!tc) {; 1210 E",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:41865,Performance,cache,cache,41865,"e"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1168 return -1;; 1169 }; 1170 return tc->DropBranch(bname,subbranches);; 1171}; 1172 ; 1173////////////////////////////////////////////////////////////////////////////////; 1174/// Remove the branch b from the Tree cache.; 1175/// if subbranches is true all the branches of the subbranches are; 1176/// also removed from the cache.; 1177///; 1178/// Returns:; 1179/// - 0 branch dropped or not in cache; 1180/// - -1 on error; 1181 ; 1182Int_t TTree::DropBranchFromCache(TBranch *b, bool subbranches); 1183{; 1184 if (!GetTree()) {; 1185 if (LoadTree(0)<0) {; 1186 Error(""DropBranchFromCache"",""Could not load a tree"");; 1187 return -1;; 1188 }; 1189 }; 1190 if (GetTree()) {; 1191 if (GetTree() != this) {; 1192 Int_t res = GetTree()->DropBranchFromCache(b, subbranches);; 1193 if (res<0) {; 1194 Error(""DropBranchFromCache"", ""Error dropping branch"");; 1195 }; 1196 return res;; 1197 }; 1198 } else {; 1199 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1200 return -1;; 1201 }; 1202 ; 1203 TFile *f = GetCurrentFile();; 1204 if (!f) {; 1205 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1206 return -1;; 1207 }; 1208 TTreeCache *tc = GetReadCache(f,true);; 1209 if (!tc) {; 1210 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1211 return -1;; 1212 }; 1213 return tc->DropBranch(b,subbranches);; 1214}; 1215 ; 1216////////////////////////////////////////////////////////////////////////////////; 1217/// Add a cloned tree to our list of trees to be notified whenever we change; 1218/// our branch addresses or when we are",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:42072,Performance,load,load,42072,"e"");; 1157 return -1;; 1158 }; 1159 ; 1160 TFile *f = GetCurrentFile();; 1161 if (!f) {; 1162 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1163 return -1;; 1164 }; 1165 TTreeCache *tc = GetReadCache(f,true);; 1166 if (!tc) {; 1167 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1168 return -1;; 1169 }; 1170 return tc->DropBranch(bname,subbranches);; 1171}; 1172 ; 1173////////////////////////////////////////////////////////////////////////////////; 1174/// Remove the branch b from the Tree cache.; 1175/// if subbranches is true all the branches of the subbranches are; 1176/// also removed from the cache.; 1177///; 1178/// Returns:; 1179/// - 0 branch dropped or not in cache; 1180/// - -1 on error; 1181 ; 1182Int_t TTree::DropBranchFromCache(TBranch *b, bool subbranches); 1183{; 1184 if (!GetTree()) {; 1185 if (LoadTree(0)<0) {; 1186 Error(""DropBranchFromCache"",""Could not load a tree"");; 1187 return -1;; 1188 }; 1189 }; 1190 if (GetTree()) {; 1191 if (GetTree() != this) {; 1192 Int_t res = GetTree()->DropBranchFromCache(b, subbranches);; 1193 if (res<0) {; 1194 Error(""DropBranchFromCache"", ""Error dropping branch"");; 1195 }; 1196 return res;; 1197 }; 1198 } else {; 1199 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1200 return -1;; 1201 }; 1202 ; 1203 TFile *f = GetCurrentFile();; 1204 if (!f) {; 1205 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1206 return -1;; 1207 }; 1208 TTreeCache *tc = GetReadCache(f,true);; 1209 if (!tc) {; 1210 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1211 return -1;; 1212 }; 1213 return tc->DropBranch(b,subbranches);; 1214}; 1215 ; 1216////////////////////////////////////////////////////////////////////////////////; 1217/// Add a cloned tree to our list of trees to be notified whenever we change; 1218/// our branch addresses or when we are",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:42459,Performance,cache,cache,42459,"ch(bname,subbranches);; 1171}; 1172 ; 1173////////////////////////////////////////////////////////////////////////////////; 1174/// Remove the branch b from the Tree cache.; 1175/// if subbranches is true all the branches of the subbranches are; 1176/// also removed from the cache.; 1177///; 1178/// Returns:; 1179/// - 0 branch dropped or not in cache; 1180/// - -1 on error; 1181 ; 1182Int_t TTree::DropBranchFromCache(TBranch *b, bool subbranches); 1183{; 1184 if (!GetTree()) {; 1185 if (LoadTree(0)<0) {; 1186 Error(""DropBranchFromCache"",""Could not load a tree"");; 1187 return -1;; 1188 }; 1189 }; 1190 if (GetTree()) {; 1191 if (GetTree() != this) {; 1192 Int_t res = GetTree()->DropBranchFromCache(b, subbranches);; 1193 if (res<0) {; 1194 Error(""DropBranchFromCache"", ""Error dropping branch"");; 1195 }; 1196 return res;; 1197 }; 1198 } else {; 1199 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1200 return -1;; 1201 }; 1202 ; 1203 TFile *f = GetCurrentFile();; 1204 if (!f) {; 1205 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1206 return -1;; 1207 }; 1208 TTreeCache *tc = GetReadCache(f,true);; 1209 if (!tc) {; 1210 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1211 return -1;; 1212 }; 1213 return tc->DropBranch(b,subbranches);; 1214}; 1215 ; 1216////////////////////////////////////////////////////////////////////////////////; 1217/// Add a cloned tree to our list of trees to be notified whenever we change; 1218/// our branch addresses or when we are deleted.; 1219 ; 1220void TTree::AddClone(TTree* clone); 1221{; 1222 if (!fClones) {; 1223 fClones = new TList();; 1224 fClones->SetOwner(false);; 1225 // So that the clones are automatically removed from the list when; 1226 // they are deleted.; 1227 {; 1228 R__LOCKGUARD(gROOTMutex);; 1229 gROOT->GetListOfCleanups()->Add(fClones);; 1230 }; 1231 }; 1232 if (!fClones->FindObject(clone)) {; 1233 fClone",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:42641,Performance,cache,cache,42641,"cache; 1180/// - -1 on error; 1181 ; 1182Int_t TTree::DropBranchFromCache(TBranch *b, bool subbranches); 1183{; 1184 if (!GetTree()) {; 1185 if (LoadTree(0)<0) {; 1186 Error(""DropBranchFromCache"",""Could not load a tree"");; 1187 return -1;; 1188 }; 1189 }; 1190 if (GetTree()) {; 1191 if (GetTree() != this) {; 1192 Int_t res = GetTree()->DropBranchFromCache(b, subbranches);; 1193 if (res<0) {; 1194 Error(""DropBranchFromCache"", ""Error dropping branch"");; 1195 }; 1196 return res;; 1197 }; 1198 } else {; 1199 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1200 return -1;; 1201 }; 1202 ; 1203 TFile *f = GetCurrentFile();; 1204 if (!f) {; 1205 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1206 return -1;; 1207 }; 1208 TTreeCache *tc = GetReadCache(f,true);; 1209 if (!tc) {; 1210 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1211 return -1;; 1212 }; 1213 return tc->DropBranch(b,subbranches);; 1214}; 1215 ; 1216////////////////////////////////////////////////////////////////////////////////; 1217/// Add a cloned tree to our list of trees to be notified whenever we change; 1218/// our branch addresses or when we are deleted.; 1219 ; 1220void TTree::AddClone(TTree* clone); 1221{; 1222 if (!fClones) {; 1223 fClones = new TList();; 1224 fClones->SetOwner(false);; 1225 // So that the clones are automatically removed from the list when; 1226 // they are deleted.; 1227 {; 1228 R__LOCKGUARD(gROOTMutex);; 1229 gROOT->GetListOfCleanups()->Add(fClones);; 1230 }; 1231 }; 1232 if (!fClones->FindObject(clone)) {; 1233 fClones->Add(clone);; 1234 }; 1235}; 1236 ; 1237// Check whether mainTree and friendTree can be friends w.r.t. the kEntriesReshuffled bit.; 1238// In particular, if any has the bit set, then friendTree must have a TTreeIndex and the; 1239// branches used for indexing must be present in mainTree.; 1240// Return true if the trees can be friends, false ot",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:42776,Performance,cache,cache,42776,"cache; 1180/// - -1 on error; 1181 ; 1182Int_t TTree::DropBranchFromCache(TBranch *b, bool subbranches); 1183{; 1184 if (!GetTree()) {; 1185 if (LoadTree(0)<0) {; 1186 Error(""DropBranchFromCache"",""Could not load a tree"");; 1187 return -1;; 1188 }; 1189 }; 1190 if (GetTree()) {; 1191 if (GetTree() != this) {; 1192 Int_t res = GetTree()->DropBranchFromCache(b, subbranches);; 1193 if (res<0) {; 1194 Error(""DropBranchFromCache"", ""Error dropping branch"");; 1195 }; 1196 return res;; 1197 }; 1198 } else {; 1199 Error(""DropBranchFromCache"", ""No tree is available. Branch was not dropped from the cache"");; 1200 return -1;; 1201 }; 1202 ; 1203 TFile *f = GetCurrentFile();; 1204 if (!f) {; 1205 Error(""DropBranchFromCache"", ""No file is available. Branch was not dropped from the cache"");; 1206 return -1;; 1207 }; 1208 TTreeCache *tc = GetReadCache(f,true);; 1209 if (!tc) {; 1210 Error(""DropBranchFromCache"", ""No cache is available, branch not dropped"");; 1211 return -1;; 1212 }; 1213 return tc->DropBranch(b,subbranches);; 1214}; 1215 ; 1216////////////////////////////////////////////////////////////////////////////////; 1217/// Add a cloned tree to our list of trees to be notified whenever we change; 1218/// our branch addresses or when we are deleted.; 1219 ; 1220void TTree::AddClone(TTree* clone); 1221{; 1222 if (!fClones) {; 1223 fClones = new TList();; 1224 fClones->SetOwner(false);; 1225 // So that the clones are automatically removed from the list when; 1226 // they are deleted.; 1227 {; 1228 R__LOCKGUARD(gROOTMutex);; 1229 gROOT->GetListOfCleanups()->Add(fClones);; 1230 }; 1231 }; 1232 if (!fClones->FindObject(clone)) {; 1233 fClones->Add(clone);; 1234 }; 1235}; 1236 ; 1237// Check whether mainTree and friendTree can be friends w.r.t. the kEntriesReshuffled bit.; 1238// In particular, if any has the bit set, then friendTree must have a TTreeIndex and the; 1239// branches used for indexing must be present in mainTree.; 1240// Return true if the trees can be friends, false ot",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:105735,Performance,cache,cache,105735,"ue;; 2667 }; 2668 TClass* clm = TClass::GetClass(base->GetName());; 2669 BuildStreamerInfo(clm, pointer, canOptimize);; 2670 }; 2671 if (sinfo && fDirectory) {; 2672 sinfo->ForceWriteInfo(fDirectory->GetFile());; 2673 }; 2674 return sinfo;; 2675}; 2676 ; 2677////////////////////////////////////////////////////////////////////////////////; 2678/// Enable the TTreeCache unless explicitly disabled for this TTree by; 2679/// a prior call to `SetCacheSize(0)`.; 2680/// If the environment variable `ROOT_TTREECACHE_SIZE` or the rootrc config; 2681/// `TTreeCache.Size` has been set to zero, this call will over-ride them with; 2682/// a value of 1.0 (i.e. use a cache size to hold 1 cluster); 2683///; 2684/// Return true if there is a cache attached to the `TTree` (either pre-exisiting; 2685/// or created as part of this call); 2686bool TTree::EnableCache(); 2687{; 2688 TFile* file = GetCurrentFile();; 2689 if (!file); 2690 return false;; 2691 // Check for an existing cache; 2692 TTreeCache* pf = GetReadCache(file);; 2693 if (pf); 2694 return true;; 2695 if (fCacheUserSet && fCacheSize == 0); 2696 return false;; 2697 return (0 == SetCacheSizeAux(true, -1));; 2698}; 2699 ; 2700////////////////////////////////////////////////////////////////////////////////; 2701/// Called by TTree::Fill() when file has reached its maximum fgMaxTreeSize.; 2702/// Create a new file. If the original file is named ""myfile.root"",; 2703/// subsequent files are named ""myfile_1.root"", ""myfile_2.root"", etc.; 2704///; 2705/// Returns a pointer to the new file.; 2706///; 2707/// Currently, the automatic change of file is restricted; 2708/// to the case where the tree is in the top level directory.; 2709/// The file should not contain sub-directories.; 2710///; 2711/// Before switching to a new file, the tree header is written; 2712/// to the current file, then the current file is closed.; 2713///; 2714/// To process the multiple files created by ChangeFile, one must use; 2715/// a TChain.; 2716///; 2717//",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:105809,Performance,cache,cache,105809,"ue;; 2667 }; 2668 TClass* clm = TClass::GetClass(base->GetName());; 2669 BuildStreamerInfo(clm, pointer, canOptimize);; 2670 }; 2671 if (sinfo && fDirectory) {; 2672 sinfo->ForceWriteInfo(fDirectory->GetFile());; 2673 }; 2674 return sinfo;; 2675}; 2676 ; 2677////////////////////////////////////////////////////////////////////////////////; 2678/// Enable the TTreeCache unless explicitly disabled for this TTree by; 2679/// a prior call to `SetCacheSize(0)`.; 2680/// If the environment variable `ROOT_TTREECACHE_SIZE` or the rootrc config; 2681/// `TTreeCache.Size` has been set to zero, this call will over-ride them with; 2682/// a value of 1.0 (i.e. use a cache size to hold 1 cluster); 2683///; 2684/// Return true if there is a cache attached to the `TTree` (either pre-exisiting; 2685/// or created as part of this call); 2686bool TTree::EnableCache(); 2687{; 2688 TFile* file = GetCurrentFile();; 2689 if (!file); 2690 return false;; 2691 // Check for an existing cache; 2692 TTreeCache* pf = GetReadCache(file);; 2693 if (pf); 2694 return true;; 2695 if (fCacheUserSet && fCacheSize == 0); 2696 return false;; 2697 return (0 == SetCacheSizeAux(true, -1));; 2698}; 2699 ; 2700////////////////////////////////////////////////////////////////////////////////; 2701/// Called by TTree::Fill() when file has reached its maximum fgMaxTreeSize.; 2702/// Create a new file. If the original file is named ""myfile.root"",; 2703/// subsequent files are named ""myfile_1.root"", ""myfile_2.root"", etc.; 2704///; 2705/// Returns a pointer to the new file.; 2706///; 2707/// Currently, the automatic change of file is restricted; 2708/// to the case where the tree is in the top level directory.; 2709/// The file should not contain sub-directories.; 2710///; 2711/// Before switching to a new file, the tree header is written; 2712/// to the current file, then the current file is closed.; 2713///; 2714/// To process the multiple files created by ChangeFile, one must use; 2715/// a TChain.; 2716///; 2717//",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:106047,Performance,cache,cache,106047,"ue;; 2667 }; 2668 TClass* clm = TClass::GetClass(base->GetName());; 2669 BuildStreamerInfo(clm, pointer, canOptimize);; 2670 }; 2671 if (sinfo && fDirectory) {; 2672 sinfo->ForceWriteInfo(fDirectory->GetFile());; 2673 }; 2674 return sinfo;; 2675}; 2676 ; 2677////////////////////////////////////////////////////////////////////////////////; 2678/// Enable the TTreeCache unless explicitly disabled for this TTree by; 2679/// a prior call to `SetCacheSize(0)`.; 2680/// If the environment variable `ROOT_TTREECACHE_SIZE` or the rootrc config; 2681/// `TTreeCache.Size` has been set to zero, this call will over-ride them with; 2682/// a value of 1.0 (i.e. use a cache size to hold 1 cluster); 2683///; 2684/// Return true if there is a cache attached to the `TTree` (either pre-exisiting; 2685/// or created as part of this call); 2686bool TTree::EnableCache(); 2687{; 2688 TFile* file = GetCurrentFile();; 2689 if (!file); 2690 return false;; 2691 // Check for an existing cache; 2692 TTreeCache* pf = GetReadCache(file);; 2693 if (pf); 2694 return true;; 2695 if (fCacheUserSet && fCacheSize == 0); 2696 return false;; 2697 return (0 == SetCacheSizeAux(true, -1));; 2698}; 2699 ; 2700////////////////////////////////////////////////////////////////////////////////; 2701/// Called by TTree::Fill() when file has reached its maximum fgMaxTreeSize.; 2702/// Create a new file. If the original file is named ""myfile.root"",; 2703/// subsequent files are named ""myfile_1.root"", ""myfile_2.root"", etc.; 2704///; 2705/// Returns a pointer to the new file.; 2706///; 2707/// Currently, the automatic change of file is restricted; 2708/// to the case where the tree is in the top level directory.; 2709/// The file should not contain sub-directories.; 2710///; 2711/// Before switching to a new file, the tree header is written; 2712/// to the current file, then the current file is closed.; 2713///; 2714/// To process the multiple files created by ChangeFile, one must use; 2715/// a TChain.; 2716///; 2717//",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:124695,Performance,optimiz,optimize,124695,"ng will be done without unzipping or unstreaming the baskets; 3097/// (i.e., a direct copy of the raw bytes on disk).; 3098///; 3099/// When 'fast' is specified, 'option' can also contain a sorting; 3100/// order for the baskets in the output file.; 3101///; 3102/// There are currently 3 supported sorting order:; 3103///; 3104/// - SortBasketsByOffset (the default); 3105/// - SortBasketsByBranch; 3106/// - SortBasketsByEntry; 3107///; 3108/// When using SortBasketsByOffset the baskets are written in the; 3109/// output file in the same order as in the original file (i.e. the; 3110/// baskets are sorted by their offset in the original file; Usually; 3111/// this also means that the baskets are sorted by the index/number of; 3112/// the _last_ entry they contain); 3113///; 3114/// When using SortBasketsByBranch all the baskets of each individual; 3115/// branches are stored contiguously. This tends to optimize reading; 3116/// speed when reading a small number (1->5) of branches, since all; 3117/// their baskets will be clustered together instead of being spread; 3118/// across the file. However it might decrease the performance when; 3119/// reading more branches (or the full entry).; 3120///; 3121/// When using SortBasketsByEntry the baskets with the lowest starting; 3122/// entry are written first. (i.e. the baskets are sorted by the; 3123/// index/number of the first entry they contain). This means that on; 3124/// the file the baskets will be in the order in which they will be; 3125/// needed when reading the whole tree sequentially.; 3126///; 3127/// For examples of CloneTree, see tutorials:; 3128///; 3129/// - copytree.C:; 3130/// A macro to copy a subset of a TTree to a new TTree.; 3131/// The input file has been generated by the program in; 3132/// $ROOTSYS/test/Event with: Event 1000 1 1 1; 3133///; 3134/// - copytree2.C:; 3135/// A macro to copy a subset of a TTree to a new TTree.; 3136/// One branch of the new Tree is written to a separate file.; 3137/// T",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:124915,Performance,perform,performance,124915,"specified, 'option' can also contain a sorting; 3100/// order for the baskets in the output file.; 3101///; 3102/// There are currently 3 supported sorting order:; 3103///; 3104/// - SortBasketsByOffset (the default); 3105/// - SortBasketsByBranch; 3106/// - SortBasketsByEntry; 3107///; 3108/// When using SortBasketsByOffset the baskets are written in the; 3109/// output file in the same order as in the original file (i.e. the; 3110/// baskets are sorted by their offset in the original file; Usually; 3111/// this also means that the baskets are sorted by the index/number of; 3112/// the _last_ entry they contain); 3113///; 3114/// When using SortBasketsByBranch all the baskets of each individual; 3115/// branches are stored contiguously. This tends to optimize reading; 3116/// speed when reading a small number (1->5) of branches, since all; 3117/// their baskets will be clustered together instead of being spread; 3118/// across the file. However it might decrease the performance when; 3119/// reading more branches (or the full entry).; 3120///; 3121/// When using SortBasketsByEntry the baskets with the lowest starting; 3122/// entry are written first. (i.e. the baskets are sorted by the; 3123/// index/number of the first entry they contain). This means that on; 3124/// the file the baskets will be in the order in which they will be; 3125/// needed when reading the whole tree sequentially.; 3126///; 3127/// For examples of CloneTree, see tutorials:; 3128///; 3129/// - copytree.C:; 3130/// A macro to copy a subset of a TTree to a new TTree.; 3131/// The input file has been generated by the program in; 3132/// $ROOTSYS/test/Event with: Event 1000 1 1 1; 3133///; 3134/// - copytree2.C:; 3135/// A macro to copy a subset of a TTree to a new TTree.; 3136/// One branch of the new Tree is written to a separate file.; 3137/// The input file has been generated by the program in; 3138/// $ROOTSYS/test/Event with: Event 1000 1 1 1; 3139 ; 3140TTree* TTree::CloneTree(Long64_t nent",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:140569,Performance,cache,cacheSizeLoc,140569,"or : if any of the underlying TTree object do no have a TTreeIndex,; 3530/// they are all dropped.; 3531/// - AsIsIndexOnError [default]: In case of missing TTreeIndex, the resulting TTree index has gaps.; 3532/// - BuildIndexOnError : If any of the underlying TTree objects do not have a TTreeIndex,; 3533/// all TTreeIndex are 'ignored' and the missing piece are rebuilt.; 3534 ; 3535Long64_t TTree::CopyEntries(TTree* tree, Long64_t nentries /* = -1 */, Option_t* option /* = """" */, bool needCopyAddresses /* = false */); 3536{; 3537 if (!tree) {; 3538 return 0;; 3539 }; 3540 // Options; 3541 TString opt = option;; 3542 opt.ToLower();; 3543 bool fastClone = opt.Contains(""fast"");; 3544 bool withIndex = !opt.Contains(""noindex"");; 3545 EOnIndexError onIndexError;; 3546 if (opt.Contains(""asisindex"")) {; 3547 onIndexError = kKeep;; 3548 } else if (opt.Contains(""buildindex"")) {; 3549 onIndexError = kBuild;; 3550 } else if (opt.Contains(""dropindex"")) {; 3551 onIndexError = kDrop;; 3552 } else {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeSt",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:140595,Performance,cache,cachesize,140595,"ase of missing TTreeIndex, the resulting TTree index has gaps.; 3532/// - BuildIndexOnError : If any of the underlying TTree objects do not have a TTreeIndex,; 3533/// all TTreeIndex are 'ignored' and the missing piece are rebuilt.; 3534 ; 3535Long64_t TTree::CopyEntries(TTree* tree, Long64_t nentries /* = -1 */, Option_t* option /* = """" */, bool needCopyAddresses /* = false */); 3536{; 3537 if (!tree) {; 3538 return 0;; 3539 }; 3540 // Options; 3541 TString opt = option;; 3542 opt.ToLower();; 3543 bool fastClone = opt.Contains(""fast"");; 3544 bool withIndex = !opt.Contains(""noindex"");; 3545 EOnIndexError onIndexError;; 3546 if (opt.Contains(""asisindex"")) {; 3547 onIndexError = kKeep;; 3548 } else if (opt.Contains(""buildindex"")) {; 3549 onIndexError = kBuild;; 3550 } else if (opt.Contains(""dropindex"")) {; 3551 onIndexError = kDrop;; 3552 } else {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:140624,Performance,cache,cacheSize,140624,"ase of missing TTreeIndex, the resulting TTree index has gaps.; 3532/// - BuildIndexOnError : If any of the underlying TTree objects do not have a TTreeIndex,; 3533/// all TTreeIndex are 'ignored' and the missing piece are rebuilt.; 3534 ; 3535Long64_t TTree::CopyEntries(TTree* tree, Long64_t nentries /* = -1 */, Option_t* option /* = """" */, bool needCopyAddresses /* = false */); 3536{; 3537 if (!tree) {; 3538 return 0;; 3539 }; 3540 // Options; 3541 TString opt = option;; 3542 opt.ToLower();; 3543 bool fastClone = opt.Contains(""fast"");; 3544 bool withIndex = !opt.Contains(""noindex"");; 3545 EOnIndexError onIndexError;; 3546 if (opt.Contains(""asisindex"")) {; 3547 onIndexError = kKeep;; 3548 } else if (opt.Contains(""buildindex"")) {; 3549 onIndexError = kBuild;; 3550 } else if (opt.Contains(""dropindex"")) {; 3551 onIndexError = kDrop;; 3552 } else {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:140650,Performance,cache,cacheSizeLoc,140650,"ase of missing TTreeIndex, the resulting TTree index has gaps.; 3532/// - BuildIndexOnError : If any of the underlying TTree objects do not have a TTreeIndex,; 3533/// all TTreeIndex are 'ignored' and the missing piece are rebuilt.; 3534 ; 3535Long64_t TTree::CopyEntries(TTree* tree, Long64_t nentries /* = -1 */, Option_t* option /* = """" */, bool needCopyAddresses /* = false */); 3536{; 3537 if (!tree) {; 3538 return 0;; 3539 }; 3540 // Options; 3541 TString opt = option;; 3542 opt.ToLower();; 3543 bool fastClone = opt.Contains(""fast"");; 3544 bool withIndex = !opt.Contains(""noindex"");; 3545 EOnIndexError onIndexError;; 3546 if (opt.Contains(""asisindex"")) {; 3547 onIndexError = kKeep;; 3548 } else if (opt.Contains(""buildindex"")) {; 3549 onIndexError = kBuild;; 3550 } else if (opt.Contains(""dropindex"")) {; 3551 onIndexError = kDrop;; 3552 } else {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:140713,Performance,cache,cacheSize,140713,"ase of missing TTreeIndex, the resulting TTree index has gaps.; 3532/// - BuildIndexOnError : If any of the underlying TTree objects do not have a TTreeIndex,; 3533/// all TTreeIndex are 'ignored' and the missing piece are rebuilt.; 3534 ; 3535Long64_t TTree::CopyEntries(TTree* tree, Long64_t nentries /* = -1 */, Option_t* option /* = """" */, bool needCopyAddresses /* = false */); 3536{; 3537 if (!tree) {; 3538 return 0;; 3539 }; 3540 // Options; 3541 TString opt = option;; 3542 opt.ToLower();; 3543 bool fastClone = opt.Contains(""fast"");; 3544 bool withIndex = !opt.Contains(""noindex"");; 3545 EOnIndexError onIndexError;; 3546 if (opt.Contains(""asisindex"")) {; 3547 onIndexError = kKeep;; 3548 } else if (opt.Contains(""buildindex"")) {; 3549 onIndexError = kBuild;; 3550 } else if (opt.Contains(""dropindex"")) {; 3551 onIndexError = kDrop;; 3552 } else {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:140749,Performance,cache,cacheSizeEnd,140749,"r : If any of the underlying TTree objects do not have a TTreeIndex,; 3533/// all TTreeIndex are 'ignored' and the missing piece are rebuilt.; 3534 ; 3535Long64_t TTree::CopyEntries(TTree* tree, Long64_t nentries /* = -1 */, Option_t* option /* = """" */, bool needCopyAddresses /* = false */); 3536{; 3537 if (!tree) {; 3538 return 0;; 3539 }; 3540 // Options; 3541 TString opt = option;; 3542 opt.ToLower();; 3543 bool fastClone = opt.Contains(""fast"");; 3544 bool withIndex = !opt.Contains(""noindex"");; 3545 EOnIndexError onIndexError;; 3546 if (opt.Contains(""asisindex"")) {; 3547 onIndexError = kKeep;; 3548 } else if (opt.Contains(""buildindex"")) {; 3549 onIndexError = kBuild;; 3550 } else if (opt.Contains(""dropindex"")) {; 3551 onIndexError = kDrop;; 3552 } else {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);; 3573 ; 3574 Long64_t nbytes = 0;; 3575 Long64_t treeEntries = tree->GetEntriesFast();; 3",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:140778,Performance,cache,cacheSizeLoc,140778,"ree* tree, Long64_t nentries /* = -1 */, Option_t* option /* = """" */, bool needCopyAddresses /* = false */); 3536{; 3537 if (!tree) {; 3538 return 0;; 3539 }; 3540 // Options; 3541 TString opt = option;; 3542 opt.ToLower();; 3543 bool fastClone = opt.Contains(""fast"");; 3544 bool withIndex = !opt.Contains(""noindex"");; 3545 EOnIndexError onIndexError;; 3546 if (opt.Contains(""asisindex"")) {; 3547 onIndexError = kKeep;; 3548 } else if (opt.Contains(""buildindex"")) {; 3549 onIndexError = kBuild;; 3550 } else if (opt.Contains(""dropindex"")) {; 3551 onIndexError = kDrop;; 3552 } else {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);; 3573 ; 3574 Long64_t nbytes = 0;; 3575 Long64_t treeEntries = tree->GetEntriesFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || ne",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:140798,Performance,cache,cacheSizeLoc,140798,"ree* tree, Long64_t nentries /* = -1 */, Option_t* option /* = """" */, bool needCopyAddresses /* = false */); 3536{; 3537 if (!tree) {; 3538 return 0;; 3539 }; 3540 // Options; 3541 TString opt = option;; 3542 opt.ToLower();; 3543 bool fastClone = opt.Contains(""fast"");; 3544 bool withIndex = !opt.Contains(""noindex"");; 3545 EOnIndexError onIndexError;; 3546 if (opt.Contains(""asisindex"")) {; 3547 onIndexError = kKeep;; 3548 } else if (opt.Contains(""buildindex"")) {; 3549 onIndexError = kBuild;; 3550 } else if (opt.Contains(""dropindex"")) {; 3551 onIndexError = kDrop;; 3552 } else {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);; 3573 ; 3574 Long64_t nbytes = 0;; 3575 Long64_t treeEntries = tree->GetEntriesFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || ne",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:140833,Performance,cache,cacheSizeStr,140833,"ree* tree, Long64_t nentries /* = -1 */, Option_t* option /* = """" */, bool needCopyAddresses /* = false */); 3536{; 3537 if (!tree) {; 3538 return 0;; 3539 }; 3540 // Options; 3541 TString opt = option;; 3542 opt.ToLower();; 3543 bool fastClone = opt.Contains(""fast"");; 3544 bool withIndex = !opt.Contains(""noindex"");; 3545 EOnIndexError onIndexError;; 3546 if (opt.Contains(""asisindex"")) {; 3547 onIndexError = kKeep;; 3548 } else if (opt.Contains(""buildindex"")) {; 3549 onIndexError = kBuild;; 3550 } else if (opt.Contains(""dropindex"")) {; 3551 onIndexError = kDrop;; 3552 } else {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);; 3573 ; 3574 Long64_t nbytes = 0;; 3575 Long64_t treeEntries = tree->GetEntriesFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || ne",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:140851,Performance,cache,cacheSizeLoc,140851,"ree* tree, Long64_t nentries /* = -1 */, Option_t* option /* = """" */, bool needCopyAddresses /* = false */); 3536{; 3537 if (!tree) {; 3538 return 0;; 3539 }; 3540 // Options; 3541 TString opt = option;; 3542 opt.ToLower();; 3543 bool fastClone = opt.Contains(""fast"");; 3544 bool withIndex = !opt.Contains(""noindex"");; 3545 EOnIndexError onIndexError;; 3546 if (opt.Contains(""asisindex"")) {; 3547 onIndexError = kKeep;; 3548 } else if (opt.Contains(""buildindex"")) {; 3549 onIndexError = kBuild;; 3550 } else if (opt.Contains(""dropindex"")) {; 3551 onIndexError = kDrop;; 3552 } else {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);; 3573 ; 3574 Long64_t nbytes = 0;; 3575 Long64_t treeEntries = tree->GetEntriesFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || ne",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:140867,Performance,cache,cacheSizeEnd,140867,"ree* tree, Long64_t nentries /* = -1 */, Option_t* option /* = """" */, bool needCopyAddresses /* = false */); 3536{; 3537 if (!tree) {; 3538 return 0;; 3539 }; 3540 // Options; 3541 TString opt = option;; 3542 opt.ToLower();; 3543 bool fastClone = opt.Contains(""fast"");; 3544 bool withIndex = !opt.Contains(""noindex"");; 3545 EOnIndexError onIndexError;; 3546 if (opt.Contains(""asisindex"")) {; 3547 onIndexError = kKeep;; 3548 } else if (opt.Contains(""buildindex"")) {; 3549 onIndexError = kBuild;; 3550 } else if (opt.Contains(""dropindex"")) {; 3551 onIndexError = kDrop;; 3552 } else {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);; 3573 ; 3574 Long64_t nbytes = 0;; 3575 Long64_t treeEntries = tree->GetEntriesFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || ne",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:140937,Performance,cache,cacheSizeStr,140937,"ree* tree, Long64_t nentries /* = -1 */, Option_t* option /* = """" */, bool needCopyAddresses /* = false */); 3536{; 3537 if (!tree) {; 3538 return 0;; 3539 }; 3540 // Options; 3541 TString opt = option;; 3542 opt.ToLower();; 3543 bool fastClone = opt.Contains(""fast"");; 3544 bool withIndex = !opt.Contains(""noindex"");; 3545 EOnIndexError onIndexError;; 3546 if (opt.Contains(""asisindex"")) {; 3547 onIndexError = kKeep;; 3548 } else if (opt.Contains(""buildindex"")) {; 3549 onIndexError = kBuild;; 3550 } else if (opt.Contains(""dropindex"")) {; 3551 onIndexError = kDrop;; 3552 } else {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);; 3573 ; 3574 Long64_t nbytes = 0;; 3575 Long64_t treeEntries = tree->GetEntriesFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || ne",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:140950,Performance,cache,cacheSize,140950,"ree* tree, Long64_t nentries /* = -1 */, Option_t* option /* = """" */, bool needCopyAddresses /* = false */); 3536{; 3537 if (!tree) {; 3538 return 0;; 3539 }; 3540 // Options; 3541 TString opt = option;; 3542 opt.ToLower();; 3543 bool fastClone = opt.Contains(""fast"");; 3544 bool withIndex = !opt.Contains(""noindex"");; 3545 EOnIndexError onIndexError;; 3546 if (opt.Contains(""asisindex"")) {; 3547 onIndexError = kKeep;; 3548 } else if (opt.Contains(""buildindex"")) {; 3549 onIndexError = kBuild;; 3550 } else if (opt.Contains(""dropindex"")) {; 3551 onIndexError = kDrop;; 3552 } else {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);; 3573 ; 3574 Long64_t nbytes = 0;; 3575 Long64_t treeEntries = tree->GetEntriesFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || ne",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:141064,Performance,cache,cachesize,141064,"ree* tree, Long64_t nentries /* = -1 */, Option_t* option /* = """" */, bool needCopyAddresses /* = false */); 3536{; 3537 if (!tree) {; 3538 return 0;; 3539 }; 3540 // Options; 3541 TString opt = option;; 3542 opt.ToLower();; 3543 bool fastClone = opt.Contains(""fast"");; 3544 bool withIndex = !opt.Contains(""noindex"");; 3545 EOnIndexError onIndexError;; 3546 if (opt.Contains(""asisindex"")) {; 3547 onIndexError = kKeep;; 3548 } else if (opt.Contains(""buildindex"")) {; 3549 onIndexError = kBuild;; 3550 } else if (opt.Contains(""dropindex"")) {; 3551 onIndexError = kDrop;; 3552 } else {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);; 3573 ; 3574 Long64_t nbytes = 0;; 3575 Long64_t treeEntries = tree->GetEntriesFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || ne",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:141136,Performance,cache,cacheSizeStr,141136,"42 opt.ToLower();; 3543 bool fastClone = opt.Contains(""fast"");; 3544 bool withIndex = !opt.Contains(""noindex"");; 3545 EOnIndexError onIndexError;; 3546 if (opt.Contains(""asisindex"")) {; 3547 onIndexError = kKeep;; 3548 } else if (opt.Contains(""buildindex"")) {; 3549 onIndexError = kBuild;; 3550 } else if (opt.Contains(""dropindex"")) {; 3551 onIndexError = kDrop;; 3552 } else {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);; 3573 ; 3574 Long64_t nbytes = 0;; 3575 Long64_t treeEntries = tree->GetEntriesFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || nentries == tree->GetEntriesFast())) {; 3583 // Quickly copy the basket without decompression and streaming.; 3584 Long64_t totbytes = GetTotBytes();; 3585 for (Long64_t i = 0; i < nentries; i += tree->GetTre",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:141354,Performance,cache,cacheSize,141354,"dex"")) {; 3547 onIndexError = kKeep;; 3548 } else if (opt.Contains(""buildindex"")) {; 3549 onIndexError = kBuild;; 3550 } else if (opt.Contains(""dropindex"")) {; 3551 onIndexError = kDrop;; 3552 } else {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);; 3573 ; 3574 Long64_t nbytes = 0;; 3575 Long64_t treeEntries = tree->GetEntriesFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || nentries == tree->GetEntriesFast())) {; 3583 // Quickly copy the basket without decompression and streaming.; 3584 Long64_t totbytes = GetTotBytes();; 3585 for (Long64_t i = 0; i < nentries; i += tree->GetTree()->GetEntries()) {; 3586 if (tree->LoadTree(i) < 0) {; 3587 break;; 3588 }; 3589 if ( withIndex ) {; 3590 withIndex = R__HandleIndex( onIndexError, this, tree );; 3591 }; 35",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:141431,Performance,cache,cachesize,141431,"dex"")) {; 3547 onIndexError = kKeep;; 3548 } else if (opt.Contains(""buildindex"")) {; 3549 onIndexError = kBuild;; 3550 } else if (opt.Contains(""dropindex"")) {; 3551 onIndexError = kDrop;; 3552 } else {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);; 3573 ; 3574 Long64_t nbytes = 0;; 3575 Long64_t treeEntries = tree->GetEntriesFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || nentries == tree->GetEntriesFast())) {; 3583 // Quickly copy the basket without decompression and streaming.; 3584 Long64_t totbytes = GetTotBytes();; 3585 for (Long64_t i = 0; i < nentries; i += tree->GetTree()->GetEntries()) {; 3586 if (tree->LoadTree(i) < 0) {; 3587 break;; 3588 }; 3589 if ( withIndex ) {; 3590 withIndex = R__HandleIndex( onIndexError, this, tree );; 3591 }; 35",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:141509,Performance,cache,cacheSizeStr,141509,"se {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);; 3573 ; 3574 Long64_t nbytes = 0;; 3575 Long64_t treeEntries = tree->GetEntriesFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || nentries == tree->GetEntriesFast())) {; 3583 // Quickly copy the basket without decompression and streaming.; 3584 Long64_t totbytes = GetTotBytes();; 3585 for (Long64_t i = 0; i < nentries; i += tree->GetTree()->GetEntries()) {; 3586 if (tree->LoadTree(i) < 0) {; 3587 break;; 3588 }; 3589 if ( withIndex ) {; 3590 withIndex = R__HandleIndex( onIndexError, this, tree );; 3591 }; 3592 if (this->GetDirectory()) {; 3593 TFile* file2 = this->GetDirectory()->GetFile();; 3594 if (file2 && (file2->GetEND() > TTree::GetMaxTreeSize())) {; 3595 if (this->GetDirectory() == (TDirectory*)",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:141588,Performance,cache,cacheSize,141588,"eLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);; 3573 ; 3574 Long64_t nbytes = 0;; 3575 Long64_t treeEntries = tree->GetEntriesFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || nentries == tree->GetEntriesFast())) {; 3583 // Quickly copy the basket without decompression and streaming.; 3584 Long64_t totbytes = GetTotBytes();; 3585 for (Long64_t i = 0; i < nentries; i += tree->GetTree()->GetEntries()) {; 3586 if (tree->LoadTree(i) < 0) {; 3587 break;; 3588 }; 3589 if ( withIndex ) {; 3590 withIndex = R__HandleIndex( onIndexError, this, tree );; 3591 }; 3592 if (this->GetDirectory()) {; 3593 TFile* file2 = this->GetDirectory()->GetFile();; 3594 if (file2 && (file2->GetEND() > TTree::GetMaxTreeSize())) {; 3595 if (this->GetDirectory() == (TDirectory*) file2) {; 3596 this->ChangeFile(file2);; 3597 }; 3598 }; 3599 }; 3600 TTreeCloner cloner(tree->GetTree(), this, option, TTreeCloner::kNoWarnings);; 3601 if (cloner.IsValid()) {; 3602 this->SetEntries(this->GetEntries() + tree->GetTree()->GetEntries());; 3603 if (cacheSiz",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:141651,Performance,cache,cacheSize,141651,"eLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);; 3573 ; 3574 Long64_t nbytes = 0;; 3575 Long64_t treeEntries = tree->GetEntriesFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || nentries == tree->GetEntriesFast())) {; 3583 // Quickly copy the basket without decompression and streaming.; 3584 Long64_t totbytes = GetTotBytes();; 3585 for (Long64_t i = 0; i < nentries; i += tree->GetTree()->GetEntries()) {; 3586 if (tree->LoadTree(i) < 0) {; 3587 break;; 3588 }; 3589 if ( withIndex ) {; 3590 withIndex = R__HandleIndex( onIndexError, this, tree );; 3591 }; 3592 if (this->GetDirectory()) {; 3593 TFile* file2 = this->GetDirectory()->GetFile();; 3594 if (file2 && (file2->GetEND() > TTree::GetMaxTreeSize())) {; 3595 if (this->GetDirectory() == (TDirectory*) file2) {; 3596 this->ChangeFile(file2);; 3597 }; 3598 }; 3599 }; 3600 TTreeCloner cloner(tree->GetTree(), this, option, TTreeCloner::kNoWarnings);; 3601 if (cloner.IsValid()) {; 3602 this->SetEntries(this->GetEntries() + tree->GetTree()->GetEntries());; 3603 if (cacheSiz",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:142779,Performance,cache,cacheSize,142779,"sFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || nentries == tree->GetEntriesFast())) {; 3583 // Quickly copy the basket without decompression and streaming.; 3584 Long64_t totbytes = GetTotBytes();; 3585 for (Long64_t i = 0; i < nentries; i += tree->GetTree()->GetEntries()) {; 3586 if (tree->LoadTree(i) < 0) {; 3587 break;; 3588 }; 3589 if ( withIndex ) {; 3590 withIndex = R__HandleIndex( onIndexError, this, tree );; 3591 }; 3592 if (this->GetDirectory()) {; 3593 TFile* file2 = this->GetDirectory()->GetFile();; 3594 if (file2 && (file2->GetEND() > TTree::GetMaxTreeSize())) {; 3595 if (this->GetDirectory() == (TDirectory*) file2) {; 3596 this->ChangeFile(file2);; 3597 }; 3598 }; 3599 }; 3600 TTreeCloner cloner(tree->GetTree(), this, option, TTreeCloner::kNoWarnings);; 3601 if (cloner.IsValid()) {; 3602 this->SetEntries(this->GetEntries() + tree->GetTree()->GetEntries());; 3603 if (cacheSize != -1) cloner.SetCacheSize(cacheSize);; 3604 cloner.Exec();; 3605 } else {; 3606 if (i == 0) {; 3607 Warning(""CopyEntries"",""%s"",cloner.GetWarning());; 3608 // If the first cloning does not work, something is really wrong; 3609 // (since apriori the source and target are exactly the same structure!); 3610 return -1;; 3611 } else {; 3612 if (cloner.NeedConversion()) {; 3613 TTree *localtree = tree->GetTree();; 3614 Long64_t tentries = localtree->GetEntries();; 3615 if (needCopyAddresses) {; 3616 // Copy MakeClass status.; 3617 tree->SetMakeClass(fMakeClass);; 3618 // Copy branch addresses.; 3619 CopyAddresses(tree);; 3620 }; 3621 for (Long64_t ii = 0; ii < tentries; ii++) {; 3622 if (localtree->GetEntry(ii) <= 0) {; 3623 break;; 3624 }; 3625 this->Fill();; 3626 }; 3627 if (needCopyAddresses); 3628 tree->ResetBranchAddresses();; 3629 if (this->GetTreeIndex()) {; 3630 this->GetTreeIndex()->Append(tree->GetTree()->GetTreeIndex(), true);; 3631 }",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:142816,Performance,cache,cacheSize,142816,"(nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || nentries == tree->GetEntriesFast())) {; 3583 // Quickly copy the basket without decompression and streaming.; 3584 Long64_t totbytes = GetTotBytes();; 3585 for (Long64_t i = 0; i < nentries; i += tree->GetTree()->GetEntries()) {; 3586 if (tree->LoadTree(i) < 0) {; 3587 break;; 3588 }; 3589 if ( withIndex ) {; 3590 withIndex = R__HandleIndex( onIndexError, this, tree );; 3591 }; 3592 if (this->GetDirectory()) {; 3593 TFile* file2 = this->GetDirectory()->GetFile();; 3594 if (file2 && (file2->GetEND() > TTree::GetMaxTreeSize())) {; 3595 if (this->GetDirectory() == (TDirectory*) file2) {; 3596 this->ChangeFile(file2);; 3597 }; 3598 }; 3599 }; 3600 TTreeCloner cloner(tree->GetTree(), this, option, TTreeCloner::kNoWarnings);; 3601 if (cloner.IsValid()) {; 3602 this->SetEntries(this->GetEntries() + tree->GetTree()->GetEntries());; 3603 if (cacheSize != -1) cloner.SetCacheSize(cacheSize);; 3604 cloner.Exec();; 3605 } else {; 3606 if (i == 0) {; 3607 Warning(""CopyEntries"",""%s"",cloner.GetWarning());; 3608 // If the first cloning does not work, something is really wrong; 3609 // (since apriori the source and target are exactly the same structure!); 3610 return -1;; 3611 } else {; 3612 if (cloner.NeedConversion()) {; 3613 TTree *localtree = tree->GetTree();; 3614 Long64_t tentries = localtree->GetEntries();; 3615 if (needCopyAddresses) {; 3616 // Copy MakeClass status.; 3617 tree->SetMakeClass(fMakeClass);; 3618 // Copy branch addresses.; 3619 CopyAddresses(tree);; 3620 }; 3621 for (Long64_t ii = 0; ii < tentries; ii++) {; 3622 if (localtree->GetEntry(ii) <= 0) {; 3623 break;; 3624 }; 3625 this->Fill();; 3626 }; 3627 if (needCopyAddresses); 3628 tree->ResetBranchAddresses();; 3629 if (this->GetTreeIndex()) {; 3630 this->GetTreeIndex()->Append(tree->GetTree()->GetTreeIndex(), true);; 3631 }; 3632 } else {; 3633 Warning(""CopyEntries"",""%s"",cloner.GetWarning());; 3634 if ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:149659,Performance,cache,cache,149659,"anch->GetMaxBaskets();; 3776 for (Int_t i=0;i<nbaskets;i++) {; 3777 Long64_t pos = branch->GetBasketSeek(i);; 3778 if (!pos) continue;; 3779 TFile *branchFile = branch->GetFile();; 3780 if (!branchFile) continue;; 3781 branchFile->GetRecordHeader(header,pos,16,nbytes,objlen,keylen);; 3782 if (nbytes <= 0) continue;; 3783 branchFile->MakeFree(pos,pos+nbytes-1);; 3784 ntot += nbytes;; 3785 nbask++;; 3786 }; 3787 }; 3788 ; 3789 // delete Tree header key and all keys with the same name; 3790 // A Tree may have been saved many times. Previous cycles are invalid.; 3791 while (key) {; 3792 ntot += key->GetNbytes();; 3793 key->Delete();; 3794 delete key;; 3795 key = fDirectory->GetKey(GetName());; 3796 }; 3797 if (dirsav) dirsav->cd();; 3798 if (gDebug) Info(""TTree::Delete"", ""Deleting Tree: %s: %d baskets deleted. Total space freed = %d bytes\n"",GetName(),nbask,ntot);; 3799 }; 3800 ; 3801 if (fDirectory) {; 3802 fDirectory->Remove(this);; 3803 //delete the file cache if it points to this Tree; 3804 MoveReadCache(file,nullptr);; 3805 fDirectory = nullptr;; 3806 ResetBit(kMustCleanup);; 3807 }; 3808 ; 3809 // Delete object from CINT symbol table so it can not be used anymore.; 3810 gCling->DeleteGlobal(this);; 3811 ; 3812 // Warning: We have intentional invalidated this object while inside a member function!; 3813 delete this;; 3814}; 3815 ; 3816 ///////////////////////////////////////////////////////////////////////////////; 3817 /// Called by TKey and TObject::Clone to automatically add us to a directory; 3818 /// when we are read from a file.; 3819 ; 3820void TTree::DirectoryAutoAdd(TDirectory* dir); 3821{; 3822 if (fDirectory == dir) return;; 3823 if (fDirectory) {; 3824 fDirectory->Remove(this);; 3825 // Delete or move the file cache if it points to this Tree; 3826 TFile *file = fDirectory->GetFile();; 3827 MoveReadCache(file,dir);; 3828 }; 3829 fDirectory = dir;; 3830 TBranch* b = nullptr;; 3831 TIter next(GetListOfBranches());; 3832 while((b = (TBranch*) next())) {; 383",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:150444,Performance,cache,cache,150444,"y->Remove(this);; 3803 //delete the file cache if it points to this Tree; 3804 MoveReadCache(file,nullptr);; 3805 fDirectory = nullptr;; 3806 ResetBit(kMustCleanup);; 3807 }; 3808 ; 3809 // Delete object from CINT symbol table so it can not be used anymore.; 3810 gCling->DeleteGlobal(this);; 3811 ; 3812 // Warning: We have intentional invalidated this object while inside a member function!; 3813 delete this;; 3814}; 3815 ; 3816 ///////////////////////////////////////////////////////////////////////////////; 3817 /// Called by TKey and TObject::Clone to automatically add us to a directory; 3818 /// when we are read from a file.; 3819 ; 3820void TTree::DirectoryAutoAdd(TDirectory* dir); 3821{; 3822 if (fDirectory == dir) return;; 3823 if (fDirectory) {; 3824 fDirectory->Remove(this);; 3825 // Delete or move the file cache if it points to this Tree; 3826 TFile *file = fDirectory->GetFile();; 3827 MoveReadCache(file,dir);; 3828 }; 3829 fDirectory = dir;; 3830 TBranch* b = nullptr;; 3831 TIter next(GetListOfBranches());; 3832 while((b = (TBranch*) next())) {; 3833 b->UpdateFile();; 3834 }; 3835 if (fBranchRef) {; 3836 fBranchRef->UpdateFile();; 3837 }; 3838 if (fDirectory) fDirectory->Append(this);; 3839}; 3840 ; 3841////////////////////////////////////////////////////////////////////////////////; 3842/// Draw expression varexp for specified entries.; 3843///; 3844/// \return -1 in case of error or number of selected events in case of success.; 3845///; 3846/// This function accepts TCut objects as arguments.; 3847/// Useful to use the string operator +; 3848///; 3849/// Example:; 3850///; 3851/// ~~~ {.cpp}; 3852/// ntuple.Draw(""x"",cut1+cut2+cut3);; 3853/// ~~~; 3854 ; 3855 ; 3856Long64_t TTree::Draw(const char* varexp, const TCut& selection, Option_t* option, Long64_t nentries, Long64_t firstentry); 3857{; 3858 return TTree::Draw(varexp, selection.GetTitle(), option, nentries, firstentry);; 3859}; 3860 ; 3861//////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:155076,Performance,perform,perform,155076,"rblock; 3903/// \param [in] selection; 3904/// \parblock; 3905/// A string containing a selection expression.; 3906/// In a selection all usual C++ mathematical and logical operators are allowed.; 3907/// The value corresponding to the selection expression is used as a weight; 3908/// to fill the histogram (a weight of 0 is equivalent to not filling the histogram).\n; 3909/// \n; 3910/// Examples:; 3911/// - ""x<y && sqrt(z)>3.2"": returns a weight = 0 or 1; 3912/// - ""(x+y)*(sqrt(z)>3.2)"": returns a weight = x+y if sqrt(z)>3.2, 0 otherwise\n; 3913/// \n; 3914/// If the selection expression returns an array, it is iterated over in sync with the; 3915/// array returned by the varexp argument (as described below in ""Drawing expressions using arrays and array; 3916/// elements""). For example, if, for a given event, varexp evaluates to; 3917/// `{1., 2., 3.}` and selection evaluates to `{0, 1, 0}`, the resulting histogram is filled with the value 2. For example, for each event here we perform a simple object selection:; 3918/// ~~~{.cpp}; 3919/// // Muon_pt is an array: fill a histogram with the array elements > 100 in each event; 3920/// tree->Draw('Muon_pt', 'Muon_pt > 100'); 3921/// ~~~; 3922/// \endparblock; 3923/// \param [in] option; 3924/// \parblock; 3925/// The drawing option.; 3926/// - When an histogram is produced it can be any histogram drawing option; 3927/// listed in THistPainter.; 3928/// - when no option is specified:; 3929/// - the default histogram drawing option is used; 3930/// if the expression is of the form ""e1"".; 3931/// - if the expression is of the form ""e1:e2""or ""e1:e2:e3"" a cloud of; 3932/// unbinned 2D or 3D points is drawn respectively.; 3933/// - if the expression has four fields ""e1:e2:e3:e4"" a cloud of unbinned 3D; 3934/// points is produced with e1 vs e2 vs e3, and e4 is mapped on the current color; 3935/// palette.; 3936/// - If option COL is specified when varexp has three fields:; 3937/// ~~~ {.cpp}; 3938/// tree.Draw(""e1:e2:e3"","""",""",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:171911,Performance,load,load,171911,"arr3[2]"");; 4249/// ~~~; 4250/// will draw the sum arr3 for the index 0 to 2 only if the; 4251/// actual_size_of_arr3 is greater or equal to 3.; 4252/// Note that the array in 'primary' is flattened/linearized thus using; 4253/// `Alt$` with multi-dimensional arrays of different dimensions in unlikely; 4254/// to yield the expected results. To visualize a bit more what elements; 4255/// would be matched by TTree::Draw, TTree::Scan can be used:; 4256/// ~~~ {.cpp}; 4257/// tree->Scan(""arr1:Alt$(arr2,0)"");; 4258/// ~~~; 4259/// will print on one line the value of arr1 and (arr2,0) that will be; 4260/// matched by; 4261/// ~~~ {.cpp}; 4262/// tree->Draw(""arr1-Alt$(arr2,0)"");; 4263/// ~~~; 4264/// The ternary operator is not directly supported in TTree::Draw however, to plot the; 4265/// equivalent of `var2<20 ? -99 : var1`, you can use:; 4266/// ~~~ {.cpp}; 4267/// tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");; 4268/// ~~~; 4269///; 4270/// ### Drawing a user function accessing the TTree data directly; 4271///; 4272/// If the formula contains a file name, TTree::MakeProxy will be used; 4273/// to load and execute this file. In particular it will draw the; 4274/// result of a function with the same name as the file. The function; 4275/// will be executed in a context where the name of the branches can; 4276/// be used as a C++ variable.; 4277///; 4278/// For example draw px using the file hsimple.root (generated by the; 4279/// hsimple.C tutorial), we need a file named hsimple.cxx:; 4280/// ~~~ {.cpp}; 4281/// double hsimple() {; 4282/// return px;; 4283/// }; 4284/// ~~~; 4285/// MakeProxy can then be used indirectly via the TTree::Draw interface; 4286/// as follow:; 4287/// ~~~ {.cpp}; 4288/// new TFile(""hsimple.root""); 4289/// ntuple->Draw(""hsimple.cxx"");; 4290/// ~~~; 4291/// A more complete example is available in the tutorials directory:; 4292/// `h1analysisProxy.cxx`, `h1analysProxy.h` and `h1analysisProxyCut.C`; 4293/// which reimplement the selector found in `",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:172901,Performance,load,loading,172901,"ion with the same name as the file. The function; 4275/// will be executed in a context where the name of the branches can; 4276/// be used as a C++ variable.; 4277///; 4278/// For example draw px using the file hsimple.root (generated by the; 4279/// hsimple.C tutorial), we need a file named hsimple.cxx:; 4280/// ~~~ {.cpp}; 4281/// double hsimple() {; 4282/// return px;; 4283/// }; 4284/// ~~~; 4285/// MakeProxy can then be used indirectly via the TTree::Draw interface; 4286/// as follow:; 4287/// ~~~ {.cpp}; 4288/// new TFile(""hsimple.root""); 4289/// ntuple->Draw(""hsimple.cxx"");; 4290/// ~~~; 4291/// A more complete example is available in the tutorials directory:; 4292/// `h1analysisProxy.cxx`, `h1analysProxy.h` and `h1analysisProxyCut.C`; 4293/// which reimplement the selector found in `h1analysis.C`; 4294///; 4295/// The main features of this facility are:; 4296///; 4297/// * on-demand loading of branches; 4298/// * ability to use the 'branchname' as if it was a data member; 4299/// * protection against array out-of-bound; 4300/// * ability to use the branch data as object (when the user code is available); 4301///; 4302/// See TTree::MakeProxy for more details.; 4303///; 4304/// ### Making a Profile histogram; 4305///; 4306/// In case of a 2-Dim expression, one can generate a TProfile histogram; 4307/// instead of a TH2F histogram by specifying option=prof or option=profs; 4308/// or option=profi or option=profg ; the trailing letter select the way; 4309/// the bin error are computed, See TProfile2D::SetErrorOption for; 4310/// details on the differences.; 4311/// The option=prof is automatically selected in case of y:x>>pf; 4312/// where pf is an existing TProfile histogram.; 4313///; 4314/// ### Making a 2D Profile histogram; 4315///; 4316/// In case of a 3-Dim expression, one can generate a TProfile2D histogram; 4317/// instead of a TH3F histogram by specifying option=prof or option=profs.; 4318/// or option=profi or option=profg ; the trailing letter sele",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:178034,Performance,load,loaded,178034," 4382/// tree.Draw("">>+yplus"",""y>0""); 4383/// ~~~; 4384/// will not reset yplus, but will enter the selected entries at the end; 4385/// of the existing list.; 4386///; 4387/// ### Using a TEventList, TEntryList or TEntryListArray as Input; 4388///; 4389/// Once a TEventList or a TEntryList object has been generated, it can be used as input; 4390/// for TTree::Draw. Use TTree::SetEventList or TTree::SetEntryList to set the; 4391/// current event list; 4392///; 4393/// Example 1:; 4394/// ~~~ {.cpp}; 4395/// TEventList *elist = (TEventList*)gDirectory->Get(""yplus"");; 4396/// tree->SetEventList(elist);; 4397/// tree->Draw(""py"");; 4398/// ~~~; 4399/// Example 2:; 4400/// ~~~ {.cpp}; 4401/// TEntryList *elist = (TEntryList*)gDirectory->Get(""yplus"");; 4402/// tree->SetEntryList(elist);; 4403/// tree->Draw(""py"");; 4404/// ~~~; 4405/// If a TEventList object is used as input, a new TEntryList object is created; 4406/// inside the SetEventList function. In case of a TChain, all tree headers are loaded; 4407/// for this transformation. This new object is owned by the chain and is deleted; 4408/// with it, unless the user extracts it by calling GetEntryList() function.; 4409/// See also comments to SetEventList() function of TTree and TChain.; 4410///; 4411/// If arrays are used in the selection criteria and TEntryListArray is not used,; 4412/// all the entries that have at least one element of the array that satisfy the selection; 4413/// are entered in the list.; 4414///; 4415/// Example:; 4416/// ~~~ {.cpp}; 4417/// tree.Draw("">>pyplus"",""fTracks.fPy>0"");; 4418/// tree->SetEventList(pyplus);; 4419/// tree->Draw(""fTracks.fPy"");; 4420/// ~~~; 4421/// will draw the fPy of ALL tracks in event with at least one track with; 4422/// a positive fPy.; 4423///; 4424/// To select only the elements that did match the original selection; 4425/// use TEventList::SetReapplyCut or TEntryList::SetReapplyCut.; 4426///; 4427/// Example:; 4428/// ~~~ {.cpp}; 4429/// tree.Draw("">>pyplus"",""fTrack",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:186005,Performance,optimiz,optimize,186005,"ault), it is then optionally compressed; 4566/// and written to disk (this operation is also called committing or; 4567/// 'flushing' the basket). The committed baskets are then; 4568/// immediately removed from memory.; 4569///; 4570/// The function returns the number of bytes committed to the; 4571/// individual branches.; 4572///; 4573/// If a write error occurs, the number of bytes returned is -1.; 4574///; 4575/// If no data are written, because, e.g., the branch is disabled,; 4576/// the number of bytes returned is 0.; 4577///; 4578/// __The baskets are flushed and the Tree header saved at regular intervals__; 4579///; 4580/// At regular intervals, when the amount of data written so far is; 4581/// greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; 4582/// This makes future reading faster as it guarantees that baskets belonging to nearby; 4583/// entries will be on the same disk region.; 4584/// When the first call to flush the baskets happen, we also take this opportunity; 4585/// to optimize the baskets buffers.; 4586/// We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; 4587/// In this case we also write the Tree header. This makes the Tree recoverable up to this point; 4588/// in case the program writing the Tree crashes.; 4589/// The decisions to FlushBaskets and Auto Save can be made based either on the number; 4590/// of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; 4591/// written (fAutoFlush and fAutoSave positive).; 4592/// Note that the user can decide to call FlushBaskets and AutoSave in her event loop; 4593/// base on the number of events written instead of the number of bytes written.; 4594///; 4595/// \note Calling `TTree::FlushBaskets` too often increases the IO time.; 4596///; 4597/// \note Calling `TTree::AutoSave` too often increases the IO time and also the; 4598/// file size.; 4599///; 4600/// \note This method calls `TTree::ChangeFile` wh",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:190705,Performance,optimiz,optimize,190705,"ave != 0) {; 4689 // Is it time to flush or autosave baskets?; 4690 if (fFlushedBytes == 0) {; 4691 // If fFlushedBytes == 0, it means we never flushed or saved, so; 4692 // we need to check if it's time to do it and recompute the values; 4693 // of fAutoFlush and fAutoSave in terms of the number of entries.; 4694 // Decision can be based initially either on the number of bytes; 4695 // or the number of entries written.; 4696 Long64_t zipBytes = GetZipBytes();; 4697 ; 4698 if (fAutoFlush); 4699 autoFlush = fAutoFlush < 0 ? (zipBytes > -fAutoFlush) : fEntries % fAutoFlush == 0;; 4700 ; 4701 if (fAutoSave); 4702 autoSave = fAutoSave < 0 ? (zipBytes > -fAutoSave) : fEntries % fAutoSave == 0;; 4703 ; 4704 if (autoFlush || autoSave) {; 4705 // First call FlushBasket to make sure that fTotBytes is up to date.; 4706 FlushBasketsImpl();; 4707 autoFlush = false; // avoid auto flushing again later; 4708 ; 4709 // When we are in one-basket-per-cluster mode, there is no need to optimize basket:; 4710 // they will automatically grow to the size needed for an event cluster (with the basket; 4711 // shrinking preventing them from growing too much larger than the actually-used space).; 4712 if (!TestBit(TTree::kOnlyFlushAtCluster)) {; 4713 OptimizeBaskets(GetTotBytes(), 1, """");; 4714 if (gDebug > 0); 4715 Info(""TTree::Fill"", ""OptimizeBaskets called at entry %lld, fZipBytes=%lld, fFlushedBytes=%lld\n"",; 4716 fEntries, GetZipBytes(), fFlushedBytes);; 4717 }; 4718 fFlushedBytes = GetZipBytes();; 4719 fAutoFlush = fEntries; // Use test on entries rather than bytes; 4720 ; 4721 // subsequently in run; 4722 if (fAutoSave < 0) {; 4723 // Set fAutoSave to the largest integer multiple of; 4724 // fAutoFlush events such that fAutoSave*fFlushedBytes; 4725 // < (minus the input value of fAutoSave); 4726 Long64_t totBytes = GetTotBytes();; 4727 if (zipBytes != 0) {; 4728 fAutoSave = TMath::Max(fAutoFlush, fEntries * ((-fAutoSave / zipBytes) / fEntries));; 4729 } else if (totBytes != 0) {; 4730 f",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:208483,Performance,load,load,208483,"hes[j].second;; 5181 if (R__unlikely(!branch)) { return; }; 5182 ; 5183 if (R__unlikely(gDebug > 0)) {; 5184 std::stringstream ss;; 5185 ss << std::this_thread::get_id();; 5186 Info(""FlushBaskets"", ""[IMT] Thread %s"", ss.str().c_str());; 5187 Info(""FlushBaskets"", ""[IMT] Running task for branch #%d: %s"", j, branch->GetName());; 5188 }; 5189 ; 5190 Int_t nbtask = branch->FlushBaskets();; 5191 ; 5192 if (nbtask < 0) { nerrpar++; }; 5193 else { nbpar += nbtask; }; 5194 };; 5195 ; 5196 ROOT::TThreadExecutor pool;; 5197 pool.Foreach(mapFunction, nb);; 5198 ; 5199 fIMTFlush = false;; 5200 const_cast<TTree*>(this)->AddTotBytes(fIMTTotBytes);; 5201 const_cast<TTree*>(this)->AddZipBytes(fIMTZipBytes);; 5202 ; 5203 return nerrpar ? -1 : nbpar.load();; 5204 }; 5205#endif; 5206 for (Int_t j = 0; j < nb; j++) {; 5207 TBranch* branch = (TBranch*) lb->UncheckedAt(j);; 5208 if (branch) {; 5209 Int_t nwrite = branch->FlushBaskets();; 5210 if (nwrite<0) {; 5211 ++nerror;; 5212 } else {; 5213 nbytes += nwrite;; 5214 }; 5215 }; 5216 }; 5217 if (nerror) {; 5218 return -1;; 5219 } else {; 5220 return nbytes;; 5221 }; 5222}; 5223 ; 5224////////////////////////////////////////////////////////////////////////////////; 5225/// Returns the expanded value of the alias. Search in the friends if any.; 5226 ; 5227const char* TTree::GetAlias(const char* aliasName) const; 5228{; 5229 // We already have been visited while recursively looking; 5230 // through the friends tree, let's return.; 5231 if (kGetAlias & fFriendLockStatus) {; 5232 return nullptr;; 5233 }; 5234 if (fAliases) {; 5235 TObject* alias = fAliases->FindObject(aliasName);; 5236 if (alias) {; 5237 return alias->GetTitle();; 5238 }; 5239 }; 5240 if (!fFriends) {; 5241 return nullptr;; 5242 }; 5243 TFriendLock lock(const_cast<TTree*>(this), kGetAlias);; 5244 TIter nextf(fFriends);; 5245 TFriendElement* fe = nullptr;; 5246 while ((fe = (TFriendElement*) nextf())) {; 5247 TTree* t = fe->GetTree();; 5248 if (t) {; 5249 const char* alias = t-",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:214108,Performance,cache,cache,214108,5362 subname += l;; 5363 if (*subname != '.') {; 5364 continue;; 5365 }; 5366 subname++;; 5367 TBranch* branch = t->GetBranch(subname);; 5368 if (branch) {; 5369 return branch;; 5370 }; 5371 }; 5372 return nullptr;; 5373}; 5374 ; 5375////////////////////////////////////////////////////////////////////////////////; 5376/// Return status of branch with name branchname.; 5377///; 5378/// - 0 if branch is not activated; 5379/// - 1 if branch is activated; 5380 ; 5381bool TTree::GetBranchStatus(const char* branchname) const; 5382{; 5383 TBranch* br = const_cast<TTree*>(this)->GetBranch(branchname);; 5384 if (br) {; 5385 return br->TestBit(kDoNotProcess) == 0;; 5386 }; 5387 return false;; 5388}; 5389 ; 5390////////////////////////////////////////////////////////////////////////////////; 5391/// Static function returning the current branch style.; 5392///; 5393/// - style = 0 old Branch; 5394/// - style = 1 new Bronch; 5395 ; 5396Int_t TTree::GetBranchStyle(); 5397{; 5398 return fgBranchStyle;; 5399}; 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402/// Used for automatic sizing of the cache.; 5403///; 5404/// Estimates a suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAuto,MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:214172,Performance,cache,cache,214172,}; 5372 return nullptr;; 5373}; 5374 ; 5375////////////////////////////////////////////////////////////////////////////////; 5376/// Return status of branch with name branchname.; 5377///; 5378/// - 0 if branch is not activated; 5379/// - 1 if branch is activated; 5380 ; 5381bool TTree::GetBranchStatus(const char* branchname) const; 5382{; 5383 TBranch* br = const_cast<TTree*>(this)->GetBranch(branchname);; 5384 if (br) {; 5385 return br->TestBit(kDoNotProcess) == 0;; 5386 }; 5387 return false;; 5388}; 5389 ; 5390////////////////////////////////////////////////////////////////////////////////; 5391/// Static function returning the current branch style.; 5392///; 5393/// - style = 0 old Branch; 5394/// - style = 1 new Bronch; 5395 ; 5396Int_t TTree::GetBranchStyle(); 5397{; 5398 return fgBranchStyle;; 5399}; 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402/// Used for automatic sizing of the cache.; 5403///; 5404/// Estimates a suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4,MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:214209,Performance,cache,cache,214209,/////////////////////////////////////////////////; 5376/// Return status of branch with name branchname.; 5377///; 5378/// - 0 if branch is not activated; 5379/// - 1 if branch is activated; 5380 ; 5381bool TTree::GetBranchStatus(const char* branchname) const; 5382{; 5383 TBranch* br = const_cast<TTree*>(this)->GetBranch(branchname);; 5384 if (br) {; 5385 return br->TestBit(kDoNotProcess) == 0;; 5386 }; 5387 return false;; 5388}; 5389 ; 5390////////////////////////////////////////////////////////////////////////////////; 5391/// Static function returning the current branch style.; 5392///; 5393/// - style = 0 old Branch; 5394/// - style = 1 new Bronch; 5395 ; 5396Int_t TTree::GetBranchStyle(); 5397{; 5398 return fgBranchStyle;; 5399}; 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402/// Used for automatic sizing of the cache.; 5403///; 5404/// Estimates a suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;,MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:214499,Performance,cache,cacheFactor,214499,"5 return br->TestBit(kDoNotProcess) == 0;; 5386 }; 5387 return false;; 5388}; 5389 ; 5390////////////////////////////////////////////////////////////////////////////////; 5391/// Static function returning the current branch style.; 5392///; 5393/// - style = 0 old Branch; 5394/// - style = 1 new Bronch; 5395 ; 5396Int_t TTree::GetBranchStyle(); 5397{; 5398 return fgBranchStyle;; 5399}; 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402/// Used for automatic sizing of the cache.; 5403///; 5404/// Estimates a suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:214535,Performance,cache,cacheSize,214535,"5 return br->TestBit(kDoNotProcess) == 0;; 5386 }; 5387 return false;; 5388}; 5389 ; 5390////////////////////////////////////////////////////////////////////////////////; 5391/// Static function returning the current branch style.; 5392///; 5393/// - style = 0 old Branch; 5394/// - style = 1 new Bronch; 5395 ; 5396Int_t TTree::GetBranchStyle(); 5397{; 5398 return fgBranchStyle;; 5399}; 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402/// Used for automatic sizing of the cache.; 5403///; 5404/// Estimates a suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:214584,Performance,cache,cacheSize,214584,"5 return br->TestBit(kDoNotProcess) == 0;; 5386 }; 5387 return false;; 5388}; 5389 ; 5390////////////////////////////////////////////////////////////////////////////////; 5391/// Static function returning the current branch style.; 5392///; 5393/// - style = 0 old Branch; 5394/// - style = 1 new Bronch; 5395 ; 5396Int_t TTree::GetBranchStyle(); 5397{; 5398 return fgBranchStyle;; 5399}; 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402/// Used for automatic sizing of the cache.; 5403///; 5404/// Estimates a suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:214606,Performance,cache,cacheFactor,214606,"5 return br->TestBit(kDoNotProcess) == 0;; 5386 }; 5387 return false;; 5388}; 5389 ; 5390////////////////////////////////////////////////////////////////////////////////; 5391/// Static function returning the current branch style.; 5392///; 5393/// - style = 0 old Branch; 5394/// - style = 1 new Bronch; 5395 ; 5396Int_t TTree::GetBranchStyle(); 5397{; 5398 return fgBranchStyle;; 5399}; 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402/// Used for automatic sizing of the cache.; 5403///; 5404/// Estimates a suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:214769,Performance,cache,cacheSize,214769,"5 return br->TestBit(kDoNotProcess) == 0;; 5386 }; 5387 return false;; 5388}; 5389 ; 5390////////////////////////////////////////////////////////////////////////////////; 5391/// Static function returning the current branch style.; 5392///; 5393/// - style = 0 old Branch; 5394/// - style = 1 new Bronch; 5395 ; 5396Int_t TTree::GetBranchStyle(); 5397{; 5398 return fgBranchStyle;; 5399}; 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402/// Used for automatic sizing of the cache.; 5403///; 5404/// Estimates a suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:214790,Performance,cache,cacheFactor,214790,"5 return br->TestBit(kDoNotProcess) == 0;; 5386 }; 5387 return false;; 5388}; 5389 ; 5390////////////////////////////////////////////////////////////////////////////////; 5391/// Static function returning the current branch style.; 5392///; 5393/// - style = 0 old Branch; 5394/// - style = 1 new Bronch; 5395 ; 5396Int_t TTree::GetBranchStyle(); 5397{; 5398 return fgBranchStyle;; 5399}; 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402/// Used for automatic sizing of the cache.; 5403///; 5404/// Estimates a suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:214880,Performance,cache,cacheSize,214880,"4/// - style = 1 new Bronch; 5395 ; 5396Int_t TTree::GetBranchStyle(); 5397{; 5398 return fgBranchStyle;; 5399}; 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402/// Used for automatic sizing of the cache.; 5403///; 5404/// Estimates a suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456///////////////",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:214901,Performance,cache,cacheFactor,214901,"4/// - style = 1 new Bronch; 5395 ; 5396Int_t TTree::GetBranchStyle(); 5397{; 5398 return fgBranchStyle;; 5399}; 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402/// Used for automatic sizing of the cache.; 5403///; 5404/// Estimates a suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456///////////////",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:214992,Performance,cache,cacheSize,214992," 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402/// Used for automatic sizing of the cache.; 5403///; 5404/// Estimates a suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:215013,Performance,cache,cacheFactor,215013," 5400 ; 5401////////////////////////////////////////////////////////////////////////////////; 5402/// Used for automatic sizing of the cache.; 5403///; 5404/// Estimates a suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:215097,Performance,cache,cacheSize,215097,"suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster of baskets starting at firstentry.; 5458///; 5459/// This iterator is not yet supported for TChain object.; 5460/// ~~~ {.cpp}; 5461/// TTree::TClusterIterator clusterIter ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:215133,Performance,cache,cacheSize,215133,"suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster of baskets starting at firstentry.; 5458///; 5459/// This iterator is not yet supported for TChain object.; 5460/// ~~~ {.cpp}; 5461/// TTree::TClusterIterator clusterIter ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:215179,Performance,cache,cacheSize,215179,"suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster of baskets starting at firstentry.; 5458///; 5459/// This iterator is not yet supported for TChain object.; 5460/// ~~~ {.cpp}; 5461/// TTree::TClusterIterator clusterIter ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:215245,Performance,cache,cacheFactor,215245,"suitable size for the tree cache based on AutoFlush.; 5405/// A cache sizing factor is taken from the configuration. If this yields zero; 5406/// and withDefault is true the historical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster of baskets starting at firstentry.; 5458///; 5459/// This iterator is not yet supported for TChain object.; 5460/// ~~~ {.cpp}; 5461/// TTree::TClusterIterator clusterIter ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:215343,Performance,cache,cacheFactor,215343,"torical algorithm for default size is used.; 5407 ; 5408Long64_t TTree::GetCacheAutoSize(bool withDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster of baskets starting at firstentry.; 5458///; 5459/// This iterator is not yet supported for TChain object.; 5460/// ~~~ {.cpp}; 5461/// TTree::TClusterIterator clusterIter = tree->GetClusterIterator(entry);; 5462/// Long64_t clusterStart;; 5463/// while( (clusterStart = clusterIter()) < tree->GetEntries() ) {; 5464/// printf(""The cluster starts at ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:215418,Performance,cache,cacheFactor,215418,"hDefault /* = false */ ); 5409{; 5410 auto calculateCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster of baskets starting at firstentry.; 5458///; 5459/// This iterator is not yet supported for TChain object.; 5460/// ~~~ {.cpp}; 5461/// TTree::TClusterIterator clusterIter = tree->GetClusterIterator(entry);; 5462/// Long64_t clusterStart;; 5463/// while( (clusterStart = clusterIter()) < tree->GetEntries() ) {; 5464/// printf(""The cluster starts at %lld and ends at %lld (inclusive)\n"",clusterStart,clusterIter.GetNextEntry()-1);; 5465/// }; 5466",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:215479,Performance,cache,cacheFactor,215479,"eCacheSize = [this](Double_t cacheFactor); 5411 {; 5412 Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster of baskets starting at firstentry.; 5458///; 5459/// This iterator is not yet supported for TChain object.; 5460/// ~~~ {.cpp}; 5461/// TTree::TClusterIterator clusterIter = tree->GetClusterIterator(entry);; 5462/// Long64_t clusterStart;; 5463/// while( (clusterStart = clusterIter()) < tree->GetEntries() ) {; 5464/// printf(""The cluster starts at %lld and ends at %lld (inclusive)\n"",clusterStart,clusterIter.GetNextEntry()-1);; 5465/// }; 5466/// ~~~; 5467 ; 5468TTree::TClusterIterator TTree::",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:215539,Performance,cache,cacheFactor,215539," Long64_t cacheSize = 0;; 5413 if (fAutoFlush < 0) {; 5414 cacheSize = Long64_t(-cacheFactor * fAutoFlush);; 5415 } else if (fAutoFlush == 0) {; 5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster of baskets starting at firstentry.; 5458///; 5459/// This iterator is not yet supported for TChain object.; 5460/// ~~~ {.cpp}; 5461/// TTree::TClusterIterator clusterIter = tree->GetClusterIterator(entry);; 5462/// Long64_t clusterStart;; 5463/// while( (clusterStart = clusterIter()) < tree->GetEntries() ) {; 5464/// printf(""The cluster starts at %lld and ends at %lld (inclusive)\n"",clusterStart,clusterIter.GetNextEntry()-1);; 5465/// }; 5466/// ~~~; 5467 ; 5468TTree::TClusterIterator TTree::GetClusterIterator(Long64_t firstentry); 5469{; 5470 /",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:215588,Performance,cache,cacheSize,215588,"5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster of baskets starting at firstentry.; 5458///; 5459/// This iterator is not yet supported for TChain object.; 5460/// ~~~ {.cpp}; 5461/// TTree::TClusterIterator clusterIter = tree->GetClusterIterator(entry);; 5462/// Long64_t clusterStart;; 5463/// while( (clusterStart = clusterIter()) < tree->GetEntries() ) {; 5464/// printf(""The cluster starts at %lld and ends at %lld (inclusive)\n"",clusterStart,clusterIter.GetNextEntry()-1);; 5465/// }; 5466/// ~~~; 5467 ; 5468TTree::TClusterIterator TTree::GetClusterIterator(Long64_t firstentry); 5469{; 5470 // create cache if wanted; 5471 if (fCacheDoAutoInit); 5472 SetCacheSizeAux();; 5473 ; 5474 return TClusterIterator(this,firstentry);; 5475}; 5476",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:215619,Performance,cache,cacheFactor,215619,"5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster of baskets starting at firstentry.; 5458///; 5459/// This iterator is not yet supported for TChain object.; 5460/// ~~~ {.cpp}; 5461/// TTree::TClusterIterator clusterIter = tree->GetClusterIterator(entry);; 5462/// Long64_t clusterStart;; 5463/// while( (clusterStart = clusterIter()) < tree->GetEntries() ) {; 5464/// printf(""The cluster starts at %lld and ends at %lld (inclusive)\n"",clusterStart,clusterIter.GetNextEntry()-1);; 5465/// }; 5466/// ~~~; 5467 ; 5468TTree::TClusterIterator TTree::GetClusterIterator(Long64_t firstentry); 5469{; 5470 // create cache if wanted; 5471 if (fCacheDoAutoInit); 5472 SetCacheSizeAux();; 5473 ; 5474 return TClusterIterator(this,firstentry);; 5475}; 5476",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:215650,Performance,cache,cacheSize,215650,"5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster of baskets starting at firstentry.; 5458///; 5459/// This iterator is not yet supported for TChain object.; 5460/// ~~~ {.cpp}; 5461/// TTree::TClusterIterator clusterIter = tree->GetClusterIterator(entry);; 5462/// Long64_t clusterStart;; 5463/// while( (clusterStart = clusterIter()) < tree->GetEntries() ) {; 5464/// printf(""The cluster starts at %lld and ends at %lld (inclusive)\n"",clusterStart,clusterIter.GetNextEntry()-1);; 5465/// }; 5466/// ~~~; 5467 ; 5468TTree::TClusterIterator TTree::GetClusterIterator(Long64_t firstentry); 5469{; 5470 // create cache if wanted; 5471 if (fCacheDoAutoInit); 5472 SetCacheSizeAux();; 5473 ; 5474 return TClusterIterator(this,firstentry);; 5475}; 5476",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:215673,Performance,cache,cacheSize,215673,"5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster of baskets starting at firstentry.; 5458///; 5459/// This iterator is not yet supported for TChain object.; 5460/// ~~~ {.cpp}; 5461/// TTree::TClusterIterator clusterIter = tree->GetClusterIterator(entry);; 5462/// Long64_t clusterStart;; 5463/// while( (clusterStart = clusterIter()) < tree->GetEntries() ) {; 5464/// printf(""The cluster starts at %lld and ends at %lld (inclusive)\n"",clusterStart,clusterIter.GetNextEntry()-1);; 5465/// }; 5466/// ~~~; 5467 ; 5468TTree::TClusterIterator TTree::GetClusterIterator(Long64_t firstentry); 5469{; 5470 // create cache if wanted; 5471 if (fCacheDoAutoInit); 5472 SetCacheSizeAux();; 5473 ; 5474 return TClusterIterator(this,firstentry);; 5475}; 5476",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:215713,Performance,cache,cacheSize,215713,"5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster of baskets starting at firstentry.; 5458///; 5459/// This iterator is not yet supported for TChain object.; 5460/// ~~~ {.cpp}; 5461/// TTree::TClusterIterator clusterIter = tree->GetClusterIterator(entry);; 5462/// Long64_t clusterStart;; 5463/// while( (clusterStart = clusterIter()) < tree->GetEntries() ) {; 5464/// printf(""The cluster starts at %lld and ends at %lld (inclusive)\n"",clusterStart,clusterIter.GetNextEntry()-1);; 5465/// }; 5466/// ~~~; 5467 ; 5468TTree::TClusterIterator TTree::GetClusterIterator(Long64_t firstentry); 5469{; 5470 // create cache if wanted; 5471 if (fCacheDoAutoInit); 5472 SetCacheSizeAux();; 5473 ; 5474 return TClusterIterator(this,firstentry);; 5475}; 5476",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:215752,Performance,cache,cacheSize,215752,"5416 const auto medianClusterSize = GetMedianClusterSize();; 5417 if (medianClusterSize > 0); 5418 cacheSize = Long64_t(cacheFactor * 1.5 * medianClusterSize * GetZipBytes() / (fEntries + 1));; 5419 else; 5420 cacheSize = Long64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster of baskets starting at firstentry.; 5458///; 5459/// This iterator is not yet supported for TChain object.; 5460/// ~~~ {.cpp}; 5461/// TTree::TClusterIterator clusterIter = tree->GetClusterIterator(entry);; 5462/// Long64_t clusterStart;; 5463/// while( (clusterStart = clusterIter()) < tree->GetEntries() ) {; 5464/// printf(""The cluster starts at %lld and ends at %lld (inclusive)\n"",clusterStart,clusterIter.GetNextEntry()-1);; 5465/// }; 5466/// ~~~; 5467 ; 5468TTree::TClusterIterator TTree::GetClusterIterator(Long64_t firstentry); 5469{; 5470 // create cache if wanted; 5471 if (fCacheDoAutoInit); 5472 SetCacheSizeAux();; 5473 ; 5474 return TClusterIterator(this,firstentry);; 5475}; 5476",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:215817,Performance,cache,cacheSize,215817,"64_t(cacheFactor * 1.5 * 30000000); // use the default value of fAutoFlush; 5421 } else {; 5422 cacheSize = Long64_t(cacheFactor * 1.5 * fAutoFlush * GetZipBytes() / (fEntries + 1));; 5423 }; 5424 if (cacheSize >= (INT_MAX / 4)) {; 5425 cacheSize = INT_MAX / 4;; 5426 }; 5427 return cacheSize;; 5428 };; 5429 ; 5430 const char *stcs;; 5431 Double_t cacheFactor = 0.0;; 5432 if (!(stcs = gSystem->Getenv(""ROOT_TTREECACHE_SIZE"")) || !*stcs) {; 5433 cacheFactor = gEnv->GetValue(""TTreeCache.Size"", 1.0);; 5434 } else {; 5435 cacheFactor = TString(stcs).Atof();; 5436 }; 5437 ; 5438 if (cacheFactor < 0.0) {; 5439 // ignore negative factors; 5440 cacheFactor = 0.0;; 5441 }; 5442 ; 5443 Long64_t cacheSize = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster of baskets starting at firstentry.; 5458///; 5459/// This iterator is not yet supported for TChain object.; 5460/// ~~~ {.cpp}; 5461/// TTree::TClusterIterator clusterIter = tree->GetClusterIterator(entry);; 5462/// Long64_t clusterStart;; 5463/// while( (clusterStart = clusterIter()) < tree->GetEntries() ) {; 5464/// printf(""The cluster starts at %lld and ends at %lld (inclusive)\n"",clusterStart,clusterIter.GetNextEntry()-1);; 5465/// }; 5466/// ~~~; 5467 ; 5468TTree::TClusterIterator TTree::GetClusterIterator(Long64_t firstentry); 5469{; 5470 // create cache if wanted; 5471 if (fCacheDoAutoInit); 5472 SetCacheSizeAux();; 5473 ; 5474 return TClusterIterator(this,firstentry);; 5475}; 5476 ; 5477////////////////////////////////////////////////////////////////////////////////; 5478/// Return pointer to the current file.; 5479 ; 5480TFile* TTree::GetCurrentFile() const; 5481{; 5482 if (!fDirectory || fDirectory==",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:216534,Performance,cache,cache,216534,"Size = calculateCacheSize(cacheFactor);; 5444 ; 5445 if (cacheSize < 0) {; 5446 cacheSize = 0;; 5447 }; 5448 ; 5449 if (cacheSize == 0 && withDefault) {; 5450 cacheSize = calculateCacheSize(1.0);; 5451 }; 5452 ; 5453 return cacheSize;; 5454}; 5455 ; 5456////////////////////////////////////////////////////////////////////////////////; 5457/// Return an iterator over the cluster of baskets starting at firstentry.; 5458///; 5459/// This iterator is not yet supported for TChain object.; 5460/// ~~~ {.cpp}; 5461/// TTree::TClusterIterator clusterIter = tree->GetClusterIterator(entry);; 5462/// Long64_t clusterStart;; 5463/// while( (clusterStart = clusterIter()) < tree->GetEntries() ) {; 5464/// printf(""The cluster starts at %lld and ends at %lld (inclusive)\n"",clusterStart,clusterIter.GetNextEntry()-1);; 5465/// }; 5466/// ~~~; 5467 ; 5468TTree::TClusterIterator TTree::GetClusterIterator(Long64_t firstentry); 5469{; 5470 // create cache if wanted; 5471 if (fCacheDoAutoInit); 5472 SetCacheSizeAux();; 5473 ; 5474 return TClusterIterator(this,firstentry);; 5475}; 5476 ; 5477////////////////////////////////////////////////////////////////////////////////; 5478/// Return pointer to the current file.; 5479 ; 5480TFile* TTree::GetCurrentFile() const; 5481{; 5482 if (!fDirectory || fDirectory==gROOT) {; 5483 return nullptr;; 5484 }; 5485 return fDirectory->GetFile();; 5486}; 5487 ; 5488////////////////////////////////////////////////////////////////////////////////; 5489/// Return the number of entries matching the selection.; 5490/// Return -1 in case of errors.; 5491///; 5492/// If the selection uses any arrays or containers, we return the number; 5493/// of entries where at least one element match the selection.; 5494/// GetEntries is implemented using the selector class TSelectorEntries,; 5495/// which can be used directly (see code in TTreePlayer::GetEntries) for; 5496/// additional option.; 5497/// If SetEventList was used on the TTree or TChain, only that subset; 5498/// ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:223666,Performance,cache,cache,223666,"618///; 5619/// ## OPTION 3; 5620///; 5621/// ~~~ {.cpp}; 5622/// Same as option 1, but you delete yourself the event.; 5623///; 5624/// for (Long64_t i=0;i<nentries;i++) {; 5625/// delete event;; 5626/// event = 0; // EXTREMELY IMPORTANT; 5627/// T.GetEntry(i);; 5628/// // the object event has been filled at this point; 5629/// }; 5630/// ~~~; 5631/// It is strongly recommended to use the default option 1. It has the; 5632/// additional advantage that functions like TTree::Draw (internally calling; 5633/// TTree::GetEntry) will be functional even when the classes in the file are; 5634/// not available.; 5635///; 5636/// Note: See the comments in TBranchElement::SetAddress() for the; 5637/// object ownership policy of the underlying (user) data.; 5638 ; 5639Int_t TTree::GetEntry(Long64_t entry, Int_t getall); 5640{; 5641 // We already have been visited while recursively looking; 5642 // through the friends tree, let return; 5643 if (kGetEntry & fFriendLockStatus) return 0;; 5644 ; 5645 if (entry < 0 || entry >= fEntries) return 0;; 5646 Int_t i;; 5647 Int_t nbytes = 0;; 5648 fReadEntry = entry;; 5649 ; 5650 // create cache if wanted; 5651 if (fCacheDoAutoInit); 5652 SetCacheSizeAux();; 5653 ; 5654 Int_t nbranches = fBranches.GetEntriesUnsafe();; 5655 Int_t nb=0;; 5656 ; 5657 auto seqprocessing = [&]() {; 5658 TBranch *branch;; 5659 for (i=0;i<nbranches;i++) {; 5660 branch = (TBranch*)fBranches.UncheckedAt(i);; 5661 nb = branch->GetEntry(entry, getall);; 5662 if (nb < 0) break;; 5663 nbytes += nb;; 5664 }; 5665 };; 5666 ; 5667#ifdef R__USE_IMT; 5668 if (nbranches > 1 && ROOT::IsImplicitMTEnabled() && fIMTEnabled && !TTreeCacheUnzip::IsParallelUnzip()) {; 5669 if (fSortedBranches.empty()); 5670 InitializeBranchLists(true);; 5671 ; 5672 // Count branches are processed first and sequentially; 5673 for (auto branch : fSeqBranches) {; 5674 nb = branch->GetEntry(entry, getall);; 5675 if (nb < 0) break;; 5676 nbytes += nb;; 5677 }; 5678 if (nb < 0) return nb;; 5679 ; 5680 /",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:231945,Performance,perform,performs,231945,"///////////////////////////////////////////////////////////; 5853///Returns the entry list assigned to this tree; 5854 ; 5855TEntryList* TTree::GetEntryList(); 5856{; 5857 return fEntryList;; 5858}; 5859 ; 5860////////////////////////////////////////////////////////////////////////////////; 5861/// Return entry number corresponding to entry.; 5862///; 5863/// if no TEntryList set returns entry; 5864/// else returns the entry number corresponding to the list index=entry; 5865 ; 5866Long64_t TTree::GetEntryNumber(Long64_t entry) const; 5867{; 5868 if (!fEntryList) {; 5869 return entry;; 5870 }; 5871 ; 5872 return fEntryList->GetEntry(entry);; 5873}; 5874 ; 5875////////////////////////////////////////////////////////////////////////////////; 5876/// Return entry number corresponding to major and minor number.; 5877/// Note that this function returns only the entry number, not the data; 5878/// To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; 5879/// the BuildIndex function has created a table of Long64_t* of sorted values; 5880/// corresponding to val = major<<31 + minor;; 5881/// The function performs binary search in this sorted table.; 5882/// If it finds a pair that matches val, it returns directly the; 5883/// index in the table.; 5884/// If an entry corresponding to major and minor is not found, the function; 5885/// returns the index of the major,minor pair immediately lower than the; 5886/// requested value, ie it will return -1 if the pair is lower than; 5887/// the first entry in the index.; 5888///; 5889/// See also GetEntryNumberWithIndex; 5890 ; 5891Long64_t TTree::GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; 5892{; 5893 if (!fTreeIndex) {; 5894 return -1;; 5895 }; 5896 return fTreeIndex->GetEntryNumberWithBestIndex(major, minor);; 5897}; 5898 ; 5899////////////////////////////////////////////////////////////////////////////////; 5900/// Return entry number corresponding to major and minor number.; 5901/",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:233122,Performance,perform,performs,233122," table.; 5882/// If it finds a pair that matches val, it returns directly the; 5883/// index in the table.; 5884/// If an entry corresponding to major and minor is not found, the function; 5885/// returns the index of the major,minor pair immediately lower than the; 5886/// requested value, ie it will return -1 if the pair is lower than; 5887/// the first entry in the index.; 5888///; 5889/// See also GetEntryNumberWithIndex; 5890 ; 5891Long64_t TTree::GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; 5892{; 5893 if (!fTreeIndex) {; 5894 return -1;; 5895 }; 5896 return fTreeIndex->GetEntryNumberWithBestIndex(major, minor);; 5897}; 5898 ; 5899////////////////////////////////////////////////////////////////////////////////; 5900/// Return entry number corresponding to major and minor number.; 5901/// Note that this function returns only the entry number, not the data; 5902/// To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; 5903/// the BuildIndex function has created a table of Long64_t* of sorted values; 5904/// corresponding to val = major<<31 + minor;; 5905/// The function performs binary search in this sorted table.; 5906/// If it finds a pair that matches val, it returns directly the; 5907/// index in the table, otherwise it returns -1.; 5908///; 5909/// See also GetEntryNumberWithBestIndex; 5910 ; 5911Long64_t TTree::GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; 5912{; 5913 if (!fTreeIndex) {; 5914 return -1;; 5915 }; 5916 return fTreeIndex->GetEntryNumberWithIndex(major, minor);; 5917}; 5918 ; 5919////////////////////////////////////////////////////////////////////////////////; 5920/// Read entry corresponding to major and minor number.; 5921///; 5922/// The function returns the total number of bytes read.; 5923/// If the Tree has friend trees, the corresponding entry with; 5924/// the index values (major,minor) is read. Note that the master Tree; 5925/// and its friend may have different entry se",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:234430,Performance,cache,cache,234430,"r) const; 5912{; 5913 if (!fTreeIndex) {; 5914 return -1;; 5915 }; 5916 return fTreeIndex->GetEntryNumberWithIndex(major, minor);; 5917}; 5918 ; 5919////////////////////////////////////////////////////////////////////////////////; 5920/// Read entry corresponding to major and minor number.; 5921///; 5922/// The function returns the total number of bytes read.; 5923/// If the Tree has friend trees, the corresponding entry with; 5924/// the index values (major,minor) is read. Note that the master Tree; 5925/// and its friend may have different entry serial numbers corresponding; 5926/// to (major,minor).; 5927 ; 5928Int_t TTree::GetEntryWithIndex(Int_t major, Int_t minor); 5929{; 5930 // We already have been visited while recursively looking; 5931 // through the friends tree, let's return.; 5932 if (kGetEntryWithIndex & fFriendLockStatus) {; 5933 return 0;; 5934 }; 5935 Long64_t serial = GetEntryNumberWithIndex(major, minor);; 5936 if (serial < 0) {; 5937 return -1;; 5938 }; 5939 // create cache if wanted; 5940 if (fCacheDoAutoInit); 5941 SetCacheSizeAux();; 5942 ; 5943 Int_t i;; 5944 Int_t nbytes = 0;; 5945 fReadEntry = serial;; 5946 TBranch *branch;; 5947 Int_t nbranches = fBranches.GetEntriesFast();; 5948 Int_t nb;; 5949 for (i = 0; i < nbranches; ++i) {; 5950 branch = (TBranch*)fBranches.UncheckedAt(i);; 5951 nb = branch->GetEntry(serial);; 5952 if (nb < 0) return nb;; 5953 nbytes += nb;; 5954 }; 5955 // GetEntry in list of friends; 5956 if (!fFriends) return nbytes;; 5957 TFriendLock lock(this,kGetEntryWithIndex);; 5958 TIter nextf(fFriends);; 5959 TFriendElement* fe = nullptr;; 5960 while ((fe = (TFriendElement*) nextf())) {; 5961 TTree *t = fe->GetTree();; 5962 if (t) {; 5963 serial = t->GetEntryNumberWithIndex(major,minor);; 5964 if (serial <0) return -nbytes;; 5965 nb = t->GetEntry(serial);; 5966 if (nb < 0) return nb;; 5967 nbytes += nb;; 5968 }; 5969 }; 5970 return nbytes;; 5971}; 5972 ; 5973//////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:244910,Performance,cache,cache,244910,"| (kGetLeaf & fFriendLockStatus)); 6221 return nullptr;; 6222 ; 6223 std::string path(name);; 6224 const auto sep = path.find_last_of('/');; 6225 if (sep != std::string::npos); 6226 return GetLeafImpl(path.substr(0, sep).c_str(), name+sep+1);; 6227 ; 6228 return GetLeafImpl(nullptr, name);; 6229}; 6230 ; 6231////////////////////////////////////////////////////////////////////////////////; 6232/// Return maximum of column with name columname.; 6233/// if the Tree has an associated TEventList or TEntryList, the maximum; 6234/// is computed for the entries in this list.; 6235 ; 6236Double_t TTree::GetMaximum(const char* columname); 6237{; 6238 TLeaf* leaf = this->GetLeaf(columname);; 6239 if (!leaf) {; 6240 return 0;; 6241 }; 6242 ; 6243 // create cache if wanted; 6244 if (fCacheDoAutoInit); 6245 SetCacheSizeAux();; 6246 ; 6247 TBranch* branch = leaf->GetBranch();; 6248 Double_t cmax = -DBL_MAX;; 6249 for (Long64_t i = 0; i < fEntries; ++i) {; 6250 Long64_t entryNumber = this->GetEntryNumber(i);; 6251 if (entryNumber < 0) break;; 6252 branch->GetEntry(entryNumber);; 6253 for (Int_t j = 0; j < leaf->GetLen(); ++j) {; 6254 Double_t val = leaf->GetValue(j);; 6255 if (val > cmax) {; 6256 cmax = val;; 6257 }; 6258 }; 6259 }; 6260 return cmax;; 6261}; 6262 ; 6263////////////////////////////////////////////////////////////////////////////////; 6264/// Static function which returns the tree file size limit in bytes.; 6265 ; 6266Long64_t TTree::GetMaxTreeSize(); 6267{; 6268 return fgMaxTreeSize;; 6269}; 6270 ; 6271////////////////////////////////////////////////////////////////////////////////; 6272/// Return minimum of column with name columname.; 6273/// if the Tree has an associated TEventList or TEntryList, the minimum; 6274/// is computed for the entries in this list.; 6275 ; 6276Double_t TTree::GetMinimum(const char* columname); 6277{; 6278 TLeaf* leaf = this->GetLeaf(columname);; 6279 if (!leaf) {; 6280 return 0;; 6281 }; 6282 ; 6283 // create cache if wanted; 6284 if (fC",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:246128,Performance,cache,cache,246128,"val;; 6257 }; 6258 }; 6259 }; 6260 return cmax;; 6261}; 6262 ; 6263////////////////////////////////////////////////////////////////////////////////; 6264/// Static function which returns the tree file size limit in bytes.; 6265 ; 6266Long64_t TTree::GetMaxTreeSize(); 6267{; 6268 return fgMaxTreeSize;; 6269}; 6270 ; 6271////////////////////////////////////////////////////////////////////////////////; 6272/// Return minimum of column with name columname.; 6273/// if the Tree has an associated TEventList or TEntryList, the minimum; 6274/// is computed for the entries in this list.; 6275 ; 6276Double_t TTree::GetMinimum(const char* columname); 6277{; 6278 TLeaf* leaf = this->GetLeaf(columname);; 6279 if (!leaf) {; 6280 return 0;; 6281 }; 6282 ; 6283 // create cache if wanted; 6284 if (fCacheDoAutoInit); 6285 SetCacheSizeAux();; 6286 ; 6287 TBranch* branch = leaf->GetBranch();; 6288 Double_t cmin = DBL_MAX;; 6289 for (Long64_t i = 0; i < fEntries; ++i) {; 6290 Long64_t entryNumber = this->GetEntryNumber(i);; 6291 if (entryNumber < 0) break;; 6292 branch->GetEntry(entryNumber);; 6293 for (Int_t j = 0;j < leaf->GetLen(); ++j) {; 6294 Double_t val = leaf->GetValue(j);; 6295 if (val < cmin) {; 6296 cmin = val;; 6297 }; 6298 }; 6299 }; 6300 return cmin;; 6301}; 6302 ; 6303////////////////////////////////////////////////////////////////////////////////; 6304/// Load the TTreePlayer (if not already done).; 6305 ; 6306TVirtualTreePlayer* TTree::GetPlayer(); 6307{; 6308 if (fPlayer) {; 6309 return fPlayer;; 6310 }; 6311 fPlayer = TVirtualTreePlayer::TreePlayer(this);; 6312 return fPlayer;; 6313}; 6314 ; 6315////////////////////////////////////////////////////////////////////////////////; 6316/// Find and return the TTreeCache registered with the file and which may; 6317/// contain branches for us.; 6318 ; 6319TTreeCache *TTree::GetReadCache(TFile *file) const; 6320{; 6321 TTreeCache *pe = dynamic_cast<TTreeCache*>(file->GetCacheRead(GetTree()));; 6322 if (pe && pe->GetTree() != G",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:247656,Performance,cache,cache,247656,"///////////////////////////////////////////////////////////; 6304/// Load the TTreePlayer (if not already done).; 6305 ; 6306TVirtualTreePlayer* TTree::GetPlayer(); 6307{; 6308 if (fPlayer) {; 6309 return fPlayer;; 6310 }; 6311 fPlayer = TVirtualTreePlayer::TreePlayer(this);; 6312 return fPlayer;; 6313}; 6314 ; 6315////////////////////////////////////////////////////////////////////////////////; 6316/// Find and return the TTreeCache registered with the file and which may; 6317/// contain branches for us.; 6318 ; 6319TTreeCache *TTree::GetReadCache(TFile *file) const; 6320{; 6321 TTreeCache *pe = dynamic_cast<TTreeCache*>(file->GetCacheRead(GetTree()));; 6322 if (pe && pe->GetTree() != GetTree()); 6323 pe = nullptr;; 6324 return pe;; 6325}; 6326 ; 6327////////////////////////////////////////////////////////////////////////////////; 6328/// Find and return the TTreeCache registered with the file and which may; 6329/// contain branches for us. If create is true and there is no cache; 6330/// a new cache is created with default size.; 6331 ; 6332TTreeCache *TTree::GetReadCache(TFile *file, bool create); 6333{; 6334 TTreeCache *pe = GetReadCache(file);; 6335 if (create && !pe) {; 6336 if (fCacheDoAutoInit); 6337 SetCacheSizeAux(true, -1);; 6338 pe = dynamic_cast<TTreeCache*>(file->GetCacheRead(GetTree()));; 6339 if (pe && pe->GetTree() != GetTree()) pe = nullptr;; 6340 }; 6341 return pe;; 6342}; 6343 ; 6344////////////////////////////////////////////////////////////////////////////////; 6345/// Return a pointer to the list containing user objects associated to this tree.; 6346///; 6347/// The list is automatically created if it does not exist.; 6348///; 6349/// WARNING: By default the TTree destructor will delete all objects added; 6350/// to this list. If you do not want these objects to be deleted,; 6351/// call:; 6352///; 6353/// mytree->GetUserInfo()->Clear();; 6354///; 6355/// before deleting the tree.; 6356 ; 6357TList* TTree::GetUserInfo(); 6358{; 6359 if (!fUserI",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:247677,Performance,cache,cache,247677,"///////////////////////////////////////////////////////////; 6304/// Load the TTreePlayer (if not already done).; 6305 ; 6306TVirtualTreePlayer* TTree::GetPlayer(); 6307{; 6308 if (fPlayer) {; 6309 return fPlayer;; 6310 }; 6311 fPlayer = TVirtualTreePlayer::TreePlayer(this);; 6312 return fPlayer;; 6313}; 6314 ; 6315////////////////////////////////////////////////////////////////////////////////; 6316/// Find and return the TTreeCache registered with the file and which may; 6317/// contain branches for us.; 6318 ; 6319TTreeCache *TTree::GetReadCache(TFile *file) const; 6320{; 6321 TTreeCache *pe = dynamic_cast<TTreeCache*>(file->GetCacheRead(GetTree()));; 6322 if (pe && pe->GetTree() != GetTree()); 6323 pe = nullptr;; 6324 return pe;; 6325}; 6326 ; 6327////////////////////////////////////////////////////////////////////////////////; 6328/// Find and return the TTreeCache registered with the file and which may; 6329/// contain branches for us. If create is true and there is no cache; 6330/// a new cache is created with default size.; 6331 ; 6332TTreeCache *TTree::GetReadCache(TFile *file, bool create); 6333{; 6334 TTreeCache *pe = GetReadCache(file);; 6335 if (create && !pe) {; 6336 if (fCacheDoAutoInit); 6337 SetCacheSizeAux(true, -1);; 6338 pe = dynamic_cast<TTreeCache*>(file->GetCacheRead(GetTree()));; 6339 if (pe && pe->GetTree() != GetTree()) pe = nullptr;; 6340 }; 6341 return pe;; 6342}; 6343 ; 6344////////////////////////////////////////////////////////////////////////////////; 6345/// Return a pointer to the list containing user objects associated to this tree.; 6346///; 6347/// The list is automatically created if it does not exist.; 6348///; 6349/// WARNING: By default the TTree destructor will delete all objects added; 6350/// to this list. If you do not want these objects to be deleted,; 6351/// call:; 6352///; 6353/// mytree->GetUserInfo()->Clear();; 6354///; 6355/// before deleting the tree.; 6356 ; 6357TList* TTree::GetUserInfo(); 6358{; 6359 if (!fUserI",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:252017,Performance,load,loading,252017," (fMaxEntries / 10);; 6420 for (Int_t i = 0; i < nb; ++i) {; 6421 TBranch* branch = (TBranch*) fBranches.UncheckedAt(i);; 6422 branch->KeepCircular(maxEntries);; 6423 }; 6424 if (fNClusterRange) {; 6425 Long64_t entriesOffset = fEntries - maxEntries;; 6426 Int_t oldsize = fNClusterRange;; 6427 for(Int_t i = 0, j = 0; j < oldsize; ++j) {; 6428 if (fClusterRangeEnd[j] > entriesOffset) {; 6429 fClusterRangeEnd[i] = fClusterRangeEnd[j] - entriesOffset;; 6430 ++i;; 6431 } else {; 6432 --fNClusterRange;; 6433 }; 6434 }; 6435 }; 6436 fEntries = maxEntries;; 6437 fReadEntry = -1;; 6438}; 6439 ; 6440////////////////////////////////////////////////////////////////////////////////; 6441/// Read in memory all baskets from all branches up to the limit of maxmemory bytes.; 6442///; 6443/// If maxmemory is non null and positive SetMaxVirtualSize is called; 6444/// with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; 6445/// The function returns the total number of baskets read into memory; 6446/// if negative an error occurred while loading the branches.; 6447/// This method may be called to force branch baskets in memory; 6448/// when random access to branch entries is required.; 6449/// If random access to only a few branches is required, you should; 6450/// call directly TBranch::LoadBaskets.; 6451 ; 6452Int_t TTree::LoadBaskets(Long64_t maxmemory); 6453{; 6454 if (maxmemory > 0) SetMaxVirtualSize(maxmemory);; 6455 ; 6456 TIter next(GetListOfLeaves());; 6457 TLeaf *leaf;; 6458 Int_t nimported = 0;; 6459 while ((leaf=(TLeaf*)next())) {; 6460 nimported += leaf->GetBranch()->LoadBaskets();//break;; 6461 }; 6462 return nimported;; 6463}; 6464 ; 6465////////////////////////////////////////////////////////////////////////////////; 6466/// Set current entry.; 6467///; 6468/// Returns -2 if entry does not exist (just as TChain::LoadTree()).; 6469/// Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; 6470///; 6471/// Calls fNotify->",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:253515,Performance,cache,cache,253515,"////////////////////////////////////////////////////////////////////////////; 6466/// Set current entry.; 6467///; 6468/// Returns -2 if entry does not exist (just as TChain::LoadTree()).; 6469/// Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; 6470///; 6471/// Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; 6472///; 6473/// \note This function is overloaded in TChain.; 6474Long64_t TTree::LoadTree(Long64_t entry); 6475{; 6476 // We have already been visited while recursively looking; 6477 // through the friend trees, let's return; 6478 if (kLoadTree & fFriendLockStatus) {; 6479 // We need to return a negative value to avoid a circular list of friends; 6480 // to think that there is always an entry somewhere in the list.; 6481 return -1;; 6482 }; 6483 ; 6484 // create cache if wanted; 6485 if (fCacheDoAutoInit && entry >=0); 6486 SetCacheSizeAux();; 6487 ; 6488 if (fNotify) {; 6489 if (fReadEntry < 0) {; 6490 fNotify->Notify();; 6491 }; 6492 }; 6493 fReadEntry = entry;; 6494 ; 6495 bool friendHasEntry = false;; 6496 if (fFriends) {; 6497 // Set current entry in friends as well.; 6498 //; 6499 // An alternative would move this code to each of the; 6500 // functions calling LoadTree (and to overload a few more).; 6501 bool needUpdate = false;; 6502 {; 6503 // This scope is need to insure the lock is released at the right time; 6504 TIter nextf(fFriends);; 6505 TFriendLock lock(this, kLoadTree);; 6506 TFriendElement* fe = nullptr;; 6507 while ((fe = (TFriendElement*) nextf())) {; 6508 if (fe->TestBit(TFriendElement::kFromChain)) {; 6509 // This friend element was added by the chain that owns this; 6510 // tree, the chain will deal with loading the correct entry.; 6511 continue;; 6512 }; 6513 TTree* friendTree = fe->GetTree();; 6514 if (friendTree) {; 6515 if (friendTree->LoadTreeFriend(entry, this) >= 0) {; 6516 friendHasEntry = true;; 6517 }; 6518 }; 6519 if (fe->IsUpdated()) {; 65",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:254397,Performance,load,loading,254397,"ited while recursively looking; 6477 // through the friend trees, let's return; 6478 if (kLoadTree & fFriendLockStatus) {; 6479 // We need to return a negative value to avoid a circular list of friends; 6480 // to think that there is always an entry somewhere in the list.; 6481 return -1;; 6482 }; 6483 ; 6484 // create cache if wanted; 6485 if (fCacheDoAutoInit && entry >=0); 6486 SetCacheSizeAux();; 6487 ; 6488 if (fNotify) {; 6489 if (fReadEntry < 0) {; 6490 fNotify->Notify();; 6491 }; 6492 }; 6493 fReadEntry = entry;; 6494 ; 6495 bool friendHasEntry = false;; 6496 if (fFriends) {; 6497 // Set current entry in friends as well.; 6498 //; 6499 // An alternative would move this code to each of the; 6500 // functions calling LoadTree (and to overload a few more).; 6501 bool needUpdate = false;; 6502 {; 6503 // This scope is need to insure the lock is released at the right time; 6504 TIter nextf(fFriends);; 6505 TFriendLock lock(this, kLoadTree);; 6506 TFriendElement* fe = nullptr;; 6507 while ((fe = (TFriendElement*) nextf())) {; 6508 if (fe->TestBit(TFriendElement::kFromChain)) {; 6509 // This friend element was added by the chain that owns this; 6510 // tree, the chain will deal with loading the correct entry.; 6511 continue;; 6512 }; 6513 TTree* friendTree = fe->GetTree();; 6514 if (friendTree) {; 6515 if (friendTree->LoadTreeFriend(entry, this) >= 0) {; 6516 friendHasEntry = true;; 6517 }; 6518 }; 6519 if (fe->IsUpdated()) {; 6520 needUpdate = true;; 6521 fe->ResetUpdated();; 6522 }; 6523 } // for each friend; 6524 }; 6525 if (needUpdate) {; 6526 //update list of leaves in all TTreeFormula of the TTreePlayer (if any); 6527 if (fPlayer) {; 6528 fPlayer->UpdateFormulaLeaves();; 6529 }; 6530 //Notify user if requested; 6531 if (fNotify) {; 6532 if(!fNotify->Notify()) return -6;; 6533 }; 6534 }; 6535 }; 6536 ; 6537 if ((fReadEntry >= fEntries) && !friendHasEntry) {; 6538 fReadEntry = -1;; 6539 return -2;; 6540 }; 6541 return fReadEntry;; 6542}; 6543 ; 6544////////////",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:261154,Performance,load,loading,261154," point; 6668/// to source files which will be included by the generated skeleton.; 6669/// Method of the same name as the file(minus the extension and path); 6670/// will be called by the generated skeleton's Process method as follow:; 6671/// ~~~ {.cpp}; 6672/// [if (cutfilename())] htemp->Fill(macrofilename());; 6673/// ~~~; 6674/// ""option"" can be used select some of the optional features during; 6675/// the code generation. The possible options are:; 6676///; 6677/// - nohist : indicates that the generated ProcessFill should not fill the histogram.; 6678///; 6679/// 'maxUnrolling' controls how deep in the class hierarchy does the; 6680/// system 'unroll' classes that are not split. Unrolling a class; 6681/// allows direct access to its data members (this emulates the behavior; 6682/// of TTreeFormula).; 6683///; 6684/// The main features of this skeleton are:; 6685///; 6686/// * on-demand loading of branches; 6687/// * ability to use the 'branchname' as if it was a data member; 6688/// * protection against array out-of-bounds errors; 6689/// * ability to use the branch data as an object (when the user code is available); 6690///; 6691/// For example with Event.root, if; 6692/// ~~~ {.cpp}; 6693/// Double_t somePx = fTracks.fPx[2];; 6694/// ~~~; 6695/// is executed by one of the method of the skeleton,; 6696/// somePx will updated with the current value of fPx of the 3rd track.; 6697///; 6698/// Both macrofilename and the optional cutfilename are expected to be; 6699/// the name of source files which contain at least a free standing; 6700/// function with the signature:; 6701/// ~~~ {.cpp}; 6702/// x_t macrofilename(); // i.e function with the same name as the file; 6703/// ~~~; 6704/// and; 6705/// ~~~ {.cpp}; 6706/// y_t cutfilename(); // i.e function with the same name as the file; 6707/// ~~~; 6708/// x_t and y_t needs to be types that can convert respectively to a double; 6709/// and a bool (because the skeleton uses:; 6710///; 6711/// if (cutfilename()) hte",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:262536,Performance,cache,cache,262536,".fPx[2];; 6694/// ~~~; 6695/// is executed by one of the method of the skeleton,; 6696/// somePx will updated with the current value of fPx of the 3rd track.; 6697///; 6698/// Both macrofilename and the optional cutfilename are expected to be; 6699/// the name of source files which contain at least a free standing; 6700/// function with the signature:; 6701/// ~~~ {.cpp}; 6702/// x_t macrofilename(); // i.e function with the same name as the file; 6703/// ~~~; 6704/// and; 6705/// ~~~ {.cpp}; 6706/// y_t cutfilename(); // i.e function with the same name as the file; 6707/// ~~~; 6708/// x_t and y_t needs to be types that can convert respectively to a double; 6709/// and a bool (because the skeleton uses:; 6710///; 6711/// if (cutfilename()) htemp->Fill(macrofilename());; 6712///; 6713/// These two functions are run in a context such that the branch names are; 6714/// available as local variables of the correct (read-only) type.; 6715///; 6716/// Note that if you use the same 'variable' twice, it is more efficient; 6717/// to 'cache' the value. For example:; 6718/// ~~~ {.cpp}; 6719/// Int_t n = fEventNumber; // Read fEventNumber; 6720/// if (n<10 || n>10) { ... }; 6721/// ~~~; 6722/// is more efficient than; 6723/// ~~~ {.cpp}; 6724/// if (fEventNumber<10 || fEventNumber>10); 6725/// ~~~; 6726/// Also, optionally, the generated selector will also call methods named; 6727/// macrofilename_methodname in each of 6 main selector methods if the method; 6728/// macrofilename_methodname exist (Where macrofilename is stripped of its; 6729/// extension).; 6730///; 6731/// Concretely, with the script named h1analysisProxy.C,; 6732///; 6733/// - The method calls the method (if it exist); 6734/// - Begin -> void h1analysisProxy_Begin(TTree*);; 6735/// - SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; 6736/// - Notify -> bool h1analysisProxy_Notify();; 6737/// - Process -> bool h1analysisProxy_Process(Long64_t);; 6738/// - SlaveTerminate -> void h1analysisProxy_SlaveTerm",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:263836,Performance,load,loaded,263836,"Number>10); 6725/// ~~~; 6726/// Also, optionally, the generated selector will also call methods named; 6727/// macrofilename_methodname in each of 6 main selector methods if the method; 6728/// macrofilename_methodname exist (Where macrofilename is stripped of its; 6729/// extension).; 6730///; 6731/// Concretely, with the script named h1analysisProxy.C,; 6732///; 6733/// - The method calls the method (if it exist); 6734/// - Begin -> void h1analysisProxy_Begin(TTree*);; 6735/// - SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; 6736/// - Notify -> bool h1analysisProxy_Notify();; 6737/// - Process -> bool h1analysisProxy_Process(Long64_t);; 6738/// - SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; 6739/// - Terminate -> void h1analysisProxy_Terminate();; 6740///; 6741/// If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; 6742/// it is included before the declaration of the proxy class. This can; 6743/// be used in particular to insure that the include files needed by; 6744/// the macro file are properly loaded.; 6745///; 6746/// The default histogram is accessible via the variable named 'htemp'.; 6747///; 6748/// If the library of the classes describing the data in the branch is; 6749/// loaded, the skeleton will add the needed `include` statements and; 6750/// give the ability to access the object stored in the branches.; 6751///; 6752/// To draw px using the file hsimple.root (generated by the; 6753/// hsimple.C tutorial), we need a file named hsimple.cxx:; 6754/// ~~~ {.cpp}; 6755/// double hsimple() {; 6756/// return px;; 6757/// }; 6758/// ~~~; 6759/// MakeProxy can then be used indirectly via the TTree::Draw interface; 6760/// as follow:; 6761/// ~~~ {.cpp}; 6762/// new TFile(""hsimple.root""); 6763/// ntuple->Draw(""hsimple.cxx"");; 6764/// ~~~; 6765/// A more complete example is available in the tutorials directory:; 6766/// h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; 6767/// which reimplement the selecto",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:264024,Performance,load,loaded,264024,"; 6729/// extension).; 6730///; 6731/// Concretely, with the script named h1analysisProxy.C,; 6732///; 6733/// - The method calls the method (if it exist); 6734/// - Begin -> void h1analysisProxy_Begin(TTree*);; 6735/// - SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; 6736/// - Notify -> bool h1analysisProxy_Notify();; 6737/// - Process -> bool h1analysisProxy_Process(Long64_t);; 6738/// - SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; 6739/// - Terminate -> void h1analysisProxy_Terminate();; 6740///; 6741/// If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; 6742/// it is included before the declaration of the proxy class. This can; 6743/// be used in particular to insure that the include files needed by; 6744/// the macro file are properly loaded.; 6745///; 6746/// The default histogram is accessible via the variable named 'htemp'.; 6747///; 6748/// If the library of the classes describing the data in the branch is; 6749/// loaded, the skeleton will add the needed `include` statements and; 6750/// give the ability to access the object stored in the branches.; 6751///; 6752/// To draw px using the file hsimple.root (generated by the; 6753/// hsimple.C tutorial), we need a file named hsimple.cxx:; 6754/// ~~~ {.cpp}; 6755/// double hsimple() {; 6756/// return px;; 6757/// }; 6758/// ~~~; 6759/// MakeProxy can then be used indirectly via the TTree::Draw interface; 6760/// as follow:; 6761/// ~~~ {.cpp}; 6762/// new TFile(""hsimple.root""); 6763/// ntuple->Draw(""hsimple.cxx"");; 6764/// ~~~; 6765/// A more complete example is available in the tutorials directory:; 6766/// h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; 6767/// which reimplement the selector found in h1analysis.C; 6768 ; 6769Int_t TTree::MakeProxy(const char* proxyClassname, const char* macrofilename, const char* cutfilename, const char* option, Int_t maxUnrolling); 6770{; 6771 GetPlayer();; 6772 if (!fPlayer) return 0;; 6773 return fPlayer->MakeProxy",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:273290,Performance,cache,cache,273290,">Write();; 6949 delete newtree;; 6950 }; 6951 // Make sure things are really written out to disk before attempting any reading.; 6952 info->fOutputDirectory->GetFile()->Flush();; 6953 info->fOutputDirectory->ReadTObject(this,this->GetName());; 6954 }; 6955 }; 6956 if (!li) return 0;; 6957 Long64_t storeAutoSave = fAutoSave;; 6958 // Disable the autosave as the TFileMerge keeps a list of key and deleting the underlying; 6959 // key would invalidate its iteration (or require costly measure to not use the deleted keys).; 6960 // Also since this is part of a merging operation, the output file is not as precious as in; 6961 // the general case since the input file should still be around.; 6962 fAutoSave = 0;; 6963 TIter next(li);; 6964 TTree *tree;; 6965 while ((tree = (TTree*)next())) {; 6966 if (tree==this) continue;; 6967 if (!tree->InheritsFrom(TTree::Class())) {; 6968 Error(""Add"",""Attempt to add object of class: %s to a %s"", tree->ClassName(), ClassName());; 6969 fAutoSave = storeAutoSave;; 6970 return -1;; 6971 }; 6972 ; 6973 CopyEntries(tree, -1, options, true);; 6974 }; 6975 fAutoSave = storeAutoSave;; 6976 return GetEntries();; 6977}; 6978 ; 6979////////////////////////////////////////////////////////////////////////////////; 6980/// Move a cache from a file to the current file in dir.; 6981/// if src is null no operation is done, if dir is null or there is no; 6982/// current file the cache is deleted.; 6983 ; 6984void TTree::MoveReadCache(TFile *src, TDirectory *dir); 6985{; 6986 if (!src) return;; 6987 TFile *dst = (dir && dir != gROOT) ? dir->GetFile() : nullptr;; 6988 if (src == dst) return;; 6989 ; 6990 TTreeCache *pf = GetReadCache(src);; 6991 if (dst) {; 6992 src->SetCacheRead(nullptr,this);; 6993 dst->SetCacheRead(pf, this);; 6994 } else {; 6995 if (pf) {; 6996 pf->WaitFinishPrefetch();; 6997 }; 6998 src->SetCacheRead(nullptr,this);; 6999 delete pf;; 7000 }; 7001}; 7002 ; 7003///////////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:273438,Performance,cache,cache,273438,"rge keeps a list of key and deleting the underlying; 6959 // key would invalidate its iteration (or require costly measure to not use the deleted keys).; 6960 // Also since this is part of a merging operation, the output file is not as precious as in; 6961 // the general case since the input file should still be around.; 6962 fAutoSave = 0;; 6963 TIter next(li);; 6964 TTree *tree;; 6965 while ((tree = (TTree*)next())) {; 6966 if (tree==this) continue;; 6967 if (!tree->InheritsFrom(TTree::Class())) {; 6968 Error(""Add"",""Attempt to add object of class: %s to a %s"", tree->ClassName(), ClassName());; 6969 fAutoSave = storeAutoSave;; 6970 return -1;; 6971 }; 6972 ; 6973 CopyEntries(tree, -1, options, true);; 6974 }; 6975 fAutoSave = storeAutoSave;; 6976 return GetEntries();; 6977}; 6978 ; 6979////////////////////////////////////////////////////////////////////////////////; 6980/// Move a cache from a file to the current file in dir.; 6981/// if src is null no operation is done, if dir is null or there is no; 6982/// current file the cache is deleted.; 6983 ; 6984void TTree::MoveReadCache(TFile *src, TDirectory *dir); 6985{; 6986 if (!src) return;; 6987 TFile *dst = (dir && dir != gROOT) ? dir->GetFile() : nullptr;; 6988 if (src == dst) return;; 6989 ; 6990 TTreeCache *pf = GetReadCache(src);; 6991 if (dst) {; 6992 src->SetCacheRead(nullptr,this);; 6993 dst->SetCacheRead(pf, this);; 6994 } else {; 6995 if (pf) {; 6996 pf->WaitFinishPrefetch();; 6997 }; 6998 src->SetCacheRead(nullptr,this);; 6999 delete pf;; 7000 }; 7001}; 7002 ; 7003////////////////////////////////////////////////////////////////////////////////; 7004/// Copy the content to a new new file, update this TTree with the new; 7005/// location information and attach this TTree to the new directory.; 7006///; 7007/// options: Indicates a basket sorting method, see TTreeCloner::TTreeCloner for; 7008/// details; 7009///; 7010/// If new and old directory are in the same file, the data is untouched,; 7011/// this ""ju",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:275076,Performance,load,loading,275076,"//////////////////////; 7004/// Copy the content to a new new file, update this TTree with the new; 7005/// location information and attach this TTree to the new directory.; 7006///; 7007/// options: Indicates a basket sorting method, see TTreeCloner::TTreeCloner for; 7008/// details; 7009///; 7010/// If new and old directory are in the same file, the data is untouched,; 7011/// this ""just"" does a call to SetDirectory.; 7012/// Equivalent to an ""in place"" cloning of the TTree.; 7013bool TTree::InPlaceClone(TDirectory *newdirectory, const char *options); 7014{; 7015 if (!newdirectory) {; 7016 LoadBaskets(2*fTotBytes);; 7017 SetDirectory(nullptr);; 7018 return true;; 7019 }; 7020 if (newdirectory->GetFile() == GetCurrentFile()) {; 7021 SetDirectory(newdirectory);; 7022 return true;; 7023 }; 7024 TTreeCloner cloner(this, newdirectory, options);; 7025 if (cloner.IsValid()); 7026 return cloner.Exec();; 7027 else; 7028 return false;; 7029}; 7030 ; 7031////////////////////////////////////////////////////////////////////////////////; 7032/// Function called when loading a new class library.; 7033 ; 7034bool TTree::Notify(); 7035{; 7036 TIter next(GetListOfLeaves());; 7037 TLeaf* leaf = nullptr;; 7038 while ((leaf = (TLeaf*) next())) {; 7039 leaf->Notify();; 7040 leaf->GetBranch()->Notify();; 7041 }; 7042 return true;; 7043}; 7044 ; 7045////////////////////////////////////////////////////////////////////////////////; 7046/// This function may be called after having filled some entries in a Tree.; 7047/// Using the information in the existing branch buffers, it will reassign; 7048/// new branch buffer sizes to optimize time and memory.; 7049///; 7050/// The function computes the best values for branch buffer sizes such that; 7051/// the total buffer sizes is less than maxMemory and nearby entries written; 7052/// at the same time.; 7053/// In case the branch compression factor for the data written so far is less; 7054/// than compMin, the compression is disabled.; 7055///; 705",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:275633,Performance,optimiz,optimize,275633,"rectory) {; 7016 LoadBaskets(2*fTotBytes);; 7017 SetDirectory(nullptr);; 7018 return true;; 7019 }; 7020 if (newdirectory->GetFile() == GetCurrentFile()) {; 7021 SetDirectory(newdirectory);; 7022 return true;; 7023 }; 7024 TTreeCloner cloner(this, newdirectory, options);; 7025 if (cloner.IsValid()); 7026 return cloner.Exec();; 7027 else; 7028 return false;; 7029}; 7030 ; 7031////////////////////////////////////////////////////////////////////////////////; 7032/// Function called when loading a new class library.; 7033 ; 7034bool TTree::Notify(); 7035{; 7036 TIter next(GetListOfLeaves());; 7037 TLeaf* leaf = nullptr;; 7038 while ((leaf = (TLeaf*) next())) {; 7039 leaf->Notify();; 7040 leaf->GetBranch()->Notify();; 7041 }; 7042 return true;; 7043}; 7044 ; 7045////////////////////////////////////////////////////////////////////////////////; 7046/// This function may be called after having filled some entries in a Tree.; 7047/// Using the information in the existing branch buffers, it will reassign; 7048/// new branch buffer sizes to optimize time and memory.; 7049///; 7050/// The function computes the best values for branch buffer sizes such that; 7051/// the total buffer sizes is less than maxMemory and nearby entries written; 7052/// at the same time.; 7053/// In case the branch compression factor for the data written so far is less; 7054/// than compMin, the compression is disabled.; 7055///; 7056/// if option =""d"" an analysis report is printed.; 7057 ; 7058void TTree::OptimizeBaskets(ULong64_t maxMemory, Float_t minComp, Option_t *option); 7059{; 7060 //Flush existing baskets if the file is writable; 7061 if (this->GetDirectory()->IsWritable()) this->FlushBasketsImpl();; 7062 ; 7063 TString opt( option );; 7064 opt.ToLower();; 7065 bool pDebug = opt.Contains(""d"");; 7066 TObjArray *leaves = this->GetListOfLeaves();; 7067 Int_t nleaves = leaves->GetEntries();; 7068 Double_t treeSize = (Double_t)this->GetTotBytes();; 7069 ; 7070 if (nleaves == 0 || treeSize == 0) {; 7",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:279155,Performance,perform,performance,279155," 7112 UInt_t newBsize = UInt_t(bsize);; 7113 if (pass) { // only on the second pass so that it doesn't interfere with scaling; 7114 // If there is an entry offset, it will be stored in the same buffer as the object data; hence,; 7115 // we must bump up the size of the branch to account for this extra footprint.; 7116 // If fAutoFlush is not set yet, let's assume that it is 'in the process of being set' to; 7117 // the value of GetEntries().; 7118 Long64_t clusterSize = (fAutoFlush > 0) ? fAutoFlush : branch->GetEntries();; 7119 if (branch->GetEntryOffsetLen()) {; 7120 newBsize = newBsize + (clusterSize * sizeof(Int_t) * 2);; 7121 }; 7122 // We used ATLAS fully-split xAOD for testing, which is a rather unbalanced TTree, 10K branches,; 7123 // with 8K having baskets smaller than 512 bytes. To achieve good I/O performance ATLAS uses auto-flush 100,; 7124 // resulting in the smallest baskets being ~300-400 bytes, so this change increases their memory by about 8k*150B =~ 1MB,; 7125 // at the same time it significantly reduces the number of total baskets because it ensures that all 100 entries can be; 7126 // stored in a single basket (the old optimization tended to make baskets too small). In a toy example with fixed sized; 7127 // structures we found a factor of 2 fewer baskets needed in the new scheme.; 7128 // rounds up, increases basket size to ensure all entries fit into single basket as intended; 7129 newBsize = newBsize - newBsize%512 + 512;; 7130 }; 7131 if (newBsize < sizeOfOneEntry) newBsize = sizeOfOneEntry;; 7132 if (newBsize < bmin) newBsize = bmin;; 7133 if (newBsize > 10000000) newBsize = bmax;; 7134 if (pass) {; 7135 if (pDebug) Info(""OptimizeBaskets"", ""Changing buffer size from %6d to %6d bytes for %s\n"",oldBsize,newBsize,branch->GetName());; 7136 branch->SetBasketSize(newBsize);; 7137 }; 7138 newMemsize += newBsize;; 7139 // For this number to be somewhat accurate when newBsize is 'low'; 7140 // we do not include any space for meta data in the requested ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:279492,Performance,optimiz,optimization,279492," 7112 UInt_t newBsize = UInt_t(bsize);; 7113 if (pass) { // only on the second pass so that it doesn't interfere with scaling; 7114 // If there is an entry offset, it will be stored in the same buffer as the object data; hence,; 7115 // we must bump up the size of the branch to account for this extra footprint.; 7116 // If fAutoFlush is not set yet, let's assume that it is 'in the process of being set' to; 7117 // the value of GetEntries().; 7118 Long64_t clusterSize = (fAutoFlush > 0) ? fAutoFlush : branch->GetEntries();; 7119 if (branch->GetEntryOffsetLen()) {; 7120 newBsize = newBsize + (clusterSize * sizeof(Int_t) * 2);; 7121 }; 7122 // We used ATLAS fully-split xAOD for testing, which is a rather unbalanced TTree, 10K branches,; 7123 // with 8K having baskets smaller than 512 bytes. To achieve good I/O performance ATLAS uses auto-flush 100,; 7124 // resulting in the smallest baskets being ~300-400 bytes, so this change increases their memory by about 8k*150B =~ 1MB,; 7125 // at the same time it significantly reduces the number of total baskets because it ensures that all 100 entries can be; 7126 // stored in a single basket (the old optimization tended to make baskets too small). In a toy example with fixed sized; 7127 // structures we found a factor of 2 fewer baskets needed in the new scheme.; 7128 // rounds up, increases basket size to ensure all entries fit into single basket as intended; 7129 newBsize = newBsize - newBsize%512 + 512;; 7130 }; 7131 if (newBsize < sizeOfOneEntry) newBsize = sizeOfOneEntry;; 7132 if (newBsize < bmin) newBsize = bmin;; 7133 if (newBsize > 10000000) newBsize = bmax;; 7134 if (pass) {; 7135 if (pDebug) Info(""OptimizeBaskets"", ""Changing buffer size from %6d to %6d bytes for %s\n"",oldBsize,newBsize,branch->GetName());; 7136 branch->SetBasketSize(newBsize);; 7137 }; 7138 newMemsize += newBsize;; 7139 // For this number to be somewhat accurate when newBsize is 'low'; 7140 // we do not include any space for meta data in the requested ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:289471,Performance,cache,cache,289471," 7347 if (fBranchRef) fBranchRef->Print(option);; 7348 ; 7349 //print friends if option ""all""; 7350 if (!fFriends || !strstr(option,""all"")) return;; 7351 TIter nextf(fFriends);; 7352 TFriendLock lock(const_cast<TTree*>(this),kPrint);; 7353 TFriendElement *fr;; 7354 while ((fr = (TFriendElement*)nextf())) {; 7355 TTree * t = fr->GetTree();; 7356 if (t) t->Print(option);; 7357 }; 7358}; 7359 ; 7360////////////////////////////////////////////////////////////////////////////////; 7361/// Print statistics about the TreeCache for this tree.; 7362/// Like:; 7363/// ~~~ {.cpp}; 7364/// ******TreeCache statistics for file: cms2.root ******; 7365/// Reading 73921562 bytes in 716 transactions; 7366/// Average transaction = 103.242405 Kbytes; 7367/// Number of blocks in current cache: 202, total size : 6001193; 7368/// ~~~; 7369/// if option = ""a"" the list of blocks in the cache is printed; 7370 ; 7371void TTree::PrintCacheStats(Option_t* option) const; 7372{; 7373 TFile *f = GetCurrentFile();; 7374 if (!f) return;; 7375 TTreeCache *tc = GetReadCache(f);; 7376 if (tc) tc->Print(option);; 7377}; 7378 ; 7379////////////////////////////////////////////////////////////////////////////////; 7380/// Process this tree executing the TSelector code in the specified filename.; 7381/// The return value is -1 in case of error and TSelector::GetStatus() in; 7382/// in case of success.; 7383///; 7384/// The code in filename is loaded (interpreted or compiled, see below),; 7385/// filename must contain a valid class implementation derived from TSelector,; 7386/// where TSelector has the following member functions:; 7387///; 7388/// - `Begin()`: called every time a loop on the tree starts,; 7389/// a convenient place to create your histograms.; 7390/// - `SlaveBegin()`: called after Begin(), when on PROOF called only on the; 7391/// slave servers.; 7392/// - `Process()`: called for each event, in this function you decide what; 7393/// to read and fill your histograms.; 7394/// - `SlaveTerminat",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:289568,Performance,cache,cache,289568," 7347 if (fBranchRef) fBranchRef->Print(option);; 7348 ; 7349 //print friends if option ""all""; 7350 if (!fFriends || !strstr(option,""all"")) return;; 7351 TIter nextf(fFriends);; 7352 TFriendLock lock(const_cast<TTree*>(this),kPrint);; 7353 TFriendElement *fr;; 7354 while ((fr = (TFriendElement*)nextf())) {; 7355 TTree * t = fr->GetTree();; 7356 if (t) t->Print(option);; 7357 }; 7358}; 7359 ; 7360////////////////////////////////////////////////////////////////////////////////; 7361/// Print statistics about the TreeCache for this tree.; 7362/// Like:; 7363/// ~~~ {.cpp}; 7364/// ******TreeCache statistics for file: cms2.root ******; 7365/// Reading 73921562 bytes in 716 transactions; 7366/// Average transaction = 103.242405 Kbytes; 7367/// Number of blocks in current cache: 202, total size : 6001193; 7368/// ~~~; 7369/// if option = ""a"" the list of blocks in the cache is printed; 7370 ; 7371void TTree::PrintCacheStats(Option_t* option) const; 7372{; 7373 TFile *f = GetCurrentFile();; 7374 if (!f) return;; 7375 TTreeCache *tc = GetReadCache(f);; 7376 if (tc) tc->Print(option);; 7377}; 7378 ; 7379////////////////////////////////////////////////////////////////////////////////; 7380/// Process this tree executing the TSelector code in the specified filename.; 7381/// The return value is -1 in case of error and TSelector::GetStatus() in; 7382/// in case of success.; 7383///; 7384/// The code in filename is loaded (interpreted or compiled, see below),; 7385/// filename must contain a valid class implementation derived from TSelector,; 7386/// where TSelector has the following member functions:; 7387///; 7388/// - `Begin()`: called every time a loop on the tree starts,; 7389/// a convenient place to create your histograms.; 7390/// - `SlaveBegin()`: called after Begin(), when on PROOF called only on the; 7391/// slave servers.; 7392/// - `Process()`: called for each event, in this function you decide what; 7393/// to read and fill your histograms.; 7394/// - `SlaveTerminat",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:290119,Performance,load,loaded,290119,"/ ~~~ {.cpp}; 7364/// ******TreeCache statistics for file: cms2.root ******; 7365/// Reading 73921562 bytes in 716 transactions; 7366/// Average transaction = 103.242405 Kbytes; 7367/// Number of blocks in current cache: 202, total size : 6001193; 7368/// ~~~; 7369/// if option = ""a"" the list of blocks in the cache is printed; 7370 ; 7371void TTree::PrintCacheStats(Option_t* option) const; 7372{; 7373 TFile *f = GetCurrentFile();; 7374 if (!f) return;; 7375 TTreeCache *tc = GetReadCache(f);; 7376 if (tc) tc->Print(option);; 7377}; 7378 ; 7379////////////////////////////////////////////////////////////////////////////////; 7380/// Process this tree executing the TSelector code in the specified filename.; 7381/// The return value is -1 in case of error and TSelector::GetStatus() in; 7382/// in case of success.; 7383///; 7384/// The code in filename is loaded (interpreted or compiled, see below),; 7385/// filename must contain a valid class implementation derived from TSelector,; 7386/// where TSelector has the following member functions:; 7387///; 7388/// - `Begin()`: called every time a loop on the tree starts,; 7389/// a convenient place to create your histograms.; 7390/// - `SlaveBegin()`: called after Begin(), when on PROOF called only on the; 7391/// slave servers.; 7392/// - `Process()`: called for each event, in this function you decide what; 7393/// to read and fill your histograms.; 7394/// - `SlaveTerminate`: called at the end of the loop on the tree, when on PROOF; 7395/// called only on the slave servers.; 7396/// - `Terminate()`: called at the end of the loop on the tree,; 7397/// a convenient place to draw/fit your histograms.; 7398///; 7399/// If filename is of the form file.C, the file will be interpreted.; 7400///; 7401/// If filename is of the form file.C++, the file file.C will be compiled; 7402/// and dynamically loaded.; 7403///; 7404/// If filename is of the form file.C+, the file file.C will be compiled; 7405/// and dynamically loaded. At next ca",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:291120,Performance,load,loaded,291120,"de in filename is loaded (interpreted or compiled, see below),; 7385/// filename must contain a valid class implementation derived from TSelector,; 7386/// where TSelector has the following member functions:; 7387///; 7388/// - `Begin()`: called every time a loop on the tree starts,; 7389/// a convenient place to create your histograms.; 7390/// - `SlaveBegin()`: called after Begin(), when on PROOF called only on the; 7391/// slave servers.; 7392/// - `Process()`: called for each event, in this function you decide what; 7393/// to read and fill your histograms.; 7394/// - `SlaveTerminate`: called at the end of the loop on the tree, when on PROOF; 7395/// called only on the slave servers.; 7396/// - `Terminate()`: called at the end of the loop on the tree,; 7397/// a convenient place to draw/fit your histograms.; 7398///; 7399/// If filename is of the form file.C, the file will be interpreted.; 7400///; 7401/// If filename is of the form file.C++, the file file.C will be compiled; 7402/// and dynamically loaded.; 7403///; 7404/// If filename is of the form file.C+, the file file.C will be compiled; 7405/// and dynamically loaded. At next call, if file.C is older than file.o; 7406/// and file.so, the file.C is not compiled, only file.so is loaded.; 7407///; 7408/// ## NOTE1; 7409///; 7410/// It may be more interesting to invoke directly the other Process function; 7411/// accepting a TSelector* as argument.eg; 7412/// ~~~ {.cpp}; 7413/// MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; 7414/// selector->CallSomeFunction(..);; 7415/// mytree.Process(selector,..);; 7416/// ~~~; 7417/// ## NOTE2; 7418//; 7419/// One should not call this function twice with the same selector file; 7420/// in the same script. If this is required, proceed as indicated in NOTE1,; 7421/// by getting a pointer to the corresponding TSelector,eg; 7422///; 7423/// ### Workaround 1; 7424///; 7425/// ~~~ {.cpp}; 7426/// void stubs1() {; 7427/// TSelector *selector = TSelector::",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:291240,Performance,load,loaded,291240,"on derived from TSelector,; 7386/// where TSelector has the following member functions:; 7387///; 7388/// - `Begin()`: called every time a loop on the tree starts,; 7389/// a convenient place to create your histograms.; 7390/// - `SlaveBegin()`: called after Begin(), when on PROOF called only on the; 7391/// slave servers.; 7392/// - `Process()`: called for each event, in this function you decide what; 7393/// to read and fill your histograms.; 7394/// - `SlaveTerminate`: called at the end of the loop on the tree, when on PROOF; 7395/// called only on the slave servers.; 7396/// - `Terminate()`: called at the end of the loop on the tree,; 7397/// a convenient place to draw/fit your histograms.; 7398///; 7399/// If filename is of the form file.C, the file will be interpreted.; 7400///; 7401/// If filename is of the form file.C++, the file file.C will be compiled; 7402/// and dynamically loaded.; 7403///; 7404/// If filename is of the form file.C+, the file file.C will be compiled; 7405/// and dynamically loaded. At next call, if file.C is older than file.o; 7406/// and file.so, the file.C is not compiled, only file.so is loaded.; 7407///; 7408/// ## NOTE1; 7409///; 7410/// It may be more interesting to invoke directly the other Process function; 7411/// accepting a TSelector* as argument.eg; 7412/// ~~~ {.cpp}; 7413/// MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; 7414/// selector->CallSomeFunction(..);; 7415/// mytree.Process(selector,..);; 7416/// ~~~; 7417/// ## NOTE2; 7418//; 7419/// One should not call this function twice with the same selector file; 7420/// in the same script. If this is required, proceed as indicated in NOTE1,; 7421/// by getting a pointer to the corresponding TSelector,eg; 7422///; 7423/// ### Workaround 1; 7424///; 7425/// ~~~ {.cpp}; 7426/// void stubs1() {; 7427/// TSelector *selector = TSelector::GetSelector(""h1test.C"");; 7428/// TFile *f1 = new TFile(""stubs_nood_le1.root"");; 7429/// TTree *h1 = (TTree*)f1->Get(""h1",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:291359,Performance,load,loaded,291359," loop on the tree starts,; 7389/// a convenient place to create your histograms.; 7390/// - `SlaveBegin()`: called after Begin(), when on PROOF called only on the; 7391/// slave servers.; 7392/// - `Process()`: called for each event, in this function you decide what; 7393/// to read and fill your histograms.; 7394/// - `SlaveTerminate`: called at the end of the loop on the tree, when on PROOF; 7395/// called only on the slave servers.; 7396/// - `Terminate()`: called at the end of the loop on the tree,; 7397/// a convenient place to draw/fit your histograms.; 7398///; 7399/// If filename is of the form file.C, the file will be interpreted.; 7400///; 7401/// If filename is of the form file.C++, the file file.C will be compiled; 7402/// and dynamically loaded.; 7403///; 7404/// If filename is of the form file.C+, the file file.C will be compiled; 7405/// and dynamically loaded. At next call, if file.C is older than file.o; 7406/// and file.so, the file.C is not compiled, only file.so is loaded.; 7407///; 7408/// ## NOTE1; 7409///; 7410/// It may be more interesting to invoke directly the other Process function; 7411/// accepting a TSelector* as argument.eg; 7412/// ~~~ {.cpp}; 7413/// MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; 7414/// selector->CallSomeFunction(..);; 7415/// mytree.Process(selector,..);; 7416/// ~~~; 7417/// ## NOTE2; 7418//; 7419/// One should not call this function twice with the same selector file; 7420/// in the same script. If this is required, proceed as indicated in NOTE1,; 7421/// by getting a pointer to the corresponding TSelector,eg; 7422///; 7423/// ### Workaround 1; 7424///; 7425/// ~~~ {.cpp}; 7426/// void stubs1() {; 7427/// TSelector *selector = TSelector::GetSelector(""h1test.C"");; 7428/// TFile *f1 = new TFile(""stubs_nood_le1.root"");; 7429/// TTree *h1 = (TTree*)f1->Get(""h1"");; 7430/// h1->Process(selector);; 7431/// TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; 7432/// TTree *h2 = (TTree*)f2->Get(""h1",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:309605,Performance,load,load,309605,"RecursiveRemove(obj);; 7908 }; 7909}; 7910 ; 7911////////////////////////////////////////////////////////////////////////////////; 7912/// Refresh contents of this tree and its branches from the current status on disk.; 7913///; 7914/// One can call this function in case the tree file is being; 7915/// updated by another process.; 7916 ; 7917void TTree::Refresh(); 7918{; 7919 if (!fDirectory->GetFile()) {; 7920 return;; 7921 }; 7922 fDirectory->ReadKeys();; 7923 fDirectory->Remove(this);; 7924 TTree* tree; fDirectory->GetObject(GetName(),tree);; 7925 if (!tree) {; 7926 return;; 7927 }; 7928 //copy info from tree header into this Tree; 7929 fEntries = 0;; 7930 fNClusterRange = 0;; 7931 ImportClusterRanges(tree);; 7932 ; 7933 fAutoSave = tree->fAutoSave;; 7934 fEntries = tree->fEntries;; 7935 fTotBytes = tree->GetTotBytes();; 7936 fZipBytes = tree->GetZipBytes();; 7937 fSavedBytes = tree->fSavedBytes;; 7938 fTotalBuffers = tree->fTotalBuffers.load();; 7939 ; 7940 //loop on all branches and update them; 7941 Int_t nleaves = fLeaves.GetEntriesFast();; 7942 for (Int_t i = 0; i < nleaves; i++) {; 7943 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);; 7944 TBranch* branch = (TBranch*) leaf->GetBranch();; 7945 branch->Refresh(tree->GetBranch(branch->GetName()));; 7946 }; 7947 fDirectory->Remove(tree);; 7948 fDirectory->Append(this);; 7949 delete tree;; 7950 tree = nullptr;; 7951}; 7952 ; 7953////////////////////////////////////////////////////////////////////////////////; 7954/// Record a TFriendElement that we need to warn when the chain switches to; 7955/// a new file (typically this is because this chain is a friend of another; 7956/// TChain); 7957 ; 7958void TTree::RegisterExternalFriend(TFriendElement *fe); 7959{; 7960 if (!fExternalFriends); 7961 fExternalFriends = new TList();; 7962 fExternalFriends->Add(fe);; 7963}; 7964 ; 7965 ; 7966////////////////////////////////////////////////////////////////////////////////; 7967/// Removes external friend; 7968 ; 7969void TTre",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:318223,Performance,optimiz,optimize,318223,"sh.; 8167///; 8168/// ### CASE 1 : autof > 0; 8169///; 8170/// autof is the number of consecutive entries after which TTree::Fill will; 8171/// flush all branch buffers to disk.; 8172///; 8173/// ### CASE 2 : autof < 0; 8174///; 8175/// When filling the Tree the branch buffers will be flushed to disk when; 8176/// more than autof bytes have been written to the file. At the first FlushBaskets; 8177/// TTree::Fill will replace fAutoFlush by the current value of fEntries.; 8178///; 8179/// Calling this function with autof<0 is interesting when it is hard to estimate; 8180/// the size of one entry. This value is also independent of the Tree.; 8181///; 8182/// The Tree is initialized with fAutoFlush=-30000000, ie that, by default,; 8183/// the first AutoFlush will be done when 30 MBytes of data are written to the file.; 8184///; 8185/// ### CASE 3 : autof = 0; 8186///; 8187/// The AutoFlush mechanism is disabled.; 8188///; 8189/// Flushing the buffers at regular intervals optimize the location of; 8190/// consecutive entries on the disk by creating clusters of baskets.; 8191///; 8192/// A cluster of baskets is a set of baskets that contains all; 8193/// the data for a (consecutive) set of entries and that is stored; 8194/// consecutively on the disk. When reading all the branches, this; 8195/// is the minimum set of baskets that the TTreeCache will read.; 8196 ; 8197void TTree::SetAutoFlush(Long64_t autof /* = -30000000 */ ); 8198{; 8199 // Implementation note:; 8200 //; 8201 // A positive value of autoflush determines the size (in number of entries) of; 8202 // a cluster of baskets.; 8203 //; 8204 // If the value of autoflush is changed over time (this happens in; 8205 // particular when the TTree results from fast merging many trees),; 8206 // we record the values of fAutoFlush in the data members:; 8207 // fClusterRangeEnd and fClusterSize.; 8208 // In the code we refer to a range of entries where the size of the; 8209 // cluster of baskets is the same (i.e the value o",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:323224,Performance,cache,cache,323224,"sterRangeEnd = new Long64_t[fMaxClusterRange];; 8276 fClusterSize = new Long64_t[fMaxClusterRange];; 8277 }; 8278 }; 8279 fClusterRangeEnd[fNClusterRange] = fEntries - 1;; 8280 // If we are auto-flushing, then the cluster size is the same as the current auto-flush setting.; 8281 if (fAutoFlush > 0) {; 8282 // Even if the user triggers MarkEventRange prior to fAutoFlush being present, the TClusterIterator; 8283 // will appropriately go to the next event range.; 8284 fClusterSize[fNClusterRange] = fAutoFlush;; 8285 // Otherwise, assume there is one cluster per event range (e.g., user is manually controlling the flush).; 8286 } else if (fNClusterRange == 0) {; 8287 fClusterSize[fNClusterRange] = fEntries;; 8288 } else {; 8289 fClusterSize[fNClusterRange] = fClusterRangeEnd[fNClusterRange] - fClusterRangeEnd[fNClusterRange-1];; 8290 }; 8291 ++fNClusterRange;; 8292}; 8293 ; 8294/// Estimate the median cluster size for the TTree.; 8295/// This value provides e.g. a reasonable cache size default if other heuristics fail.; 8296/// Clusters with size 0 and the very last cluster range, that might not have been committed to fClusterSize yet,; 8297/// are ignored for the purposes of the calculation.; 8298Long64_t TTree::GetMedianClusterSize(); 8299{; 8300 std::vector<Long64_t> clusterSizesPerRange;; 8301 clusterSizesPerRange.reserve(fNClusterRange);; 8302 ; 8303 // We ignore cluster sizes of 0 for the purposes of this function.; 8304 // We also ignore the very last cluster range which might not have been committed to fClusterSize.; 8305 std::copy_if(fClusterSize, fClusterSize + fNClusterRange, std::back_inserter(clusterSizesPerRange),; 8306 [](Long64_t size) { return size != 0; });; 8307 ; 8308 std::vector<double> nClustersInRange; // we need to store doubles because of the signature of TMath::Median; 8309 nClustersInRange.reserve(clusterSizesPerRange.size());; 8310 ; 8311 auto clusterRangeStart = 0ll;; 8312 for (int i = 0; i < fNClusterRange; ++i) {; 8313 const auto size = fCl",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:337799,Performance,cache,cache,337799,"t(i);; 8637 branch = (TBranch*)leaf->GetBranch();; 8638 if (!branch->TestBit(kDoNotProcess)) {; 8639 leafcount = leaf->GetLeafCount();; 8640 if (leafcount) {; 8641 bcount = leafcount->GetBranch();; 8642 bcount->ResetBit(kDoNotProcess);; 8643 }; 8644 } else {; 8645 //Int_t nbranches = branch->GetListOfBranches()->GetEntriesFast();; 8646 Int_t nbranches = branch->GetListOfBranches()->GetEntries();; 8647 for (j=0;j<nbranches;j++) {; 8648 bson = (TBranch*)branch->GetListOfBranches()->UncheckedAt(j);; 8649 if (!bson) continue;; 8650 if (!bson->TestBit(kDoNotProcess)) {; 8651 if (bson->GetNleaves() <= 0) continue;; 8652 branch->ResetBit(kDoNotProcess);; 8653 break;; 8654 }; 8655 }; 8656 }; 8657 }; 8658}; 8659 ; 8660////////////////////////////////////////////////////////////////////////////////; 8661/// Set the current branch style. (static function); 8662///; 8663/// - style = 0 old Branch; 8664/// - style = 1 new Bronch; 8665 ; 8666void TTree::SetBranchStyle(Int_t style); 8667{; 8668 fgBranchStyle = style;; 8669}; 8670 ; 8671////////////////////////////////////////////////////////////////////////////////; 8672/// Set maximum size of the file cache .; 8673//; 8674/// - if cachesize = 0 the existing cache (if any) is deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be a",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:337829,Performance,cache,cachesize,337829,"2 bcount->ResetBit(kDoNotProcess);; 8643 }; 8644 } else {; 8645 //Int_t nbranches = branch->GetListOfBranches()->GetEntriesFast();; 8646 Int_t nbranches = branch->GetListOfBranches()->GetEntries();; 8647 for (j=0;j<nbranches;j++) {; 8648 bson = (TBranch*)branch->GetListOfBranches()->UncheckedAt(j);; 8649 if (!bson) continue;; 8650 if (!bson->TestBit(kDoNotProcess)) {; 8651 if (bson->GetNleaves() <= 0) continue;; 8652 branch->ResetBit(kDoNotProcess);; 8653 break;; 8654 }; 8655 }; 8656 }; 8657 }; 8658}; 8659 ; 8660////////////////////////////////////////////////////////////////////////////////; 8661/// Set the current branch style. (static function); 8662///; 8663/// - style = 0 old Branch; 8664/// - style = 1 new Bronch; 8665 ; 8666void TTree::SetBranchStyle(Int_t style); 8667{; 8668 fgBranchStyle = style;; 8669}; 8670 ; 8671////////////////////////////////////////////////////////////////////////////////; 8672/// Set maximum size of the file cache .; 8673//; 8674/// - if cachesize = 0 the existing cache (if any) is deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:337856,Performance,cache,cache,337856,"2 bcount->ResetBit(kDoNotProcess);; 8643 }; 8644 } else {; 8645 //Int_t nbranches = branch->GetListOfBranches()->GetEntriesFast();; 8646 Int_t nbranches = branch->GetListOfBranches()->GetEntries();; 8647 for (j=0;j<nbranches;j++) {; 8648 bson = (TBranch*)branch->GetListOfBranches()->UncheckedAt(j);; 8649 if (!bson) continue;; 8650 if (!bson->TestBit(kDoNotProcess)) {; 8651 if (bson->GetNleaves() <= 0) continue;; 8652 branch->ResetBit(kDoNotProcess);; 8653 break;; 8654 }; 8655 }; 8656 }; 8657 }; 8658}; 8659 ; 8660////////////////////////////////////////////////////////////////////////////////; 8661/// Set the current branch style. (static function); 8662///; 8663/// - style = 0 old Branch; 8664/// - style = 1 new Bronch; 8665 ; 8666void TTree::SetBranchStyle(Int_t style); 8667{; 8668 fgBranchStyle = style;; 8669}; 8670 ; 8671////////////////////////////////////////////////////////////////////////////////; 8672/// Set maximum size of the file cache .; 8673//; 8674/// - if cachesize = 0 the existing cache (if any) is deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:337897,Performance,cache,cachesize,337897,"Branches()->GetEntriesFast();; 8646 Int_t nbranches = branch->GetListOfBranches()->GetEntries();; 8647 for (j=0;j<nbranches;j++) {; 8648 bson = (TBranch*)branch->GetListOfBranches()->UncheckedAt(j);; 8649 if (!bson) continue;; 8650 if (!bson->TestBit(kDoNotProcess)) {; 8651 if (bson->GetNleaves() <= 0) continue;; 8652 branch->ResetBit(kDoNotProcess);; 8653 break;; 8654 }; 8655 }; 8656 }; 8657 }; 8658}; 8659 ; 8660////////////////////////////////////////////////////////////////////////////////; 8661/// Set the current branch style. (static function); 8662///; 8663/// - style = 0 old Branch; 8664/// - style = 1 new Bronch; 8665 ; 8666void TTree::SetBranchStyle(Int_t style); 8667{; 8668 fgBranchStyle = style;; 8669}; 8670 ; 8671////////////////////////////////////////////////////////////////////////////////; 8672/// Set maximum size of the file cache .; 8673//; 8674/// - if cachesize = 0 the existing cache (if any) is deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocach",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:338032,Performance,cache,cacheSize,338032,");; 8653 break;; 8654 }; 8655 }; 8656 }; 8657 }; 8658}; 8659 ; 8660////////////////////////////////////////////////////////////////////////////////; 8661/// Set the current branch style. (static function); 8662///; 8663/// - style = 0 old Branch; 8664/// - style = 1 new Bronch; 8665 ; 8666void TTree::SetBranchStyle(Int_t style); 8667{; 8668 fgBranchStyle = style;; 8669}; 8670 ; 8671////////////////////////////////////////////////////////////////////////////////; 8672/// Set maximum size of the file cache .; 8673//; 8674/// - if cachesize = 0 the existing cache (if any) is deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:338144,Performance,cache,cache,338144,");; 8653 break;; 8654 }; 8655 }; 8656 }; 8657 }; 8658}; 8659 ; 8660////////////////////////////////////////////////////////////////////////////////; 8661/// Set the current branch style. (static function); 8662///; 8663/// - style = 0 old Branch; 8664/// - style = 1 new Bronch; 8665 ; 8666void TTree::SetBranchStyle(Int_t style); 8667{; 8668 fgBranchStyle = style;; 8669}; 8670 ; 8671////////////////////////////////////////////////////////////////////////////////; 8672/// Set maximum size of the file cache .; 8673//; 8674/// - if cachesize = 0 the existing cache (if any) is deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:338244,Performance,cache,cacheSize,338244,");; 8653 break;; 8654 }; 8655 }; 8656 }; 8657 }; 8658}; 8659 ; 8660////////////////////////////////////////////////////////////////////////////////; 8661/// Set the current branch style. (static function); 8662///; 8663/// - style = 0 old Branch; 8664/// - style = 1 new Bronch; 8665 ; 8666void TTree::SetBranchStyle(Int_t style); 8667{; 8668 fgBranchStyle = style;; 8669}; 8670 ; 8671////////////////////////////////////////////////////////////////////////////////; 8672/// Set maximum size of the file cache .; 8673//; 8674/// - if cachesize = 0 the existing cache (if any) is deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:338320,Performance,cache,cache,338320,");; 8653 break;; 8654 }; 8655 }; 8656 }; 8657 }; 8658}; 8659 ; 8660////////////////////////////////////////////////////////////////////////////////; 8661/// Set the current branch style. (static function); 8662///; 8663/// - style = 0 old Branch; 8664/// - style = 1 new Bronch; 8665 ; 8666void TTree::SetBranchStyle(Int_t style); 8667{; 8668 fgBranchStyle = style;; 8669}; 8670 ; 8671////////////////////////////////////////////////////////////////////////////////; 8672/// Set maximum size of the file cache .; 8673//; 8674/// - if cachesize = 0 the existing cache (if any) is deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:338403,Performance,cache,cacheSize,338403,");; 8653 break;; 8654 }; 8655 }; 8656 }; 8657 }; 8658}; 8659 ; 8660////////////////////////////////////////////////////////////////////////////////; 8661/// Set the current branch style. (static function); 8662///; 8663/// - style = 0 old Branch; 8664/// - style = 1 new Bronch; 8665 ; 8666void TTree::SetBranchStyle(Int_t style); 8667{; 8668 fgBranchStyle = style;; 8669}; 8670 ; 8671////////////////////////////////////////////////////////////////////////////////; 8672/// Set maximum size of the file cache .; 8673//; 8674/// - if cachesize = 0 the existing cache (if any) is deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:338549,Performance,cache,cache,338549,");; 8653 break;; 8654 }; 8655 }; 8656 }; 8657 }; 8658}; 8659 ; 8660////////////////////////////////////////////////////////////////////////////////; 8661/// Set the current branch style. (static function); 8662///; 8663/// - style = 0 old Branch; 8664/// - style = 1 new Bronch; 8665 ; 8666void TTree::SetBranchStyle(Int_t style); 8667{; 8668 fgBranchStyle = style;; 8669}; 8670 ; 8671////////////////////////////////////////////////////////////////////////////////; 8672/// Set maximum size of the file cache .; 8673//; 8674/// - if cachesize = 0 the existing cache (if any) is deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:338658,Performance,cache,cache,338658,"= style;; 8669}; 8670 ; 8671////////////////////////////////////////////////////////////////////////////////; 8672/// Set maximum size of the file cache .; 8673//; 8674/// - if cachesize = 0 the existing cache (if any) is deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user reques",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:338717,Performance,cache,cache,338717,"= style;; 8669}; 8670 ; 8671////////////////////////////////////////////////////////////////////////////////; 8672/// Set maximum size of the file cache .; 8673//; 8674/// - if cachesize = 0 the existing cache (if any) is deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user reques",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:338768,Performance,cache,cacheSize,338768,"s deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSiz",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:338790,Performance,cache,cacheSize,338790,"s deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSiz",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:338809,Performance,cache,cache,338809,"s deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSiz",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:338826,Performance,cache,cache,338826,"s deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSiz",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:338863,Performance,cache,cacheSize,338863,"s deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSiz",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:338899,Performance,cache,cache,338899,"s deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSiz",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:338992,Performance,cache,cache,338992,"s deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSiz",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:338999,Performance,cache,cacheSize,338999,"//; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if the",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:339029,Performance,cache,cache,339029,"//; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if the",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:339050,Performance,cache,cache,339050,"FileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:339118,Performance,cache,cacheSize,339118,"1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCach",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:339252,Performance,cache,cache,339252,"1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCach",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:339289,Performance,cache,cache,339289,"ibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCacheSize = cacheSize;; 8738 }; 8739 if (GetTree() != this) {; 8740 return 0;; 8741 }; 8742 if (!autocache && cacheSize>0) {; 8743 Warning(""SetCacheSizeAux"", ""A TTreeCache could not be created because the TTree has no file"");; 8744 }; 8745 return 0;; 8746 }; 8747 ; 8748 // Check for an existing cache; 8749 TTreeCache* pf = GetReadCache(file);; 8750 if (pf) {; 8751 if (autocache) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:339422,Performance,cache,cacheSize,339422,"ibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCacheSize = cacheSize;; 8738 }; 8739 if (GetTree() != this) {; 8740 return 0;; 8741 }; 8742 if (!autocache && cacheSize>0) {; 8743 Warning(""SetCacheSizeAux"", ""A TTreeCache could not be created because the TTree has no file"");; 8744 }; 8745 return 0;; 8746 }; 8747 ; 8748 // Check for an existing cache; 8749 TTreeCache* pf = GetReadCache(file);; 8750 if (pf) {; 8751 if (autocache) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:339525,Performance,cache,cache,339525,"ibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCacheSize = cacheSize;; 8738 }; 8739 if (GetTree() != this) {; 8740 return 0;; 8741 }; 8742 if (!autocache && cacheSize>0) {; 8743 Warning(""SetCacheSizeAux"", ""A TTreeCache could not be created because the TTree has no file"");; 8744 }; 8745 return 0;; 8746 }; 8747 ; 8748 // Check for an existing cache; 8749 TTreeCache* pf = GetReadCache(file);; 8750 if (pf) {; 8751 if (autocache) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:339677,Performance,cache,cacheSize,339677,"ibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCacheSize = cacheSize;; 8738 }; 8739 if (GetTree() != this) {; 8740 return 0;; 8741 }; 8742 if (!autocache && cacheSize>0) {; 8743 Warning(""SetCacheSizeAux"", ""A TTreeCache could not be created because the TTree has no file"");; 8744 }; 8745 return 0;; 8746 }; 8747 ; 8748 // Check for an existing cache; 8749 TTreeCache* pf = GetReadCache(file);; 8750 if (pf) {; 8751 if (autocache) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:339700,Performance,cache,cacheSize,339700,"ibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCacheSize = cacheSize;; 8738 }; 8739 if (GetTree() != this) {; 8740 return 0;; 8741 }; 8742 if (!autocache && cacheSize>0) {; 8743 Warning(""SetCacheSizeAux"", ""A TTreeCache could not be created because the TTree has no file"");; 8744 }; 8745 return 0;; 8746 }; 8747 ; 8748 // Check for an existing cache; 8749 TTreeCache* pf = GetReadCache(file);; 8750 if (pf) {; 8751 if (autocache) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:339769,Performance,cache,cacheSize,339769,"ibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCacheSize = cacheSize;; 8738 }; 8739 if (GetTree() != this) {; 8740 return 0;; 8741 }; 8742 if (!autocache && cacheSize>0) {; 8743 Warning(""SetCacheSizeAux"", ""A TTreeCache could not be created because the TTree has no file"");; 8744 }; 8745 return 0;; 8746 }; 8747 ; 8748 // Check for an existing cache; 8749 TTreeCache* pf = GetReadCache(file);; 8750 if (pf) {; 8751 if (autocache) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:339793,Performance,cache,cacheSize,339793,"ibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCacheSize = cacheSize;; 8738 }; 8739 if (GetTree() != this) {; 8740 return 0;; 8741 }; 8742 if (!autocache && cacheSize>0) {; 8743 Warning(""SetCacheSizeAux"", ""A TTreeCache could not be created because the TTree has no file"");; 8744 }; 8745 return 0;; 8746 }; 8747 ; 8748 // Check for an existing cache; 8749 TTreeCache* pf = GetReadCache(file);; 8750 if (pf) {; 8751 if (autocache) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:339842,Performance,cache,cacheSize,339842,"ibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCacheSize = cacheSize;; 8738 }; 8739 if (GetTree() != this) {; 8740 return 0;; 8741 }; 8742 if (!autocache && cacheSize>0) {; 8743 Warning(""SetCacheSizeAux"", ""A TTreeCache could not be created because the TTree has no file"");; 8744 }; 8745 return 0;; 8746 }; 8747 ; 8748 // Check for an existing cache; 8749 TTreeCache* pf = GetReadCache(file);; 8750 if (pf) {; 8751 if (autocache) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:339865,Performance,cache,cacheSize,339865,"ibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCacheSize = cacheSize;; 8738 }; 8739 if (GetTree() != this) {; 8740 return 0;; 8741 }; 8742 if (!autocache && cacheSize>0) {; 8743 Warning(""SetCacheSizeAux"", ""A TTreeCache could not be created because the TTree has no file"");; 8744 }; 8745 return 0;; 8746 }; 8747 ; 8748 // Check for an existing cache; 8749 TTreeCache* pf = GetReadCache(file);; 8750 if (pf) {; 8751 if (autocache) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:340107,Performance,cache,cache,340107,"requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCacheSize = cacheSize;; 8738 }; 8739 if (GetTree() != this) {; 8740 return 0;; 8741 }; 8742 if (!autocache && cacheSize>0) {; 8743 Warning(""SetCacheSizeAux"", ""A TTreeCache could not be created because the TTree has no file"");; 8744 }; 8745 return 0;; 8746 }; 8747 ; 8748 // Check for an existing cache; 8749 TTreeCache* pf = GetReadCache(file);; 8750 if (pf) {; 8751 if (autocache) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without using one of the TTree methods; 8754 fCacheSize = pf->GetBufferSize();; 8755 fCacheUserSet = !pf->IsAutoCreated();; 8756 ; 8757 if (fCacheUserSet) {; 8758 // existing cache was created by the user, don't change it; 8759 return 0;; 8760 }; 8761 } else {; 8762 // update the cache to ensure it records the user has explicitly; 8763 // requested it; 8764 pf->SetAutoCreated(false);; 8765 }; 8766 ; 8767 // if we're using an automatically calculated size and the existing; 8768 // cache is already almost large enough don't resize; 8769 if (autocache && Long64_t(0.80*cacheSize) < fCacheSize) {; 8770 // already large enough; 8771 return 0;; 8772 }; 8773 ; 8774 if (cacheSize == fCacheSize) {; 8775 return 0;; 8776 }; 8777 ; 8778 if (cacheSize == 0) {; 8779 // delete existing cache; 8780 pf->WaitFinishPrefetch();; 8781 file->SetCacheRead(nullptr,this);; 8782 delete pf;; 8783 pf = nullptr;; 8784 } else {; 8785 // resize; 8786 Int_t res = pf->SetBufferSize(cacheSize);; 8787 if (",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:340195,Performance,cache,cacheSize,340195,"requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCacheSize = cacheSize;; 8738 }; 8739 if (GetTree() != this) {; 8740 return 0;; 8741 }; 8742 if (!autocache && cacheSize>0) {; 8743 Warning(""SetCacheSizeAux"", ""A TTreeCache could not be created because the TTree has no file"");; 8744 }; 8745 return 0;; 8746 }; 8747 ; 8748 // Check for an existing cache; 8749 TTreeCache* pf = GetReadCache(file);; 8750 if (pf) {; 8751 if (autocache) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without using one of the TTree methods; 8754 fCacheSize = pf->GetBufferSize();; 8755 fCacheUserSet = !pf->IsAutoCreated();; 8756 ; 8757 if (fCacheUserSet) {; 8758 // existing cache was created by the user, don't change it; 8759 return 0;; 8760 }; 8761 } else {; 8762 // update the cache to ensure it records the user has explicitly; 8763 // requested it; 8764 pf->SetAutoCreated(false);; 8765 }; 8766 ; 8767 // if we're using an automatically calculated size and the existing; 8768 // cache is already almost large enough don't resize; 8769 if (autocache && Long64_t(0.80*cacheSize) < fCacheSize) {; 8770 // already large enough; 8771 return 0;; 8772 }; 8773 ; 8774 if (cacheSize == fCacheSize) {; 8775 return 0;; 8776 }; 8777 ; 8778 if (cacheSize == 0) {; 8779 // delete existing cache; 8780 pf->WaitFinishPrefetch();; 8781 file->SetCacheRead(nullptr,this);; 8782 delete pf;; 8783 pf = nullptr;; 8784 } else {; 8785 // resize; 8786 Int_t res = pf->SetBufferSize(cacheSize);; 8787 if (",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:340293,Performance,cache,cacheSize,340293,"requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCacheSize = cacheSize;; 8738 }; 8739 if (GetTree() != this) {; 8740 return 0;; 8741 }; 8742 if (!autocache && cacheSize>0) {; 8743 Warning(""SetCacheSizeAux"", ""A TTreeCache could not be created because the TTree has no file"");; 8744 }; 8745 return 0;; 8746 }; 8747 ; 8748 // Check for an existing cache; 8749 TTreeCache* pf = GetReadCache(file);; 8750 if (pf) {; 8751 if (autocache) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without using one of the TTree methods; 8754 fCacheSize = pf->GetBufferSize();; 8755 fCacheUserSet = !pf->IsAutoCreated();; 8756 ; 8757 if (fCacheUserSet) {; 8758 // existing cache was created by the user, don't change it; 8759 return 0;; 8760 }; 8761 } else {; 8762 // update the cache to ensure it records the user has explicitly; 8763 // requested it; 8764 pf->SetAutoCreated(false);; 8765 }; 8766 ; 8767 // if we're using an automatically calculated size and the existing; 8768 // cache is already almost large enough don't resize; 8769 if (autocache && Long64_t(0.80*cacheSize) < fCacheSize) {; 8770 // already large enough; 8771 return 0;; 8772 }; 8773 ; 8774 if (cacheSize == fCacheSize) {; 8775 return 0;; 8776 }; 8777 ; 8778 if (cacheSize == 0) {; 8779 // delete existing cache; 8780 pf->WaitFinishPrefetch();; 8781 file->SetCacheRead(nullptr,this);; 8782 delete pf;; 8783 pf = nullptr;; 8784 } else {; 8785 // resize; 8786 Int_t res = pf->SetBufferSize(cacheSize);; 8787 if (",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:340479,Performance,cache,cache,340479,"requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCacheSize = cacheSize;; 8738 }; 8739 if (GetTree() != this) {; 8740 return 0;; 8741 }; 8742 if (!autocache && cacheSize>0) {; 8743 Warning(""SetCacheSizeAux"", ""A TTreeCache could not be created because the TTree has no file"");; 8744 }; 8745 return 0;; 8746 }; 8747 ; 8748 // Check for an existing cache; 8749 TTreeCache* pf = GetReadCache(file);; 8750 if (pf) {; 8751 if (autocache) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without using one of the TTree methods; 8754 fCacheSize = pf->GetBufferSize();; 8755 fCacheUserSet = !pf->IsAutoCreated();; 8756 ; 8757 if (fCacheUserSet) {; 8758 // existing cache was created by the user, don't change it; 8759 return 0;; 8760 }; 8761 } else {; 8762 // update the cache to ensure it records the user has explicitly; 8763 // requested it; 8764 pf->SetAutoCreated(false);; 8765 }; 8766 ; 8767 // if we're using an automatically calculated size and the existing; 8768 // cache is already almost large enough don't resize; 8769 if (autocache && Long64_t(0.80*cacheSize) < fCacheSize) {; 8770 // already large enough; 8771 return 0;; 8772 }; 8773 ; 8774 if (cacheSize == fCacheSize) {; 8775 return 0;; 8776 }; 8777 ; 8778 if (cacheSize == 0) {; 8779 // delete existing cache; 8780 pf->WaitFinishPrefetch();; 8781 file->SetCacheRead(nullptr,this);; 8782 delete pf;; 8783 pf = nullptr;; 8784 } else {; 8785 // resize; 8786 Int_t res = pf->SetBufferSize(cacheSize);; 8787 if (",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:340586,Performance,cache,cache,340586,"requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCacheSize = cacheSize;; 8738 }; 8739 if (GetTree() != this) {; 8740 return 0;; 8741 }; 8742 if (!autocache && cacheSize>0) {; 8743 Warning(""SetCacheSizeAux"", ""A TTreeCache could not be created because the TTree has no file"");; 8744 }; 8745 return 0;; 8746 }; 8747 ; 8748 // Check for an existing cache; 8749 TTreeCache* pf = GetReadCache(file);; 8750 if (pf) {; 8751 if (autocache) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without using one of the TTree methods; 8754 fCacheSize = pf->GetBufferSize();; 8755 fCacheUserSet = !pf->IsAutoCreated();; 8756 ; 8757 if (fCacheUserSet) {; 8758 // existing cache was created by the user, don't change it; 8759 return 0;; 8760 }; 8761 } else {; 8762 // update the cache to ensure it records the user has explicitly; 8763 // requested it; 8764 pf->SetAutoCreated(false);; 8765 }; 8766 ; 8767 // if we're using an automatically calculated size and the existing; 8768 // cache is already almost large enough don't resize; 8769 if (autocache && Long64_t(0.80*cacheSize) < fCacheSize) {; 8770 // already large enough; 8771 return 0;; 8772 }; 8773 ; 8774 if (cacheSize == fCacheSize) {; 8775 return 0;; 8776 }; 8777 ; 8778 if (cacheSize == 0) {; 8779 // delete existing cache; 8780 pf->WaitFinishPrefetch();; 8781 file->SetCacheRead(nullptr,this);; 8782 delete pf;; 8783 pf = nullptr;; 8784 } else {; 8785 // resize; 8786 Int_t res = pf->SetBufferSize(cacheSize);; 8787 if (",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:340625,Performance,cache,cache,340625,"requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCacheSize = cacheSize;; 8738 }; 8739 if (GetTree() != this) {; 8740 return 0;; 8741 }; 8742 if (!autocache && cacheSize>0) {; 8743 Warning(""SetCacheSizeAux"", ""A TTreeCache could not be created because the TTree has no file"");; 8744 }; 8745 return 0;; 8746 }; 8747 ; 8748 // Check for an existing cache; 8749 TTreeCache* pf = GetReadCache(file);; 8750 if (pf) {; 8751 if (autocache) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without using one of the TTree methods; 8754 fCacheSize = pf->GetBufferSize();; 8755 fCacheUserSet = !pf->IsAutoCreated();; 8756 ; 8757 if (fCacheUserSet) {; 8758 // existing cache was created by the user, don't change it; 8759 return 0;; 8760 }; 8761 } else {; 8762 // update the cache to ensure it records the user has explicitly; 8763 // requested it; 8764 pf->SetAutoCreated(false);; 8765 }; 8766 ; 8767 // if we're using an automatically calculated size and the existing; 8768 // cache is already almost large enough don't resize; 8769 if (autocache && Long64_t(0.80*cacheSize) < fCacheSize) {; 8770 // already large enough; 8771 return 0;; 8772 }; 8773 ; 8774 if (cacheSize == fCacheSize) {; 8775 return 0;; 8776 }; 8777 ; 8778 if (cacheSize == 0) {; 8779 // delete existing cache; 8780 pf->WaitFinishPrefetch();; 8781 file->SetCacheRead(nullptr,this);; 8782 delete pf;; 8783 pf = nullptr;; 8784 } else {; 8785 // resize; 8786 Int_t res = pf->SetBufferSize(cacheSize);; 8787 if (",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:340837,Performance,cache,cache,340837,"requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCacheSize = cacheSize;; 8738 }; 8739 if (GetTree() != this) {; 8740 return 0;; 8741 }; 8742 if (!autocache && cacheSize>0) {; 8743 Warning(""SetCacheSizeAux"", ""A TTreeCache could not be created because the TTree has no file"");; 8744 }; 8745 return 0;; 8746 }; 8747 ; 8748 // Check for an existing cache; 8749 TTreeCache* pf = GetReadCache(file);; 8750 if (pf) {; 8751 if (autocache) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without using one of the TTree methods; 8754 fCacheSize = pf->GetBufferSize();; 8755 fCacheUserSet = !pf->IsAutoCreated();; 8756 ; 8757 if (fCacheUserSet) {; 8758 // existing cache was created by the user, don't change it; 8759 return 0;; 8760 }; 8761 } else {; 8762 // update the cache to ensure it records the user has explicitly; 8763 // requested it; 8764 pf->SetAutoCreated(false);; 8765 }; 8766 ; 8767 // if we're using an automatically calculated size and the existing; 8768 // cache is already almost large enough don't resize; 8769 if (autocache && Long64_t(0.80*cacheSize) < fCacheSize) {; 8770 // already large enough; 8771 return 0;; 8772 }; 8773 ; 8774 if (cacheSize == fCacheSize) {; 8775 return 0;; 8776 }; 8777 ; 8778 if (cacheSize == 0) {; 8779 // delete existing cache; 8780 pf->WaitFinishPrefetch();; 8781 file->SetCacheRead(nullptr,this);; 8782 delete pf;; 8783 pf = nullptr;; 8784 } else {; 8785 // resize; 8786 Int_t res = pf->SetBufferSize(cacheSize);; 8787 if (",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:340943,Performance,cache,cache,340943,"requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCacheSize = cacheSize;; 8738 }; 8739 if (GetTree() != this) {; 8740 return 0;; 8741 }; 8742 if (!autocache && cacheSize>0) {; 8743 Warning(""SetCacheSizeAux"", ""A TTreeCache could not be created because the TTree has no file"");; 8744 }; 8745 return 0;; 8746 }; 8747 ; 8748 // Check for an existing cache; 8749 TTreeCache* pf = GetReadCache(file);; 8750 if (pf) {; 8751 if (autocache) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without using one of the TTree methods; 8754 fCacheSize = pf->GetBufferSize();; 8755 fCacheUserSet = !pf->IsAutoCreated();; 8756 ; 8757 if (fCacheUserSet) {; 8758 // existing cache was created by the user, don't change it; 8759 return 0;; 8760 }; 8761 } else {; 8762 // update the cache to ensure it records the user has explicitly; 8763 // requested it; 8764 pf->SetAutoCreated(false);; 8765 }; 8766 ; 8767 // if we're using an automatically calculated size and the existing; 8768 // cache is already almost large enough don't resize; 8769 if (autocache && Long64_t(0.80*cacheSize) < fCacheSize) {; 8770 // already large enough; 8771 return 0;; 8772 }; 8773 ; 8774 if (cacheSize == fCacheSize) {; 8775 return 0;; 8776 }; 8777 ; 8778 if (cacheSize == 0) {; 8779 // delete existing cache; 8780 pf->WaitFinishPrefetch();; 8781 file->SetCacheRead(nullptr,this);; 8782 delete pf;; 8783 pf = nullptr;; 8784 } else {; 8785 // resize; 8786 Int_t res = pf->SetBufferSize(cacheSize);; 8787 if (",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:341147,Performance,cache,cache,341147,"requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCacheSize = cacheSize;; 8738 }; 8739 if (GetTree() != this) {; 8740 return 0;; 8741 }; 8742 if (!autocache && cacheSize>0) {; 8743 Warning(""SetCacheSizeAux"", ""A TTreeCache could not be created because the TTree has no file"");; 8744 }; 8745 return 0;; 8746 }; 8747 ; 8748 // Check for an existing cache; 8749 TTreeCache* pf = GetReadCache(file);; 8750 if (pf) {; 8751 if (autocache) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without using one of the TTree methods; 8754 fCacheSize = pf->GetBufferSize();; 8755 fCacheUserSet = !pf->IsAutoCreated();; 8756 ; 8757 if (fCacheUserSet) {; 8758 // existing cache was created by the user, don't change it; 8759 return 0;; 8760 }; 8761 } else {; 8762 // update the cache to ensure it records the user has explicitly; 8763 // requested it; 8764 pf->SetAutoCreated(false);; 8765 }; 8766 ; 8767 // if we're using an automatically calculated size and the existing; 8768 // cache is already almost large enough don't resize; 8769 if (autocache && Long64_t(0.80*cacheSize) < fCacheSize) {; 8770 // already large enough; 8771 return 0;; 8772 }; 8773 ; 8774 if (cacheSize == fCacheSize) {; 8775 return 0;; 8776 }; 8777 ; 8778 if (cacheSize == 0) {; 8779 // delete existing cache; 8780 pf->WaitFinishPrefetch();; 8781 file->SetCacheRead(nullptr,this);; 8782 delete pf;; 8783 pf = nullptr;; 8784 } else {; 8785 // resize; 8786 Int_t res = pf->SetBufferSize(cacheSize);; 8787 if (",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:341234,Performance,cache,cacheSize,341234,"e) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without using one of the TTree methods; 8754 fCacheSize = pf->GetBufferSize();; 8755 fCacheUserSet = !pf->IsAutoCreated();; 8756 ; 8757 if (fCacheUserSet) {; 8758 // existing cache was created by the user, don't change it; 8759 return 0;; 8760 }; 8761 } else {; 8762 // update the cache to ensure it records the user has explicitly; 8763 // requested it; 8764 pf->SetAutoCreated(false);; 8765 }; 8766 ; 8767 // if we're using an automatically calculated size and the existing; 8768 // cache is already almost large enough don't resize; 8769 if (autocache && Long64_t(0.80*cacheSize) < fCacheSize) {; 8770 // already large enough; 8771 return 0;; 8772 }; 8773 ; 8774 if (cacheSize == fCacheSize) {; 8775 return 0;; 8776 }; 8777 ; 8778 if (cacheSize == 0) {; 8779 // delete existing cache; 8780 pf->WaitFinishPrefetch();; 8781 file->SetCacheRead(nullptr,this);; 8782 delete pf;; 8783 pf = nullptr;; 8784 } else {; 8785 // resize; 8786 Int_t res = pf->SetBufferSize(cacheSize);; 8787 if (res < 0) {; 8788 return -1;; 8789 }; 8790 cacheSize = pf->GetBufferSize(); // update after potential clamp; 8791 }; 8792 } else {; 8793 // no existing cache; 8794 if (autocache) {; 8795 if (fCacheUserSet) {; 8796 // value was already set manually.; 8797 if (fCacheSize == 0) return 0;; 8798 // Expected a cache should exist; perhaps the user moved it; 8799 // Do nothing more here.; 8800 if (cacheSize) {; 8801 Error(""SetCacheSizeAux"", ""Not setting up an automatically sized TTreeCache because of missing cache previously set"");; 8802 }; 8803 return -1;; 8804 }; 8805 }; 8806 }; 8807 ; 8808 fCacheSize = cacheSize;; 8809 if (cacheSize == 0 || pf) {; 8810 return 0;; 8811 }; 8812 ; 8813#ifdef R__USE_IMT; 8814 if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:341332,Performance,cache,cacheSize,341332,"e) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without using one of the TTree methods; 8754 fCacheSize = pf->GetBufferSize();; 8755 fCacheUserSet = !pf->IsAutoCreated();; 8756 ; 8757 if (fCacheUserSet) {; 8758 // existing cache was created by the user, don't change it; 8759 return 0;; 8760 }; 8761 } else {; 8762 // update the cache to ensure it records the user has explicitly; 8763 // requested it; 8764 pf->SetAutoCreated(false);; 8765 }; 8766 ; 8767 // if we're using an automatically calculated size and the existing; 8768 // cache is already almost large enough don't resize; 8769 if (autocache && Long64_t(0.80*cacheSize) < fCacheSize) {; 8770 // already large enough; 8771 return 0;; 8772 }; 8773 ; 8774 if (cacheSize == fCacheSize) {; 8775 return 0;; 8776 }; 8777 ; 8778 if (cacheSize == 0) {; 8779 // delete existing cache; 8780 pf->WaitFinishPrefetch();; 8781 file->SetCacheRead(nullptr,this);; 8782 delete pf;; 8783 pf = nullptr;; 8784 } else {; 8785 // resize; 8786 Int_t res = pf->SetBufferSize(cacheSize);; 8787 if (res < 0) {; 8788 return -1;; 8789 }; 8790 cacheSize = pf->GetBufferSize(); // update after potential clamp; 8791 }; 8792 } else {; 8793 // no existing cache; 8794 if (autocache) {; 8795 if (fCacheUserSet) {; 8796 // value was already set manually.; 8797 if (fCacheSize == 0) return 0;; 8798 // Expected a cache should exist; perhaps the user moved it; 8799 // Do nothing more here.; 8800 if (cacheSize) {; 8801 Error(""SetCacheSizeAux"", ""Not setting up an automatically sized TTreeCache because of missing cache previously set"");; 8802 }; 8803 return -1;; 8804 }; 8805 }; 8806 }; 8807 ; 8808 fCacheSize = cacheSize;; 8809 if (cacheSize == 0 || pf) {; 8810 return 0;; 8811 }; 8812 ; 8813#ifdef R__USE_IMT; 8814 if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:341400,Performance,cache,cacheSize,341400,"e) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without using one of the TTree methods; 8754 fCacheSize = pf->GetBufferSize();; 8755 fCacheUserSet = !pf->IsAutoCreated();; 8756 ; 8757 if (fCacheUserSet) {; 8758 // existing cache was created by the user, don't change it; 8759 return 0;; 8760 }; 8761 } else {; 8762 // update the cache to ensure it records the user has explicitly; 8763 // requested it; 8764 pf->SetAutoCreated(false);; 8765 }; 8766 ; 8767 // if we're using an automatically calculated size and the existing; 8768 // cache is already almost large enough don't resize; 8769 if (autocache && Long64_t(0.80*cacheSize) < fCacheSize) {; 8770 // already large enough; 8771 return 0;; 8772 }; 8773 ; 8774 if (cacheSize == fCacheSize) {; 8775 return 0;; 8776 }; 8777 ; 8778 if (cacheSize == 0) {; 8779 // delete existing cache; 8780 pf->WaitFinishPrefetch();; 8781 file->SetCacheRead(nullptr,this);; 8782 delete pf;; 8783 pf = nullptr;; 8784 } else {; 8785 // resize; 8786 Int_t res = pf->SetBufferSize(cacheSize);; 8787 if (res < 0) {; 8788 return -1;; 8789 }; 8790 cacheSize = pf->GetBufferSize(); // update after potential clamp; 8791 }; 8792 } else {; 8793 // no existing cache; 8794 if (autocache) {; 8795 if (fCacheUserSet) {; 8796 // value was already set manually.; 8797 if (fCacheSize == 0) return 0;; 8798 // Expected a cache should exist; perhaps the user moved it; 8799 // Do nothing more here.; 8800 if (cacheSize) {; 8801 Error(""SetCacheSizeAux"", ""Not setting up an automatically sized TTreeCache because of missing cache previously set"");; 8802 }; 8803 return -1;; 8804 }; 8805 }; 8806 }; 8807 ; 8808 fCacheSize = cacheSize;; 8809 if (cacheSize == 0 || pf) {; 8810 return 0;; 8811 }; 8812 ; 8813#ifdef R__USE_IMT; 8814 if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:341443,Performance,cache,cache,341443,"e) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without using one of the TTree methods; 8754 fCacheSize = pf->GetBufferSize();; 8755 fCacheUserSet = !pf->IsAutoCreated();; 8756 ; 8757 if (fCacheUserSet) {; 8758 // existing cache was created by the user, don't change it; 8759 return 0;; 8760 }; 8761 } else {; 8762 // update the cache to ensure it records the user has explicitly; 8763 // requested it; 8764 pf->SetAutoCreated(false);; 8765 }; 8766 ; 8767 // if we're using an automatically calculated size and the existing; 8768 // cache is already almost large enough don't resize; 8769 if (autocache && Long64_t(0.80*cacheSize) < fCacheSize) {; 8770 // already large enough; 8771 return 0;; 8772 }; 8773 ; 8774 if (cacheSize == fCacheSize) {; 8775 return 0;; 8776 }; 8777 ; 8778 if (cacheSize == 0) {; 8779 // delete existing cache; 8780 pf->WaitFinishPrefetch();; 8781 file->SetCacheRead(nullptr,this);; 8782 delete pf;; 8783 pf = nullptr;; 8784 } else {; 8785 // resize; 8786 Int_t res = pf->SetBufferSize(cacheSize);; 8787 if (res < 0) {; 8788 return -1;; 8789 }; 8790 cacheSize = pf->GetBufferSize(); // update after potential clamp; 8791 }; 8792 } else {; 8793 // no existing cache; 8794 if (autocache) {; 8795 if (fCacheUserSet) {; 8796 // value was already set manually.; 8797 if (fCacheSize == 0) return 0;; 8798 // Expected a cache should exist; perhaps the user moved it; 8799 // Do nothing more here.; 8800 if (cacheSize) {; 8801 Error(""SetCacheSizeAux"", ""Not setting up an automatically sized TTreeCache because of missing cache previously set"");; 8802 }; 8803 return -1;; 8804 }; 8805 }; 8806 }; 8807 ; 8808 fCacheSize = cacheSize;; 8809 if (cacheSize == 0 || pf) {; 8810 return 0;; 8811 }; 8812 ; 8813#ifdef R__USE_IMT; 8814 if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:341625,Performance,cache,cacheSize,341625,"e) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without using one of the TTree methods; 8754 fCacheSize = pf->GetBufferSize();; 8755 fCacheUserSet = !pf->IsAutoCreated();; 8756 ; 8757 if (fCacheUserSet) {; 8758 // existing cache was created by the user, don't change it; 8759 return 0;; 8760 }; 8761 } else {; 8762 // update the cache to ensure it records the user has explicitly; 8763 // requested it; 8764 pf->SetAutoCreated(false);; 8765 }; 8766 ; 8767 // if we're using an automatically calculated size and the existing; 8768 // cache is already almost large enough don't resize; 8769 if (autocache && Long64_t(0.80*cacheSize) < fCacheSize) {; 8770 // already large enough; 8771 return 0;; 8772 }; 8773 ; 8774 if (cacheSize == fCacheSize) {; 8775 return 0;; 8776 }; 8777 ; 8778 if (cacheSize == 0) {; 8779 // delete existing cache; 8780 pf->WaitFinishPrefetch();; 8781 file->SetCacheRead(nullptr,this);; 8782 delete pf;; 8783 pf = nullptr;; 8784 } else {; 8785 // resize; 8786 Int_t res = pf->SetBufferSize(cacheSize);; 8787 if (res < 0) {; 8788 return -1;; 8789 }; 8790 cacheSize = pf->GetBufferSize(); // update after potential clamp; 8791 }; 8792 } else {; 8793 // no existing cache; 8794 if (autocache) {; 8795 if (fCacheUserSet) {; 8796 // value was already set manually.; 8797 if (fCacheSize == 0) return 0;; 8798 // Expected a cache should exist; perhaps the user moved it; 8799 // Do nothing more here.; 8800 if (cacheSize) {; 8801 Error(""SetCacheSizeAux"", ""Not setting up an automatically sized TTreeCache because of missing cache previously set"");; 8802 }; 8803 return -1;; 8804 }; 8805 }; 8806 }; 8807 ; 8808 fCacheSize = cacheSize;; 8809 if (cacheSize == 0 || pf) {; 8810 return 0;; 8811 }; 8812 ; 8813#ifdef R__USE_IMT; 8814 if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:341689,Performance,cache,cacheSize,341689,"e) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without using one of the TTree methods; 8754 fCacheSize = pf->GetBufferSize();; 8755 fCacheUserSet = !pf->IsAutoCreated();; 8756 ; 8757 if (fCacheUserSet) {; 8758 // existing cache was created by the user, don't change it; 8759 return 0;; 8760 }; 8761 } else {; 8762 // update the cache to ensure it records the user has explicitly; 8763 // requested it; 8764 pf->SetAutoCreated(false);; 8765 }; 8766 ; 8767 // if we're using an automatically calculated size and the existing; 8768 // cache is already almost large enough don't resize; 8769 if (autocache && Long64_t(0.80*cacheSize) < fCacheSize) {; 8770 // already large enough; 8771 return 0;; 8772 }; 8773 ; 8774 if (cacheSize == fCacheSize) {; 8775 return 0;; 8776 }; 8777 ; 8778 if (cacheSize == 0) {; 8779 // delete existing cache; 8780 pf->WaitFinishPrefetch();; 8781 file->SetCacheRead(nullptr,this);; 8782 delete pf;; 8783 pf = nullptr;; 8784 } else {; 8785 // resize; 8786 Int_t res = pf->SetBufferSize(cacheSize);; 8787 if (res < 0) {; 8788 return -1;; 8789 }; 8790 cacheSize = pf->GetBufferSize(); // update after potential clamp; 8791 }; 8792 } else {; 8793 // no existing cache; 8794 if (autocache) {; 8795 if (fCacheUserSet) {; 8796 // value was already set manually.; 8797 if (fCacheSize == 0) return 0;; 8798 // Expected a cache should exist; perhaps the user moved it; 8799 // Do nothing more here.; 8800 if (cacheSize) {; 8801 Error(""SetCacheSizeAux"", ""Not setting up an automatically sized TTreeCache because of missing cache previously set"");; 8802 }; 8803 return -1;; 8804 }; 8805 }; 8806 }; 8807 ; 8808 fCacheSize = cacheSize;; 8809 if (cacheSize == 0 || pf) {; 8810 return 0;; 8811 }; 8812 ; 8813#ifdef R__USE_IMT; 8814 if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:341798,Performance,cache,cache,341798,"e) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without using one of the TTree methods; 8754 fCacheSize = pf->GetBufferSize();; 8755 fCacheUserSet = !pf->IsAutoCreated();; 8756 ; 8757 if (fCacheUserSet) {; 8758 // existing cache was created by the user, don't change it; 8759 return 0;; 8760 }; 8761 } else {; 8762 // update the cache to ensure it records the user has explicitly; 8763 // requested it; 8764 pf->SetAutoCreated(false);; 8765 }; 8766 ; 8767 // if we're using an automatically calculated size and the existing; 8768 // cache is already almost large enough don't resize; 8769 if (autocache && Long64_t(0.80*cacheSize) < fCacheSize) {; 8770 // already large enough; 8771 return 0;; 8772 }; 8773 ; 8774 if (cacheSize == fCacheSize) {; 8775 return 0;; 8776 }; 8777 ; 8778 if (cacheSize == 0) {; 8779 // delete existing cache; 8780 pf->WaitFinishPrefetch();; 8781 file->SetCacheRead(nullptr,this);; 8782 delete pf;; 8783 pf = nullptr;; 8784 } else {; 8785 // resize; 8786 Int_t res = pf->SetBufferSize(cacheSize);; 8787 if (res < 0) {; 8788 return -1;; 8789 }; 8790 cacheSize = pf->GetBufferSize(); // update after potential clamp; 8791 }; 8792 } else {; 8793 // no existing cache; 8794 if (autocache) {; 8795 if (fCacheUserSet) {; 8796 // value was already set manually.; 8797 if (fCacheSize == 0) return 0;; 8798 // Expected a cache should exist; perhaps the user moved it; 8799 // Do nothing more here.; 8800 if (cacheSize) {; 8801 Error(""SetCacheSizeAux"", ""Not setting up an automatically sized TTreeCache because of missing cache previously set"");; 8802 }; 8803 return -1;; 8804 }; 8805 }; 8806 }; 8807 ; 8808 fCacheSize = cacheSize;; 8809 if (cacheSize == 0 || pf) {; 8810 return 0;; 8811 }; 8812 ; 8813#ifdef R__USE_IMT; 8814 if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:341952,Performance,cache,cache,341952," records the user has explicitly; 8763 // requested it; 8764 pf->SetAutoCreated(false);; 8765 }; 8766 ; 8767 // if we're using an automatically calculated size and the existing; 8768 // cache is already almost large enough don't resize; 8769 if (autocache && Long64_t(0.80*cacheSize) < fCacheSize) {; 8770 // already large enough; 8771 return 0;; 8772 }; 8773 ; 8774 if (cacheSize == fCacheSize) {; 8775 return 0;; 8776 }; 8777 ; 8778 if (cacheSize == 0) {; 8779 // delete existing cache; 8780 pf->WaitFinishPrefetch();; 8781 file->SetCacheRead(nullptr,this);; 8782 delete pf;; 8783 pf = nullptr;; 8784 } else {; 8785 // resize; 8786 Int_t res = pf->SetBufferSize(cacheSize);; 8787 if (res < 0) {; 8788 return -1;; 8789 }; 8790 cacheSize = pf->GetBufferSize(); // update after potential clamp; 8791 }; 8792 } else {; 8793 // no existing cache; 8794 if (autocache) {; 8795 if (fCacheUserSet) {; 8796 // value was already set manually.; 8797 if (fCacheSize == 0) return 0;; 8798 // Expected a cache should exist; perhaps the user moved it; 8799 // Do nothing more here.; 8800 if (cacheSize) {; 8801 Error(""SetCacheSizeAux"", ""Not setting up an automatically sized TTreeCache because of missing cache previously set"");; 8802 }; 8803 return -1;; 8804 }; 8805 }; 8806 }; 8807 ; 8808 fCacheSize = cacheSize;; 8809 if (cacheSize == 0 || pf) {; 8810 return 0;; 8811 }; 8812 ; 8813#ifdef R__USE_IMT; 8814 if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->SetAutoCreated(autocache);; 8821 ; 8822 return 0;; 8823}; 8824 ; 8825////////////////////////////////////////////////////////////////////////////////; 8826///interface to TTreeCache to set the cache entry range; 8827///; 8828/// Returns:; 8829/// - 0 entry range set; 8830/// - -1 on error; 8831 ; 8832Int_t TTree::SetCacheEntryRange(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:342039,Performance,cache,cacheSize,342039,"es < 0) {; 8788 return -1;; 8789 }; 8790 cacheSize = pf->GetBufferSize(); // update after potential clamp; 8791 }; 8792 } else {; 8793 // no existing cache; 8794 if (autocache) {; 8795 if (fCacheUserSet) {; 8796 // value was already set manually.; 8797 if (fCacheSize == 0) return 0;; 8798 // Expected a cache should exist; perhaps the user moved it; 8799 // Do nothing more here.; 8800 if (cacheSize) {; 8801 Error(""SetCacheSizeAux"", ""Not setting up an automatically sized TTreeCache because of missing cache previously set"");; 8802 }; 8803 return -1;; 8804 }; 8805 }; 8806 }; 8807 ; 8808 fCacheSize = cacheSize;; 8809 if (cacheSize == 0 || pf) {; 8810 return 0;; 8811 }; 8812 ; 8813#ifdef R__USE_IMT; 8814 if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->SetAutoCreated(autocache);; 8821 ; 8822 return 0;; 8823}; 8824 ; 8825////////////////////////////////////////////////////////////////////////////////; 8826///interface to TTreeCache to set the cache entry range; 8827///; 8828/// Returns:; 8829/// - 0 entry range set; 8830/// - -1 on error; 8831 ; 8832Int_t TTree::SetCacheEntryRange(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry rang",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:342152,Performance,cache,cache,342152,"es < 0) {; 8788 return -1;; 8789 }; 8790 cacheSize = pf->GetBufferSize(); // update after potential clamp; 8791 }; 8792 } else {; 8793 // no existing cache; 8794 if (autocache) {; 8795 if (fCacheUserSet) {; 8796 // value was already set manually.; 8797 if (fCacheSize == 0) return 0;; 8798 // Expected a cache should exist; perhaps the user moved it; 8799 // Do nothing more here.; 8800 if (cacheSize) {; 8801 Error(""SetCacheSizeAux"", ""Not setting up an automatically sized TTreeCache because of missing cache previously set"");; 8802 }; 8803 return -1;; 8804 }; 8805 }; 8806 }; 8807 ; 8808 fCacheSize = cacheSize;; 8809 if (cacheSize == 0 || pf) {; 8810 return 0;; 8811 }; 8812 ; 8813#ifdef R__USE_IMT; 8814 if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->SetAutoCreated(autocache);; 8821 ; 8822 return 0;; 8823}; 8824 ; 8825////////////////////////////////////////////////////////////////////////////////; 8826///interface to TTreeCache to set the cache entry range; 8827///; 8828/// Returns:; 8829/// - 0 entry range set; 8830/// - -1 on error; 8831 ; 8832Int_t TTree::SetCacheEntryRange(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry rang",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:342251,Performance,cache,cacheSize,342251,"es < 0) {; 8788 return -1;; 8789 }; 8790 cacheSize = pf->GetBufferSize(); // update after potential clamp; 8791 }; 8792 } else {; 8793 // no existing cache; 8794 if (autocache) {; 8795 if (fCacheUserSet) {; 8796 // value was already set manually.; 8797 if (fCacheSize == 0) return 0;; 8798 // Expected a cache should exist; perhaps the user moved it; 8799 // Do nothing more here.; 8800 if (cacheSize) {; 8801 Error(""SetCacheSizeAux"", ""Not setting up an automatically sized TTreeCache because of missing cache previously set"");; 8802 }; 8803 return -1;; 8804 }; 8805 }; 8806 }; 8807 ; 8808 fCacheSize = cacheSize;; 8809 if (cacheSize == 0 || pf) {; 8810 return 0;; 8811 }; 8812 ; 8813#ifdef R__USE_IMT; 8814 if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->SetAutoCreated(autocache);; 8821 ; 8822 return 0;; 8823}; 8824 ; 8825////////////////////////////////////////////////////////////////////////////////; 8826///interface to TTreeCache to set the cache entry range; 8827///; 8828/// Returns:; 8829/// - 0 entry range set; 8830/// - -1 on error; 8831 ; 8832Int_t TTree::SetCacheEntryRange(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry rang",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:342272,Performance,cache,cacheSize,342272,"es < 0) {; 8788 return -1;; 8789 }; 8790 cacheSize = pf->GetBufferSize(); // update after potential clamp; 8791 }; 8792 } else {; 8793 // no existing cache; 8794 if (autocache) {; 8795 if (fCacheUserSet) {; 8796 // value was already set manually.; 8797 if (fCacheSize == 0) return 0;; 8798 // Expected a cache should exist; perhaps the user moved it; 8799 // Do nothing more here.; 8800 if (cacheSize) {; 8801 Error(""SetCacheSizeAux"", ""Not setting up an automatically sized TTreeCache because of missing cache previously set"");; 8802 }; 8803 return -1;; 8804 }; 8805 }; 8806 }; 8807 ; 8808 fCacheSize = cacheSize;; 8809 if (cacheSize == 0 || pf) {; 8810 return 0;; 8811 }; 8812 ; 8813#ifdef R__USE_IMT; 8814 if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->SetAutoCreated(autocache);; 8821 ; 8822 return 0;; 8823}; 8824 ; 8825////////////////////////////////////////////////////////////////////////////////; 8826///interface to TTreeCache to set the cache entry range; 8827///; 8828/// Returns:; 8829/// - 0 entry range set; 8830/// - -1 on error; 8831 ; 8832Int_t TTree::SetCacheEntryRange(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry rang",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:342467,Performance,cache,cacheSize,342467,"es < 0) {; 8788 return -1;; 8789 }; 8790 cacheSize = pf->GetBufferSize(); // update after potential clamp; 8791 }; 8792 } else {; 8793 // no existing cache; 8794 if (autocache) {; 8795 if (fCacheUserSet) {; 8796 // value was already set manually.; 8797 if (fCacheSize == 0) return 0;; 8798 // Expected a cache should exist; perhaps the user moved it; 8799 // Do nothing more here.; 8800 if (cacheSize) {; 8801 Error(""SetCacheSizeAux"", ""Not setting up an automatically sized TTreeCache because of missing cache previously set"");; 8802 }; 8803 return -1;; 8804 }; 8805 }; 8806 }; 8807 ; 8808 fCacheSize = cacheSize;; 8809 if (cacheSize == 0 || pf) {; 8810 return 0;; 8811 }; 8812 ; 8813#ifdef R__USE_IMT; 8814 if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->SetAutoCreated(autocache);; 8821 ; 8822 return 0;; 8823}; 8824 ; 8825////////////////////////////////////////////////////////////////////////////////; 8826///interface to TTreeCache to set the cache entry range; 8827///; 8828/// Returns:; 8829/// - 0 entry range set; 8830/// - -1 on error; 8831 ; 8832Int_t TTree::SetCacheEntryRange(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry rang",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:342534,Performance,cache,cacheSize,342534,"es < 0) {; 8788 return -1;; 8789 }; 8790 cacheSize = pf->GetBufferSize(); // update after potential clamp; 8791 }; 8792 } else {; 8793 // no existing cache; 8794 if (autocache) {; 8795 if (fCacheUserSet) {; 8796 // value was already set manually.; 8797 if (fCacheSize == 0) return 0;; 8798 // Expected a cache should exist; perhaps the user moved it; 8799 // Do nothing more here.; 8800 if (cacheSize) {; 8801 Error(""SetCacheSizeAux"", ""Not setting up an automatically sized TTreeCache because of missing cache previously set"");; 8802 }; 8803 return -1;; 8804 }; 8805 }; 8806 }; 8807 ; 8808 fCacheSize = cacheSize;; 8809 if (cacheSize == 0 || pf) {; 8810 return 0;; 8811 }; 8812 ; 8813#ifdef R__USE_IMT; 8814 if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->SetAutoCreated(autocache);; 8821 ; 8822 return 0;; 8823}; 8824 ; 8825////////////////////////////////////////////////////////////////////////////////; 8826///interface to TTreeCache to set the cache entry range; 8827///; 8828/// Returns:; 8829/// - 0 entry range set; 8830/// - -1 on error; 8831 ; 8832Int_t TTree::SetCacheEntryRange(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry rang",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:342756,Performance,cache,cache,342756,"es < 0) {; 8788 return -1;; 8789 }; 8790 cacheSize = pf->GetBufferSize(); // update after potential clamp; 8791 }; 8792 } else {; 8793 // no existing cache; 8794 if (autocache) {; 8795 if (fCacheUserSet) {; 8796 // value was already set manually.; 8797 if (fCacheSize == 0) return 0;; 8798 // Expected a cache should exist; perhaps the user moved it; 8799 // Do nothing more here.; 8800 if (cacheSize) {; 8801 Error(""SetCacheSizeAux"", ""Not setting up an automatically sized TTreeCache because of missing cache previously set"");; 8802 }; 8803 return -1;; 8804 }; 8805 }; 8806 }; 8807 ; 8808 fCacheSize = cacheSize;; 8809 if (cacheSize == 0 || pf) {; 8810 return 0;; 8811 }; 8812 ; 8813#ifdef R__USE_IMT; 8814 if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->SetAutoCreated(autocache);; 8821 ; 8822 return 0;; 8823}; 8824 ; 8825////////////////////////////////////////////////////////////////////////////////; 8826///interface to TTreeCache to set the cache entry range; 8827///; 8828/// Returns:; 8829/// - 0 entry range set; 8830/// - -1 on error; 8831 ; 8832Int_t TTree::SetCacheEntryRange(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry rang",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:343030,Performance,load,load,343030,"es < 0) {; 8788 return -1;; 8789 }; 8790 cacheSize = pf->GetBufferSize(); // update after potential clamp; 8791 }; 8792 } else {; 8793 // no existing cache; 8794 if (autocache) {; 8795 if (fCacheUserSet) {; 8796 // value was already set manually.; 8797 if (fCacheSize == 0) return 0;; 8798 // Expected a cache should exist; perhaps the user moved it; 8799 // Do nothing more here.; 8800 if (cacheSize) {; 8801 Error(""SetCacheSizeAux"", ""Not setting up an automatically sized TTreeCache because of missing cache previously set"");; 8802 }; 8803 return -1;; 8804 }; 8805 }; 8806 }; 8807 ; 8808 fCacheSize = cacheSize;; 8809 if (cacheSize == 0 || pf) {; 8810 return 0;; 8811 }; 8812 ; 8813#ifdef R__USE_IMT; 8814 if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->SetAutoCreated(autocache);; 8821 ; 8822 return 0;; 8823}; 8824 ; 8825////////////////////////////////////////////////////////////////////////////////; 8826///interface to TTreeCache to set the cache entry range; 8827///; 8828/// Returns:; 8829/// - 0 entry range set; 8830/// - -1 on error; 8831 ; 8832Int_t TTree::SetCacheEntryRange(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry rang",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:343283,Performance,cache,cache,343283," if(TTreeCacheUnzip::IsParallelUnzip() && file->GetCompressionLevel() > 0); 8815 pf = new TTreeCacheUnzip(this, cacheSize);; 8816 else; 8817#endif; 8818 pf = new TTreeCache(this, cacheSize);; 8819 ; 8820 pf->SetAutoCreated(autocache);; 8821 ; 8822 return 0;; 8823}; 8824 ; 8825////////////////////////////////////////////////////////////////////////////////; 8826///interface to TTreeCache to set the cache entry range; 8827///; 8828/// Returns:; 8829/// - 0 entry range set; 8830/// - -1 on error; 8831 ; 8832Int_t TTree::SetCacheEntryRange(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry range"");; 8857 return -1;; 8858 }; 8859 tc->SetEntryRange(first,last);; 8860 return 0;; 8861}; 8862 ; 8863////////////////////////////////////////////////////////////////////////////////; 8864/// Interface to TTreeCache to set the number of entries for the learning phase; 8865 ; 8866void TTree::SetCacheLearnEntries(Int_t n); 8867{; 8868 TTreeCache::SetLearnEntries(n);; 8869}; 8870 ; 8871////////////////////////////////////////////////////////////////////////////////; 8872/// Enable/Disable circularity for this tree.; 8873///; 8874/// if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; 8875/// per branch in memory.; 8876/// Note that when this function is called (maxEntries>0) the Tre",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:343458,Performance,cache,cache,343458," cacheSize);; 8819 ; 8820 pf->SetAutoCreated(autocache);; 8821 ; 8822 return 0;; 8823}; 8824 ; 8825////////////////////////////////////////////////////////////////////////////////; 8826///interface to TTreeCache to set the cache entry range; 8827///; 8828/// Returns:; 8829/// - 0 entry range set; 8830/// - -1 on error; 8831 ; 8832Int_t TTree::SetCacheEntryRange(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry range"");; 8857 return -1;; 8858 }; 8859 tc->SetEntryRange(first,last);; 8860 return 0;; 8861}; 8862 ; 8863////////////////////////////////////////////////////////////////////////////////; 8864/// Interface to TTreeCache to set the number of entries for the learning phase; 8865 ; 8866void TTree::SetCacheLearnEntries(Int_t n); 8867{; 8868 TTreeCache::SetLearnEntries(n);; 8869}; 8870 ; 8871////////////////////////////////////////////////////////////////////////////////; 8872/// Enable/Disable circularity for this tree.; 8873///; 8874/// if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; 8875/// per branch in memory.; 8876/// Note that when this function is called (maxEntries>0) the Tree; 8877/// must be empty or having only one basket per branch.; 8878/// if maxEntries <= 0 the tree circularity is disabled.; 8879///; 8880/// #### NOTE 1:; 8881/// Circular Tre",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:343604,Performance,cache,cache,343604," cacheSize);; 8819 ; 8820 pf->SetAutoCreated(autocache);; 8821 ; 8822 return 0;; 8823}; 8824 ; 8825////////////////////////////////////////////////////////////////////////////////; 8826///interface to TTreeCache to set the cache entry range; 8827///; 8828/// Returns:; 8829/// - 0 entry range set; 8830/// - -1 on error; 8831 ; 8832Int_t TTree::SetCacheEntryRange(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry range"");; 8857 return -1;; 8858 }; 8859 tc->SetEntryRange(first,last);; 8860 return 0;; 8861}; 8862 ; 8863////////////////////////////////////////////////////////////////////////////////; 8864/// Interface to TTreeCache to set the number of entries for the learning phase; 8865 ; 8866void TTree::SetCacheLearnEntries(Int_t n); 8867{; 8868 TTreeCache::SetLearnEntries(n);; 8869}; 8870 ; 8871////////////////////////////////////////////////////////////////////////////////; 8872/// Enable/Disable circularity for this tree.; 8873///; 8874/// if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; 8875/// per branch in memory.; 8876/// Note that when this function is called (maxEntries>0) the Tree; 8877/// must be empty or having only one basket per branch.; 8878/// if maxEntries <= 0 the tree circularity is disabled.; 8879///; 8880/// #### NOTE 1:; 8881/// Circular Tre",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:347903,Performance,cache,cache,347903,";; 8949 TBranch *b;; 8950 while ( ( b = (TBranch*)next() ) ) {; 8951 b->SetEntryOffsetLen( newdefault, true );; 8952 }; 8953 if (fBranchRef) {; 8954 fBranchRef->SetEntryOffsetLen( newdefault, true );; 8955 }; 8956 }; 8957}; 8958 ; 8959////////////////////////////////////////////////////////////////////////////////; 8960/// Change the tree's directory.; 8961///; 8962/// Remove reference to this tree from current directory and; 8963/// add reference to new directory dir. The dir parameter can; 8964/// be 0 in which case the tree does not belong to any directory.; 8965///; 8966 ; 8967void TTree::SetDirectory(TDirectory* dir); 8968{; 8969 if (fDirectory == dir) {; 8970 return;; 8971 }; 8972 if (fDirectory) {; 8973 fDirectory->Remove(this);; 8974 ; 8975 // Delete or move the file cache if it points to this Tree; 8976 TFile *file = fDirectory->GetFile();; 8977 MoveReadCache(file,dir);; 8978 }; 8979 fDirectory = dir;; 8980 if (fDirectory) {; 8981 fDirectory->Append(this);; 8982 }; 8983 TFile* file = nullptr;; 8984 if (fDirectory) {; 8985 file = fDirectory->GetFile();; 8986 }; 8987 if (fBranchRef) {; 8988 fBranchRef->SetFile(file);; 8989 }; 8990 TBranch* b = nullptr;; 8991 TIter next(GetListOfBranches());; 8992 while((b = (TBranch*) next())) {; 8993 b->SetFile(file);; 8994 }; 8995}; 8996 ; 8997////////////////////////////////////////////////////////////////////////////////; 8998/// Change number of entries in the tree.; 8999///; 9000/// If n >= 0, set number of entries in the tree = n.; 9001///; 9002/// If n < 0, set number of entries in the tree to match the; 9003/// number of entries in each branch. (default for n is -1); 9004///; 9005/// This function should be called only when one fills each branch; 9006/// independently via TBranch::Fill without calling TTree::Fill.; 9007/// Calling TTree::SetEntries() make sense only if the number of entries; 9008/// in each branch is identical, a warning is issued otherwise.; 9009/// The function returns the number of entries.; 9010/",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:359830,Performance,cache,cacheSize,359830,"///////////////; 9290/// Enable or disable parallel unzipping of Tree buffers.; 9291 ; 9292void TTree::SetParallelUnzip(bool opt, Float_t RelSize); 9293{; 9294#ifdef R__USE_IMT; 9295 if (GetTree() == nullptr) {; 9296 LoadTree(GetReadEntry());; 9297 if (!GetTree()); 9298 return;; 9299 }; 9300 if (GetTree() != this) {; 9301 GetTree()->SetParallelUnzip(opt, RelSize);; 9302 return;; 9303 }; 9304 TFile* file = GetCurrentFile();; 9305 if (!file); 9306 return;; 9307 ; 9308 TTreeCache* pf = GetReadCache(file);; 9309 if (pf && !( opt ^ (nullptr != dynamic_cast<TTreeCacheUnzip*>(pf)))) {; 9310 // done with opt and type are in agreement.; 9311 return;; 9312 }; 9313 delete pf;; 9314 auto cacheSize = GetCacheAutoSize(true);; 9315 if (opt) {; 9316 auto unzip = new TTreeCacheUnzip(this, cacheSize);; 9317 unzip->SetUnzipBufferSize( Long64_t(cacheSize * RelSize) );; 9318 } else {; 9319 pf = new TTreeCache(this, cacheSize);; 9320 }; 9321#else; 9322 (void)opt;; 9323 (void)RelSize;; 9324#endif; 9325}; 9326 ; 9327////////////////////////////////////////////////////////////////////////////////; 9328/// Set perf stats; 9329 ; 9330void TTree::SetPerfStats(TVirtualPerfStats *perf); 9331{; 9332 fPerfStats = perf;; 9333}; 9334 ; 9335////////////////////////////////////////////////////////////////////////////////; 9336/// The current TreeIndex is replaced by the new index.; 9337/// Note that this function does not delete the previous index.; 9338/// This gives the possibility to play with more than one index, e.g.,; 9339/// ~~~ {.cpp}; 9340/// TVirtualIndex* oldIndex = tree.GetTreeIndex();; 9341/// tree.SetTreeIndex(newIndex);; 9342/// tree.Draw();; 9343/// tree.SetTreeIndex(oldIndex);; 9344/// tree.Draw(); etc; 9345/// ~~~; 9346 ; 9347void TTree::SetTreeIndex(TVirtualIndex* index); 9348{; 9349 if (fTreeIndex) {; 9350 fTreeIndex->SetTree(nullptr);; 9351 }; 9352 fTreeIndex = index;; 9353}; 9354 ; 9355////////////////////////////////////////////////////////////////////////////////; 9356/// Set tr",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:359928,Performance,cache,cacheSize,359928,"///////////////; 9290/// Enable or disable parallel unzipping of Tree buffers.; 9291 ; 9292void TTree::SetParallelUnzip(bool opt, Float_t RelSize); 9293{; 9294#ifdef R__USE_IMT; 9295 if (GetTree() == nullptr) {; 9296 LoadTree(GetReadEntry());; 9297 if (!GetTree()); 9298 return;; 9299 }; 9300 if (GetTree() != this) {; 9301 GetTree()->SetParallelUnzip(opt, RelSize);; 9302 return;; 9303 }; 9304 TFile* file = GetCurrentFile();; 9305 if (!file); 9306 return;; 9307 ; 9308 TTreeCache* pf = GetReadCache(file);; 9309 if (pf && !( opt ^ (nullptr != dynamic_cast<TTreeCacheUnzip*>(pf)))) {; 9310 // done with opt and type are in agreement.; 9311 return;; 9312 }; 9313 delete pf;; 9314 auto cacheSize = GetCacheAutoSize(true);; 9315 if (opt) {; 9316 auto unzip = new TTreeCacheUnzip(this, cacheSize);; 9317 unzip->SetUnzipBufferSize( Long64_t(cacheSize * RelSize) );; 9318 } else {; 9319 pf = new TTreeCache(this, cacheSize);; 9320 }; 9321#else; 9322 (void)opt;; 9323 (void)RelSize;; 9324#endif; 9325}; 9326 ; 9327////////////////////////////////////////////////////////////////////////////////; 9328/// Set perf stats; 9329 ; 9330void TTree::SetPerfStats(TVirtualPerfStats *perf); 9331{; 9332 fPerfStats = perf;; 9333}; 9334 ; 9335////////////////////////////////////////////////////////////////////////////////; 9336/// The current TreeIndex is replaced by the new index.; 9337/// Note that this function does not delete the previous index.; 9338/// This gives the possibility to play with more than one index, e.g.,; 9339/// ~~~ {.cpp}; 9340/// TVirtualIndex* oldIndex = tree.GetTreeIndex();; 9341/// tree.SetTreeIndex(newIndex);; 9342/// tree.Draw();; 9343/// tree.SetTreeIndex(oldIndex);; 9344/// tree.Draw(); etc; 9345/// ~~~; 9346 ; 9347void TTree::SetTreeIndex(TVirtualIndex* index); 9348{; 9349 if (fTreeIndex) {; 9350 fTreeIndex->SetTree(nullptr);; 9351 }; 9352 fTreeIndex = index;; 9353}; 9354 ; 9355////////////////////////////////////////////////////////////////////////////////; 9356/// Set tr",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:359982,Performance,cache,cacheSize,359982,"///////////////; 9290/// Enable or disable parallel unzipping of Tree buffers.; 9291 ; 9292void TTree::SetParallelUnzip(bool opt, Float_t RelSize); 9293{; 9294#ifdef R__USE_IMT; 9295 if (GetTree() == nullptr) {; 9296 LoadTree(GetReadEntry());; 9297 if (!GetTree()); 9298 return;; 9299 }; 9300 if (GetTree() != this) {; 9301 GetTree()->SetParallelUnzip(opt, RelSize);; 9302 return;; 9303 }; 9304 TFile* file = GetCurrentFile();; 9305 if (!file); 9306 return;; 9307 ; 9308 TTreeCache* pf = GetReadCache(file);; 9309 if (pf && !( opt ^ (nullptr != dynamic_cast<TTreeCacheUnzip*>(pf)))) {; 9310 // done with opt and type are in agreement.; 9311 return;; 9312 }; 9313 delete pf;; 9314 auto cacheSize = GetCacheAutoSize(true);; 9315 if (opt) {; 9316 auto unzip = new TTreeCacheUnzip(this, cacheSize);; 9317 unzip->SetUnzipBufferSize( Long64_t(cacheSize * RelSize) );; 9318 } else {; 9319 pf = new TTreeCache(this, cacheSize);; 9320 }; 9321#else; 9322 (void)opt;; 9323 (void)RelSize;; 9324#endif; 9325}; 9326 ; 9327////////////////////////////////////////////////////////////////////////////////; 9328/// Set perf stats; 9329 ; 9330void TTree::SetPerfStats(TVirtualPerfStats *perf); 9331{; 9332 fPerfStats = perf;; 9333}; 9334 ; 9335////////////////////////////////////////////////////////////////////////////////; 9336/// The current TreeIndex is replaced by the new index.; 9337/// Note that this function does not delete the previous index.; 9338/// This gives the possibility to play with more than one index, e.g.,; 9339/// ~~~ {.cpp}; 9340/// TVirtualIndex* oldIndex = tree.GetTreeIndex();; 9341/// tree.SetTreeIndex(newIndex);; 9342/// tree.Draw();; 9343/// tree.SetTreeIndex(oldIndex);; 9344/// tree.Draw(); etc; 9345/// ~~~; 9346 ; 9347void TTree::SetTreeIndex(TVirtualIndex* index); 9348{; 9349 if (fTreeIndex) {; 9350 fTreeIndex->SetTree(nullptr);; 9351 }; 9352 fTreeIndex = index;; 9353}; 9354 ; 9355////////////////////////////////////////////////////////////////////////////////; 9356/// Set tr",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:360053,Performance,cache,cacheSize,360053,"///////////////; 9290/// Enable or disable parallel unzipping of Tree buffers.; 9291 ; 9292void TTree::SetParallelUnzip(bool opt, Float_t RelSize); 9293{; 9294#ifdef R__USE_IMT; 9295 if (GetTree() == nullptr) {; 9296 LoadTree(GetReadEntry());; 9297 if (!GetTree()); 9298 return;; 9299 }; 9300 if (GetTree() != this) {; 9301 GetTree()->SetParallelUnzip(opt, RelSize);; 9302 return;; 9303 }; 9304 TFile* file = GetCurrentFile();; 9305 if (!file); 9306 return;; 9307 ; 9308 TTreeCache* pf = GetReadCache(file);; 9309 if (pf && !( opt ^ (nullptr != dynamic_cast<TTreeCacheUnzip*>(pf)))) {; 9310 // done with opt and type are in agreement.; 9311 return;; 9312 }; 9313 delete pf;; 9314 auto cacheSize = GetCacheAutoSize(true);; 9315 if (opt) {; 9316 auto unzip = new TTreeCacheUnzip(this, cacheSize);; 9317 unzip->SetUnzipBufferSize( Long64_t(cacheSize * RelSize) );; 9318 } else {; 9319 pf = new TTreeCache(this, cacheSize);; 9320 }; 9321#else; 9322 (void)opt;; 9323 (void)RelSize;; 9324#endif; 9325}; 9326 ; 9327////////////////////////////////////////////////////////////////////////////////; 9328/// Set perf stats; 9329 ; 9330void TTree::SetPerfStats(TVirtualPerfStats *perf); 9331{; 9332 fPerfStats = perf;; 9333}; 9334 ; 9335////////////////////////////////////////////////////////////////////////////////; 9336/// The current TreeIndex is replaced by the new index.; 9337/// Note that this function does not delete the previous index.; 9338/// This gives the possibility to play with more than one index, e.g.,; 9339/// ~~~ {.cpp}; 9340/// TVirtualIndex* oldIndex = tree.GetTreeIndex();; 9341/// tree.SetTreeIndex(newIndex);; 9342/// tree.Draw();; 9343/// tree.SetTreeIndex(oldIndex);; 9344/// tree.Draw(); etc; 9345/// ~~~; 9346 ; 9347void TTree::SetTreeIndex(TVirtualIndex* index); 9348{; 9349 if (fTreeIndex) {; 9350 fTreeIndex->SetTree(nullptr);; 9351 }; 9352 fTreeIndex = index;; 9353}; 9354 ; 9355////////////////////////////////////////////////////////////////////////////////; 9356/// Set tr",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:364493,Performance,cache,cache,364493,"f->IsA() == TLeafD::Class()) {; 9433 ltype = 5;; 9434 }; 9435 if (leaf->IsA() == TLeafC::Class()) {; 9436 len = 1;; 9437 ltype = 5;; 9438 };; 9439 printf("" %-15s = "", leaf->GetName());; 9440 for (Int_t l = 0; l < len; l++) {; 9441 leaf->PrintValue(l);; 9442 if (l == (len - 1)) {; 9443 printf(""\n"");; 9444 continue;; 9445 }; 9446 printf("", "");; 9447 if ((l % ltype) == 0) {; 9448 printf(""\n "");; 9449 }; 9450 }; 9451 }; 9452}; 9453 ; 9454////////////////////////////////////////////////////////////////////////////////; 9455/// Start the TTreeViewer on this tree.; 9456///; 9457/// - ww is the width of the canvas in pixels; 9458/// - wh is the height of the canvas in pixels; 9459 ; 9460void TTree::StartViewer(); 9461{; 9462 GetPlayer();; 9463 if (fPlayer) {; 9464 fPlayer->StartViewer(600, 400);; 9465 }; 9466}; 9467 ; 9468////////////////////////////////////////////////////////////////////////////////; 9469/// Stop the cache learning phase; 9470///; 9471/// Returns:; 9472/// - 0 learning phase stopped or not active; 9473/// - -1 on error; 9474 ; 9475Int_t TTree::StopCacheLearningPhase(); 9476{; 9477 if (!GetTree()) {; 9478 if (LoadTree(0)<0) {; 9479 Error(""StopCacheLearningPhase"",""Could not load a tree"");; 9480 return -1;; 9481 }; 9482 }; 9483 if (GetTree()) {; 9484 if (GetTree() != this) {; 9485 return GetTree()->StopCacheLearningPhase();; 9486 }; 9487 } else {; 9488 Error(""StopCacheLearningPhase"", ""No tree is available. Could not stop cache learning phase"");; 9489 return -1;; 9490 }; 9491 ; 9492 TFile *f = GetCurrentFile();; 9493 if (!f) {; 9494 Error(""StopCacheLearningPhase"", ""No file is available. Could not stop cache learning phase"");; 9495 return -1;; 9496 }; 9497 TTreeCache *tc = GetReadCache(f,true);; 9498 if (!tc) {; 9499 Error(""StopCacheLearningPhase"", ""No cache is available. Could not stop learning phase"");; 9500 return -1;; 9501 }; 9502 tc->StopLearningPhase();; 9503 return 0;; 9504}; 9505 ; 9506///////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:364770,Performance,load,load,364770,"f->IsA() == TLeafD::Class()) {; 9433 ltype = 5;; 9434 }; 9435 if (leaf->IsA() == TLeafC::Class()) {; 9436 len = 1;; 9437 ltype = 5;; 9438 };; 9439 printf("" %-15s = "", leaf->GetName());; 9440 for (Int_t l = 0; l < len; l++) {; 9441 leaf->PrintValue(l);; 9442 if (l == (len - 1)) {; 9443 printf(""\n"");; 9444 continue;; 9445 }; 9446 printf("", "");; 9447 if ((l % ltype) == 0) {; 9448 printf(""\n "");; 9449 }; 9450 }; 9451 }; 9452}; 9453 ; 9454////////////////////////////////////////////////////////////////////////////////; 9455/// Start the TTreeViewer on this tree.; 9456///; 9457/// - ww is the width of the canvas in pixels; 9458/// - wh is the height of the canvas in pixels; 9459 ; 9460void TTree::StartViewer(); 9461{; 9462 GetPlayer();; 9463 if (fPlayer) {; 9464 fPlayer->StartViewer(600, 400);; 9465 }; 9466}; 9467 ; 9468////////////////////////////////////////////////////////////////////////////////; 9469/// Stop the cache learning phase; 9470///; 9471/// Returns:; 9472/// - 0 learning phase stopped or not active; 9473/// - -1 on error; 9474 ; 9475Int_t TTree::StopCacheLearningPhase(); 9476{; 9477 if (!GetTree()) {; 9478 if (LoadTree(0)<0) {; 9479 Error(""StopCacheLearningPhase"",""Could not load a tree"");; 9480 return -1;; 9481 }; 9482 }; 9483 if (GetTree()) {; 9484 if (GetTree() != this) {; 9485 return GetTree()->StopCacheLearningPhase();; 9486 }; 9487 } else {; 9488 Error(""StopCacheLearningPhase"", ""No tree is available. Could not stop cache learning phase"");; 9489 return -1;; 9490 }; 9491 ; 9492 TFile *f = GetCurrentFile();; 9493 if (!f) {; 9494 Error(""StopCacheLearningPhase"", ""No file is available. Could not stop cache learning phase"");; 9495 return -1;; 9496 }; 9497 TTreeCache *tc = GetReadCache(f,true);; 9498 if (!tc) {; 9499 Error(""StopCacheLearningPhase"", ""No cache is available. Could not stop learning phase"");; 9500 return -1;; 9501 }; 9502 tc->StopLearningPhase();; 9503 return 0;; 9504}; 9505 ; 9506///////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:365021,Performance,cache,cache,365021,"Start the TTreeViewer on this tree.; 9456///; 9457/// - ww is the width of the canvas in pixels; 9458/// - wh is the height of the canvas in pixels; 9459 ; 9460void TTree::StartViewer(); 9461{; 9462 GetPlayer();; 9463 if (fPlayer) {; 9464 fPlayer->StartViewer(600, 400);; 9465 }; 9466}; 9467 ; 9468////////////////////////////////////////////////////////////////////////////////; 9469/// Stop the cache learning phase; 9470///; 9471/// Returns:; 9472/// - 0 learning phase stopped or not active; 9473/// - -1 on error; 9474 ; 9475Int_t TTree::StopCacheLearningPhase(); 9476{; 9477 if (!GetTree()) {; 9478 if (LoadTree(0)<0) {; 9479 Error(""StopCacheLearningPhase"",""Could not load a tree"");; 9480 return -1;; 9481 }; 9482 }; 9483 if (GetTree()) {; 9484 if (GetTree() != this) {; 9485 return GetTree()->StopCacheLearningPhase();; 9486 }; 9487 } else {; 9488 Error(""StopCacheLearningPhase"", ""No tree is available. Could not stop cache learning phase"");; 9489 return -1;; 9490 }; 9491 ; 9492 TFile *f = GetCurrentFile();; 9493 if (!f) {; 9494 Error(""StopCacheLearningPhase"", ""No file is available. Could not stop cache learning phase"");; 9495 return -1;; 9496 }; 9497 TTreeCache *tc = GetReadCache(f,true);; 9498 if (!tc) {; 9499 Error(""StopCacheLearningPhase"", ""No cache is available. Could not stop learning phase"");; 9500 return -1;; 9501 }; 9502 tc->StopLearningPhase();; 9503 return 0;; 9504}; 9505 ; 9506////////////////////////////////////////////////////////////////////////////////; 9507/// Set the fTree member for all branches and sub branches.; 9508 ; 9509static void TBranch__SetTree(TTree *tree, TObjArray &branches); 9510{; 9511 Int_t nb = branches.GetEntriesFast();; 9512 for (Int_t i = 0; i < nb; ++i) {; 9513 TBranch* br = (TBranch*) branches.UncheckedAt(i);; 9514 br->SetTree(tree);; 9515 ; 9516 Int_t writeBasket = br->GetWriteBasket();; 9517 for (Int_t j = writeBasket; j >= 0; --j) {; 9518 TBasket *bk = (TBasket*)br->GetListOfBaskets()->UncheckedAt(j);; 9519 if (bk) {; 9520 tree->In",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:365204,Performance,cache,cache,365204," 9461{; 9462 GetPlayer();; 9463 if (fPlayer) {; 9464 fPlayer->StartViewer(600, 400);; 9465 }; 9466}; 9467 ; 9468////////////////////////////////////////////////////////////////////////////////; 9469/// Stop the cache learning phase; 9470///; 9471/// Returns:; 9472/// - 0 learning phase stopped or not active; 9473/// - -1 on error; 9474 ; 9475Int_t TTree::StopCacheLearningPhase(); 9476{; 9477 if (!GetTree()) {; 9478 if (LoadTree(0)<0) {; 9479 Error(""StopCacheLearningPhase"",""Could not load a tree"");; 9480 return -1;; 9481 }; 9482 }; 9483 if (GetTree()) {; 9484 if (GetTree() != this) {; 9485 return GetTree()->StopCacheLearningPhase();; 9486 }; 9487 } else {; 9488 Error(""StopCacheLearningPhase"", ""No tree is available. Could not stop cache learning phase"");; 9489 return -1;; 9490 }; 9491 ; 9492 TFile *f = GetCurrentFile();; 9493 if (!f) {; 9494 Error(""StopCacheLearningPhase"", ""No file is available. Could not stop cache learning phase"");; 9495 return -1;; 9496 }; 9497 TTreeCache *tc = GetReadCache(f,true);; 9498 if (!tc) {; 9499 Error(""StopCacheLearningPhase"", ""No cache is available. Could not stop learning phase"");; 9500 return -1;; 9501 }; 9502 tc->StopLearningPhase();; 9503 return 0;; 9504}; 9505 ; 9506////////////////////////////////////////////////////////////////////////////////; 9507/// Set the fTree member for all branches and sub branches.; 9508 ; 9509static void TBranch__SetTree(TTree *tree, TObjArray &branches); 9510{; 9511 Int_t nb = branches.GetEntriesFast();; 9512 for (Int_t i = 0; i < nb; ++i) {; 9513 TBranch* br = (TBranch*) branches.UncheckedAt(i);; 9514 br->SetTree(tree);; 9515 ; 9516 Int_t writeBasket = br->GetWriteBasket();; 9517 for (Int_t j = writeBasket; j >= 0; --j) {; 9518 TBasket *bk = (TBasket*)br->GetListOfBaskets()->UncheckedAt(j);; 9519 if (bk) {; 9520 tree->IncrementTotalBuffers(bk->GetBufferSize());; 9521 }; 9522 }; 9523 ; 9524 TBranch__SetTree(tree,*br->GetListOfBranches());; 9525 }; 9526}; 9527 ; 9528//////////////////////////////////////",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:365357,Performance,cache,cache,365357," 9461{; 9462 GetPlayer();; 9463 if (fPlayer) {; 9464 fPlayer->StartViewer(600, 400);; 9465 }; 9466}; 9467 ; 9468////////////////////////////////////////////////////////////////////////////////; 9469/// Stop the cache learning phase; 9470///; 9471/// Returns:; 9472/// - 0 learning phase stopped or not active; 9473/// - -1 on error; 9474 ; 9475Int_t TTree::StopCacheLearningPhase(); 9476{; 9477 if (!GetTree()) {; 9478 if (LoadTree(0)<0) {; 9479 Error(""StopCacheLearningPhase"",""Could not load a tree"");; 9480 return -1;; 9481 }; 9482 }; 9483 if (GetTree()) {; 9484 if (GetTree() != this) {; 9485 return GetTree()->StopCacheLearningPhase();; 9486 }; 9487 } else {; 9488 Error(""StopCacheLearningPhase"", ""No tree is available. Could not stop cache learning phase"");; 9489 return -1;; 9490 }; 9491 ; 9492 TFile *f = GetCurrentFile();; 9493 if (!f) {; 9494 Error(""StopCacheLearningPhase"", ""No file is available. Could not stop cache learning phase"");; 9495 return -1;; 9496 }; 9497 TTreeCache *tc = GetReadCache(f,true);; 9498 if (!tc) {; 9499 Error(""StopCacheLearningPhase"", ""No cache is available. Could not stop learning phase"");; 9500 return -1;; 9501 }; 9502 tc->StopLearningPhase();; 9503 return 0;; 9504}; 9505 ; 9506////////////////////////////////////////////////////////////////////////////////; 9507/// Set the fTree member for all branches and sub branches.; 9508 ; 9509static void TBranch__SetTree(TTree *tree, TObjArray &branches); 9510{; 9511 Int_t nb = branches.GetEntriesFast();; 9512 for (Int_t i = 0; i < nb; ++i) {; 9513 TBranch* br = (TBranch*) branches.UncheckedAt(i);; 9514 br->SetTree(tree);; 9515 ; 9516 Int_t writeBasket = br->GetWriteBasket();; 9517 for (Int_t j = writeBasket; j >= 0; --j) {; 9518 TBasket *bk = (TBasket*)br->GetListOfBaskets()->UncheckedAt(j);; 9519 if (bk) {; 9520 tree->IncrementTotalBuffers(bk->GetBufferSize());; 9521 }; 9522 }; 9523 ; 9524 TBranch__SetTree(tree,*br->GetListOfBranches());; 9525 }; 9526}; 9527 ; 9528//////////////////////////////////////",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:366992,Performance,cache,cache,366992,"()->UncheckedAt(j);; 9519 if (bk) {; 9520 tree->IncrementTotalBuffers(bk->GetBufferSize());; 9521 }; 9522 }; 9523 ; 9524 TBranch__SetTree(tree,*br->GetListOfBranches());; 9525 }; 9526}; 9527 ; 9528////////////////////////////////////////////////////////////////////////////////; 9529/// Set the fTree member for all friend elements.; 9530 ; 9531void TFriendElement__SetTree(TTree *tree, TList *frlist); 9532{; 9533 if (frlist) {; 9534 TObjLink *lnk = frlist->FirstLink();; 9535 while (lnk) {; 9536 TFriendElement *elem = (TFriendElement*)lnk->GetObject();; 9537 elem->fParentTree = tree;; 9538 lnk = lnk->Next();; 9539 }; 9540 }; 9541}; 9542 ; 9543////////////////////////////////////////////////////////////////////////////////; 9544/// Stream a class object.; 9545 ; 9546void TTree::Streamer(TBuffer& b); 9547{; 9548 if (b.IsReading()) {; 9549 UInt_t R__s, R__c;; 9550 if (fDirectory) {; 9551 fDirectory->Remove(this);; 9552 //delete the file cache if it points to this Tree; 9553 TFile *file = fDirectory->GetFile();; 9554 MoveReadCache(file,nullptr);; 9555 }; 9556 fDirectory = nullptr;; 9557 fCacheDoAutoInit = true;; 9558 fCacheUserSet = false;; 9559 Version_t R__v = b.ReadVersion(&R__s, &R__c);; 9560 if (R__v > 4) {; 9561 b.ReadClassBuffer(TTree::Class(), this, R__v, R__s, R__c);; 9562 ; 9563 fBranches.SetOwner(true); // True needed only for R__v < 19 and most R__v == 19; 9564 ; 9565 if (fBranchRef) fBranchRef->SetTree(this);; 9566 TBranch__SetTree(this,fBranches);; 9567 TFriendElement__SetTree(this,fFriends);; 9568 ; 9569 if (fTreeIndex) {; 9570 fTreeIndex->SetTree(this);; 9571 }; 9572 if (fIndex.fN) {; 9573 Warning(""Streamer"", ""Old style index in this tree is deleted. Rebuild the index via TTree::BuildIndex"");; 9574 fIndex.Set(0);; 9575 fIndexValues.Set(0);; 9576 }; 9577 if (fEstimate <= 10000) {; 9578 fEstimate = 1000000;; 9579 }; 9580 ; 9581 if (fNClusterRange) {; 9582 // The I/O allocated just enough memory to hold the; 9583 // current set of ranges.; 9584 fMaxClusterRange",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:368196,Performance,cache,cache,368196,"lement__SetTree(this,fFriends);; 9568 ; 9569 if (fTreeIndex) {; 9570 fTreeIndex->SetTree(this);; 9571 }; 9572 if (fIndex.fN) {; 9573 Warning(""Streamer"", ""Old style index in this tree is deleted. Rebuild the index via TTree::BuildIndex"");; 9574 fIndex.Set(0);; 9575 fIndexValues.Set(0);; 9576 }; 9577 if (fEstimate <= 10000) {; 9578 fEstimate = 1000000;; 9579 }; 9580 ; 9581 if (fNClusterRange) {; 9582 // The I/O allocated just enough memory to hold the; 9583 // current set of ranges.; 9584 fMaxClusterRange = fNClusterRange;; 9585 }; 9586 ; 9587 // Throughs calls to `GetCacheAutoSize` or `EnableCache` (for example; 9588 // by TTreePlayer::Process, the cache size will be automatically; 9589 // determined unless the user explicitly call `SetCacheSize`; 9590 fCacheSize = 0;; 9591 fCacheUserSet = false;; 9592 ; 9593 ResetBit(kMustCleanup);; 9594 return;; 9595 }; 9596 //====process old versions before automatic schema evolution; 9597 Stat_t djunk;; 9598 Int_t ijunk;; 9599 TNamed::Streamer(b);; 9600 TAttLine::Streamer(b);; 9601 TAttFill::Streamer(b);; 9602 TAttMarker::Streamer(b);; 9603 b >> fScanField;; 9604 b >> ijunk; fMaxEntryLoop = (Long64_t)ijunk;; 9605 b >> ijunk; fMaxVirtualSize = (Long64_t)ijunk;; 9606 b >> djunk; fEntries = (Long64_t)djunk;; 9607 b >> djunk; fTotBytes = (Long64_t)djunk;; 9608 b >> djunk; fZipBytes = (Long64_t)djunk;; 9609 b >> ijunk; fAutoSave = (Long64_t)ijunk;; 9610 b >> ijunk; fEstimate = (Long64_t)ijunk;; 9611 if (fEstimate <= 10000) fEstimate = 1000000;; 9612 fBranches.Streamer(b);; 9613 if (fBranchRef) fBranchRef->SetTree(this);; 9614 TBranch__SetTree(this,fBranches);; 9615 fLeaves.Streamer(b);; 9616 fSavedBytes = fTotBytes;; 9617 if (R__v > 1) fIndexValues.Streamer(b);; 9618 if (R__v > 2) fIndex.Streamer(b);; 9619 if (R__v > 3) {; 9620 TList OldInfoList;; 9621 OldInfoList.Streamer(b);; 9622 OldInfoList.Delete();; 9623 }; 9624 fNClusterRange = 0;; 9625 fDefaultEntryOffsetLen = 1000;; 9626 ResetBit(kMustCleanup);; 9627 b.CheckByteCount(R__s, R__",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:392847,Performance,load,loaded,392847,"ement.h:213; TBranchElement::SetBranchFoldervirtual void SetBranchFolder()Definition TBranchElement.h:226; TBranchElement::Classstatic TClass * Class(); TBranchElement::GetClassVersionInt_t GetClassVersion()Definition TBranchElement.h:210; TBranchElement::GetClassNameconst char * GetClassName() const overrideReturn the name of the user class whose content is stored in this branch, if any.Definition TBranchElement.h:186; TBranchElement::ResetAddressvoid ResetAddress() overrideSet branch address to zero and free all allocated memory.Definition TBranchElement.cxx:4780; TBranchElement::UnrollInt_t Unroll(const char *name, TClass *cltop, TClass *cl, char *ptr, Int_t basketsize, Int_t splitlevel, Int_t btype)Split class cl into sub-branches of this branch.Definition TBranchElement.cxx:6212; TBranchElement::SetAddressvoid SetAddress(void *addobj) overridePoint this branch at an object.Definition TBranchElement.cxx:4962; TBranchElement::SetTargetClassvirtual void SetTargetClass(const char *name)Set the name of the class of the in-memory object into which the data will loaded.Definition TBranchElement.cxx:5855; TBranchElement::GetCheckSumUInt_t GetCheckSum()Definition TBranchElement.h:185; TBranchElement::SetObjectvoid SetObject(void *objadd) overrideSet object this branch is pointing to.Definition TBranchElement.cxx:5575; TBranchObjectA Branch for the case of an object.Definition TBranchObject.h:26; TBranchRefA branch containing and managing a TRefTable for TRef autoloading.Definition TBranchRef.h:34; TBranchRef::Resetvoid Reset(Option_t *option="""") overrideDefinition TBranchRef.cxx:187; TBranchRef::Printvoid Print(Option_t *option="""") const overridePrint the TRefTable branch.Definition TBranchRef.cxx:159; TBranchRef::Clearvoid Clear(Option_t *option="""") overrideClear entries in the TRefTable.Definition TBranchRef.cxx:95; TBranchRef::ResetAfterMergevoid ResetAfterMerge(TFileMergeInfo *) overrideReset a Branch after a Merge operation (drop data but keep customizations) TRefTa",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:393889,Performance,queue,queues,393889,"anchElement.cxx:5855; TBranchElement::GetCheckSumUInt_t GetCheckSum()Definition TBranchElement.h:185; TBranchElement::SetObjectvoid SetObject(void *objadd) overrideSet object this branch is pointing to.Definition TBranchElement.cxx:5575; TBranchObjectA Branch for the case of an object.Definition TBranchObject.h:26; TBranchRefA branch containing and managing a TRefTable for TRef autoloading.Definition TBranchRef.h:34; TBranchRef::Resetvoid Reset(Option_t *option="""") overrideDefinition TBranchRef.cxx:187; TBranchRef::Printvoid Print(Option_t *option="""") const overridePrint the TRefTable branch.Definition TBranchRef.cxx:159; TBranchRef::Clearvoid Clear(Option_t *option="""") overrideClear entries in the TRefTable.Definition TBranchRef.cxx:95; TBranchRef::ResetAfterMergevoid ResetAfterMerge(TFileMergeInfo *) overrideReset a Branch after a Merge operation (drop data but keep customizations) TRefTable is cleared.Definition TBranchRef.cxx:198; TBranchSTLA Branch handling STL collection of pointers (vectors, lists, queues, sets and multisets) while stori...Definition TBranchSTL.h:22; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBranch::GetLeafvirtual TLeaf * GetLeaf(const char *name) constReturn pointer to the 1st Leaf named name in thisBranch.Definition TBranch.cxx:2055; TBranch::GetMakeClassvirtual bool GetMakeClass() constReturn whether this branch is in a mode where the object are decomposed or not (Also known as MakeCla...Definition TBranch.cxx:2117; TBranch::SetupAddressesvirtual void SetupAddresses()If the branch address is not set, we set all addresses starting with the top level parent branch.Definition TBranch.cxx:3294; TBranch::ResetAddressvirtual void ResetAddress()Reset the address of the branch.Definition TBranch.cxx:2651; TBranch::GetBasketSeekvirtual Long64_t GetBasketSeek(Int_t basket) constReturn address of basket in the file.Definition TBranch.cxx:1302; TBranch::GetAddressvirtual char * GetAddress() constDefinition TBranch.h:212; TBranch::",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:401899,Performance,load,load,401899,"GetCollectionType() constReturn the 'type' of the STL the TClass is representing.Definition TClass.cxx:2953; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::HasDataMemberInfoBool_t HasDataMemberInfo() constDefinition TClass.h:407; TClass::HasCustomStreamerMemberBool_t HasCustomStreamerMember() constThe class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based...Definition TClass.h:508; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::BuildRealDatavoid BuildRealData(void *pointer=nullptr, Bool_t isTransient=kFALSE)Build a full list of persistent data members.Definition TClass.cxx:2098; TClass::GetTypeInfoconst std::type_info * GetTypeInfo() constDefinition TClass.h:496; TClass::GetListOfDataMembersTList * GetListOfDataMembers(Bool_t load=kTRUE)Return list containing the TDataMembers of a class.Definition TClass.cxx:3837; TClass::GetListOfRealDataTList * GetListOfRealData() constDefinition TClass.h:453; TClass::CanIgnoreTObjectStreamerBool_t CanIgnoreTObjectStreamer()Definition TClass.h:393; TClass::GetSchemaRulesconst ROOT::Detail::TSchemaRuleSet * GetSchemaRules() constReturn the set of the schema rules if any.Definition TClass.cxx:1999; TClass::GetListOfBasesTList * GetListOfBases()Return list containing the TBaseClass(es) of a class.Definition TClass.cxx:3703; TClass::IsLoadedBool_t IsLoaded() constReturn true if the shared library of this class is currently in the a process's memory.Definition TClass.cxx:5979; TClass::IsTObjectBool_t IsTObject() constReturn kTRUE is the class inherits from TObject.Definition TClass.cxx:6005; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the o",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:404101,Performance,load,load,404101,"; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetConversionStreamerInfoTVirtualStreamerInfo * GetConversionStreamerInfo(const char *onfile_classname, Int_t version) constReturn a Conversion StreamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7260; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetActualClassTClass * GetActualClass(const void *object) constReturn a pointer to the real class of the object.Definition TClass.cxx:2674; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClass::WriteBufferInt_t WriteBuffer(TBuffer &b, void *pointer, const char *info="""")Function called by the Streamer functions to serialize object at p to buffer b.Definition TClass.cxx:6846; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::BypassStreamervoid BypassStreamer(Bool_t bypass=kTRUE)When the kBypassStreamer bit is set, the automatically generated Streamer can call directly TClass::W...Definition TClonesArray.cxx:321; TClonesArray::GetClassTClass * GetClass() constDefinition TClonesArray.h:53; TClonesArray::Classstatic TClass * Class(); TCollectionCollection abstract base class.Definition TCollection.h:65; TCollection::GetObjectRefvirtual TObject ** GetObjectRef(const TObject *obj) const =0; TCollection::MakeIteratorvirtual TIterator * MakeIterator(Bool_t dir=kIterForward) const =0; TCollection::Classstatic TClass * C",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:410937,Performance,cache,cache,410937,"al void SetReapplyCut(bool apply=false)Definition TEntryList.h:108; TEntryList::SetDirectoryvirtual void SetDirectory(TDirectory *dir)Add reference to directory dir. dir can be 0.Definition TEntryList.cxx:1170; TEntryList::GetEntryvirtual Long64_t GetEntry(Long64_t index)Return the number of the entry #index of this TEntryList in the TTree or TChain See also Next().Definition TEntryList.cxx:759; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TEventList<div class=""legacybox""><h2>Legacy Code</h2> TEventList is a legacy interface: there will be no bug fi...Definition TEventList.h:31; TEventList::GetEntryvirtual Long64_t GetEntry(Int_t index) constReturn value of entry at index in the list.Definition TEventList.cxx:227; TEventList::GetReapplyCutvirtual bool GetReapplyCut() constDefinition TEventList.h:57; TEventList::GetNvirtual Int_t GetN() constDefinition TEventList.h:56; TFileCacheReadA cache when reading files over the network.Definition TFileCacheRead.h:22; TFileCacheRead::WaitFinishPrefetchvirtual void WaitFinishPrefetch()Definition TFileCacheRead.cxx:691; TFileCacheRead::GetBufferSizevirtual Int_t GetBufferSize() constDefinition TFileCacheRead.h:88; TFileMergeInfoDefinition TFileMergeInfo.h:42; TFileMergeInfo::fIOFeaturesTIOFeatures * fIOFeaturesDefinition TFileMergeInfo.h:55; TFileMergeInfo::fIsFirstBool_t fIsFirstDefinition TFileMergeInfo.h:52; TFileMergeInfo::fOptionsTString fOptionsDefinition TFileMergeInfo.h:53; TFileMergeInfo::fOutputDirectoryTDirectory * fOutputDirectoryDefinition TFileMergeInfo.h:51; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::SetCacheReadvirtual void SetCacheRead(TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect)Set a pointer to the read cache.Definition TFile.cxx:2365; TFile::GetCompressionSettingsInt_t GetCompressionSettings(",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:411768,Performance,cache,cache,411768,"applyCutvirtual bool GetReapplyCut() constDefinition TEventList.h:57; TEventList::GetNvirtual Int_t GetN() constDefinition TEventList.h:56; TFileCacheReadA cache when reading files over the network.Definition TFileCacheRead.h:22; TFileCacheRead::WaitFinishPrefetchvirtual void WaitFinishPrefetch()Definition TFileCacheRead.cxx:691; TFileCacheRead::GetBufferSizevirtual Int_t GetBufferSize() constDefinition TFileCacheRead.h:88; TFileMergeInfoDefinition TFileMergeInfo.h:42; TFileMergeInfo::fIOFeaturesTIOFeatures * fIOFeaturesDefinition TFileMergeInfo.h:55; TFileMergeInfo::fIsFirstBool_t fIsFirstDefinition TFileMergeInfo.h:52; TFileMergeInfo::fOptionsTString fOptionsDefinition TFileMergeInfo.h:53; TFileMergeInfo::fOutputDirectoryTDirectory * fOutputDirectoryDefinition TFileMergeInfo.h:51; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::SetCacheReadvirtual void SetCacheRead(TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect)Set a pointer to the read cache.Definition TFile.cxx:2365; TFile::GetCompressionSettingsInt_t GetCompressionSettings() constDefinition TFile.h:397; TFile::GetCompressionLevelInt_t GetCompressionLevel() constDefinition TFile.h:391; TFile::GetENDvirtual Long64_t GetEND() constDefinition TFile.h:231; TFile::WriteStreamerInfovirtual void WriteStreamerInfo()Write the list of TStreamerInfo as a single object in this file The class Streamer description for al...Definition TFile.cxx:3792; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk states.Definition TFile.cxx:1141; TFile::MakeFreevirtual void MakeFree(Long64_t first, Long64_t last)Mark unused bytes on the file.Definition TFile.cxx:1484; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, In",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:411856,Performance,cache,cache,411856,"applyCutvirtual bool GetReapplyCut() constDefinition TEventList.h:57; TEventList::GetNvirtual Int_t GetN() constDefinition TEventList.h:56; TFileCacheReadA cache when reading files over the network.Definition TFileCacheRead.h:22; TFileCacheRead::WaitFinishPrefetchvirtual void WaitFinishPrefetch()Definition TFileCacheRead.cxx:691; TFileCacheRead::GetBufferSizevirtual Int_t GetBufferSize() constDefinition TFileCacheRead.h:88; TFileMergeInfoDefinition TFileMergeInfo.h:42; TFileMergeInfo::fIOFeaturesTIOFeatures * fIOFeaturesDefinition TFileMergeInfo.h:55; TFileMergeInfo::fIsFirstBool_t fIsFirstDefinition TFileMergeInfo.h:52; TFileMergeInfo::fOptionsTString fOptionsDefinition TFileMergeInfo.h:53; TFileMergeInfo::fOutputDirectoryTDirectory * fOutputDirectoryDefinition TFileMergeInfo.h:51; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::SetCacheReadvirtual void SetCacheRead(TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect)Set a pointer to the read cache.Definition TFile.cxx:2365; TFile::GetCompressionSettingsInt_t GetCompressionSettings() constDefinition TFile.h:397; TFile::GetCompressionLevelInt_t GetCompressionLevel() constDefinition TFile.h:391; TFile::GetENDvirtual Long64_t GetEND() constDefinition TFile.h:231; TFile::WriteStreamerInfovirtual void WriteStreamerInfo()Write the list of TStreamerInfo as a single object in this file The class Streamer description for al...Definition TFile.cxx:3792; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk states.Definition TFile.cxx:1141; TFile::MakeFreevirtual void MakeFree(Long64_t first, Long64_t last)Mark unused bytes on the file.Definition TFile.cxx:1484; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, In",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:413271,Performance,cache,cache,413271,"merInfo as a single object in this file The class Streamer description for al...Definition TFile.cxx:3792; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk states.Definition TFile.cxx:1141; TFile::MakeFreevirtual void MakeFree(Long64_t first, Long64_t last)Mark unused bytes on the file.Definition TFile.cxx:1484; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::WriteHeadervirtual void WriteHeader()Write File Header.Definition TFile.cxx:2615; TFile::GetRecordHeaderInt_t GetRecordHeader(char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen)Read the logical record header starting at a certain postion.Definition TFile.cxx:1301; TFile::GetCacheReadTFileCacheRead * GetCacheRead(const TObject *tree=nullptr) constReturn a pointer to the current read cache.Definition TFile.cxx:1262; TFolder<div class=""legacybox""><h2>Legacy Code</h2> TFolder is a legacy interface: there will be no bug fixes...Definition TFolder.h:30; TFolder::GetListOfFoldersTCollection * GetListOfFolders() constDefinition TFolder.h:55; TFolder::Occurencevirtual Int_t Occurence(const TObject *obj) constReturn occurence number of object in the list of objects of this folder.Definition TFolder.cxx:427; TFolder::Classstatic TClass * Class(); TFriendElementA TFriendElement TF describes a TTree object TF in a file.Definition TFriendElement.h:33; TFriendElement::ResetUpdatedvoid ResetUpdated()Definition TFriendElement.h:68; TFriendElement::kFromChain@ kFromChainDefinition TFriendElement.h:49; TFriendElement::GetTreeNamevirtual const char * GetTreeName() constGet the actual TTree name of the friend.Definition TFriendElement.h:64; TFriendElement::GetTreevirtual TTree * GetTree()Return pointer to friend TTree.Defi",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:429121,Performance,cache,cache,429121,"llStylevoid SetHistFillStyle(Style_t styl=0)Definition TStyle.h:381; TStyle::GetHistLineWidthWidth_t GetHistLineWidth() constDefinition TStyle.h:236; TStyle::SetHistLineWidthvoid SetHistLineWidth(Width_t width=1)Definition TStyle.h:383; TSubStringA zero length substring is legal.Definition TString.h:85; TSubString::StringTString & String()Definition TString.h:124; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeCacheUnzipA TTreeCache which exploits parallelized decompression of its own content.Definition TTreeCacheUnzip.h:35; TTreeCacheUnzip::IsParallelUnzipstatic bool IsParallelUnzip()Static function that tells wether the multithreading unzipping is activated.Definition TTreeCacheUnzip.cxx:416; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::IsAutoCreatedbool IsAutoCreated() constDefinition TTreeCache.h:150; TTreeCache::SetBufferSizeInt_t SetBufferSize(Long64_t buffersize) overrideChange the underlying buffer size of the cache.Definition TTreeCache.cxx:2073; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2145; TTreeCache::GetTreeTTree * GetTree() constDefinition TTreeCache.h:149; TTreeCache::SetEntryRangevirtual void SetEntryRange(Long64_t emin, Long64_t emax)Set the minimum and maximum entry number to be processed this information helps to optimize the numbe...Definition TTreeCache.cxx:2106; TTreeCache::DropBranchvirtual Int_t DropBranch(TBranch *b, bool subbranches=false)Remove a branch to the list of branches to be stored in the cache this function is called by TBranch:...Definition TTreeCache.cxx:541",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:429391,Performance,cache,cache,429391,"th_t width=1)Definition TStyle.h:383; TSubStringA zero length substring is legal.Definition TString.h:85; TSubString::StringTString & String()Definition TString.h:124; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeCacheUnzipA TTreeCache which exploits parallelized decompression of its own content.Definition TTreeCacheUnzip.h:35; TTreeCacheUnzip::IsParallelUnzipstatic bool IsParallelUnzip()Static function that tells wether the multithreading unzipping is activated.Definition TTreeCacheUnzip.cxx:416; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::IsAutoCreatedbool IsAutoCreated() constDefinition TTreeCache.h:150; TTreeCache::SetBufferSizeInt_t SetBufferSize(Long64_t buffersize) overrideChange the underlying buffer size of the cache.Definition TTreeCache.cxx:2073; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2145; TTreeCache::GetTreeTTree * GetTree() constDefinition TTreeCache.h:149; TTreeCache::SetEntryRangevirtual void SetEntryRange(Long64_t emin, Long64_t emax)Set the minimum and maximum entry number to be processed this information helps to optimize the numbe...Definition TTreeCache.cxx:2106; TTreeCache::DropBranchvirtual Int_t DropBranch(TBranch *b, bool subbranches=false)Remove a branch to the list of branches to be stored in the cache this function is called by TBranch:...Definition TTreeCache.cxx:541; TTreeCache::SetAutoCreatedvoid SetAutoCreated(bool val)Definition TTreeCache.h:164; TTreeCache::StopLearningPhasevirtual void StopLearningPhase()This is the counterpart of StartLearningPhase() and ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:429866,Performance,optimiz,optimize,429866,"ition TSystem.cxx:1296; TTreeCacheUnzipA TTreeCache which exploits parallelized decompression of its own content.Definition TTreeCacheUnzip.h:35; TTreeCacheUnzip::IsParallelUnzipstatic bool IsParallelUnzip()Static function that tells wether the multithreading unzipping is activated.Definition TTreeCacheUnzip.cxx:416; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::IsAutoCreatedbool IsAutoCreated() constDefinition TTreeCache.h:150; TTreeCache::SetBufferSizeInt_t SetBufferSize(Long64_t buffersize) overrideChange the underlying buffer size of the cache.Definition TTreeCache.cxx:2073; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2145; TTreeCache::GetTreeTTree * GetTree() constDefinition TTreeCache.h:149; TTreeCache::SetEntryRangevirtual void SetEntryRange(Long64_t emin, Long64_t emax)Set the minimum and maximum entry number to be processed this information helps to optimize the numbe...Definition TTreeCache.cxx:2106; TTreeCache::DropBranchvirtual Int_t DropBranch(TBranch *b, bool subbranches=false)Remove a branch to the list of branches to be stored in the cache this function is called by TBranch:...Definition TTreeCache.cxx:541; TTreeCache::SetAutoCreatedvoid SetAutoCreated(bool val)Definition TTreeCache.h:164; TTreeCache::StopLearningPhasevirtual void StopLearningPhase()This is the counterpart of StartLearningPhase() and can be used to stop the learning phase.Definition TTreeCache.cxx:2187; TTreeCache::Printvoid Print(Option_t *option="""") const overridePrint cache statistics.Definition TTreeCache.cxx:1899; TTreeCache::AddBranchInt_t AddBranch(TBranch *b, bool subgbranches=false) overrideAdd a branch to the list of branches to be stored in the cache this function is called by the user vi...Definition TTreeCache.cxx:376; TTreeClonerClass implementing or helping the variou",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:430061,Performance,cache,cache,430061,"nction that tells wether the multithreading unzipping is activated.Definition TTreeCacheUnzip.cxx:416; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::IsAutoCreatedbool IsAutoCreated() constDefinition TTreeCache.h:150; TTreeCache::SetBufferSizeInt_t SetBufferSize(Long64_t buffersize) overrideChange the underlying buffer size of the cache.Definition TTreeCache.cxx:2073; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2145; TTreeCache::GetTreeTTree * GetTree() constDefinition TTreeCache.h:149; TTreeCache::SetEntryRangevirtual void SetEntryRange(Long64_t emin, Long64_t emax)Set the minimum and maximum entry number to be processed this information helps to optimize the numbe...Definition TTreeCache.cxx:2106; TTreeCache::DropBranchvirtual Int_t DropBranch(TBranch *b, bool subbranches=false)Remove a branch to the list of branches to be stored in the cache this function is called by TBranch:...Definition TTreeCache.cxx:541; TTreeCache::SetAutoCreatedvoid SetAutoCreated(bool val)Definition TTreeCache.h:164; TTreeCache::StopLearningPhasevirtual void StopLearningPhase()This is the counterpart of StartLearningPhase() and can be used to stop the learning phase.Definition TTreeCache.cxx:2187; TTreeCache::Printvoid Print(Option_t *option="""") const overridePrint cache statistics.Definition TTreeCache.cxx:1899; TTreeCache::AddBranchInt_t AddBranch(TBranch *b, bool subgbranches=false) overrideAdd a branch to the list of branches to be stored in the cache this function is called by the user vi...Definition TTreeCache.cxx:376; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeCloner::kNoWarnings@ kNoWarningsDefinition TTreeCloner.h:100; TTreeCloner::GetWarningconst char * GetWarning() constDefinition TTreeCloner.h:117; TTreeCloner::",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:430473,Performance,cache,cache,430473,"etLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2145; TTreeCache::GetTreeTTree * GetTree() constDefinition TTreeCache.h:149; TTreeCache::SetEntryRangevirtual void SetEntryRange(Long64_t emin, Long64_t emax)Set the minimum and maximum entry number to be processed this information helps to optimize the numbe...Definition TTreeCache.cxx:2106; TTreeCache::DropBranchvirtual Int_t DropBranch(TBranch *b, bool subbranches=false)Remove a branch to the list of branches to be stored in the cache this function is called by TBranch:...Definition TTreeCache.cxx:541; TTreeCache::SetAutoCreatedvoid SetAutoCreated(bool val)Definition TTreeCache.h:164; TTreeCache::StopLearningPhasevirtual void StopLearningPhase()This is the counterpart of StartLearningPhase() and can be used to stop the learning phase.Definition TTreeCache.cxx:2187; TTreeCache::Printvoid Print(Option_t *option="""") const overridePrint cache statistics.Definition TTreeCache.cxx:1899; TTreeCache::AddBranchInt_t AddBranch(TBranch *b, bool subgbranches=false) overrideAdd a branch to the list of branches to be stored in the cache this function is called by the user vi...Definition TTreeCache.cxx:376; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeCloner::kNoWarnings@ kNoWarningsDefinition TTreeCloner.h:100; TTreeCloner::GetWarningconst char * GetWarning() constDefinition TTreeCloner.h:117; TTreeCloner::Execbool Exec()Execute the cloning.Definition TTreeCloner.cxx:222; TTreeCloner::NeedConversionbool NeedConversion()Definition TTreeCloner.h:121; TTreeCloner::IsValidbool IsValid()Definition TTreeCloner.h:120; TTreeCloner::SetCacheSizevoid SetCacheSize(Long64_t size)Set the cache size used by the matching TFile.Definition TTreeCloner.cxx:656; TTreeFriendLeafIterIterator on all the leaves in a TTree and its friend.Definition TTree.h:7",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:430661,Performance,cache,cache,430661," TTreeCache.cxx:2145; TTreeCache::GetTreeTTree * GetTree() constDefinition TTreeCache.h:149; TTreeCache::SetEntryRangevirtual void SetEntryRange(Long64_t emin, Long64_t emax)Set the minimum and maximum entry number to be processed this information helps to optimize the numbe...Definition TTreeCache.cxx:2106; TTreeCache::DropBranchvirtual Int_t DropBranch(TBranch *b, bool subbranches=false)Remove a branch to the list of branches to be stored in the cache this function is called by TBranch:...Definition TTreeCache.cxx:541; TTreeCache::SetAutoCreatedvoid SetAutoCreated(bool val)Definition TTreeCache.h:164; TTreeCache::StopLearningPhasevirtual void StopLearningPhase()This is the counterpart of StartLearningPhase() and can be used to stop the learning phase.Definition TTreeCache.cxx:2187; TTreeCache::Printvoid Print(Option_t *option="""") const overridePrint cache statistics.Definition TTreeCache.cxx:1899; TTreeCache::AddBranchInt_t AddBranch(TBranch *b, bool subgbranches=false) overrideAdd a branch to the list of branches to be stored in the cache this function is called by the user vi...Definition TTreeCache.cxx:376; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeCloner::kNoWarnings@ kNoWarningsDefinition TTreeCloner.h:100; TTreeCloner::GetWarningconst char * GetWarning() constDefinition TTreeCloner.h:117; TTreeCloner::Execbool Exec()Execute the cloning.Definition TTreeCloner.cxx:222; TTreeCloner::NeedConversionbool NeedConversion()Definition TTreeCloner.h:121; TTreeCloner::IsValidbool IsValid()Definition TTreeCloner.h:120; TTreeCloner::SetCacheSizevoid SetCacheSize(Long64_t size)Set the cache size used by the matching TFile.Definition TTreeCloner.cxx:656; TTreeFriendLeafIterIterator on all the leaves in a TTree and its friend.Definition TTree.h:716; TTreeFriendLeafIter::fTreeTTree * fTreetree being iteratedDefinition TTree.h:719; TTreeFriendLeafIter::operator=TIterator & operator=(const TIterator &rhs) overrid",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:431280,Performance,cache,cache,431280,"topLearningPhase()This is the counterpart of StartLearningPhase() and can be used to stop the learning phase.Definition TTreeCache.cxx:2187; TTreeCache::Printvoid Print(Option_t *option="""") const overridePrint cache statistics.Definition TTreeCache.cxx:1899; TTreeCache::AddBranchInt_t AddBranch(TBranch *b, bool subgbranches=false) overrideAdd a branch to the list of branches to be stored in the cache this function is called by the user vi...Definition TTreeCache.cxx:376; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeCloner::kNoWarnings@ kNoWarningsDefinition TTreeCloner.h:100; TTreeCloner::GetWarningconst char * GetWarning() constDefinition TTreeCloner.h:117; TTreeCloner::Execbool Exec()Execute the cloning.Definition TTreeCloner.cxx:222; TTreeCloner::NeedConversionbool NeedConversion()Definition TTreeCloner.h:121; TTreeCloner::IsValidbool IsValid()Definition TTreeCloner.h:120; TTreeCloner::SetCacheSizevoid SetCacheSize(Long64_t size)Set the cache size used by the matching TFile.Definition TTreeCloner.cxx:656; TTreeFriendLeafIterIterator on all the leaves in a TTree and its friend.Definition TTree.h:716; TTreeFriendLeafIter::fTreeTTree * fTreetree being iteratedDefinition TTree.h:719; TTreeFriendLeafIter::operator=TIterator & operator=(const TIterator &rhs) overrideOverridden assignment operator. Does NOT copy the 'cursor' location!Definition TTree.cxx:9792; TTreeFriendLeafIter::TTreeFriendLeafIterTTreeFriendLeafIter()Definition TTree.h:724; TTreeFriendLeafIter::NextTObject * Next() overrideGo the next friend element.Definition TTree.cxx:9815; TTreeFriendLeafIter::fLeafIterTIterator * fLeafItercurrent leaf sub-iterator.Definition TTree.h:720; TTreeFriendLeafIter::GetOptionOption_t * GetOption() const overrideReturns the object option stored in the list.Definition TTree.cxx:9854; TTreeFriendLeafIter::fTreeIterTIterator * fTreeItercurrent tree sub-iterator.Definition TTree.h:721; TTreeFriendLeafIter::fDirect",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:435679,Performance,multi-thread,multi-threading,435679,"l.Definition TTree.cxx:2652; TTree::FindBranchvirtual TBranch * FindBranch(const char *name)Return the branch that correspond to the path 'branchname', which can include the name of the tree or...Definition TTree.cxx:4841; TTree::SetBranchStatusvirtual void SetBranchStatus(const char *bname, bool status=true, UInt_t *found=nullptr)Set branch status to Process or DoNotProcess.Definition TTree.cxx:8534; TTree::EnableCachebool EnableCache()Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0).Definition TTree.cxx:2685; TTree::GetBranchvirtual TBranch * GetBranch(const char *name)Return pointer to the branch with the given name in this tree or its friends.Definition TTree.cxx:5294; TTree::GetBranchStylestatic Int_t GetBranchStyle()Static function returning the current branch style.Definition TTree.cxx:5395; TTree::fFriendsTList * fFriendspointer to list of friend elementsDefinition TTree.h:130; TTree::fIMTEnabledbool fIMTEnabled! true if implicit multi-threading is enabled for this treeDefinition TTree.h:142; TTree::GetBranchStatusvirtual bool GetBranchStatus(const char *branchname) constReturn status of branch with name branchname.Definition TTree.cxx:5380; TTree::fFriendLockStatusUInt_t fFriendLockStatus! Record which method is locking the friend recursionDefinition TTree.h:137; TTree::GetLeafImplvirtual TLeaf * GetLeafImpl(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6098; TTree::fTotBytesLong64_t fTotBytesTotal number of bytes in all branches before compression.Definition TTree.h:86; TTree::FlushBasketsvirtual Int_t FlushBaskets(bool create_cluster=true) constWrite to disk all the basket that have not yet been individually written and create an event cluster ...Definition TTree.cxx:5129; TTree::fMaxClusterRangeInt_t fMaxClusterRange! Memory allocated for the cluster range.Definition TTree.h:96; TTree",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:437068,Performance,cache,cache,437068,"lvirtual TLeaf * GetLeafImpl(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6098; TTree::fTotBytesLong64_t fTotBytesTotal number of bytes in all branches before compression.Definition TTree.h:86; TTree::FlushBasketsvirtual Int_t FlushBaskets(bool create_cluster=true) constWrite to disk all the basket that have not yet been individually written and create an event cluster ...Definition TTree.cxx:5129; TTree::fMaxClusterRangeInt_t fMaxClusterRange! Memory allocated for the cluster range.Definition TTree.h:96; TTree::Showvirtual void Show(Long64_t entry=-1, Int_t lenmax=20)Print values of all active leaves for entry.Definition TTree.cxx:9385; TTree::fEventListTEventList * fEventList! Pointer to event selection list (if one)Definition TTree.h:125; TTree::GetAutoSavevirtual Long64_t GetAutoSave() constDefinition TTree.h:448; TTree::StopCacheLearningPhasevirtual Int_t StopCacheLearningPhase()Stop the cache learning phase.Definition TTree.cxx:9474; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::fSortedBranchesstd::vector< std::pair< Long64_t, TBranch * > > fSortedBranches! Branches to be processed in parallel when IMT is on, sorted by average task timeDefinition TTree.h:144; TTree::SetCircularvirtual void SetCircular(Long64_t maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTree::fSavedBytesLong64_t fSavedBytesNumber of autosaved bytes.Definition TTree.h:88; TTree::AddBranchToCachevirtual Int_t AddBranchToCache(const char *bname, bool subbranches=false)Add branch with name bname to the Tree cache.Definition TTree.cxx:1059; TTree::GetMedianClusterSizeLong64_t GetMedianClusterSize()Estimate the median cluster size for the TTree.Definition TTree.cxx:8297; TTree::GetClusterIteratorvirtual TClusterIterator G",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:437821,Performance,cache,cache,437821,"all active leaves for entry.Definition TTree.cxx:9385; TTree::fEventListTEventList * fEventList! Pointer to event selection list (if one)Definition TTree.h:125; TTree::GetAutoSavevirtual Long64_t GetAutoSave() constDefinition TTree.h:448; TTree::StopCacheLearningPhasevirtual Int_t StopCacheLearningPhase()Stop the cache learning phase.Definition TTree.cxx:9474; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::fSortedBranchesstd::vector< std::pair< Long64_t, TBranch * > > fSortedBranches! Branches to be processed in parallel when IMT is on, sorted by average task timeDefinition TTree.h:144; TTree::SetCircularvirtual void SetCircular(Long64_t maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTree::fSavedBytesLong64_t fSavedBytesNumber of autosaved bytes.Definition TTree.h:88; TTree::AddBranchToCachevirtual Int_t AddBranchToCache(const char *bname, bool subbranches=false)Add branch with name bname to the Tree cache.Definition TTree.cxx:1059; TTree::GetMedianClusterSizeLong64_t GetMedianClusterSize()Estimate the median cluster size for the TTree.Definition TTree.cxx:8297; TTree::GetClusterIteratorvirtual TClusterIterator GetClusterIterator(Long64_t firstentry)Return an iterator over the cluster of baskets starting at firstentry.Definition TTree.cxx:5467; TTree::ResetBranchAddressvirtual void ResetBranchAddress(TBranch *)Tell all of our branches to set their addresses to zero.Definition TTree.cxx:8065; TTree::fCacheUserSetbool fCacheUserSet! true if the cache setting was explicitly given by userDefinition TTree.h:141; TTree::GetNewlineValuechar GetNewlineValue(std::istream &inputStream)Determine which newline this file is using.Definition TTree.cxx:7588; TTree::fIOFeaturesTIOFeatures fIOFeaturesIO features to define for newly-written baskets and branches.Definition TTree.h:114; TTree::GetEntryNumberWithIndexvirtual Long64_t Ge",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:438374,Performance,cache,cache,438374," to be processed in parallel when IMT is on, sorted by average task timeDefinition TTree.h:144; TTree::SetCircularvirtual void SetCircular(Long64_t maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTree::fSavedBytesLong64_t fSavedBytesNumber of autosaved bytes.Definition TTree.h:88; TTree::AddBranchToCachevirtual Int_t AddBranchToCache(const char *bname, bool subbranches=false)Add branch with name bname to the Tree cache.Definition TTree.cxx:1059; TTree::GetMedianClusterSizeLong64_t GetMedianClusterSize()Estimate the median cluster size for the TTree.Definition TTree.cxx:8297; TTree::GetClusterIteratorvirtual TClusterIterator GetClusterIterator(Long64_t firstentry)Return an iterator over the cluster of baskets starting at firstentry.Definition TTree.cxx:5467; TTree::ResetBranchAddressvirtual void ResetBranchAddress(TBranch *)Tell all of our branches to set their addresses to zero.Definition TTree.cxx:8065; TTree::fCacheUserSetbool fCacheUserSet! true if the cache setting was explicitly given by userDefinition TTree.h:141; TTree::GetNewlineValuechar GetNewlineValue(std::istream &inputStream)Determine which newline this file is using.Definition TTree.cxx:7588; TTree::fIOFeaturesTIOFeatures fIOFeaturesIO features to define for newly-written baskets and branches.Definition TTree.h:114; TTree::GetEntryNumberWithIndexvirtual Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor=0) constReturn entry number corresponding to major and minor number.Definition TTree.cxx:5910; TTree::fDebugMinLong64_t fDebugMin! First entry number to debugDefinition TTree.h:112; TTree::SetEntriesvirtual Long64_t SetEntries(Long64_t n=-1)Change number of entries in the tree.Definition TTree.cxx:9011; TTree::GetListOfLeavesvirtual TObjArray * GetListOfLeaves()Definition TTree.h:529; TTree::BranchOldvirtual TBranch * BranchOld(const char *name, const char *classname, void *addobj, Int_t bufsize=32000, Int_t splitlevel=1)Create a new TTree BranchObject.Definit",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:439498,Performance,cache,cache,439498,"ee::GetNewlineValuechar GetNewlineValue(std::istream &inputStream)Determine which newline this file is using.Definition TTree.cxx:7588; TTree::fIOFeaturesTIOFeatures fIOFeaturesIO features to define for newly-written baskets and branches.Definition TTree.h:114; TTree::GetEntryNumberWithIndexvirtual Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor=0) constReturn entry number corresponding to major and minor number.Definition TTree.cxx:5910; TTree::fDebugMinLong64_t fDebugMin! First entry number to debugDefinition TTree.h:112; TTree::SetEntriesvirtual Long64_t SetEntries(Long64_t n=-1)Change number of entries in the tree.Definition TTree.cxx:9011; TTree::GetListOfLeavesvirtual TObjArray * GetListOfLeaves()Definition TTree.h:529; TTree::BranchOldvirtual TBranch * BranchOld(const char *name, const char *classname, void *addobj, Int_t bufsize=32000, Int_t splitlevel=1)Create a new TTree BranchObject.Definition TTree.cxx:2074; TTree::GetCacheAutoSizeLong64_t GetCacheAutoSize(bool withDefault=false)Used for automatic sizing of the cache.Definition TTree.cxx:5407; TTree::BranchRefvirtual TBranch * BranchRef()Build the optional branch supporting the TRefTable.Definition TTree.cxx:2328; TTree::GetCurrentFileTFile * GetCurrentFile() constReturn pointer to the current file.Definition TTree.cxx:5479; TTree::fAliasesTList * fAliasesList of aliases for expressions based on the tree branches.Definition TTree.h:124; TTree::CopyTreevirtual TTree * CopyTree(const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Copy a tree with selection.Definition TTree.cxx:3719; TTree::DropBranchFromCachevirtual Int_t DropBranchFromCache(const char *bname, bool subbranches=false)Remove the branch with name 'bname' from the Tree cache.Definition TTree.cxx:1142; TTree::Fitvirtual Int_t Fit(const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Option_t *goption="""", Long64_t nentries=kMaxEntries, Long64_t firstent",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:440224,Performance,cache,cache,440224,"Array * GetListOfLeaves()Definition TTree.h:529; TTree::BranchOldvirtual TBranch * BranchOld(const char *name, const char *classname, void *addobj, Int_t bufsize=32000, Int_t splitlevel=1)Create a new TTree BranchObject.Definition TTree.cxx:2074; TTree::GetCacheAutoSizeLong64_t GetCacheAutoSize(bool withDefault=false)Used for automatic sizing of the cache.Definition TTree.cxx:5407; TTree::BranchRefvirtual TBranch * BranchRef()Build the optional branch supporting the TRefTable.Definition TTree.cxx:2328; TTree::GetCurrentFileTFile * GetCurrentFile() constReturn pointer to the current file.Definition TTree.cxx:5479; TTree::fAliasesTList * fAliasesList of aliases for expressions based on the tree branches.Definition TTree.h:124; TTree::CopyTreevirtual TTree * CopyTree(const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Copy a tree with selection.Definition TTree.cxx:3719; TTree::DropBranchFromCachevirtual Int_t DropBranchFromCache(const char *bname, bool subbranches=false)Remove the branch with name 'bname' from the Tree cache.Definition TTree.cxx:1142; TTree::Fitvirtual Int_t Fit(const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Option_t *goption="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Fit a projected item(s) from a tree.Definition TTree.cxx:5079; TTree::fClusterRangeEndLong64_t * fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.Definition TTree.h:103; TTree::Streamervoid Streamer(TBuffer &) overrideStream a class object.Definition TTree.cxx:9545; TTree::fIMTZipBytesstd::atomic< Long64_t > fIMTZipBytes! Zip bytes for the IMT flush baskets.Definition TTree.h:161; TTree::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideMake sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree.Definition TTree.cxx:7881; TTree::GetPlayerTVirtualTreePlayer * GetPlayer()Load the TTreePlayer (if not already done).Definition TTree.c",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:442348,Performance,load,loaded,442348,"st char *option=nullptr, Int_t maxUnrolling=3)Generate a skeleton analysis class for this Tree using TBranchProxy.Definition TTree.cxx:6768; TTree::kSplitCollectionOfPointers@ kSplitCollectionOfPointersDefinition TTree.h:266; TTree::ReadStreamvirtual Long64_t ReadStream(std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ')Create or simply read branches from an input stream.Definition TTree.cxx:7615; TTree::SetDebugvirtual void SetDebug(Int_t level=1, Long64_t min=0, Long64_t max=9999999)Set the debug level and the debug range.Definition TTree.cxx:8928; TTree::fScanFieldInt_t fScanFieldNumber of runs before prompting in Scan.Definition TTree.h:92; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; TTree::GetFriendvirtual TTree * GetFriend(const char *) constReturn a pointer to the TTree friend whose name or alias is friendname.Definition TTree.cxx:5975; TTree::SetNotifyvirtual void SetNotify(TObject *obj)Sets the address of the object to be notified when the tree is loaded.Definition TTree.cxx:9231; TTree::GetMaximumvirtual Double_t GetMaximum(const char *columname)Return maximum of column with name columname.Definition TTree.cxx:6235; TTree::GetEntryNumberWithBestIndexvirtual Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor=0) constReturn entry number corresponding to major and minor number.Definition TTree.cxx:5890; TTree::SetMaxTreeSizestatic void SetMaxTreeSize(Long64_t maxsize=100000000000LL)Set the maximum size in bytes of a Tree file (static function).Definition TTree.cxx:9197; TTree::Printvoid Print(Option_t *option="""") const overridePrint a summary of the tree contents.Definition TTree.cxx:7219; TTree::UnbinnedFitvirtual Int_t UnbinnedFit(const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Unbinned fit of one or more variable(s) from a tree.Definition TTree.cxx:9702; TTree:",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:444657,Performance,cache,cache,444657,"e=""0"")Build a Tree Index (default is TTreeIndex).Definition TTree.cxx:2637; TTree::fPlayerTVirtualTreePlayer * fPlayer! Pointer to current Tree playerDefinition TTree.h:134; TTree::GetIteratorOnAllLeavesvirtual TIterator * GetIteratorOnAllLeaves(bool dir=kIterForward)Creates a new iterator that will go through all the leaves on the tree itself and its friend.Definition TTree.cxx:6082; TTree::SetMakeClassvirtual void SetMakeClass(Int_t make)Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode).Definition TTree.cxx:9177; TTree::InPlaceClonevirtual bool InPlaceClone(TDirectory *newdirectory, const char *options="""")Copy the content to a new new file, update this TTree with the new location information and attach th...Definition TTree.cxx:7012; TTree::fBranchesTObjArray fBranchesList of Branches.Definition TTree.h:122; TTree::GetDirectoryTDirectory * GetDirectory() constDefinition TTree.h:462; TTree::fCacheDoAutoInitbool fCacheDoAutoInit! true if cache auto creation or resize check is neededDefinition TTree.h:139; TTree::GetReadCacheTTreeCache * GetReadCache(TFile *file) constFind and return the TTreeCache registered with the file and which may contain branches for us.Definition TTree.cxx:6318; TTree::fEntriesLong64_t fEntriesNumber of entries.Definition TTree.h:84; TTree::ChangeFilevirtual TFile * ChangeFile(TFile *file)Called by TTree::Fill() when file has reached its maximum fgMaxTreeSize.Definition TTree.cxx:2749; TTree::GetEntryListvirtual TEntryList * GetEntryList()Returns the entry list assigned to this tree.Definition TTree.cxx:5854; TTree::SetWeightvirtual void SetWeight(Double_t w=1, Option_t *option="""")Set tree weight.Definition TTree.cxx:9374; TTree::InitializeBranchListsvoid InitializeBranchLists(bool checkLeafCount)Divides the top-level branches into two vectors: (i) branches to be processed sequentially and (ii) b...Definition TTree.cxx:5781; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname,",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:448809,Performance,cache,cache,448809,"ge task time recorded per branch.Definition TTree.cxx:5834; TTree::Deletevoid Delete(Option_t *option="""") overrideDelete this tree from memory or/and disk.Definition TTree.cxx:3747; TTree::GetBranchRefvirtual TBranchRef * GetBranchRef() constDefinition TTree.h:450; TTree::Processvirtual Long64_t Process(const char *filename, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Process this tree executing the TSelector code in the specified filename.Definition TTree.cxx:7450; TTree::BranchImpRefvirtual TBranch * BranchImpRef(const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel)Same as TTree::Branch but automatic detection of the class name.Definition TTree.cxx:1635; TTree::SetEventListvirtual void SetEventList(TEventList *list)This function transfroms the given TEventList into a TEntryList The new TEntryList is owned by the TT...Definition TTree.cxx:9069; TTree::MoveReadCachevoid MoveReadCache(TFile *src, TDirectory *dir)Move a cache from a file to the current file in dir.Definition TTree.cxx:6983; TTree::fAutoFlushLong64_t fAutoFlushAuto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced.Definition TTree.h:101; TTree::fUpdateInt_t fUpdateUpdate frequency for EntryLoop.Definition TTree.h:93; TTree::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Resets the state of this TTree after a merge (keep the customization but forget the data).Definition TTree.cxx:8034; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::SetEstimatevirtual void SetEstimate(Long64_t nentries=1000000)Set number of entries to estimate variable limits.Definition TTree.cxx:9110; TTree::fTimerIntervalInt_t fTimerIntervalTimer interval in milliseconds.Definition TTree.h:91; TTree::fDebugInt_t fDebug! Debug levelDefinition TTree.h:111; TTree::SetCacheSizeAuxInt_t SetCacheSizeAux(bool autocache=true, Long64_t cacheSize=0)Set the size of the file ca",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:449751,Performance,cache,cacheSize,449751,"eReadCachevoid MoveReadCache(TFile *src, TDirectory *dir)Move a cache from a file to the current file in dir.Definition TTree.cxx:6983; TTree::fAutoFlushLong64_t fAutoFlushAuto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced.Definition TTree.h:101; TTree::fUpdateInt_t fUpdateUpdate frequency for EntryLoop.Definition TTree.h:93; TTree::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Resets the state of this TTree after a merge (keep the customization but forget the data).Definition TTree.cxx:8034; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::SetEstimatevirtual void SetEstimate(Long64_t nentries=1000000)Set number of entries to estimate variable limits.Definition TTree.cxx:9110; TTree::fTimerIntervalInt_t fTimerIntervalTimer interval in milliseconds.Definition TTree.h:91; TTree::fDebugInt_t fDebug! Debug levelDefinition TTree.h:111; TTree::SetCacheSizeAuxInt_t SetCacheSizeAux(bool autocache=true, Long64_t cacheSize=0)Set the size of the file cache and create it if possible.Definition TTree.cxx:8711; TTree::AutoSavevirtual Long64_t AutoSave(Option_t *option="""")AutoSave tree header every fAutoSave bytes.Definition TTree.cxx:1500; TTree::GetEntryNumbervirtual Long64_t GetEntryNumber(Long64_t entry) constReturn entry number corresponding to entry.Definition TTree.cxx:5865; TTree::CloneTreevirtual TTree * CloneTree(Long64_t nentries=-1, Option_t *option="""")Create a clone of this tree and copy nentries.Definition TTree.cxx:3139; TTree::fFileNumberInt_t fFileNumber! current file number (if file extensions)Definition TTree.h:116; TTree::GetLeafvirtual TLeaf * GetLeaf(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6195; TTree::GetZipBytesvirtual Long64_t GetZipBytes() constDefinition TTree.h:585; TTree::fLeavesTObjArray fLeavesDirect pointers to individual branch leave",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:449788,Performance,cache,cache,449788,"eReadCachevoid MoveReadCache(TFile *src, TDirectory *dir)Move a cache from a file to the current file in dir.Definition TTree.cxx:6983; TTree::fAutoFlushLong64_t fAutoFlushAuto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced.Definition TTree.h:101; TTree::fUpdateInt_t fUpdateUpdate frequency for EntryLoop.Definition TTree.h:93; TTree::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Resets the state of this TTree after a merge (keep the customization but forget the data).Definition TTree.cxx:8034; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::SetEstimatevirtual void SetEstimate(Long64_t nentries=1000000)Set number of entries to estimate variable limits.Definition TTree.cxx:9110; TTree::fTimerIntervalInt_t fTimerIntervalTimer interval in milliseconds.Definition TTree.h:91; TTree::fDebugInt_t fDebug! Debug levelDefinition TTree.h:111; TTree::SetCacheSizeAuxInt_t SetCacheSizeAux(bool autocache=true, Long64_t cacheSize=0)Set the size of the file cache and create it if possible.Definition TTree.cxx:8711; TTree::AutoSavevirtual Long64_t AutoSave(Option_t *option="""")AutoSave tree header every fAutoSave bytes.Definition TTree.cxx:1500; TTree::GetEntryNumbervirtual Long64_t GetEntryNumber(Long64_t entry) constReturn entry number corresponding to entry.Definition TTree.cxx:5865; TTree::CloneTreevirtual TTree * CloneTree(Long64_t nentries=-1, Option_t *option="""")Create a clone of this tree and copy nentries.Definition TTree.cxx:3139; TTree::fFileNumberInt_t fFileNumber! current file number (if file extensions)Definition TTree.h:116; TTree::GetLeafvirtual TLeaf * GetLeaf(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6195; TTree::GetZipBytesvirtual Long64_t GetZipBytes() constDefinition TTree.h:585; TTree::fLeavesTObjArray fLeavesDirect pointers to individual branch leave",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:454190,Performance,load,loading,454190,"y corresponding to major and minor number.Definition TTree.cxx:5927; TTree::MergeTreesstatic TTree * MergeTrees(TList *list, Option_t *option="""")Static function merging the trees in the TList into a new tree.Definition TTree.cxx:6851; TTree::MemoryFullbool MemoryFull(Int_t nbytes)Check if adding nbytes to memory we are still below MaxVirtualsize.Definition TTree.cxx:6837; TTree::GetReadEntryvirtual Long64_t GetReadEntry() constDefinition TTree.h:549; TTree::GetListOfBranchesvirtual TObjArray * GetListOfBranches()Definition TTree.h:528; TTree::fZipBytesLong64_t fZipBytesTotal number of bytes in all branches after compression.Definition TTree.h:87; TTree::GetTreevirtual TTree * GetTree() constDefinition TTree.h:557; TTree::fTransientBufferTBuffer * fTransientBuffer! Pointer to the current transient buffer.Definition TTree.h:138; TTree::SetEntryListvirtual void SetEntryList(TEntryList *list, Option_t *opt="""")Set an EntryList.Definition TTree.cxx:9046; TTree::Notifybool Notify() overrideFunction called when loading a new class library.Definition TTree.cxx:7033; TTree::AddZipBytesvirtual void AddZipBytes(Int_t zip)Definition TTree.h:332; TTree::LoadTreevirtual Long64_t LoadTree(Long64_t entry)Set current entry.Definition TTree.cxx:6473; TTree::ReadFilevirtual Long64_t ReadFile(const char *filename, const char *branchDescriptor="""", char delimiter=' ')Create or simply read branches from filename.Definition TTree.cxx:7564; TTree::GetAliasvirtual const char * GetAlias(const char *aliasName) constReturns the expanded value of the alias. Search in the friends if any.Definition TTree.cxx:5226; TTree::SetIOFeaturesROOT::TIOFeatures SetIOFeatures(const ROOT::TIOFeatures &)Provide the end-user with the ability to enable/disable various experimental IO features for this TTr...Definition TTree.cxx:9130; TTree::CreateBasketvirtual TBasket * CreateBasket(TBranch *)Create a basket for this tree and given branch.Definition TTree.cxx:3731; TTree::fUserInfoTList * fUserInfopointer to a li",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:458522,Performance,load,loading,458522,"ter range information stored in 'fromtree' to this tree, including the value of fAuto...Definition TTree.cxx:6372; TTree::IsATClass * IsA() const overrideDefinition TTree.h:705; TTree::fEstimateLong64_t fEstimateNumber of entries to estimate histogram limits.Definition TTree.h:102; TTree::FlushBasketsImplInt_t FlushBasketsImpl() constInternal implementation of the FlushBaskets algorithm.Definition TTree.cxx:5146; TTree::LoadTreeFriendvirtual Long64_t LoadTreeFriend(Long64_t entry, TTree *T)Load entry on behalf of our master tree, we may use an index.Definition TTree.cxx:6557; TTree::WriteInt_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0) overrideWrite this object to the current directory.Definition TTree.cxx:9753; TTree::fTreeIndexTVirtualIndex * fTreeIndexPointer to the tree Index (if any)Definition TTree.h:129; TTree::UseCurrentStylevoid UseCurrentStyle() overrideReplace current attributes by current style.Definition TTree.cxx:9714; TTree::fNotifyTObject * fNotifyObject to be notified when loading a Tree.Definition TTree.h:120; TTree::BranchImpvirtual TBranch * BranchImp(const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel)Same as TTree::Branch() with added check that addobj matches className.Definition TTree.cxx:1554; TTree::fCacheSizeLong64_t fCacheSize! Maximum size of file buffersDefinition TTree.h:105; TTree::fClonesTList * fClones! List of cloned trees which share our addressesDefinition TTree.h:135; TTree::fTotalBuffersstd::atomic< Long64_t > fTotalBuffers! Total number of bytes in branch buffersDefinition TTree.h:108; TTree::Classstatic TClass * Class(); TTree::kFindBranch@ kFindBranchDefinition TTree.h:212; TTree::kFindLeaf@ kFindLeafDefinition TTree.h:213; TTree::kGetEntryWithIndex@ kGetEntryWithIndexDefinition TTree.h:217; TTree::kPrint@ kPrintDefinition TTree.h:222; TTree::kGetFriend@ kGetFriendDefinition TTree.h:218; TTree::kGetBranch@ kGetBranchDefinition TTree.h:215; TTree:",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:460616,Performance,cache,cache,460616,"dTree@ kLoadTreeDefinition TTree.h:221; TTree::kGetEntry@ kGetEntryDefinition TTree.h:216; TTree::kGetLeaf@ kGetLeafDefinition TTree.h:220; TTree::kRemoveFriend@ kRemoveFriendDefinition TTree.h:223; TTree::kGetFriendAlias@ kGetFriendAliasDefinition TTree.h:219; TTree::kGetAlias@ kGetAliasDefinition TTree.h:214; TTree::SetTreeIndexvirtual void SetTreeIndex(TVirtualIndex *index)The current TreeIndex is replaced by the new index.Definition TTree.cxx:9346; TTree::OptimizeBasketsvirtual void OptimizeBaskets(ULong64_t maxMemory=10000000, Float_t minComp=1.1, Option_t *option="""")This function may be called after having filled some entries in a Tree.Definition TTree.cxx:7057; TTree::Projectvirtual Long64_t Project(const char *hname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Make a projection of a tree using selections.Definition TTree.cxx:7498; TTree::SetCacheEntryRangevirtual Int_t SetCacheEntryRange(Long64_t first, Long64_t last)interface to TTreeCache to set the cache entry rangeDefinition TTree.cxx:8831; TTree::GetMaxTreeSizestatic Long64_t GetMaxTreeSize()Static function which returns the tree file size limit in bytes.Definition TTree.cxx:6265; TTree::fCacheDoClusterPrefetchbool fCacheDoClusterPrefetch! true if cache is prefetching whole clustersDefinition TTree.h:140; TTree::SetBranchAddressImpInt_t SetBranchAddressImp(TBranch *branch, void *addr, TBranch **ptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8445; TTree::SetAliasvirtual bool SetAlias(const char *aliasName, const char *aliasFormula)Set a tree variable alias.Definition TTree.cxx:8141; TTree::CopyAddressesvirtual void CopyAddresses(TTree *, bool undo=false)Set branch addresses of passed tree equal to ours.Definition TTree.cxx:3299; TTree::fMaxEntriesLong64_t fMaxEntriesMaximum number of entries in case of circular buffers.Definition TTree.h:97; TTree::DropBuffersvirtual void DropBuffers(Int_t nbytes",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:460872,Performance,cache,cache,460872,"nition TTree.h:214; TTree::SetTreeIndexvirtual void SetTreeIndex(TVirtualIndex *index)The current TreeIndex is replaced by the new index.Definition TTree.cxx:9346; TTree::OptimizeBasketsvirtual void OptimizeBaskets(ULong64_t maxMemory=10000000, Float_t minComp=1.1, Option_t *option="""")This function may be called after having filled some entries in a Tree.Definition TTree.cxx:7057; TTree::Projectvirtual Long64_t Project(const char *hname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Make a projection of a tree using selections.Definition TTree.cxx:7498; TTree::SetCacheEntryRangevirtual Int_t SetCacheEntryRange(Long64_t first, Long64_t last)interface to TTreeCache to set the cache entry rangeDefinition TTree.cxx:8831; TTree::GetMaxTreeSizestatic Long64_t GetMaxTreeSize()Static function which returns the tree file size limit in bytes.Definition TTree.cxx:6265; TTree::fCacheDoClusterPrefetchbool fCacheDoClusterPrefetch! true if cache is prefetching whole clustersDefinition TTree.h:140; TTree::SetBranchAddressImpInt_t SetBranchAddressImp(TBranch *branch, void *addr, TBranch **ptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8445; TTree::SetAliasvirtual bool SetAlias(const char *aliasName, const char *aliasFormula)Set a tree variable alias.Definition TTree.cxx:8141; TTree::CopyAddressesvirtual void CopyAddresses(TTree *, bool undo=false)Set branch addresses of passed tree equal to ours.Definition TTree.cxx:3299; TTree::fMaxEntriesLong64_t fMaxEntriesMaximum number of entries in case of circular buffers.Definition TTree.h:97; TTree::DropBuffersvirtual void DropBuffers(Int_t nbytes)Drop branch buffers to accommodate nbytes below MaxVirtualsize.Definition TTree.cxx:4531; TTree::GetListOfFriendsvirtual TList * GetListOfFriends() constDefinition TTree.h:530; TTree::Refreshvirtual void Refresh()Refresh contents of this tree and its branches from the current status on disk",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:464870,Performance,cache,cachesize,464870,"e.h:239; TTree::kInternalError@ kInternalErrorDefinition TTree.h:234; TTree::kMatch@ kMatchDefinition TTree.h:238; TTree::kMissingBranch@ kMissingBranchDefinition TTree.h:233; TTree::kMakeClass@ kMakeClassDefinition TTree.h:241; TTree::fgBranchStylestatic Int_t fgBranchStyleOld/New branch style.Definition TTree.h:154; TTree::ResetBranchAddressesvirtual void ResetBranchAddresses()Tell all of our branches to drop their current objects and allocate new ones.Definition TTree.cxx:8075; TTree::fNfillInt_t fNfill! Local for EntryLoopDefinition TTree.h:110; TTree::SetNamevoid SetName(const char *name) overrideChange the name of this tree.Definition TTree.cxx:9205; TTree::RegisterExternalFriendvirtual void RegisterExternalFriend(TFriendElement *)Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is...Definition TTree.cxx:7957; TTree::fIndexTArrayI fIndexIndex of sorted values.Definition TTree.h:128; TTree::SetCacheSizevirtual Int_t SetCacheSize(Long64_t cachesize=-1)Set maximum size of the file cache .Definition TTree.cxx:8683; TTree::AddClonevoid AddClone(TTree *)Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when...Definition TTree.cxx:1219; TTree::CheckBranchAddressTypevirtual Int_t CheckBranchAddressType(TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr)Check whether or not the address described by the last 3 parameters matches the content of the branch...Definition TTree.cxx:2867; TTree::GetTransientBufferTBuffer * GetTransientBuffer(Int_t size)Returns the transient buffer currently used by this TTree for reading/writing baskets.Definition TTree.cxx:1037; TTree::GetIOFeaturesROOT::TIOFeatures GetIOFeatures() constReturns the current set of IO settings.Definition TTree.cxx:6074; TTree::MakeClassvirtual Int_t MakeClass(const char *classname=nullptr, Option_t *option="""")Generate a skeleton analysis class for this tree.Definition TTree.cxx:6607; TTree::GetFriendAli",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:464912,Performance,cache,cache,464912,"e.h:239; TTree::kInternalError@ kInternalErrorDefinition TTree.h:234; TTree::kMatch@ kMatchDefinition TTree.h:238; TTree::kMissingBranch@ kMissingBranchDefinition TTree.h:233; TTree::kMakeClass@ kMakeClassDefinition TTree.h:241; TTree::fgBranchStylestatic Int_t fgBranchStyleOld/New branch style.Definition TTree.h:154; TTree::ResetBranchAddressesvirtual void ResetBranchAddresses()Tell all of our branches to drop their current objects and allocate new ones.Definition TTree.cxx:8075; TTree::fNfillInt_t fNfill! Local for EntryLoopDefinition TTree.h:110; TTree::SetNamevoid SetName(const char *name) overrideChange the name of this tree.Definition TTree.cxx:9205; TTree::RegisterExternalFriendvirtual void RegisterExternalFriend(TFriendElement *)Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is...Definition TTree.cxx:7957; TTree::fIndexTArrayI fIndexIndex of sorted values.Definition TTree.h:128; TTree::SetCacheSizevirtual Int_t SetCacheSize(Long64_t cachesize=-1)Set maximum size of the file cache .Definition TTree.cxx:8683; TTree::AddClonevoid AddClone(TTree *)Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when...Definition TTree.cxx:1219; TTree::CheckBranchAddressTypevirtual Int_t CheckBranchAddressType(TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr)Check whether or not the address described by the last 3 parameters matches the content of the branch...Definition TTree.cxx:2867; TTree::GetTransientBufferTBuffer * GetTransientBuffer(Int_t size)Returns the transient buffer currently used by this TTree for reading/writing baskets.Definition TTree.cxx:1037; TTree::GetIOFeaturesROOT::TIOFeatures GetIOFeatures() constReturns the current set of IO settings.Definition TTree.cxx:6074; TTree::MakeClassvirtual Int_t MakeClass(const char *classname=nullptr, Option_t *option="""")Generate a skeleton analysis class for this tree.Definition TTree.cxx:6607; TTree::GetFriendAli",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:469439,Performance,perform,performance,469439,"lCollectionProxy.h:52; TVirtualCollectionProxy::GetTypevirtual EDataType GetType() const =0If the value type is a fundamental data type, return its type (see enumeration EDataType).; TVirtualCollectionProxy::GetValueClassvirtual TClass * GetValueClass() const =0If the value type is a user-defined class, return a pointer to the TClass representing the value type...; TVirtualCollectionProxy::HasPointersvirtual Bool_t HasPointers() const =0Return true if the content is of type 'pointer to'.; TVirtualIndexAbstract interface for Tree Index.Definition TVirtualIndex.h:30; TVirtualIndex::GetMajorNamevirtual const char * GetMajorName() const =0; TVirtualIndex::GetEntryNumberWithIndexvirtual Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const =0; TVirtualIndex::GetEntryNumberFriendvirtual Long64_t GetEntryNumberFriend(const TTree *)=0; TVirtualIndex::Appendvirtual void Append(const TVirtualIndex *, bool delaySort=false)=0; TVirtualIndex::GetMinorNamevirtual const char * GetMinorName() const =0; TVirtualIndex::SetTreevirtual void SetTree(TTree *T)=0; TVirtualIndex::GetNvirtual Long64_t GetN() const =0; TVirtualIndex::IsValidForvirtual bool IsValidFor(const TTree *parent)=0; TVirtualIndex::GetEntryNumberWithBestIndexvirtual Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const =0; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; TVirtualTreePlayerAbstract base class defining the interface for the plugins that implement Draw, Scan,...Definition TVirtualTreePlayer.h:38; TVirtualTreePlayer::Scanvirtual Long64_t Scan(const char *varexp, const char *selection, Option_t *option, Long64_t nentries, Long64_t firstentry)=0; TVirtualTreePlayer::UpdateFormulaLeavesvirtual void UpdateFormulaLeaves()=0; TVirtualTreePlayer::DrawSelectvirtual Long64_t DrawSelect(const char *varexp, const char *selection, Option_t *option, Long64_t nentries, Long64_t firstentry)=0; ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:472552,Performance,multi-thread,multi-threading,472552,"ntry=0)=0; TVirtualTreePlayer::SetEstimatevirtual void SetEstimate(Long64_t n)=0; TVirtualTreePlayer::TreePlayerstatic TVirtualTreePlayer * TreePlayer(TTree *obj)Static function returning a pointer to a Tree player.Definition TVirtualTreePlayer.cxx:35; TVirtualTreePlayer::MakeClassvirtual Int_t MakeClass(const char *classname, const char *option)=0; TVirtualTreePlayer::Fitvirtual Int_t Fit(const char *formula, const char *varexp, const char *selection, Option_t *option, Option_t *goption, Long64_t nentries, Long64_t firstentry)=0; double; int; unsigned int; lineTLine * lineDefinition entrylistblock_figure1.C:235; nconst Int_t nDefinition legend1.C:16; ROOT::DetailSpecial implementation of ROOT::RRangeCast for TCollection, including a check that the cast target ty...Definition TObject.h:387; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::ESTLTypeESTLTypeDefinition ESTLType.h:28; ROOT::kSTLmap@ kSTLmapDefinition ESTLType.h:33; ROOT::kSTLmultimap@ kSTLmultimapDefinition ESTLType.h:34; ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; ROOT::ToHumanReadableSizevoid ToHumanReadableSize(value_type bytes, Bool_t si, Double_t *coeff, const char **units)Return the size expressed in 'human readable' format.Definition StringConv.hxx:38; ROOT::FromHumanReadableSizeEFromHumanReadableSize FromHumanReadableSize(std::string_view str, T &value)Convert strings like the following into byte counts 5MB, 5 MB, 5M, 3.7GB, 123b, 456kB,...Definition StringConv.hxx:86; ROOT::EFromHumanReadableSize::kParseFail@ kParseFail; ROOT::EFromHumanReadableSize::kOverflow@ kOverflow; TMath::MaxShort_t Max(Short_t a, Short_t b)R",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:13928,Safety,detect,detector,13928,"OOT offers the concept of friends for TTree and TChain:; 266if is good practice to rely on friend trees rather than adding a branch manually.; 267 ; 268\anchor fullexample; 269## An Example; 270 ; 271Begin_Macro; 272../../../tutorials/tree/tree.C; 273End_Macro; 274 ; 275~~~ {.cpp}; 276 // A simple example with histograms and a tree; 277 //; 278 // This program creates :; 279 // - a one dimensional histogram; 280 // - a two dimensional histogram; 281 // - a profile histogram; 282 // - a tree; 283 //; 284 // These objects are filled with some random numbers and saved on a file.; 285 ; 286 #include ""TFile.h""; 287 #include ""TH1.h""; 288 #include ""TH2.h""; 289 #include ""TProfile.h""; 290 #include ""TRandom.h""; 291 #include ""TTree.h""; 292 ; 293 //__________________________________________________________________________; 294 main(int argc, char **argv); 295 {; 296 // Create a new ROOT binary machine independent file.; 297 // Note that this file may contain any kind of ROOT objects, histograms,trees; 298 // pictures, graphics objects, detector geometries, tracks, events, etc..; 299 // This file is now becoming the current directory.; 300 TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");; 301 ; 302 // Create some histograms and a profile histogram; 303 TH1F hpx(""hpx"",""This is the px distribution"",100,-4,4);; 304 TH2F hpxpy(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; 305 TProfile hprof(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; 306 ; 307 // Define some simple structures; 308 typedef struct {Float_t x,y,z;} POINT;; 309 typedef struct {; 310 Int_t ntrack,nseg,nvertex;; 311 UInt_t flag;; 312 Float_t temperature;; 313 } EVENTN;; 314 POINT point;; 315 EVENTN eventn;; 316 ; 317 // Create a ROOT Tree; 318 TTree tree(""T"",""An example of ROOT tree with a few branches"");; 319 tree.Branch(""point"",&point,""x:y:z"");; 320 tree.Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; 321 tree.Branch(""hpx"",""TH1F"",&hpx,128000,0);; 322 ; 323 Float_t px,p",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:34084,Safety,avoid,avoid,34084,"if (strlen(title) > 2) {; 912 if (title[0] == '/') {; 913 Branch(title+1,32000,splitlevel);; 914 }; 915 }; 916}; 917 ; 918////////////////////////////////////////////////////////////////////////////////; 919/// Destructor.; 920 ; 921TTree::~TTree(); 922{; 923 if (auto link = dynamic_cast<TNotifyLinkBase*>(fNotify)) {; 924 link->Clear();; 925 }; 926 if (fAllocationCount && (gDebug > 0)) {; 927 Info(""TTree::~TTree"", ""For tree %s, allocation count is %u."", GetName(), fAllocationCount.load());; 928#ifdef R__TRACK_BASKET_ALLOC_TIME; 929 Info(""TTree::~TTree"", ""For tree %s, allocation time is %lluus."", GetName(), fAllocationTime.load());; 930#endif; 931 }; 932 ; 933 if (fDirectory) {; 934 // We are in a directory, which may possibly be a file.; 935 if (fDirectory->GetList()) {; 936 // Remove us from the directory listing.; 937 fDirectory->Remove(this);; 938 }; 939 //delete the file cache if it points to this Tree; 940 TFile *file = fDirectory->GetFile();; 941 MoveReadCache(file,nullptr);; 942 }; 943 ; 944 // Remove the TTree from any list (linked to to the list of Cleanups) to avoid the unnecessary call to; 945 // this RecursiveRemove while we delete our content.; 946 ROOT::CallRecursiveRemoveIfNeeded(*this);; 947 ResetBit(kMustCleanup); // Don't redo it.; 948 ; 949 // We don't own the leaves in fLeaves, the branches do.; 950 fLeaves.Clear();; 951 // I'm ready to destroy any objects allocated by; 952 // SetAddress() by my branches. If I have clones,; 953 // tell them to zero their pointers to this shared; 954 // memory.; 955 if (fClones && fClones->GetEntries()) {; 956 // I have clones.; 957 // I am about to delete the objects created by; 958 // SetAddress() which we are sharing, so tell; 959 // the clones to release their pointers to them.; 960 for (TObjLink* lnk = fClones->FirstLink(); lnk; lnk = lnk->Next()) {; 961 TTree* clone = (TTree*) lnk->GetObject();; 962 // clone->ResetBranchAddresses();; 963 ; 964 // Reset only the branch we have set the address of.; 965 CopyAdd",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:35244,Safety,detect,detect,35244,"es, the branches do.; 950 fLeaves.Clear();; 951 // I'm ready to destroy any objects allocated by; 952 // SetAddress() by my branches. If I have clones,; 953 // tell them to zero their pointers to this shared; 954 // memory.; 955 if (fClones && fClones->GetEntries()) {; 956 // I have clones.; 957 // I am about to delete the objects created by; 958 // SetAddress() which we are sharing, so tell; 959 // the clones to release their pointers to them.; 960 for (TObjLink* lnk = fClones->FirstLink(); lnk; lnk = lnk->Next()) {; 961 TTree* clone = (TTree*) lnk->GetObject();; 962 // clone->ResetBranchAddresses();; 963 ; 964 // Reset only the branch we have set the address of.; 965 CopyAddresses(clone,true);; 966 }; 967 }; 968 // Get rid of our branches, note that this will also release; 969 // any memory allocated by TBranchElement::SetAddress().; 970 fBranches.Delete();; 971 ; 972 // The TBranch destructor is using fDirectory to detect whether it; 973 // owns the TFile that contains its data (See TBranch::~TBranch); 974 fDirectory = nullptr;; 975 ; 976 // FIXME: We must consider what to do with the reset of these if we are a clone.; 977 delete fPlayer;; 978 fPlayer = nullptr;; 979 if (fExternalFriends) {; 980 using namespace ROOT::Detail;; 981 for(auto fetree : TRangeStaticCast<TFriendElement>(*fExternalFriends)); 982 fetree->Reset();; 983 fExternalFriends->Clear(""nodelete"");; 984 SafeDelete(fExternalFriends);; 985 }; 986 if (fFriends) {; 987 fFriends->Delete();; 988 delete fFriends;; 989 fFriends = nullptr;; 990 }; 991 if (fAliases) {; 992 fAliases->Delete();; 993 delete fAliases;; 994 fAliases = nullptr;; 995 }; 996 if (fUserInfo) {; 997 fUserInfo->Delete();; 998 delete fUserInfo;; 999 fUserInfo = nullptr;; 1000 }; 1001 if (fClones) {; 1002 // Clone trees should no longer be removed from fClones when they are deleted.; 1003 {; 1004 R__LOCKGUARD(gROOTMutex);; 1005 gROOT->GetListOfCleanups()->Remove(fClones);; 1006 }; 1007 // Note: fClones does not own its content.; 1008 delet",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:44741,Safety,risk,risk,44741,"or indexing must be present in mainTree.; 1240// Return true if the trees can be friends, false otherwise.; 1241bool CheckReshuffling(TTree &mainTree, TTree &friendTree); 1242{; 1243 const auto isMainReshuffled = mainTree.TestBit(TTree::kEntriesReshuffled);; 1244 const auto isFriendReshuffled = friendTree.TestBit(TTree::kEntriesReshuffled);; 1245 const auto friendHasValidIndex = [&] {; 1246 auto idx = friendTree.GetTreeIndex();; 1247 return idx ? idx->IsValidFor(&mainTree) : false;; 1248 }();; 1249 ; 1250 if ((isMainReshuffled || isFriendReshuffled) && !friendHasValidIndex) {; 1251 const auto reshuffledTreeName = isMainReshuffled ? mainTree.GetName() : friendTree.GetName();; 1252 const auto msg =; 1253 ""Tree '%s' has the kEntriesReshuffled bit set and cannot have friends nor can be added as a friend unless the ""; 1254 ""main tree has a TTreeIndex on the friend tree '%s'. You can also unset the bit manually if you know what you ""; 1255 ""are doing; note that you risk associating wrong TTree entries of the friend with those of the main TTree!"";; 1256 Error(""AddFriend"", msg, reshuffledTreeName, friendTree.GetName());; 1257 return false;; 1258 }; 1259 return true;; 1260}; 1261 ; 1262////////////////////////////////////////////////////////////////////////////////; 1263/// Add a TFriendElement to the list of friends.; 1264///; 1265/// This function:; 1266/// - opens a file if filename is specified; 1267/// - reads a Tree with name treename from the file (current directory); 1268/// - adds the Tree to the list of friends; 1269/// see other AddFriend functions; 1270///; 1271/// A TFriendElement TF describes a TTree object TF in a file.; 1272/// When a TFriendElement TF is added to the list of friends of an; 1273/// existing TTree T, any variable from TF can be referenced in a query; 1274/// to T.; 1275///; 1276/// A tree keeps a list of friends. In the context of a tree (or a chain),; 1277/// friendship means unrestricted access to the friends data. In this way; 1278/// it is",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:45831,Safety,risk,risk,45831,"se of the main TTree!"";; 1256 Error(""AddFriend"", msg, reshuffledTreeName, friendTree.GetName());; 1257 return false;; 1258 }; 1259 return true;; 1260}; 1261 ; 1262////////////////////////////////////////////////////////////////////////////////; 1263/// Add a TFriendElement to the list of friends.; 1264///; 1265/// This function:; 1266/// - opens a file if filename is specified; 1267/// - reads a Tree with name treename from the file (current directory); 1268/// - adds the Tree to the list of friends; 1269/// see other AddFriend functions; 1270///; 1271/// A TFriendElement TF describes a TTree object TF in a file.; 1272/// When a TFriendElement TF is added to the list of friends of an; 1273/// existing TTree T, any variable from TF can be referenced in a query; 1274/// to T.; 1275///; 1276/// A tree keeps a list of friends. In the context of a tree (or a chain),; 1277/// friendship means unrestricted access to the friends data. In this way; 1278/// it is much like adding another branch to the tree without taking the risk; 1279/// of damaging it. To add a friend to the list, you can use the TTree::AddFriend; 1280/// method. The tree in the diagram below has two friends (friend_tree1 and; 1281/// friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m.; 1282///; 1283/// \image html ttree_friend1.png; 1284///; 1285/// The AddFriend method has two parameters, the first is the tree name and the; 1286/// second is the name of the ROOT file where the friend tree is saved.; 1287/// AddFriend automatically opens the friend file. If no file name is given,; 1288/// the tree called ft1 is assumed to be in the same file as the original tree.; 1289///; 1290/// tree.AddFriend(""ft1"",""friendfile1.root"");; 1291/// If the friend tree has the same name as the original tree, you can give it; 1292/// an alias in the context of the friendship:; 1293///; 1294/// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; 1295/// Once the tree has friends, we can use TTree::Draw as if ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:52256,Safety,safe,safe,52256," *tree, const char *alias, bool warn); 1399{; 1400 if (!tree) {; 1401 return nullptr;; 1402 }; 1403 if (!fFriends) {; 1404 fFriends = new TList();; 1405 }; 1406 TFriendElement *fe = new TFriendElement(this, tree, alias);; 1407 R__ASSERT(fe); // this assert is for historical reasons. Don't remove it unless you understand all the consequences.; 1408 TTree *t = fe->GetTree();; 1409 if (warn && (t->GetEntries() < fEntries)) {; 1410 Warning(""AddFriend"", ""FriendElement '%s' in file '%s' has less entries %lld than its parent tree: %lld"",; 1411 tree->GetName(), fe->GetFile() ? fe->GetFile()->GetName() : ""(memory resident)"", t->GetEntries(),; 1412 fEntries);; 1413 }; 1414 if (CheckReshuffling(*this, *t)); 1415 fFriends->Add(fe);; 1416 else; 1417 tree->RemoveExternalFriend(fe);; 1418 return fe;; 1419}; 1420 ; 1421////////////////////////////////////////////////////////////////////////////////; 1422/// AutoSave tree header every fAutoSave bytes.; 1423///; 1424/// When large Trees are produced, it is safe to activate the AutoSave; 1425/// procedure. Some branches may have buffers holding many entries.; 1426/// If fAutoSave is negative, AutoSave is automatically called by; 1427/// TTree::Fill when the number of bytes generated since the previous; 1428/// AutoSave is greater than -fAutoSave bytes.; 1429/// If fAutoSave is positive, AutoSave is automatically called by; 1430/// TTree::Fill every N entries.; 1431/// This function may also be invoked by the user.; 1432/// Each AutoSave generates a new key on the file.; 1433/// Once the key with the tree header has been written, the previous cycle; 1434/// (if any) is deleted.; 1435///; 1436/// Note that calling TTree::AutoSave too frequently (or similarly calling; 1437/// TTree::SetAutoSave with a small value) is an expensive operation.; 1438/// You should make tests for your own application to find a compromise; 1439/// between speed and the quantity of information you may loose in case of; 1440/// a job crash.; 1441///; 1442/// In c",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:53361,Safety,recover,recovered,53361," buffers holding many entries.; 1426/// If fAutoSave is negative, AutoSave is automatically called by; 1427/// TTree::Fill when the number of bytes generated since the previous; 1428/// AutoSave is greater than -fAutoSave bytes.; 1429/// If fAutoSave is positive, AutoSave is automatically called by; 1430/// TTree::Fill every N entries.; 1431/// This function may also be invoked by the user.; 1432/// Each AutoSave generates a new key on the file.; 1433/// Once the key with the tree header has been written, the previous cycle; 1434/// (if any) is deleted.; 1435///; 1436/// Note that calling TTree::AutoSave too frequently (or similarly calling; 1437/// TTree::SetAutoSave with a small value) is an expensive operation.; 1438/// You should make tests for your own application to find a compromise; 1439/// between speed and the quantity of information you may loose in case of; 1440/// a job crash.; 1441///; 1442/// In case your program crashes before closing the file holding this tree,; 1443/// the file will be automatically recovered when you will connect the file; 1444/// in UPDATE mode.; 1445/// The Tree will be recovered at the status corresponding to the last AutoSave.; 1446///; 1447/// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; 1448/// This allows another process to analyze the Tree while the Tree is being filled.; 1449///; 1450/// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; 1451/// the current basket are closed-out and written to disk individually.; 1452///; 1453/// By default the previous header is deleted after having written the new header.; 1454/// if option contains ""Overwrite"", the previous Tree header is deleted; 1455/// before written the new header. This option is slightly faster, but; 1456/// the default option is safer in case of a problem (disk quota exceeded); 1457/// when writing the new header.; 1458///; 1459/// The function returns the number of bytes written to the file.; 1460/// if the number of b",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:53453,Safety,recover,recovered,53453," bytes generated since the previous; 1428/// AutoSave is greater than -fAutoSave bytes.; 1429/// If fAutoSave is positive, AutoSave is automatically called by; 1430/// TTree::Fill every N entries.; 1431/// This function may also be invoked by the user.; 1432/// Each AutoSave generates a new key on the file.; 1433/// Once the key with the tree header has been written, the previous cycle; 1434/// (if any) is deleted.; 1435///; 1436/// Note that calling TTree::AutoSave too frequently (or similarly calling; 1437/// TTree::SetAutoSave with a small value) is an expensive operation.; 1438/// You should make tests for your own application to find a compromise; 1439/// between speed and the quantity of information you may loose in case of; 1440/// a job crash.; 1441///; 1442/// In case your program crashes before closing the file holding this tree,; 1443/// the file will be automatically recovered when you will connect the file; 1444/// in UPDATE mode.; 1445/// The Tree will be recovered at the status corresponding to the last AutoSave.; 1446///; 1447/// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; 1448/// This allows another process to analyze the Tree while the Tree is being filled.; 1449///; 1450/// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; 1451/// the current basket are closed-out and written to disk individually.; 1452///; 1453/// By default the previous header is deleted after having written the new header.; 1454/// if option contains ""Overwrite"", the previous Tree header is deleted; 1455/// before written the new header. This option is slightly faster, but; 1456/// the default option is safer in case of a problem (disk quota exceeded); 1457/// when writing the new header.; 1458///; 1459/// The function returns the number of bytes written to the file.; 1460/// if the number of bytes is null, an error has occurred while writing; 1461/// the header to the file.; 1462///; 1463/// ## How to write a Tree in one process an",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:54134,Safety,safe,safer,54134,"en speed and the quantity of information you may loose in case of; 1440/// a job crash.; 1441///; 1442/// In case your program crashes before closing the file holding this tree,; 1443/// the file will be automatically recovered when you will connect the file; 1444/// in UPDATE mode.; 1445/// The Tree will be recovered at the status corresponding to the last AutoSave.; 1446///; 1447/// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; 1448/// This allows another process to analyze the Tree while the Tree is being filled.; 1449///; 1450/// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; 1451/// the current basket are closed-out and written to disk individually.; 1452///; 1453/// By default the previous header is deleted after having written the new header.; 1454/// if option contains ""Overwrite"", the previous Tree header is deleted; 1455/// before written the new header. This option is slightly faster, but; 1456/// the default option is safer in case of a problem (disk quota exceeded); 1457/// when writing the new header.; 1458///; 1459/// The function returns the number of bytes written to the file.; 1460/// if the number of bytes is null, an error has occurred while writing; 1461/// the header to the file.; 1462///; 1463/// ## How to write a Tree in one process and view it from another process; 1464///; 1465/// The following two scripts illustrate how to do this.; 1466/// The script treew.C is executed by process1, treer.C by process2; 1467///; 1468/// script treew.C:; 1469/// ~~~ {.cpp}; 1470/// void treew() {; 1471/// TFile f(""test.root"",""recreate"");; 1472/// TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; 1473/// Float_t px, py, pz;; 1474/// for ( Int_t i=0; i<10000000; i++) {; 1475/// gRandom->Rannor(px,py);; 1476/// pz = px*px + py*py;; 1477/// Float_t random = gRandom->Rndm(1);; 1478/// ntuple->Fill(px,py,pz,random,i);; 1479/// if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; 1480/// }; 1481/// }; 1",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:57450,Safety,avoid,avoid,57450,"rectory->WriteTObject(this); //nbytes will be 0 if Write failed (disk space exceeded); 1523 if (nbytes && key && strcmp(ClassName(), key->GetClassName()) == 0) {; 1524 key->Delete();; 1525 delete key;; 1526 }; 1527 }; 1528 // save StreamerInfo; 1529 TFile *file = fDirectory->GetFile();; 1530 if (file) file->WriteStreamerInfo();; 1531 ; 1532 if (opt.Contains(""saveself"")) {; 1533 fDirectory->SaveSelf();; 1534 //the following line is required in case GetUserInfo contains a user class; 1535 //for which the StreamerInfo must be written. One could probably be a bit faster (Rene); 1536 if (file) file->WriteHeader();; 1537 }; 1538 ; 1539 return nbytes;; 1540}; 1541 ; 1542namespace {; 1543 // This error message is repeated several times in the code. We write it once.; 1544 const char* writeStlWithoutProxyMsg = ""The class requested (%s) for the branch \""%s\""""; 1545 "" is an instance of an stl collection and does not have a compiled CollectionProxy.""; 1546 "" Please generate the dictionary for this collection (%s) to avoid to write corrupted data."";; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// Same as TTree::Branch() with added check that addobj matches className.; 1551///; 1552/// \see TTree::Branch() for other details.; 1553///; 1554 ; 1555TBranch* TTree::BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); 1556{; 1557 TClass* claim = TClass::GetClass(classname);; 1558 if (!ptrClass) {; 1559 if (claim && claim->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(claim->GetCollectionProxy())) {; 1560 Error(""Branch"", writeStlWithoutProxyMsg,; 1561 claim->GetName(), branchname, claim->GetName());; 1562 return nullptr;; 1563 }; 1564 return Branch(branchname, classname, (void*) addobj, bufsize, splitlevel);; 1565 }; 1566 TClass* actualClass = nullptr;; 1567 void** addr = (void**) addobj;; 1568 if (addr) {; 1569 actualClass = ptrClass->GetA",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:60243,Safety,detect,detection,60243,"le32_t. This is actually a correct case.; 1577 } else {; 1578 Error(""Branch"", ""The class requested (%s) for \""%s\"" is different from the type of the pointer passed (%s)"",; 1579 claim->GetName(), branchname, ptrClass->GetName());; 1580 }; 1581 } else if (actualClass && (claim != actualClass) && !actualClass->InheritsFrom(claim)) {; 1582 if (claim->IsLoaded() && actualClass->IsLoaded() && strcmp( claim->GetTypeInfo()->name(), actualClass->GetTypeInfo()->name() ) == 0) {; 1583 // The type is the same according to the C++ type_info, we must be in the case of; 1584 // a template of Double32_t. This is actually a correct case.; 1585 } else {; 1586 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"",; 1587 actualClass->GetName(), branchname, claim->GetName());; 1588 }; 1589 }; 1590 }; 1591 if (claim && claim->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(claim->GetCollectionProxy())) {; 1592 Error(""Branch"", writeStlWithoutProxyMsg,; 1593 claim->GetName(), branchname, claim->GetName());; 1594 return nullptr;; 1595 }; 1596 return Branch(branchname, classname, (void*) addobj, bufsize, splitlevel);; 1597}; 1598 ; 1599////////////////////////////////////////////////////////////////////////////////; 1600/// Same as TTree::Branch but automatic detection of the class name.; 1601/// \see TTree::Branch for other details.; 1602 ; 1603TBranch* TTree::BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); 1604{; 1605 if (!ptrClass) {; 1606 Error(""Branch"", ""The pointer specified for %s is not of a class known to ROOT"", branchname);; 1607 return nullptr;; 1608 }; 1609 TClass* actualClass = nullptr;; 1610 void** addr = (void**) addobj;; 1611 if (addr && *addr) {; 1612 actualClass = ptrClass->GetActualClass(*addr);; 1613 if (!actualClass) {; 1614 Warning(""Branch"", ""The actual TClass corresponding to the object provided for the definition of the branch \",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:61926,Safety,detect,detection,61926,"plitlevel); 1604{; 1605 if (!ptrClass) {; 1606 Error(""Branch"", ""The pointer specified for %s is not of a class known to ROOT"", branchname);; 1607 return nullptr;; 1608 }; 1609 TClass* actualClass = nullptr;; 1610 void** addr = (void**) addobj;; 1611 if (addr && *addr) {; 1612 actualClass = ptrClass->GetActualClass(*addr);; 1613 if (!actualClass) {; 1614 Warning(""Branch"", ""The actual TClass corresponding to the object provided for the definition of the branch \""%s\"" is missing.\n\tThe object will be truncated down to its %s part"",; 1615 branchname, ptrClass->GetName());; 1616 actualClass = ptrClass;; 1617 } else if ((ptrClass != actualClass) && !actualClass->InheritsFrom(ptrClass)) {; 1618 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"", actualClass->GetName(), branchname, ptrClass->GetName());; 1619 return nullptr;; 1620 }; 1621 } else {; 1622 actualClass = ptrClass;; 1623 }; 1624 if (actualClass && actualClass->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(actualClass->GetCollectionProxy())) {; 1625 Error(""Branch"", writeStlWithoutProxyMsg,; 1626 actualClass->GetName(), branchname, actualClass->GetName());; 1627 return nullptr;; 1628 }; 1629 return Branch(branchname, actualClass->GetName(), (void*) addobj, bufsize, splitlevel);; 1630}; 1631 ; 1632////////////////////////////////////////////////////////////////////////////////; 1633/// Same as TTree::Branch but automatic detection of the class name.; 1634/// \see TTree::Branch for other details.; 1635 ; 1636TBranch* TTree::BranchImpRef(const char* branchname, const char *classname, TClass* ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel); 1637{; 1638 TClass* claim = TClass::GetClass(classname);; 1639 if (!ptrClass) {; 1640 if (claim && claim->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(claim->GetCollectionProxy())) {; 1641 Error(""Branch"", writeStlWithoutProxyMsg,; 1642 claim->GetName(), branch",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:65390,Safety,detect,detection,65390," C++ type_info, we must be in the case of; 1669 // a template of Double32_t. This is actually a correct case.; 1670 } else {; 1671 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"",; 1672 actualClass->GetName(), branchname, claim->GetName());; 1673 }; 1674 }; 1675 }; 1676 if (!actualClass) {; 1677 Warning(""Branch"", ""The actual TClass corresponding to the object provided for the definition of the branch \""%s\"" is missing.\n\tThe object will be truncated down to its %s part"",; 1678 branchname, ptrClass->GetName());; 1679 actualClass = ptrClass;; 1680 } else if ((ptrClass != actualClass) && !actualClass->InheritsFrom(ptrClass)) {; 1681 Error(""Branch"", ""The actual class (%s) of the object provided for the definition of the branch \""%s\"" does not inherit from %s"", actualClass->GetName(), branchname, ptrClass->GetName());; 1682 return nullptr;; 1683 }; 1684 if (actualClass && actualClass->GetCollectionProxy() && dynamic_cast<TEmulatedCollectionProxy*>(actualClass->GetCollectionProxy())) {; 1685 Error(""Branch"", writeStlWithoutProxyMsg,; 1686 actualClass->GetName(), branchname, actualClass->GetName());; 1687 return nullptr;; 1688 }; 1689 return BronchExec(branchname, actualClass->GetName(), (void*) addobj, false, bufsize, splitlevel);; 1690}; 1691 ; 1692////////////////////////////////////////////////////////////////////////////////; 1693/// Same as TTree::Branch but automatic detection of the class name.; 1694/// \see TTree::Branch for other details.; 1695 ; 1696TBranch* TTree::BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); 1697{; 1698 if (!ptrClass) {; 1699 if (datatype == kOther_t || datatype == kNoType_t) {; 1700 Error(""Branch"", ""The pointer specified for %s is not of a class or type known to ROOT"", branchname);; 1701 } else {; 1702 TString varname; varname.Form(""%s/%c"",branchname,DataTypeToChar(datatype));; 1703 retur",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:69837,Safety,avoid,avoid,69837,"a TObjArray*; 1763/// - if splitlevel = 1, one top level branch is created for each element; 1764/// of the TObjArray.; 1765/// - if splitlevel = 2, one top level branch is created for each array element.; 1766/// if, in turn, one of the array elements is a TCollection, one top level; 1767/// branch will be created for each element of this collection.; 1768///; 1769/// In case a collection element is a TClonesArray, the special Tree constructor; 1770/// for TClonesArray is called.; 1771/// The collection itself cannot be a TClonesArray.; 1772///; 1773/// The function returns the total number of branches created.; 1774///; 1775/// If name is given, all branch names will be prefixed with name_.; 1776///; 1777/// IMPORTANT NOTE1: This function should not be called with splitlevel < 1.; 1778///; 1779/// IMPORTANT NOTE2: The branches created by this function will have names; 1780/// corresponding to the collection or object names. It is important; 1781/// to give names to collections to avoid misleading branch names or; 1782/// identical branch names. By default collections have a name equal to; 1783/// the corresponding class name, e.g. the default name for a TList is ""TList"".; 1784///; 1785/// And in general, in case two or more master branches contain subbranches; 1786/// with identical names, one must add a ""."" (dot) character at the end; 1787/// of the master branch name. This will force the name of the subbranches; 1788/// to be of the form `master.subbranch` instead of simply `subbranch`.; 1789/// This situation happens when the top level object; 1790/// has two or more members referencing the same class.; 1791/// For example, if a Tree has two branches B1 and B2 corresponding; 1792/// to objects of the same class MyClass, one can do:; 1793/// ~~~ {.cpp}; 1794/// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; 1795/// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; 1796/// ~~~; 1797/// if MyClass has 3 members a,b,c, the two instructions above will generate; 1798/// subbranche",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:119795,Safety,avoid,avoid,119795,"e know how to convert them, if we know how to convert their content.; 2967 // NOTE: we need to extend this to std::pair ...; 2968 ; 2969 TClass *onfileValueClass = expectedClass->GetCollectionProxy()->GetValueClass();; 2970 TClass *inmemValueClass = ptrClass->GetCollectionProxy()->GetValueClass();; 2971 ; 2972 if (inmemValueClass->GetSchemaRules() &&; 2973 inmemValueClass->GetSchemaRules()->HasRuleWithSourceClass(onfileValueClass->GetName() ) ); 2974 {; 2975 TBranchElement* bEl = (TBranchElement*)branch;; 2976 bEl->SetTargetClass( ptrClass->GetName() );; 2977 return kMatchConversionCollection;; 2978 }; 2979 }; 2980 ; 2981 Error(""SetBranchAddress"", ""The pointer type given (%s) does not correspond to the class needed (%s) by the branch: %s"", ptrClass->GetName(), expectedClass->GetName(), branch->GetName());; 2982 if (isBranchElement) {; 2983 TBranchElement* bEl = (TBranchElement*)branch;; 2984 bEl->SetTargetClass( expectedClass->GetName() );; 2985 }; 2986 return kClassMismatch;; 2987 ; 2988 } else if ((expectedType != kOther_t) && (datatype != kOther_t) && (expectedType != kNoType_t) && (datatype != kNoType_t) && (expectedType != datatype)) {; 2989 if (datatype != kChar_t) {; 2990 // For backward compatibility we assume that (char*) was just a cast and/or a generic address; 2991 Error(""SetBranchAddress"", ""The pointer type given \""%s\"" (%d) does not correspond to the type needed \""%s\"" (%d) by the branch: %s"",; 2992 TDataType::GetTypeName(datatype), datatype, TDataType::GetTypeName(expectedType), expectedType, branch->GetName());; 2993 return kMismatch;; 2994 }; 2995 } else if ((expectedClass && (datatype != kOther_t && datatype != kNoType_t && datatype != kInt_t)) ||; 2996 (ptrClass && (expectedType != kOther_t && expectedType != kNoType_t && datatype != kInt_t)) ) {; 2997 // Sometime a null pointer can look an int, avoid complaining in that case.; 2998 if (expectedClass) {; 2999 Error(""SetBranchAddress"", ""The pointer type given \""%s\"" (%d) does not correspond to the ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:169868,Safety,avoid,avoid,169868,"/// - `Length$(formula )` : return the total number of element of the formula; 4215/// given as a parameter.; 4216/// - `Sum$(formula )` : return the sum of the value of the elements of the; 4217/// formula given as a parameter. For example the mean for all the elements in; 4218/// one entry can be calculated with: `Sum$(formula )/Length$(formula )`; 4219/// - `Min$(formula )` : return the minimum (within one TTree entry) of the value of the; 4220/// elements of the formula given as a parameter.; 4221/// - `Max$(formula )` : return the maximum (within one TTree entry) of the value of the; 4222/// elements of the formula given as a parameter.; 4223/// - `MinIf$(formula,condition)`; 4224/// - `MaxIf$(formula,condition)` : return the minimum (maximum) (within one TTree entry); 4225/// of the value of the elements of the formula given as a parameter; 4226/// if they match the condition. If no element matches the condition,; 4227/// the result is zero. To avoid the resulting peak at zero, use the; 4228/// pattern:; 4229/// ~~~ {.cpp}; 4230/// tree->Draw(""MinIf$(formula,condition)"",""condition"");; 4231/// ~~~; 4232/// which will avoid calculation `MinIf$` for the entries that have no match; 4233/// for the condition.; 4234/// - `Alt$(primary,alternate)` : return the value of ""primary"" if it is available; 4235/// for the current iteration otherwise return the value of ""alternate"".; 4236/// For example, with arr1[3] and arr2[2]; 4237/// ~~~ {.cpp}; 4238/// tree->Draw(""arr1+Alt$(arr2,0)"");; 4239/// ~~~; 4240/// will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; 4241/// Or with a variable size array arr3; 4242/// ~~~ {.cpp}; 4243/// tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; 4244/// ~~~; 4245/// will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); 4246/// As a comparison; 4247/// ~~~ {.cpp}; 4248/// tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; 4249/// ~~~; 4250/// will draw the sum arr3 for the index 0 to 2 only if the; 4251/// actual_",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:170043,Safety,avoid,avoid,170043,")` : return the sum of the value of the elements of the; 4217/// formula given as a parameter. For example the mean for all the elements in; 4218/// one entry can be calculated with: `Sum$(formula )/Length$(formula )`; 4219/// - `Min$(formula )` : return the minimum (within one TTree entry) of the value of the; 4220/// elements of the formula given as a parameter.; 4221/// - `Max$(formula )` : return the maximum (within one TTree entry) of the value of the; 4222/// elements of the formula given as a parameter.; 4223/// - `MinIf$(formula,condition)`; 4224/// - `MaxIf$(formula,condition)` : return the minimum (maximum) (within one TTree entry); 4225/// of the value of the elements of the formula given as a parameter; 4226/// if they match the condition. If no element matches the condition,; 4227/// the result is zero. To avoid the resulting peak at zero, use the; 4228/// pattern:; 4229/// ~~~ {.cpp}; 4230/// tree->Draw(""MinIf$(formula,condition)"",""condition"");; 4231/// ~~~; 4232/// which will avoid calculation `MinIf$` for the entries that have no match; 4233/// for the condition.; 4234/// - `Alt$(primary,alternate)` : return the value of ""primary"" if it is available; 4235/// for the current iteration otherwise return the value of ""alternate"".; 4236/// For example, with arr1[3] and arr2[2]; 4237/// ~~~ {.cpp}; 4238/// tree->Draw(""arr1+Alt$(arr2,0)"");; 4239/// ~~~; 4240/// will draw arr1[0]+arr2[0] ; arr1[1]+arr2[1] and arr1[2]+0; 4241/// Or with a variable size array arr3; 4242/// ~~~ {.cpp}; 4243/// tree->Draw(""Alt$(arr3[0],0)+Alt$(arr3[1],0)+Alt$(arr3[2],0)"");; 4244/// ~~~; 4245/// will draw the sum arr3 for the index 0 to min(2,actual_size_of_arr3-1); 4246/// As a comparison; 4247/// ~~~ {.cpp}; 4248/// tree->Draw(""arr3[0]+arr3[1]+arr3[2]"");; 4249/// ~~~; 4250/// will draw the sum arr3 for the index 0 to 2 only if the; 4251/// actual_size_of_arr3 is greater or equal to 3.; 4252/// Note that the array in 'primary' is flattened/linearized thus using; 4253/// `Alt$` wi",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:186206,Safety,recover,recoverable,186206,"r of bytes committed to the; 4571/// individual branches.; 4572///; 4573/// If a write error occurs, the number of bytes returned is -1.; 4574///; 4575/// If no data are written, because, e.g., the branch is disabled,; 4576/// the number of bytes returned is 0.; 4577///; 4578/// __The baskets are flushed and the Tree header saved at regular intervals__; 4579///; 4580/// At regular intervals, when the amount of data written so far is; 4581/// greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; 4582/// This makes future reading faster as it guarantees that baskets belonging to nearby; 4583/// entries will be on the same disk region.; 4584/// When the first call to flush the baskets happen, we also take this opportunity; 4585/// to optimize the baskets buffers.; 4586/// We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; 4587/// In this case we also write the Tree header. This makes the Tree recoverable up to this point; 4588/// in case the program writing the Tree crashes.; 4589/// The decisions to FlushBaskets and Auto Save can be made based either on the number; 4590/// of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; 4591/// written (fAutoFlush and fAutoSave positive).; 4592/// Note that the user can decide to call FlushBaskets and AutoSave in her event loop; 4593/// base on the number of events written instead of the number of bytes written.; 4594///; 4595/// \note Calling `TTree::FlushBaskets` too often increases the IO time.; 4596///; 4597/// \note Calling `TTree::AutoSave` too often increases the IO time and also the; 4598/// file size.; 4599///; 4600/// \note This method calls `TTree::ChangeFile` when the tree reaches a size; 4601/// greater than `TTree::fgMaxTreeSize`. This doesn't happen if the tree is; 4602/// attached to a `TMemFile` or derivate.; 4603 ; 4604Int_t TTree::Fill(); 4605{; 4606 Int_t nbytes = 0;; 4607 Int_t nwrite = 0;; 4608 Int_t nerror = 0;; 4",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:190593,Safety,avoid,avoid,190593,"ave != 0) {; 4689 // Is it time to flush or autosave baskets?; 4690 if (fFlushedBytes == 0) {; 4691 // If fFlushedBytes == 0, it means we never flushed or saved, so; 4692 // we need to check if it's time to do it and recompute the values; 4693 // of fAutoFlush and fAutoSave in terms of the number of entries.; 4694 // Decision can be based initially either on the number of bytes; 4695 // or the number of entries written.; 4696 Long64_t zipBytes = GetZipBytes();; 4697 ; 4698 if (fAutoFlush); 4699 autoFlush = fAutoFlush < 0 ? (zipBytes > -fAutoFlush) : fEntries % fAutoFlush == 0;; 4700 ; 4701 if (fAutoSave); 4702 autoSave = fAutoSave < 0 ? (zipBytes > -fAutoSave) : fEntries % fAutoSave == 0;; 4703 ; 4704 if (autoFlush || autoSave) {; 4705 // First call FlushBasket to make sure that fTotBytes is up to date.; 4706 FlushBasketsImpl();; 4707 autoFlush = false; // avoid auto flushing again later; 4708 ; 4709 // When we are in one-basket-per-cluster mode, there is no need to optimize basket:; 4710 // they will automatically grow to the size needed for an event cluster (with the basket; 4711 // shrinking preventing them from growing too much larger than the actually-used space).; 4712 if (!TestBit(TTree::kOnlyFlushAtCluster)) {; 4713 OptimizeBaskets(GetTotBytes(), 1, """");; 4714 if (gDebug > 0); 4715 Info(""TTree::Fill"", ""OptimizeBaskets called at entry %lld, fZipBytes=%lld, fFlushedBytes=%lld\n"",; 4716 fEntries, GetZipBytes(), fFlushedBytes);; 4717 }; 4718 fFlushedBytes = GetZipBytes();; 4719 fAutoFlush = fEntries; // Use test on entries rather than bytes; 4720 ; 4721 // subsequently in run; 4722 if (fAutoSave < 0) {; 4723 // Set fAutoSave to the largest integer multiple of; 4724 // fAutoFlush events such that fAutoSave*fFlushedBytes; 4725 // < (minus the input value of fAutoSave); 4726 Long64_t totBytes = GetTotBytes();; 4727 if (zipBytes != 0) {; 4728 fAutoSave = TMath::Max(fAutoFlush, fEntries * ((-fAutoSave / zipBytes) / fEntries));; 4729 } else if (totBytes != 0) {; 4730 f",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:210241,Safety,avoid,avoid,210241,"tr;; 5233 }; 5234 if (fAliases) {; 5235 TObject* alias = fAliases->FindObject(aliasName);; 5236 if (alias) {; 5237 return alias->GetTitle();; 5238 }; 5239 }; 5240 if (!fFriends) {; 5241 return nullptr;; 5242 }; 5243 TFriendLock lock(const_cast<TTree*>(this), kGetAlias);; 5244 TIter nextf(fFriends);; 5245 TFriendElement* fe = nullptr;; 5246 while ((fe = (TFriendElement*) nextf())) {; 5247 TTree* t = fe->GetTree();; 5248 if (t) {; 5249 const char* alias = t->GetAlias(aliasName);; 5250 if (alias) {; 5251 return alias;; 5252 }; 5253 const char* subAliasName = strstr(aliasName, fe->GetName());; 5254 if (subAliasName && (subAliasName[strlen(fe->GetName())] == '.')) {; 5255 alias = t->GetAlias(aliasName + strlen(fe->GetName()) + 1);; 5256 if (alias) {; 5257 return alias;; 5258 }; 5259 }; 5260 }; 5261 }; 5262 return nullptr;; 5263}; 5264 ; 5265namespace {; 5266/// Do a breadth first search through the implied hierarchy; 5267/// of branches.; 5268/// To avoid scanning through the list multiple time; 5269/// we also remember the 'depth-first' match.; 5270TBranch *R__GetBranch(const TObjArray &branches, const char *name); 5271{; 5272 TBranch *result = nullptr;; 5273 Int_t nb = branches.GetEntriesFast();; 5274 for (Int_t i = 0; i < nb; i++) {; 5275 TBranch* b = (TBranch*)branches.UncheckedAt(i);; 5276 if (!b); 5277 continue;; 5278 if (!strcmp(b->GetName(), name)) {; 5279 return b;; 5280 }; 5281 if (!strcmp(b->GetFullName(), name)) {; 5282 return b;; 5283 }; 5284 if (!result); 5285 result = R__GetBranch(*(b->GetListOfBranches()), name);; 5286 }; 5287 return result;; 5288}; 5289}; 5290 ; 5291////////////////////////////////////////////////////////////////////////////////; 5292/// Return pointer to the branch with the given name in this tree or its friends.; 5293/// The search is done breadth first.; 5294 ; 5295TBranch* TTree::GetBranch(const char* name); 5296{; 5297 // We already have been visited while recursively; 5298 // looking through the friends tree, let's return.; 5299 if ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:229197,Safety,safe,safely,229197,"t leaves.; 5781 ; 5782void TTree::InitializeBranchLists(bool checkLeafCount); 5783{; 5784 Int_t nbranches = fBranches.GetEntriesFast();; 5785 ; 5786 // The special branch fBranchRef needs to be processed sequentially:; 5787 // we add it once only.; 5788 if (fBranchRef && fBranchRef != fSeqBranches[0]) {; 5789 fSeqBranches.push_back(fBranchRef);; 5790 }; 5791 ; 5792 // The branches to be processed sequentially are those that are the leaf count of another branch; 5793 if (checkLeafCount) {; 5794 for (Int_t i = 0; i < nbranches; i++) {; 5795 TBranch* branch = (TBranch*)fBranches.UncheckedAt(i);; 5796 auto leafCount = ((TLeaf*)branch->GetListOfLeaves()->At(0))->GetLeafCount();; 5797 if (leafCount) {; 5798 auto countBranch = leafCount->GetBranch();; 5799 if (std::find(fSeqBranches.begin(), fSeqBranches.end(), countBranch) == fSeqBranches.end()) {; 5800 fSeqBranches.push_back(countBranch);; 5801 }; 5802 }; 5803 }; 5804 }; 5805 ; 5806 // Any branch that is not a leaf count can be safely processed in parallel when reading; 5807 // We need to reset the vector to make sure we do not re-add several times the same branch.; 5808 if (!checkLeafCount) {; 5809 fSortedBranches.clear();; 5810 }; 5811 for (Int_t i = 0; i < nbranches; i++) {; 5812 Long64_t bbytes = 0;; 5813 TBranch* branch = (TBranch*)fBranches.UncheckedAt(i);; 5814 if (std::find(fSeqBranches.begin(), fSeqBranches.end(), branch) == fSeqBranches.end()) {; 5815 bbytes = branch->GetTotBytes(""*"");; 5816 fSortedBranches.emplace_back(bbytes, branch);; 5817 }; 5818 }; 5819 ; 5820 // Initially sort parallel branches by size; 5821 std::sort(fSortedBranches.begin(),; 5822 fSortedBranches.end(),; 5823 [](std::pair<Long64_t,TBranch*> a, std::pair<Long64_t,TBranch*> b) {; 5824 return a.first > b.first;; 5825 });; 5826 ; 5827 for (size_t i = 0; i < fSortedBranches.size(); i++) {; 5828 fSortedBranches[i].first = 0LL;; 5829 }; 5830}; 5831 ; 5832////////////////////////////////////////////////////////////////////////////////; 5833/// S",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:241733,Safety,avoid,avoid,241733,"nch *mother = br->GetMother();; 6124 if (strncmp(brname,branchname,nbch)) {; 6125 if (mother != br) {; 6126 const char *mothername = mother->GetName();; 6127 UInt_t motherlen = strlen(mothername);; 6128 if (!strcmp(mothername, branchname)) {; 6129 return leaf;; 6130 } else if (nbch > motherlen && strncmp(mothername,branchname,motherlen)==0 && (mothername[motherlen-1]=='.' || branchname[motherlen]=='.')) {; 6131 // The left part of the requested name match the name of the mother, let's see if the right part match the name of the branch.; 6132 if (strncmp(brname,branchname+motherlen+1,nbch-motherlen-1)) {; 6133 // No it does not; 6134 continue;; 6135 } // else we have match so we can proceed.; 6136 } else {; 6137 // no match; 6138 continue;; 6139 }; 6140 } else {; 6141 continue;; 6142 }; 6143 }; 6144 // The start of the branch name is identical to the content; 6145 // of 'aname' before the first '/'.; 6146 // Let's make sure that it is not longer (we are trying; 6147 // to avoid having jet2/value match the branch jet23; 6148 if ((strlen(brname) > nbch) && (brname[nbch] != '.') && (brname[nbch] != '[')) {; 6149 continue;; 6150 }; 6151 }; 6152 return leaf;; 6153 }; 6154 if (!fFriends) return nullptr;; 6155 TFriendLock lock(this,kGetLeaf);; 6156 TIter next(fFriends);; 6157 TFriendElement *fe;; 6158 while ((fe = (TFriendElement*)next())) {; 6159 TTree *t = fe->GetTree();; 6160 if (t) {; 6161 leaf = t->GetLeaf(branchname, leafname);; 6162 if (leaf) return leaf;; 6163 }; 6164 }; 6165 ; 6166 //second pass in the list of friends when the leaf name; 6167 //is prefixed by the tree name; 6168 TString strippedArg;; 6169 next.Reset();; 6170 while ((fe = (TFriendElement*)next())) {; 6171 TTree *t = fe->GetTree();; 6172 if (!t) continue;; 6173 const char *subname = strstr(leafname,fe->GetName());; 6174 if (subname != leafname) continue;; 6175 Int_t l = strlen(fe->GetName());; 6176 subname += l;; 6177 if (*subname != '.') continue;; 6178 subname++;; 6179 strippedArg += subname;; 6180",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:253363,Safety,avoid,avoid,253363,"6451 ; 6452Int_t TTree::LoadBaskets(Long64_t maxmemory); 6453{; 6454 if (maxmemory > 0) SetMaxVirtualSize(maxmemory);; 6455 ; 6456 TIter next(GetListOfLeaves());; 6457 TLeaf *leaf;; 6458 Int_t nimported = 0;; 6459 while ((leaf=(TLeaf*)next())) {; 6460 nimported += leaf->GetBranch()->LoadBaskets();//break;; 6461 }; 6462 return nimported;; 6463}; 6464 ; 6465////////////////////////////////////////////////////////////////////////////////; 6466/// Set current entry.; 6467///; 6468/// Returns -2 if entry does not exist (just as TChain::LoadTree()).; 6469/// Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; 6470///; 6471/// Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; 6472///; 6473/// \note This function is overloaded in TChain.; 6474Long64_t TTree::LoadTree(Long64_t entry); 6475{; 6476 // We have already been visited while recursively looking; 6477 // through the friend trees, let's return; 6478 if (kLoadTree & fFriendLockStatus) {; 6479 // We need to return a negative value to avoid a circular list of friends; 6480 // to think that there is always an entry somewhere in the list.; 6481 return -1;; 6482 }; 6483 ; 6484 // create cache if wanted; 6485 if (fCacheDoAutoInit && entry >=0); 6486 SetCacheSizeAux();; 6487 ; 6488 if (fNotify) {; 6489 if (fReadEntry < 0) {; 6490 fNotify->Notify();; 6491 }; 6492 }; 6493 fReadEntry = entry;; 6494 ; 6495 bool friendHasEntry = false;; 6496 if (fFriends) {; 6497 // Set current entry in friends as well.; 6498 //; 6499 // An alternative would move this code to each of the; 6500 // functions calling LoadTree (and to overload a few more).; 6501 bool needUpdate = false;; 6502 {; 6503 // This scope is need to insure the lock is released at the right time; 6504 TIter nextf(fFriends);; 6505 TFriendLock lock(this, kLoadTree);; 6506 TFriendElement* fe = nullptr;; 6507 while ((fe = (TFriendElement*) nextf())) {; 6508 if (fe->TestBit(TFriendElement::kFromChain))",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:268852,Safety,avoid,avoid,268852,"; 6834 ; 6835////////////////////////////////////////////////////////////////////////////////; 6836/// Check if adding nbytes to memory we are still below MaxVirtualsize.; 6837 ; 6838bool TTree::MemoryFull(Int_t nbytes); 6839{; 6840 if ((fTotalBuffers + nbytes) < fMaxVirtualSize) {; 6841 return false;; 6842 }; 6843 return true;; 6844}; 6845 ; 6846////////////////////////////////////////////////////////////////////////////////; 6847/// Static function merging the trees in the TList into a new tree.; 6848///; 6849/// Trees in the list can be memory or disk-resident trees.; 6850/// The new tree is created in the current directory (memory if gROOT).; 6851 ; 6852TTree* TTree::MergeTrees(TList* li, Option_t* options); 6853{; 6854 if (!li) return nullptr;; 6855 TIter next(li);; 6856 TTree *newtree = nullptr;; 6857 TObject *obj;; 6858 ; 6859 while ((obj=next())) {; 6860 if (!obj->InheritsFrom(TTree::Class())) continue;; 6861 TTree *tree = (TTree*)obj;; 6862 Long64_t nentries = tree->GetEntries();; 6863 if (nentries == 0) continue;; 6864 if (!newtree) {; 6865 newtree = (TTree*)tree->CloneTree(-1, options);; 6866 if (!newtree) continue;; 6867 ; 6868 // Once the cloning is done, separate the trees,; 6869 // to avoid as many side-effects as possible; 6870 // The list of clones is guaranteed to exist since we; 6871 // just cloned the tree.; 6872 tree->GetListOfClones()->Remove(newtree);; 6873 tree->ResetBranchAddresses();; 6874 newtree->ResetBranchAddresses();; 6875 continue;; 6876 }; 6877 ; 6878 newtree->CopyEntries(tree, -1, options, true);; 6879 }; 6880 if (newtree && newtree->GetTreeIndex()) {; 6881 newtree->GetTreeIndex()->Append(nullptr,false); // Force the sorting; 6882 }; 6883 return newtree;; 6884}; 6885 ; 6886////////////////////////////////////////////////////////////////////////////////; 6887/// Merge the trees in the TList into this tree.; 6888///; 6889/// Returns the total number of entries in the merged tree.; 6890 ; 6891Long64_t TTree::Merge(TCollection* li, Optio",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:320805,Safety,avoid,avoid,320805,"s.; 8214 //; 8215 // fClusterRangeEnd contains the last entries number of a cluster range.; 8216 // In particular this means that the 'next' cluster starts at fClusterRangeEnd[]+1; 8217 // fClusterSize contains the size in number of entries of all the cluster; 8218 // within the given range.; 8219 // The last range (and the only one if fNClusterRange is zero) start at; 8220 // fNClusterRange[fNClusterRange-1]+1 and ends at the end of the TTree. The; 8221 // size of the cluster in this range is given by the value of fAutoFlush.; 8222 //; 8223 // For example printing the beginning and end of each the ranges can be done by:; 8224 //; 8225 // Printf(""%-16s %-16s %-16s %5s"",; 8226 // ""Cluster Range #"", ""Entry Start"", ""Last Entry"", ""Size"");; 8227 // Int_t index= 0;; 8228 // Long64_t clusterRangeStart = 0;; 8229 // if (fNClusterRange) {; 8230 // for( ; index < fNClusterRange; ++index) {; 8231 // Printf(""%-16d %-16lld %-16lld %5lld"",; 8232 // index, clusterRangeStart, fClusterRangeEnd[index], fClusterSize[index]);; 8233 // clusterRangeStart = fClusterRangeEnd[index] + 1;; 8234 // }; 8235 // }; 8236 // Printf(""%-16d %-16lld %-16lld %5lld"",; 8237 // index, prevEntry, fEntries - 1, fAutoFlush);; 8238 //; 8239 ; 8240 // Note: We store the entry number corresponding to the end of the cluster; 8241 // rather than its start in order to avoid using the array if the cluster; 8242 // size never varies (If there is only one value of AutoFlush for the whole TTree).; 8243 ; 8244 if( fAutoFlush != autof) {; 8245 if ((fAutoFlush > 0 || autof > 0) && fFlushedBytes) {; 8246 // The mechanism was already enabled, let's record the previous; 8247 // cluster if needed.; 8248 MarkEventCluster();; 8249 }; 8250 fAutoFlush = autof;; 8251 }; 8252}; 8253 ; 8254////////////////////////////////////////////////////////////////////////////////; 8255/// Mark the previous event as being at the end of the event cluster.; 8256///; 8257/// So, if fEntries is set to 10 (and this is the first cluster) when MarkEv",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:324939,Safety,recover,recover,324939,"erSizesPerRange),; 8306 [](Long64_t size) { return size != 0; });; 8307 ; 8308 std::vector<double> nClustersInRange; // we need to store doubles because of the signature of TMath::Median; 8309 nClustersInRange.reserve(clusterSizesPerRange.size());; 8310 ; 8311 auto clusterRangeStart = 0ll;; 8312 for (int i = 0; i < fNClusterRange; ++i) {; 8313 const auto size = fClusterSize[i];; 8314 R__ASSERT(size >= 0);; 8315 if (fClusterSize[i] == 0); 8316 continue;; 8317 const auto nClusters = (1 + fClusterRangeEnd[i] - clusterRangeStart) / fClusterSize[i];; 8318 nClustersInRange.emplace_back(nClusters);; 8319 clusterRangeStart = fClusterRangeEnd[i] + 1;; 8320 }; 8321 ; 8322 R__ASSERT(nClustersInRange.size() == clusterSizesPerRange.size());; 8323 const auto medianClusterSize =; 8324 TMath::Median(nClustersInRange.size(), clusterSizesPerRange.data(), nClustersInRange.data());; 8325 return medianClusterSize;; 8326}; 8327 ; 8328////////////////////////////////////////////////////////////////////////////////; 8329/// In case of a program crash, it will be possible to recover the data in the; 8330/// tree up to the last AutoSave point.; 8331/// This function may be called before filling a TTree to specify when the; 8332/// branch buffers and TTree header are flushed to disk as part of; 8333/// TTree::Fill().; 8334/// The default is -300000000, ie the TTree will write data to disk once it; 8335/// exceeds 300 MBytes.; 8336/// CASE 1: If fAutoSave is positive the watermark is reached when a multiple of; 8337/// fAutoSave entries have been filled.; 8338/// CASE 2: If fAutoSave is negative the watermark is reached when -fAutoSave; 8339/// bytes can be written to the file.; 8340/// CASE 3: If fAutoSave is 0, AutoSave() will never be called automatically; 8341/// as part of TTree::Fill().; 8342 ; 8343void TTree::SetAutoSave(Long64_t autos); 8344{; 8345 fAutoSave = autos;; 8346}; 8347 ; 8348////////////////////////////////////////////////////////////////////////////////; 8349/// Set a branch",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:353057,Safety,safe,safety,353057,"; 9104 ; 9105////////////////////////////////////////////////////////////////////////////////; 9106/// Set number of entries to estimate variable limits.; 9107/// If n is -1, the estimate is set to be the current maximum; 9108/// for the tree (i.e. GetEntries() + 1); 9109/// If n is less than -1, the behavior is undefined.; 9110 ; 9111void TTree::SetEstimate(Long64_t n /* = 1000000 */); 9112{; 9113 if (n == 0) {; 9114 n = 10000;; 9115 } else if (n < 0) {; 9116 n = fEntries - n;; 9117 }; 9118 fEstimate = n;; 9119 GetPlayer();; 9120 if (fPlayer) {; 9121 fPlayer->SetEstimate(n);; 9122 }; 9123}; 9124 ; 9125////////////////////////////////////////////////////////////////////////////////; 9126/// Provide the end-user with the ability to enable/disable various experimental; 9127/// IO features for this TTree.; 9128///; 9129/// Returns all the newly-set IO settings.; 9130 ; 9131ROOT::TIOFeatures TTree::SetIOFeatures(const ROOT::TIOFeatures &features); 9132{; 9133 // Purposely ignore all unsupported bits; TIOFeatures implementation already warned the user about the; 9134 // error of their ways; this is just a safety check.; 9135 UChar_t featuresRequested = features.GetFeatures() & static_cast<UChar_t>(TBasket::EIOBits::kSupported);; 9136 ; 9137 UChar_t curFeatures = fIOFeatures.GetFeatures();; 9138 UChar_t newFeatures = ~curFeatures & featuresRequested;; 9139 curFeatures |= newFeatures;; 9140 fIOFeatures.Set(curFeatures);; 9141 ; 9142 ROOT::TIOFeatures newSettings(newFeatures);; 9143 return newSettings;; 9144}; 9145 ; 9146////////////////////////////////////////////////////////////////////////////////; 9147/// Set fFileNumber to number.; 9148/// fFileNumber is used by TTree::Fill to set the file name; 9149/// for a new file to be created when the current file exceeds fgTreeMaxSize.; 9150/// (see TTree::ChangeFile); 9151/// if fFileNumber=10, the new file name will have a suffix ""_11"",; 9152/// ie, fFileNumber is incremented before setting the file name; 9153 ; 9154void TTree:",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:447232,Safety,recover,recover,447232," IMT flush basketsDefinition TTree.h:160; TTree::SetCacheLearnEntriesvirtual void SetCacheLearnEntries(Int_t n=10)Interface to TTreeCache to set the number of entries for the learning phase.Definition TTree.cxx:8865; TTree::fEntryListTEntryList * fEntryList! Pointer to event selection list (if one)Definition TTree.h:126; TTree::GetTreeIndexvirtual TVirtualIndex * GetTreeIndex() constDefinition TTree.h:558; TTree::fExternalFriendsTList * fExternalFriends! List of TFriendsElement pointing to us and need to be notified of LoadTree. Content not owned.Definition TTree.h:131; TTree::Mergevirtual Long64_t Merge(TCollection *list, Option_t *option="""")Merge the trees in the TList into this tree.Definition TTree.cxx:6890; TTree::SetMaxVirtualSizevirtual void SetMaxVirtualSize(Long64_t size=0)Definition TTree.h:665; TTree::DropBasketsvirtual void DropBaskets()Remove some baskets from memory.Definition TTree.cxx:4518; TTree::SetAutoSavevirtual void SetAutoSave(Long64_t autos=-300000000)In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSa...Definition TTree.cxx:8342; TTree::fMaxEntryLoopLong64_t fMaxEntryLoopMaximum number of entries to process.Definition TTree.h:98; TTree::SetParallelUnzipvirtual void SetParallelUnzip(bool opt=true, Float_t RelSize=-1)Enable or disable parallel unzipping of Tree buffers.Definition TTree.cxx:9291; TTree::SetDirectoryvirtual void SetDirectory(TDirectory *dir)Change the tree's directory.Definition TTree.cxx:8966; TTree::SortBranchesByTimevoid SortBranchesByTime()Sorts top-level branches by the last average task time recorded per branch.Definition TTree.cxx:5834; TTree::Deletevoid Delete(Option_t *option="""") overrideDelete this tree from memory or/and disk.Definition TTree.cxx:3747; TTree::GetBranchRefvirtual TBranchRef * GetBranchRef() constDefinition TTree.h:450; TTree::Processvirtual Long64_t Process(const char *filename, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Pro",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:448487,Safety,detect,detection,448487,"tion TTree.h:98; TTree::SetParallelUnzipvirtual void SetParallelUnzip(bool opt=true, Float_t RelSize=-1)Enable or disable parallel unzipping of Tree buffers.Definition TTree.cxx:9291; TTree::SetDirectoryvirtual void SetDirectory(TDirectory *dir)Change the tree's directory.Definition TTree.cxx:8966; TTree::SortBranchesByTimevoid SortBranchesByTime()Sorts top-level branches by the last average task time recorded per branch.Definition TTree.cxx:5834; TTree::Deletevoid Delete(Option_t *option="""") overrideDelete this tree from memory or/and disk.Definition TTree.cxx:3747; TTree::GetBranchRefvirtual TBranchRef * GetBranchRef() constDefinition TTree.h:450; TTree::Processvirtual Long64_t Process(const char *filename, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Process this tree executing the TSelector code in the specified filename.Definition TTree.cxx:7450; TTree::BranchImpRefvirtual TBranch * BranchImpRef(const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel)Same as TTree::Branch but automatic detection of the class name.Definition TTree.cxx:1635; TTree::SetEventListvirtual void SetEventList(TEventList *list)This function transfroms the given TEventList into a TEntryList The new TEntryList is owned by the TT...Definition TTree.cxx:9069; TTree::MoveReadCachevoid MoveReadCache(TFile *src, TDirectory *dir)Move a cache from a file to the current file in dir.Definition TTree.cxx:6983; TTree::fAutoFlushLong64_t fAutoFlushAuto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced.Definition TTree.h:101; TTree::fUpdateInt_t fUpdateUpdate frequency for EntryLoop.Definition TTree.h:93; TTree::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Resets the state of this TTree after a merge (keep the customization but forget the data).Definition TTree.cxx:8034; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::SetEstimatevirtua",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:1131,Security,access,access,1131,"ocumentation of this file. 1// @(#)root/tree:$Id$; 2// Author: Rene Brun 12/01/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11/**; 12 \defgroup tree Tree Library; 13 ; 14 In order to store columnar datasets, ROOT provides the TTree, TChain,; 15 TNtuple and TNtupleD classes.; 16 The TTree class represents a columnar dataset. Any C++ type can be stored in the; 17 columns. The TTree has allowed to store about **1 EB** of data coming from the LHC alone:; 18 it is demonstrated to scale and it's battle tested. It has been optimized during the years; 19 to reduce dataset sizes on disk and to deliver excellent runtime performance.; 20 It allows to access only part of the columns of the datasets, too.; 21 The TNtuple and TNtupleD classes are specialisations of the TTree class which can; 22 only hold single precision and double precision floating-point numbers respectively;; 23 The TChain is a collection of TTrees, which can be located also in different files.; 24 ; 25*/; 26 ; 27/** \class TTree; 28\ingroup tree; 29 ; 30A TTree represents a columnar dataset. Any C++ type can be stored in its columns.; 31 ; 32A TTree, often called in jargon *tree*, consists of a list of independent columns or *branches*,; 33represented by the TBranch class.; 34Behind each branch, buffers are allocated automatically by ROOT.; 35Such buffers are automatically written to disk or kept in memory until the size stored in the; 36attribute fMaxVirtualSize is reached.; 37Variables of one branch are written to the same buffer. A branch buffer is; 38automatically compressed if the file compression attribute is set (default).; 39Branches may be written to different files (see T",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:10984,Security,access,access,10984,"eted or; 191 TTree::ResetBranchAddress is called.; 192 ; 193Note: The pointer p_object must be initialized before calling TTree::Branch; 194- Do either:; 195~~~ {.cpp}; 196 MyDataClass* p_object = nullptr;; 197 tree.Branch(branchname, &p_object);; 198~~~; 199- Or:; 200~~~ {.cpp}; 201 auto p_object = new MyDataClass;; 202 tree.Branch(branchname, &p_object);; 203~~~; 204Whether the pointer is set to zero or not, the ownership of the object; 205is not taken over by the TTree. I.e. even though an object will be allocated; 206by TTree::Branch if the pointer p_object is zero, the object will <b>not</b>; 207be deleted when the TTree is deleted.; 208 ; 209\anchor addingacolumnoftclonesarray; 210## Add a column holding TClonesArray instances; 211 ; 212*It is recommended to use STL containers instead of TClonesArrays*.; 213 ; 214~~~ {.cpp}; 215 // clonesarray is the address of a pointer to a TClonesArray.; 216 auto branch = tree.Branch(branchname,clonesarray, bufsize, splitlevel); 217~~~; 218The TClonesArray is a direct access list of objects of the same class.; 219For example, if the TClonesArray is an array of TTrack objects,; 220this function will create one subbranch for each data member of; 221the object TTrack.; 222 ; 223\anchor fillthetree; 224## Fill the Tree; 225 ; 226A TTree instance is filled with the invocation of the TTree::Fill method:; 227~~~ {.cpp}; 228 tree.Fill(); 229~~~; 230Upon its invocation, a loop on all defined branches takes place that for each branch invokes; 231the TBranch::Fill method.; 232 ; 233\anchor addcoltoexistingtree; 234## Add a column to an already existing Tree; 235 ; 236You may want to add a branch to an existing tree. For example,; 237if one variable in the tree was computed with a certain algorithm,; 238you may want to try another algorithm and compare the results.; 239One solution is to add a new branch, fill it, and save the tree.; 240The code below adds a simple branch to an existing tree.; 241Note the kOverwrite option in the Write",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:45713,Security,access,access,45713,"f you know what you ""; 1255 ""are doing; note that you risk associating wrong TTree entries of the friend with those of the main TTree!"";; 1256 Error(""AddFriend"", msg, reshuffledTreeName, friendTree.GetName());; 1257 return false;; 1258 }; 1259 return true;; 1260}; 1261 ; 1262////////////////////////////////////////////////////////////////////////////////; 1263/// Add a TFriendElement to the list of friends.; 1264///; 1265/// This function:; 1266/// - opens a file if filename is specified; 1267/// - reads a Tree with name treename from the file (current directory); 1268/// - adds the Tree to the list of friends; 1269/// see other AddFriend functions; 1270///; 1271/// A TFriendElement TF describes a TTree object TF in a file.; 1272/// When a TFriendElement TF is added to the list of friends of an; 1273/// existing TTree T, any variable from TF can be referenced in a query; 1274/// to T.; 1275///; 1276/// A tree keeps a list of friends. In the context of a tree (or a chain),; 1277/// friendship means unrestricted access to the friends data. In this way; 1278/// it is much like adding another branch to the tree without taking the risk; 1279/// of damaging it. To add a friend to the list, you can use the TTree::AddFriend; 1280/// method. The tree in the diagram below has two friends (friend_tree1 and; 1281/// friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m.; 1282///; 1283/// \image html ttree_friend1.png; 1284///; 1285/// The AddFriend method has two parameters, the first is the tree name and the; 1286/// second is the name of the ROOT file where the friend tree is saved.; 1287/// AddFriend automatically opens the friend file. If no file name is given,; 1288/// the tree called ft1 is assumed to be in the same file as the original tree.; 1289///; 1290/// tree.AddFriend(""ft1"",""friendfile1.root"");; 1291/// If the friend tree has the same name as the original tree, you can give it; 1292/// an alias in the context of the friendship:; 1293///; 1294/// tre",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:46039,Security,access,access,46039,"////////////////////////////////; 1263/// Add a TFriendElement to the list of friends.; 1264///; 1265/// This function:; 1266/// - opens a file if filename is specified; 1267/// - reads a Tree with name treename from the file (current directory); 1268/// - adds the Tree to the list of friends; 1269/// see other AddFriend functions; 1270///; 1271/// A TFriendElement TF describes a TTree object TF in a file.; 1272/// When a TFriendElement TF is added to the list of friends of an; 1273/// existing TTree T, any variable from TF can be referenced in a query; 1274/// to T.; 1275///; 1276/// A tree keeps a list of friends. In the context of a tree (or a chain),; 1277/// friendship means unrestricted access to the friends data. In this way; 1278/// it is much like adding another branch to the tree without taking the risk; 1279/// of damaging it. To add a friend to the list, you can use the TTree::AddFriend; 1280/// method. The tree in the diagram below has two friends (friend_tree1 and; 1281/// friend_tree2) and now has access to the variables a,b,c,i,j,k,l and m.; 1282///; 1283/// \image html ttree_friend1.png; 1284///; 1285/// The AddFriend method has two parameters, the first is the tree name and the; 1286/// second is the name of the ROOT file where the friend tree is saved.; 1287/// AddFriend automatically opens the friend file. If no file name is given,; 1288/// the tree called ft1 is assumed to be in the same file as the original tree.; 1289///; 1290/// tree.AddFriend(""ft1"",""friendfile1.root"");; 1291/// If the friend tree has the same name as the original tree, you can give it; 1292/// an alias in the context of the friendship:; 1293///; 1294/// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; 1295/// Once the tree has friends, we can use TTree::Draw as if the friend's; 1296/// variables were in the original tree. To specify which tree to use in; 1297/// the Draw method, use the syntax:; 1298/// ~~~ {.cpp}; 1299/// <treeName>.<branchname>.<varname>; 1300/// ~~~; 1",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:47584,Security,access,access,47584," tree, you can give it; 1292/// an alias in the context of the friendship:; 1293///; 1294/// tree.AddFriend(""tree1 = tree"",""friendfile1.root"");; 1295/// Once the tree has friends, we can use TTree::Draw as if the friend's; 1296/// variables were in the original tree. To specify which tree to use in; 1297/// the Draw method, use the syntax:; 1298/// ~~~ {.cpp}; 1299/// <treeName>.<branchname>.<varname>; 1300/// ~~~; 1301/// If the variablename is enough to uniquely identify the variable, you can; 1302/// leave out the tree and/or branch name.; 1303/// For example, these commands generate a 3-d scatter plot of variable ""var""; 1304/// in the TTree tree versus variable v1 in TTree ft1 versus variable v2 in; 1305/// TTree ft2.; 1306/// ~~~ {.cpp}; 1307/// tree.AddFriend(""ft1"",""friendfile1.root"");; 1308/// tree.AddFriend(""ft2"",""friendfile2.root"");; 1309/// tree.Draw(""var:ft1.v1:ft2.v2"");; 1310/// ~~~; 1311/// \image html ttree_friend2.png; 1312///; 1313/// The picture illustrates the access of the tree and its friends with a; 1314/// Draw command.; 1315/// When AddFriend is called, the ROOT file is automatically opened and the; 1316/// friend tree (ft1) is read into memory. The new friend (ft1) is added to; 1317/// the list of friends of tree.; 1318/// The number of entries in the friend must be equal or greater to the number; 1319/// of entries of the original tree. If the friend tree has fewer entries a; 1320/// warning is given and the missing entries are not included in the histogram.; 1321/// To retrieve the list of friends from a tree use TTree::GetListOfFriends.; 1322/// When the tree is written to file (TTree::Write), the friends list is saved; 1323/// with it. And when the tree is retrieved, the trees on the friends list are; 1324/// also retrieved and the friendship restored.; 1325/// When a tree is deleted, the elements of the friend list are also deleted.; 1326/// It is possible to declare a friend tree that has the same internal; 1327/// structure (same branc",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:78660,Security,access,access,78660," dimensional array of fixed size.; 1969/// - In case of the truncated floating point types (Float16_t and Double32_t) you can; 1970/// furthermore specify the range in the style [xmin,xmax] or [xmin,xmax,nbits] after; 1971/// the type character. See `TStreamerElement::GetRange()` for further information.; 1972///; 1973/// Any of other form is not supported.; 1974///; 1975/// Note that the TTree will assume that all the item are contiguous in memory.; 1976/// On some platform, this is not always true of the member of a struct or a class,; 1977/// due to padding and alignment. Sorting your data member in order of decreasing; 1978/// sizeof usually leads to their being contiguous in memory.; 1979///; 1980/// * bufsize is the buffer size in bytes for this branch; 1981/// The default value is 32000 bytes and should be ok for most cases.; 1982/// You can specify a larger value (e.g. 256000) if your Tree is not split; 1983/// and each entry is large (Megabytes); 1984/// A small value for bufsize is optimum if you intend to access; 1985/// the entries in the Tree randomly and your Tree is in split mode.; 1986 ; 1987TBranch* TTree::Branch(const char* name, void* address, const char* leaflist, Int_t bufsize /* = 32000 */); 1988{; 1989 TBranch* branch = new TBranch(this, name, address, leaflist, bufsize);; 1990 if (branch->IsZombie()) {; 1991 delete branch;; 1992 branch = nullptr;; 1993 return nullptr;; 1994 }; 1995 fBranches.Add(branch);; 1996 return branch;; 1997}; 1998 ; 1999////////////////////////////////////////////////////////////////////////////////; 2000/// Create a new branch with the object of class classname at address addobj.; 2001///; 2002/// WARNING:; 2003///; 2004/// Starting with Root version 3.01, the Branch function uses the new style; 2005/// branches (TBranchElement). To get the old behaviour, you can:; 2006/// - call BranchOld or; 2007/// - call TTree::SetBranchStyle(0); 2008///; 2009/// Note that with the new style, classname does not need to derive from ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:81042,Security,access,access,81042,"t level is set to the default (99), TTree::Branch will; 2020/// not issue a warning if the class can not be split.; 2021 ; 2022TBranch* TTree::Branch(const char* name, const char* classname, void* addobj, Int_t bufsize /* = 32000 */, Int_t splitlevel /* = 99 */); 2023{; 2024 if (fgBranchStyle == 1) {; 2025 return Bronch(name, classname, addobj, bufsize, splitlevel);; 2026 } else {; 2027 if (splitlevel < 0) {; 2028 splitlevel = 0;; 2029 }; 2030 return BranchOld(name, classname, addobj, bufsize, splitlevel);; 2031 }; 2032}; 2033 ; 2034////////////////////////////////////////////////////////////////////////////////; 2035/// Create a new TTree BranchObject.; 2036///; 2037/// Build a TBranchObject for an object of class classname.; 2038/// addobj is the address of a pointer to an object of class classname.; 2039/// IMPORTANT: classname must derive from TObject.; 2040/// The class dictionary must be available (ClassDef in class header).; 2041///; 2042/// This option requires access to the library where the corresponding class; 2043/// is defined. Accessing one single data member in the object implies; 2044/// reading the full object.; 2045/// See the next Branch constructor for a more efficient storage; 2046/// in case the entry consists of arrays of identical objects.; 2047///; 2048/// By default the branch buffers are stored in the same file as the Tree.; 2049/// use TBranch::SetFile to specify a different file; 2050///; 2051/// IMPORTANT NOTE about branch names:; 2052///; 2053/// And in general, in case two or more master branches contain subbranches; 2054/// with identical names, one must add a ""."" (dot) character at the end; 2055/// of the master branch name. This will force the name of the subbranches; 2056/// to be of the form `master.subbranch` instead of simply `subbranch`.; 2057/// This situation happens when the top level object; 2058/// has two or more members referencing the same class.; 2059/// For example, if a Tree has two branches B1 and B2 corresponding;",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:82728,Security,access,access,82728,"r at the end; 2055/// of the master branch name. This will force the name of the subbranches; 2056/// to be of the form `master.subbranch` instead of simply `subbranch`.; 2057/// This situation happens when the top level object; 2058/// has two or more members referencing the same class.; 2059/// For example, if a Tree has two branches B1 and B2 corresponding; 2060/// to objects of the same class MyClass, one can do:; 2061/// ~~~ {.cpp}; 2062/// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; 2063/// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; 2064/// ~~~; 2065/// if MyClass has 3 members a,b,c, the two instructions above will generate; 2066/// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; 2067///; 2068/// bufsize is the buffer size in bytes for this branch; 2069/// The default value is 32000 bytes and should be ok for most cases.; 2070/// You can specify a larger value (e.g. 256000) if your Tree is not split; 2071/// and each entry is large (Megabytes); 2072/// A small value for bufsize is optimum if you intend to access; 2073/// the entries in the Tree randomly and your Tree is in split mode.; 2074 ; 2075TBranch* TTree::BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize /* = 32000 */, Int_t splitlevel /* = 1 */); 2076{; 2077 TClass* cl = TClass::GetClass(classname);; 2078 if (!cl) {; 2079 Error(""BranchOld"", ""Cannot find class: '%s'"", classname);; 2080 return nullptr;; 2081 }; 2082 if (!cl->IsTObject()) {; 2083 if (fgBranchStyle == 0) {; 2084 Fatal(""BranchOld"", ""The requested class ('%s') does not inherit from TObject.\n""; 2085 ""\tfgBranchStyle is set to zero requesting by default to use BranchOld.\n""; 2086 ""\tIf this is intentional use Bronch instead of Branch or BranchOld."", classname);; 2087 } else {; 2088 Fatal(""BranchOld"", ""The requested class ('%s') does not inherit from TObject.\n""; 2089 ""\tYou can not use BranchOld to store objects of this type."",classname);; 2090 }; 2091 return nullptr;; 2092 }; 2093 TBranch* branch = new TBranc",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:93776,Security,access,access,93776," be the address of a pointer).; 2349/// For more flexibility use 'Branch'. Use Bronch only in (rare); 2350/// cases (likely to be legacy cases) where both the new and old; 2351/// implementation of Branch needs to be used at the same time.; 2352///; 2353/// This function is far more powerful than the old Branch; 2354/// function. It supports the full C++, including STL and has; 2355/// the same behaviour in split or non-split mode. classname does; 2356/// not have to derive from TObject. The function is based on; 2357/// the new TStreamerInfo.; 2358///; 2359/// Build a TBranchElement for an object of class classname.; 2360///; 2361/// addr is the address of a pointer to an object of class; 2362/// classname. The class dictionary must be available (ClassDef; 2363/// in class header).; 2364///; 2365/// Note: See the comments in TBranchElement::SetAddress() for a more; 2366/// detailed discussion of the meaning of the addr parameter.; 2367///; 2368/// This option requires access to the library where the; 2369/// corresponding class is defined. Accessing one single data; 2370/// member in the object implies reading the full object.; 2371///; 2372/// By default the branch buffers are stored in the same file as the Tree.; 2373/// use TBranch::SetFile to specify a different file; 2374///; 2375/// IMPORTANT NOTE about branch names:; 2376///; 2377/// And in general, in case two or more master branches contain subbranches; 2378/// with identical names, one must add a ""."" (dot) character at the end; 2379/// of the master branch name. This will force the name of the subbranches; 2380/// to be of the form `master.subbranch` instead of simply `subbranch`.; 2381/// This situation happens when the top level object; 2382/// has two or more members referencing the same class.; 2383/// For example, if a Tree has two branches B1 and B2 corresponding; 2384/// to objects of the same class MyClass, one can do:; 2385/// ~~~ {.cpp}; 2386/// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; 2387/// ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:95324,Security,access,access,95324,"r at the end; 2379/// of the master branch name. This will force the name of the subbranches; 2380/// to be of the form `master.subbranch` instead of simply `subbranch`.; 2381/// This situation happens when the top level object; 2382/// has two or more members referencing the same class.; 2383/// For example, if a Tree has two branches B1 and B2 corresponding; 2384/// to objects of the same class MyClass, one can do:; 2385/// ~~~ {.cpp}; 2386/// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; 2387/// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; 2388/// ~~~; 2389/// if MyClass has 3 members a,b,c, the two instructions above will generate; 2390/// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; 2391///; 2392/// bufsize is the buffer size in bytes for this branch; 2393/// The default value is 32000 bytes and should be ok for most cases.; 2394/// You can specify a larger value (e.g. 256000) if your Tree is not split; 2395/// and each entry is large (Megabytes); 2396/// A small value for bufsize is optimum if you intend to access; 2397/// the entries in the Tree randomly and your Tree is in split mode.; 2398///; 2399/// Use splitlevel < 0 instead of splitlevel=0 when the class; 2400/// has a custom Streamer; 2401///; 2402/// Note: if the split level is set to the default (99), TTree::Branch will; 2403/// not issue a warning if the class can not be split.; 2404 ; 2405TBranch* TTree::Bronch(const char* name, const char* classname, void* addr, Int_t bufsize /* = 32000 */, Int_t splitlevel /* = 99 */); 2406{; 2407 return BronchExec(name, classname, addr, true, bufsize, splitlevel);; 2408}; 2409 ; 2410////////////////////////////////////////////////////////////////////////////////; 2411/// Helper function implementing TTree::Bronch and TTree::Branch(const char *name, T &obj);; 2412 ; 2413TBranch* TTree::BronchExec(const char* name, const char* classname, void* addr, bool isptrptr, Int_t bufsize /* = 32000 */, Int_t splitlevel /* = 99 */); 2414{; 2415 TClass* cl = TClass::GetClas",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:156969,Security,access,access,156969,"Therefore changing the pad to log scale along Z as no effect; 3943/// on the colors.; 3944/// - if expression has more than four fields the option ""PARA""or ""CANDLE""; 3945/// can be used.; 3946/// - If option contains the string ""goff"", no graphics is generated.; 3947/// \endparblock; 3948/// \param [in] nentries The number of entries to process (default is all); 3949/// \param [in] firstentry The first entry to process (default is 0); 3950///; 3951/// ### Drawing expressions using arrays and array elements; 3952///; 3953/// Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array,; 3954/// or a TClonesArray.; 3955/// In a TTree::Draw expression you can now access fMatrix using the following; 3956/// syntaxes:; 3957///; 3958/// | String passed | What is used for each entry of the tree; 3959/// |-----------------|--------------------------------------------------------|; 3960/// | `fMatrix` | the 9 elements of fMatrix |; 3961/// | `fMatrix[][]` | the 9 elements of fMatrix |; 3962/// | `fMatrix[2][2]` | only the elements fMatrix[2][2] |; 3963/// | `fMatrix[1]` | the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] |; 3964/// | `fMatrix[1][]` | the 3 elements fMatrix[1][0], fMatrix[1][1] and fMatrix[1][2] |; 3965/// | `fMatrix[][0]` | the 3 elements fMatrix[0][0], fMatrix[1][0] and fMatrix[2][0] |; 3966///; 3967/// ""fEvent.fMatrix...."" same as ""fMatrix..."" (unless there is more than one leaf named fMatrix!).; 3968///; 3969/// In summary, if a specific index is not specified for a dimension, TTree::Draw; 3970/// will loop through all the indices along this dimension. Leaving off the; 3971/// last (right most) dimension of specifying then with the two characters '[]'; 3972/// is equivalent. For variable size arrays (and TClonesArray) the range; 3973/// of the first dimension is recalculated for each entry of the tree.; 3974/// You can also specify the index as an expression of any other variables from the; 3975/// tree.; 3976///; 3977/// TTree::D",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:162635,Security,access,access,162635,"ith the default drawing option (`""""`),; 4047/// a cloud of points is drawn and the histogram `htemp` is not filled. For all the other; 4048/// drawing options `htemp` will be filled.; 4049///; 4050/// In all cases `htemp` can be retrieved by calling:; 4051///; 4052/// ~~~ {.cpp}; 4053/// auto htemp = (TH1F*)gPad->GetPrimitive(""htemp""); // 1D; 4054/// auto htemp = (TH2F*)gPad->GetPrimitive(""htemp""); // 2D; 4055/// auto htemp = (TH3F*)gPad->GetPrimitive(""htemp""); // 3D; 4056/// ~~~; 4057///; 4058/// In the two dimensional case (`Draw(""e1;e2"")`), with the default drawing option, the; 4059/// data is filled into a TGraph named `Graph`. This TGraph can be retrieved by; 4060/// calling; 4061///; 4062/// ~~~ {.cpp}; 4063/// auto graph = (TGraph*)gPad->GetPrimitive(""Graph"");; 4064/// ~~~; 4065///; 4066/// For the three and four dimensional cases, with the default drawing option, an unnamed; 4067/// TPolyMarker3D is produced, and therefore cannot be retrieved.; 4068///; 4069/// In all cases `htemp` can be used to access the axes. For instance in the 2D case:; 4070///; 4071/// ~~~ {.cpp}; 4072/// auto htemp = (TH2F*)gPad->GetPrimitive(""htemp"");; 4073/// auto xaxis = htemp->GetXaxis();; 4074/// ~~~; 4075///; 4076/// When the option `""A""` is used (with TGraph painting option) to draw a 2D; 4077/// distribution:; 4078/// ~~~ {.cpp}; 4079/// tree.Draw(""e1:e2"","""",""A*"");; 4080/// ~~~; 4081/// a scatter plot is produced (with stars in that case) but the axis creation is; 4082/// delegated to TGraph and `htemp` is not created.; 4083///; 4084/// ### Saving the result of Draw to a histogram; 4085///; 4086/// If `varexp` contains `>>hnew` (following the variable(s) name(s)),; 4087/// the new histogram called `hnew` is created and it is kept in the current; 4088/// directory (and also the current pad). This works for all dimensions.; 4089///; 4090/// Example:; 4091/// ~~~ {.cpp}; 4092/// tree.Draw(""sqrt(x)>>hsqrt"",""y>0""); 4093/// ~~~; 4094/// will draw `sqrt(x)` and save the histogram as ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:165996,Security,access,access,165996,"e is ignored, when the name is followed by; 4130/// binning information as described in the previous paragraph.; 4131/// ~~~ {.cpp}; 4132/// tree.Draw(""sqrt(x)>>+hsqrt"",""y>0""); 4133/// ~~~; 4134/// will not reset `hsqrt`, but will continue filling. This works for 1-D, 2-D; 4135/// and 3-D histograms.; 4136///; 4137/// ### Accessing collection objects; 4138///; 4139/// TTree::Draw default's handling of collections is to assume that any; 4140/// request on a collection pertain to it content. For example, if fTracks; 4141/// is a collection of Track objects, the following:; 4142/// ~~~ {.cpp}; 4143/// tree->Draw(""event.fTracks.fPx"");; 4144/// ~~~; 4145/// will plot the value of fPx for each Track objects inside the collection.; 4146/// Also; 4147/// ~~~ {.cpp}; 4148/// tree->Draw(""event.fTracks.size()"");; 4149/// ~~~; 4150/// would plot the result of the member function Track::size() for each; 4151/// Track object inside the collection.; 4152/// To access information about the collection itself, TTree::Draw support; 4153/// the '@' notation. If a variable which points to a collection is prefixed; 4154/// or postfixed with '@', the next part of the expression will pertain to; 4155/// the collection object. For example:; 4156/// ~~~ {.cpp}; 4157/// tree->Draw(""event.@fTracks.size()"");; 4158/// ~~~; 4159/// will plot the size of the collection referred to by `fTracks` (i.e the number; 4160/// of Track objects).; 4161///; 4162/// ### Drawing 'objects'; 4163///; 4164/// When a class has a member function named AsDouble or AsString, requesting; 4165/// to directly draw the object will imply a call to one of the 2 functions.; 4166/// If both AsDouble and AsString are present, AsDouble will be used.; 4167/// AsString can return either a char*, a std::string or a TString.s; 4168/// For example, the following; 4169/// ~~~ {.cpp}; 4170/// tree->Draw(""event.myTTimeStamp"");; 4171/// ~~~; 4172/// will draw the same histogram as; 4173/// ~~~ {.cpp}; 4174/// tree->Draw(""event.myTTimeSt",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:168034,Security,access,access,168034,"ram as; 4173/// ~~~ {.cpp}; 4174/// tree->Draw(""event.myTTimeStamp.AsDouble()"");; 4175/// ~~~; 4176/// In addition, when the object is a type TString or std::string, TTree::Draw; 4177/// will call respectively `TString::Data` and `std::string::c_str()`; 4178///; 4179/// If the object is a TBits, the histogram will contain the index of the bit; 4180/// that are turned on.; 4181///; 4182/// ### Retrieving information about the tree itself.; 4183///; 4184/// You can refer to the tree (or chain) containing the data by using the; 4185/// string 'This'.; 4186/// You can then could any TTree methods. For example:; 4187/// ~~~ {.cpp}; 4188/// tree->Draw(""This->GetReadEntry()"");; 4189/// ~~~; 4190/// will display the local entry numbers be read.; 4191/// ~~~ {.cpp}; 4192/// tree->Draw(""This->GetUserInfo()->At(0)->GetName()"");; 4193/// ~~~; 4194/// will display the name of the first 'user info' object.; 4195///; 4196/// ### Special functions and variables; 4197///; 4198/// `Entry$`: A TTree::Draw formula can use the special variable `Entry$`; 4199/// to access the entry number being read. For example to draw every; 4200/// other entry use:; 4201/// ~~~ {.cpp}; 4202/// tree.Draw(""myvar"",""Entry$%2==0"");; 4203/// ~~~; 4204/// - `Entry$` : return the current entry number (`== TTree::GetReadEntry()`); 4205/// - `LocalEntry$` : return the current entry number in the current tree of a; 4206/// chain (`== GetTree()->GetReadEntry()`); 4207/// - `Entries$` : return the total number of entries (== TTree::GetEntries()); 4208/// - `LocalEntries$` : return the total number of entries in the current tree; 4209/// of a chain (== GetTree()->TTree::GetEntries()); 4210/// - `Length$` : return the total number of element of this formula for this; 4211/// entry (`==TTreeFormula::GetNdata()`); 4212/// - `Iteration$` : return the current iteration over this formula for this; 4213/// entry (i.e. varies from 0 to `Length$`).; 4214/// - `Length$(formula )` : return the total number of element of the f",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:171780,Security,access,accessing,171780,"arr3[2]"");; 4249/// ~~~; 4250/// will draw the sum arr3 for the index 0 to 2 only if the; 4251/// actual_size_of_arr3 is greater or equal to 3.; 4252/// Note that the array in 'primary' is flattened/linearized thus using; 4253/// `Alt$` with multi-dimensional arrays of different dimensions in unlikely; 4254/// to yield the expected results. To visualize a bit more what elements; 4255/// would be matched by TTree::Draw, TTree::Scan can be used:; 4256/// ~~~ {.cpp}; 4257/// tree->Scan(""arr1:Alt$(arr2,0)"");; 4258/// ~~~; 4259/// will print on one line the value of arr1 and (arr2,0) that will be; 4260/// matched by; 4261/// ~~~ {.cpp}; 4262/// tree->Draw(""arr1-Alt$(arr2,0)"");; 4263/// ~~~; 4264/// The ternary operator is not directly supported in TTree::Draw however, to plot the; 4265/// equivalent of `var2<20 ? -99 : var1`, you can use:; 4266/// ~~~ {.cpp}; 4267/// tree->Draw(""(var2<20)*99+(var2>=20)*var1"","""");; 4268/// ~~~; 4269///; 4270/// ### Drawing a user function accessing the TTree data directly; 4271///; 4272/// If the formula contains a file name, TTree::MakeProxy will be used; 4273/// to load and execute this file. In particular it will draw the; 4274/// result of a function with the same name as the file. The function; 4275/// will be executed in a context where the name of the branches can; 4276/// be used as a C++ variable.; 4277///; 4278/// For example draw px using the file hsimple.root (generated by the; 4279/// hsimple.C tutorial), we need a file named hsimple.cxx:; 4280/// ~~~ {.cpp}; 4281/// double hsimple() {; 4282/// return px;; 4283/// }; 4284/// ~~~; 4285/// MakeProxy can then be used indirectly via the TTree::Draw interface; 4286/// as follow:; 4287/// ~~~ {.cpp}; 4288/// new TFile(""hsimple.root""); 4289/// ntuple->Draw(""hsimple.cxx"");; 4290/// ~~~; 4291/// A more complete example is available in the tutorials directory:; 4292/// `h1analysisProxy.cxx`, `h1analysProxy.h` and `h1analysisProxyCut.C`; 4293/// which reimplement the selector found in `",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:179954,Security,access,access,179954," {.cpp}; 4429/// tree.Draw("">>pyplus"",""fTracks.fPy>0"");; 4430/// pyplus->SetReapplyCut(true);; 4431/// tree->SetEventList(pyplus);; 4432/// tree->Draw(""fTracks.fPy"");; 4433/// ~~~; 4434/// will draw the fPy of only the tracks that have a positive fPy.; 4435///; 4436/// To draw only the elements that match a selection in case of arrays,; 4437/// you can also use TEntryListArray (faster in case of a more general selection).; 4438///; 4439/// Example:; 4440/// ~~~ {.cpp}; 4441/// tree.Draw("">>pyplus"",""fTracks.fPy>0"", ""entrylistarray"");; 4442/// tree->SetEntryList(pyplus);; 4443/// tree->Draw(""fTracks.fPy"");; 4444/// ~~~; 4445/// will draw the fPy of only the tracks that have a positive fPy,; 4446/// but without redoing the selection.; 4447///; 4448/// Note: Use tree->SetEventList(0) if you do not want use the list as input.; 4449///; 4450/// ### How to obtain more info from TTree::Draw; 4451///; 4452/// Once TTree::Draw has been called, it is possible to access useful; 4453/// information still stored in the TTree object via the following functions:; 4454///; 4455/// - GetSelectedRows() // return the number of values accepted by the selection expression. In case where no selection was specified, returns the number of values processed.; 4456/// - GetV1() // returns a pointer to the double array of V1; 4457/// - GetV2() // returns a pointer to the double array of V2; 4458/// - GetV3() // returns a pointer to the double array of V3; 4459/// - GetV4() // returns a pointer to the double array of V4; 4460/// - GetW() // returns a pointer to the double array of Weights where weight equal the result of the selection expression.; 4461///; 4462/// where V1,V2,V3 correspond to the expressions in; 4463/// ~~~ {.cpp}; 4464/// TTree::Draw(""V1:V2:V3:V4"",selection);; 4465/// ~~~; 4466/// If the expression has more than 4 component use GetVal(index); 4467///; 4468/// Example:; 4469/// ~~~ {.cpp}; 4470/// Root > ntuple->Draw(""py:px"",""pz>4"");; 4471/// Root > TGraph *gr = new TGraph(ntuple",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:252129,Security,access,access,252129,"KeepCircular(maxEntries);; 6423 }; 6424 if (fNClusterRange) {; 6425 Long64_t entriesOffset = fEntries - maxEntries;; 6426 Int_t oldsize = fNClusterRange;; 6427 for(Int_t i = 0, j = 0; j < oldsize; ++j) {; 6428 if (fClusterRangeEnd[j] > entriesOffset) {; 6429 fClusterRangeEnd[i] = fClusterRangeEnd[j] - entriesOffset;; 6430 ++i;; 6431 } else {; 6432 --fNClusterRange;; 6433 }; 6434 }; 6435 }; 6436 fEntries = maxEntries;; 6437 fReadEntry = -1;; 6438}; 6439 ; 6440////////////////////////////////////////////////////////////////////////////////; 6441/// Read in memory all baskets from all branches up to the limit of maxmemory bytes.; 6442///; 6443/// If maxmemory is non null and positive SetMaxVirtualSize is called; 6444/// with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; 6445/// The function returns the total number of baskets read into memory; 6446/// if negative an error occurred while loading the branches.; 6447/// This method may be called to force branch baskets in memory; 6448/// when random access to branch entries is required.; 6449/// If random access to only a few branches is required, you should; 6450/// call directly TBranch::LoadBaskets.; 6451 ; 6452Int_t TTree::LoadBaskets(Long64_t maxmemory); 6453{; 6454 if (maxmemory > 0) SetMaxVirtualSize(maxmemory);; 6455 ; 6456 TIter next(GetListOfLeaves());; 6457 TLeaf *leaf;; 6458 Int_t nimported = 0;; 6459 while ((leaf=(TLeaf*)next())) {; 6460 nimported += leaf->GetBranch()->LoadBaskets();//break;; 6461 }; 6462 return nimported;; 6463}; 6464 ; 6465////////////////////////////////////////////////////////////////////////////////; 6466/// Set current entry.; 6467///; 6468/// Returns -2 if entry does not exist (just as TChain::LoadTree()).; 6469/// Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; 6470///; 6471/// Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; 6472///; 6473/// \note This function is overloaded in TC",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:252186,Security,access,access,252186,"nt_t oldsize = fNClusterRange;; 6427 for(Int_t i = 0, j = 0; j < oldsize; ++j) {; 6428 if (fClusterRangeEnd[j] > entriesOffset) {; 6429 fClusterRangeEnd[i] = fClusterRangeEnd[j] - entriesOffset;; 6430 ++i;; 6431 } else {; 6432 --fNClusterRange;; 6433 }; 6434 }; 6435 }; 6436 fEntries = maxEntries;; 6437 fReadEntry = -1;; 6438}; 6439 ; 6440////////////////////////////////////////////////////////////////////////////////; 6441/// Read in memory all baskets from all branches up to the limit of maxmemory bytes.; 6442///; 6443/// If maxmemory is non null and positive SetMaxVirtualSize is called; 6444/// with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; 6445/// The function returns the total number of baskets read into memory; 6446/// if negative an error occurred while loading the branches.; 6447/// This method may be called to force branch baskets in memory; 6448/// when random access to branch entries is required.; 6449/// If random access to only a few branches is required, you should; 6450/// call directly TBranch::LoadBaskets.; 6451 ; 6452Int_t TTree::LoadBaskets(Long64_t maxmemory); 6453{; 6454 if (maxmemory > 0) SetMaxVirtualSize(maxmemory);; 6455 ; 6456 TIter next(GetListOfLeaves());; 6457 TLeaf *leaf;; 6458 Int_t nimported = 0;; 6459 while ((leaf=(TLeaf*)next())) {; 6460 nimported += leaf->GetBranch()->LoadBaskets();//break;; 6461 }; 6462 return nimported;; 6463}; 6464 ; 6465////////////////////////////////////////////////////////////////////////////////; 6466/// Set current entry.; 6467///; 6468/// Returns -2 if entry does not exist (just as TChain::LoadTree()).; 6469/// Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; 6470///; 6471/// Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; 6472///; 6473/// \note This function is overloaded in TChain.; 6474Long64_t TTree::LoadTree(Long64_t entry); 6475{; 6476 // We have already been visited while recursively looking;",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:259749,Security,access,access,259749," branches addresses,; 6628/// - A skeleton for the entry loop.; 6629///; 6630/// To use this function:; 6631///; 6632/// - Open your Tree file (eg: TFile f(""myfile.root"");); 6633/// - T->MakeCode(""MyAnalysis.C"");; 6634///; 6635/// where T is the name of the TTree in file myfile.root; 6636/// and MyAnalysis.C the name of the file created by this function.; 6637///; 6638/// NOTE: Since the implementation of this function, a new and better; 6639/// function TTree::MakeClass() has been developed.; 6640 ; 6641Int_t TTree::MakeCode(const char* filename); 6642{; 6643 Warning(""MakeCode"", ""MakeCode is obsolete. Use MakeClass or MakeSelector instead"");; 6644 ; 6645 GetPlayer();; 6646 if (!fPlayer) return 0;; 6647 return fPlayer->MakeCode(filename);; 6648}; 6649 ; 6650////////////////////////////////////////////////////////////////////////////////; 6651/// Generate a skeleton analysis class for this Tree using TBranchProxy.; 6652///; 6653/// TBranchProxy is the base of a class hierarchy implementing an; 6654/// indirect access to the content of the branches of a TTree.; 6655///; 6656/// ""proxyClassname"" is expected to be of the form:; 6657/// ~~~ {.cpp}; 6658/// [path/]fileprefix; 6659/// ~~~; 6660/// The skeleton will then be generated in the file:; 6661/// ~~~ {.cpp}; 6662/// fileprefix.h; 6663/// ~~~; 6664/// located in the current directory or in 'path/' if it is specified.; 6665/// The class generated will be named 'fileprefix'; 6666///; 6667/// ""macrofilename"" and optionally ""cutfilename"" are expected to point; 6668/// to source files which will be included by the generated skeleton.; 6669/// Method of the same name as the file(minus the extension and path); 6670/// will be called by the generated skeleton's Process method as follow:; 6671/// ~~~ {.cpp}; 6672/// [if (cutfilename())] htemp->Fill(macrofilename());; 6673/// ~~~; 6674/// ""option"" can be used select some of the optional features during; 6675/// the code generation. The possible options are:; 6676///; 6677/// ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:260984,Security,access,access,260984," 6662/// fileprefix.h; 6663/// ~~~; 6664/// located in the current directory or in 'path/' if it is specified.; 6665/// The class generated will be named 'fileprefix'; 6666///; 6667/// ""macrofilename"" and optionally ""cutfilename"" are expected to point; 6668/// to source files which will be included by the generated skeleton.; 6669/// Method of the same name as the file(minus the extension and path); 6670/// will be called by the generated skeleton's Process method as follow:; 6671/// ~~~ {.cpp}; 6672/// [if (cutfilename())] htemp->Fill(macrofilename());; 6673/// ~~~; 6674/// ""option"" can be used select some of the optional features during; 6675/// the code generation. The possible options are:; 6676///; 6677/// - nohist : indicates that the generated ProcessFill should not fill the histogram.; 6678///; 6679/// 'maxUnrolling' controls how deep in the class hierarchy does the; 6680/// system 'unroll' classes that are not split. Unrolling a class; 6681/// allows direct access to its data members (this emulates the behavior; 6682/// of TTreeFormula).; 6683///; 6684/// The main features of this skeleton are:; 6685///; 6686/// * on-demand loading of branches; 6687/// * ability to use the 'branchname' as if it was a data member; 6688/// * protection against array out-of-bounds errors; 6689/// * ability to use the branch data as an object (when the user code is available); 6690///; 6691/// For example with Event.root, if; 6692/// ~~~ {.cpp}; 6693/// Double_t somePx = fTracks.fPx[2];; 6694/// ~~~; 6695/// is executed by one of the method of the skeleton,; 6696/// somePx will updated with the current value of fPx of the 3rd track.; 6697///; 6698/// Both macrofilename and the optional cutfilename are expected to be; 6699/// the name of source files which contain at least a free standing; 6700/// function with the signature:; 6701/// ~~~ {.cpp}; 6702/// x_t macrofilename(); // i.e function with the same name as the file; 6703/// ~~~; 6704/// and; 6705/// ~~~ {.cpp}; 6706/// y_t ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:263887,Security,access,accessible,263887,"7/// macrofilename_methodname in each of 6 main selector methods if the method; 6728/// macrofilename_methodname exist (Where macrofilename is stripped of its; 6729/// extension).; 6730///; 6731/// Concretely, with the script named h1analysisProxy.C,; 6732///; 6733/// - The method calls the method (if it exist); 6734/// - Begin -> void h1analysisProxy_Begin(TTree*);; 6735/// - SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; 6736/// - Notify -> bool h1analysisProxy_Notify();; 6737/// - Process -> bool h1analysisProxy_Process(Long64_t);; 6738/// - SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; 6739/// - Terminate -> void h1analysisProxy_Terminate();; 6740///; 6741/// If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; 6742/// it is included before the declaration of the proxy class. This can; 6743/// be used in particular to insure that the include files needed by; 6744/// the macro file are properly loaded.; 6745///; 6746/// The default histogram is accessible via the variable named 'htemp'.; 6747///; 6748/// If the library of the classes describing the data in the branch is; 6749/// loaded, the skeleton will add the needed `include` statements and; 6750/// give the ability to access the object stored in the branches.; 6751///; 6752/// To draw px using the file hsimple.root (generated by the; 6753/// hsimple.C tutorial), we need a file named hsimple.cxx:; 6754/// ~~~ {.cpp}; 6755/// double hsimple() {; 6756/// return px;; 6757/// }; 6758/// ~~~; 6759/// MakeProxy can then be used indirectly via the TTree::Draw interface; 6760/// as follow:; 6761/// ~~~ {.cpp}; 6762/// new TFile(""hsimple.root""); 6763/// ntuple->Draw(""hsimple.cxx"");; 6764/// ~~~; 6765/// A more complete example is available in the tutorials directory:; 6766/// h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; 6767/// which reimplement the selector found in h1analysis.C; 6768 ; 6769Int_t TTree::MakeProxy(const char* proxyClassname, const char* macrofil",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:264119,Security,access,access,264119,"; 6729/// extension).; 6730///; 6731/// Concretely, with the script named h1analysisProxy.C,; 6732///; 6733/// - The method calls the method (if it exist); 6734/// - Begin -> void h1analysisProxy_Begin(TTree*);; 6735/// - SlaveBegin -> void h1analysisProxy_SlaveBegin(TTree*);; 6736/// - Notify -> bool h1analysisProxy_Notify();; 6737/// - Process -> bool h1analysisProxy_Process(Long64_t);; 6738/// - SlaveTerminate -> void h1analysisProxy_SlaveTerminate();; 6739/// - Terminate -> void h1analysisProxy_Terminate();; 6740///; 6741/// If a file name macrofilename.h (or .hh, .hpp, .hxx, .hPP, .hXX) exist; 6742/// it is included before the declaration of the proxy class. This can; 6743/// be used in particular to insure that the include files needed by; 6744/// the macro file are properly loaded.; 6745///; 6746/// The default histogram is accessible via the variable named 'htemp'.; 6747///; 6748/// If the library of the classes describing the data in the branch is; 6749/// loaded, the skeleton will add the needed `include` statements and; 6750/// give the ability to access the object stored in the branches.; 6751///; 6752/// To draw px using the file hsimple.root (generated by the; 6753/// hsimple.C tutorial), we need a file named hsimple.cxx:; 6754/// ~~~ {.cpp}; 6755/// double hsimple() {; 6756/// return px;; 6757/// }; 6758/// ~~~; 6759/// MakeProxy can then be used indirectly via the TTree::Draw interface; 6760/// as follow:; 6761/// ~~~ {.cpp}; 6762/// new TFile(""hsimple.root""); 6763/// ntuple->Draw(""hsimple.cxx"");; 6764/// ~~~; 6765/// A more complete example is available in the tutorials directory:; 6766/// h1analysisProxy.cxx , h1analysProxy.h and h1analysisProxyCut.C; 6767/// which reimplement the selector found in h1analysis.C; 6768 ; 6769Int_t TTree::MakeProxy(const char* proxyClassname, const char* macrofilename, const char* cutfilename, const char* option, Int_t maxUnrolling); 6770{; 6771 GetPlayer();; 6772 if (!fPlayer) return 0;; 6773 return fPlayer->MakeProxy",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:354848,Security,access,access,354848,"e setting the file name; 9153 ; 9154void TTree::SetFileNumber(Int_t number); 9155{; 9156 if (fFileNumber < 0) {; 9157 Warning(""SetFileNumber"", ""file number must be positive. Set to 0"");; 9158 fFileNumber = 0;; 9159 return;; 9160 }; 9161 fFileNumber = number;; 9162}; 9163 ; 9164////////////////////////////////////////////////////////////////////////////////; 9165/// Set all the branches in this TTree to be in decomposed object mode; 9166/// (also known as MakeClass mode).; 9167///; 9168/// For MakeClass mode 0, the TTree expects the address where the data is stored; 9169/// to be set by either the user or the TTree to the address of a full object; 9170/// through the top level branch.; 9171/// For MakeClass mode 1, this address is expected to point to a numerical type; 9172/// or C-style array (variable or not) of numerical type, representing the; 9173/// primitive data members.; 9174/// The function's primary purpose is to allow the user to access the data; 9175/// directly with numerical type variable rather than having to have the original; 9176/// set of classes (or a reproduction thereof).; 9177 ; 9178void TTree::SetMakeClass(Int_t make); 9179{; 9180 fMakeClass = make;; 9181 ; 9182 Int_t nb = fBranches.GetEntriesFast();; 9183 for (Int_t i = 0; i < nb; ++i) {; 9184 TBranch* branch = (TBranch*) fBranches.UncheckedAt(i);; 9185 branch->SetMakeClass(make);; 9186 }; 9187}; 9188 ; 9189////////////////////////////////////////////////////////////////////////////////; 9190/// Set the maximum size in bytes of a Tree file (static function).; 9191/// The default size is 100000000000LL, ie 100 Gigabytes.; 9192///; 9193/// In TTree::Fill, when the file has a size > fgMaxTreeSize,; 9194/// the function closes the current file and starts writing into; 9195/// a new file with a name of the style ""file_1.root"" if the original; 9196/// requested file name was ""file.root"".; 9197 ; 9198void TTree::SetMaxTreeSize(Long64_t maxsize); 9199{; 9200 fgMaxTreeSize = maxsize;; 9201}; 9202 ; 9",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:356196,Security,hash,hashlists,356196," (TBranch*) fBranches.UncheckedAt(i);; 9185 branch->SetMakeClass(make);; 9186 }; 9187}; 9188 ; 9189////////////////////////////////////////////////////////////////////////////////; 9190/// Set the maximum size in bytes of a Tree file (static function).; 9191/// The default size is 100000000000LL, ie 100 Gigabytes.; 9192///; 9193/// In TTree::Fill, when the file has a size > fgMaxTreeSize,; 9194/// the function closes the current file and starts writing into; 9195/// a new file with a name of the style ""file_1.root"" if the original; 9196/// requested file name was ""file.root"".; 9197 ; 9198void TTree::SetMaxTreeSize(Long64_t maxsize); 9199{; 9200 fgMaxTreeSize = maxsize;; 9201}; 9202 ; 9203////////////////////////////////////////////////////////////////////////////////; 9204/// Change the name of this tree.; 9205 ; 9206void TTree::SetName(const char* name); 9207{; 9208 if (gPad) {; 9209 gPad->Modified();; 9210 }; 9211 // Trees are named objects in a THashList.; 9212 // We must update hashlists if we change the name.; 9213 TFile *file = nullptr;; 9214 TTreeCache *pf = nullptr;; 9215 if (fDirectory) {; 9216 fDirectory->Remove(this);; 9217 if ((file = GetCurrentFile())) {; 9218 pf = GetReadCache(file);; 9219 file->SetCacheRead(nullptr,this,TFile::kDoNotDisconnect);; 9220 }; 9221 }; 9222 // This changes our hash value.; 9223 fName = name;; 9224 if (fDirectory) {; 9225 fDirectory->Append(this);; 9226 if (pf) {; 9227 file->SetCacheRead(pf,this,TFile::kDoNotDisconnect);; 9228 }; 9229 }; 9230}; 9231 ; 9232void TTree::SetNotify(TObject *obj); 9233{; 9234 if (obj && fNotify && dynamic_cast<TNotifyLinkBase *>(fNotify)) {; 9235 auto *oldLink = static_cast<TNotifyLinkBase *>(fNotify);; 9236 auto *newLink = dynamic_cast<TNotifyLinkBase *>(obj);; 9237 if (!newLink) {; 9238 Warning(""TTree::SetNotify"",; 9239 ""The tree or chain already has a fNotify registered and it is a TNotifyLink, while the new object is ""; 9240 ""not a TNotifyLink. Setting fNotify to the new value will lead to an or",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:356522,Security,hash,hash,356522,"9190/// Set the maximum size in bytes of a Tree file (static function).; 9191/// The default size is 100000000000LL, ie 100 Gigabytes.; 9192///; 9193/// In TTree::Fill, when the file has a size > fgMaxTreeSize,; 9194/// the function closes the current file and starts writing into; 9195/// a new file with a name of the style ""file_1.root"" if the original; 9196/// requested file name was ""file.root"".; 9197 ; 9198void TTree::SetMaxTreeSize(Long64_t maxsize); 9199{; 9200 fgMaxTreeSize = maxsize;; 9201}; 9202 ; 9203////////////////////////////////////////////////////////////////////////////////; 9204/// Change the name of this tree.; 9205 ; 9206void TTree::SetName(const char* name); 9207{; 9208 if (gPad) {; 9209 gPad->Modified();; 9210 }; 9211 // Trees are named objects in a THashList.; 9212 // We must update hashlists if we change the name.; 9213 TFile *file = nullptr;; 9214 TTreeCache *pf = nullptr;; 9215 if (fDirectory) {; 9216 fDirectory->Remove(this);; 9217 if ((file = GetCurrentFile())) {; 9218 pf = GetReadCache(file);; 9219 file->SetCacheRead(nullptr,this,TFile::kDoNotDisconnect);; 9220 }; 9221 }; 9222 // This changes our hash value.; 9223 fName = name;; 9224 if (fDirectory) {; 9225 fDirectory->Append(this);; 9226 if (pf) {; 9227 file->SetCacheRead(pf,this,TFile::kDoNotDisconnect);; 9228 }; 9229 }; 9230}; 9231 ; 9232void TTree::SetNotify(TObject *obj); 9233{; 9234 if (obj && fNotify && dynamic_cast<TNotifyLinkBase *>(fNotify)) {; 9235 auto *oldLink = static_cast<TNotifyLinkBase *>(fNotify);; 9236 auto *newLink = dynamic_cast<TNotifyLinkBase *>(obj);; 9237 if (!newLink) {; 9238 Warning(""TTree::SetNotify"",; 9239 ""The tree or chain already has a fNotify registered and it is a TNotifyLink, while the new object is ""; 9240 ""not a TNotifyLink. Setting fNotify to the new value will lead to an orphan linked list of ""; 9241 ""TNotifyLinks and it is most likely not intended. If this is the intended goal, please call ""; 9242 ""SetNotify(nullptr) first to silence this warning."");",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:358535,Security,hash,hashlists,358535," 9246 // Otherwise newLink and oldLink are unrelated:; 9247 Warning(""TTree::SetNotify"",; 9248 ""The tree or chain already has a TNotifyLink registered, and the new TNotifyLink `obj` does not link ""; 9249 ""to it. Setting fNotify to the new value will lead to an orphan linked list of TNotifyLinks and it is ""; 9250 ""most likely not intended. If this is the intended goal, please call SetNotify(nullptr) first to ""; 9251 ""silence this warning."");; 9252 }; 9253 }; 9254 ; 9255 fNotify = obj;; 9256}; 9257 ; 9258////////////////////////////////////////////////////////////////////////////////; 9259/// Change the name and title of this tree.; 9260 ; 9261void TTree::SetObject(const char* name, const char* title); 9262{; 9263 if (gPad) {; 9264 gPad->Modified();; 9265 }; 9266 ; 9267 // Trees are named objects in a THashList.; 9268 // We must update hashlists if we change the name; 9269 TFile *file = nullptr;; 9270 TTreeCache *pf = nullptr;; 9271 if (fDirectory) {; 9272 fDirectory->Remove(this);; 9273 if ((file = GetCurrentFile())) {; 9274 pf = GetReadCache(file);; 9275 file->SetCacheRead(nullptr,this,TFile::kDoNotDisconnect);; 9276 }; 9277 }; 9278 // This changes our hash value.; 9279 fName = name;; 9280 fTitle = title;; 9281 if (fDirectory) {; 9282 fDirectory->Append(this);; 9283 if (pf) {; 9284 file->SetCacheRead(pf,this,TFile::kDoNotDisconnect);; 9285 }; 9286 }; 9287}; 9288 ; 9289////////////////////////////////////////////////////////////////////////////////; 9290/// Enable or disable parallel unzipping of Tree buffers.; 9291 ; 9292void TTree::SetParallelUnzip(bool opt, Float_t RelSize); 9293{; 9294#ifdef R__USE_IMT; 9295 if (GetTree() == nullptr) {; 9296 LoadTree(GetReadEntry());; 9297 if (!GetTree()); 9298 return;; 9299 }; 9300 if (GetTree() != this) {; 9301 GetTree()->SetParallelUnzip(opt, RelSize);; 9302 return;; 9303 }; 9304 TFile* file = GetCurrentFile();; 9305 if (!file); 9306 return;; 9307 ; 9308 TTreeCache* pf = GetReadCache(file);; 9309 if (pf && !( opt ^ (nullptr != d",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:358860,Security,hash,hash,358860," 9246 // Otherwise newLink and oldLink are unrelated:; 9247 Warning(""TTree::SetNotify"",; 9248 ""The tree or chain already has a TNotifyLink registered, and the new TNotifyLink `obj` does not link ""; 9249 ""to it. Setting fNotify to the new value will lead to an orphan linked list of TNotifyLinks and it is ""; 9250 ""most likely not intended. If this is the intended goal, please call SetNotify(nullptr) first to ""; 9251 ""silence this warning."");; 9252 }; 9253 }; 9254 ; 9255 fNotify = obj;; 9256}; 9257 ; 9258////////////////////////////////////////////////////////////////////////////////; 9259/// Change the name and title of this tree.; 9260 ; 9261void TTree::SetObject(const char* name, const char* title); 9262{; 9263 if (gPad) {; 9264 gPad->Modified();; 9265 }; 9266 ; 9267 // Trees are named objects in a THashList.; 9268 // We must update hashlists if we change the name; 9269 TFile *file = nullptr;; 9270 TTreeCache *pf = nullptr;; 9271 if (fDirectory) {; 9272 fDirectory->Remove(this);; 9273 if ((file = GetCurrentFile())) {; 9274 pf = GetReadCache(file);; 9275 file->SetCacheRead(nullptr,this,TFile::kDoNotDisconnect);; 9276 }; 9277 }; 9278 // This changes our hash value.; 9279 fName = name;; 9280 fTitle = title;; 9281 if (fDirectory) {; 9282 fDirectory->Append(this);; 9283 if (pf) {; 9284 file->SetCacheRead(pf,this,TFile::kDoNotDisconnect);; 9285 }; 9286 }; 9287}; 9288 ; 9289////////////////////////////////////////////////////////////////////////////////; 9290/// Enable or disable parallel unzipping of Tree buffers.; 9291 ; 9292void TTree::SetParallelUnzip(bool opt, Float_t RelSize); 9293{; 9294#ifdef R__USE_IMT; 9295 if (GetTree() == nullptr) {; 9296 LoadTree(GetReadEntry());; 9297 if (!GetTree()); 9298 return;; 9299 }; 9300 if (GetTree() != this) {; 9301 GetTree()->SetParallelUnzip(opt, RelSize);; 9302 return;; 9303 }; 9304 TFile* file = GetCurrentFile();; 9305 if (!file); 9306 return;; 9307 ; 9308 TTreeCache* pf = GetReadCache(file);; 9309 if (pf && !( opt ^ (nullptr != d",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:403659,Security,checksum,checksum,403659,"he class inherits from TObject.Definition TClass.cxx:6005; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetConversionStreamerInfoTVirtualStreamerInfo * GetConversionStreamerInfo(const char *onfile_classname, Int_t version) constReturn a Conversion StreamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7260; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetActualClassTClass * GetActualClass(const void *object) constReturn a pointer to the real class of the object.Definition TClass.cxx:2674; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClass::WriteBufferInt_t WriteBuffer(TBuffer &b, void *pointer, const char *info="""")Function called by the Streamer functions to serialize object at p to buffer b.Definition TClass.cxx:6846; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::BypassStreamervoid BypassStreamer(Bool_t bypass=kTRUE)When the kBypassStreamer bit is set, the automatically generated Streamer can cal",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:403765,Security,checksum,checksum,403765,"he class inherits from TObject.Definition TClass.cxx:6005; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::InheritsFromBool_t InheritsFrom(const char *cl) const overrideReturn kTRUE if this class inherits from a class with name ""classname"".Definition TClass.cxx:4941; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetConversionStreamerInfoTVirtualStreamerInfo * GetConversionStreamerInfo(const char *onfile_classname, Int_t version) constReturn a Conversion StreamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::FindConversionStreamerInfoTVirtualStreamerInfo * FindConversionStreamerInfo(const char *onfile_classname, UInt_t checksum) constReturn a Conversion StreamerInfo from the class 'classname' for the layout represented by 'checksum' ...Definition TClass.cxx:7260; TClass::GetClassVersionVersion_t GetClassVersion() constDefinition TClass.h:420; TClass::GetActualClassTClass * GetActualClass(const void *object) constReturn a pointer to the real class of the object.Definition TClass.cxx:2674; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TClass::WriteBufferInt_t WriteBuffer(TBuffer &b, void *pointer, const char *info="""")Function called by the Streamer functions to serialize object at p to buffer b.Definition TClass.cxx:6846; TClonesArrayAn array of clone (identical) objects.Definition TClonesArray.h:29; TClonesArray::BypassStreamervoid BypassStreamer(Bool_t bypass=kTRUE)When the kBypassStreamer bit is set, the automatically generated Streamer can cal",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:428739,Security,access,access,428739,"h:296; TStyle::SetHistLineStylevoid SetHistLineStyle(Style_t styl=0)Definition TStyle.h:382; TStyle::GetHistFillStyleStyle_t GetHistFillStyle() constDefinition TStyle.h:234; TStyle::GetHistFillColorColor_t GetHistFillColor() constDefinition TStyle.h:232; TStyle::SetHistLineColorvoid SetHistLineColor(Color_t color=1)Definition TStyle.h:380; TStyle::GetHistLineStyleStyle_t GetHistLineStyle() constDefinition TStyle.h:235; TStyle::SetHistFillStylevoid SetHistFillStyle(Style_t styl=0)Definition TStyle.h:381; TStyle::GetHistLineWidthWidth_t GetHistLineWidth() constDefinition TStyle.h:236; TStyle::SetHistLineWidthvoid SetHistLineWidth(Width_t width=1)Definition TStyle.h:383; TSubStringA zero length substring is legal.Definition TString.h:85; TSubString::StringTString & String()Definition TString.h:124; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeCacheUnzipA TTreeCache which exploits parallelized decompression of its own content.Definition TTreeCacheUnzip.h:35; TTreeCacheUnzip::IsParallelUnzipstatic bool IsParallelUnzip()Static function that tells wether the multithreading unzipping is activated.Definition TTreeCacheUnzip.cxx:416; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::IsAutoCreatedbool IsAutoCreated() constDefinition TTreeCache.h:150; TTreeCache::SetBufferSizeInt_t SetBufferSize(Long64_t buffersize) overrideChange the underlying buffer size of the cache.Definition TTreeCache.cxx:2073; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2145; TTreeCache::GetTreeTTree * GetTree() constDefinition TTreeCache.",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:428773,Security,access,access,428773,"h:296; TStyle::SetHistLineStylevoid SetHistLineStyle(Style_t styl=0)Definition TStyle.h:382; TStyle::GetHistFillStyleStyle_t GetHistFillStyle() constDefinition TStyle.h:234; TStyle::GetHistFillColorColor_t GetHistFillColor() constDefinition TStyle.h:232; TStyle::SetHistLineColorvoid SetHistLineColor(Color_t color=1)Definition TStyle.h:380; TStyle::GetHistLineStyleStyle_t GetHistLineStyle() constDefinition TStyle.h:235; TStyle::SetHistFillStylevoid SetHistFillStyle(Style_t styl=0)Definition TStyle.h:381; TStyle::GetHistLineWidthWidth_t GetHistLineWidth() constDefinition TStyle.h:236; TStyle::SetHistLineWidthvoid SetHistLineWidth(Width_t width=1)Definition TStyle.h:383; TSubStringA zero length substring is legal.Definition TString.h:85; TSubString::StringTString & String()Definition TString.h:124; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeCacheUnzipA TTreeCache which exploits parallelized decompression of its own content.Definition TTreeCacheUnzip.h:35; TTreeCacheUnzip::IsParallelUnzipstatic bool IsParallelUnzip()Static function that tells wether the multithreading unzipping is activated.Definition TTreeCacheUnzip.cxx:416; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::IsAutoCreatedbool IsAutoCreated() constDefinition TTreeCache.h:150; TTreeCache::SetBufferSizeInt_t SetBufferSize(Long64_t buffersize) overrideChange the underlying buffer size of the cache.Definition TTreeCache.cxx:2073; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2145; TTreeCache::GetTreeTTree * GetTree() constDefinition TTreeCache.",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:985,Testability,test,tested,985,". ROOT: tree/tree/src/TTree.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TTree.cxx. Go to the documentation of this file. 1// @(#)root/tree:$Id$; 2// Author: Rene Brun 12/01/96; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11/**; 12 \defgroup tree Tree Library; 13 ; 14 In order to store columnar datasets, ROOT provides the TTree, TChain,; 15 TNtuple and TNtupleD classes.; 16 The TTree class represents a columnar dataset. Any C++ type can be stored in the; 17 columns. The TTree has allowed to store about **1 EB** of data coming from the LHC alone:; 18 it is demonstrated to scale and it's battle tested. It has been optimized during the years; 19 to reduce dataset sizes on disk and to deliver excellent runtime performance.; 20 It allows to access only part of the columns of the datasets, too.; 21 The TNtuple and TNtupleD classes are specialisations of the TTree class which can; 22 only hold single precision and double precision floating-point numbers respectively;; 23 The TChain is a collection of TTrees, which can be located also in different files.; 24 ; 25*/; 26 ; 27/** \class TTree; 28\ingroup tree; 29 ; 30A TTree represents a columnar dataset. Any C++ type can be stored in its columns.; 31 ; 32A TTree, often called in jargon *tree*, consists of a list of independent columns or *branches*,; 33represented by the TBranch class.; 34Behind each branch, buffers are allocated automatically by ROOT.; 35Such buffers are automatically written to disk or kept in memory until the size stored in the; 36attribute fMaxVirtualSize is reached.; 37Variables of one branch are written to the same buffer. A b",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:51502,Testability,assert,assert,51502,"Friend = CheckReshuffling(*this, *t);; 1378 if (!t->GetTreeIndex() && (t->GetEntries() < fEntries)) {; 1379 Warning(""AddFriend"", ""FriendElement %s in file %s has less entries %lld than its parent tree: %lld"", treename,; 1380 file->GetName(), t->GetEntries(), fEntries);; 1381 }; 1382 } else {; 1383 Error(""AddFriend"", ""Cannot find tree '%s' in file '%s', friend not added"", treename, file->GetName());; 1384 canAddFriend = false;; 1385 }; 1386 ; 1387 if (canAddFriend); 1388 fFriends->Add(fe);; 1389 return fe;; 1390}; 1391 ; 1392////////////////////////////////////////////////////////////////////////////////; 1393/// Add a TFriendElement to the list of friends.; 1394///; 1395/// The TTree is managed by the user (e.g., the user must delete the file).; 1396/// For a complete description see AddFriend(const char *, const char *).; 1397 ; 1398TFriendElement *TTree::AddFriend(TTree *tree, const char *alias, bool warn); 1399{; 1400 if (!tree) {; 1401 return nullptr;; 1402 }; 1403 if (!fFriends) {; 1404 fFriends = new TList();; 1405 }; 1406 TFriendElement *fe = new TFriendElement(this, tree, alias);; 1407 R__ASSERT(fe); // this assert is for historical reasons. Don't remove it unless you understand all the consequences.; 1408 TTree *t = fe->GetTree();; 1409 if (warn && (t->GetEntries() < fEntries)) {; 1410 Warning(""AddFriend"", ""FriendElement '%s' in file '%s' has less entries %lld than its parent tree: %lld"",; 1411 tree->GetName(), fe->GetFile() ? fe->GetFile()->GetName() : ""(memory resident)"", t->GetEntries(),; 1412 fEntries);; 1413 }; 1414 if (CheckReshuffling(*this, *t)); 1415 fFriends->Add(fe);; 1416 else; 1417 tree->RemoveExternalFriend(fe);; 1418 return fe;; 1419}; 1420 ; 1421////////////////////////////////////////////////////////////////////////////////; 1422/// AutoSave tree header every fAutoSave bytes.; 1423///; 1424/// When large Trees are produced, it is safe to activate the AutoSave; 1425/// procedure. Some branches may have buffers holding many entries.; 1426/// ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:53077,Testability,test,tests,53077,"///////; 1422/// AutoSave tree header every fAutoSave bytes.; 1423///; 1424/// When large Trees are produced, it is safe to activate the AutoSave; 1425/// procedure. Some branches may have buffers holding many entries.; 1426/// If fAutoSave is negative, AutoSave is automatically called by; 1427/// TTree::Fill when the number of bytes generated since the previous; 1428/// AutoSave is greater than -fAutoSave bytes.; 1429/// If fAutoSave is positive, AutoSave is automatically called by; 1430/// TTree::Fill every N entries.; 1431/// This function may also be invoked by the user.; 1432/// Each AutoSave generates a new key on the file.; 1433/// Once the key with the tree header has been written, the previous cycle; 1434/// (if any) is deleted.; 1435///; 1436/// Note that calling TTree::AutoSave too frequently (or similarly calling; 1437/// TTree::SetAutoSave with a small value) is an expensive operation.; 1438/// You should make tests for your own application to find a compromise; 1439/// between speed and the quantity of information you may loose in case of; 1440/// a job crash.; 1441///; 1442/// In case your program crashes before closing the file holding this tree,; 1443/// the file will be automatically recovered when you will connect the file; 1444/// in UPDATE mode.; 1445/// The Tree will be recovered at the status corresponding to the last AutoSave.; 1446///; 1447/// if option contains ""SaveSelf"", gDirectory->SaveSelf() is called.; 1448/// This allows another process to analyze the Tree while the Tree is being filled.; 1449///; 1450/// if option contains ""FlushBaskets"", TTree::FlushBaskets is called and all; 1451/// the current basket are closed-out and written to disk individually.; 1452///; 1453/// By default the previous header is deleted after having written the new header.; 1454/// if option contains ""Overwrite"", the previous Tree header is deleted; 1455/// before written the new header. This option is slightly faster, but; 1456/// the default option is safer i",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:54740,Testability,test,test,54740,"ns ""FlushBaskets"", TTree::FlushBaskets is called and all; 1451/// the current basket are closed-out and written to disk individually.; 1452///; 1453/// By default the previous header is deleted after having written the new header.; 1454/// if option contains ""Overwrite"", the previous Tree header is deleted; 1455/// before written the new header. This option is slightly faster, but; 1456/// the default option is safer in case of a problem (disk quota exceeded); 1457/// when writing the new header.; 1458///; 1459/// The function returns the number of bytes written to the file.; 1460/// if the number of bytes is null, an error has occurred while writing; 1461/// the header to the file.; 1462///; 1463/// ## How to write a Tree in one process and view it from another process; 1464///; 1465/// The following two scripts illustrate how to do this.; 1466/// The script treew.C is executed by process1, treer.C by process2; 1467///; 1468/// script treew.C:; 1469/// ~~~ {.cpp}; 1470/// void treew() {; 1471/// TFile f(""test.root"",""recreate"");; 1472/// TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; 1473/// Float_t px, py, pz;; 1474/// for ( Int_t i=0; i<10000000; i++) {; 1475/// gRandom->Rannor(px,py);; 1476/// pz = px*px + py*py;; 1477/// Float_t random = gRandom->Rndm(1);; 1478/// ntuple->Fill(px,py,pz,random,i);; 1479/// if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; 1480/// }; 1481/// }; 1482/// ~~~; 1483/// script treer.C:; 1484/// ~~~ {.cpp}; 1485/// void treer() {; 1486/// TFile f(""test.root"");; 1487/// TTree *ntuple = (TTree*)f.Get(""ntuple"");; 1488/// TCanvas c1;; 1489/// Int_t first = 0;; 1490/// while(1) {; 1491/// if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; 1492/// else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; 1493/// first = (Int_t)ntuple->GetEntries();; 1494/// c1.Update();; 1495/// gSystem->Sleep(1000); //sleep 1 second; 1496/// ntuple->Refresh();; 1497/// }; 1498/// }; 1499/// ~~~; 1500 ; 1501Long64_t TTree::AutoSave",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:55241,Testability,test,test,55241,"; 1458///; 1459/// The function returns the number of bytes written to the file.; 1460/// if the number of bytes is null, an error has occurred while writing; 1461/// the header to the file.; 1462///; 1463/// ## How to write a Tree in one process and view it from another process; 1464///; 1465/// The following two scripts illustrate how to do this.; 1466/// The script treew.C is executed by process1, treer.C by process2; 1467///; 1468/// script treew.C:; 1469/// ~~~ {.cpp}; 1470/// void treew() {; 1471/// TFile f(""test.root"",""recreate"");; 1472/// TNtuple *ntuple = new TNtuple(""ntuple"",""Demo"",""px:py:pz:random:i"");; 1473/// Float_t px, py, pz;; 1474/// for ( Int_t i=0; i<10000000; i++) {; 1475/// gRandom->Rannor(px,py);; 1476/// pz = px*px + py*py;; 1477/// Float_t random = gRandom->Rndm(1);; 1478/// ntuple->Fill(px,py,pz,random,i);; 1479/// if (i%1000 == 1) ntuple->AutoSave(""SaveSelf"");; 1480/// }; 1481/// }; 1482/// ~~~; 1483/// script treer.C:; 1484/// ~~~ {.cpp}; 1485/// void treer() {; 1486/// TFile f(""test.root"");; 1487/// TTree *ntuple = (TTree*)f.Get(""ntuple"");; 1488/// TCanvas c1;; 1489/// Int_t first = 0;; 1490/// while(1) {; 1491/// if (first == 0) ntuple->Draw(""px>>hpx"", """","""",10000000,first);; 1492/// else ntuple->Draw(""px>>+hpx"","""","""",10000000,first);; 1493/// first = (Int_t)ntuple->GetEntries();; 1494/// c1.Update();; 1495/// gSystem->Sleep(1000); //sleep 1 second; 1496/// ntuple->Refresh();; 1497/// }; 1498/// }; 1499/// ~~~; 1500 ; 1501Long64_t TTree::AutoSave(Option_t* option); 1502{; 1503 if (!fDirectory || fDirectory == gROOT || !fDirectory->IsWritable()) return 0;; 1504 if (gDebug > 0) {; 1505 Info(""AutoSave"", ""Tree:%s after %lld bytes written\n"",GetName(),GetTotBytes());; 1506 }; 1507 TString opt = option;; 1508 opt.ToLower();; 1509 ; 1510 if (opt.Contains(""flushbaskets"")) {; 1511 if (gDebug > 0) Info(""AutoSave"", ""calling FlushBaskets \n"");; 1512 FlushBasketsImpl();; 1513 }; 1514 ; 1515 fSavedBytes = GetZipBytes();; 1516 ; 1517 TKey *key = (TKey*",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:70965,Testability,test,test,70965," This situation happens when the top level object; 1790/// has two or more members referencing the same class.; 1791/// For example, if a Tree has two branches B1 and B2 corresponding; 1792/// to objects of the same class MyClass, one can do:; 1793/// ~~~ {.cpp}; 1794/// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; 1795/// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; 1796/// ~~~; 1797/// if MyClass has 3 members a,b,c, the two instructions above will generate; 1798/// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; 1799///; 1800/// Example:; 1801/// ~~~ {.cpp}; 1802/// {; 1803/// TTree T(""T"",""test list"");; 1804/// TList *list = new TList();; 1805///; 1806/// TObjArray *a1 = new TObjArray();; 1807/// a1->SetName(""a1"");; 1808/// list->Add(a1);; 1809/// TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; 1810/// TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; 1811/// a1->Add(ha1a);; 1812/// a1->Add(ha1b);; 1813/// TObjArray *b1 = new TObjArray();; 1814/// b1->SetName(""b1"");; 1815/// list->Add(b1);; 1816/// TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; 1817/// TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; 1818/// b1->Add(hb1a);; 1819/// b1->Add(hb1b);; 1820///; 1821/// TObjArray *a2 = new TObjArray();; 1822/// a2->SetName(""a2"");; 1823/// list->Add(a2);; 1824/// TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; 1825/// TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; 1826/// a2->Add(ha2a);; 1827/// a2->Add(ha2b);; 1828///; 1829/// T.Branch(list,16000,2);; 1830/// T.Print();; 1831/// }; 1832/// ~~~; 1833 ; 1834Int_t TTree::Branch(TCollection* li, Int_t bufsize /* = 32000 */, Int_t splitlevel /* = 99 */, const char* name /* = """" */); 1835{; 1836 ; 1837 if (!li) {; 1838 return 0;; 1839 }; 1840 TObject* obj = nullptr;; 1841 Int_t nbranches = GetListOfBranches()->GetEntries();; 1842 if (li->InheritsFrom(TClonesArray::Class())) {; 1843 Error(""Branch"", ""Cannot call this constructor for a TClonesArray"");; 1844 return 0;; 1845 }; 1846 Int_t nch = strlen(name);; 1847 TString branchname;; 1848 TI",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:91185,Testability,test,test,91185,"laceAll(""*"","""");; 2278 leaflist.ReplaceAll(""*"","""");; 2279 // Add the branch to the tree and indicate that the address; 2280 // is that of a pointer to be dereferenced before using.; 2281 branch1 = new TBranch(branch, bname, *((void**) pointer), leaflist, bufsize);; 2282 TLeaf* leaf = (TLeaf*) branch1->GetListOfLeaves()->At(0);; 2283 leaf->SetBit(TLeaf::kIndirectAddress);; 2284 leaf->SetAddress((void**) pointer);; 2285 blist->Add(branch1);; 2286 }; 2287 } else if (dm->IsBasic()) {; 2288 // We have a basic type.; 2289 ; 2290 char vcode = DataTypeToChar((EDataType)code);; 2291 if (vcode) {; 2292 leaflist.Form(""%s/%c"", rdname, vcode);; 2293 } else {; 2294 Error(""BranchOld"", ""Cannot create branch for rdname: %s code: %d"", branchname.Data(), code);; 2295 leaflist = """";; 2296 }; 2297 branch1 = new TBranch(branch, branchname, pointer, leaflist, bufsize);; 2298 branch1->SetTitle(rdname);; 2299 blist->Add(branch1);; 2300 } else {; 2301 // We have a class type.; 2302 // Note: This cannot happen due to the rd->IsObject() test above.; 2303 // FIXME: Put an error message here just in case.; 2304 }; 2305 if (branch1) {; 2306 branch1->SetOffset(offset);; 2307 } else {; 2308 Warning(""BranchOld"", ""Cannot process member: '%s'"", rdname);; 2309 }; 2310 }; 2311 if (delobj) {; 2312 delete obj;; 2313 obj = nullptr;; 2314 }; 2315 return branch;; 2316}; 2317 ; 2318////////////////////////////////////////////////////////////////////////////////; 2319/// Build the optional branch supporting the TRefTable.; 2320/// This branch will keep all the information to find the branches; 2321/// containing referenced objects.; 2322///; 2323/// At each Tree::Fill, the branch numbers containing the; 2324/// referenced objects are saved to the TBranchRef basket.; 2325/// When the Tree header is saved (via TTree::Write), the branch; 2326/// is saved keeping the information with the pointers to the branches; 2327/// having referenced objects.; 2328 ; 2329TBranch* TTree::BranchRef(); 2330{; 2331 if (!fBranchRe",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:125577,Testability,test,test,125577,"// When using SortBasketsByBranch all the baskets of each individual; 3115/// branches are stored contiguously. This tends to optimize reading; 3116/// speed when reading a small number (1->5) of branches, since all; 3117/// their baskets will be clustered together instead of being spread; 3118/// across the file. However it might decrease the performance when; 3119/// reading more branches (or the full entry).; 3120///; 3121/// When using SortBasketsByEntry the baskets with the lowest starting; 3122/// entry are written first. (i.e. the baskets are sorted by the; 3123/// index/number of the first entry they contain). This means that on; 3124/// the file the baskets will be in the order in which they will be; 3125/// needed when reading the whole tree sequentially.; 3126///; 3127/// For examples of CloneTree, see tutorials:; 3128///; 3129/// - copytree.C:; 3130/// A macro to copy a subset of a TTree to a new TTree.; 3131/// The input file has been generated by the program in; 3132/// $ROOTSYS/test/Event with: Event 1000 1 1 1; 3133///; 3134/// - copytree2.C:; 3135/// A macro to copy a subset of a TTree to a new TTree.; 3136/// One branch of the new Tree is written to a separate file.; 3137/// The input file has been generated by the program in; 3138/// $ROOTSYS/test/Event with: Event 1000 1 1 1; 3139 ; 3140TTree* TTree::CloneTree(Long64_t nentries /* = -1 */, Option_t* option /* = """" */); 3141{; 3142 // Options; 3143 bool fastClone = false;; 3144 ; 3145 TString opt = option;; 3146 opt.ToLower();; 3147 if (opt.Contains(""fast"")) {; 3148 fastClone = true;; 3149 }; 3150 ; 3151 // If we are a chain, switch to the first tree.; 3152 if ((fEntries > 0) && (LoadTree(0) < 0)) {; 3153 // FIXME: We need an error message here.; 3154 return nullptr;; 3155 }; 3156 ; 3157 // Note: For a tree we get the this pointer, for; 3158 // a chain we get the chain's current tree.; 3159 TTree* thistree = GetTree();; 3160 ; 3161 // We will use this to override the IO features on the cloned bran",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:125851,Testability,test,test,125851,"e when; 3119/// reading more branches (or the full entry).; 3120///; 3121/// When using SortBasketsByEntry the baskets with the lowest starting; 3122/// entry are written first. (i.e. the baskets are sorted by the; 3123/// index/number of the first entry they contain). This means that on; 3124/// the file the baskets will be in the order in which they will be; 3125/// needed when reading the whole tree sequentially.; 3126///; 3127/// For examples of CloneTree, see tutorials:; 3128///; 3129/// - copytree.C:; 3130/// A macro to copy a subset of a TTree to a new TTree.; 3131/// The input file has been generated by the program in; 3132/// $ROOTSYS/test/Event with: Event 1000 1 1 1; 3133///; 3134/// - copytree2.C:; 3135/// A macro to copy a subset of a TTree to a new TTree.; 3136/// One branch of the new Tree is written to a separate file.; 3137/// The input file has been generated by the program in; 3138/// $ROOTSYS/test/Event with: Event 1000 1 1 1; 3139 ; 3140TTree* TTree::CloneTree(Long64_t nentries /* = -1 */, Option_t* option /* = """" */); 3141{; 3142 // Options; 3143 bool fastClone = false;; 3144 ; 3145 TString opt = option;; 3146 opt.ToLower();; 3147 if (opt.Contains(""fast"")) {; 3148 fastClone = true;; 3149 }; 3150 ; 3151 // If we are a chain, switch to the first tree.; 3152 if ((fEntries > 0) && (LoadTree(0) < 0)) {; 3153 // FIXME: We need an error message here.; 3154 return nullptr;; 3155 }; 3156 ; 3157 // Note: For a tree we get the this pointer, for; 3158 // a chain we get the chain's current tree.; 3159 TTree* thistree = GetTree();; 3160 ; 3161 // We will use this to override the IO features on the cloned branches.; 3162 ROOT::TIOFeatures features = this->GetIOFeatures();; 3163 ;; 3164 ; 3165 // Note: For a chain, the returned clone will be; 3166 // a clone of the chain's first tree.; 3167 TTree* newtree = (TTree*) thistree->Clone();; 3168 if (!newtree) {; 3169 return nullptr;; 3170 }; 3171 ; 3172 // The clone should not delete any objects allocated by SetAdd",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:146142,Testability,test,test,146142,"9 this->GetTreeIndex()->Append(nullptr,false); // Force the sorting; 3680 }; 3681 }; 3682 return nbytes;; 3683}; 3684 ; 3685////////////////////////////////////////////////////////////////////////////////; 3686/// Copy a tree with selection.; 3687///; 3688/// ### Important:; 3689///; 3690/// The returned copied tree stays connected with the original tree; 3691/// until the original tree is deleted. In particular, any changes; 3692/// to the branch addresses in the original tree are also made to; 3693/// the copied tree. Any changes made to the branch addresses of the; 3694/// copied tree are overridden anytime the original tree changes its; 3695/// branch addresses. When the original tree is deleted, all the; 3696/// branch addresses of the copied tree are set to zero.; 3697///; 3698/// For examples of CopyTree, see the tutorials:; 3699///; 3700/// - copytree.C:; 3701/// Example macro to copy a subset of a tree to a new tree.; 3702/// The input file was generated by running the program in; 3703/// $ROOTSYS/test/Event in this way:; 3704/// ~~~ {.cpp}; 3705/// ./Event 1000 1 1 1; 3706/// ~~~; 3707/// - copytree2.C; 3708/// Example macro to copy a subset of a tree to a new tree.; 3709/// One branch of the new tree is written to a separate file.; 3710/// The input file was generated by running the program in; 3711/// $ROOTSYS/test/Event in this way:; 3712/// ~~~ {.cpp}; 3713/// ./Event 1000 1 1 1; 3714/// ~~~; 3715/// - copytree3.C; 3716/// Example macro to copy a subset of a tree to a new tree.; 3717/// Only selected entries are copied to the new tree.; 3718/// NOTE that only the active branches are copied.; 3719 ; 3720TTree* TTree::CopyTree(const char* selection, Option_t* option /* = 0 */, Long64_t nentries /* = TTree::kMaxEntries */, Long64_t firstentry /* = 0 */); 3721{; 3722 GetPlayer();; 3723 if (fPlayer) {; 3724 return fPlayer->CopyTree(selection, option, nentries, firstentry);; 3725 }; 3726 return nullptr;; 3727}; 3728 ; 3729////////////////////////////////////",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:146464,Testability,test,test,146464,"s connected with the original tree; 3691/// until the original tree is deleted. In particular, any changes; 3692/// to the branch addresses in the original tree are also made to; 3693/// the copied tree. Any changes made to the branch addresses of the; 3694/// copied tree are overridden anytime the original tree changes its; 3695/// branch addresses. When the original tree is deleted, all the; 3696/// branch addresses of the copied tree are set to zero.; 3697///; 3698/// For examples of CopyTree, see the tutorials:; 3699///; 3700/// - copytree.C:; 3701/// Example macro to copy a subset of a tree to a new tree.; 3702/// The input file was generated by running the program in; 3703/// $ROOTSYS/test/Event in this way:; 3704/// ~~~ {.cpp}; 3705/// ./Event 1000 1 1 1; 3706/// ~~~; 3707/// - copytree2.C; 3708/// Example macro to copy a subset of a tree to a new tree.; 3709/// One branch of the new tree is written to a separate file.; 3710/// The input file was generated by running the program in; 3711/// $ROOTSYS/test/Event in this way:; 3712/// ~~~ {.cpp}; 3713/// ./Event 1000 1 1 1; 3714/// ~~~; 3715/// - copytree3.C; 3716/// Example macro to copy a subset of a tree to a new tree.; 3717/// Only selected entries are copied to the new tree.; 3718/// NOTE that only the active branches are copied.; 3719 ; 3720TTree* TTree::CopyTree(const char* selection, Option_t* option /* = 0 */, Long64_t nentries /* = TTree::kMaxEntries */, Long64_t firstentry /* = 0 */); 3721{; 3722 GetPlayer();; 3723 if (fPlayer) {; 3724 return fPlayer->CopyTree(selection, option, nentries, firstentry);; 3725 }; 3726 return nullptr;; 3727}; 3728 ; 3729////////////////////////////////////////////////////////////////////////////////; 3730/// Create a basket for this tree and given branch.; 3731 ; 3732TBasket* TTree::CreateBasket(TBranch* branch); 3733{; 3734 if (!branch) {; 3735 return nullptr;; 3736 }; 3737 return new TBasket(branch->GetName(), GetName(), branch);; 3738}; 3739 ; 3740/////////////////////",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:154247,Testability,log,logical,154247,"y ps pz; 3887/// and the color number of each marker will be 2.5*E.; 3888/// If the color number is negative it is set to 0.; 3889/// If the color number is greater than the current number of colors; 3890/// it is set to the highest color number. The default number of; 3891/// colors is 50. See TStyle::SetPalette for setting a new color palette.; 3892///; 3893/// The expressions can use all the operations and built-in functions; 3894/// supported by TFormula (see TFormula::Analyze()), including free; 3895/// functions taking numerical arguments (e.g. TMath::Bessel()).; 3896/// In addition, you can call member functions taking numerical; 3897/// arguments. For example, these are two valid expressions:; 3898/// ~~~ {.cpp}; 3899/// TMath::BreitWigner(fPx,3,2); 3900/// event.GetHistogram()->GetXaxis()->GetXmax(); 3901/// ~~~; 3902/// \endparblock; 3903/// \param [in] selection; 3904/// \parblock; 3905/// A string containing a selection expression.; 3906/// In a selection all usual C++ mathematical and logical operators are allowed.; 3907/// The value corresponding to the selection expression is used as a weight; 3908/// to fill the histogram (a weight of 0 is equivalent to not filling the histogram).\n; 3909/// \n; 3910/// Examples:; 3911/// - ""x<y && sqrt(z)>3.2"": returns a weight = 0 or 1; 3912/// - ""(x+y)*(sqrt(z)>3.2)"": returns a weight = x+y if sqrt(z)>3.2, 0 otherwise\n; 3913/// \n; 3914/// If the selection expression returns an array, it is iterated over in sync with the; 3915/// array returned by the varexp argument (as described below in ""Drawing expressions using arrays and array; 3916/// elements""). For example, if, for a given event, varexp evaluates to; 3917/// `{1., 2., 3.}` and selection evaluates to `{0, 1, 0}`, the resulting histogram is filled with the value 2. For example, for each event here we perform a simple object selection:; 3918/// ~~~{.cpp}; 3919/// // Muon_pt is an array: fill a histogram with the array elements > 100 in each event; 3920/// t",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:156316,Testability,log,log,156316," option; 3924/// \parblock; 3925/// The drawing option.; 3926/// - When an histogram is produced it can be any histogram drawing option; 3927/// listed in THistPainter.; 3928/// - when no option is specified:; 3929/// - the default histogram drawing option is used; 3930/// if the expression is of the form ""e1"".; 3931/// - if the expression is of the form ""e1:e2""or ""e1:e2:e3"" a cloud of; 3932/// unbinned 2D or 3D points is drawn respectively.; 3933/// - if the expression has four fields ""e1:e2:e3:e4"" a cloud of unbinned 3D; 3934/// points is produced with e1 vs e2 vs e3, and e4 is mapped on the current color; 3935/// palette.; 3936/// - If option COL is specified when varexp has three fields:; 3937/// ~~~ {.cpp}; 3938/// tree.Draw(""e1:e2:e3"","""",""col"");; 3939/// ~~~; 3940/// a 2D scatter is produced with e1 vs e2, and e3 is mapped on the current; 3941/// color palette. The colors for e3 are evaluated once in linear scale before; 3942/// painting. Therefore changing the pad to log scale along Z as no effect; 3943/// on the colors.; 3944/// - if expression has more than four fields the option ""PARA""or ""CANDLE""; 3945/// can be used.; 3946/// - If option contains the string ""goff"", no graphics is generated.; 3947/// \endparblock; 3948/// \param [in] nentries The number of entries to process (default is all); 3949/// \param [in] firstentry The first entry to process (default is 0); 3950///; 3951/// ### Drawing expressions using arrays and array elements; 3952///; 3953/// Let assumes, a leaf fMatrix, on the branch fEvent, which is a 3 by 3 array,; 3954/// or a TClonesArray.; 3955/// In a TTree::Draw expression you can now access fMatrix using the following; 3956/// syntaxes:; 3957///; 3958/// | String passed | What is used for each entry of the tree; 3959/// |-----------------|--------------------------------------------------------|; 3960/// | `fMatrix` | the 9 elements of fMatrix |; 3961/// | `fMatrix[][]` | the 9 elements of fMatrix |; 3962/// | `fMatrix[2][2]` | only the",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:191261,Testability,test,test,191261," 4704 if (autoFlush || autoSave) {; 4705 // First call FlushBasket to make sure that fTotBytes is up to date.; 4706 FlushBasketsImpl();; 4707 autoFlush = false; // avoid auto flushing again later; 4708 ; 4709 // When we are in one-basket-per-cluster mode, there is no need to optimize basket:; 4710 // they will automatically grow to the size needed for an event cluster (with the basket; 4711 // shrinking preventing them from growing too much larger than the actually-used space).; 4712 if (!TestBit(TTree::kOnlyFlushAtCluster)) {; 4713 OptimizeBaskets(GetTotBytes(), 1, """");; 4714 if (gDebug > 0); 4715 Info(""TTree::Fill"", ""OptimizeBaskets called at entry %lld, fZipBytes=%lld, fFlushedBytes=%lld\n"",; 4716 fEntries, GetZipBytes(), fFlushedBytes);; 4717 }; 4718 fFlushedBytes = GetZipBytes();; 4719 fAutoFlush = fEntries; // Use test on entries rather than bytes; 4720 ; 4721 // subsequently in run; 4722 if (fAutoSave < 0) {; 4723 // Set fAutoSave to the largest integer multiple of; 4724 // fAutoFlush events such that fAutoSave*fFlushedBytes; 4725 // < (minus the input value of fAutoSave); 4726 Long64_t totBytes = GetTotBytes();; 4727 if (zipBytes != 0) {; 4728 fAutoSave = TMath::Max(fAutoFlush, fEntries * ((-fAutoSave / zipBytes) / fEntries));; 4729 } else if (totBytes != 0) {; 4730 fAutoSave = TMath::Max(fAutoFlush, fEntries * ((-fAutoSave / totBytes) / fEntries));; 4731 } else {; 4732 TBufferFile b(TBuffer::kWrite, 10000);; 4733 TTree::Class()->WriteBuffer(b, (TTree *)this);; 4734 Long64_t total = b.Length();; 4735 fAutoSave = TMath::Max(fAutoFlush, fEntries * ((-fAutoSave / total) / fEntries));; 4736 }; 4737 } else if (fAutoSave > 0) {; 4738 fAutoSave = fAutoFlush * (fAutoSave / fAutoFlush);; 4739 }; 4740 ; 4741 if (fAutoSave != 0 && fEntries >= fAutoSave); 4742 autoSave = true;; 4743 ; 4744 if (gDebug > 0); 4745 Info(""TTree::Fill"", ""First AutoFlush. fAutoFlush = %lld, fAutoSave = %lld\n"", fAutoFlush, fAutoSave);; 4746 }; 4747 } else {; 4748 // Check if we need to auto fl",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:220390,Testability,test,test,220390,"y branches ""a"" and ""b"" will be read.; 5545///; 5546/// __WARNING!!__; 5547/// If your Tree has been created in split mode with a parent branch ""parent."",; 5548/// ~~~ {.cpp}; 5549/// mytree.SetBranchStatus(""parent"",1);; 5550/// ~~~; 5551/// will not activate the sub-branches of ""parent"". You should do:; 5552/// ~~~ {.cpp}; 5553/// mytree.SetBranchStatus(""parent*"",1);; 5554/// ~~~; 5555/// Without the trailing dot in the branch creation you have no choice but to; 5556/// call SetBranchStatus explicitly for each of the sub branches.; 5557///; 5558/// An alternative is to call directly; 5559/// ~~~ {.cpp}; 5560/// brancha.GetEntry(i); 5561/// branchb.GetEntry(i);; 5562/// ~~~; 5563/// ## IMPORTANT NOTE; 5564///; 5565/// By default, GetEntry reuses the space allocated by the previous object; 5566/// for each branch. You can force the previous object to be automatically; 5567/// deleted if you call mybranch.SetAutoDelete(true) (default is false).; 5568///; 5569/// Example:; 5570///; 5571/// Consider the example in $ROOTSYS/test/Event.h; 5572/// The top level branch in the tree T is declared with:; 5573/// ~~~ {.cpp}; 5574/// Event *event = 0; //event must be null or point to a valid object; 5575/// //it must be initialized; 5576/// T.SetBranchAddress(""event"",&event);; 5577/// ~~~; 5578/// When reading the Tree, one can choose one of these 3 options:; 5579///; 5580/// ## OPTION 1; 5581///; 5582/// ~~~ {.cpp}; 5583/// for (Long64_t i=0;i<nentries;i++) {; 5584/// T.GetEntry(i);; 5585/// // the object event has been filled at this point; 5586/// }; 5587/// ~~~; 5588/// The default (recommended). At the first entry an object of the class; 5589/// Event will be created and pointed by event. At the following entries,; 5590/// event will be overwritten by the new data. All internal members that are; 5591/// TObject* are automatically deleted. It is important that these members; 5592/// be in a valid state when GetEntry is called. Pointers must be correctly; 5593/// initialized. ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:279020,Testability,test,testing,279020,"ldMemsize += oldBsize;; 7103 oldBaskets += 1+Int_t(totBytes/oldBsize);; 7104 Int_t nb = branch->GetListOfBranches()->GetEntries();; 7105 if (nb > 0) {; 7106 newBaskets += 1+Int_t(totBytes/oldBsize);; 7107 continue;; 7108 }; 7109 Double_t bsize = oldBsize*idealFactor*memFactor; //bsize can be very large !; 7110 if (bsize < 0) bsize = bmax;; 7111 if (bsize > bmax) bsize = bmax;; 7112 UInt_t newBsize = UInt_t(bsize);; 7113 if (pass) { // only on the second pass so that it doesn't interfere with scaling; 7114 // If there is an entry offset, it will be stored in the same buffer as the object data; hence,; 7115 // we must bump up the size of the branch to account for this extra footprint.; 7116 // If fAutoFlush is not set yet, let's assume that it is 'in the process of being set' to; 7117 // the value of GetEntries().; 7118 Long64_t clusterSize = (fAutoFlush > 0) ? fAutoFlush : branch->GetEntries();; 7119 if (branch->GetEntryOffsetLen()) {; 7120 newBsize = newBsize + (clusterSize * sizeof(Int_t) * 2);; 7121 }; 7122 // We used ATLAS fully-split xAOD for testing, which is a rather unbalanced TTree, 10K branches,; 7123 // with 8K having baskets smaller than 512 bytes. To achieve good I/O performance ATLAS uses auto-flush 100,; 7124 // resulting in the smallest baskets being ~300-400 bytes, so this change increases their memory by about 8k*150B =~ 1MB,; 7125 // at the same time it significantly reduces the number of total baskets because it ensures that all 100 entries can be; 7126 // stored in a single basket (the old optimization tended to make baskets too small). In a toy example with fixed sized; 7127 // structures we found a factor of 2 fewer baskets needed in the new scheme.; 7128 // rounds up, increases basket size to ensure all entries fit into single basket as intended; 7129 newBsize = newBsize - newBsize%512 + 512;; 7130 }; 7131 if (newBsize < sizeOfOneEntry) newBsize = sizeOfOneEntry;; 7132 if (newBsize < bmin) newBsize = bmin;; 7133 if (newBsize > 10000000) newBsi",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:413072,Testability,log,logical,413072,"nLevel() constDefinition TFile.h:391; TFile::GetENDvirtual Long64_t GetEND() constDefinition TFile.h:231; TFile::WriteStreamerInfovirtual void WriteStreamerInfo()Write the list of TStreamerInfo as a single object in this file The class Streamer description for al...Definition TFile.cxx:3792; TFile::kDoNotDisconnect@ kDoNotDisconnectDefinition TFile.h:70; TFile::Flushvirtual void Flush()Synchronize a file's in-memory and on-disk states.Definition TFile.cxx:1141; TFile::MakeFreevirtual void MakeFree(Long64_t first, Long64_t last)Mark unused bytes on the file.Definition TFile.cxx:1484; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::WriteHeadervirtual void WriteHeader()Write File Header.Definition TFile.cxx:2615; TFile::GetRecordHeaderInt_t GetRecordHeader(char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen)Read the logical record header starting at a certain postion.Definition TFile.cxx:1301; TFile::GetCacheReadTFileCacheRead * GetCacheRead(const TObject *tree=nullptr) constReturn a pointer to the current read cache.Definition TFile.cxx:1262; TFolder<div class=""legacybox""><h2>Legacy Code</h2> TFolder is a legacy interface: there will be no bug fixes...Definition TFolder.h:30; TFolder::GetListOfFoldersTCollection * GetListOfFolders() constDefinition TFolder.h:55; TFolder::Occurencevirtual Int_t Occurence(const TObject *obj) constReturn occurence number of object in the list of objects of this folder.Definition TFolder.cxx:427; TFolder::Classstatic TClass * Class(); TFriendElementA TFriendElement TF describes a TTree object TF in a file.Definition TFriendElement.h:33; TFriendElement::ResetUpdatedvoid ResetUpdated()Definition TFriendElement.h:68; TFriendElement::kFromChain@ kFromChainDefinition TFriendElement.h:49; TFriendElement::GetTreeNamevirtual c",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:3318,Usability,simpl,simple,3318," 43Making several branches is particularly interesting in the data analysis phase,; 44when it is desirable to have a high reading rate and not all columns are equally interesting; 45 ; 46\anchor creatingattreetoc; 47## Create a TTree to store columnar data; 48- [Construct a TTree](\ref creatingattree); 49- [Add a column of Fundamental Types and Arrays thereof](\ref addcolumnoffundamentaltypes); 50- [Add a column of a STL Collection instances](\ref addingacolumnofstl); 51- [Add a column holding an object](\ref addingacolumnofobjs); 52- [Add a column holding a TObjectArray](\ref addingacolumnofobjs); 53- [Fill the tree](\ref fillthetree); 54- [Add a column to an already existing Tree](\ref addcoltoexistingtree); 55- [An Example](\ref fullexample); 56 ; 57\anchor creatingattree; 58## Construct a TTree; 59 ; 60~~~ {.cpp}; 61 TTree tree(name, title); 62~~~; 63Creates a Tree with name and title.; 64 ; 65Various kinds of branches can be added to a tree:; 66- Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran; 67structures.; 68- Any C++ object or collection, provided by the STL or ROOT.; 69 ; 70In the following, the details about the creation of different types of branches are given.; 71 ; 72\anchor addcolumnoffundamentaltypes; 73## Add a column (""branch"") holding fundamental types and arrays thereof; 74This strategy works also for lists of variables, e.g. to describe simple structures.; 75It is strongly recommended to persistify those as objects rather than lists of leaves.; 76 ; 77~~~ {.cpp}; 78 auto branch = tree.Branch(branchname, address, leaflist, bufsize); 79~~~; 80- address is the address of the first item of a structure; 81- leaflist is the concatenation of all the variable names and types; 82 separated by a colon character :; 83 The variable name and the variable type are separated by a; 84 slash (/). The variable type must be 1 character. (Characters; 85 after the first are legal and will be appen",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:3761,Usability,simpl,simple,3761,"ddingacolumnofstl); 51- [Add a column holding an object](\ref addingacolumnofobjs); 52- [Add a column holding a TObjectArray](\ref addingacolumnofobjs); 53- [Fill the tree](\ref fillthetree); 54- [Add a column to an already existing Tree](\ref addcoltoexistingtree); 55- [An Example](\ref fullexample); 56 ; 57\anchor creatingattree; 58## Construct a TTree; 59 ; 60~~~ {.cpp}; 61 TTree tree(name, title); 62~~~; 63Creates a Tree with name and title.; 64 ; 65Various kinds of branches can be added to a tree:; 66- Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran; 67structures.; 68- Any C++ object or collection, provided by the STL or ROOT.; 69 ; 70In the following, the details about the creation of different types of branches are given.; 71 ; 72\anchor addcolumnoffundamentaltypes; 73## Add a column (""branch"") holding fundamental types and arrays thereof; 74This strategy works also for lists of variables, e.g. to describe simple structures.; 75It is strongly recommended to persistify those as objects rather than lists of leaves.; 76 ; 77~~~ {.cpp}; 78 auto branch = tree.Branch(branchname, address, leaflist, bufsize); 79~~~; 80- address is the address of the first item of a structure; 81- leaflist is the concatenation of all the variable names and types; 82 separated by a colon character :; 83 The variable name and the variable type are separated by a; 84 slash (/). The variable type must be 1 character. (Characters; 85 after the first are legal and will be appended to the visible; 86 name of the leaf, but have no effect.) If no type is given, the; 87 type of the variable is assumed to be the same as the previous; 88 variable. If the first variable does not have a type, it is; 89 assumed of type F by default. The list of currently supported; 90 types is given below:; 91 - `C` : a character string terminated by the 0 character; 92 - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an ",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:11880,Usability,simpl,simple,11880," = tree.Branch(branchname,clonesarray, bufsize, splitlevel); 217~~~; 218The TClonesArray is a direct access list of objects of the same class.; 219For example, if the TClonesArray is an array of TTrack objects,; 220this function will create one subbranch for each data member of; 221the object TTrack.; 222 ; 223\anchor fillthetree; 224## Fill the Tree; 225 ; 226A TTree instance is filled with the invocation of the TTree::Fill method:; 227~~~ {.cpp}; 228 tree.Fill(); 229~~~; 230Upon its invocation, a loop on all defined branches takes place that for each branch invokes; 231the TBranch::Fill method.; 232 ; 233\anchor addcoltoexistingtree; 234## Add a column to an already existing Tree; 235 ; 236You may want to add a branch to an existing tree. For example,; 237if one variable in the tree was computed with a certain algorithm,; 238you may want to try another algorithm and compare the results.; 239One solution is to add a new branch, fill it, and save the tree.; 240The code below adds a simple branch to an existing tree.; 241Note the kOverwrite option in the Write method, it overwrites the; 242existing tree. If it is not specified, two copies of the tree headers; 243are saved.; 244~~~ {.cpp}; 245 void tree3AddBranch() {; 246 TFile f(""tree3.root"", ""update"");; 247 ; 248 Float_t new_v;; 249 auto t3 = f->Get<TTree>(""t3"");; 250 auto newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");; 251 ; 252 Long64_t nentries = t3->GetEntries(); // read the number of entries in the t3; 253 ; 254 for (Long64_t i = 0; i < nentries; i++) {; 255 new_v = gRandom->Gaus(0, 1);; 256 newBranch->Fill();; 257 }; 258 ; 259 t3->Write("""", TObject::kOverwrite); // save only the new version of the tree; 260 }; 261~~~; 262It is not always possible to add branches to existing datasets stored in TFiles: for example,; 263these files might not be writeable, just readable. In addition, modifying in place a TTree; 264causes a new TTree instance to be written and the previous one to be deleted.; 265For this reason",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:13180,Usability,simpl,simple,13180,"tEntries(); // read the number of entries in the t3; 253 ; 254 for (Long64_t i = 0; i < nentries; i++) {; 255 new_v = gRandom->Gaus(0, 1);; 256 newBranch->Fill();; 257 }; 258 ; 259 t3->Write("""", TObject::kOverwrite); // save only the new version of the tree; 260 }; 261~~~; 262It is not always possible to add branches to existing datasets stored in TFiles: for example,; 263these files might not be writeable, just readable. In addition, modifying in place a TTree; 264causes a new TTree instance to be written and the previous one to be deleted.; 265For this reasons, ROOT offers the concept of friends for TTree and TChain:; 266if is good practice to rely on friend trees rather than adding a branch manually.; 267 ; 268\anchor fullexample; 269## An Example; 270 ; 271Begin_Macro; 272../../../tutorials/tree/tree.C; 273End_Macro; 274 ; 275~~~ {.cpp}; 276 // A simple example with histograms and a tree; 277 //; 278 // This program creates :; 279 // - a one dimensional histogram; 280 // - a two dimensional histogram; 281 // - a profile histogram; 282 // - a tree; 283 //; 284 // These objects are filled with some random numbers and saved on a file.; 285 ; 286 #include ""TFile.h""; 287 #include ""TH1.h""; 288 #include ""TH2.h""; 289 #include ""TProfile.h""; 290 #include ""TRandom.h""; 291 #include ""TTree.h""; 292 ; 293 //__________________________________________________________________________; 294 main(int argc, char **argv); 295 {; 296 // Create a new ROOT binary machine independent file.; 297 // Note that this file may contain any kind of ROOT objects, histograms,trees; 298 // pictures, graphics objects, detector geometries, tracks, events, etc..; 299 // This file is now becoming the current directory.; 300 TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");; 301 ; 302 // Create some histograms and a profile histogram; 303 TH1F hpx(""hpx"",""This is the px distribution"",100,-4,4);; 304 TH2F hpxpy(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; 305 TProfile hprof(""hprof"",""Pr",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:14383,Usability,simpl,simple,14383,"tree; 283 //; 284 // These objects are filled with some random numbers and saved on a file.; 285 ; 286 #include ""TFile.h""; 287 #include ""TH1.h""; 288 #include ""TH2.h""; 289 #include ""TProfile.h""; 290 #include ""TRandom.h""; 291 #include ""TTree.h""; 292 ; 293 //__________________________________________________________________________; 294 main(int argc, char **argv); 295 {; 296 // Create a new ROOT binary machine independent file.; 297 // Note that this file may contain any kind of ROOT objects, histograms,trees; 298 // pictures, graphics objects, detector geometries, tracks, events, etc..; 299 // This file is now becoming the current directory.; 300 TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");; 301 ; 302 // Create some histograms and a profile histogram; 303 TH1F hpx(""hpx"",""This is the px distribution"",100,-4,4);; 304 TH2F hpxpy(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; 305 TProfile hprof(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; 306 ; 307 // Define some simple structures; 308 typedef struct {Float_t x,y,z;} POINT;; 309 typedef struct {; 310 Int_t ntrack,nseg,nvertex;; 311 UInt_t flag;; 312 Float_t temperature;; 313 } EVENTN;; 314 POINT point;; 315 EVENTN eventn;; 316 ; 317 // Create a ROOT Tree; 318 TTree tree(""T"",""An example of ROOT tree with a few branches"");; 319 tree.Branch(""point"",&point,""x:y:z"");; 320 tree.Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; 321 tree.Branch(""hpx"",""TH1F"",&hpx,128000,0);; 322 ; 323 Float_t px,py,pz;; 324 ; 325 // Here we start a loop on 1000 events; 326 for ( Int_t i=0; i<1000; i++) {; 327 gRandom->Rannor(px,py);; 328 pz = px*px + py*py;; 329 const auto random = gRandom->::Rndm(1);; 330 ; 331 // Fill histograms; 332 hpx.Fill(px);; 333 hpxpy.Fill(px,py,1);; 334 hprof.Fill(px,pz,1);; 335 ; 336 // Fill structures; 337 point.x = 10*(random-1);; 338 point.y = 5*random;; 339 point.z = 20*random;; 340 eventn.ntrack = Int_t(100*random);; 341 eventn.nseg = Int_t(2*eventn.ntrack);; 342",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:15573,Usability,simpl,simple,15573,"eventn;; 316 ; 317 // Create a ROOT Tree; 318 TTree tree(""T"",""An example of ROOT tree with a few branches"");; 319 tree.Branch(""point"",&point,""x:y:z"");; 320 tree.Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; 321 tree.Branch(""hpx"",""TH1F"",&hpx,128000,0);; 322 ; 323 Float_t px,py,pz;; 324 ; 325 // Here we start a loop on 1000 events; 326 for ( Int_t i=0; i<1000; i++) {; 327 gRandom->Rannor(px,py);; 328 pz = px*px + py*py;; 329 const auto random = gRandom->::Rndm(1);; 330 ; 331 // Fill histograms; 332 hpx.Fill(px);; 333 hpxpy.Fill(px,py,1);; 334 hprof.Fill(px,pz,1);; 335 ; 336 // Fill structures; 337 point.x = 10*(random-1);; 338 point.y = 5*random;; 339 point.z = 20*random;; 340 eventn.ntrack = Int_t(100*random);; 341 eventn.nseg = Int_t(2*eventn.ntrack);; 342 eventn.nvertex = 1;; 343 eventn.flag = Int_t(random+0.5);; 344 eventn.temperature = 20+random;; 345 ; 346 // Fill the tree. For each event, save the 2 structures and 3 objects; 347 // In this simple example, the objects hpx, hprof and hpxpy are slightly; 348 // different from event to event. We expect a big compression factor!; 349 tree->Fill();; 350 }; 351 // End of the loop; 352 ; 353 tree.Print();; 354 ; 355 // Save all objects in this file; 356 hfile.Write();; 357 ; 358 // Close the file. Note that this is automatically done when you leave; 359 // the application upon file destruction.; 360 hfile.Close();; 361 ; 362 return 0;; 363}; 364~~~; 365*/; 366 ; 367#include <ROOT/RConfig.hxx>; 368#include ""TTree.h""; 369 ; 370#include ""ROOT/TIOFeatures.hxx""; 371#include ""TArrayC.h""; 372#include ""TBufferFile.h""; 373#include ""TBaseClass.h""; 374#include ""TBasket.h""; 375#include ""TBranchClones.h""; 376#include ""TBranchElement.h""; 377#include ""TBranchObject.h""; 378#include ""TBranchRef.h""; 379#include ""TBrowser.h""; 380#include ""TClass.h""; 381#include ""TClassEdit.h""; 382#include ""TClonesArray.h""; 383#include ""TCut.h""; 384#include ""TDataMember.h""; 385#include ""TDataType.h""; 386#include ""TDirectory.h""; 38",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:70336,Usability,simpl,simply,70336," The collection itself cannot be a TClonesArray.; 1772///; 1773/// The function returns the total number of branches created.; 1774///; 1775/// If name is given, all branch names will be prefixed with name_.; 1776///; 1777/// IMPORTANT NOTE1: This function should not be called with splitlevel < 1.; 1778///; 1779/// IMPORTANT NOTE2: The branches created by this function will have names; 1780/// corresponding to the collection or object names. It is important; 1781/// to give names to collections to avoid misleading branch names or; 1782/// identical branch names. By default collections have a name equal to; 1783/// the corresponding class name, e.g. the default name for a TList is ""TList"".; 1784///; 1785/// And in general, in case two or more master branches contain subbranches; 1786/// with identical names, one must add a ""."" (dot) character at the end; 1787/// of the master branch name. This will force the name of the subbranches; 1788/// to be of the form `master.subbranch` instead of simply `subbranch`.; 1789/// This situation happens when the top level object; 1790/// has two or more members referencing the same class.; 1791/// For example, if a Tree has two branches B1 and B2 corresponding; 1792/// to objects of the same class MyClass, one can do:; 1793/// ~~~ {.cpp}; 1794/// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; 1795/// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; 1796/// ~~~; 1797/// if MyClass has 3 members a,b,c, the two instructions above will generate; 1798/// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; 1799///; 1800/// Example:; 1801/// ~~~ {.cpp}; 1802/// {; 1803/// TTree T(""T"",""test list"");; 1804/// TList *list = new TList();; 1805///; 1806/// TObjArray *a1 = new TObjArray();; 1807/// a1->SetName(""a1"");; 1808/// list->Add(a1);; 1809/// TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; 1810/// TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; 1811/// a1->Add(ha1a);; 1812/// a1->Add(ha1b);; 1813/// TObjArray *b1 = new TObjArray();; 1814/// b1->SetName",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:75119,Usability,simpl,simple,75119,"A() == TFolder::Class()) {; 1899 Branch(curname, bufsize, splitlevel - 1);; 1900 } else {; 1901 void* add = (void*) folder->GetListOfFolders()->GetObjectRef(obj);; 1902 for (Int_t i = 0; i < 1000; ++i) {; 1903 if (curname[i] == 0) {; 1904 break;; 1905 }; 1906 if (curname[i] == '/') {; 1907 curname[i] = '.';; 1908 }; 1909 }; 1910 Int_t noccur = folder->Occurence(obj);; 1911 if (noccur > 0) {; 1912 snprintf(occur,20, ""_%d"", noccur);; 1913 strlcat(curname, occur,1000);; 1914 }; 1915 TBranchElement* br = (TBranchElement*) Bronch(curname, obj->ClassName(), add, bufsize, splitlevel - 1);; 1916 if (br) br->SetBranchFolder();; 1917 }; 1918 }; 1919 delete[] curname;; 1920 return GetListOfBranches()->GetEntries() - nbranches;; 1921}; 1922 ; 1923////////////////////////////////////////////////////////////////////////////////; 1924/// Create a new TTree Branch.; 1925///; 1926/// This Branch constructor is provided to support non-objects in; 1927/// a Tree. The variables described in leaflist may be simple; 1928/// variables or structures. // See the two following; 1929/// constructors for writing objects in a Tree.; 1930///; 1931/// By default the branch buffers are stored in the same file as the Tree.; 1932/// use TBranch::SetFile to specify a different file; 1933///; 1934/// * address is the address of the first item of a structure.; 1935/// * leaflist is the concatenation of all the variable names and types; 1936/// separated by a colon character :; 1937/// The variable name and the variable type are separated by a slash (/).; 1938/// The variable type may be 0,1 or 2 characters. If no type is given,; 1939/// the type of the variable is assumed to be the same as the previous; 1940/// variable. If the first variable does not have a type, it is assumed; 1941/// of type F by default. The list of currently supported types is given below:; 1942/// - `C` : a character string terminated by the 0 character; 1943/// - `B` : an 8 bit signed integer (`Char_t`); Treated as a character w",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:81846,Usability,simpl,simply,81846,"object of class classname.; 2039/// IMPORTANT: classname must derive from TObject.; 2040/// The class dictionary must be available (ClassDef in class header).; 2041///; 2042/// This option requires access to the library where the corresponding class; 2043/// is defined. Accessing one single data member in the object implies; 2044/// reading the full object.; 2045/// See the next Branch constructor for a more efficient storage; 2046/// in case the entry consists of arrays of identical objects.; 2047///; 2048/// By default the branch buffers are stored in the same file as the Tree.; 2049/// use TBranch::SetFile to specify a different file; 2050///; 2051/// IMPORTANT NOTE about branch names:; 2052///; 2053/// And in general, in case two or more master branches contain subbranches; 2054/// with identical names, one must add a ""."" (dot) character at the end; 2055/// of the master branch name. This will force the name of the subbranches; 2056/// to be of the form `master.subbranch` instead of simply `subbranch`.; 2057/// This situation happens when the top level object; 2058/// has two or more members referencing the same class.; 2059/// For example, if a Tree has two branches B1 and B2 corresponding; 2060/// to objects of the same class MyClass, one can do:; 2061/// ~~~ {.cpp}; 2062/// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; 2063/// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; 2064/// ~~~; 2065/// if MyClass has 3 members a,b,c, the two instructions above will generate; 2066/// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; 2067///; 2068/// bufsize is the buffer size in bytes for this branch; 2069/// The default value is 32000 bytes and should be ok for most cases.; 2070/// You can specify a larger value (e.g. 256000) if your Tree is not split; 2071/// and each entry is large (Megabytes); 2072/// A small value for bufsize is optimum if you intend to access; 2073/// the entries in the Tree randomly and your Tree is in split mode.; 2074 ; 2075TBranch* TTree::BranchOl",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:94442,Usability,simpl,simply,94442,"is the address of a pointer to an object of class; 2362/// classname. The class dictionary must be available (ClassDef; 2363/// in class header).; 2364///; 2365/// Note: See the comments in TBranchElement::SetAddress() for a more; 2366/// detailed discussion of the meaning of the addr parameter.; 2367///; 2368/// This option requires access to the library where the; 2369/// corresponding class is defined. Accessing one single data; 2370/// member in the object implies reading the full object.; 2371///; 2372/// By default the branch buffers are stored in the same file as the Tree.; 2373/// use TBranch::SetFile to specify a different file; 2374///; 2375/// IMPORTANT NOTE about branch names:; 2376///; 2377/// And in general, in case two or more master branches contain subbranches; 2378/// with identical names, one must add a ""."" (dot) character at the end; 2379/// of the master branch name. This will force the name of the subbranches; 2380/// to be of the form `master.subbranch` instead of simply `subbranch`.; 2381/// This situation happens when the top level object; 2382/// has two or more members referencing the same class.; 2383/// For example, if a Tree has two branches B1 and B2 corresponding; 2384/// to objects of the same class MyClass, one can do:; 2385/// ~~~ {.cpp}; 2386/// tree.Branch(""B1."",""MyClass"",&b1,8000,1);; 2387/// tree.Branch(""B2."",""MyClass"",&b2,8000,1);; 2388/// ~~~; 2389/// if MyClass has 3 members a,b,c, the two instructions above will generate; 2390/// subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c; 2391///; 2392/// bufsize is the buffer size in bytes for this branch; 2393/// The default value is 32000 bytes and should be ok for most cases.; 2394/// You can specify a larger value (e.g. 256000) if your Tree is not split; 2395/// and each entry is large (Megabytes); 2396/// A small value for bufsize is optimum if you intend to access; 2397/// the entries in the Tree randomly and your Tree is in split mode.; 2398///; 2399/// Use splitlevel < 0",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:112945,Usability,usab,usable,112945,"1//; 2852/// - kMissingBranch (-5) : Missing branch; 2853/// - kInternalError (-4) : Internal error (could not find the type corresponding to a data type number); 2854/// - kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; 2855/// - kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; 2856/// - kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; 2857/// - kMatch (0) : perfect match; 2858/// - kMatchConversion (1) : match with (I/O) conversion; 2859/// - kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; 2860/// - kMakeClass (3) : MakeClass mode so we can not check.; 2861/// - kVoidPtr (4) : void* passed so no check was made.; 2862/// - kNoCheck (5) : Underlying TBranch not yet available so no check was made.; 2863/// In addition this can be multiplexed with the two bits:; 2864/// - kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; 2865/// - kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode.; 2866/// This bits can be masked out by using kDecomposedObjMask; 2867 ; 2868Int_t TTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, bool isptr); 2869{; 2870 if (GetMakeClass()) {; 2871 // If we are in MakeClass mode so we do not really use classes.; 2872 return kMakeClass;; 2873 }; 2874 ; 2875 // Let's determine what we need!; 2876 TClass* expectedClass = nullptr;; 2877 EDataType expectedType = kOther_t;; 2878 if (0 != branch->GetExpectedType(expectedClass,expectedType) ) {; 2879 // Something went wrong, the warning message has already been issued.; 2880 return kInternalError;; 2881 }; 2882 bool isBranchElement = branch->InheritsFrom( TBranchElement::Class() );; 2883 if (expectedClass && dat",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:113097,Usability,usab,usable,113097,"ledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; 2855/// - kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; 2856/// - kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; 2857/// - kMatch (0) : perfect match; 2858/// - kMatchConversion (1) : match with (I/O) conversion; 2859/// - kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; 2860/// - kMakeClass (3) : MakeClass mode so we can not check.; 2861/// - kVoidPtr (4) : void* passed so no check was made.; 2862/// - kNoCheck (5) : Underlying TBranch not yet available so no check was made.; 2863/// In addition this can be multiplexed with the two bits:; 2864/// - kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; 2865/// - kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode.; 2866/// This bits can be masked out by using kDecomposedObjMask; 2867 ; 2868Int_t TTree::CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, bool isptr); 2869{; 2870 if (GetMakeClass()) {; 2871 // If we are in MakeClass mode so we do not really use classes.; 2872 return kMakeClass;; 2873 }; 2874 ; 2875 // Let's determine what we need!; 2876 TClass* expectedClass = nullptr;; 2877 EDataType expectedType = kOther_t;; 2878 if (0 != branch->GetExpectedType(expectedClass,expectedType) ) {; 2879 // Something went wrong, the warning message has already been issued.; 2880 return kInternalError;; 2881 }; 2882 bool isBranchElement = branch->InheritsFrom( TBranchElement::Class() );; 2883 if (expectedClass && datatype == kOther_t && ptrClass == nullptr) {; 2884 if (isBranchElement) {; 2885 TBranchElement* bEl = (TBranchElement*)branch;; 2886 bEl->SetTargetClass( expectedClass->GetName() );; 288",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:130468,Usability,undo,undo,130468,"; 3256 lb1->RemoveAt(k);; 3257 delete b2;; 3258 b2 = nullptr;; 3259 lb1->Compress();; 3260 break;; 3261 }; 3262 }; 3263 }; 3264 }; 3265 }; 3266 leaves->Compress();; 3267 ; 3268 // Copy MakeClass status.; 3269 newtree->SetMakeClass(fMakeClass);; 3270 ; 3271 // Copy branch addresses.; 3272 CopyAddresses(newtree);; 3273 ; 3274 //; 3275 // Copy entries if requested.; 3276 //; 3277 ; 3278 if (nentries != 0) {; 3279 if (fastClone && (nentries < 0)) {; 3280 if ( newtree->CopyEntries( this, -1, option, false ) < 0 ) {; 3281 // There was a problem!; 3282 Error(""CloneTTree"", ""TTree has not been cloned\n"");; 3283 delete newtree;; 3284 newtree = nullptr;; 3285 return nullptr;; 3286 }; 3287 } else {; 3288 newtree->CopyEntries( this, nentries, option, false );; 3289 }; 3290 }; 3291 ; 3292 return newtree;; 3293}; 3294 ; 3295////////////////////////////////////////////////////////////////////////////////; 3296/// Set branch addresses of passed tree equal to ours.; 3297/// If undo is true, reset the branch addresses instead of copying them.; 3298/// This ensures 'separation' of a cloned tree from its original.; 3299 ; 3300void TTree::CopyAddresses(TTree* tree, bool undo); 3301{; 3302 // Copy branch addresses starting from branches.; 3303 TObjArray* branches = GetListOfBranches();; 3304 Int_t nbranches = branches->GetEntriesFast();; 3305 for (Int_t i = 0; i < nbranches; ++i) {; 3306 TBranch* branch = (TBranch*) branches->UncheckedAt(i);; 3307 if (branch->TestBit(kDoNotProcess)) {; 3308 continue;; 3309 }; 3310 if (undo) {; 3311 TBranch* br = tree->GetBranch(branch->GetName());; 3312 tree->ResetBranchAddress(br);; 3313 } else {; 3314 char* addr = branch->GetAddress();; 3315 if (!addr) {; 3316 if (branch->IsA() == TBranch::Class()) {; 3317 // If the branch was created using a leaflist, the branch itself may not have; 3318 // an address but the leaf might already.; 3319 TLeaf *firstleaf = (TLeaf*)branch->GetListOfLeaves()->At(0);; 3320 if (!firstleaf || firstleaf->GetValuePointer()) {; 3",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:130661,Usability,undo,undo,130661,"3268 // Copy MakeClass status.; 3269 newtree->SetMakeClass(fMakeClass);; 3270 ; 3271 // Copy branch addresses.; 3272 CopyAddresses(newtree);; 3273 ; 3274 //; 3275 // Copy entries if requested.; 3276 //; 3277 ; 3278 if (nentries != 0) {; 3279 if (fastClone && (nentries < 0)) {; 3280 if ( newtree->CopyEntries( this, -1, option, false ) < 0 ) {; 3281 // There was a problem!; 3282 Error(""CloneTTree"", ""TTree has not been cloned\n"");; 3283 delete newtree;; 3284 newtree = nullptr;; 3285 return nullptr;; 3286 }; 3287 } else {; 3288 newtree->CopyEntries( this, nentries, option, false );; 3289 }; 3290 }; 3291 ; 3292 return newtree;; 3293}; 3294 ; 3295////////////////////////////////////////////////////////////////////////////////; 3296/// Set branch addresses of passed tree equal to ours.; 3297/// If undo is true, reset the branch addresses instead of copying them.; 3298/// This ensures 'separation' of a cloned tree from its original.; 3299 ; 3300void TTree::CopyAddresses(TTree* tree, bool undo); 3301{; 3302 // Copy branch addresses starting from branches.; 3303 TObjArray* branches = GetListOfBranches();; 3304 Int_t nbranches = branches->GetEntriesFast();; 3305 for (Int_t i = 0; i < nbranches; ++i) {; 3306 TBranch* branch = (TBranch*) branches->UncheckedAt(i);; 3307 if (branch->TestBit(kDoNotProcess)) {; 3308 continue;; 3309 }; 3310 if (undo) {; 3311 TBranch* br = tree->GetBranch(branch->GetName());; 3312 tree->ResetBranchAddress(br);; 3313 } else {; 3314 char* addr = branch->GetAddress();; 3315 if (!addr) {; 3316 if (branch->IsA() == TBranch::Class()) {; 3317 // If the branch was created using a leaflist, the branch itself may not have; 3318 // an address but the leaf might already.; 3319 TLeaf *firstleaf = (TLeaf*)branch->GetListOfLeaves()->At(0);; 3320 if (!firstleaf || firstleaf->GetValuePointer()) {; 3321 // Either there is no leaf (and thus no point in copying the address); 3322 // or the leaf has an address but we can not copy it via the branche; 3323 // this will be c",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:131015,Usability,undo,undo,131015,"ror(""CloneTTree"", ""TTree has not been cloned\n"");; 3283 delete newtree;; 3284 newtree = nullptr;; 3285 return nullptr;; 3286 }; 3287 } else {; 3288 newtree->CopyEntries( this, nentries, option, false );; 3289 }; 3290 }; 3291 ; 3292 return newtree;; 3293}; 3294 ; 3295////////////////////////////////////////////////////////////////////////////////; 3296/// Set branch addresses of passed tree equal to ours.; 3297/// If undo is true, reset the branch addresses instead of copying them.; 3298/// This ensures 'separation' of a cloned tree from its original.; 3299 ; 3300void TTree::CopyAddresses(TTree* tree, bool undo); 3301{; 3302 // Copy branch addresses starting from branches.; 3303 TObjArray* branches = GetListOfBranches();; 3304 Int_t nbranches = branches->GetEntriesFast();; 3305 for (Int_t i = 0; i < nbranches; ++i) {; 3306 TBranch* branch = (TBranch*) branches->UncheckedAt(i);; 3307 if (branch->TestBit(kDoNotProcess)) {; 3308 continue;; 3309 }; 3310 if (undo) {; 3311 TBranch* br = tree->GetBranch(branch->GetName());; 3312 tree->ResetBranchAddress(br);; 3313 } else {; 3314 char* addr = branch->GetAddress();; 3315 if (!addr) {; 3316 if (branch->IsA() == TBranch::Class()) {; 3317 // If the branch was created using a leaflist, the branch itself may not have; 3318 // an address but the leaf might already.; 3319 TLeaf *firstleaf = (TLeaf*)branch->GetListOfLeaves()->At(0);; 3320 if (!firstleaf || firstleaf->GetValuePointer()) {; 3321 // Either there is no leaf (and thus no point in copying the address); 3322 // or the leaf has an address but we can not copy it via the branche; 3323 // this will be copied via the next loop (over the leaf).; 3324 continue;; 3325 }; 3326 }; 3327 // Note: This may cause an object to be allocated.; 3328 branch->SetAddress(nullptr);; 3329 addr = branch->GetAddress();; 3330 }; 3331 TBranch* br = tree->GetBranch(branch->GetFullName());; 3332 if (br) {; 3333 if (br->GetMakeClass() != branch->GetMakeClass()); 3334 br->SetMakeClass(branch->GetMakeClas",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:133051,Usability,undo,undo,133051,"s());; 3335 br->SetAddress(addr);; 3336 // The copy does not own any object allocated by SetAddress().; 3337 if (br->InheritsFrom(TBranchElement::Class())) {; 3338 ((TBranchElement*) br)->ResetDeleteObject();; 3339 }; 3340 } else {; 3341 Warning(""CopyAddresses"", ""Could not find branch named '%s' in tree named '%s'"", branch->GetName(), tree->GetName());; 3342 }; 3343 }; 3344 }; 3345 ; 3346 // Copy branch addresses starting from leaves.; 3347 TObjArray* tleaves = tree->GetListOfLeaves();; 3348 Int_t ntleaves = tleaves->GetEntriesFast();; 3349 std::set<TLeaf*> updatedLeafCount;; 3350 for (Int_t i = 0; i < ntleaves; ++i) {; 3351 TLeaf* tleaf = (TLeaf*) tleaves->UncheckedAt(i);; 3352 TBranch* tbranch = tleaf->GetBranch();; 3353 TBranch* branch = GetBranch(tbranch->GetName());; 3354 if (!branch) {; 3355 continue;; 3356 }; 3357 TLeaf* leaf = branch->GetLeaf(tleaf->GetName());; 3358 if (!leaf) {; 3359 continue;; 3360 }; 3361 if (branch->TestBit(kDoNotProcess)) {; 3362 continue;; 3363 }; 3364 if (undo) {; 3365 // Now we know whether the address has been transfered; 3366 tree->ResetBranchAddress(tbranch);; 3367 } else {; 3368 TBranchElement *mother = dynamic_cast<TBranchElement*>(leaf->GetBranch()->GetMother());; 3369 bool needAddressReset = false;; 3370 if (leaf->GetLeafCount() && (leaf->TestBit(TLeaf::kNewValue) || !leaf->GetValuePointer() || (mother && mother->IsObjectOwner())) && tleaf->GetLeafCount()); 3371 {; 3372 // If it is an array and it was allocated by the leaf itself,; 3373 // let's make sure it is large enough for the incoming data.; 3374 if (leaf->GetLeafCount()->GetMaximum() < tleaf->GetLeafCount()->GetMaximum()) {; 3375 leaf->GetLeafCount()->IncludeRange( tleaf->GetLeafCount() );; 3376 updatedLeafCount.insert(leaf->GetLeafCount());; 3377 needAddressReset = true;; 3378 } else {; 3379 needAddressReset = (updatedLeafCount.find(leaf->GetLeafCount()) != updatedLeafCount.end());; 3380 }; 3381 }; 3382 if (needAddressReset && leaf->GetValuePointer()) {; 3383 if (leaf",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:134481,Usability,simpl,simplest,134481," was allocated by the leaf itself,; 3373 // let's make sure it is large enough for the incoming data.; 3374 if (leaf->GetLeafCount()->GetMaximum() < tleaf->GetLeafCount()->GetMaximum()) {; 3375 leaf->GetLeafCount()->IncludeRange( tleaf->GetLeafCount() );; 3376 updatedLeafCount.insert(leaf->GetLeafCount());; 3377 needAddressReset = true;; 3378 } else {; 3379 needAddressReset = (updatedLeafCount.find(leaf->GetLeafCount()) != updatedLeafCount.end());; 3380 }; 3381 }; 3382 if (needAddressReset && leaf->GetValuePointer()) {; 3383 if (leaf->IsA() == TLeafElement::Class() && mother); 3384 mother->ResetAddress();; 3385 else; 3386 leaf->SetAddress(nullptr);; 3387 }; 3388 if (!branch->GetAddress() && !leaf->GetValuePointer()) {; 3389 // We should attempts to set the address of the branch.; 3390 // something like:; 3391 //(TBranchElement*)branch->GetMother()->SetAddress(0); 3392 //plus a few more subtleties (see TBranchElement::GetEntry).; 3393 //but for now we go the simplest route:; 3394 //; 3395 // Note: This may result in the allocation of an object.; 3396 branch->SetupAddresses();; 3397 }; 3398 if (branch->GetAddress()) {; 3399 tree->SetBranchAddress(branch->GetName(), (void*) branch->GetAddress());; 3400 TBranch* br = tree->GetBranch(branch->GetName());; 3401 if (br) {; 3402 if (br->IsA() != branch->IsA()) {; 3403 Error(; 3404 ""CopyAddresses"",; 3405 ""Branch kind mismatch between input tree '%s' and output tree '%s' for branch '%s': '%s' vs '%s'"",; 3406 tree->GetName(), br->GetTree()->GetName(), br->GetName(), branch->IsA()->GetName(),; 3407 br->IsA()->GetName());; 3408 }; 3409 // The copy does not own any object allocated by SetAddress().; 3410 // FIXME: We do too much here, br may not be a top-level branch.; 3411 if (br->InheritsFrom(TBranchElement::Class())) {; 3412 ((TBranchElement*) br)->ResetDeleteObject();; 3413 }; 3414 } else {; 3415 Warning(""CopyAddresses"", ""Could not find branch named '%s' in tree named '%s'"", branch->GetName(), tree->GetName());; 3416 }; 3417 }",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:135608,Usability,undo,undo,135608,"ress()) {; 3399 tree->SetBranchAddress(branch->GetName(), (void*) branch->GetAddress());; 3400 TBranch* br = tree->GetBranch(branch->GetName());; 3401 if (br) {; 3402 if (br->IsA() != branch->IsA()) {; 3403 Error(; 3404 ""CopyAddresses"",; 3405 ""Branch kind mismatch between input tree '%s' and output tree '%s' for branch '%s': '%s' vs '%s'"",; 3406 tree->GetName(), br->GetTree()->GetName(), br->GetName(), branch->IsA()->GetName(),; 3407 br->IsA()->GetName());; 3408 }; 3409 // The copy does not own any object allocated by SetAddress().; 3410 // FIXME: We do too much here, br may not be a top-level branch.; 3411 if (br->InheritsFrom(TBranchElement::Class())) {; 3412 ((TBranchElement*) br)->ResetDeleteObject();; 3413 }; 3414 } else {; 3415 Warning(""CopyAddresses"", ""Could not find branch named '%s' in tree named '%s'"", branch->GetName(), tree->GetName());; 3416 }; 3417 } else {; 3418 tleaf->SetAddress(leaf->GetValuePointer());; 3419 }; 3420 }; 3421 }; 3422 ; 3423 if (undo &&; 3424 ( tree->IsA()->InheritsFrom(""TNtuple"") || tree->IsA()->InheritsFrom(""TNtupleD"") ); 3425 ) {; 3426 tree->ResetBranchAddresses();; 3427 }; 3428}; 3429 ; 3430namespace {; 3431 ; 3432 enum EOnIndexError { kDrop, kKeep, kBuild };; 3433 ; 3434 bool R__HandleIndex(EOnIndexError onIndexError, TTree *newtree, TTree *oldtree); 3435 {; 3436 // Return true if we should continue to handle indices, false otherwise.; 3437 ; 3438 bool withIndex = true;; 3439 ; 3440 if ( newtree->GetTreeIndex() ) {; 3441 if ( oldtree->GetTree()->GetTreeIndex() == nullptr ) {; 3442 switch (onIndexError) {; 3443 case kDrop:; 3444 delete newtree->GetTreeIndex();; 3445 newtree->SetTreeIndex(nullptr);; 3446 withIndex = false;; 3447 break;; 3448 case kKeep:; 3449 // Nothing to do really.; 3450 break;; 3451 case kBuild:; 3452 // Build the index then copy it; 3453 if (oldtree->GetTree()->BuildIndex(newtree->GetTreeIndex()->GetMajorName(), newtree->GetTreeIndex()->GetMinorName())) {; 3454 newtree->GetTreeIndex()->Append(oldtree->GetTree()-",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:152933,Usability,simpl,simplest,152933,"orms:; 3869/// - ""e1"" produces a 1-d histogram (TH1F) of expression ""e1""; 3870/// - ""e1:e2"" produces an unbinned 2-d scatter-plot (TGraph) of ""e1""; 3871/// on the y-axis versus ""e2"" on the x-axis; 3872/// - ""e1:e2:e3"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; 3873/// vs ""e2"" vs ""e3"" on the z-, y-, x-axis, respectively; 3874/// - ""e1:e2:e3:e4"" produces an unbinned 3-d scatter-plot (TPolyMarker3D) of ""e1""; 3875/// vs ""e2"" vs ""e3"" and ""e4"" mapped on the current color palette.; 3876/// (to create histograms in the 2, 3, and 4 dimensional case,; 3877/// see section ""Saving the result of Draw to an histogram""); 3878/// - ""e1:e2:e3:e4:e5"" with option ""GL5D"" produces a 5D plot using OpenGL. `gStyle->SetCanvasPreferGL(true)` is needed.; 3879/// - Any number of variables no fewer than two can be used with the options ""CANDLE"" and ""PARA""; 3880/// - An arbitrary number of variables can be used with the option ""GOFF""; 3881///; 3882/// Examples:; 3883/// - ""x"": the simplest case, it draws a 1-Dim histogram of column x; 3884/// - ""sqrt(x)"", ""x*y/z"": draw histogram with the values of the specified numerical expression across TTree events; 3885/// - ""y:sqrt(x)"": 2-Dim histogram of y versus sqrt(x); 3886/// - ""px:py:pz:2.5*E"": produces a 3-d scatter-plot of px vs py ps pz; 3887/// and the color number of each marker will be 2.5*E.; 3888/// If the color number is negative it is set to 0.; 3889/// If the color number is greater than the current number of colors; 3890/// it is set to the highest color number. The default number of; 3891/// colors is 50. See TStyle::SetPalette for setting a new color palette.; 3892///; 3893/// The expressions can use all the operations and built-in functions; 3894/// supported by TFormula (see TFormula::Analyze()), including free; 3895/// functions taking numerical arguments (e.g. TMath::Bessel()).; 3896/// In addition, you can call member functions taking numerical; 3897/// arguments. For example, these are two valid expressions:; 38",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:155086,Usability,simpl,simple,155086,"rblock; 3903/// \param [in] selection; 3904/// \parblock; 3905/// A string containing a selection expression.; 3906/// In a selection all usual C++ mathematical and logical operators are allowed.; 3907/// The value corresponding to the selection expression is used as a weight; 3908/// to fill the histogram (a weight of 0 is equivalent to not filling the histogram).\n; 3909/// \n; 3910/// Examples:; 3911/// - ""x<y && sqrt(z)>3.2"": returns a weight = 0 or 1; 3912/// - ""(x+y)*(sqrt(z)>3.2)"": returns a weight = x+y if sqrt(z)>3.2, 0 otherwise\n; 3913/// \n; 3914/// If the selection expression returns an array, it is iterated over in sync with the; 3915/// array returned by the varexp argument (as described below in ""Drawing expressions using arrays and array; 3916/// elements""). For example, if, for a given event, varexp evaluates to; 3917/// `{1., 2., 3.}` and selection evaluates to `{0, 1, 0}`, the resulting histogram is filled with the value 2. For example, for each event here we perform a simple object selection:; 3918/// ~~~{.cpp}; 3919/// // Muon_pt is an array: fill a histogram with the array elements > 100 in each event; 3920/// tree->Draw('Muon_pt', 'Muon_pt > 100'); 3921/// ~~~; 3922/// \endparblock; 3923/// \param [in] option; 3924/// \parblock; 3925/// The drawing option.; 3926/// - When an histogram is produced it can be any histogram drawing option; 3927/// listed in THistPainter.; 3928/// - when no option is specified:; 3929/// - the default histogram drawing option is used; 3930/// if the expression is of the form ""e1"".; 3931/// - if the expression is of the form ""e1:e2""or ""e1:e2:e3"" a cloud of; 3932/// unbinned 2D or 3D points is drawn respectively.; 3933/// - if the expression has four fields ""e1:e2:e3:e4"" a cloud of unbinned 3D; 3934/// points is produced with e1 vs e2 vs e3, and e4 is mapped on the current color; 3935/// palette.; 3936/// - If option COL is specified when varexp has three fields:; 3937/// ~~~ {.cpp}; 3938/// tree.Draw(""e1:e2:e3"","""",""",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:184688,Usability,simpl,simple,184688,"t_t nleaves = fLeaves.GetEntriesFast();; 4536 for (Int_t i = 0; i < nleaves; ++i) {; 4537 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);; 4538 TBranch* branch = (TBranch*) leaf->GetBranch();; 4539 Int_t nbaskets = branch->GetListOfBaskets()->GetEntries();; 4540 for (Int_t j = 0; j < nbaskets - 1; ++j) {; 4541 if ((j == branch->GetReadBasket()) || (j == branch->GetWriteBasket())) {; 4542 continue;; 4543 }; 4544 TBasket* basket = (TBasket*)branch->GetListOfBaskets()->UncheckedAt(j);; 4545 if (basket) {; 4546 basket->DropBuffers();; 4547 if (fTotalBuffers < fMaxVirtualSize) {; 4548 return;; 4549 }; 4550 }; 4551 }; 4552 }; 4553}; 4554 ; 4555////////////////////////////////////////////////////////////////////////////////; 4556/// Fill all branches.; 4557///; 4558/// This function loops on all the branches of this tree. For; 4559/// each branch, it copies to the branch buffer (basket) the current; 4560/// values of the leaves data types. If a leaf is a simple data type,; 4561/// a simple conversion to a machine independent format has to be done.; 4562///; 4563/// This machine independent version of the data is copied into a; 4564/// basket (each branch has its own basket). When a basket is full; 4565/// (32k worth of data by default), it is then optionally compressed; 4566/// and written to disk (this operation is also called committing or; 4567/// 'flushing' the basket). The committed baskets are then; 4568/// immediately removed from memory.; 4569///; 4570/// The function returns the number of bytes committed to the; 4571/// individual branches.; 4572///; 4573/// If a write error occurs, the number of bytes returned is -1.; 4574///; 4575/// If no data are written, because, e.g., the branch is disabled,; 4576/// the number of bytes returned is 0.; 4577///; 4578/// __The baskets are flushed and the Tree header saved at regular intervals__; 4579///; 4580/// At regular intervals, when the amount of data written so far is; 4581/// greater than fAutoFlush (see SetAutoFlush) a",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:184717,Usability,simpl,simple,184717,"t_t nleaves = fLeaves.GetEntriesFast();; 4536 for (Int_t i = 0; i < nleaves; ++i) {; 4537 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(i);; 4538 TBranch* branch = (TBranch*) leaf->GetBranch();; 4539 Int_t nbaskets = branch->GetListOfBaskets()->GetEntries();; 4540 for (Int_t j = 0; j < nbaskets - 1; ++j) {; 4541 if ((j == branch->GetReadBasket()) || (j == branch->GetWriteBasket())) {; 4542 continue;; 4543 }; 4544 TBasket* basket = (TBasket*)branch->GetListOfBaskets()->UncheckedAt(j);; 4545 if (basket) {; 4546 basket->DropBuffers();; 4547 if (fTotalBuffers < fMaxVirtualSize) {; 4548 return;; 4549 }; 4550 }; 4551 }; 4552 }; 4553}; 4554 ; 4555////////////////////////////////////////////////////////////////////////////////; 4556/// Fill all branches.; 4557///; 4558/// This function loops on all the branches of this tree. For; 4559/// each branch, it copies to the branch buffer (basket) the current; 4560/// values of the leaves data types. If a leaf is a simple data type,; 4561/// a simple conversion to a machine independent format has to be done.; 4562///; 4563/// This machine independent version of the data is copied into a; 4564/// basket (each branch has its own basket). When a basket is full; 4565/// (32k worth of data by default), it is then optionally compressed; 4566/// and written to disk (this operation is also called committing or; 4567/// 'flushing' the basket). The committed baskets are then; 4568/// immediately removed from memory.; 4569///; 4570/// The function returns the number of bytes committed to the; 4571/// individual branches.; 4572///; 4573/// If a write error occurs, the number of bytes returned is -1.; 4574///; 4575/// If no data are written, because, e.g., the branch is disabled,; 4576/// the number of bytes returned is 0.; 4577///; 4578/// __The baskets are flushed and the Tree header saved at regular intervals__; 4579///; 4580/// At regular intervals, when the amount of data written so far is; 4581/// greater than fAutoFlush (see SetAutoFlush) a",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:229388,Usability,clear,clear,229388,".; 5788 if (fBranchRef && fBranchRef != fSeqBranches[0]) {; 5789 fSeqBranches.push_back(fBranchRef);; 5790 }; 5791 ; 5792 // The branches to be processed sequentially are those that are the leaf count of another branch; 5793 if (checkLeafCount) {; 5794 for (Int_t i = 0; i < nbranches; i++) {; 5795 TBranch* branch = (TBranch*)fBranches.UncheckedAt(i);; 5796 auto leafCount = ((TLeaf*)branch->GetListOfLeaves()->At(0))->GetLeafCount();; 5797 if (leafCount) {; 5798 auto countBranch = leafCount->GetBranch();; 5799 if (std::find(fSeqBranches.begin(), fSeqBranches.end(), countBranch) == fSeqBranches.end()) {; 5800 fSeqBranches.push_back(countBranch);; 5801 }; 5802 }; 5803 }; 5804 }; 5805 ; 5806 // Any branch that is not a leaf count can be safely processed in parallel when reading; 5807 // We need to reset the vector to make sure we do not re-add several times the same branch.; 5808 if (!checkLeafCount) {; 5809 fSortedBranches.clear();; 5810 }; 5811 for (Int_t i = 0; i < nbranches; i++) {; 5812 Long64_t bbytes = 0;; 5813 TBranch* branch = (TBranch*)fBranches.UncheckedAt(i);; 5814 if (std::find(fSeqBranches.begin(), fSeqBranches.end(), branch) == fSeqBranches.end()) {; 5815 bbytes = branch->GetTotBytes(""*"");; 5816 fSortedBranches.emplace_back(bbytes, branch);; 5817 }; 5818 }; 5819 ; 5820 // Initially sort parallel branches by size; 5821 std::sort(fSortedBranches.begin(),; 5822 fSortedBranches.end(),; 5823 [](std::pair<Long64_t,TBranch*> a, std::pair<Long64_t,TBranch*> b) {; 5824 return a.first > b.first;; 5825 });; 5826 ; 5827 for (size_t i = 0; i < fSortedBranches.size(); i++) {; 5828 fSortedBranches[i].first = 0LL;; 5829 }; 5830}; 5831 ; 5832////////////////////////////////////////////////////////////////////////////////; 5833/// Sorts top-level branches by the last average task time recorded per branch.; 5834 ; 5835void TTree::SortBranchesByTime(); 5836{; 5837 for (size_t i = 0; i < fSortedBranches.size(); i++) {; 5838 fSortedBranches[i].first *= kNEntriesResortInv;; 5839",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:295964,Usability,simpl,simply,295964,"a 1-D, 2-D, etc.,; 7495/// projection of the tree will be filled in histogram hname.; 7496/// Note that the dimension of hname must match with the dimension of varexp.; 7497///; 7498 ; 7499Long64_t TTree::Project(const char* hname, const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); 7500{; 7501 TString var;; 7502 var.Form(""%s>>%s"", varexp, hname);; 7503 TString opt(""goff"");; 7504 if (option) {; 7505 opt.Form(""%sgoff"", option);; 7506 }; 7507 Long64_t nsel = Draw(var, selection, opt, nentries, firstentry);; 7508 return nsel;; 7509}; 7510 ; 7511////////////////////////////////////////////////////////////////////////////////; 7512/// Loop over entries and return a TSQLResult object containing entries following selection.; 7513 ; 7514TSQLResult* TTree::Query(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); 7515{; 7516 GetPlayer();; 7517 if (fPlayer) {; 7518 return fPlayer->Query(varexp, selection, option, nentries, firstentry);; 7519 }; 7520 return nullptr;; 7521}; 7522 ; 7523////////////////////////////////////////////////////////////////////////////////; 7524/// Create or simply read branches from filename.; 7525///; 7526/// if branchDescriptor = """" (default), it is assumed that the Tree descriptor; 7527/// is given in the first line of the file with a syntax like; 7528/// ~~~ {.cpp}; 7529/// A/D:Table[2]/F:Ntracks/I:astring/C; 7530/// ~~~; 7531/// otherwise branchDescriptor must be specified with the above syntax.; 7532///; 7533/// - If the type of the first variable is not specified, it is assumed to be ""/F""; 7534/// - If the type of any other variable is not specified, the type of the previous; 7535/// variable is assumed. eg; 7536/// - `x:y:z` (all variables are assumed of type ""F""); 7537/// - `x/D:y:z` (all variables are of type ""D""); 7538/// - `x:y/D:z` (x is type ""F"", y and z of type ""D""); 7539///; 7540/// delimiter allows for the use of another delimiter besid",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:299369,Usability,clear,clear,299369,"Error(""ReadFile"",""Cannot open file: %s"",filename);; 7576 return 0;; 7577 }; 7578 const char* ext = strrchr(filename, '.');; 7579 if(ext && ((strcmp(ext, "".csv"") == 0) || (strcmp(ext, "".CSV"") == 0)) && delimiter == ' ') {; 7580 delimiter = ',';; 7581 }; 7582 return ReadStream(in, branchDescriptor, delimiter);; 7583}; 7584 ; 7585////////////////////////////////////////////////////////////////////////////////; 7586/// Determine which newline this file is using.; 7587/// Return '\\r' for Windows '\\r\\n' as that already terminates.; 7588 ; 7589char TTree::GetNewlineValue(std::istream &inputStream); 7590{; 7591 Long_t inPos = inputStream.tellg();; 7592 char newline = '\n';; 7593 while(true) {; 7594 char c = 0;; 7595 inputStream.get(c);; 7596 if(!inputStream.good()) {; 7597 Error(""ReadStream"",""Error reading stream: no newline found."");; 7598 return 0;; 7599 }; 7600 if(c == newline) break;; 7601 if(c == '\r') {; 7602 newline = '\r';; 7603 break;; 7604 }; 7605 }; 7606 inputStream.clear();; 7607 inputStream.seekg(inPos);; 7608 return newline;; 7609}; 7610 ; 7611////////////////////////////////////////////////////////////////////////////////; 7612/// Create or simply read branches from an input stream.; 7613///; 7614/// \see reference information for TTree::ReadFile; 7615 ; 7616Long64_t TTree::ReadStream(std::istream& inputStream, const char *branchDescriptor, char delimiter); 7617{; 7618 char newline = 0;; 7619 std::stringstream ss;; 7620 std::istream *inTemp;; 7621 Long_t inPos = inputStream.tellg();; 7622 if (!inputStream.good()) {; 7623 Error(""ReadStream"",""Error reading stream"");; 7624 return 0;; 7625 }; 7626 if (inPos == -1) {; 7627 ss << std::cin.rdbuf();; 7628 newline = GetNewlineValue(ss);; 7629 inTemp = &ss;; 7630 } else {; 7631 newline = GetNewlineValue(inputStream);; 7632 inTemp = &inputStream;; 7633 }; 7634 std::istream& in = *inTemp;; 7635 Long64_t nlines = 0;; 7636 ; 7637 TBranch *branch = nullptr;; 7638 Int_t nbranches = fBranches.GetEntries();; 7639 if (nbranch",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:299551,Usability,simpl,simply,299551,"ame, '.');; 7579 if(ext && ((strcmp(ext, "".csv"") == 0) || (strcmp(ext, "".CSV"") == 0)) && delimiter == ' ') {; 7580 delimiter = ',';; 7581 }; 7582 return ReadStream(in, branchDescriptor, delimiter);; 7583}; 7584 ; 7585////////////////////////////////////////////////////////////////////////////////; 7586/// Determine which newline this file is using.; 7587/// Return '\\r' for Windows '\\r\\n' as that already terminates.; 7588 ; 7589char TTree::GetNewlineValue(std::istream &inputStream); 7590{; 7591 Long_t inPos = inputStream.tellg();; 7592 char newline = '\n';; 7593 while(true) {; 7594 char c = 0;; 7595 inputStream.get(c);; 7596 if(!inputStream.good()) {; 7597 Error(""ReadStream"",""Error reading stream: no newline found."");; 7598 return 0;; 7599 }; 7600 if(c == newline) break;; 7601 if(c == '\r') {; 7602 newline = '\r';; 7603 break;; 7604 }; 7605 }; 7606 inputStream.clear();; 7607 inputStream.seekg(inPos);; 7608 return newline;; 7609}; 7610 ; 7611////////////////////////////////////////////////////////////////////////////////; 7612/// Create or simply read branches from an input stream.; 7613///; 7614/// \see reference information for TTree::ReadFile; 7615 ; 7616Long64_t TTree::ReadStream(std::istream& inputStream, const char *branchDescriptor, char delimiter); 7617{; 7618 char newline = 0;; 7619 std::stringstream ss;; 7620 std::istream *inTemp;; 7621 Long_t inPos = inputStream.tellg();; 7622 if (!inputStream.good()) {; 7623 Error(""ReadStream"",""Error reading stream"");; 7624 return 0;; 7625 }; 7626 if (inPos == -1) {; 7627 ss << std::cin.rdbuf();; 7628 newline = GetNewlineValue(ss);; 7629 inTemp = &ss;; 7630 } else {; 7631 newline = GetNewlineValue(inputStream);; 7632 inTemp = &inputStream;; 7633 }; 7634 std::istream& in = *inTemp;; 7635 Long64_t nlines = 0;; 7636 ; 7637 TBranch *branch = nullptr;; 7638 Int_t nbranches = fBranches.GetEntries();; 7639 if (nbranches == 0) {; 7640 char *bdname = new char[4000];; 7641 char *bd = new char[100000];; 7642 Int_t nch = 0;; 7643 if",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:305865,Usability,clear,clear,305865,"ading whitespace; 7781 if (tok.IsNull() && delimiter == ' ') {; 7782 // 1 2 should not be interpreted as 1,,,2 but 1, 2.; 7783 // Thus continue until we have a non-empty token.; 7784 continue;; 7785 }; 7786 ; 7787 if (!remainingLeafLen) {; 7788 // next branch!; 7789 branch = (TBranch*)fBranches.At(iBranch);; 7790 }; 7791 TLeaf *leaf = (TLeaf*)branch->GetListOfLeaves()->At(0);; 7792 if (!remainingLeafLen) {; 7793 remainingLeafLen = leaf->GetLen();; 7794 if (leaf->GetMaximum() > 0) {; 7795 // This is a dynamic leaf length, i.e. most likely a TLeafC's; 7796 // string size. This still translates into one token:; 7797 remainingLeafLen = 1;; 7798 }; 7799 ; 7800 leafData = tok;; 7801 } else {; 7802 // append token to laf data:; 7803 leafData += "" "";; 7804 leafData += tok;; 7805 }; 7806 --remainingLeafLen;; 7807 if (remainingLeafLen) {; 7808 // need more columns for this branch:; 7809 continue;; 7810 }; 7811 ++iBranch;; 7812 ; 7813 // initialize stringstream with token; 7814 sToken.clear();; 7815 sToken.seekp(0, std::ios_base::beg);; 7816 sToken.str(leafData.Data());; 7817 sToken.seekg(0, std::ios_base::beg);; 7818 leaf->ReadValue(sToken, 0 /* 0 = ""all"" */);; 7819 if (gDebug > 3) {; 7820 Info(""ReadStream"", ""%5lld:%3d:%d%d%d%d:%d%d%d%d:%s"",; 7821 nlines, iBranch,; 7822 (int)sToken.good(), (int)sToken.fail(),; 7823 (int)sToken.bad(), (int)sToken.eof(),; 7824 (int)in.good(), (int)in.fail(),; 7825 (int)in.bad(), (int)in.eof(),; 7826 sToken.str().c_str());; 7827 }; 7828 ; 7829 // Error handling; 7830 if (sToken.bad()) {; 7831 // How could that happen for a stringstream?; 7832 Warning(""ReadStream"",; 7833 ""Buffer error while reading data for branch %s on line %lld"",; 7834 branch->GetName(), nlines);; 7835 } else if (!sToken.eof()) {; 7836 if (sToken.fail()) {; 7837 Warning(""ReadStream"",; 7838 ""Couldn't read formatted data in \""%s\"" for branch %s on line %lld; ignoring line"",; 7839 tok.Data(), branch->GetName(), nlines);; 7840 goodLine = false;; 7841 } else {; 7842 std::string rema",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:343901,Usability,learn,learning,343901,"ge(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry range"");; 8857 return -1;; 8858 }; 8859 tc->SetEntryRange(first,last);; 8860 return 0;; 8861}; 8862 ; 8863////////////////////////////////////////////////////////////////////////////////; 8864/// Interface to TTreeCache to set the number of entries for the learning phase; 8865 ; 8866void TTree::SetCacheLearnEntries(Int_t n); 8867{; 8868 TTreeCache::SetLearnEntries(n);; 8869}; 8870 ; 8871////////////////////////////////////////////////////////////////////////////////; 8872/// Enable/Disable circularity for this tree.; 8873///; 8874/// if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; 8875/// per branch in memory.; 8876/// Note that when this function is called (maxEntries>0) the Tree; 8877/// must be empty or having only one basket per branch.; 8878/// if maxEntries <= 0 the tree circularity is disabled.; 8879///; 8880/// #### NOTE 1:; 8881/// Circular Trees are interesting in online real time environments; 8882/// to store the results of the last maxEntries events.; 8883/// #### NOTE 2:; 8884/// Calling SetCircular with maxEntries <= 0 is necessary before; 8885/// merging circular Trees that have been saved on files.; 8886/// #### NOTE 3:; 8887/// SetCircular with maxEntries <= 0 is automatically called; 8888",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:364499,Usability,learn,learning,364499,"f->IsA() == TLeafD::Class()) {; 9433 ltype = 5;; 9434 }; 9435 if (leaf->IsA() == TLeafC::Class()) {; 9436 len = 1;; 9437 ltype = 5;; 9438 };; 9439 printf("" %-15s = "", leaf->GetName());; 9440 for (Int_t l = 0; l < len; l++) {; 9441 leaf->PrintValue(l);; 9442 if (l == (len - 1)) {; 9443 printf(""\n"");; 9444 continue;; 9445 }; 9446 printf("", "");; 9447 if ((l % ltype) == 0) {; 9448 printf(""\n "");; 9449 }; 9450 }; 9451 }; 9452}; 9453 ; 9454////////////////////////////////////////////////////////////////////////////////; 9455/// Start the TTreeViewer on this tree.; 9456///; 9457/// - ww is the width of the canvas in pixels; 9458/// - wh is the height of the canvas in pixels; 9459 ; 9460void TTree::StartViewer(); 9461{; 9462 GetPlayer();; 9463 if (fPlayer) {; 9464 fPlayer->StartViewer(600, 400);; 9465 }; 9466}; 9467 ; 9468////////////////////////////////////////////////////////////////////////////////; 9469/// Stop the cache learning phase; 9470///; 9471/// Returns:; 9472/// - 0 learning phase stopped or not active; 9473/// - -1 on error; 9474 ; 9475Int_t TTree::StopCacheLearningPhase(); 9476{; 9477 if (!GetTree()) {; 9478 if (LoadTree(0)<0) {; 9479 Error(""StopCacheLearningPhase"",""Could not load a tree"");; 9480 return -1;; 9481 }; 9482 }; 9483 if (GetTree()) {; 9484 if (GetTree() != this) {; 9485 return GetTree()->StopCacheLearningPhase();; 9486 }; 9487 } else {; 9488 Error(""StopCacheLearningPhase"", ""No tree is available. Could not stop cache learning phase"");; 9489 return -1;; 9490 }; 9491 ; 9492 TFile *f = GetCurrentFile();; 9493 if (!f) {; 9494 Error(""StopCacheLearningPhase"", ""No file is available. Could not stop cache learning phase"");; 9495 return -1;; 9496 }; 9497 TTreeCache *tc = GetReadCache(f,true);; 9498 if (!tc) {; 9499 Error(""StopCacheLearningPhase"", ""No cache is available. Could not stop learning phase"");; 9500 return -1;; 9501 }; 9502 tc->StopLearningPhase();; 9503 return 0;; 9504}; 9505 ; 9506///////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:364554,Usability,learn,learning,364554,"f->IsA() == TLeafD::Class()) {; 9433 ltype = 5;; 9434 }; 9435 if (leaf->IsA() == TLeafC::Class()) {; 9436 len = 1;; 9437 ltype = 5;; 9438 };; 9439 printf("" %-15s = "", leaf->GetName());; 9440 for (Int_t l = 0; l < len; l++) {; 9441 leaf->PrintValue(l);; 9442 if (l == (len - 1)) {; 9443 printf(""\n"");; 9444 continue;; 9445 }; 9446 printf("", "");; 9447 if ((l % ltype) == 0) {; 9448 printf(""\n "");; 9449 }; 9450 }; 9451 }; 9452}; 9453 ; 9454////////////////////////////////////////////////////////////////////////////////; 9455/// Start the TTreeViewer on this tree.; 9456///; 9457/// - ww is the width of the canvas in pixels; 9458/// - wh is the height of the canvas in pixels; 9459 ; 9460void TTree::StartViewer(); 9461{; 9462 GetPlayer();; 9463 if (fPlayer) {; 9464 fPlayer->StartViewer(600, 400);; 9465 }; 9466}; 9467 ; 9468////////////////////////////////////////////////////////////////////////////////; 9469/// Stop the cache learning phase; 9470///; 9471/// Returns:; 9472/// - 0 learning phase stopped or not active; 9473/// - -1 on error; 9474 ; 9475Int_t TTree::StopCacheLearningPhase(); 9476{; 9477 if (!GetTree()) {; 9478 if (LoadTree(0)<0) {; 9479 Error(""StopCacheLearningPhase"",""Could not load a tree"");; 9480 return -1;; 9481 }; 9482 }; 9483 if (GetTree()) {; 9484 if (GetTree() != this) {; 9485 return GetTree()->StopCacheLearningPhase();; 9486 }; 9487 } else {; 9488 Error(""StopCacheLearningPhase"", ""No tree is available. Could not stop cache learning phase"");; 9489 return -1;; 9490 }; 9491 ; 9492 TFile *f = GetCurrentFile();; 9493 if (!f) {; 9494 Error(""StopCacheLearningPhase"", ""No file is available. Could not stop cache learning phase"");; 9495 return -1;; 9496 }; 9497 TTreeCache *tc = GetReadCache(f,true);; 9498 if (!tc) {; 9499 Error(""StopCacheLearningPhase"", ""No cache is available. Could not stop learning phase"");; 9500 return -1;; 9501 }; 9502 tc->StopLearningPhase();; 9503 return 0;; 9504}; 9505 ; 9506///////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:365027,Usability,learn,learning,365027,"Start the TTreeViewer on this tree.; 9456///; 9457/// - ww is the width of the canvas in pixels; 9458/// - wh is the height of the canvas in pixels; 9459 ; 9460void TTree::StartViewer(); 9461{; 9462 GetPlayer();; 9463 if (fPlayer) {; 9464 fPlayer->StartViewer(600, 400);; 9465 }; 9466}; 9467 ; 9468////////////////////////////////////////////////////////////////////////////////; 9469/// Stop the cache learning phase; 9470///; 9471/// Returns:; 9472/// - 0 learning phase stopped or not active; 9473/// - -1 on error; 9474 ; 9475Int_t TTree::StopCacheLearningPhase(); 9476{; 9477 if (!GetTree()) {; 9478 if (LoadTree(0)<0) {; 9479 Error(""StopCacheLearningPhase"",""Could not load a tree"");; 9480 return -1;; 9481 }; 9482 }; 9483 if (GetTree()) {; 9484 if (GetTree() != this) {; 9485 return GetTree()->StopCacheLearningPhase();; 9486 }; 9487 } else {; 9488 Error(""StopCacheLearningPhase"", ""No tree is available. Could not stop cache learning phase"");; 9489 return -1;; 9490 }; 9491 ; 9492 TFile *f = GetCurrentFile();; 9493 if (!f) {; 9494 Error(""StopCacheLearningPhase"", ""No file is available. Could not stop cache learning phase"");; 9495 return -1;; 9496 }; 9497 TTreeCache *tc = GetReadCache(f,true);; 9498 if (!tc) {; 9499 Error(""StopCacheLearningPhase"", ""No cache is available. Could not stop learning phase"");; 9500 return -1;; 9501 }; 9502 tc->StopLearningPhase();; 9503 return 0;; 9504}; 9505 ; 9506////////////////////////////////////////////////////////////////////////////////; 9507/// Set the fTree member for all branches and sub branches.; 9508 ; 9509static void TBranch__SetTree(TTree *tree, TObjArray &branches); 9510{; 9511 Int_t nb = branches.GetEntriesFast();; 9512 for (Int_t i = 0; i < nb; ++i) {; 9513 TBranch* br = (TBranch*) branches.UncheckedAt(i);; 9514 br->SetTree(tree);; 9515 ; 9516 Int_t writeBasket = br->GetWriteBasket();; 9517 for (Int_t j = writeBasket; j >= 0; --j) {; 9518 TBasket *bk = (TBasket*)br->GetListOfBaskets()->UncheckedAt(j);; 9519 if (bk) {; 9520 tree->In",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:365210,Usability,learn,learning,365210," 9461{; 9462 GetPlayer();; 9463 if (fPlayer) {; 9464 fPlayer->StartViewer(600, 400);; 9465 }; 9466}; 9467 ; 9468////////////////////////////////////////////////////////////////////////////////; 9469/// Stop the cache learning phase; 9470///; 9471/// Returns:; 9472/// - 0 learning phase stopped or not active; 9473/// - -1 on error; 9474 ; 9475Int_t TTree::StopCacheLearningPhase(); 9476{; 9477 if (!GetTree()) {; 9478 if (LoadTree(0)<0) {; 9479 Error(""StopCacheLearningPhase"",""Could not load a tree"");; 9480 return -1;; 9481 }; 9482 }; 9483 if (GetTree()) {; 9484 if (GetTree() != this) {; 9485 return GetTree()->StopCacheLearningPhase();; 9486 }; 9487 } else {; 9488 Error(""StopCacheLearningPhase"", ""No tree is available. Could not stop cache learning phase"");; 9489 return -1;; 9490 }; 9491 ; 9492 TFile *f = GetCurrentFile();; 9493 if (!f) {; 9494 Error(""StopCacheLearningPhase"", ""No file is available. Could not stop cache learning phase"");; 9495 return -1;; 9496 }; 9497 TTreeCache *tc = GetReadCache(f,true);; 9498 if (!tc) {; 9499 Error(""StopCacheLearningPhase"", ""No cache is available. Could not stop learning phase"");; 9500 return -1;; 9501 }; 9502 tc->StopLearningPhase();; 9503 return 0;; 9504}; 9505 ; 9506////////////////////////////////////////////////////////////////////////////////; 9507/// Set the fTree member for all branches and sub branches.; 9508 ; 9509static void TBranch__SetTree(TTree *tree, TObjArray &branches); 9510{; 9511 Int_t nb = branches.GetEntriesFast();; 9512 for (Int_t i = 0; i < nb; ++i) {; 9513 TBranch* br = (TBranch*) branches.UncheckedAt(i);; 9514 br->SetTree(tree);; 9515 ; 9516 Int_t writeBasket = br->GetWriteBasket();; 9517 for (Int_t j = writeBasket; j >= 0; --j) {; 9518 TBasket *bk = (TBasket*)br->GetListOfBaskets()->UncheckedAt(j);; 9519 if (bk) {; 9520 tree->IncrementTotalBuffers(bk->GetBufferSize());; 9521 }; 9522 }; 9523 ; 9524 TBranch__SetTree(tree,*br->GetListOfBranches());; 9525 }; 9526}; 9527 ; 9528//////////////////////////////////////",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:365392,Usability,learn,learning,365392,"se; 9470///; 9471/// Returns:; 9472/// - 0 learning phase stopped or not active; 9473/// - -1 on error; 9474 ; 9475Int_t TTree::StopCacheLearningPhase(); 9476{; 9477 if (!GetTree()) {; 9478 if (LoadTree(0)<0) {; 9479 Error(""StopCacheLearningPhase"",""Could not load a tree"");; 9480 return -1;; 9481 }; 9482 }; 9483 if (GetTree()) {; 9484 if (GetTree() != this) {; 9485 return GetTree()->StopCacheLearningPhase();; 9486 }; 9487 } else {; 9488 Error(""StopCacheLearningPhase"", ""No tree is available. Could not stop cache learning phase"");; 9489 return -1;; 9490 }; 9491 ; 9492 TFile *f = GetCurrentFile();; 9493 if (!f) {; 9494 Error(""StopCacheLearningPhase"", ""No file is available. Could not stop cache learning phase"");; 9495 return -1;; 9496 }; 9497 TTreeCache *tc = GetReadCache(f,true);; 9498 if (!tc) {; 9499 Error(""StopCacheLearningPhase"", ""No cache is available. Could not stop learning phase"");; 9500 return -1;; 9501 }; 9502 tc->StopLearningPhase();; 9503 return 0;; 9504}; 9505 ; 9506////////////////////////////////////////////////////////////////////////////////; 9507/// Set the fTree member for all branches and sub branches.; 9508 ; 9509static void TBranch__SetTree(TTree *tree, TObjArray &branches); 9510{; 9511 Int_t nb = branches.GetEntriesFast();; 9512 for (Int_t i = 0; i < nb; ++i) {; 9513 TBranch* br = (TBranch*) branches.UncheckedAt(i);; 9514 br->SetTree(tree);; 9515 ; 9516 Int_t writeBasket = br->GetWriteBasket();; 9517 for (Int_t j = writeBasket; j >= 0; --j) {; 9518 TBasket *bk = (TBasket*)br->GetListOfBaskets()->UncheckedAt(j);; 9519 if (bk) {; 9520 tree->IncrementTotalBuffers(bk->GetBufferSize());; 9521 }; 9522 }; 9523 ; 9524 TBranch__SetTree(tree,*br->GetListOfBranches());; 9525 }; 9526}; 9527 ; 9528////////////////////////////////////////////////////////////////////////////////; 9529/// Set the fTree member for all friend elements.; 9530 ; 9531void TFriendElement__SetTree(TTree *tree, TList *frlist); 9532{; 9533 if (frlist) {; 9534 TObjLink *lnk = frlist->First",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:388468,Usability,simpl,simple,388468,"st TString &source) constReturn True if we have any rule whose source class is 'source'.Definition TSchemaRuleSet.cxx:199; ROOT::Internal::TBranchIMTHelperA helper class for managing IMT work during TTree:Fill operations.Definition TBranchIMTHelper.h:28; ROOT::Internal::TBranchIMTHelper::Waitvoid Wait()Definition TBranchIMTHelper.h:51; ROOT::Internal::TBranchIMTHelper::GetNerrorsLong64_t GetNerrors()Definition TBranchIMTHelper.h:58; ROOT::Internal::TBranchIMTHelper::GetNbytesLong64_t GetNbytes()Definition TBranchIMTHelper.h:57; ROOT::Internal::TParBranchProcessingRAIIDefinition TROOT.h:75; ROOT::TIOFeaturesTIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TT...Definition TIOFeatures.hxx:69; ROOT::TIOFeatures::GetFeaturesUChar_t GetFeatures() constDefinition TIOFeatures.cxx:250; ROOT::TIOFeatures::Setbool Set(EIOFeatures bits)Set a specific IO feature.Definition TIOFeatures.cxx:139; ROOT::TThreadExecutorThis class provides a simple interface to execute the same task multiple times in parallel threads,...Definition TThreadExecutor.hxx:41; ROOT::TThreadExecutor::Foreachvoid Foreach(F func, unsigned nTimes, unsigned nChunks=0)Execute a function without arguments several times in parallel, dividing the execution in nChunks.Definition TThreadExecutor.hxx:146; TArrayD::Streamervoid Streamer(TBuffer &) overrideStream a TArrayD object.Definition TArrayD.cxx:149; TArrayD::Setvoid Set(Int_t n) overrideSet size of this array to n doubles.Definition TArrayD.cxx:106; TArrayI::Setvoid Set(Int_t n) overrideSet size of this array to n ints.Definition TArrayI.cxx:105; TArrayI::Streamervoid Streamer(TBuffer &) overrideStream a TArrayI object.Definition TArrayI.cxx:148; TArray::fNInt_t fNDefinition TArray.h:38; TAttFillFill Area Attributes class.Definition TAttFill.h:19; TAttFill::Streamervirtual void Streamer(TBuffer &); TAttFill::GetFillColorvirtual Color_t GetFillColor() constReturn the fill area color.Definition TAttFill.h:30; TAttFi",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:393778,Usability,clear,cleared,393778,"TBranchElement::SetTargetClassvirtual void SetTargetClass(const char *name)Set the name of the class of the in-memory object into which the data will loaded.Definition TBranchElement.cxx:5855; TBranchElement::GetCheckSumUInt_t GetCheckSum()Definition TBranchElement.h:185; TBranchElement::SetObjectvoid SetObject(void *objadd) overrideSet object this branch is pointing to.Definition TBranchElement.cxx:5575; TBranchObjectA Branch for the case of an object.Definition TBranchObject.h:26; TBranchRefA branch containing and managing a TRefTable for TRef autoloading.Definition TBranchRef.h:34; TBranchRef::Resetvoid Reset(Option_t *option="""") overrideDefinition TBranchRef.cxx:187; TBranchRef::Printvoid Print(Option_t *option="""") const overridePrint the TRefTable branch.Definition TBranchRef.cxx:159; TBranchRef::Clearvoid Clear(Option_t *option="""") overrideClear entries in the TRefTable.Definition TBranchRef.cxx:95; TBranchRef::ResetAfterMergevoid ResetAfterMerge(TFileMergeInfo *) overrideReset a Branch after a Merge operation (drop data but keep customizations) TRefTable is cleared.Definition TBranchRef.cxx:198; TBranchSTLA Branch handling STL collection of pointers (vectors, lists, queues, sets and multisets) while stori...Definition TBranchSTL.h:22; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBranch::GetLeafvirtual TLeaf * GetLeaf(const char *name) constReturn pointer to the 1st Leaf named name in thisBranch.Definition TBranch.cxx:2055; TBranch::GetMakeClassvirtual bool GetMakeClass() constReturn whether this branch is in a mode where the object are decomposed or not (Also known as MakeCla...Definition TBranch.cxx:2117; TBranch::SetupAddressesvirtual void SetupAddresses()If the branch address is not set, we set all addresses starting with the top level parent branch.Definition TBranch.cxx:3294; TBranch::ResetAddressvirtual void ResetAddress()Reset the address of the branch.Definition TBranch.cxx:2651; TBranch::GetBasketSeekvirtual Long64_t GetBasketSeek(",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:429554,Usability,learn,learning,429554,"::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TTreeCacheUnzipA TTreeCache which exploits parallelized decompression of its own content.Definition TTreeCacheUnzip.h:35; TTreeCacheUnzip::IsParallelUnzipstatic bool IsParallelUnzip()Static function that tells wether the multithreading unzipping is activated.Definition TTreeCacheUnzip.cxx:416; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::IsAutoCreatedbool IsAutoCreated() constDefinition TTreeCache.h:150; TTreeCache::SetBufferSizeInt_t SetBufferSize(Long64_t buffersize) overrideChange the underlying buffer size of the cache.Definition TTreeCache.cxx:2073; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2145; TTreeCache::GetTreeTTree * GetTree() constDefinition TTreeCache.h:149; TTreeCache::SetEntryRangevirtual void SetEntryRange(Long64_t emin, Long64_t emax)Set the minimum and maximum entry number to be processed this information helps to optimize the numbe...Definition TTreeCache.cxx:2106; TTreeCache::DropBranchvirtual Int_t DropBranch(TBranch *b, bool subbranches=false)Remove a branch to the list of branches to be stored in the cache this function is called by TBranch:...Definition TTreeCache.cxx:541; TTreeCache::SetAutoCreatedvoid SetAutoCreated(bool val)Definition TTreeCache.h:164; TTreeCache::StopLearningPhasevirtual void StopLearningPhase()This is the counterpart of StartLearningPhase() and can be used to stop the learning phase.Definition TTreeCache.cxx:2187; TTreeCache::Printvoid Print(Option_t *option="""") const overridePrint cache statistics.Definition TTreeCa",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:430357,Usability,learn,learning,430357,"ufferSizeInt_t SetBufferSize(Long64_t buffersize) overrideChange the underlying buffer size of the cache.Definition TTreeCache.cxx:2073; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2145; TTreeCache::GetTreeTTree * GetTree() constDefinition TTreeCache.h:149; TTreeCache::SetEntryRangevirtual void SetEntryRange(Long64_t emin, Long64_t emax)Set the minimum and maximum entry number to be processed this information helps to optimize the numbe...Definition TTreeCache.cxx:2106; TTreeCache::DropBranchvirtual Int_t DropBranch(TBranch *b, bool subbranches=false)Remove a branch to the list of branches to be stored in the cache this function is called by TBranch:...Definition TTreeCache.cxx:541; TTreeCache::SetAutoCreatedvoid SetAutoCreated(bool val)Definition TTreeCache.h:164; TTreeCache::StopLearningPhasevirtual void StopLearningPhase()This is the counterpart of StartLearningPhase() and can be used to stop the learning phase.Definition TTreeCache.cxx:2187; TTreeCache::Printvoid Print(Option_t *option="""") const overridePrint cache statistics.Definition TTreeCache.cxx:1899; TTreeCache::AddBranchInt_t AddBranch(TBranch *b, bool subgbranches=false) overrideAdd a branch to the list of branches to be stored in the cache this function is called by the user vi...Definition TTreeCache.cxx:376; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeCloner::kNoWarnings@ kNoWarningsDefinition TTreeCloner.h:100; TTreeCloner::GetWarningconst char * GetWarning() constDefinition TTreeCloner.h:117; TTreeCloner::Execbool Exec()Execute the cloning.Definition TTreeCloner.cxx:222; TTreeCloner::NeedConversionbool NeedConversion()Definition TTreeCloner.h:121; TTreeCloner::IsValidbool IsValid()Definition TTreeCloner.h:120; TTreeCloner::SetCacheSizevoid SetCacheSize(Long64_t size)Set the cache size us",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:437074,Usability,learn,learning,437074,"lvirtual TLeaf * GetLeafImpl(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6098; TTree::fTotBytesLong64_t fTotBytesTotal number of bytes in all branches before compression.Definition TTree.h:86; TTree::FlushBasketsvirtual Int_t FlushBaskets(bool create_cluster=true) constWrite to disk all the basket that have not yet been individually written and create an event cluster ...Definition TTree.cxx:5129; TTree::fMaxClusterRangeInt_t fMaxClusterRange! Memory allocated for the cluster range.Definition TTree.h:96; TTree::Showvirtual void Show(Long64_t entry=-1, Int_t lenmax=20)Print values of all active leaves for entry.Definition TTree.cxx:9385; TTree::fEventListTEventList * fEventList! Pointer to event selection list (if one)Definition TTree.h:125; TTree::GetAutoSavevirtual Long64_t GetAutoSave() constDefinition TTree.h:448; TTree::StopCacheLearningPhasevirtual Int_t StopCacheLearningPhase()Stop the cache learning phase.Definition TTree.cxx:9474; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::fSortedBranchesstd::vector< std::pair< Long64_t, TBranch * > > fSortedBranches! Branches to be processed in parallel when IMT is on, sorted by average task timeDefinition TTree.h:144; TTree::SetCircularvirtual void SetCircular(Long64_t maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTree::fSavedBytesLong64_t fSavedBytesNumber of autosaved bytes.Definition TTree.h:88; TTree::AddBranchToCachevirtual Int_t AddBranchToCache(const char *bname, bool subbranches=false)Add branch with name bname to the Tree cache.Definition TTree.cxx:1059; TTree::GetMedianClusterSizeLong64_t GetMedianClusterSize()Estimate the median cluster size for the TTree.Definition TTree.cxx:8297; TTree::GetClusterIteratorvirtual TClusterIterator G",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:441649,Usability,simpl,simply,441649,"ter range.Definition TTree.h:103; TTree::Streamervoid Streamer(TBuffer &) overrideStream a class object.Definition TTree.cxx:9545; TTree::fIMTZipBytesstd::atomic< Long64_t > fIMTZipBytes! Zip bytes for the IMT flush baskets.Definition TTree.h:161; TTree::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideMake sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree.Definition TTree.cxx:7881; TTree::GetPlayerTVirtualTreePlayer * GetPlayer()Load the TTreePlayer (if not already done).Definition TTree.cxx:6305; TTree::MakeProxyvirtual Int_t MakeProxy(const char *classname, const char *macrofilename=nullptr, const char *cutfilename=nullptr, const char *option=nullptr, Int_t maxUnrolling=3)Generate a skeleton analysis class for this Tree using TBranchProxy.Definition TTree.cxx:6768; TTree::kSplitCollectionOfPointers@ kSplitCollectionOfPointersDefinition TTree.h:266; TTree::ReadStreamvirtual Long64_t ReadStream(std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ')Create or simply read branches from an input stream.Definition TTree.cxx:7615; TTree::SetDebugvirtual void SetDebug(Int_t level=1, Long64_t min=0, Long64_t max=9999999)Set the debug level and the debug range.Definition TTree.cxx:8928; TTree::fScanFieldInt_t fScanFieldNumber of runs before prompting in Scan.Definition TTree.h:92; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; TTree::GetFriendvirtual TTree * GetFriend(const char *) constReturn a pointer to the TTree friend whose name or alias is friendname.Definition TTree.cxx:5975; TTree::SetNotifyvirtual void SetNotify(TObject *obj)Sets the address of the object to be notified when the tree is loaded.Definition TTree.cxx:9231; TTree::GetMaximumvirtual Double_t GetMaximum(const char *columname)Return maximum of column with name columname.Definition TTree.cxx:6235; TTree::GetEntryNumberWithBestIndexvirtual Long64_t GetEntryNumberWithBestIndex(",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:446367,Usability,learn,learning,446367,"ouble_t w=1, Option_t *option="""")Set tree weight.Definition TTree.cxx:9374; TTree::InitializeBranchListsvoid InitializeBranchLists(bool checkLeafCount)Divides the top-level branches into two vectors: (i) branches to be processed sequentially and (ii) b...Definition TTree.cxx:5781; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::fClusterSizeLong64_t * fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.Definition TTree.h:104; TTree::fFlushedBytesLong64_t fFlushedBytesNumber of auto-flushed bytes.Definition TTree.h:89; TTree::SetPerfStatsvirtual void SetPerfStats(TVirtualPerfStats *perf)Set perf stats.Definition TTree.cxx:9329; TTree::fIMTTotBytesstd::atomic< Long64_t > fIMTTotBytes! Total bytes for the IMT flush basketsDefinition TTree.h:160; TTree::SetCacheLearnEntriesvirtual void SetCacheLearnEntries(Int_t n=10)Interface to TTreeCache to set the number of entries for the learning phase.Definition TTree.cxx:8865; TTree::fEntryListTEntryList * fEntryList! Pointer to event selection list (if one)Definition TTree.h:126; TTree::GetTreeIndexvirtual TVirtualIndex * GetTreeIndex() constDefinition TTree.h:558; TTree::fExternalFriendsTList * fExternalFriends! List of TFriendsElement pointing to us and need to be notified of LoadTree. Content not owned.Definition TTree.h:131; TTree::Mergevirtual Long64_t Merge(TCollection *list, Option_t *option="""")Merge the trees in the TList into this tree.Definition TTree.cxx:6890; TTree::SetMaxVirtualSizevirtual void SetMaxVirtualSize(Long64_t size=0)Definition TTree.h:665; TTree::DropBasketsvirtual void DropBaskets()Remove some baskets from memory.Definition TTree.cxx:4518; TTree::SetAutoSavevirtual void SetAutoSave(Long64_t autos=-300000000)In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSa...Definition TTree.cxx",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:454548,Usability,simpl,simply,454548,"below MaxVirtualsize.Definition TTree.cxx:6837; TTree::GetReadEntryvirtual Long64_t GetReadEntry() constDefinition TTree.h:549; TTree::GetListOfBranchesvirtual TObjArray * GetListOfBranches()Definition TTree.h:528; TTree::fZipBytesLong64_t fZipBytesTotal number of bytes in all branches after compression.Definition TTree.h:87; TTree::GetTreevirtual TTree * GetTree() constDefinition TTree.h:557; TTree::fTransientBufferTBuffer * fTransientBuffer! Pointer to the current transient buffer.Definition TTree.h:138; TTree::SetEntryListvirtual void SetEntryList(TEntryList *list, Option_t *opt="""")Set an EntryList.Definition TTree.cxx:9046; TTree::Notifybool Notify() overrideFunction called when loading a new class library.Definition TTree.cxx:7033; TTree::AddZipBytesvirtual void AddZipBytes(Int_t zip)Definition TTree.h:332; TTree::LoadTreevirtual Long64_t LoadTree(Long64_t entry)Set current entry.Definition TTree.cxx:6473; TTree::ReadFilevirtual Long64_t ReadFile(const char *filename, const char *branchDescriptor="""", char delimiter=' ')Create or simply read branches from filename.Definition TTree.cxx:7564; TTree::GetAliasvirtual const char * GetAlias(const char *aliasName) constReturns the expanded value of the alias. Search in the friends if any.Definition TTree.cxx:5226; TTree::SetIOFeaturesROOT::TIOFeatures SetIOFeatures(const ROOT::TIOFeatures &)Provide the end-user with the ability to enable/disable various experimental IO features for this TTr...Definition TTree.cxx:9130; TTree::CreateBasketvirtual TBasket * CreateBasket(TBranch *)Create a basket for this tree and given branch.Definition TTree.cxx:3731; TTree::fUserInfoTList * fUserInfopointer to a list of user objects associated to this TreeDefinition TTree.h:133; TTree::GetMinimumvirtual Double_t GetMinimum(const char *columname)Return minimum of column with name columname.Definition TTree.cxx:6275; TTree::RemoveFriendvirtual void RemoveFriend(TTree *)Remove a friend from the list of friends.Definition TTree.cxx:7977; T",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8cxx_source.html:461309,Usability,undo,undo,461309,"st char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Make a projection of a tree using selections.Definition TTree.cxx:7498; TTree::SetCacheEntryRangevirtual Int_t SetCacheEntryRange(Long64_t first, Long64_t last)interface to TTreeCache to set the cache entry rangeDefinition TTree.cxx:8831; TTree::GetMaxTreeSizestatic Long64_t GetMaxTreeSize()Static function which returns the tree file size limit in bytes.Definition TTree.cxx:6265; TTree::fCacheDoClusterPrefetchbool fCacheDoClusterPrefetch! true if cache is prefetching whole clustersDefinition TTree.h:140; TTree::SetBranchAddressImpInt_t SetBranchAddressImp(TBranch *branch, void *addr, TBranch **ptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8445; TTree::SetAliasvirtual bool SetAlias(const char *aliasName, const char *aliasFormula)Set a tree variable alias.Definition TTree.cxx:8141; TTree::CopyAddressesvirtual void CopyAddresses(TTree *, bool undo=false)Set branch addresses of passed tree equal to ours.Definition TTree.cxx:3299; TTree::fMaxEntriesLong64_t fMaxEntriesMaximum number of entries in case of circular buffers.Definition TTree.h:97; TTree::DropBuffersvirtual void DropBuffers(Int_t nbytes)Drop branch buffers to accommodate nbytes below MaxVirtualsize.Definition TTree.cxx:4531; TTree::GetListOfFriendsvirtual TList * GetListOfFriends() constDefinition TTree.h:530; TTree::Refreshvirtual void Refresh()Refresh contents of this tree and its branches from the current status on disk.Definition TTree.cxx:7916; TTree::SetAutoFlushvirtual void SetAutoFlush(Long64_t autof=-30000000)This function may be called at the start of a program to change the default value for fAutoFlush.Definition TTree.cxx:8196; TTree::fgMaxTreeSizestatic Long64_t fgMaxTreeSizeMaximum size of a file containing a Tree.Definition TTree.h:155; TTree::fReadEntryLong64_t fReadEntry! Number of the entry being processedDefinition TTree.h:107; TTree::fInde",MatchSource.WIKI,doc/master/TTree_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html
https://root.cern/doc/master/TTree_8h.html:588,Integrability,depend,dependency,588,". ROOT: tree/tree/inc/TTree.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TTree.h File Reference. #include ""Compression.h""; #include ""ROOT/TIOFeatures.hxx""; #include ""TArrayD.h""; #include ""TArrayI.h""; #include ""TAttFill.h""; #include ""TAttLine.h""; #include ""TAttMarker.h""; #include ""TClass.h""; #include ""TDataType.h""; #include ""TDirectory.h""; #include ""TObjArray.h""; #include ""TVirtualTreePlayer.h""; #include ""TBranch.h""; #include ""TList.h""; #include <array>; #include <atomic>; #include <vector>; #include <utility>. Include dependency graph for TTree.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TTree::TClusterIterator;  Helper class to iterate over cluster of baskets. More...;  ; class  TTree::TFriendLock;  Helper class to prevent infinite recursion in the usage of TTree Friends. More...;  ; class  TTree;  A TTree represents a columnar dataset. More...;  ; class  TTreeFriendLeafIter;  Iterator on all the leaves in a TTree and its friend. More...;  . treetreeincTTree.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TTree_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h.html
https://root.cern/doc/master/TTree_8h_source.html:48487,Availability,error,error,48487,"le is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFriendElementA TFriendElement TF describes a TTree object TF in a file.Definition TFriendElement.h:33; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TIteratorIterator abstract base class.Definition TIterator.h:30; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TListA doubly linked list.Definition TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPolyMarkerA PolyMarker is defined by an array on N points in a 2-D space.Definition TPolyMarker.h:31; TPrincipalPrincipal Components Analysis (PCA)Definition TPrincipal.h:21; TSQLResultDefinition TSQLResult.h:31; TSelectorA TSelector object is used by the TTree::Draw, TTree::Scan, TTree::Process to navigate in a TTree and...Definition TSelector.h:31; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeFormulaUsed to pass a selection expression to the Tree drawing routine.Definition TTreeFormula.h:58; TTreeFriendLeafIterIterator on all the leaves in a TTree and its friend.Definition TTree.h:716; TTreeFriendLeafIter::operator!=bool operator!=(const TIterator &) const overrideCompare two iterator objects.Definition TTree.h",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:67847,Availability,recover,recover,67847,"nst char *bname, T *add, TBranch **ptr=nullptr)Definition TTree.h:637; TTree::SetTargetMemoryRatiovoid SetTargetMemoryRatio(Float_t ratio)Definition TTree.h:692; TTree::fEntryListTEntryList * fEntryList! Pointer to event selection list (if one)Definition TTree.h:126; TTree::GetTreeIndexvirtual TVirtualIndex * GetTreeIndex() constDefinition TTree.h:558; TTree::DebugInt_t Debug() constDefinition TTree.h:429; TTree::fExternalFriendsTList * fExternalFriends! List of TFriendsElement pointing to us and need to be notified of LoadTree. Content not owned.Definition TTree.h:131; TTree::Mergevirtual Long64_t Merge(TCollection *list, Option_t *option="""")Merge the trees in the TList into this tree.Definition TTree.cxx:6890; TTree::SetMaxVirtualSizevirtual void SetMaxVirtualSize(Long64_t size=0)Definition TTree.h:665; TTree::DropBasketsvirtual void DropBaskets()Remove some baskets from memory.Definition TTree.cxx:4518; TTree::SetAutoSavevirtual void SetAutoSave(Long64_t autos=-300000000)In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSa...Definition TTree.cxx:8342; TTree::GetClusterPrefetchvirtual bool GetClusterPrefetch() constDefinition TTree.h:457; TTree::BranchTBranch * Branch(const char *name, const char *classname, T **addobj, Int_t bufsize=32000, Int_t splitlevel=99)Definition TTree.h:400; TTree::fMaxEntryLoopLong64_t fMaxEntryLoopMaximum number of entries to process.Definition TTree.h:98; TTree::TTreeBranchImpReffriend TBranch * TTreeBranchImpRef(TTree *tree, const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel); TTree::GetTargetMemoryRatioFloat_t GetTargetMemoryRatio() constDefinition TTree.h:560; TTree::SetParallelUnzipvirtual void SetParallelUnzip(bool opt=true, Float_t RelSize=-1)Enable or disable parallel unzipping of Tree buffers.Definition TTree.cxx:9291; TTree::SetDirectoryvirtual void SetDirectory(TDirectory *dir)Change the tree's directory.Definition TTree.c",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:10822,Deployability,update,update,10822,"tNewlineValue(std::istream &inputStream);; 184 void ImportClusterRanges(TTree *fromtree);; 185 void MoveReadCache(TFile *src, TDirectory *dir);; 186 Int_t SetCacheSizeAux(bool autocache = true, Long64_t cacheSize = 0);; 187 ; 188 class TFriendLock {; 189 // Helper class to prevent infinite recursion in the; 190 // usage of TTree Friends. Implemented in TTree.cxx.; 191 TTree *fTree; // Pointer to the locked tree; 192 UInt_t fMethodBit; // BIT for the locked method; 193 bool fPrevious; // Previous value of the BIT.; 194 ; 195 protected:; 196 TFriendLock(const TFriendLock&);; 197 TFriendLock& operator=(const TFriendLock&);; 198 ; 199 public:; 200 TFriendLock(TTree* tree, UInt_t methodbit);; 201 ~TFriendLock();; 202 };; 203 friend class TFriendLock;; 204 // So that the index class can use TFriendLock:; 205 friend class TTreeIndex;; 206 friend class TChainIndex;; 207 // So that the TTreeCloner can access the protected interfaces; 208 friend class TTreeCloner;; 209 ; 210 // use to update fFriendLockStatus; 211 enum ELockStatusBits {; 212 kFindBranch = BIT(0),; 213 kFindLeaf = BIT(1),; 214 kGetAlias = BIT(2),; 215 kGetBranch = BIT(3),; 216 kGetEntry = BIT(4),; 217 kGetEntryWithIndex = BIT(5),; 218 kGetFriend = BIT(6),; 219 kGetFriendAlias = BIT(7),; 220 kGetLeaf = BIT(8),; 221 kLoadTree = BIT(9),; 222 kPrint = BIT(10),; 223 kRemoveFriend = BIT(11),; 224 kSetBranchStatus = BIT(12); 225 };; 226 ; 227public:; 228 // Used as the max value for any TTree range operation.; 229 static constexpr Long64_t kMaxEntries = TVirtualTreePlayer::kMaxEntries;; 230 ; 231 // SetBranchAddress return values; 232 enum ESetBranchAddressStatus {; 233 kMissingBranch = -5,; 234 kInternalError = -4,; 235 kMissingCompiledCollectionProxy = -3,; 236 kMismatch = -2,; 237 kClassMismatch = -1,; 238 kMatch = 0,; 239 kMatchConversion = 1,; 240 kMatchConversionCollection = 2,; 241 kMakeClass = 3,; 242 kVoidPtr = 4,; 243 kNoCheck = 5,; 244 kNeedEnableDecomposedObj = BIT(29), // DecomposedObj is the newer name ",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:15316,Deployability,update,updates,15316,"o the next cluster and return the starting entry; 294 // of this next cluster; 295 Long64_t Next();; 296 ; 297 // Move on to the previous cluster and return the starting entry; 298 // of this previous cluster; 299 Long64_t Previous();; 300 ; 301 // Return the start entry of the current cluster.; 302 Long64_t GetStartEntry() {; 303 return fStartEntry;; 304 }; 305 ; 306 // Return the first entry of the next cluster.; 307 Long64_t GetNextEntry() {; 308 return fNextEntry;; 309 }; 310 ; 311 Long64_t operator()() { return Next(); }; 312 };; 313 ; 314 TTree();; 315 TTree(const char* name, const char* title, Int_t splitlevel = 99, TDirectory* dir = gDirectory);; 316 ~TTree() override;; 317 ; 318 TTree(const TTree& tt) = delete;; 319 TTree& operator=(const TTree& tt) = delete;; 320 ; 321 virtual Int_t AddBranchToCache(const char *bname, bool subbranches = false);; 322 virtual Int_t AddBranchToCache(TBranch *branch, bool subbranches = false);; 323 virtual Int_t DropBranchFromCache(const char *bname, bool subbranches = false);; 324 virtual Int_t DropBranchFromCache(TBranch *branch, bool subbranches = false);; 325 void AddClone(TTree*);; 326 virtual TFriendElement *AddFriend(const char* treename, const char* filename = """");; 327 virtual TFriendElement *AddFriend(const char* treename, TFile* file);; 328 virtual TFriendElement *AddFriend(TTree* tree, const char* alias = """", bool warn = false);; 329 // As the TBasket invokes Add{Tot,Zip}Bytes on its parent tree, we must do these updates in a thread-safe; 330 // manner only when we are flushing multiple baskets in parallel.; 331 virtual void AddTotBytes(Int_t tot) { if (fIMTFlush) { fIMTTotBytes += tot; } else { fTotBytes += tot; } }; 332 virtual void AddZipBytes(Int_t zip) { if (fIMTFlush) { fIMTZipBytes += zip; } else { fZipBytes += zip; } }; 333// NOTE: these counters aren't thread safe like the ones above.; 334#ifdef R__TRACK_BASKET_ALLOC_TIME; 335 void AddAllocationTime(ULong64_t time) { fAllocationTime += time; }; 336#endif; 3",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:26967,Deployability,update,update,26967,"tEntriesFast(); ievent++) {; 486 /// // Do something with the event in the dataset; 487 /// }; 488 /// \endcode; 489 ///; 490 /// In the example above, independently on whether the dataset is a TTree or; 491 /// a TChain, the GetEntriesFast call will provide the correct stopping; 492 /// condition for the loop (i.e. the total number of entries). In the TChain; 493 /// case, calling GetEntries instead would open all the files in the chain; 494 /// upfront which could be costly.; 495 ///; 496 /// The functionality offered by this method can also be seen when used in; 497 /// conjunction with LoadTree. For a call like <tt> LoadTree(ievent) </tt>,; 498 /// the condition <tt> ievent < dataset.GetEntriesFast() </tt> is only; 499 /// satisfied if \p ievent is strictly smaller than the total number of; 500 /// entries in the dataset. In fact, even when the dataset is a TChain, the; 501 /// first time LoadTree is called with an entry number that belongs to the; 502 /// last file of the chain, this will update the internal data member of the; 503 /// class so that the next call to GetEntriesFast returns the total number; 504 /// of entries in the dataset.; 505 virtual Long64_t GetEntriesFast() const { return fEntries; }; 506 virtual Long64_t GetEntriesFriend() const;; 507 virtual Long64_t GetEstimate() const { return fEstimate; }; 508 virtual Int_t GetEntry(Long64_t entry, Int_t getall = 0);; 509 Int_t GetEvent(Long64_t entry, Int_t getall = 0) { return GetEntry(entry, getall); }; 510 virtual Int_t GetEntryWithIndex(Int_t major, Int_t minor = 0);; 511 virtual Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor = 0) const;; 512 virtual Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor = 0) const;; 513 TEventList *GetEventList() const { return fEventList; }; 514 virtual TEntryList *GetEntryList();; 515 virtual Long64_t GetEntryNumber(Long64_t entry) const;; 516 virtual Int_t GetFileNumber() const { return fFileNumber; }; 517 virtual TTree *GetFrien",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:36900,Deployability,update,updateExisting,36900,"ss T> Int_t SetBranchAddress(const char *bname, T *add, TBranch **ptr = nullptr) {; 638 TClass *cl = TClass::GetClass<T>();; 639 EDataType type = kOther_t;; 640 if (!cl) type = TDataType::GetType(typeid(T));; 641 return SetBranchAddress(bname,add,ptr,cl,type,false);; 642 }; 643#endif; 644 virtual void SetBranchStatus(const char* bname, bool status = true, UInt_t* found = nullptr);; 645 static void SetBranchStyle(Int_t style = 1); //style=0 for old branch, =1 for new branch style; 646 virtual Int_t SetCacheSize(Long64_t cachesize = -1);; 647 virtual Int_t SetCacheEntryRange(Long64_t first, Long64_t last);; 648 virtual void SetCacheLearnEntries(Int_t n=10);; 649 virtual void SetChainOffset(Long64_t offset = 0) { fChainOffset=offset; }; 650 virtual void SetCircular(Long64_t maxEntries);; 651 virtual void SetClusterPrefetch(bool enabled) { fCacheDoClusterPrefetch = enabled; }; 652 virtual void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); // *MENU*; 653 virtual void SetDefaultEntryOffsetLen(Int_t newdefault, bool updateExisting = false);; 654 virtual void SetDirectory(TDirectory* dir);; 655 virtual Long64_t SetEntries(Long64_t n = -1);; 656 virtual void SetEstimate(Long64_t nentries = 1000000);; 657 ROOT::TIOFeatures SetIOFeatures(const ROOT::TIOFeatures &);; 658 virtual void SetFileNumber(Int_t number = 0);; 659 virtual void SetEventList(TEventList* list);; 660 virtual void SetEntryList(TEntryList* list, Option_t *opt="""");; 661 virtual void SetImplicitMT(bool enabled) { fIMTEnabled = enabled; }; 662 virtual void SetMakeClass(Int_t make);; 663 virtual void SetMaxEntryLoop(Long64_t maxev = kMaxEntries) { fMaxEntryLoop = maxev; } // *MENU*; 664 static void SetMaxTreeSize(Long64_t maxsize = 100000000000LL);; 665 virtual void SetMaxVirtualSize(Long64_t size = 0) { fMaxVirtualSize = size; } // *MENU*; 666 void SetName(const char* name) override; // *MENU*; 667 ; 668 /**; 669 * @brief Sets the address of the object to be notified when the tree is loaded.",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:64544,Deployability,update,update,64544,"RangeNumber of Cluster range in addition to the one defined by 'AutoFlush'.Definition TTree.h:95; TTree::PrintCacheStatsvirtual void PrintCacheStats(Option_t *option="""") constPrint statistics about the TreeCache for this tree.Definition TTree.cxx:7370; TTree::BuildIndexvirtual Int_t BuildIndex(const char *majorname, const char *minorname=""0"")Build a Tree Index (default is TTreeIndex).Definition TTree.cxx:2637; TTree::fPlayerTVirtualTreePlayer * fPlayer! Pointer to current Tree playerDefinition TTree.h:134; TTree::GetIteratorOnAllLeavesvirtual TIterator * GetIteratorOnAllLeaves(bool dir=kIterForward)Creates a new iterator that will go through all the leaves on the tree itself and its friend.Definition TTree.cxx:6082; TTree::SetMakeClassvirtual void SetMakeClass(Int_t make)Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode).Definition TTree.cxx:9177; TTree::InPlaceClonevirtual bool InPlaceClone(TDirectory *newdirectory, const char *options="""")Copy the content to a new new file, update this TTree with the new location information and attach th...Definition TTree.cxx:7012; TTree::IncrementTotalBuffersvirtual void IncrementTotalBuffers(Int_t nbytes)Definition TTree.h:586; TTree::fBranchesTObjArray fBranchesList of Branches.Definition TTree.h:122; TTree::GetDirectoryTDirectory * GetDirectory() constDefinition TTree.h:462; TTree::fCacheDoAutoInitbool fCacheDoAutoInit! true if cache auto creation or resize check is neededDefinition TTree.h:139; TTree::GetReadCacheTTreeCache * GetReadCache(TFile *file) constFind and return the TTreeCache registered with the file and which may contain branches for us.Definition TTree.cxx:6318; TTree::fEntriesLong64_t fEntriesNumber of entries.Definition TTree.h:84; TTree::ChangeFilevirtual TFile * ChangeFile(TFile *file)Called by TTree::Fill() when file has reached its maximum fgMaxTreeSize.Definition TTree.cxx:2749; TTree::GetEntryListvirtual TEntryList * GetEntryList()Returns the entry list assi",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:72849,Deployability,update,updateExisting,72849,"ee.cxx:3139; TTree::GetImplicitMTvirtual bool GetImplicitMT()Definition TTree.h:520; TTree::fFileNumberInt_t fFileNumber! current file number (if file extensions)Definition TTree.h:116; TTree::GetLeafvirtual TLeaf * GetLeaf(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6195; TTree::GetZipBytesvirtual Long64_t GetZipBytes() constDefinition TTree.h:585; TTree::fLeavesTObjArray fLeavesDirect pointers to individual branch leaves.Definition TTree.h:123; TTree::Resetvirtual void Reset(Option_t *option="""")Reset baskets, buffers and entries count in all branches and leaves.Definition TTree.cxx:8003; TTree::SetImplicitMTvirtual void SetImplicitMT(bool enabled)Definition TTree.h:661; TTree::KeepCircularvirtual void KeepCircular()Keep a maximum of fMaxEntries in memory.Definition TTree.cxx:6415; TTree::SetDefaultEntryOffsetLenvirtual void SetDefaultEntryOffsetLen(Int_t newdefault, bool updateExisting=false)Update the default value for the branch's fEntryOffsetLen.Definition TTree.cxx:8940; TTree::DirectoryAutoAddvirtual void DirectoryAutoAdd(TDirectory *)Called by TKey and TObject::Clone to automatically add us to a directory when we are read from a file...Definition TTree.cxx:3819; TTree::fMaxVirtualSizeLong64_t fMaxVirtualSizeMaximum total size of buffers kept in memory.Definition TTree.h:99; TTree::GetTotBytesvirtual Long64_t GetTotBytes() constDefinition TTree.h:556; TTree::MakeSelectorvirtual Int_t MakeSelector(const char *selector=nullptr, Option_t *option="""")Generate skeleton selector class for this tree.Definition TTree.cxx:6822; TTree::SetObjectvirtual void SetObject(const char *name, const char *title)Change the name and title of this tree.Definition TTree.cxx:9260; TTree::fPerfStatsTVirtualPerfStats * fPerfStats! pointer to the current perf stats objectDefinition TTree.h:132; TTree::fWeightDouble_t fWeightTree weight (see TTree::SetWeight)Defini",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:3303,Energy Efficiency,allocate,allocated,3303,"ist;; 64class TEntryList;; 65class TSQLResult;; 66class TSelector;; 67class TPrincipal;; 68class TFriendElement;; 69class TCut;; 70class TVirtualIndex;; 71class TBranchRef;; 72class TBasket;; 73class TStreamerInfo;; 74class TTreeCache;; 75class TTreeCloner;; 76class TFileMergeInfo;; 77class TVirtualPerfStats;; 78 ; 79class TTree : public TNamed, public TAttLine, public TAttFill, public TAttMarker {; 80 ; 81 using TIOFeatures = ROOT::TIOFeatures;; 82 ; 83protected:; 84 Long64_t fEntries; ///< Number of entries; 85// NOTE: cannot use std::atomic for these counters as it cannot be serialized.; 86 Long64_t fTotBytes; ///< Total number of bytes in all branches before compression; 87 Long64_t fZipBytes; ///< Total number of bytes in all branches after compression; 88 Long64_t fSavedBytes; ///< Number of autosaved bytes; 89 Long64_t fFlushedBytes; ///< Number of auto-flushed bytes; 90 Double_t fWeight; ///< Tree weight (see TTree::SetWeight); 91 Int_t fTimerInterval; ///< Timer interval in milliseconds; 92 Int_t fScanField; ///< Number of runs before prompting in Scan; 93 Int_t fUpdate; ///< Update frequency for EntryLoop; 94 Int_t fDefaultEntryOffsetLen; ///< Initial Length of fEntryOffset table in the basket buffers; 95 Int_t fNClusterRange; ///< Number of Cluster range in addition to the one defined by 'AutoFlush'; 96 Int_t fMaxClusterRange; ///<! Memory allocated for the cluster range.; 97 Long64_t fMaxEntries; ///< Maximum number of entries in case of circular buffers; 98 Long64_t fMaxEntryLoop; ///< Maximum number of entries to process; 99 Long64_t fMaxVirtualSize; ///< Maximum total size of buffers kept in memory; 100 Long64_t fAutoSave; ///< Autosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced; 101 Long64_t fAutoFlush; ///< Auto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced; 102 Long64_t fEstimate; ///< Number of entries to estimate histogram limits; 103 Long64_t *fClusterRangeEnd; ///<[fNClus",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:55629,Energy Efficiency,allocate,allocated,55629,"r(Long64_t entry) constDefinition TTree.h:455; TTree::GetBranchStatusvirtual bool GetBranchStatus(const char *branchname) constReturn status of branch with name branchname.Definition TTree.cxx:5380; TTree::fFriendLockStatusUInt_t fFriendLockStatus! Record which method is locking the friend recursionDefinition TTree.h:137; TTree::GetLeafImplvirtual TLeaf * GetLeafImpl(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6098; TTree::fTotBytesLong64_t fTotBytesTotal number of bytes in all branches before compression.Definition TTree.h:86; TTree::FlushBasketsvirtual Int_t FlushBaskets(bool create_cluster=true) constWrite to disk all the basket that have not yet been individually written and create an event cluster ...Definition TTree.cxx:5129; TTree::GetDefaultEntryOffsetLenInt_t GetDefaultEntryOffsetLen() constDefinition TTree.h:459; TTree::fMaxClusterRangeInt_t fMaxClusterRange! Memory allocated for the cluster range.Definition TTree.h:96; TTree::Showvirtual void Show(Long64_t entry=-1, Int_t lenmax=20)Print values of all active leaves for entry.Definition TTree.cxx:9385; TTree::fEventListTEventList * fEventList! Pointer to event selection list (if one)Definition TTree.h:125; TTree::GetAutoSavevirtual Long64_t GetAutoSave() constDefinition TTree.h:448; TTree::StopCacheLearningPhasevirtual Int_t StopCacheLearningPhase()Stop the cache learning phase.Definition TTree.cxx:9474; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::fSortedBranchesstd::vector< std::pair< Long64_t, TBranch * > > fSortedBranches! Branches to be processed in parallel when IMT is on, sorted by average task timeDefinition TTree.h:144; TTree::SetCircularvirtual void SetCircular(Long64_t maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTree",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:88405,Energy Efficiency,allocate,allocate,88405,on TTree.h:244; TTree::kClassMismatch@ kClassMismatchDefinition TTree.h:237; TTree::kNeedDisableDecomposedObj@ kNeedDisableDecomposedObjDefinition TTree.h:245; TTree::kVoidPtr@ kVoidPtrDefinition TTree.h:242; TTree::kNoCheck@ kNoCheckDefinition TTree.h:243; TTree::kMatchConversionCollection@ kMatchConversionCollectionDefinition TTree.h:240; TTree::kMissingCompiledCollectionProxy@ kMissingCompiledCollectionProxyDefinition TTree.h:235; TTree::kMismatch@ kMismatchDefinition TTree.h:236; TTree::kMatchConversion@ kMatchConversionDefinition TTree.h:239; TTree::kInternalError@ kInternalErrorDefinition TTree.h:234; TTree::kDecomposedObjMask@ kDecomposedObjMaskDefinition TTree.h:246; TTree::kMatch@ kMatchDefinition TTree.h:238; TTree::kMissingBranch@ kMissingBranchDefinition TTree.h:233; TTree::kMakeClass@ kMakeClassDefinition TTree.h:241; TTree::fgBranchStylestatic Int_t fgBranchStyleOld/New branch style.Definition TTree.h:154; TTree::ResetBranchAddressesvirtual void ResetBranchAddresses()Tell all of our branches to drop their current objects and allocate new ones.Definition TTree.cxx:8075; TTree::fNfillInt_t fNfill! Local for EntryLoopDefinition TTree.h:110; TTree::SetNamevoid SetName(const char *name) overrideChange the name of this tree.Definition TTree.cxx:9205; TTree::GetCacheSizevirtual Long64_t GetCacheSize() constDefinition TTree.h:453; TTree::RegisterExternalFriendvirtual void RegisterExternalFriend(TFriendElement *)Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is...Definition TTree.cxx:7957; TTree::fIndexTArrayI fIndexIndex of sorted values.Definition TTree.h:128; TTree::GetPacketSizevirtual Int_t GetPacketSize() constDefinition TTree.h:545; TTree::SetCacheSizevirtual Int_t SetCacheSize(Long64_t cachesize=-1)Set maximum size of the file cache .Definition TTree.cxx:8683; TTree::AddClonevoid AddClone(TTree *)Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when...Def,MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:10759,Integrability,interface,interfaces,10759,"tNewlineValue(std::istream &inputStream);; 184 void ImportClusterRanges(TTree *fromtree);; 185 void MoveReadCache(TFile *src, TDirectory *dir);; 186 Int_t SetCacheSizeAux(bool autocache = true, Long64_t cacheSize = 0);; 187 ; 188 class TFriendLock {; 189 // Helper class to prevent infinite recursion in the; 190 // usage of TTree Friends. Implemented in TTree.cxx.; 191 TTree *fTree; // Pointer to the locked tree; 192 UInt_t fMethodBit; // BIT for the locked method; 193 bool fPrevious; // Previous value of the BIT.; 194 ; 195 protected:; 196 TFriendLock(const TFriendLock&);; 197 TFriendLock& operator=(const TFriendLock&);; 198 ; 199 public:; 200 TFriendLock(TTree* tree, UInt_t methodbit);; 201 ~TFriendLock();; 202 };; 203 friend class TFriendLock;; 204 // So that the index class can use TFriendLock:; 205 friend class TTreeIndex;; 206 friend class TChainIndex;; 207 // So that the TTreeCloner can access the protected interfaces; 208 friend class TTreeCloner;; 209 ; 210 // use to update fFriendLockStatus; 211 enum ELockStatusBits {; 212 kFindBranch = BIT(0),; 213 kFindLeaf = BIT(1),; 214 kGetAlias = BIT(2),; 215 kGetBranch = BIT(3),; 216 kGetEntry = BIT(4),; 217 kGetEntryWithIndex = BIT(5),; 218 kGetFriend = BIT(6),; 219 kGetFriendAlias = BIT(7),; 220 kGetLeaf = BIT(8),; 221 kLoadTree = BIT(9),; 222 kPrint = BIT(10),; 223 kRemoveFriend = BIT(11),; 224 kSetBranchStatus = BIT(12); 225 };; 226 ; 227public:; 228 // Used as the max value for any TTree range operation.; 229 static constexpr Long64_t kMaxEntries = TVirtualTreePlayer::kMaxEntries;; 230 ; 231 // SetBranchAddress return values; 232 enum ESetBranchAddressStatus {; 233 kMissingBranch = -5,; 234 kInternalError = -4,; 235 kMissingCompiledCollectionProxy = -3,; 236 kMismatch = -2,; 237 kClassMismatch = -1,; 238 kMatch = 0,; 239 kMatchConversion = 1,; 240 kMatchConversionCollection = 2,; 241 kMakeClass = 3,; 242 kVoidPtr = 4,; 243 kNoCheck = 5,; 244 kNeedEnableDecomposedObj = BIT(29), // DecomposedObj is the newer name ",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:25215,Integrability,depend,depends,25215,"7 virtual bool GetClusterPrefetch() const { return fCacheDoClusterPrefetch; }; 458 TFile *GetCurrentFile() const;; 459 Int_t GetDefaultEntryOffsetLen() const {return fDefaultEntryOffsetLen;}; 460 Long64_t GetDebugMax() const { return fDebugMax; }; 461 Long64_t GetDebugMin() const { return fDebugMin; }; 462 TDirectory *GetDirectory() const { return fDirectory; }; 463 virtual Long64_t GetEntries() const { return fEntries; }; 464 virtual Long64_t GetEntries(const char *selection);; 465 /// Return a number greater or equal to the total number of entries in the; 466 /// dataset.; 467 ///; 468 /// \note If you are interested in the total number of entries in a TChain,; 469 /// this function will give that number once the last file of the chain; 470 /// is opened. In general, using this instead of GetEntries will avoid; 471 /// opening all files in the chain which could be very costly for very; 472 /// large number of files stored at a remote location.; 473 ///; 474 /// The logic depends on whether the dataset is a TTree or a TChain. In the; 475 /// first case, it simply returns the total number of entries in the tree. In; 476 /// the latter case, it depends on which point of the processing of the chain; 477 /// this function is called. During most of the chain processing, this; 478 /// function will return TTree::kMaxEntries. When the chain arrives at the; 479 /// last file, then the function will return the accumulated total number of; 480 /// entries in the whole chain. A notable use case where this function; 481 /// becomes quite useful is when writing the following for loop to traverse; 482 /// the entries in the dataset:; 483 ///; 484 /// \code{.cpp}; 485 /// for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; 486 /// // Do something with the event in the dataset; 487 /// }; 488 /// \endcode; 489 ///; 490 /// In the example above, independently on whether the dataset is a TTree or; 491 /// a TChain, the GetEntriesFast call will provide the correct",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:25389,Integrability,depend,depends,25389,"}; 460 Long64_t GetDebugMax() const { return fDebugMax; }; 461 Long64_t GetDebugMin() const { return fDebugMin; }; 462 TDirectory *GetDirectory() const { return fDirectory; }; 463 virtual Long64_t GetEntries() const { return fEntries; }; 464 virtual Long64_t GetEntries(const char *selection);; 465 /// Return a number greater or equal to the total number of entries in the; 466 /// dataset.; 467 ///; 468 /// \note If you are interested in the total number of entries in a TChain,; 469 /// this function will give that number once the last file of the chain; 470 /// is opened. In general, using this instead of GetEntries will avoid; 471 /// opening all files in the chain which could be very costly for very; 472 /// large number of files stored at a remote location.; 473 ///; 474 /// The logic depends on whether the dataset is a TTree or a TChain. In the; 475 /// first case, it simply returns the total number of entries in the tree. In; 476 /// the latter case, it depends on which point of the processing of the chain; 477 /// this function is called. During most of the chain processing, this; 478 /// function will return TTree::kMaxEntries. When the chain arrives at the; 479 /// last file, then the function will return the accumulated total number of; 480 /// entries in the whole chain. A notable use case where this function; 481 /// becomes quite useful is when writing the following for loop to traverse; 482 /// the entries in the dataset:; 483 ///; 484 /// \code{.cpp}; 485 /// for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; 486 /// // Do something with the event in the dataset; 487 /// }; 488 /// \endcode; 489 ///; 490 /// In the example above, independently on whether the dataset is a TTree or; 491 /// a TChain, the GetEntriesFast call will provide the correct stopping; 492 /// condition for the loop (i.e. the total number of entries). In the TChain; 493 /// case, calling GetEntries instead would open all the files in the chain; 494 /// upfront",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:47362,Integrability,interface,interface,47362,"9; TBasketManages buffers for branches of a Tree.Definition TBasket.h:34; TBranchRefA branch containing and managing a TRefTable for TRef autoloading.Definition TBranchRef.h:34; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TChainIndexA Chain Index.Definition TChainIndex.h:40; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TCollectionCollection abstract base class.Definition TCollection.h:65; TCutA specialized string object used for TTree selections.Definition TCut.h:25; TDataType::GetTypeInt_t GetType() constDefinition TDataType.h:68; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TEntryListA List of entry numbers in a TTree or TChain.Definition TEntryList.h:26; TEventList<div class=""legacybox""><h2>Legacy Code</h2> TEventList is a legacy interface: there will be no bug fi...Definition TEventList.h:31; TFileMergeInfoDefinition TFileMergeInfo.h:42; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFriendElementA TFriendElement TF describes a TTree object TF in a file.Definition TFriendElement.h:33; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TIteratorIterator abstract base class.Definition TIterator.h:30; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TListA doubly linked list.Definition TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:48493,Integrability,message,message,48493,"le is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFriendElementA TFriendElement TF describes a TTree object TF in a file.Definition TFriendElement.h:33; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TIteratorIterator abstract base class.Definition TIterator.h:30; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TListA doubly linked list.Definition TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPolyMarkerA PolyMarker is defined by an array on N points in a 2-D space.Definition TPolyMarker.h:31; TPrincipalPrincipal Components Analysis (PCA)Definition TPrincipal.h:21; TSQLResultDefinition TSQLResult.h:31; TSelectorA TSelector object is used by the TTree::Draw, TTree::Scan, TTree::Process to navigate in a TTree and...Definition TSelector.h:31; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeFormulaUsed to pass a selection expression to the Tree drawing routine.Definition TTreeFormula.h:58; TTreeFriendLeafIterIterator on all the leaves in a TTree and its friend.Definition TTree.h:716; TTreeFriendLeafIter::operator!=bool operator!=(const TIterator &) const overrideCompare two iterator objects.Definition TTree.h",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:49227,Integrability,rout,routine,49227,"ed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPolyMarkerA PolyMarker is defined by an array on N points in a 2-D space.Definition TPolyMarker.h:31; TPrincipalPrincipal Components Analysis (PCA)Definition TPrincipal.h:21; TSQLResultDefinition TSQLResult.h:31; TSelectorA TSelector object is used by the TTree::Draw, TTree::Scan, TTree::Process to navigate in a TTree and...Definition TSelector.h:31; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeFormulaUsed to pass a selection expression to the Tree drawing routine.Definition TTreeFormula.h:58; TTreeFriendLeafIterIterator on all the leaves in a TTree and its friend.Definition TTree.h:716; TTreeFriendLeafIter::operator!=bool operator!=(const TIterator &) const overrideCompare two iterator objects.Definition TTree.h:738; TTreeFriendLeafIter::GetCollectionconst TCollection * GetCollection() const overrideDefinition TTree.h:734; TTreeFriendLeafIter::fTreeTTree * fTreetree being iteratedDefinition TTree.h:719; TTreeFriendLeafIter::operator*TObject * operator*() const overrideReturn current object or nullptr.Definition TTree.h:746; TTreeFriendLeafIter::Resetvoid Reset() overrideDefinition TTree.h:737; TTreeFriendLeafIter::operator=TIterator & operator=(const TIterator &rhs) overrideOverridden assignment operator. Does NOT copy the 'cursor' location!Definition TTree.cxx:9792; TTreeFriendLeafIter::~TTreeFriendLeafIter~TTreeFriendLeafIter() overrideDefinition TTree.h:730; TTreeFriendLeafIter::TTreeFriendLeafIterTTr",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:83697,Integrability,interface,interface,83697,":kGetAlias@ kGetAliasDefinition TTree.h:214; TTree::GetV4virtual Double_t * GetV4()Definition TTree.h:582; TTree::BranchTBranch * Branch(const char *name, const char *classname, T *obj, Int_t bufsize=32000, Int_t splitlevel=99)Definition TTree.h:395; TTree::GetVar3TTreeFormula * GetVar3()Definition TTree.h:570; TTree::SetTreeIndexvirtual void SetTreeIndex(TVirtualIndex *index)The current TreeIndex is replaced by the new index.Definition TTree.cxx:9346; TTree::OptimizeBasketsvirtual void OptimizeBaskets(ULong64_t maxMemory=10000000, Float_t minComp=1.1, Option_t *option="""")This function may be called after having filled some entries in a Tree.Definition TTree.cxx:7057; TTree::Projectvirtual Long64_t Project(const char *hname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Make a projection of a tree using selections.Definition TTree.cxx:7498; TTree::SetCacheEntryRangevirtual Int_t SetCacheEntryRange(Long64_t first, Long64_t last)interface to TTreeCache to set the cache entry rangeDefinition TTree.cxx:8831; TTree::GetMaxTreeSizestatic Long64_t GetMaxTreeSize()Static function which returns the tree file size limit in bytes.Definition TTree.cxx:6265; TTree::fCacheDoClusterPrefetchbool fCacheDoClusterPrefetch! true if cache is prefetching whole clustersDefinition TTree.h:140; TTree::SetBranchAddressImpInt_t SetBranchAddressImp(TBranch *branch, void *addr, TBranch **ptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8445; TTree::SetAliasvirtual bool SetAlias(const char *aliasName, const char *aliasFormula)Set a tree variable alias.Definition TTree.cxx:8141; TTree::GetTimerIntervalvirtual Int_t GetTimerInterval() constDefinition TTree.h:554; TTree::CopyAddressesvirtual void CopyAddresses(TTree *, bool undo=false)Set branch addresses of passed tree equal to ours.Definition TTree.cxx:3299; TTree::SetScanFieldvirtual void SetScanField(Int_t n=50)Sets the default maximum numb",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:92872,Integrability,interface,interface,92872,"CopyEntriesvirtual Long64_t CopyEntries(TTree *tree, Long64_t nentries=-1, Option_t *option="""", bool needCopyAddresses=false)Copy nentries from given tree to this tree.Definition TTree.cxx:3534; TTree::fMakeClassInt_t fMakeClass! not zero when processing code generated by MakeClassDefinition TTree.h:115; TTree::LoadBasketsvirtual Int_t LoadBaskets(Long64_t maxmemory=2000000000)Read in memory all baskets from all branches up to the limit of maxmemory bytes.Definition TTree.cxx:6451; TTree::kMaxEntriesstatic constexpr Long64_t kMaxEntriesDefinition TTree.h:229; TTree::PrincipalTPrincipal * Principal(const char *varexp="""", const char *selection="""", Option_t *option=""np"", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Interface to the Principal Components Analysis class.Definition TTree.cxx:7200; TTree::GetAutoFlushvirtual Long64_t GetAutoFlush() constDefinition TTree.h:447; TTree::GetMaxVirtualSizevirtual Long64_t GetMaxVirtualSize() constDefinition TTree.h:540; TVirtualIndexAbstract interface for Tree Index.Definition TVirtualIndex.h:30; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; TVirtualTreePlayerAbstract base class defining the interface for the plugins that implement Draw, Scan,...Definition TVirtualTreePlayer.h:38; TVirtualTreePlayer::GetVar1virtual TTreeFormula * GetVar1() const =0; TVirtualTreePlayer::GetV4virtual Double_t * GetV4() const =0; TVirtualTreePlayer::GetWvirtual Double_t * GetW() const =0; TVirtualTreePlayer::GetVar4virtual TTreeFormula * GetVar4() const =0; TVirtualTreePlayer::GetVarvirtual TTreeFormula * GetVar(Int_t) const =0; TVirtualTreePlayer::GetValvirtual Double_t * GetVal(Int_t) const =0; TVirtualTreePlayer::GetVar2virtual TTreeFormula * GetVar2() const =0; TVirtualTreePlayer::GetV1virtual Double_t * GetV1() const =0; TVirtualTreePlayer::kMaxEntriesstatic constexpr Long64_t kMaxEntriesDefinition TVirtualTreePlayer.h:45; TVirtualTreePlayer::",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:92958,Integrability,interface,interface,92958,"pyAddresses=false)Copy nentries from given tree to this tree.Definition TTree.cxx:3534; TTree::fMakeClassInt_t fMakeClass! not zero when processing code generated by MakeClassDefinition TTree.h:115; TTree::LoadBasketsvirtual Int_t LoadBaskets(Long64_t maxmemory=2000000000)Read in memory all baskets from all branches up to the limit of maxmemory bytes.Definition TTree.cxx:6451; TTree::kMaxEntriesstatic constexpr Long64_t kMaxEntriesDefinition TTree.h:229; TTree::PrincipalTPrincipal * Principal(const char *varexp="""", const char *selection="""", Option_t *option=""np"", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Interface to the Principal Components Analysis class.Definition TTree.cxx:7200; TTree::GetAutoFlushvirtual Long64_t GetAutoFlush() constDefinition TTree.h:447; TTree::GetMaxVirtualSizevirtual Long64_t GetMaxVirtualSize() constDefinition TTree.h:540; TVirtualIndexAbstract interface for Tree Index.Definition TVirtualIndex.h:30; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; TVirtualTreePlayerAbstract base class defining the interface for the plugins that implement Draw, Scan,...Definition TVirtualTreePlayer.h:38; TVirtualTreePlayer::GetVar1virtual TTreeFormula * GetVar1() const =0; TVirtualTreePlayer::GetV4virtual Double_t * GetV4() const =0; TVirtualTreePlayer::GetWvirtual Double_t * GetW() const =0; TVirtualTreePlayer::GetVar4virtual TTreeFormula * GetVar4() const =0; TVirtualTreePlayer::GetVarvirtual TTreeFormula * GetVar(Int_t) const =0; TVirtualTreePlayer::GetValvirtual Double_t * GetVal(Int_t) const =0; TVirtualTreePlayer::GetVar2virtual TTreeFormula * GetVar2() const =0; TVirtualTreePlayer::GetV1virtual Double_t * GetV1() const =0; TVirtualTreePlayer::kMaxEntriesstatic constexpr Long64_t kMaxEntriesDefinition TVirtualTreePlayer.h:45; TVirtualTreePlayer::GetVar3virtual TTreeFormula * GetVar3() const =0; TVirtualTreePlayer::GetV2virtual Double_t * GetV2() const ",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:93119,Integrability,interface,interface,93119,"cessing code generated by MakeClassDefinition TTree.h:115; TTree::LoadBasketsvirtual Int_t LoadBaskets(Long64_t maxmemory=2000000000)Read in memory all baskets from all branches up to the limit of maxmemory bytes.Definition TTree.cxx:6451; TTree::kMaxEntriesstatic constexpr Long64_t kMaxEntriesDefinition TTree.h:229; TTree::PrincipalTPrincipal * Principal(const char *varexp="""", const char *selection="""", Option_t *option=""np"", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Interface to the Principal Components Analysis class.Definition TTree.cxx:7200; TTree::GetAutoFlushvirtual Long64_t GetAutoFlush() constDefinition TTree.h:447; TTree::GetMaxVirtualSizevirtual Long64_t GetMaxVirtualSize() constDefinition TTree.h:540; TVirtualIndexAbstract interface for Tree Index.Definition TVirtualIndex.h:30; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; TVirtualTreePlayerAbstract base class defining the interface for the plugins that implement Draw, Scan,...Definition TVirtualTreePlayer.h:38; TVirtualTreePlayer::GetVar1virtual TTreeFormula * GetVar1() const =0; TVirtualTreePlayer::GetV4virtual Double_t * GetV4() const =0; TVirtualTreePlayer::GetWvirtual Double_t * GetW() const =0; TVirtualTreePlayer::GetVar4virtual TTreeFormula * GetVar4() const =0; TVirtualTreePlayer::GetVarvirtual TTreeFormula * GetVar(Int_t) const =0; TVirtualTreePlayer::GetValvirtual Double_t * GetVal(Int_t) const =0; TVirtualTreePlayer::GetVar2virtual TTreeFormula * GetVar2() const =0; TVirtualTreePlayer::GetV1virtual Double_t * GetV1() const =0; TVirtualTreePlayer::kMaxEntriesstatic constexpr Long64_t kMaxEntriesDefinition TVirtualTreePlayer.h:45; TVirtualTreePlayer::GetVar3virtual TTreeFormula * GetVar3() const =0; TVirtualTreePlayer::GetV2virtual Double_t * GetV2() const =0; TVirtualTreePlayer::GetSelectvirtual TTreeFormula * GetSelect() const =0; TVirtualTreePlayer::GetHistogramvirtual TH1 * GetHistogram() ",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:63420,Modifiability,variab,variable,63420,"ndname.Definition TTree.cxx:5975; TTree::GetVarTTreeFormula * GetVar(Int_t i)Definition TTree.h:564; TTree::SetNotifyvirtual void SetNotify(TObject *obj)Sets the address of the object to be notified when the tree is loaded.Definition TTree.cxx:9231; TTree::GetMaximumvirtual Double_t GetMaximum(const char *columname)Return maximum of column with name columname.Definition TTree.cxx:6235; TTree::GetEntryNumberWithBestIndexvirtual Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor=0) constReturn entry number corresponding to major and minor number.Definition TTree.cxx:5890; TTree::SetMaxTreeSizestatic void SetMaxTreeSize(Long64_t maxsize=100000000000LL)Set the maximum size in bytes of a Tree file (static function).Definition TTree.cxx:9197; TTree::Printvoid Print(Option_t *option="""") const overridePrint a summary of the tree contents.Definition TTree.cxx:7219; TTree::UnbinnedFitvirtual Int_t UnbinnedFit(const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Unbinned fit of one or more variable(s) from a tree.Definition TTree.cxx:9702; TTree::fNClusterRangeInt_t fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'.Definition TTree.h:95; TTree::PrintCacheStatsvirtual void PrintCacheStats(Option_t *option="""") constPrint statistics about the TreeCache for this tree.Definition TTree.cxx:7370; TTree::BuildIndexvirtual Int_t BuildIndex(const char *majorname, const char *minorname=""0"")Build a Tree Index (default is TTreeIndex).Definition TTree.cxx:2637; TTree::fPlayerTVirtualTreePlayer * fPlayer! Pointer to current Tree playerDefinition TTree.h:134; TTree::GetIteratorOnAllLeavesvirtual TIterator * GetIteratorOnAllLeaves(bool dir=kIterForward)Creates a new iterator that will go through all the leaves on the tree itself and its friend.Definition TTree.cxx:6082; TTree::SetMakeClassvirtual void SetMakeClass(Int_t make)Set all the branches in this TT",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:71048,Modifiability,variab,variable,71048,"h * Branch(const char *name, int address, const char *leaflist, Int_t bufsize=32000)Definition TTree.h:389; TTree::MoveReadCachevoid MoveReadCache(TFile *src, TDirectory *dir)Move a cache from a file to the current file in dir.Definition TTree.cxx:6983; TTree::operator=TTree & operator=(const TTree &tt)=delete; TTree::fAutoFlushLong64_t fAutoFlushAuto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced.Definition TTree.h:101; TTree::fUpdateInt_t fUpdateUpdate frequency for EntryLoop.Definition TTree.h:93; TTree::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Resets the state of this TTree after a merge (keep the customization but forget the data).Definition TTree.cxx:8034; TTree::BranchTBranch * Branch(const char *name, std::array< T, N > *obj, Int_t bufsize=32000, Int_t splitlevel=99)Definition TTree.h:405; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::SetEstimatevirtual void SetEstimate(Long64_t nentries=1000000)Set number of entries to estimate variable limits.Definition TTree.cxx:9110; TTree::fTimerIntervalInt_t fTimerIntervalTimer interval in milliseconds.Definition TTree.h:91; TTree::fDebugInt_t fDebug! Debug levelDefinition TTree.h:111; TTree::SetCacheSizeAuxInt_t SetCacheSizeAux(bool autocache=true, Long64_t cacheSize=0)Set the size of the file cache and create it if possible.Definition TTree.cxx:8711; TTree::AutoSavevirtual Long64_t AutoSave(Option_t *option="""")AutoSave tree header every fAutoSave bytes.Definition TTree.cxx:1500; TTree::GetEntryNumbervirtual Long64_t GetEntryNumber(Long64_t entry) constReturn entry number corresponding to entry.Definition TTree.cxx:5865; TTree::CloneTreevirtual TTree * CloneTree(Long64_t nentries=-1, Option_t *option="""")Create a clone of this tree and copy nentries.Definition TTree.cxx:3139; TTree::GetImplicitMTvirtual bool GetImplicitMT()Definition TTree.h:520; TTree::fFileNumberInt_t fFileNumber! current file number (if file extensions)De",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:84322,Modifiability,variab,variable,84322,"ay be called after having filled some entries in a Tree.Definition TTree.cxx:7057; TTree::Projectvirtual Long64_t Project(const char *hname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Make a projection of a tree using selections.Definition TTree.cxx:7498; TTree::SetCacheEntryRangevirtual Int_t SetCacheEntryRange(Long64_t first, Long64_t last)interface to TTreeCache to set the cache entry rangeDefinition TTree.cxx:8831; TTree::GetMaxTreeSizestatic Long64_t GetMaxTreeSize()Static function which returns the tree file size limit in bytes.Definition TTree.cxx:6265; TTree::fCacheDoClusterPrefetchbool fCacheDoClusterPrefetch! true if cache is prefetching whole clustersDefinition TTree.h:140; TTree::SetBranchAddressImpInt_t SetBranchAddressImp(TBranch *branch, void *addr, TBranch **ptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8445; TTree::SetAliasvirtual bool SetAlias(const char *aliasName, const char *aliasFormula)Set a tree variable alias.Definition TTree.cxx:8141; TTree::GetTimerIntervalvirtual Int_t GetTimerInterval() constDefinition TTree.h:554; TTree::CopyAddressesvirtual void CopyAddresses(TTree *, bool undo=false)Set branch addresses of passed tree equal to ours.Definition TTree.cxx:3299; TTree::SetScanFieldvirtual void SetScanField(Int_t n=50)Sets the default maximum number of lines to be shown before <CR> when calling Scan().Definition TTree.h:691; TTree::TTreeTTree(const TTree &tt)=delete; TTree::fMaxEntriesLong64_t fMaxEntriesMaximum number of entries in case of circular buffers.Definition TTree.h:97; TTree::SetBranchAddressInt_t SetBranchAddress(const char *bname, T **add, TBranch **ptr=nullptr)Definition TTree.h:628; TTree::BranchTBranch * Branch(const char *name, char *address, const char *leaflist, Int_t bufsize=32000)Definition TTree.h:379; TTree::DropBuffersvirtual void DropBuffers(Int_t nbytes)Drop branch buffers to accommodate nbytes below Max",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:93137,Modifiability,plugin,plugins,93137,"cessing code generated by MakeClassDefinition TTree.h:115; TTree::LoadBasketsvirtual Int_t LoadBaskets(Long64_t maxmemory=2000000000)Read in memory all baskets from all branches up to the limit of maxmemory bytes.Definition TTree.cxx:6451; TTree::kMaxEntriesstatic constexpr Long64_t kMaxEntriesDefinition TTree.h:229; TTree::PrincipalTPrincipal * Principal(const char *varexp="""", const char *selection="""", Option_t *option=""np"", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Interface to the Principal Components Analysis class.Definition TTree.cxx:7200; TTree::GetAutoFlushvirtual Long64_t GetAutoFlush() constDefinition TTree.h:447; TTree::GetMaxVirtualSizevirtual Long64_t GetMaxVirtualSize() constDefinition TTree.h:540; TVirtualIndexAbstract interface for Tree Index.Definition TVirtualIndex.h:30; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; TVirtualTreePlayerAbstract base class defining the interface for the plugins that implement Draw, Scan,...Definition TVirtualTreePlayer.h:38; TVirtualTreePlayer::GetVar1virtual TTreeFormula * GetVar1() const =0; TVirtualTreePlayer::GetV4virtual Double_t * GetV4() const =0; TVirtualTreePlayer::GetWvirtual Double_t * GetW() const =0; TVirtualTreePlayer::GetVar4virtual TTreeFormula * GetVar4() const =0; TVirtualTreePlayer::GetVarvirtual TTreeFormula * GetVar(Int_t) const =0; TVirtualTreePlayer::GetValvirtual Double_t * GetVal(Int_t) const =0; TVirtualTreePlayer::GetVar2virtual TTreeFormula * GetVar2() const =0; TVirtualTreePlayer::GetV1virtual Double_t * GetV1() const =0; TVirtualTreePlayer::kMaxEntriesstatic constexpr Long64_t kMaxEntriesDefinition TVirtualTreePlayer.h:45; TVirtualTreePlayer::GetVar3virtual TTreeFormula * GetVar3() const =0; TVirtualTreePlayer::GetV2virtual Double_t * GetV2() const =0; TVirtualTreePlayer::GetSelectvirtual TTreeFormula * GetSelect() const =0; TVirtualTreePlayer::GetHistogramvirtual TH1 * GetHistogram() ",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:4939,Performance,load,loading,4939,ntries to estimate histogram limits; 103 Long64_t *fClusterRangeEnd; ///<[fNClusterRange] Last entry of a cluster range.; 104 Long64_t *fClusterSize; ///<[fNClusterRange] Number of entries in each cluster for a given range.; 105 Long64_t fCacheSize; ///<! Maximum size of file buffers; 106 Long64_t fChainOffset; ///<! Offset of 1st entry of this Tree in a TChain; 107 Long64_t fReadEntry; ///<! Number of the entry being processed; 108 std::atomic<Long64_t> fTotalBuffers; ///<! Total number of bytes in branch buffers; 109 Int_t fPacketSize; ///<! Number of entries in one packet for parallel root; 110 Int_t fNfill; ///<! Local for EntryLoop; 111 Int_t fDebug; ///<! Debug level; 112 Long64_t fDebugMin; ///<! First entry number to debug; 113 Long64_t fDebugMax; ///<! Last entry number to debug; 114 TIOFeatures fIOFeatures{0}; ///< IO features to define for newly-written baskets and branches.; 115 Int_t fMakeClass; ///<! not zero when processing code generated by MakeClass; 116 Int_t fFileNumber; ///<! current file number (if file extensions); 117 /// Object to be notified when loading a Tree.; 118 /// TTree::LoadTree() and TChain::LoadTree() will call fNotify->Notify().; 119 /// Usually points to a TNotifyLink if this is a TChain.; 120 TObject *fNotify; //!; 121 TDirectory *fDirectory; ///<! Pointer to directory holding this tree; 122 TObjArray fBranches; ///< List of Branches; 123 TObjArray fLeaves; ///< Direct pointers to individual branch leaves; 124 TList *fAliases; ///< List of aliases for expressions based on the tree branches.; 125 TEventList *fEventList; ///<! Pointer to event selection list (if one); 126 TEntryList *fEntryList; ///<! Pointer to event selection list (if one); 127 TArrayD fIndexValues; ///< Sorted index values; 128 TArrayI fIndex; ///< Index of sorted values; 129 TVirtualIndex *fTreeIndex; ///< Pointer to the tree Index (if any); 130 TList *fFriends; ///< pointer to list of friend elements; 131 TList *fExternalFriends; ///<! List of TFriendsElement ,MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:6522,Performance,cache,cache,6522,"ent pointing to us and need to be notified of LoadTree. Content not owned.; 132 TVirtualPerfStats *fPerfStats; ///<! pointer to the current perf stats object; 133 TList *fUserInfo; ///< pointer to a list of user objects associated to this Tree; 134 TVirtualTreePlayer *fPlayer; ///<! Pointer to current Tree player; 135 TList *fClones; ///<! List of cloned trees which share our addresses; 136 TBranchRef *fBranchRef; ///< Branch supporting the TRefTable (if any); 137 UInt_t fFriendLockStatus; ///<! Record which method is locking the friend recursion; 138 TBuffer *fTransientBuffer; ///<! Pointer to the current transient buffer.; 139 bool fCacheDoAutoInit; ///<! true if cache auto creation or resize check is needed; 140 bool fCacheDoClusterPrefetch;///<! true if cache is prefetching whole clusters; 141 bool fCacheUserSet; ///<! true if the cache setting was explicitly given by user; 142 bool fIMTEnabled; ///<! true if implicit multi-threading is enabled for this tree; 143 UInt_t fNEntriesSinceSorting; ///<! Number of entries processed since the last re-sorting of branches; 144 std::vector<std::pair<Long64_t,TBranch*>> fSortedBranches; ///<! Branches to be processed in parallel when IMT is on, sorted by average task time; 145 std::vector<TBranch*> fSeqBranches; ///<! Branches to be processed sequentially when IMT is on; 146 Float_t fTargetMemoryRatio{1.1f}; ///<! Ratio for memory usage in uncompressed buffers versus actual occupancy. 1.0; 147 /// indicates basket should be resized to exact memory usage, but causes significant; 148/// memory churn.; 149#ifdef R__TRACK_BASKET_ALLOC_TIME; 150 mutable std::atomic<ULong64_t> fAllocationTime{0}; ///<! Time spent reallocating basket memory buffers, in microseconds.; 151#endif; 152 mutable std::atomic<UInt_t> fAllocationCount{0}; ///<! Number of reallocations basket memory buffers.; 153 ; 154 static Int_t fgBranchStyle; ///< Old/New branch style; 155 static Long64_t fgMaxTreeSize; ///< Maximum size of a file containing a Tree; 15",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:6616,Performance,cache,cache,6616,"ent pointing to us and need to be notified of LoadTree. Content not owned.; 132 TVirtualPerfStats *fPerfStats; ///<! pointer to the current perf stats object; 133 TList *fUserInfo; ///< pointer to a list of user objects associated to this Tree; 134 TVirtualTreePlayer *fPlayer; ///<! Pointer to current Tree player; 135 TList *fClones; ///<! List of cloned trees which share our addresses; 136 TBranchRef *fBranchRef; ///< Branch supporting the TRefTable (if any); 137 UInt_t fFriendLockStatus; ///<! Record which method is locking the friend recursion; 138 TBuffer *fTransientBuffer; ///<! Pointer to the current transient buffer.; 139 bool fCacheDoAutoInit; ///<! true if cache auto creation or resize check is needed; 140 bool fCacheDoClusterPrefetch;///<! true if cache is prefetching whole clusters; 141 bool fCacheUserSet; ///<! true if the cache setting was explicitly given by user; 142 bool fIMTEnabled; ///<! true if implicit multi-threading is enabled for this tree; 143 UInt_t fNEntriesSinceSorting; ///<! Number of entries processed since the last re-sorting of branches; 144 std::vector<std::pair<Long64_t,TBranch*>> fSortedBranches; ///<! Branches to be processed in parallel when IMT is on, sorted by average task time; 145 std::vector<TBranch*> fSeqBranches; ///<! Branches to be processed sequentially when IMT is on; 146 Float_t fTargetMemoryRatio{1.1f}; ///<! Ratio for memory usage in uncompressed buffers versus actual occupancy. 1.0; 147 /// indicates basket should be resized to exact memory usage, but causes significant; 148/// memory churn.; 149#ifdef R__TRACK_BASKET_ALLOC_TIME; 150 mutable std::atomic<ULong64_t> fAllocationTime{0}; ///<! Time spent reallocating basket memory buffers, in microseconds.; 151#endif; 152 mutable std::atomic<UInt_t> fAllocationCount{0}; ///<! Number of reallocations basket memory buffers.; 153 ; 154 static Int_t fgBranchStyle; ///< Old/New branch style; 155 static Long64_t fgMaxTreeSize; ///< Maximum size of a file containing a Tree; 15",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:6695,Performance,cache,cache,6695,"ent pointing to us and need to be notified of LoadTree. Content not owned.; 132 TVirtualPerfStats *fPerfStats; ///<! pointer to the current perf stats object; 133 TList *fUserInfo; ///< pointer to a list of user objects associated to this Tree; 134 TVirtualTreePlayer *fPlayer; ///<! Pointer to current Tree player; 135 TList *fClones; ///<! List of cloned trees which share our addresses; 136 TBranchRef *fBranchRef; ///< Branch supporting the TRefTable (if any); 137 UInt_t fFriendLockStatus; ///<! Record which method is locking the friend recursion; 138 TBuffer *fTransientBuffer; ///<! Pointer to the current transient buffer.; 139 bool fCacheDoAutoInit; ///<! true if cache auto creation or resize check is needed; 140 bool fCacheDoClusterPrefetch;///<! true if cache is prefetching whole clusters; 141 bool fCacheUserSet; ///<! true if the cache setting was explicitly given by user; 142 bool fIMTEnabled; ///<! true if implicit multi-threading is enabled for this tree; 143 UInt_t fNEntriesSinceSorting; ///<! Number of entries processed since the last re-sorting of branches; 144 std::vector<std::pair<Long64_t,TBranch*>> fSortedBranches; ///<! Branches to be processed in parallel when IMT is on, sorted by average task time; 145 std::vector<TBranch*> fSeqBranches; ///<! Branches to be processed sequentially when IMT is on; 146 Float_t fTargetMemoryRatio{1.1f}; ///<! Ratio for memory usage in uncompressed buffers versus actual occupancy. 1.0; 147 /// indicates basket should be resized to exact memory usage, but causes significant; 148/// memory churn.; 149#ifdef R__TRACK_BASKET_ALLOC_TIME; 150 mutable std::atomic<ULong64_t> fAllocationTime{0}; ///<! Time spent reallocating basket memory buffers, in microseconds.; 151#endif; 152 mutable std::atomic<UInt_t> fAllocationCount{0}; ///<! Number of reallocations basket memory buffers.; 153 ; 154 static Int_t fgBranchStyle; ///< Old/New branch style; 155 static Long64_t fgMaxTreeSize; ///< Maximum size of a file containing a Tree; 15",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:6784,Performance,multi-thread,multi-threading,6784,"ent pointing to us and need to be notified of LoadTree. Content not owned.; 132 TVirtualPerfStats *fPerfStats; ///<! pointer to the current perf stats object; 133 TList *fUserInfo; ///< pointer to a list of user objects associated to this Tree; 134 TVirtualTreePlayer *fPlayer; ///<! Pointer to current Tree player; 135 TList *fClones; ///<! List of cloned trees which share our addresses; 136 TBranchRef *fBranchRef; ///< Branch supporting the TRefTable (if any); 137 UInt_t fFriendLockStatus; ///<! Record which method is locking the friend recursion; 138 TBuffer *fTransientBuffer; ///<! Pointer to the current transient buffer.; 139 bool fCacheDoAutoInit; ///<! true if cache auto creation or resize check is needed; 140 bool fCacheDoClusterPrefetch;///<! true if cache is prefetching whole clusters; 141 bool fCacheUserSet; ///<! true if the cache setting was explicitly given by user; 142 bool fIMTEnabled; ///<! true if implicit multi-threading is enabled for this tree; 143 UInt_t fNEntriesSinceSorting; ///<! Number of entries processed since the last re-sorting of branches; 144 std::vector<std::pair<Long64_t,TBranch*>> fSortedBranches; ///<! Branches to be processed in parallel when IMT is on, sorted by average task time; 145 std::vector<TBranch*> fSeqBranches; ///<! Branches to be processed sequentially when IMT is on; 146 Float_t fTargetMemoryRatio{1.1f}; ///<! Ratio for memory usage in uncompressed buffers versus actual occupancy. 1.0; 147 /// indicates basket should be resized to exact memory usage, but causes significant; 148/// memory churn.; 149#ifdef R__TRACK_BASKET_ALLOC_TIME; 150 mutable std::atomic<ULong64_t> fAllocationTime{0}; ///<! Time spent reallocating basket memory buffers, in microseconds.; 151#endif; 152 mutable std::atomic<UInt_t> fAllocationCount{0}; ///<! Number of reallocations basket memory buffers.; 153 ; 154 static Int_t fgBranchStyle; ///< Old/New branch style; 155 static Long64_t fgMaxTreeSize; ///< Maximum size of a file containing a Tree; 15",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:10035,Performance,cache,cacheSize,10035,"p bytes for the IMT flush baskets.; 162 ; 163 void InitializeBranchLists(bool checkLeafCount);; 164 void SortBranchesByTime();; 165 Int_t FlushBasketsImpl() const;; 166 void MarkEventCluster();; 167 Long64_t GetMedianClusterSize();; 168 ; 169protected:; 170 virtual void KeepCircular();; 171 virtual TBranch *BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel);; 172 virtual TBranch *BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel);; 173 virtual TBranch *BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel);; 174 virtual TBranch *BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel);; 175 virtual TBranch *BranchImpArr(const char* branchname, EDataType datatype, std::size_t N, void* addobj, Int_t bufsize, Int_t splitlevel);; 176 virtual Int_t CheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, bool ptr);; 177 virtual TBranch *BronchExec(const char* name, const char* classname, void* addobj, bool isptrptr, Int_t bufsize, Int_t splitlevel);; 178 friend TBranch *TTreeBranchImpRef(TTree *tree, const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel);; 179 Int_t SetBranchAddressImp(TBranch *branch, void* addr, TBranch** ptr);; 180 virtual TLeaf *GetLeafImpl(const char* branchname, const char* leafname);; 181 ; 182 Long64_t GetCacheAutoSize(bool withDefault = false);; 183 char GetNewlineValue(std::istream &inputStream);; 184 void ImportClusterRanges(TTree *fromtree);; 185 void MoveReadCache(TFile *src, TDirectory *dir);; 186 Int_t SetCacheSizeAux(bool autocache = true, Long64_t cacheSize = 0);; 187 ; 188 class TFriendLock {; 189 // Helper class to prevent infinite recursion in the; 190 // usage of TTree Friends. Implemented in TTree.cxx.; 191 TT",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:28964,Performance,perform,performance,28964,"virtual Int_t *GetIndex() { return &fIndex.fArray[0]; }; 522 virtual Double_t *GetIndexValues() { return &fIndexValues.fArray[0]; }; 523 ROOT::TIOFeatures GetIOFeatures() const;; 524 virtual TIterator *GetIteratorOnAllLeaves(bool dir = kIterForward);; 525 virtual TLeaf *GetLeaf(const char* branchname, const char* leafname);; 526 virtual TLeaf *GetLeaf(const char* name);; 527 virtual TList *GetListOfClones() { return fClones; }; 528 virtual TObjArray *GetListOfBranches() { return &fBranches; }; 529 virtual TObjArray *GetListOfLeaves() { return &fLeaves; }; 530 virtual TList *GetListOfFriends() const { return fFriends; }; 531 virtual TList *GetListOfAliases() const { return fAliases; }; 532 ; 533 // GetMakeClass is left non-virtual for efficiency reason.; 534 // Making it virtual affects the performance of the I/O; 535 Int_t GetMakeClass() const { return fMakeClass; }; 536 ; 537 virtual Long64_t GetMaxEntryLoop() const { return fMaxEntryLoop; }; 538 virtual Double_t GetMaximum(const char* columname);; 539 static Long64_t GetMaxTreeSize();; 540 virtual Long64_t GetMaxVirtualSize() const { return fMaxVirtualSize; }; 541 virtual Double_t GetMinimum(const char* columname);; 542 virtual Int_t GetNbranches() { return fBranches.GetEntriesFast(); }; 543 TObject *GetNotify() const { return fNotify; }; 544 TVirtualTreePlayer *GetPlayer();; 545 virtual Int_t GetPacketSize() const { return fPacketSize; }; 546 virtual TVirtualPerfStats *GetPerfStats() const { return fPerfStats; }; 547 TTreeCache *GetReadCache(TFile *file) const;; 548 TTreeCache *GetReadCache(TFile *file, bool create);; 549 virtual Long64_t GetReadEntry() const { return fReadEntry; }; 550 virtual Long64_t GetReadEvent() const { return fReadEntry; }; 551 virtual Int_t GetScanField() const { return fScanField; }; 552 TTreeFormula *GetSelect() { return GetPlayer()->GetSelect(); }; 553 virtual Long64_t GetSelectedRows() { return GetPlayer()->GetSelectedRows(); }; 554 virtual Int_t GetTimerInterval() const { return fTime",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:36377,Performance,cache,cachesize,36377,"; 628 template <class T> Int_t SetBranchAddress(const char *bname, T **add, TBranch **ptr = nullptr) {; 629 TClass *cl = TClass::GetClass<T>();; 630 EDataType type = kOther_t;; 631 if (!cl) type = TDataType::GetType(typeid(T));; 632 return SetBranchAddress(bname,add,ptr,cl,type,true);; 633 }; 634#ifndef R__NO_CLASS_TEMPLATE_SPECIALIZATION; 635 // This can only be used when the template overload resolution can distinguish between; 636 // T* and T**; 637 template <class T> Int_t SetBranchAddress(const char *bname, T *add, TBranch **ptr = nullptr) {; 638 TClass *cl = TClass::GetClass<T>();; 639 EDataType type = kOther_t;; 640 if (!cl) type = TDataType::GetType(typeid(T));; 641 return SetBranchAddress(bname,add,ptr,cl,type,false);; 642 }; 643#endif; 644 virtual void SetBranchStatus(const char* bname, bool status = true, UInt_t* found = nullptr);; 645 static void SetBranchStyle(Int_t style = 1); //style=0 for old branch, =1 for new branch style; 646 virtual Int_t SetCacheSize(Long64_t cachesize = -1);; 647 virtual Int_t SetCacheEntryRange(Long64_t first, Long64_t last);; 648 virtual void SetCacheLearnEntries(Int_t n=10);; 649 virtual void SetChainOffset(Long64_t offset = 0) { fChainOffset=offset; }; 650 virtual void SetCircular(Long64_t maxEntries);; 651 virtual void SetClusterPrefetch(bool enabled) { fCacheDoClusterPrefetch = enabled; }; 652 virtual void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); // *MENU*; 653 virtual void SetDefaultEntryOffsetLen(Int_t newdefault, bool updateExisting = false);; 654 virtual void SetDirectory(TDirectory* dir);; 655 virtual Long64_t SetEntries(Long64_t n = -1);; 656 virtual void SetEstimate(Long64_t nentries = 1000000);; 657 ROOT::TIOFeatures SetIOFeatures(const ROOT::TIOFeatures &);; 658 virtual void SetFileNumber(Int_t number = 0);; 659 virtual void SetEventList(TEventList* list);; 660 virtual void SetEntryList(TEntryList* list, Option_t *opt="""");; 661 virtual void SetImplicitMT(bool enabled) { fIMTEnabled = e",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:37846,Performance,load,loaded,37846,"ss T> Int_t SetBranchAddress(const char *bname, T *add, TBranch **ptr = nullptr) {; 638 TClass *cl = TClass::GetClass<T>();; 639 EDataType type = kOther_t;; 640 if (!cl) type = TDataType::GetType(typeid(T));; 641 return SetBranchAddress(bname,add,ptr,cl,type,false);; 642 }; 643#endif; 644 virtual void SetBranchStatus(const char* bname, bool status = true, UInt_t* found = nullptr);; 645 static void SetBranchStyle(Int_t style = 1); //style=0 for old branch, =1 for new branch style; 646 virtual Int_t SetCacheSize(Long64_t cachesize = -1);; 647 virtual Int_t SetCacheEntryRange(Long64_t first, Long64_t last);; 648 virtual void SetCacheLearnEntries(Int_t n=10);; 649 virtual void SetChainOffset(Long64_t offset = 0) { fChainOffset=offset; }; 650 virtual void SetCircular(Long64_t maxEntries);; 651 virtual void SetClusterPrefetch(bool enabled) { fCacheDoClusterPrefetch = enabled; }; 652 virtual void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); // *MENU*; 653 virtual void SetDefaultEntryOffsetLen(Int_t newdefault, bool updateExisting = false);; 654 virtual void SetDirectory(TDirectory* dir);; 655 virtual Long64_t SetEntries(Long64_t n = -1);; 656 virtual void SetEstimate(Long64_t nentries = 1000000);; 657 ROOT::TIOFeatures SetIOFeatures(const ROOT::TIOFeatures &);; 658 virtual void SetFileNumber(Int_t number = 0);; 659 virtual void SetEventList(TEventList* list);; 660 virtual void SetEntryList(TEntryList* list, Option_t *opt="""");; 661 virtual void SetImplicitMT(bool enabled) { fIMTEnabled = enabled; }; 662 virtual void SetMakeClass(Int_t make);; 663 virtual void SetMaxEntryLoop(Long64_t maxev = kMaxEntries) { fMaxEntryLoop = maxev; } // *MENU*; 664 static void SetMaxTreeSize(Long64_t maxsize = 100000000000LL);; 665 virtual void SetMaxVirtualSize(Long64_t size = 0) { fMaxVirtualSize = size; } // *MENU*; 666 void SetName(const char* name) override; // *MENU*; 667 ; 668 /**; 669 * @brief Sets the address of the object to be notified when the tree is loaded.",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:37950,Performance,load,loaded,37950,"eExisting = false);; 654 virtual void SetDirectory(TDirectory* dir);; 655 virtual Long64_t SetEntries(Long64_t n = -1);; 656 virtual void SetEstimate(Long64_t nentries = 1000000);; 657 ROOT::TIOFeatures SetIOFeatures(const ROOT::TIOFeatures &);; 658 virtual void SetFileNumber(Int_t number = 0);; 659 virtual void SetEventList(TEventList* list);; 660 virtual void SetEntryList(TEntryList* list, Option_t *opt="""");; 661 virtual void SetImplicitMT(bool enabled) { fIMTEnabled = enabled; }; 662 virtual void SetMakeClass(Int_t make);; 663 virtual void SetMaxEntryLoop(Long64_t maxev = kMaxEntries) { fMaxEntryLoop = maxev; } // *MENU*; 664 static void SetMaxTreeSize(Long64_t maxsize = 100000000000LL);; 665 virtual void SetMaxVirtualSize(Long64_t size = 0) { fMaxVirtualSize = size; } // *MENU*; 666 void SetName(const char* name) override; // *MENU*; 667 ; 668 /**; 669 * @brief Sets the address of the object to be notified when the tree is loaded.; 670 *; 671 * The method TObject::Notify is called for the given object when the tree; 672 * is loaded. Specifically this occurs in the TTree::LoadTree method. To; 673 * remove the notification call this method with nullptr:; 674 * @code tree->SetNotify(nullptr); @endcode; 675 *; 676 * If this is a TChain, `obj` is most often going to be a TNotifyLink.; 677 *; 678 * @param[in] obj Pointer to a TObject to be notified.; 679 */; 680 virtual void SetNotify(TObject* obj);; 681 ; 682 virtual void SetObject(const char* name, const char* title);; 683 virtual void SetParallelUnzip(bool opt=true, Float_t RelSize=-1);; 684 virtual void SetPerfStats(TVirtualPerfStats* perf);; 685 /**; 686 * \brief Sets the default maximum number of lines to be shown before `<CR>` when calling Scan().; 687 * \param n the maximum number of lines. Default=50, if 0, all entries of the Tree are shown; 688 * and there is no need to press `<CR>` or `q` to exit the function.; 689 * \see TTreePlayer::Scan for more details on how to redirect the output to an ASCII file; 690",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:48981,Performance,cache,cache,48981,"tion TList.h:38; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPolyMarkerA PolyMarker is defined by an array on N points in a 2-D space.Definition TPolyMarker.h:31; TPrincipalPrincipal Components Analysis (PCA)Definition TPrincipal.h:21; TSQLResultDefinition TSQLResult.h:31; TSelectorA TSelector object is used by the TTree::Draw, TTree::Scan, TTree::Process to navigate in a TTree and...Definition TSelector.h:31; TStreamerInfoDescribes a persistent version of a class.Definition TStreamerInfo.h:39; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeClonerClass implementing or helping the various TTree cloning method.Definition TTreeCloner.h:31; TTreeFormulaUsed to pass a selection expression to the Tree drawing routine.Definition TTreeFormula.h:58; TTreeFriendLeafIterIterator on all the leaves in a TTree and its friend.Definition TTree.h:716; TTreeFriendLeafIter::operator!=bool operator!=(const TIterator &) const overrideCompare two iterator objects.Definition TTree.h:738; TTreeFriendLeafIter::GetCollectionconst TCollection * GetCollection() const overrideDefinition TTree.h:734; TTreeFriendLeafIter::fTreeTTree * fTreetree being iteratedDefinition TTree.h:719; TTreeFriendLeafIter::operator*TObject * operator*() const overrideReturn current object or nullptr.Definition TTree.h:746; TTreeFriendLeafIter::Resetvoid Reset() overrideDefinition TTree.h:737; TTreeFriendLeafIter::operator=TIterator & operator=(const TIterator &rhs) overrideOverridden assignment operator. Does",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:54489,Performance,multi-thread,multi-threading,54489,"merIntervalvirtual void SetTimerInterval(Int_t msec=333)Definition TTree.h:693; TTree::SetBranchStatusvirtual void SetBranchStatus(const char *bname, bool status=true, UInt_t *found=nullptr)Set branch status to Process or DoNotProcess.Definition TTree.cxx:8534; TTree::GetSelectTTreeFormula * GetSelect()Definition TTree.h:552; TTree::EnableCachebool EnableCache()Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0).Definition TTree.cxx:2685; TTree::GetBranchvirtual TBranch * GetBranch(const char *name)Return pointer to the branch with the given name in this tree or its friends.Definition TTree.cxx:5294; TTree::GetScanFieldvirtual Int_t GetScanField() constDefinition TTree.h:551; TTree::GetBranchStylestatic Int_t GetBranchStyle()Static function returning the current branch style.Definition TTree.cxx:5395; TTree::fFriendsTList * fFriendspointer to list of friend elementsDefinition TTree.h:130; TTree::fIMTEnabledbool fIMTEnabled! true if implicit multi-threading is enabled for this treeDefinition TTree.h:142; TTree::GetChainEntryNumbervirtual Long64_t GetChainEntryNumber(Long64_t entry) constDefinition TTree.h:455; TTree::GetBranchStatusvirtual bool GetBranchStatus(const char *branchname) constReturn status of branch with name branchname.Definition TTree.cxx:5380; TTree::fFriendLockStatusUInt_t fFriendLockStatus! Record which method is locking the friend recursionDefinition TTree.h:137; TTree::GetLeafImplvirtual TLeaf * GetLeafImpl(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6098; TTree::fTotBytesLong64_t fTotBytesTotal number of bytes in all branches before compression.Definition TTree.h:86; TTree::FlushBasketsvirtual Int_t FlushBaskets(bool create_cluster=true) constWrite to disk all the basket that have not yet been individually written and create an event cluster ...Definition TTree.cxx:5129; TTree:",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:56079,Performance,cache,cache,56079,"he 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6098; TTree::fTotBytesLong64_t fTotBytesTotal number of bytes in all branches before compression.Definition TTree.h:86; TTree::FlushBasketsvirtual Int_t FlushBaskets(bool create_cluster=true) constWrite to disk all the basket that have not yet been individually written and create an event cluster ...Definition TTree.cxx:5129; TTree::GetDefaultEntryOffsetLenInt_t GetDefaultEntryOffsetLen() constDefinition TTree.h:459; TTree::fMaxClusterRangeInt_t fMaxClusterRange! Memory allocated for the cluster range.Definition TTree.h:96; TTree::Showvirtual void Show(Long64_t entry=-1, Int_t lenmax=20)Print values of all active leaves for entry.Definition TTree.cxx:9385; TTree::fEventListTEventList * fEventList! Pointer to event selection list (if one)Definition TTree.h:125; TTree::GetAutoSavevirtual Long64_t GetAutoSave() constDefinition TTree.h:448; TTree::StopCacheLearningPhasevirtual Int_t StopCacheLearningPhase()Stop the cache learning phase.Definition TTree.cxx:9474; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::fSortedBranchesstd::vector< std::pair< Long64_t, TBranch * > > fSortedBranches! Branches to be processed in parallel when IMT is on, sorted by average task timeDefinition TTree.h:144; TTree::SetCircularvirtual void SetCircular(Long64_t maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTree::GetEstimatevirtual Long64_t GetEstimate() constDefinition TTree.h:507; TTree::GetDebugMaxLong64_t GetDebugMax() constDefinition TTree.h:460; TTree::fSavedBytesLong64_t fSavedBytesNumber of autosaved bytes.Definition TTree.h:88; TTree::AddBranchToCachevirtual Int_t AddBranchToCache(const char *bname, bool subbranches=false)Add branch with name bname to the Tree cache.Definition TTree.cxx:1059; TTree::GetMedianClusterSizeLong64_t",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:56980,Performance,cache,cache,56980,"TTree.h:125; TTree::GetAutoSavevirtual Long64_t GetAutoSave() constDefinition TTree.h:448; TTree::StopCacheLearningPhasevirtual Int_t StopCacheLearningPhase()Stop the cache learning phase.Definition TTree.cxx:9474; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::fSortedBranchesstd::vector< std::pair< Long64_t, TBranch * > > fSortedBranches! Branches to be processed in parallel when IMT is on, sorted by average task timeDefinition TTree.h:144; TTree::SetCircularvirtual void SetCircular(Long64_t maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTree::GetEstimatevirtual Long64_t GetEstimate() constDefinition TTree.h:507; TTree::GetDebugMaxLong64_t GetDebugMax() constDefinition TTree.h:460; TTree::fSavedBytesLong64_t fSavedBytesNumber of autosaved bytes.Definition TTree.h:88; TTree::AddBranchToCachevirtual Int_t AddBranchToCache(const char *bname, bool subbranches=false)Add branch with name bname to the Tree cache.Definition TTree.cxx:1059; TTree::GetMedianClusterSizeLong64_t GetMedianClusterSize()Estimate the median cluster size for the TTree.Definition TTree.cxx:8297; TTree::GetClusterIteratorvirtual TClusterIterator GetClusterIterator(Long64_t firstentry)Return an iterator over the cluster of baskets starting at firstentry.Definition TTree.cxx:5467; TTree::ResetBranchAddressvirtual void ResetBranchAddress(TBranch *)Tell all of our branches to set their addresses to zero.Definition TTree.cxx:8065; TTree::fCacheUserSetbool fCacheUserSet! true if the cache setting was explicitly given by userDefinition TTree.h:141; TTree::GetNewlineValuechar GetNewlineValue(std::istream &inputStream)Determine which newline this file is using.Definition TTree.cxx:7588; TTree::BranchTBranch * Branch(const char *name, T **addobj, Int_t bufsize=32000, Int_t splitlevel=99)Add a new branch, and infer the data type from the array addobj being pass",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:57533,Performance,cache,cache,57533,"maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTree::GetEstimatevirtual Long64_t GetEstimate() constDefinition TTree.h:507; TTree::GetDebugMaxLong64_t GetDebugMax() constDefinition TTree.h:460; TTree::fSavedBytesLong64_t fSavedBytesNumber of autosaved bytes.Definition TTree.h:88; TTree::AddBranchToCachevirtual Int_t AddBranchToCache(const char *bname, bool subbranches=false)Add branch with name bname to the Tree cache.Definition TTree.cxx:1059; TTree::GetMedianClusterSizeLong64_t GetMedianClusterSize()Estimate the median cluster size for the TTree.Definition TTree.cxx:8297; TTree::GetClusterIteratorvirtual TClusterIterator GetClusterIterator(Long64_t firstentry)Return an iterator over the cluster of baskets starting at firstentry.Definition TTree.cxx:5467; TTree::ResetBranchAddressvirtual void ResetBranchAddress(TBranch *)Tell all of our branches to set their addresses to zero.Definition TTree.cxx:8065; TTree::fCacheUserSetbool fCacheUserSet! true if the cache setting was explicitly given by userDefinition TTree.h:141; TTree::GetNewlineValuechar GetNewlineValue(std::istream &inputStream)Determine which newline this file is using.Definition TTree.cxx:7588; TTree::BranchTBranch * Branch(const char *name, T **addobj, Int_t bufsize=32000, Int_t splitlevel=99)Add a new branch, and infer the data type from the array addobj being passed.Definition TTree.h:370; TTree::fIOFeaturesTIOFeatures fIOFeaturesIO features to define for newly-written baskets and branches.Definition TTree.h:114; TTree::GetSelectedRowsvirtual Long64_t GetSelectedRows()Definition TTree.h:553; TTree::AddAllocationCountvoid AddAllocationCount(UInt_t count)Definition TTree.h:337; TTree::SetMaxEntryLoopvirtual void SetMaxEntryLoop(Long64_t maxev=kMaxEntries)Definition TTree.h:663; TTree::GetEntryNumberWithIndexvirtual Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor=0) constReturn entry number corresponding to major and minor number.Definition TTree.cxx:5910; T",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:59127,Performance,cache,cache,59127,":GetSelectedRowsvirtual Long64_t GetSelectedRows()Definition TTree.h:553; TTree::AddAllocationCountvoid AddAllocationCount(UInt_t count)Definition TTree.h:337; TTree::SetMaxEntryLoopvirtual void SetMaxEntryLoop(Long64_t maxev=kMaxEntries)Definition TTree.h:663; TTree::GetEntryNumberWithIndexvirtual Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor=0) constReturn entry number corresponding to major and minor number.Definition TTree.cxx:5910; TTree::fDebugMinLong64_t fDebugMin! First entry number to debugDefinition TTree.h:112; TTree::SetEntriesvirtual Long64_t SetEntries(Long64_t n=-1)Change number of entries in the tree.Definition TTree.cxx:9011; TTree::GetListOfLeavesvirtual TObjArray * GetListOfLeaves()Definition TTree.h:529; TTree::BranchOldvirtual TBranch * BranchOld(const char *name, const char *classname, void *addobj, Int_t bufsize=32000, Int_t splitlevel=1)Create a new TTree BranchObject.Definition TTree.cxx:2074; TTree::GetCacheAutoSizeLong64_t GetCacheAutoSize(bool withDefault=false)Used for automatic sizing of the cache.Definition TTree.cxx:5407; TTree::BranchRefvirtual TBranch * BranchRef()Build the optional branch supporting the TRefTable.Definition TTree.cxx:2328; TTree::GetCurrentFileTFile * GetCurrentFile() constReturn pointer to the current file.Definition TTree.cxx:5479; TTree::GetNotifyTObject * GetNotify() constDefinition TTree.h:543; TTree::fAliasesTList * fAliasesList of aliases for expressions based on the tree branches.Definition TTree.h:124; TTree::BranchTBranch * Branch(const char *name, Longptr_t address, const char *leaflist, Int_t bufsize=32000)Definition TTree.h:384; TTree::CopyTreevirtual TTree * CopyTree(const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Copy a tree with selection.Definition TTree.cxx:3719; TTree::DropBranchFromCachevirtual Int_t DropBranchFromCache(const char *bname, bool subbranches=false)Remove the branch with name 'bname' from the Tree cache.Definition TTr",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:60053,Performance,cache,cache,60053," TTree BranchObject.Definition TTree.cxx:2074; TTree::GetCacheAutoSizeLong64_t GetCacheAutoSize(bool withDefault=false)Used for automatic sizing of the cache.Definition TTree.cxx:5407; TTree::BranchRefvirtual TBranch * BranchRef()Build the optional branch supporting the TRefTable.Definition TTree.cxx:2328; TTree::GetCurrentFileTFile * GetCurrentFile() constReturn pointer to the current file.Definition TTree.cxx:5479; TTree::GetNotifyTObject * GetNotify() constDefinition TTree.h:543; TTree::fAliasesTList * fAliasesList of aliases for expressions based on the tree branches.Definition TTree.h:124; TTree::BranchTBranch * Branch(const char *name, Longptr_t address, const char *leaflist, Int_t bufsize=32000)Definition TTree.h:384; TTree::CopyTreevirtual TTree * CopyTree(const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Copy a tree with selection.Definition TTree.cxx:3719; TTree::DropBranchFromCachevirtual Int_t DropBranchFromCache(const char *bname, bool subbranches=false)Remove the branch with name 'bname' from the Tree cache.Definition TTree.cxx:1142; TTree::Fitvirtual Int_t Fit(const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Option_t *goption="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Fit a projected item(s) from a tree.Definition TTree.cxx:5079; TTree::fClusterRangeEndLong64_t * fClusterRangeEnd[fNClusterRange] Last entry of a cluster range.Definition TTree.h:103; TTree::fIMTZipBytesstd::atomic< Long64_t > fIMTZipBytes! Zip bytes for the IMT flush baskets.Definition TTree.h:161; TTree::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideMake sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree.Definition TTree.cxx:7881; TTree::GetPlayerTVirtualTreePlayer * GetPlayer()Load the TTreePlayer (if not already done).Definition TTree.cxx:6305; TTree::MakeProxyvirtual Int_t MakeProxy(const char *classname, const char *macrofilename",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:62536,Performance,load,loaded,62536,"ee::GetListOfAliasesvirtual TList * GetListOfAliases() constDefinition TTree.h:531; TTree::ReadStreamvirtual Long64_t ReadStream(std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ')Create or simply read branches from an input stream.Definition TTree.cxx:7615; TTree::SetDebugvirtual void SetDebug(Int_t level=1, Long64_t min=0, Long64_t max=9999999)Set the debug level and the debug range.Definition TTree.cxx:8928; TTree::fScanFieldInt_t fScanFieldNumber of runs before prompting in Scan.Definition TTree.h:92; TTree::GetWeightvirtual Double_t GetWeight() constDefinition TTree.h:584; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; TTree::GetFriendvirtual TTree * GetFriend(const char *) constReturn a pointer to the TTree friend whose name or alias is friendname.Definition TTree.cxx:5975; TTree::GetVarTTreeFormula * GetVar(Int_t i)Definition TTree.h:564; TTree::SetNotifyvirtual void SetNotify(TObject *obj)Sets the address of the object to be notified when the tree is loaded.Definition TTree.cxx:9231; TTree::GetMaximumvirtual Double_t GetMaximum(const char *columname)Return maximum of column with name columname.Definition TTree.cxx:6235; TTree::GetEntryNumberWithBestIndexvirtual Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor=0) constReturn entry number corresponding to major and minor number.Definition TTree.cxx:5890; TTree::SetMaxTreeSizestatic void SetMaxTreeSize(Long64_t maxsize=100000000000LL)Set the maximum size in bytes of a Tree file (static function).Definition TTree.cxx:9197; TTree::Printvoid Print(Option_t *option="""") const overridePrint a summary of the tree contents.Definition TTree.cxx:7219; TTree::UnbinnedFitvirtual Int_t UnbinnedFit(const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Unbinned fit of one or more variable(s) from a tree.Definition TTree.cxx:9702; TTree::f",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:64945,Performance,cache,cache,64945,"eePlayer * fPlayer! Pointer to current Tree playerDefinition TTree.h:134; TTree::GetIteratorOnAllLeavesvirtual TIterator * GetIteratorOnAllLeaves(bool dir=kIterForward)Creates a new iterator that will go through all the leaves on the tree itself and its friend.Definition TTree.cxx:6082; TTree::SetMakeClassvirtual void SetMakeClass(Int_t make)Set all the branches in this TTree to be in decomposed object mode (also known as MakeClass mode).Definition TTree.cxx:9177; TTree::InPlaceClonevirtual bool InPlaceClone(TDirectory *newdirectory, const char *options="""")Copy the content to a new new file, update this TTree with the new location information and attach th...Definition TTree.cxx:7012; TTree::IncrementTotalBuffersvirtual void IncrementTotalBuffers(Int_t nbytes)Definition TTree.h:586; TTree::fBranchesTObjArray fBranchesList of Branches.Definition TTree.h:122; TTree::GetDirectoryTDirectory * GetDirectory() constDefinition TTree.h:462; TTree::fCacheDoAutoInitbool fCacheDoAutoInit! true if cache auto creation or resize check is neededDefinition TTree.h:139; TTree::GetReadCacheTTreeCache * GetReadCache(TFile *file) constFind and return the TTreeCache registered with the file and which may contain branches for us.Definition TTree.cxx:6318; TTree::fEntriesLong64_t fEntriesNumber of entries.Definition TTree.h:84; TTree::ChangeFilevirtual TFile * ChangeFile(TFile *file)Called by TTree::Fill() when file has reached its maximum fgMaxTreeSize.Definition TTree.cxx:2749; TTree::GetEntryListvirtual TEntryList * GetEntryList()Returns the entry list assigned to this tree.Definition TTree.cxx:5854; TTree::SetWeightvirtual void SetWeight(Double_t w=1, Option_t *option="""")Set tree weight.Definition TTree.cxx:9374; TTree::InitializeBranchListsvoid InitializeBranchLists(bool checkLeafCount)Divides the top-level branches into two vectors: (i) branches to be processed sequentially and (ii) b...Definition TTree.cxx:5781; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname,",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:70183,Performance,cache,cache,70183,"tBranchRefvirtual TBranchRef * GetBranchRef() constDefinition TTree.h:450; TTree::GetV3virtual Double_t * GetV3()Definition TTree.h:580; TTree::Processvirtual Long64_t Process(const char *filename, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Process this tree executing the TSelector code in the specified filename.Definition TTree.cxx:7450; TTree::BranchImpRefvirtual TBranch * BranchImpRef(const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel)Same as TTree::Branch but automatic detection of the class name.Definition TTree.cxx:1635; TTree::SetEventListvirtual void SetEventList(TEventList *list)This function transfroms the given TEventList into a TEntryList The new TEntryList is owned by the TT...Definition TTree.cxx:9069; TTree::BranchTBranch * Branch(const char *name, int address, const char *leaflist, Int_t bufsize=32000)Definition TTree.h:389; TTree::MoveReadCachevoid MoveReadCache(TFile *src, TDirectory *dir)Move a cache from a file to the current file in dir.Definition TTree.cxx:6983; TTree::operator=TTree & operator=(const TTree &tt)=delete; TTree::fAutoFlushLong64_t fAutoFlushAuto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced.Definition TTree.h:101; TTree::fUpdateInt_t fUpdateUpdate frequency for EntryLoop.Definition TTree.h:93; TTree::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Resets the state of this TTree after a merge (keep the customization but forget the data).Definition TTree.cxx:8034; TTree::BranchTBranch * Branch(const char *name, std::array< T, N > *obj, Int_t bufsize=32000, Int_t splitlevel=99)Definition TTree.h:405; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::SetEstimatevirtual void SetEstimate(Long64_t nentries=1000000)Set number of entries to estimate variable limits.Definition TTree.cxx:9110; TTree::fTimerIntervalInt_t fTimerIntervalTimer interval in milliseconds.De",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:71322,Performance,cache,cacheSize,71322,"ree::fAutoFlushLong64_t fAutoFlushAuto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced.Definition TTree.h:101; TTree::fUpdateInt_t fUpdateUpdate frequency for EntryLoop.Definition TTree.h:93; TTree::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Resets the state of this TTree after a merge (keep the customization but forget the data).Definition TTree.cxx:8034; TTree::BranchTBranch * Branch(const char *name, std::array< T, N > *obj, Int_t bufsize=32000, Int_t splitlevel=99)Definition TTree.h:405; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::SetEstimatevirtual void SetEstimate(Long64_t nentries=1000000)Set number of entries to estimate variable limits.Definition TTree.cxx:9110; TTree::fTimerIntervalInt_t fTimerIntervalTimer interval in milliseconds.Definition TTree.h:91; TTree::fDebugInt_t fDebug! Debug levelDefinition TTree.h:111; TTree::SetCacheSizeAuxInt_t SetCacheSizeAux(bool autocache=true, Long64_t cacheSize=0)Set the size of the file cache and create it if possible.Definition TTree.cxx:8711; TTree::AutoSavevirtual Long64_t AutoSave(Option_t *option="""")AutoSave tree header every fAutoSave bytes.Definition TTree.cxx:1500; TTree::GetEntryNumbervirtual Long64_t GetEntryNumber(Long64_t entry) constReturn entry number corresponding to entry.Definition TTree.cxx:5865; TTree::CloneTreevirtual TTree * CloneTree(Long64_t nentries=-1, Option_t *option="""")Create a clone of this tree and copy nentries.Definition TTree.cxx:3139; TTree::GetImplicitMTvirtual bool GetImplicitMT()Definition TTree.h:520; TTree::fFileNumberInt_t fFileNumber! current file number (if file extensions)Definition TTree.h:116; TTree::GetLeafvirtual TLeaf * GetLeaf(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6195; TTree::GetZipBytesvirtual Long64_t GetZipBytes() constDefinition TTree.h:585; T",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:71359,Performance,cache,cache,71359,"ree::fAutoFlushLong64_t fAutoFlushAuto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced.Definition TTree.h:101; TTree::fUpdateInt_t fUpdateUpdate frequency for EntryLoop.Definition TTree.h:93; TTree::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Resets the state of this TTree after a merge (keep the customization but forget the data).Definition TTree.cxx:8034; TTree::BranchTBranch * Branch(const char *name, std::array< T, N > *obj, Int_t bufsize=32000, Int_t splitlevel=99)Definition TTree.h:405; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::SetEstimatevirtual void SetEstimate(Long64_t nentries=1000000)Set number of entries to estimate variable limits.Definition TTree.cxx:9110; TTree::fTimerIntervalInt_t fTimerIntervalTimer interval in milliseconds.Definition TTree.h:91; TTree::fDebugInt_t fDebug! Debug levelDefinition TTree.h:111; TTree::SetCacheSizeAuxInt_t SetCacheSizeAux(bool autocache=true, Long64_t cacheSize=0)Set the size of the file cache and create it if possible.Definition TTree.cxx:8711; TTree::AutoSavevirtual Long64_t AutoSave(Option_t *option="""")AutoSave tree header every fAutoSave bytes.Definition TTree.cxx:1500; TTree::GetEntryNumbervirtual Long64_t GetEntryNumber(Long64_t entry) constReturn entry number corresponding to entry.Definition TTree.cxx:5865; TTree::CloneTreevirtual TTree * CloneTree(Long64_t nentries=-1, Option_t *option="""")Create a clone of this tree and copy nentries.Definition TTree.cxx:3139; TTree::GetImplicitMTvirtual bool GetImplicitMT()Definition TTree.h:520; TTree::fFileNumberInt_t fFileNumber! current file number (if file extensions)Definition TTree.h:116; TTree::GetLeafvirtual TLeaf * GetLeaf(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6195; TTree::GetZipBytesvirtual Long64_t GetZipBytes() constDefinition TTree.h:585; T",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:76126,Performance,load,loading,76126," *option="""")Static function merging the trees in the TList into a new tree.Definition TTree.cxx:6851; TTree::MemoryFullbool MemoryFull(Int_t nbytes)Check if adding nbytes to memory we are still below MaxVirtualsize.Definition TTree.cxx:6837; TTree::GetVar4TTreeFormula * GetVar4()Definition TTree.h:572; TTree::GetReadEntryvirtual Long64_t GetReadEntry() constDefinition TTree.h:549; TTree::GetListOfBranchesvirtual TObjArray * GetListOfBranches()Definition TTree.h:528; TTree::fZipBytesLong64_t fZipBytesTotal number of bytes in all branches after compression.Definition TTree.h:87; TTree::GetTreevirtual TTree * GetTree() constDefinition TTree.h:557; TTree::fTransientBufferTBuffer * fTransientBuffer! Pointer to the current transient buffer.Definition TTree.h:138; TTree::GetValvirtual Double_t * GetVal(Int_t i)Definition TTree.h:574; TTree::SetEntryListvirtual void SetEntryList(TEntryList *list, Option_t *opt="""")Set an EntryList.Definition TTree.cxx:9046; TTree::Notifybool Notify() overrideFunction called when loading a new class library.Definition TTree.cxx:7033; TTree::AddZipBytesvirtual void AddZipBytes(Int_t zip)Definition TTree.h:332; TTree::LoadTreevirtual Long64_t LoadTree(Long64_t entry)Set current entry.Definition TTree.cxx:6473; TTree::ReadFilevirtual Long64_t ReadFile(const char *filename, const char *branchDescriptor="""", char delimiter=' ')Create or simply read branches from filename.Definition TTree.cxx:7564; TTree::GetAliasvirtual const char * GetAlias(const char *aliasName) constReturns the expanded value of the alias. Search in the friends if any.Definition TTree.cxx:5226; TTree::SetIOFeaturesROOT::TIOFeatures SetIOFeatures(const ROOT::TIOFeatures &)Provide the end-user with the ability to enable/disable various experimental IO features for this TTr...Definition TTree.cxx:9130; TTree::CreateBasketvirtual TBasket * CreateBasket(TBranch *)Create a basket for this tree and given branch.Definition TTree.cxx:3731; TTree::fUserInfoTList * fUserInfopointer to a li",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:81267,Performance,load,loading,81267,"AllocationCount() constDefinition TTree.h:443; TTree::FlushBasketsImplInt_t FlushBasketsImpl() constInternal implementation of the FlushBaskets algorithm.Definition TTree.cxx:5146; TTree::GetDebugMinLong64_t GetDebugMin() constDefinition TTree.h:461; TTree::LoadTreeFriendvirtual Long64_t LoadTreeFriend(Long64_t entry, TTree *T)Load entry on behalf of our master tree, we may use an index.Definition TTree.cxx:6557; TTree::WriteInt_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0) overrideWrite this object to the current directory.Definition TTree.cxx:9753; TTree::fTreeIndexTVirtualIndex * fTreeIndexPointer to the tree Index (if any)Definition TTree.h:129; TTree::UseCurrentStylevoid UseCurrentStyle() overrideReplace current attributes by current style.Definition TTree.cxx:9714; TTree::GetTreeNumbervirtual Int_t GetTreeNumber() constDefinition TTree.h:559; TTree::GetEventInt_t GetEvent(Long64_t entry, Int_t getall=0)Definition TTree.h:509; TTree::fNotifyTObject * fNotifyObject to be notified when loading a Tree.Definition TTree.h:120; TTree::BranchImpvirtual TBranch * BranchImp(const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel)Same as TTree::Branch() with added check that addobj matches className.Definition TTree.cxx:1554; TTree::GetListOfClonesvirtual TList * GetListOfClones()Definition TTree.h:527; TTree::fCacheSizeLong64_t fCacheSize! Maximum size of file buffersDefinition TTree.h:105; TTree::fClonesTList * fClones! List of cloned trees which share our addressesDefinition TTree.h:135; TTree::fTotalBuffersstd::atomic< Long64_t > fTotalBuffers! Total number of bytes in branch buffersDefinition TTree.h:108; TTree::ELockStatusBitsELockStatusBitsDefinition TTree.h:211; TTree::kFindBranch@ kFindBranchDefinition TTree.h:212; TTree::kFindLeaf@ kFindLeafDefinition TTree.h:213; TTree::kGetEntryWithIndex@ kGetEntryWithIndexDefinition TTree.h:217; TTree::kPrint@ kPrintDefinition TTree.h:222; TTree::kGe",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:83732,Performance,cache,cache,83732,":kGetAlias@ kGetAliasDefinition TTree.h:214; TTree::GetV4virtual Double_t * GetV4()Definition TTree.h:582; TTree::BranchTBranch * Branch(const char *name, const char *classname, T *obj, Int_t bufsize=32000, Int_t splitlevel=99)Definition TTree.h:395; TTree::GetVar3TTreeFormula * GetVar3()Definition TTree.h:570; TTree::SetTreeIndexvirtual void SetTreeIndex(TVirtualIndex *index)The current TreeIndex is replaced by the new index.Definition TTree.cxx:9346; TTree::OptimizeBasketsvirtual void OptimizeBaskets(ULong64_t maxMemory=10000000, Float_t minComp=1.1, Option_t *option="""")This function may be called after having filled some entries in a Tree.Definition TTree.cxx:7057; TTree::Projectvirtual Long64_t Project(const char *hname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Make a projection of a tree using selections.Definition TTree.cxx:7498; TTree::SetCacheEntryRangevirtual Int_t SetCacheEntryRange(Long64_t first, Long64_t last)interface to TTreeCache to set the cache entry rangeDefinition TTree.cxx:8831; TTree::GetMaxTreeSizestatic Long64_t GetMaxTreeSize()Static function which returns the tree file size limit in bytes.Definition TTree.cxx:6265; TTree::fCacheDoClusterPrefetchbool fCacheDoClusterPrefetch! true if cache is prefetching whole clustersDefinition TTree.h:140; TTree::SetBranchAddressImpInt_t SetBranchAddressImp(TBranch *branch, void *addr, TBranch **ptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8445; TTree::SetAliasvirtual bool SetAlias(const char *aliasName, const char *aliasFormula)Set a tree variable alias.Definition TTree.cxx:8141; TTree::GetTimerIntervalvirtual Int_t GetTimerInterval() constDefinition TTree.h:554; TTree::CopyAddressesvirtual void CopyAddresses(TTree *, bool undo=false)Set branch addresses of passed tree equal to ours.Definition TTree.cxx:3299; TTree::SetScanFieldvirtual void SetScanField(Int_t n=50)Sets the default maximum numb",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:83988,Performance,cache,cache,83988,"nition TTree.h:570; TTree::SetTreeIndexvirtual void SetTreeIndex(TVirtualIndex *index)The current TreeIndex is replaced by the new index.Definition TTree.cxx:9346; TTree::OptimizeBasketsvirtual void OptimizeBaskets(ULong64_t maxMemory=10000000, Float_t minComp=1.1, Option_t *option="""")This function may be called after having filled some entries in a Tree.Definition TTree.cxx:7057; TTree::Projectvirtual Long64_t Project(const char *hname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Make a projection of a tree using selections.Definition TTree.cxx:7498; TTree::SetCacheEntryRangevirtual Int_t SetCacheEntryRange(Long64_t first, Long64_t last)interface to TTreeCache to set the cache entry rangeDefinition TTree.cxx:8831; TTree::GetMaxTreeSizestatic Long64_t GetMaxTreeSize()Static function which returns the tree file size limit in bytes.Definition TTree.cxx:6265; TTree::fCacheDoClusterPrefetchbool fCacheDoClusterPrefetch! true if cache is prefetching whole clustersDefinition TTree.h:140; TTree::SetBranchAddressImpInt_t SetBranchAddressImp(TBranch *branch, void *addr, TBranch **ptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8445; TTree::SetAliasvirtual bool SetAlias(const char *aliasName, const char *aliasFormula)Set a tree variable alias.Definition TTree.cxx:8141; TTree::GetTimerIntervalvirtual Int_t GetTimerInterval() constDefinition TTree.h:554; TTree::CopyAddressesvirtual void CopyAddresses(TTree *, bool undo=false)Set branch addresses of passed tree equal to ours.Definition TTree.cxx:3299; TTree::SetScanFieldvirtual void SetScanField(Int_t n=50)Sets the default maximum number of lines to be shown before <CR> when calling Scan().Definition TTree.h:691; TTree::TTreeTTree(const TTree &tt)=delete; TTree::fMaxEntriesLong64_t fMaxEntriesMaximum number of entries in case of circular buffers.Definition TTree.h:97; TTree::SetBranchAddressInt_t SetBranchAddress(const ch",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:89130,Performance,cache,cachesize,89130,"ion TTree.h:233; TTree::kMakeClass@ kMakeClassDefinition TTree.h:241; TTree::fgBranchStylestatic Int_t fgBranchStyleOld/New branch style.Definition TTree.h:154; TTree::ResetBranchAddressesvirtual void ResetBranchAddresses()Tell all of our branches to drop their current objects and allocate new ones.Definition TTree.cxx:8075; TTree::fNfillInt_t fNfill! Local for EntryLoopDefinition TTree.h:110; TTree::SetNamevoid SetName(const char *name) overrideChange the name of this tree.Definition TTree.cxx:9205; TTree::GetCacheSizevirtual Long64_t GetCacheSize() constDefinition TTree.h:453; TTree::RegisterExternalFriendvirtual void RegisterExternalFriend(TFriendElement *)Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is...Definition TTree.cxx:7957; TTree::fIndexTArrayI fIndexIndex of sorted values.Definition TTree.h:128; TTree::GetPacketSizevirtual Int_t GetPacketSize() constDefinition TTree.h:545; TTree::SetCacheSizevirtual Int_t SetCacheSize(Long64_t cachesize=-1)Set maximum size of the file cache .Definition TTree.cxx:8683; TTree::AddClonevoid AddClone(TTree *)Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when...Definition TTree.cxx:1219; TTree::CheckBranchAddressTypevirtual Int_t CheckBranchAddressType(TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr)Check whether or not the address described by the last 3 parameters matches the content of the branch...Definition TTree.cxx:2867; TTree::GetTransientBufferTBuffer * GetTransientBuffer(Int_t size)Returns the transient buffer currently used by this TTree for reading/writing baskets.Definition TTree.cxx:1037; TTree::GetIOFeaturesROOT::TIOFeatures GetIOFeatures() constReturns the current set of IO settings.Definition TTree.cxx:6074; TTree::MakeClassvirtual Int_t MakeClass(const char *classname=nullptr, Option_t *option="""")Generate a skeleton analysis class for this tree.Definition TTree.cxx:6607; TTree::GetFileNumbe",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:89172,Performance,cache,cache,89172,"ion TTree.h:233; TTree::kMakeClass@ kMakeClassDefinition TTree.h:241; TTree::fgBranchStylestatic Int_t fgBranchStyleOld/New branch style.Definition TTree.h:154; TTree::ResetBranchAddressesvirtual void ResetBranchAddresses()Tell all of our branches to drop their current objects and allocate new ones.Definition TTree.cxx:8075; TTree::fNfillInt_t fNfill! Local for EntryLoopDefinition TTree.h:110; TTree::SetNamevoid SetName(const char *name) overrideChange the name of this tree.Definition TTree.cxx:9205; TTree::GetCacheSizevirtual Long64_t GetCacheSize() constDefinition TTree.h:453; TTree::RegisterExternalFriendvirtual void RegisterExternalFriend(TFriendElement *)Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is...Definition TTree.cxx:7957; TTree::fIndexTArrayI fIndexIndex of sorted values.Definition TTree.h:128; TTree::GetPacketSizevirtual Int_t GetPacketSize() constDefinition TTree.h:545; TTree::SetCacheSizevirtual Int_t SetCacheSize(Long64_t cachesize=-1)Set maximum size of the file cache .Definition TTree.cxx:8683; TTree::AddClonevoid AddClone(TTree *)Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when...Definition TTree.cxx:1219; TTree::CheckBranchAddressTypevirtual Int_t CheckBranchAddressType(TBranch *branch, TClass *ptrClass, EDataType datatype, bool ptr)Check whether or not the address described by the last 3 parameters matches the content of the branch...Definition TTree.cxx:2867; TTree::GetTransientBufferTBuffer * GetTransientBuffer(Int_t size)Returns the transient buffer currently used by this TTree for reading/writing baskets.Definition TTree.cxx:1037; TTree::GetIOFeaturesROOT::TIOFeatures GetIOFeatures() constReturns the current set of IO settings.Definition TTree.cxx:6074; TTree::MakeClassvirtual Int_t MakeClass(const char *classname=nullptr, Option_t *option="""")Generate a skeleton analysis class for this tree.Definition TTree.cxx:6607; TTree::GetFileNumbe",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:92991,Performance,perform,performance,92991,"pyAddresses=false)Copy nentries from given tree to this tree.Definition TTree.cxx:3534; TTree::fMakeClassInt_t fMakeClass! not zero when processing code generated by MakeClassDefinition TTree.h:115; TTree::LoadBasketsvirtual Int_t LoadBaskets(Long64_t maxmemory=2000000000)Read in memory all baskets from all branches up to the limit of maxmemory bytes.Definition TTree.cxx:6451; TTree::kMaxEntriesstatic constexpr Long64_t kMaxEntriesDefinition TTree.h:229; TTree::PrincipalTPrincipal * Principal(const char *varexp="""", const char *selection="""", Option_t *option=""np"", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Interface to the Principal Components Analysis class.Definition TTree.cxx:7200; TTree::GetAutoFlushvirtual Long64_t GetAutoFlush() constDefinition TTree.h:447; TTree::GetMaxVirtualSizevirtual Long64_t GetMaxVirtualSize() constDefinition TTree.h:540; TVirtualIndexAbstract interface for Tree Index.Definition TVirtualIndex.h:30; TVirtualPerfStatsProvides the interface for the PROOF internal performance measurement and event tracing.Definition TVirtualPerfStats.h:32; TVirtualTreePlayerAbstract base class defining the interface for the plugins that implement Draw, Scan,...Definition TVirtualTreePlayer.h:38; TVirtualTreePlayer::GetVar1virtual TTreeFormula * GetVar1() const =0; TVirtualTreePlayer::GetV4virtual Double_t * GetV4() const =0; TVirtualTreePlayer::GetWvirtual Double_t * GetW() const =0; TVirtualTreePlayer::GetVar4virtual TTreeFormula * GetVar4() const =0; TVirtualTreePlayer::GetVarvirtual TTreeFormula * GetVar(Int_t) const =0; TVirtualTreePlayer::GetValvirtual Double_t * GetVal(Int_t) const =0; TVirtualTreePlayer::GetVar2virtual TTreeFormula * GetVar2() const =0; TVirtualTreePlayer::GetV1virtual Double_t * GetV1() const =0; TVirtualTreePlayer::kMaxEntriesstatic constexpr Long64_t kMaxEntriesDefinition TVirtualTreePlayer.h:45; TVirtualTreePlayer::GetVar3virtual TTreeFormula * GetVar3() const =0; TVirtualTreePlayer::GetV2virtual Double_t * GetV2() const ",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:12532,Safety,safe,safety,12532,"match = -2,; 237 kClassMismatch = -1,; 238 kMatch = 0,; 239 kMatchConversion = 1,; 240 kMatchConversionCollection = 2,; 241 kMakeClass = 3,; 242 kVoidPtr = 4,; 243 kNoCheck = 5,; 244 kNeedEnableDecomposedObj = BIT(29), // DecomposedObj is the newer name of MakeClass mode; 245 kNeedDisableDecomposedObj = BIT(30),; 246 kDecomposedObjMask = kNeedEnableDecomposedObj | kNeedDisableDecomposedObj; 247 };; 248 ; 249 // TTree status bits; 250 enum EStatusBits {; 251 kForceRead = BIT(11),; 252 kCircular = BIT(12),; 253 /// If set, the branch's buffers will grow until an event cluster boundary is hit,; 254 /// guaranteeing a basket per cluster. This mode does not provide any guarantee on the; 255 /// memory bounds in the case of extremely large events.; 256 kOnlyFlushAtCluster = BIT(14),; 257 /// If set, signals that this TTree is the output of the processing of another TTree, and; 258 /// the entries are reshuffled w.r.t. to the original TTree. As a safety measure, a TTree; 259 /// with this bit set cannot add friends nor can be added as a friend. If you know what; 260 /// you are doing, you can manually unset this bit with `ResetBit(EStatusBits::kEntriesReshuffled)`.; 261 kEntriesReshuffled = BIT(19) // bits 15-18 are used by TChain; 262 };; 263 ; 264 // Split level modifier; 265 enum {; 266 kSplitCollectionOfPointers = 100; 267 };; 268 ; 269 class TClusterIterator; 270 {; 271 private:; 272 TTree *fTree; // TTree upon which we are iterating.; 273 Int_t fClusterRange; // Which cluster range are we looking at.; 274 Long64_t fStartEntry; // Where does the cluster start.; 275 Long64_t fNextEntry; // Where does the cluster end (exclusive).; 276 Long64_t fEstimatedSize; // If positive, the calculated estimated tree size.; 277 ; 278 Long64_t GetEstimatedClusterSize();; 279 ; 280 protected:; 281 friend class TTree;; 282 TClusterIterator(TTree *tree, Long64_t firstEntry);; 283 ; 284 public:; 285 // Intentionally used the default copy constructor and default destructor; 286 // as the T",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:15336,Safety,safe,safe,15336,"o the next cluster and return the starting entry; 294 // of this next cluster; 295 Long64_t Next();; 296 ; 297 // Move on to the previous cluster and return the starting entry; 298 // of this previous cluster; 299 Long64_t Previous();; 300 ; 301 // Return the start entry of the current cluster.; 302 Long64_t GetStartEntry() {; 303 return fStartEntry;; 304 }; 305 ; 306 // Return the first entry of the next cluster.; 307 Long64_t GetNextEntry() {; 308 return fNextEntry;; 309 }; 310 ; 311 Long64_t operator()() { return Next(); }; 312 };; 313 ; 314 TTree();; 315 TTree(const char* name, const char* title, Int_t splitlevel = 99, TDirectory* dir = gDirectory);; 316 ~TTree() override;; 317 ; 318 TTree(const TTree& tt) = delete;; 319 TTree& operator=(const TTree& tt) = delete;; 320 ; 321 virtual Int_t AddBranchToCache(const char *bname, bool subbranches = false);; 322 virtual Int_t AddBranchToCache(TBranch *branch, bool subbranches = false);; 323 virtual Int_t DropBranchFromCache(const char *bname, bool subbranches = false);; 324 virtual Int_t DropBranchFromCache(TBranch *branch, bool subbranches = false);; 325 void AddClone(TTree*);; 326 virtual TFriendElement *AddFriend(const char* treename, const char* filename = """");; 327 virtual TFriendElement *AddFriend(const char* treename, TFile* file);; 328 virtual TFriendElement *AddFriend(TTree* tree, const char* alias = """", bool warn = false);; 329 // As the TBasket invokes Add{Tot,Zip}Bytes on its parent tree, we must do these updates in a thread-safe; 330 // manner only when we are flushing multiple baskets in parallel.; 331 virtual void AddTotBytes(Int_t tot) { if (fIMTFlush) { fIMTTotBytes += tot; } else { fTotBytes += tot; } }; 332 virtual void AddZipBytes(Int_t zip) { if (fIMTFlush) { fIMTZipBytes += zip; } else { fZipBytes += zip; } }; 333// NOTE: these counters aren't thread safe like the ones above.; 334#ifdef R__TRACK_BASKET_ALLOC_TIME; 335 void AddAllocationTime(ULong64_t time) { fAllocationTime += time; }; 336#endif; 3",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:15678,Safety,safe,safe,15678," 319 TTree& operator=(const TTree& tt) = delete;; 320 ; 321 virtual Int_t AddBranchToCache(const char *bname, bool subbranches = false);; 322 virtual Int_t AddBranchToCache(TBranch *branch, bool subbranches = false);; 323 virtual Int_t DropBranchFromCache(const char *bname, bool subbranches = false);; 324 virtual Int_t DropBranchFromCache(TBranch *branch, bool subbranches = false);; 325 void AddClone(TTree*);; 326 virtual TFriendElement *AddFriend(const char* treename, const char* filename = """");; 327 virtual TFriendElement *AddFriend(const char* treename, TFile* file);; 328 virtual TFriendElement *AddFriend(TTree* tree, const char* alias = """", bool warn = false);; 329 // As the TBasket invokes Add{Tot,Zip}Bytes on its parent tree, we must do these updates in a thread-safe; 330 // manner only when we are flushing multiple baskets in parallel.; 331 virtual void AddTotBytes(Int_t tot) { if (fIMTFlush) { fIMTTotBytes += tot; } else { fTotBytes += tot; } }; 332 virtual void AddZipBytes(Int_t zip) { if (fIMTFlush) { fIMTZipBytes += zip; } else { fZipBytes += zip; } }; 333// NOTE: these counters aren't thread safe like the ones above.; 334#ifdef R__TRACK_BASKET_ALLOC_TIME; 335 void AddAllocationTime(ULong64_t time) { fAllocationTime += time; }; 336#endif; 337 void AddAllocationCount(UInt_t count) { fAllocationCount += count; }; 338 virtual Long64_t AutoSave(Option_t* option = """");; 339 ; 340 /// Add a new branch, and infer the data type from the type of `obj` being passed.; 341 ///; 342 /// \note This and the next overload should cover most cases for creating a branch. Try to use these two whenever; 343 /// possible, unless e.g. type conversions are needed.; 344 ///; 345 /// \param[in] name Name of the branch to be created.; 346 /// \param[in] obj Address of the object to be added. Make sure to pass a pointer to the actual type/class that; 347 /// should be stored in the tree (no pointers to base classes). When calling Fill(), the current value of the type/object will be ",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:19361,Safety,avoid,avoid,19361,"h. When the buffer is full, it is compressed and written to disc.; 366 /// The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes).; 367 /// A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode.; 368 /// \param[in] splitlevel If T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches.; 369 /// \return Pointer to the TBranch that was created. The branch is owned by the tree.; 370 template <class T> TBranch *Branch(const char* name, T** addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); 371 {; 372 return BranchImp(name, TClass::GetClass<T>(), addobj, bufsize, splitlevel);; 373 }; 374 ; 375 virtual Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """");; 376 virtual Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99);; 377 virtual Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99);; 378 virtual TBranch *Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000);; 379 TBranch *Branch(const char* name, char* address, const char* leaflist, Int_t bufsize = 32000); 380 {; 381 // Overload to avoid confusion between this signature and the template instance.; 382 return Branch(name,(void*)address,leaflist,bufsize);; 383 }; 384 TBranch *Branch(const char* name, Longptr_t address, const char* leaflist, Int_t bufsize = 32000); 385 {; 386 // Overload to avoid confusion between this signature and the template instance.; 387 return Branch(name,(void*)address,leaflist,bufsize);; 388 }; 389 TBranch *Branch(const char* name, int address, const char* leaflist, Int_t bufsize = 32000); 390 {; 391 // Overload to avoid confusion between this signature and the template instance.; 392 return Branch(name,(void*)(Longptr_t)address,leaflist,bufsize);; 393 }; 3",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:19622,Safety,avoid,avoid,19622," TBranch that was created. The branch is owned by the tree.; 370 template <class T> TBranch *Branch(const char* name, T** addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); 371 {; 372 return BranchImp(name, TClass::GetClass<T>(), addobj, bufsize, splitlevel);; 373 }; 374 ; 375 virtual Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """");; 376 virtual Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99);; 377 virtual Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99);; 378 virtual TBranch *Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000);; 379 TBranch *Branch(const char* name, char* address, const char* leaflist, Int_t bufsize = 32000); 380 {; 381 // Overload to avoid confusion between this signature and the template instance.; 382 return Branch(name,(void*)address,leaflist,bufsize);; 383 }; 384 TBranch *Branch(const char* name, Longptr_t address, const char* leaflist, Int_t bufsize = 32000); 385 {; 386 // Overload to avoid confusion between this signature and the template instance.; 387 return Branch(name,(void*)address,leaflist,bufsize);; 388 }; 389 TBranch *Branch(const char* name, int address, const char* leaflist, Int_t bufsize = 32000); 390 {; 391 // Overload to avoid confusion between this signature and the template instance.; 392 return Branch(name,(void*)(Longptr_t)address,leaflist,bufsize);; 393 }; 394 virtual TBranch *Branch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99);; 395 template <class T> TBranch *Branch(const char* name, const char* classname, T* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); 396 {; 397 // See BranchImpRed for details. Here we __ignore; 398 return BranchImpRef(name, classname, TClass::GetClass<T>(), obj, bufsize, splitlevel);; 399 }; 400 template <class T> TBranch *Branch(const char* name, const char* classname, T** addobj, Int_t bufsize = 32",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:19877,Safety,avoid,avoid,19877,"vel);; 373 }; 374 ; 375 virtual Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """");; 376 virtual Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99);; 377 virtual Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99);; 378 virtual TBranch *Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000);; 379 TBranch *Branch(const char* name, char* address, const char* leaflist, Int_t bufsize = 32000); 380 {; 381 // Overload to avoid confusion between this signature and the template instance.; 382 return Branch(name,(void*)address,leaflist,bufsize);; 383 }; 384 TBranch *Branch(const char* name, Longptr_t address, const char* leaflist, Int_t bufsize = 32000); 385 {; 386 // Overload to avoid confusion between this signature and the template instance.; 387 return Branch(name,(void*)address,leaflist,bufsize);; 388 }; 389 TBranch *Branch(const char* name, int address, const char* leaflist, Int_t bufsize = 32000); 390 {; 391 // Overload to avoid confusion between this signature and the template instance.; 392 return Branch(name,(void*)(Longptr_t)address,leaflist,bufsize);; 393 }; 394 virtual TBranch *Branch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99);; 395 template <class T> TBranch *Branch(const char* name, const char* classname, T* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); 396 {; 397 // See BranchImpRed for details. Here we __ignore; 398 return BranchImpRef(name, classname, TClass::GetClass<T>(), obj, bufsize, splitlevel);; 399 }; 400 template <class T> TBranch *Branch(const char* name, const char* classname, T** addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); 401 {; 402 // See BranchImp for details; 403 return BranchImp(name, classname, TClass::GetClass<T>(), addobj, bufsize, splitlevel);; 404 }; 405 template <typename T, std::size_t N> TBranch *Branch(const char* name, std::array<T, ",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:25045,Safety,avoid,avoid,25045,"4_t GetChainEntryNumber(Long64_t entry) const { return entry; }; 456 virtual Long64_t GetChainOffset() const { return fChainOffset; }; 457 virtual bool GetClusterPrefetch() const { return fCacheDoClusterPrefetch; }; 458 TFile *GetCurrentFile() const;; 459 Int_t GetDefaultEntryOffsetLen() const {return fDefaultEntryOffsetLen;}; 460 Long64_t GetDebugMax() const { return fDebugMax; }; 461 Long64_t GetDebugMin() const { return fDebugMin; }; 462 TDirectory *GetDirectory() const { return fDirectory; }; 463 virtual Long64_t GetEntries() const { return fEntries; }; 464 virtual Long64_t GetEntries(const char *selection);; 465 /// Return a number greater or equal to the total number of entries in the; 466 /// dataset.; 467 ///; 468 /// \note If you are interested in the total number of entries in a TChain,; 469 /// this function will give that number once the last file of the chain; 470 /// is opened. In general, using this instead of GetEntries will avoid; 471 /// opening all files in the chain which could be very costly for very; 472 /// large number of files stored at a remote location.; 473 ///; 474 /// The logic depends on whether the dataset is a TTree or a TChain. In the; 475 /// first case, it simply returns the total number of entries in the tree. In; 476 /// the latter case, it depends on which point of the processing of the chain; 477 /// this function is called. During most of the chain processing, this; 478 /// function will return TTree::kMaxEntries. When the chain arrives at the; 479 /// last file, then the function will return the accumulated total number of; 480 /// entries in the whole chain. A notable use case where this function; 481 /// becomes quite useful is when writing the following for loop to traverse; 482 /// the entries in the dataset:; 483 ///; 484 /// \code{.cpp}; 485 /// for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; 486 /// // Do something with the event in the dataset; 487 /// }; 488 /// \endcode; 489 ///; 490 /// In",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:67847,Safety,recover,recover,67847,"nst char *bname, T *add, TBranch **ptr=nullptr)Definition TTree.h:637; TTree::SetTargetMemoryRatiovoid SetTargetMemoryRatio(Float_t ratio)Definition TTree.h:692; TTree::fEntryListTEntryList * fEntryList! Pointer to event selection list (if one)Definition TTree.h:126; TTree::GetTreeIndexvirtual TVirtualIndex * GetTreeIndex() constDefinition TTree.h:558; TTree::DebugInt_t Debug() constDefinition TTree.h:429; TTree::fExternalFriendsTList * fExternalFriends! List of TFriendsElement pointing to us and need to be notified of LoadTree. Content not owned.Definition TTree.h:131; TTree::Mergevirtual Long64_t Merge(TCollection *list, Option_t *option="""")Merge the trees in the TList into this tree.Definition TTree.cxx:6890; TTree::SetMaxVirtualSizevirtual void SetMaxVirtualSize(Long64_t size=0)Definition TTree.h:665; TTree::DropBasketsvirtual void DropBaskets()Remove some baskets from memory.Definition TTree.cxx:4518; TTree::SetAutoSavevirtual void SetAutoSave(Long64_t autos=-300000000)In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSa...Definition TTree.cxx:8342; TTree::GetClusterPrefetchvirtual bool GetClusterPrefetch() constDefinition TTree.h:457; TTree::BranchTBranch * Branch(const char *name, const char *classname, T **addobj, Int_t bufsize=32000, Int_t splitlevel=99)Definition TTree.h:400; TTree::fMaxEntryLoopLong64_t fMaxEntryLoopMaximum number of entries to process.Definition TTree.h:98; TTree::TTreeBranchImpReffriend TBranch * TTreeBranchImpRef(TTree *tree, const char *branchname, TClass *ptrClass, EDataType datatype, void *addobj, Int_t bufsize, Int_t splitlevel); TTree::GetTargetMemoryRatioFloat_t GetTargetMemoryRatio() constDefinition TTree.h:560; TTree::SetParallelUnzipvirtual void SetParallelUnzip(bool opt=true, Float_t RelSize=-1)Enable or disable parallel unzipping of Tree buffers.Definition TTree.cxx:9291; TTree::SetDirectoryvirtual void SetDirectory(TDirectory *dir)Change the tree's directory.Definition TTree.c",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:69734,Safety,detect,detection,69734,"lel unzipping of Tree buffers.Definition TTree.cxx:9291; TTree::SetDirectoryvirtual void SetDirectory(TDirectory *dir)Change the tree's directory.Definition TTree.cxx:8966; TTree::SortBranchesByTimevoid SortBranchesByTime()Sorts top-level branches by the last average task time recorded per branch.Definition TTree.cxx:5834; TTree::Deletevoid Delete(Option_t *option="""") overrideDelete this tree from memory or/and disk.Definition TTree.cxx:3747; TTree::GetIndexvirtual Int_t * GetIndex()Definition TTree.h:521; TTree::GetBranchRefvirtual TBranchRef * GetBranchRef() constDefinition TTree.h:450; TTree::GetV3virtual Double_t * GetV3()Definition TTree.h:580; TTree::Processvirtual Long64_t Process(const char *filename, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Process this tree executing the TSelector code in the specified filename.Definition TTree.cxx:7450; TTree::BranchImpRefvirtual TBranch * BranchImpRef(const char *branchname, const char *classname, TClass *ptrClass, void *addobj, Int_t bufsize, Int_t splitlevel)Same as TTree::Branch but automatic detection of the class name.Definition TTree.cxx:1635; TTree::SetEventListvirtual void SetEventList(TEventList *list)This function transfroms the given TEventList into a TEntryList The new TEntryList is owned by the TT...Definition TTree.cxx:9069; TTree::BranchTBranch * Branch(const char *name, int address, const char *leaflist, Int_t bufsize=32000)Definition TTree.h:389; TTree::MoveReadCachevoid MoveReadCache(TFile *src, TDirectory *dir)Move a cache from a file to the current file in dir.Definition TTree.cxx:6983; TTree::operator=TTree & operator=(const TTree &tt)=delete; TTree::fAutoFlushLong64_t fAutoFlushAuto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced.Definition TTree.h:101; TTree::fUpdateInt_t fUpdateUpdate frequency for EntryLoop.Definition TTree.h:93; TTree::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Resets the state of this TTree ",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:10738,Security,access,access,10738,"tNewlineValue(std::istream &inputStream);; 184 void ImportClusterRanges(TTree *fromtree);; 185 void MoveReadCache(TFile *src, TDirectory *dir);; 186 Int_t SetCacheSizeAux(bool autocache = true, Long64_t cacheSize = 0);; 187 ; 188 class TFriendLock {; 189 // Helper class to prevent infinite recursion in the; 190 // usage of TTree Friends. Implemented in TTree.cxx.; 191 TTree *fTree; // Pointer to the locked tree; 192 UInt_t fMethodBit; // BIT for the locked method; 193 bool fPrevious; // Previous value of the BIT.; 194 ; 195 protected:; 196 TFriendLock(const TFriendLock&);; 197 TFriendLock& operator=(const TFriendLock&);; 198 ; 199 public:; 200 TFriendLock(TTree* tree, UInt_t methodbit);; 201 ~TFriendLock();; 202 };; 203 friend class TFriendLock;; 204 // So that the index class can use TFriendLock:; 205 friend class TTreeIndex;; 206 friend class TChainIndex;; 207 // So that the TTreeCloner can access the protected interfaces; 208 friend class TTreeCloner;; 209 ; 210 // use to update fFriendLockStatus; 211 enum ELockStatusBits {; 212 kFindBranch = BIT(0),; 213 kFindLeaf = BIT(1),; 214 kGetAlias = BIT(2),; 215 kGetBranch = BIT(3),; 216 kGetEntry = BIT(4),; 217 kGetEntryWithIndex = BIT(5),; 218 kGetFriend = BIT(6),; 219 kGetFriendAlias = BIT(7),; 220 kGetLeaf = BIT(8),; 221 kLoadTree = BIT(9),; 222 kPrint = BIT(10),; 223 kRemoveFriend = BIT(11),; 224 kSetBranchStatus = BIT(12); 225 };; 226 ; 227public:; 228 // Used as the max value for any TTree range operation.; 229 static constexpr Long64_t kMaxEntries = TVirtualTreePlayer::kMaxEntries;; 230 ; 231 // SetBranchAddress return values; 232 enum ESetBranchAddressStatus {; 233 kMissingBranch = -5,; 234 kInternalError = -4,; 235 kMissingCompiledCollectionProxy = -3,; 236 kMismatch = -2,; 237 kClassMismatch = -1,; 238 kMatch = 0,; 239 kMatchConversion = 1,; 240 kMatchConversionCollection = 2,; 241 kMakeClass = 3,; 242 kVoidPtr = 4,; 243 kNoCheck = 5,; 244 kNeedEnableDecomposedObj = BIT(29), // DecomposedObj is the newer name ",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:16947,Security,access,accessed,16947,"ption_t* option = """");; 339 ; 340 /// Add a new branch, and infer the data type from the type of `obj` being passed.; 341 ///; 342 /// \note This and the next overload should cover most cases for creating a branch. Try to use these two whenever; 343 /// possible, unless e.g. type conversions are needed.; 344 ///; 345 /// \param[in] name Name of the branch to be created.; 346 /// \param[in] obj Address of the object to be added. Make sure to pass a pointer to the actual type/class that; 347 /// should be stored in the tree (no pointers to base classes). When calling Fill(), the current value of the type/object will be saved.; 348 /// \param[in] bufsize The buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc.; 349 /// The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes).; 350 /// A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode.; 351 /// \param[in] splitlevel If T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches.; 352 /// \return Pointer to the TBranch that was created. The branch is owned by the tree.; 353 template <class T> TBranch *Branch(const char* name, T* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); 354 {; 355 return BranchImpRef(name, TClass::GetClass<T>(), TDataType::GetType(typeid(T)), obj, bufsize, splitlevel);; 356 }; 357 ; 358 /// Add a new branch, and infer the data type from the array `addobj` being passed.; 359 ///; 360 /// \note This and the previous overload should cover most cases for creating a branch. Try to use these two whenever; 361 /// possible, unless e.g. type conversions are needed.; 362 ///; 363 /// \param[in] name Name of the branch to be created.; 364 /// \param[in] addobj Array of the objects to be added. When calling Fill(), the current value of the type/o",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:18336,Security,access,accessed,18336," splitlevel = 99); 354 {; 355 return BranchImpRef(name, TClass::GetClass<T>(), TDataType::GetType(typeid(T)), obj, bufsize, splitlevel);; 356 }; 357 ; 358 /// Add a new branch, and infer the data type from the array `addobj` being passed.; 359 ///; 360 /// \note This and the previous overload should cover most cases for creating a branch. Try to use these two whenever; 361 /// possible, unless e.g. type conversions are needed.; 362 ///; 363 /// \param[in] name Name of the branch to be created.; 364 /// \param[in] addobj Array of the objects to be added. When calling Fill(), the current value of the type/object will be saved.; 365 /// \param[in] bufsize he buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc.; 366 /// The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes).; 367 /// A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode.; 368 /// \param[in] splitlevel If T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches.; 369 /// \return Pointer to the TBranch that was created. The branch is owned by the tree.; 370 template <class T> TBranch *Branch(const char* name, T** addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); 371 {; 372 return BranchImp(name, TClass::GetClass<T>(), addobj, bufsize, splitlevel);; 373 }; 374 ; 375 virtual Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """");; 376 virtual Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99);; 377 virtual Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99);; 378 virtual TBranch *Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000);; 379 TBranch *Branch(const char* name, char* address, const char* leaflist, Int_t bufsi",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:25209,Testability,log,logic,25209,"7 virtual bool GetClusterPrefetch() const { return fCacheDoClusterPrefetch; }; 458 TFile *GetCurrentFile() const;; 459 Int_t GetDefaultEntryOffsetLen() const {return fDefaultEntryOffsetLen;}; 460 Long64_t GetDebugMax() const { return fDebugMax; }; 461 Long64_t GetDebugMin() const { return fDebugMin; }; 462 TDirectory *GetDirectory() const { return fDirectory; }; 463 virtual Long64_t GetEntries() const { return fEntries; }; 464 virtual Long64_t GetEntries(const char *selection);; 465 /// Return a number greater or equal to the total number of entries in the; 466 /// dataset.; 467 ///; 468 /// \note If you are interested in the total number of entries in a TChain,; 469 /// this function will give that number once the last file of the chain; 470 /// is opened. In general, using this instead of GetEntries will avoid; 471 /// opening all files in the chain which could be very costly for very; 472 /// large number of files stored at a remote location.; 473 ///; 474 /// The logic depends on whether the dataset is a TTree or a TChain. In the; 475 /// first case, it simply returns the total number of entries in the tree. In; 476 /// the latter case, it depends on which point of the processing of the chain; 477 /// this function is called. During most of the chain processing, this; 478 /// function will return TTree::kMaxEntries. When the chain arrives at the; 479 /// last file, then the function will return the accumulated total number of; 480 /// entries in the whole chain. A notable use case where this function; 481 /// becomes quite useful is when writing the following for loop to traverse; 482 /// the entries in the dataset:; 483 ///; 484 /// \code{.cpp}; 485 /// for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; 486 /// // Do something with the event in the dataset; 487 /// }; 488 /// \endcode; 489 ///; 490 /// In the example above, independently on whether the dataset is a TTree or; 491 /// a TChain, the GetEntriesFast call will provide the correct",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:7876,Usability,simpl,simplicity,7876,"nt_t fNEntriesSinceSorting; ///<! Number of entries processed since the last re-sorting of branches; 144 std::vector<std::pair<Long64_t,TBranch*>> fSortedBranches; ///<! Branches to be processed in parallel when IMT is on, sorted by average task time; 145 std::vector<TBranch*> fSeqBranches; ///<! Branches to be processed sequentially when IMT is on; 146 Float_t fTargetMemoryRatio{1.1f}; ///<! Ratio for memory usage in uncompressed buffers versus actual occupancy. 1.0; 147 /// indicates basket should be resized to exact memory usage, but causes significant; 148/// memory churn.; 149#ifdef R__TRACK_BASKET_ALLOC_TIME; 150 mutable std::atomic<ULong64_t> fAllocationTime{0}; ///<! Time spent reallocating basket memory buffers, in microseconds.; 151#endif; 152 mutable std::atomic<UInt_t> fAllocationCount{0}; ///<! Number of reallocations basket memory buffers.; 153 ; 154 static Int_t fgBranchStyle; ///< Old/New branch style; 155 static Long64_t fgMaxTreeSize; ///< Maximum size of a file containing a Tree; 156 ; 157private:; 158 // For simplicity, although fIMTFlush is always disabled in non-IMT builds, we don't #ifdef it out.; 159 mutable bool fIMTFlush{false}; ///<! True if we are doing a multithreaded flush.; 160 mutable std::atomic<Long64_t> fIMTTotBytes; ///<! Total bytes for the IMT flush baskets; 161 mutable std::atomic<Long64_t> fIMTZipBytes; ///<! Zip bytes for the IMT flush baskets.; 162 ; 163 void InitializeBranchLists(bool checkLeafCount);; 164 void SortBranchesByTime();; 165 Int_t FlushBasketsImpl() const;; 166 void MarkEventCluster();; 167 Long64_t GetMedianClusterSize();; 168 ; 169protected:; 170 virtual void KeepCircular();; 171 virtual TBranch *BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel);; 172 virtual TBranch *BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel);; 173 virtual TBranch *BranchImpRef(const char* branchname, const char* cla",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:16765,Usability,simpl,simple,16765,"TIME; 335 void AddAllocationTime(ULong64_t time) { fAllocationTime += time; }; 336#endif; 337 void AddAllocationCount(UInt_t count) { fAllocationCount += count; }; 338 virtual Long64_t AutoSave(Option_t* option = """");; 339 ; 340 /// Add a new branch, and infer the data type from the type of `obj` being passed.; 341 ///; 342 /// \note This and the next overload should cover most cases for creating a branch. Try to use these two whenever; 343 /// possible, unless e.g. type conversions are needed.; 344 ///; 345 /// \param[in] name Name of the branch to be created.; 346 /// \param[in] obj Address of the object to be added. Make sure to pass a pointer to the actual type/class that; 347 /// should be stored in the tree (no pointers to base classes). When calling Fill(), the current value of the type/object will be saved.; 348 /// \param[in] bufsize The buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc.; 349 /// The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes).; 350 /// A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode.; 351 /// \param[in] splitlevel If T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches.; 352 /// \return Pointer to the TBranch that was created. The branch is owned by the tree.; 353 template <class T> TBranch *Branch(const char* name, T* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); 354 {; 355 return BranchImpRef(name, TClass::GetClass<T>(), TDataType::GetType(typeid(T)), obj, bufsize, splitlevel);; 356 }; 357 ; 358 /// Add a new branch, and infer the data type from the array `addobj` being passed.; 359 ///; 360 /// \note This and the previous overload should cover most cases for creating a branch. Try to use these two whenever; 361 /// possible, unless e.g. type conversio",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:18154,Usability,simpl,simple,18154,"branches.; 352 /// \return Pointer to the TBranch that was created. The branch is owned by the tree.; 353 template <class T> TBranch *Branch(const char* name, T* obj, Int_t bufsize = 32000, Int_t splitlevel = 99); 354 {; 355 return BranchImpRef(name, TClass::GetClass<T>(), TDataType::GetType(typeid(T)), obj, bufsize, splitlevel);; 356 }; 357 ; 358 /// Add a new branch, and infer the data type from the array `addobj` being passed.; 359 ///; 360 /// \note This and the previous overload should cover most cases for creating a branch. Try to use these two whenever; 361 /// possible, unless e.g. type conversions are needed.; 362 ///; 363 /// \param[in] name Name of the branch to be created.; 364 /// \param[in] addobj Array of the objects to be added. When calling Fill(), the current value of the type/object will be saved.; 365 /// \param[in] bufsize he buffer size in bytes for this branch. When the buffer is full, it is compressed and written to disc.; 366 /// The default value of 32000 bytes and should be ok for most simple types. Larger buffers (e.g. 256000) if your Tree is not split and each entry is large (Megabytes).; 367 /// A small value for bufsize is beneficial if entries in the Tree are accessed randomly and the Tree is in split mode.; 368 /// \param[in] splitlevel If T is a class or struct and splitlevel > 0, the members of the object are serialised as separate branches.; 369 /// \return Pointer to the TBranch that was created. The branch is owned by the tree.; 370 template <class T> TBranch *Branch(const char* name, T** addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); 371 {; 372 return BranchImp(name, TClass::GetClass<T>(), addobj, bufsize, splitlevel);; 373 }; 374 ; 375 virtual Int_t Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """");; 376 virtual Int_t Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99);; 377 virtual Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99);",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:21963,Usability,undo,undo,21963,"Class<std::array<T, N>>();; 410 Error(""Branch"",""std::array of objects not yet supported as top level branch object (the class is %s)"",; 411 arrCl ? arrCl->GetName() : cl->GetName());; 412 return nullptr;; 413 }; 414 return BranchImpArr(name, TDataType::GetType(typeid(T)), N, obj, bufsize, splitlevel);; 415 }; 416 virtual TBranch *Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99);; 417 virtual TBranch *BranchOld(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1);; 418 virtual TBranch *BranchRef();; 419 void Browse(TBrowser*) override;; 420 virtual Int_t BuildIndex(const char *majorname, const char *minorname = ""0"");; 421 TStreamerInfo *BuildStreamerInfo(TClass* cl, void *pointer = nullptr, bool canOptimize = true);; 422 virtual TFile *ChangeFile(TFile* file);; 423 virtual TTree *CloneTree(Long64_t nentries = -1, Option_t* option = """");; 424 virtual void CopyAddresses(TTree*,bool undo = false);; 425 virtual Long64_t CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t *option = """", bool needCopyAddresses = false);; 426 virtual TTree *CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = kMaxEntries, Long64_t firstentry = 0);; 427 virtual TBasket *CreateBasket(TBranch*);; 428 virtual void DirectoryAutoAdd(TDirectory *);; 429 Int_t Debug() const { return fDebug; }; 430 void Delete(Option_t* option = """") override; // *MENU*; 431 void Draw(Option_t* opt) override { Draw(opt, """", """", kMaxEntries, 0); }; 432 virtual Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = kMaxEntries, Long64_t firstentry = 0);; 433 virtual Long64_t Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = kMaxEntries, Long64_t firstentry = 0); // *MENU*; 434 virtual void DropBaskets();; 435 virtual void DropBuffers(Int_t nbytes);; 436 bool EnableCache();; 437 virtual Int_t Fill();; 438 ",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:25301,Usability,simpl,simply,25301,"ile *GetCurrentFile() const;; 459 Int_t GetDefaultEntryOffsetLen() const {return fDefaultEntryOffsetLen;}; 460 Long64_t GetDebugMax() const { return fDebugMax; }; 461 Long64_t GetDebugMin() const { return fDebugMin; }; 462 TDirectory *GetDirectory() const { return fDirectory; }; 463 virtual Long64_t GetEntries() const { return fEntries; }; 464 virtual Long64_t GetEntries(const char *selection);; 465 /// Return a number greater or equal to the total number of entries in the; 466 /// dataset.; 467 ///; 468 /// \note If you are interested in the total number of entries in a TChain,; 469 /// this function will give that number once the last file of the chain; 470 /// is opened. In general, using this instead of GetEntries will avoid; 471 /// opening all files in the chain which could be very costly for very; 472 /// large number of files stored at a remote location.; 473 ///; 474 /// The logic depends on whether the dataset is a TTree or a TChain. In the; 475 /// first case, it simply returns the total number of entries in the tree. In; 476 /// the latter case, it depends on which point of the processing of the chain; 477 /// this function is called. During most of the chain processing, this; 478 /// function will return TTree::kMaxEntries. When the chain arrives at the; 479 /// last file, then the function will return the accumulated total number of; 480 /// entries in the whole chain. A notable use case where this function; 481 /// becomes quite useful is when writing the following for loop to traverse; 482 /// the entries in the dataset:; 483 ///; 484 /// \code{.cpp}; 485 /// for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; 486 /// // Do something with the event in the dataset; 487 /// }; 488 /// \endcode; 489 ///; 490 /// In the example above, independently on whether the dataset is a TTree or; 491 /// a TChain, the GetEntriesFast call will provide the correct stopping; 492 /// condition for the loop (i.e. the total number of entries). In the ",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:56085,Usability,learn,learning,56085,"he 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6098; TTree::fTotBytesLong64_t fTotBytesTotal number of bytes in all branches before compression.Definition TTree.h:86; TTree::FlushBasketsvirtual Int_t FlushBaskets(bool create_cluster=true) constWrite to disk all the basket that have not yet been individually written and create an event cluster ...Definition TTree.cxx:5129; TTree::GetDefaultEntryOffsetLenInt_t GetDefaultEntryOffsetLen() constDefinition TTree.h:459; TTree::fMaxClusterRangeInt_t fMaxClusterRange! Memory allocated for the cluster range.Definition TTree.h:96; TTree::Showvirtual void Show(Long64_t entry=-1, Int_t lenmax=20)Print values of all active leaves for entry.Definition TTree.cxx:9385; TTree::fEventListTEventList * fEventList! Pointer to event selection list (if one)Definition TTree.h:125; TTree::GetAutoSavevirtual Long64_t GetAutoSave() constDefinition TTree.h:448; TTree::StopCacheLearningPhasevirtual Int_t StopCacheLearningPhase()Stop the cache learning phase.Definition TTree.cxx:9474; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::fSortedBranchesstd::vector< std::pair< Long64_t, TBranch * > > fSortedBranches! Branches to be processed in parallel when IMT is on, sorted by average task timeDefinition TTree.h:144; TTree::SetCircularvirtual void SetCircular(Long64_t maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTree::GetEstimatevirtual Long64_t GetEstimate() constDefinition TTree.h:507; TTree::GetDebugMaxLong64_t GetDebugMax() constDefinition TTree.h:460; TTree::fSavedBytesLong64_t fSavedBytesNumber of autosaved bytes.Definition TTree.h:88; TTree::AddBranchToCachevirtual Int_t AddBranchToCache(const char *bname, bool subbranches=false)Add branch with name bname to the Tree cache.Definition TTree.cxx:1059; TTree::GetMedianClusterSizeLong64_t",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:61696,Usability,simpl,simply,61696,"ke sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree.Definition TTree.cxx:7881; TTree::GetPlayerTVirtualTreePlayer * GetPlayer()Load the TTreePlayer (if not already done).Definition TTree.cxx:6305; TTree::MakeProxyvirtual Int_t MakeProxy(const char *classname, const char *macrofilename=nullptr, const char *cutfilename=nullptr, const char *option=nullptr, Int_t maxUnrolling=3)Generate a skeleton analysis class for this Tree using TBranchProxy.Definition TTree.cxx:6768; TTree::kSplitCollectionOfPointers@ kSplitCollectionOfPointersDefinition TTree.h:266; TTree::fTargetMemoryRatioFloat_t fTargetMemoryRatio! Ratio for memory usage in uncompressed buffers versus actual occupancy.Definition TTree.h:146; TTree::GetIndexValuesvirtual Double_t * GetIndexValues()Definition TTree.h:522; TTree::GetListOfAliasesvirtual TList * GetListOfAliases() constDefinition TTree.h:531; TTree::ReadStreamvirtual Long64_t ReadStream(std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ')Create or simply read branches from an input stream.Definition TTree.cxx:7615; TTree::SetDebugvirtual void SetDebug(Int_t level=1, Long64_t min=0, Long64_t max=9999999)Set the debug level and the debug range.Definition TTree.cxx:8928; TTree::fScanFieldInt_t fScanFieldNumber of runs before prompting in Scan.Definition TTree.h:92; TTree::GetWeightvirtual Double_t GetWeight() constDefinition TTree.h:584; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; TTree::GetFriendvirtual TTree * GetFriend(const char *) constReturn a pointer to the TTree friend whose name or alias is friendname.Definition TTree.cxx:5975; TTree::GetVarTTreeFormula * GetVar(Int_t i)Definition TTree.h:564; TTree::SetNotifyvirtual void SetNotify(TObject *obj)Sets the address of the object to be notified when the tree is loaded.Definition TTree.cxx:9231; TTree::GetMaximumvirtual Double_t GetMaximum(const char *columname)Return max",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:66717,Usability,learn,learning,66717,"ree.cxx:9374; TTree::InitializeBranchListsvoid InitializeBranchLists(bool checkLeafCount)Divides the top-level branches into two vectors: (i) branches to be processed sequentially and (ii) b...Definition TTree.cxx:5781; TTree::SetBranchAddressvirtual Int_t SetBranchAddress(const char *bname, void *add, TBranch **ptr=nullptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8385; TTree::fClusterSizeLong64_t * fClusterSize[fNClusterRange] Number of entries in each cluster for a given range.Definition TTree.h:104; TTree::fFlushedBytesLong64_t fFlushedBytesNumber of auto-flushed bytes.Definition TTree.h:89; TTree::SetPerfStatsvirtual void SetPerfStats(TVirtualPerfStats *perf)Set perf stats.Definition TTree.cxx:9329; TTree::GetVar2TTreeFormula * GetVar2()Definition TTree.h:568; TTree::fIMTTotBytesstd::atomic< Long64_t > fIMTTotBytes! Total bytes for the IMT flush basketsDefinition TTree.h:160; TTree::SetCacheLearnEntriesvirtual void SetCacheLearnEntries(Int_t n=10)Interface to TTreeCache to set the number of entries for the learning phase.Definition TTree.cxx:8865; TTree::SetBranchAddressInt_t SetBranchAddress(const char *bname, T *add, TBranch **ptr=nullptr)Definition TTree.h:637; TTree::SetTargetMemoryRatiovoid SetTargetMemoryRatio(Float_t ratio)Definition TTree.h:692; TTree::fEntryListTEntryList * fEntryList! Pointer to event selection list (if one)Definition TTree.h:126; TTree::GetTreeIndexvirtual TVirtualIndex * GetTreeIndex() constDefinition TTree.h:558; TTree::DebugInt_t Debug() constDefinition TTree.h:429; TTree::fExternalFriendsTList * fExternalFriends! List of TFriendsElement pointing to us and need to be notified of LoadTree. Content not owned.Definition TTree.h:131; TTree::Mergevirtual Long64_t Merge(TCollection *list, Option_t *option="""")Merge the trees in the TList into this tree.Definition TTree.cxx:6890; TTree::SetMaxVirtualSizevirtual void SetMaxVirtualSize(Long64_t size=0)Definition TTree.h:665; TTree::DropBasketsvirtual void ",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:76484,Usability,simpl,simply,76484,"ual Long64_t GetReadEntry() constDefinition TTree.h:549; TTree::GetListOfBranchesvirtual TObjArray * GetListOfBranches()Definition TTree.h:528; TTree::fZipBytesLong64_t fZipBytesTotal number of bytes in all branches after compression.Definition TTree.h:87; TTree::GetTreevirtual TTree * GetTree() constDefinition TTree.h:557; TTree::fTransientBufferTBuffer * fTransientBuffer! Pointer to the current transient buffer.Definition TTree.h:138; TTree::GetValvirtual Double_t * GetVal(Int_t i)Definition TTree.h:574; TTree::SetEntryListvirtual void SetEntryList(TEntryList *list, Option_t *opt="""")Set an EntryList.Definition TTree.cxx:9046; TTree::Notifybool Notify() overrideFunction called when loading a new class library.Definition TTree.cxx:7033; TTree::AddZipBytesvirtual void AddZipBytes(Int_t zip)Definition TTree.h:332; TTree::LoadTreevirtual Long64_t LoadTree(Long64_t entry)Set current entry.Definition TTree.cxx:6473; TTree::ReadFilevirtual Long64_t ReadFile(const char *filename, const char *branchDescriptor="""", char delimiter=' ')Create or simply read branches from filename.Definition TTree.cxx:7564; TTree::GetAliasvirtual const char * GetAlias(const char *aliasName) constReturns the expanded value of the alias. Search in the friends if any.Definition TTree.cxx:5226; TTree::SetIOFeaturesROOT::TIOFeatures SetIOFeatures(const ROOT::TIOFeatures &)Provide the end-user with the ability to enable/disable various experimental IO features for this TTr...Definition TTree.cxx:9130; TTree::CreateBasketvirtual TBasket * CreateBasket(TBranch *)Create a basket for this tree and given branch.Definition TTree.cxx:3731; TTree::fUserInfoTList * fUserInfopointer to a list of user objects associated to this TreeDefinition TTree.h:133; TTree::GetMinimumvirtual Double_t GetMinimum(const char *columname)Return minimum of column with name columname.Definition TTree.cxx:6275; TTree::RemoveFriendvirtual void RemoveFriend(TTree *)Remove a friend from the list of friends.Definition TTree.cxx:7977; T",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TTree_8h_source.html:84510,Usability,undo,undo,84510,"Entries, Long64_t firstentry=0)Make a projection of a tree using selections.Definition TTree.cxx:7498; TTree::SetCacheEntryRangevirtual Int_t SetCacheEntryRange(Long64_t first, Long64_t last)interface to TTreeCache to set the cache entry rangeDefinition TTree.cxx:8831; TTree::GetMaxTreeSizestatic Long64_t GetMaxTreeSize()Static function which returns the tree file size limit in bytes.Definition TTree.cxx:6265; TTree::fCacheDoClusterPrefetchbool fCacheDoClusterPrefetch! true if cache is prefetching whole clustersDefinition TTree.h:140; TTree::SetBranchAddressImpInt_t SetBranchAddressImp(TBranch *branch, void *addr, TBranch **ptr)Change branch address, dealing with clone trees properly.Definition TTree.cxx:8445; TTree::SetAliasvirtual bool SetAlias(const char *aliasName, const char *aliasFormula)Set a tree variable alias.Definition TTree.cxx:8141; TTree::GetTimerIntervalvirtual Int_t GetTimerInterval() constDefinition TTree.h:554; TTree::CopyAddressesvirtual void CopyAddresses(TTree *, bool undo=false)Set branch addresses of passed tree equal to ours.Definition TTree.cxx:3299; TTree::SetScanFieldvirtual void SetScanField(Int_t n=50)Sets the default maximum number of lines to be shown before <CR> when calling Scan().Definition TTree.h:691; TTree::TTreeTTree(const TTree &tt)=delete; TTree::fMaxEntriesLong64_t fMaxEntriesMaximum number of entries in case of circular buffers.Definition TTree.h:97; TTree::SetBranchAddressInt_t SetBranchAddress(const char *bname, T **add, TBranch **ptr=nullptr)Definition TTree.h:628; TTree::BranchTBranch * Branch(const char *name, char *address, const char *leaflist, Int_t bufsize=32000)Definition TTree.h:379; TTree::DropBuffersvirtual void DropBuffers(Int_t nbytes)Drop branch buffers to accommodate nbytes below MaxVirtualsize.Definition TTree.cxx:4531; TTree::GetListOfFriendsvirtual TList * GetListOfFriends() constDefinition TTree.h:530; TTree::Refreshvirtual void Refresh()Refresh contents of this tree and its branches from the current stat",MatchSource.WIKI,doc/master/TTree_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:13884,Availability,error,error,13884,"ring p = gApplication->Argv(0);; 449 if (p.BeginsWith(""/"")); 450 exepath = p;; 451 else if (p.Contains(""/"")) {; 452 exepath = gSystem->WorkingDirectory();; 453 exepath += ""/"";; 454 exepath += p;; 455 } else {; 456 char *exe = gSystem->Which(gSystem->Getenv(""PATH""), p, kExecutePermission);; 457 if (exe) {; 458 exepath = exe;; 459 delete [] exe;; 460 }; 461 }; 462#endif; 463 }; 464 return exepath;; 465}; 466 ; 467#if defined(HAVE_DLADDR) && !defined(R__MACOSX); 468////////////////////////////////////////////////////////////////////////////////; 469 ; 470static void SetRootSys(); 471{; 472#ifdef ROOTPREFIX; 473 if (gSystem->Getenv(""ROOTIGNOREPREFIX"")) {; 474#endif; 475 void *addr = (void *)SetRootSys;; 476 Dl_info info;; 477 if (dladdr(addr, &info) && info.dli_fname && info.dli_fname[0]) {; 478 char respath[kMAXPATHLEN];; 479 if (!realpath(info.dli_fname, respath)) {; 480 if (!gSystem->Getenv(""ROOTSYS"")); 481 ::SysError(""TUnixSystem::SetRootSys"", ""error getting realpath of libCore, please set ROOTSYS in the shell"");; 482 } else {; 483 TString rs = gSystem->GetDirName(respath);; 484 gSystem->Setenv(""ROOTSYS"", gSystem->GetDirName(rs.Data()).Data());; 485 }; 486 }; 487#ifdef ROOTPREFIX; 488 }; 489#endif; 490}; 491#endif; 492 ; 493#if defined(R__MACOSX); 494static TString gLinkedDylibs;; 495 ; 496////////////////////////////////////////////////////////////////////////////////; 497 ; 498static void DylibAdded(const struct mach_header *mh, intptr_t /* vmaddr_slide */); 499{; 500 static int i = 0;; 501 static Bool_t gotFirstSo = kFALSE;; 502 static TString linkedDylibs;; 503 ; 504 // to copy the local linkedDylibs to the global gLinkedDylibs call this; 505 // function with mh==0; 506 if (!mh) {; 507 gLinkedDylibs = linkedDylibs;; 508 return;; 509 }; 510 ; 511 TString lib = _dyld_get_image_name(i++);; 512 ; 513 TRegexp sovers = ""libCore\\.[0-9]+\\.*[0-9]*\\.*[0-9]*\\.so"";; 514 TRegexp dyvers = ""libCore\\.[0-9]+\\.*[0-9]*\\.*[0-9]*\\.dylib"";; 515 ; 516#ifdef ROOTPREFIX; 517 if ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:15263,Availability,error,error,15263,"////////////////////////////////////////////////; 497 ; 498static void DylibAdded(const struct mach_header *mh, intptr_t /* vmaddr_slide */); 499{; 500 static int i = 0;; 501 static Bool_t gotFirstSo = kFALSE;; 502 static TString linkedDylibs;; 503 ; 504 // to copy the local linkedDylibs to the global gLinkedDylibs call this; 505 // function with mh==0; 506 if (!mh) {; 507 gLinkedDylibs = linkedDylibs;; 508 return;; 509 }; 510 ; 511 TString lib = _dyld_get_image_name(i++);; 512 ; 513 TRegexp sovers = ""libCore\\.[0-9]+\\.*[0-9]*\\.*[0-9]*\\.so"";; 514 TRegexp dyvers = ""libCore\\.[0-9]+\\.*[0-9]*\\.*[0-9]*\\.dylib"";; 515 ; 516#ifdef ROOTPREFIX; 517 if (gSystem->Getenv(""ROOTIGNOREPREFIX"")) {; 518#endif; 519 if (lib.EndsWith(""libCore.dylib"") || lib.EndsWith(""libCore.so"") ||; 520 lib.Index(sovers) != kNPOS || lib.Index(dyvers) != kNPOS) {; 521 char respath[kMAXPATHLEN];; 522 if (!realpath(lib, respath)) {; 523 if (!gSystem->Getenv(""ROOTSYS"")); 524 ::SysError(""TUnixSystem::DylibAdded"", ""error getting realpath of libCore, please set ROOTSYS in the shell"");; 525 } else {; 526 TString rs = gSystem->GetDirName(respath);; 527 gSystem->Setenv(""ROOTSYS"", gSystem->GetDirName(rs.Data()).Data());; 528 }; 529 }; 530#ifdef ROOTPREFIX; 531 }; 532#endif; 533 ; 534 // when libSystem.B.dylib is loaded we have finished loading all dylibs; 535 // explicitly linked against the executable. Additional dylibs; 536 // come when they are explicitly linked against loaded so's, currently; 537 // we are not interested in these; 538 if (lib.EndsWith(""/libSystem.B.dylib"")) {; 539 gotFirstSo = kTRUE;; 540 if (linkedDylibs.IsNull()) {; 541 // TSystem::GetLibraries() assumes that an empty GetLinkedLibraries(); 542 // means failure to extract the linked libraries. Signal ""we did; 543 // manage, but it's empty"" by returning a single space.; 544 linkedDylibs = ' ';; 545 }; 546 }; 547 ; 548 // add all libs loaded before libSystem.B.dylib; 549 if (!gotFirstSo && (lib.EndsWith("".dylib"") || lib.EndsWith("".so"")))",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:15982,Availability,failure,failure,15982,"REPREFIX"")) {; 518#endif; 519 if (lib.EndsWith(""libCore.dylib"") || lib.EndsWith(""libCore.so"") ||; 520 lib.Index(sovers) != kNPOS || lib.Index(dyvers) != kNPOS) {; 521 char respath[kMAXPATHLEN];; 522 if (!realpath(lib, respath)) {; 523 if (!gSystem->Getenv(""ROOTSYS"")); 524 ::SysError(""TUnixSystem::DylibAdded"", ""error getting realpath of libCore, please set ROOTSYS in the shell"");; 525 } else {; 526 TString rs = gSystem->GetDirName(respath);; 527 gSystem->Setenv(""ROOTSYS"", gSystem->GetDirName(rs.Data()).Data());; 528 }; 529 }; 530#ifdef ROOTPREFIX; 531 }; 532#endif; 533 ; 534 // when libSystem.B.dylib is loaded we have finished loading all dylibs; 535 // explicitly linked against the executable. Additional dylibs; 536 // come when they are explicitly linked against loaded so's, currently; 537 // we are not interested in these; 538 if (lib.EndsWith(""/libSystem.B.dylib"")) {; 539 gotFirstSo = kTRUE;; 540 if (linkedDylibs.IsNull()) {; 541 // TSystem::GetLibraries() assumes that an empty GetLinkedLibraries(); 542 // means failure to extract the linked libraries. Signal ""we did; 543 // manage, but it's empty"" by returning a single space.; 544 linkedDylibs = ' ';; 545 }; 546 }; 547 ; 548 // add all libs loaded before libSystem.B.dylib; 549 if (!gotFirstSo && (lib.EndsWith("".dylib"") || lib.EndsWith("".so""))) {; 550 sovers = ""\\.[0-9]+\\.*[0-9]*\\.so"";; 551 Ssiz_t idx = lib.Index(sovers);; 552 if (idx != kNPOS) {; 553 lib.Remove(idx);; 554 lib += "".so"";; 555 }; 556 dyvers = ""\\.[0-9]+\\.*[0-9]*\\.dylib"";; 557 idx = lib.Index(dyvers);; 558 if (idx != kNPOS) {; 559 lib.Remove(idx);; 560 lib += "".dylib"";; 561 }; 562 if (!gSystem->AccessPathName(lib, kReadPermission)) {; 563 if (linkedDylibs.Length()); 564 linkedDylibs += "" "";; 565 linkedDylibs += lib;; 566 }; 567 }; 568}; 569#endif; 570 ; 571ClassImp(TUnixSystem);; 572 ; 573////////////////////////////////////////////////////////////////////////////////; 574 ; 575TUnixSystem::TUnixSystem() : TSystem(""Unix"", ""Unix System""); 576{ }; ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:21517,Availability,error,error,21517,"== kNPOS); 680 disp.Append("":0.0"");; 681 Setenv(""DISPLAY"", disp.Data());; 682 Warning(""SetDisplay"", ""DISPLAY not set, setting it to %s"", disp.Data());; 683 }; 684#ifndef UTMP_NO_ADDR; 685 else if (utmp_entry->ut_addr) {; 686 ; 687 struct sockaddr_in addr;; 688 addr.sin_family = AF_INET;; 689 addr.sin_port = 0;; 690 memcpy(&addr.sin_addr, &utmp_entry->ut_addr, sizeof(addr.sin_addr));; 691 memset(&addr.sin_zero[0], 0, sizeof(addr.sin_zero));; 692 struct sockaddr *sa = (struct sockaddr *) &addr; // input; 693 ; 694 char hbuf[NI_MAXHOST + 4];; 695 if (getnameinfo(sa, sizeof(struct sockaddr), hbuf, sizeof(hbuf), nullptr, 0, NI_NAMEREQD) == 0) {; 696 assert( strlen(hbuf) < NI_MAXHOST );; 697 strlcat(hbuf, "":0.0"", sizeof(hbuf));; 698 Setenv(""DISPLAY"", hbuf);; 699 Warning(""SetDisplay"", ""DISPLAY not set, setting it to %s"",; 700 hbuf);; 701 }; 702 }; 703#endif; 704 }; 705 }; 706#ifndef R__HAS_COCOA; 707 if (!gROOT->IsBatch() && !getenv(""DISPLAY"")) {; 708 Error(""SetDisplay"", ""Can't figure out DISPLAY, set it manually\n""; 709 ""In case you run a remote ssh session, restart your ssh session with:\n""; 710 ""=========> ssh -Y"");; 711 }; 712#endif; 713 }; 714}; 715 ; 716////////////////////////////////////////////////////////////////////////////////; 717/// Return system error string.; 718 ; 719const char *TUnixSystem::GetError(); 720{; 721 Int_t err = GetErrno();; 722 if (err == 0 && GetLastErrorString() != """"); 723 return GetLastErrorString();; 724 ; 725#if defined(R__SOLARIS) || defined (R__LINUX) || defined(R__AIX) || \; 726 defined(R__FBSD) || defined(R__OBSD) || defined(R__HURD); 727 return strerror(err);; 728#else; 729 if (err < 0 || err >= sys_nerr); 730 return Form(""errno out of range %d"", err);; 731 return sys_errlist[err];; 732#endif; 733}; 734 ; 735////////////////////////////////////////////////////////////////////////////////; 736/// Return cryptographic random number; 737/// Fill provided buffer with random values; 738/// Returns number of bytes written to buffer or -1",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:22255,Availability,error,error,22255,"2 }; 703#endif; 704 }; 705 }; 706#ifndef R__HAS_COCOA; 707 if (!gROOT->IsBatch() && !getenv(""DISPLAY"")) {; 708 Error(""SetDisplay"", ""Can't figure out DISPLAY, set it manually\n""; 709 ""In case you run a remote ssh session, restart your ssh session with:\n""; 710 ""=========> ssh -Y"");; 711 }; 712#endif; 713 }; 714}; 715 ; 716////////////////////////////////////////////////////////////////////////////////; 717/// Return system error string.; 718 ; 719const char *TUnixSystem::GetError(); 720{; 721 Int_t err = GetErrno();; 722 if (err == 0 && GetLastErrorString() != """"); 723 return GetLastErrorString();; 724 ; 725#if defined(R__SOLARIS) || defined (R__LINUX) || defined(R__AIX) || \; 726 defined(R__FBSD) || defined(R__OBSD) || defined(R__HURD); 727 return strerror(err);; 728#else; 729 if (err < 0 || err >= sys_nerr); 730 return Form(""errno out of range %d"", err);; 731 return sys_errlist[err];; 732#endif; 733}; 734 ; 735////////////////////////////////////////////////////////////////////////////////; 736/// Return cryptographic random number; 737/// Fill provided buffer with random values; 738/// Returns number of bytes written to buffer or -1 in case of error; 739 ; 740Int_t TUnixSystem::GetCryptoRandom(void *buf, Int_t len); 741{; 742#if defined(R__ARC4_STDLIB) || defined(R__ARC4_BSDLIB); 743 arc4random_buf(buf, len);; 744 return len;; 745#elif defined(R__GETRANDOM_CLIB); 746 return getrandom(buf, len, GRND_NONBLOCK);; 747#elif defined(R__USE_URANDOM); 748 std::ifstream urandom{""/dev/urandom""};; 749 if (!urandom); 750 return -1;; 751 urandom.read(reinterpret_cast<char *>(buf), len);; 752 return len;; 753#else; 754#error ""Reliable cryptographic random function not defined""; 755 return -1;; 756#endif; 757}; 758 ; 759////////////////////////////////////////////////////////////////////////////////; 760/// Return the system's host name.; 761 ; 762const char *TUnixSystem::HostName(); 763{; 764 if (fHostname == """") {; 765 char hn[64];; 766#if defined(R__SOLARIS); 767 sysinfo(SI_H",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:22726,Availability,error,error,22726," defined(R__OBSD) || defined(R__HURD); 727 return strerror(err);; 728#else; 729 if (err < 0 || err >= sys_nerr); 730 return Form(""errno out of range %d"", err);; 731 return sys_errlist[err];; 732#endif; 733}; 734 ; 735////////////////////////////////////////////////////////////////////////////////; 736/// Return cryptographic random number; 737/// Fill provided buffer with random values; 738/// Returns number of bytes written to buffer or -1 in case of error; 739 ; 740Int_t TUnixSystem::GetCryptoRandom(void *buf, Int_t len); 741{; 742#if defined(R__ARC4_STDLIB) || defined(R__ARC4_BSDLIB); 743 arc4random_buf(buf, len);; 744 return len;; 745#elif defined(R__GETRANDOM_CLIB); 746 return getrandom(buf, len, GRND_NONBLOCK);; 747#elif defined(R__USE_URANDOM); 748 std::ifstream urandom{""/dev/urandom""};; 749 if (!urandom); 750 return -1;; 751 urandom.read(reinterpret_cast<char *>(buf), len);; 752 return len;; 753#else; 754#error ""Reliable cryptographic random function not defined""; 755 return -1;; 756#endif; 757}; 758 ; 759////////////////////////////////////////////////////////////////////////////////; 760/// Return the system's host name.; 761 ; 762const char *TUnixSystem::HostName(); 763{; 764 if (fHostname == """") {; 765 char hn[64];; 766#if defined(R__SOLARIS); 767 sysinfo(SI_HOSTNAME, hn, sizeof(hn));; 768#else; 769 gethostname(hn, sizeof(hn));; 770#endif; 771 fHostname = hn;; 772 }; 773 return (const char *)fHostname;; 774}; 775 ; 776//---- EventLoop ---------------------------------------------------------------; 777 ; 778////////////////////////////////////////////////////////////////////////////////; 779/// Add a file handler to the list of system file handlers. Only adds; 780/// the handler if it is not already in the list of file handlers.; 781 ; 782void TUnixSystem::AddFileHandler(TFileHandler *h); 783{; 784 R__LOCKGUARD2(gSystemMutex);; 785 ; 786 TSystem::AddFileHandler(h);; 787 if (h) {; 788 int fd = h->GetFd();; 789 if (h->HasReadInterest()) {; 790 fReadmask->Se",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:27900,Availability,mask,mask,27900,"///////////////////////////////////////////////////; 901/// When the argument is true the SIGALRM signal handler is set so that; 902/// interrupted syscalls will not be restarted by the kernel. This is; 903/// typically used in case one wants to put a timeout on an I/O operation.; 904/// By default interrupted syscalls will always be restarted (for all; 905/// signals). This can be controlled for each a-synchronous TTimer via; 906/// the method TTimer::SetInterruptSyscalls().; 907 ; 908void TUnixSystem::SigAlarmInterruptsSyscalls(Bool_t set); 909{; 910 UnixSigAlarmInterruptsSyscalls(set);; 911}; 912 ; 913////////////////////////////////////////////////////////////////////////////////; 914/// Return the bitmap of conditions that trigger a floating point exception.; 915 ; 916Int_t TUnixSystem::GetFPEMask(); 917{; 918 Int_t mask = 0;; 919 ; 920#if defined(R__LINUX) && !defined(__powerpc__); 921#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 922 ; 923#if __GLIBC_MINOR__>=3; 924 ; 925 Int_t oldmask = fegetexcept();; 926 ; 927#else; 928 fenv_t oldenv;; 929 fegetenv(&oldenv);; 930 fesetenv(&oldenv);; 931#if __ia64__; 932 Int_t oldmask = ~oldenv;; 933#else; 934 Int_t oldmask = ~oldenv.__control_word;; 935#endif; 936#endif; 937 ; 938 if (oldmask & FE_INVALID ) mask |= kInvalid;; 939 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 940 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 941 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 942# ifdef FE_INEXACT; 943 if (oldmask & FE_INEXACT ) mask |= kInexact;; 944# endif; 945#endif; 946#endif; 947 ; 948#if defined(R__MACOSX) && defined(__SSE2__); 949 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 950 Int_t oldmask = ~_MM_GET_EXCEPTION_MASK();; 951 ; 952 if (oldmask & _MM_MASK_INVALID ) mask |= kInvalid;; 953 if (oldmask & _MM_MASK_DIV_ZERO ) mask |= kDivByZero;; 954 if (oldmask & _MM_MASK_OVERFLOW ) mask |= kOverflow;; 955 if (oldmask & _MM_MASK_UNDERFLOW) mask |= kUnderf",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:28370,Availability,mask,mask,28370,"nt_t TUnixSystem::GetFPEMask(); 917{; 918 Int_t mask = 0;; 919 ; 920#if defined(R__LINUX) && !defined(__powerpc__); 921#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 922 ; 923#if __GLIBC_MINOR__>=3; 924 ; 925 Int_t oldmask = fegetexcept();; 926 ; 927#else; 928 fenv_t oldenv;; 929 fegetenv(&oldenv);; 930 fesetenv(&oldenv);; 931#if __ia64__; 932 Int_t oldmask = ~oldenv;; 933#else; 934 Int_t oldmask = ~oldenv.__control_word;; 935#endif; 936#endif; 937 ; 938 if (oldmask & FE_INVALID ) mask |= kInvalid;; 939 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 940 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 941 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 942# ifdef FE_INEXACT; 943 if (oldmask & FE_INEXACT ) mask |= kInexact;; 944# endif; 945#endif; 946#endif; 947 ; 948#if defined(R__MACOSX) && defined(__SSE2__); 949 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 950 Int_t oldmask = ~_MM_GET_EXCEPTION_MASK();; 951 ; 952 if (oldmask & _MM_MASK_INVALID ) mask |= kInvalid;; 953 if (oldmask & _MM_MASK_DIV_ZERO ) mask |= kDivByZero;; 954 if (oldmask & _MM_MASK_OVERFLOW ) mask |= kOverflow;; 955 if (oldmask & _MM_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:28421,Availability,mask,mask,28421,"nt_t TUnixSystem::GetFPEMask(); 917{; 918 Int_t mask = 0;; 919 ; 920#if defined(R__LINUX) && !defined(__powerpc__); 921#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 922 ; 923#if __GLIBC_MINOR__>=3; 924 ; 925 Int_t oldmask = fegetexcept();; 926 ; 927#else; 928 fenv_t oldenv;; 929 fegetenv(&oldenv);; 930 fesetenv(&oldenv);; 931#if __ia64__; 932 Int_t oldmask = ~oldenv;; 933#else; 934 Int_t oldmask = ~oldenv.__control_word;; 935#endif; 936#endif; 937 ; 938 if (oldmask & FE_INVALID ) mask |= kInvalid;; 939 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 940 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 941 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 942# ifdef FE_INEXACT; 943 if (oldmask & FE_INEXACT ) mask |= kInexact;; 944# endif; 945#endif; 946#endif; 947 ; 948#if defined(R__MACOSX) && defined(__SSE2__); 949 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 950 Int_t oldmask = ~_MM_GET_EXCEPTION_MASK();; 951 ; 952 if (oldmask & _MM_MASK_INVALID ) mask |= kInvalid;; 953 if (oldmask & _MM_MASK_DIV_ZERO ) mask |= kDivByZero;; 954 if (oldmask & _MM_MASK_OVERFLOW ) mask |= kOverflow;; 955 if (oldmask & _MM_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:28474,Availability,mask,mask,28474,"nt_t TUnixSystem::GetFPEMask(); 917{; 918 Int_t mask = 0;; 919 ; 920#if defined(R__LINUX) && !defined(__powerpc__); 921#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 922 ; 923#if __GLIBC_MINOR__>=3; 924 ; 925 Int_t oldmask = fegetexcept();; 926 ; 927#else; 928 fenv_t oldenv;; 929 fegetenv(&oldenv);; 930 fesetenv(&oldenv);; 931#if __ia64__; 932 Int_t oldmask = ~oldenv;; 933#else; 934 Int_t oldmask = ~oldenv.__control_word;; 935#endif; 936#endif; 937 ; 938 if (oldmask & FE_INVALID ) mask |= kInvalid;; 939 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 940 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 941 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 942# ifdef FE_INEXACT; 943 if (oldmask & FE_INEXACT ) mask |= kInexact;; 944# endif; 945#endif; 946#endif; 947 ; 948#if defined(R__MACOSX) && defined(__SSE2__); 949 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 950 Int_t oldmask = ~_MM_GET_EXCEPTION_MASK();; 951 ; 952 if (oldmask & _MM_MASK_INVALID ) mask |= kInvalid;; 953 if (oldmask & _MM_MASK_DIV_ZERO ) mask |= kDivByZero;; 954 if (oldmask & _MM_MASK_OVERFLOW ) mask |= kOverflow;; 955 if (oldmask & _MM_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:28526,Availability,mask,mask,28526,"nt_t TUnixSystem::GetFPEMask(); 917{; 918 Int_t mask = 0;; 919 ; 920#if defined(R__LINUX) && !defined(__powerpc__); 921#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 922 ; 923#if __GLIBC_MINOR__>=3; 924 ; 925 Int_t oldmask = fegetexcept();; 926 ; 927#else; 928 fenv_t oldenv;; 929 fegetenv(&oldenv);; 930 fesetenv(&oldenv);; 931#if __ia64__; 932 Int_t oldmask = ~oldenv;; 933#else; 934 Int_t oldmask = ~oldenv.__control_word;; 935#endif; 936#endif; 937 ; 938 if (oldmask & FE_INVALID ) mask |= kInvalid;; 939 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 940 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 941 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 942# ifdef FE_INEXACT; 943 if (oldmask & FE_INEXACT ) mask |= kInexact;; 944# endif; 945#endif; 946#endif; 947 ; 948#if defined(R__MACOSX) && defined(__SSE2__); 949 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 950 Int_t oldmask = ~_MM_GET_EXCEPTION_MASK();; 951 ; 952 if (oldmask & _MM_MASK_INVALID ) mask |= kInvalid;; 953 if (oldmask & _MM_MASK_DIV_ZERO ) mask |= kDivByZero;; 954 if (oldmask & _MM_MASK_OVERFLOW ) mask |= kOverflow;; 955 if (oldmask & _MM_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:28601,Availability,mask,mask,28601,"nt_t TUnixSystem::GetFPEMask(); 917{; 918 Int_t mask = 0;; 919 ; 920#if defined(R__LINUX) && !defined(__powerpc__); 921#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 922 ; 923#if __GLIBC_MINOR__>=3; 924 ; 925 Int_t oldmask = fegetexcept();; 926 ; 927#else; 928 fenv_t oldenv;; 929 fegetenv(&oldenv);; 930 fesetenv(&oldenv);; 931#if __ia64__; 932 Int_t oldmask = ~oldenv;; 933#else; 934 Int_t oldmask = ~oldenv.__control_word;; 935#endif; 936#endif; 937 ; 938 if (oldmask & FE_INVALID ) mask |= kInvalid;; 939 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 940 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 941 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 942# ifdef FE_INEXACT; 943 if (oldmask & FE_INEXACT ) mask |= kInexact;; 944# endif; 945#endif; 946#endif; 947 ; 948#if defined(R__MACOSX) && defined(__SSE2__); 949 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 950 Int_t oldmask = ~_MM_GET_EXCEPTION_MASK();; 951 ; 952 if (oldmask & _MM_MASK_INVALID ) mask |= kInvalid;; 953 if (oldmask & _MM_MASK_DIV_ZERO ) mask |= kDivByZero;; 954 if (oldmask & _MM_MASK_OVERFLOW ) mask |= kOverflow;; 955 if (oldmask & _MM_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:28878,Availability,mask,mask,28878,"nt_t TUnixSystem::GetFPEMask(); 917{; 918 Int_t mask = 0;; 919 ; 920#if defined(R__LINUX) && !defined(__powerpc__); 921#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 922 ; 923#if __GLIBC_MINOR__>=3; 924 ; 925 Int_t oldmask = fegetexcept();; 926 ; 927#else; 928 fenv_t oldenv;; 929 fegetenv(&oldenv);; 930 fesetenv(&oldenv);; 931#if __ia64__; 932 Int_t oldmask = ~oldenv;; 933#else; 934 Int_t oldmask = ~oldenv.__control_word;; 935#endif; 936#endif; 937 ; 938 if (oldmask & FE_INVALID ) mask |= kInvalid;; 939 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 940 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 941 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 942# ifdef FE_INEXACT; 943 if (oldmask & FE_INEXACT ) mask |= kInexact;; 944# endif; 945#endif; 946#endif; 947 ; 948#if defined(R__MACOSX) && defined(__SSE2__); 949 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 950 Int_t oldmask = ~_MM_GET_EXCEPTION_MASK();; 951 ; 952 if (oldmask & _MM_MASK_INVALID ) mask |= kInvalid;; 953 if (oldmask & _MM_MASK_DIV_ZERO ) mask |= kDivByZero;; 954 if (oldmask & _MM_MASK_OVERFLOW ) mask |= kOverflow;; 955 if (oldmask & _MM_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:28935,Availability,mask,mask,28935,"nt_t TUnixSystem::GetFPEMask(); 917{; 918 Int_t mask = 0;; 919 ; 920#if defined(R__LINUX) && !defined(__powerpc__); 921#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 922 ; 923#if __GLIBC_MINOR__>=3; 924 ; 925 Int_t oldmask = fegetexcept();; 926 ; 927#else; 928 fenv_t oldenv;; 929 fegetenv(&oldenv);; 930 fesetenv(&oldenv);; 931#if __ia64__; 932 Int_t oldmask = ~oldenv;; 933#else; 934 Int_t oldmask = ~oldenv.__control_word;; 935#endif; 936#endif; 937 ; 938 if (oldmask & FE_INVALID ) mask |= kInvalid;; 939 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 940 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 941 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 942# ifdef FE_INEXACT; 943 if (oldmask & FE_INEXACT ) mask |= kInexact;; 944# endif; 945#endif; 946#endif; 947 ; 948#if defined(R__MACOSX) && defined(__SSE2__); 949 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 950 Int_t oldmask = ~_MM_GET_EXCEPTION_MASK();; 951 ; 952 if (oldmask & _MM_MASK_INVALID ) mask |= kInvalid;; 953 if (oldmask & _MM_MASK_DIV_ZERO ) mask |= kDivByZero;; 954 if (oldmask & _MM_MASK_OVERFLOW ) mask |= kOverflow;; 955 if (oldmask & _MM_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:28994,Availability,mask,mask,28994,"nt_t TUnixSystem::GetFPEMask(); 917{; 918 Int_t mask = 0;; 919 ; 920#if defined(R__LINUX) && !defined(__powerpc__); 921#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 922 ; 923#if __GLIBC_MINOR__>=3; 924 ; 925 Int_t oldmask = fegetexcept();; 926 ; 927#else; 928 fenv_t oldenv;; 929 fegetenv(&oldenv);; 930 fesetenv(&oldenv);; 931#if __ia64__; 932 Int_t oldmask = ~oldenv;; 933#else; 934 Int_t oldmask = ~oldenv.__control_word;; 935#endif; 936#endif; 937 ; 938 if (oldmask & FE_INVALID ) mask |= kInvalid;; 939 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 940 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 941 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 942# ifdef FE_INEXACT; 943 if (oldmask & FE_INEXACT ) mask |= kInexact;; 944# endif; 945#endif; 946#endif; 947 ; 948#if defined(R__MACOSX) && defined(__SSE2__); 949 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 950 Int_t oldmask = ~_MM_GET_EXCEPTION_MASK();; 951 ; 952 if (oldmask & _MM_MASK_INVALID ) mask |= kInvalid;; 953 if (oldmask & _MM_MASK_DIV_ZERO ) mask |= kDivByZero;; 954 if (oldmask & _MM_MASK_OVERFLOW ) mask |= kOverflow;; 955 if (oldmask & _MM_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:29052,Availability,mask,mask,29052,"nt_t TUnixSystem::GetFPEMask(); 917{; 918 Int_t mask = 0;; 919 ; 920#if defined(R__LINUX) && !defined(__powerpc__); 921#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 922 ; 923#if __GLIBC_MINOR__>=3; 924 ; 925 Int_t oldmask = fegetexcept();; 926 ; 927#else; 928 fenv_t oldenv;; 929 fegetenv(&oldenv);; 930 fesetenv(&oldenv);; 931#if __ia64__; 932 Int_t oldmask = ~oldenv;; 933#else; 934 Int_t oldmask = ~oldenv.__control_word;; 935#endif; 936#endif; 937 ; 938 if (oldmask & FE_INVALID ) mask |= kInvalid;; 939 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 940 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 941 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 942# ifdef FE_INEXACT; 943 if (oldmask & FE_INEXACT ) mask |= kInexact;; 944# endif; 945#endif; 946#endif; 947 ; 948#if defined(R__MACOSX) && defined(__SSE2__); 949 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 950 Int_t oldmask = ~_MM_GET_EXCEPTION_MASK();; 951 ; 952 if (oldmask & _MM_MASK_INVALID ) mask |= kInvalid;; 953 if (oldmask & _MM_MASK_DIV_ZERO ) mask |= kDivByZero;; 954 if (oldmask & _MM_MASK_OVERFLOW ) mask |= kOverflow;; 955 if (oldmask & _MM_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:29110,Availability,mask,mask,29110,"nt_t TUnixSystem::GetFPEMask(); 917{; 918 Int_t mask = 0;; 919 ; 920#if defined(R__LINUX) && !defined(__powerpc__); 921#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 922 ; 923#if __GLIBC_MINOR__>=3; 924 ; 925 Int_t oldmask = fegetexcept();; 926 ; 927#else; 928 fenv_t oldenv;; 929 fegetenv(&oldenv);; 930 fesetenv(&oldenv);; 931#if __ia64__; 932 Int_t oldmask = ~oldenv;; 933#else; 934 Int_t oldmask = ~oldenv.__control_word;; 935#endif; 936#endif; 937 ; 938 if (oldmask & FE_INVALID ) mask |= kInvalid;; 939 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 940 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 941 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 942# ifdef FE_INEXACT; 943 if (oldmask & FE_INEXACT ) mask |= kInexact;; 944# endif; 945#endif; 946#endif; 947 ; 948#if defined(R__MACOSX) && defined(__SSE2__); 949 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 950 Int_t oldmask = ~_MM_GET_EXCEPTION_MASK();; 951 ; 952 if (oldmask & _MM_MASK_INVALID ) mask |= kInvalid;; 953 if (oldmask & _MM_MASK_DIV_ZERO ) mask |= kDivByZero;; 954 if (oldmask & _MM_MASK_OVERFLOW ) mask |= kOverflow;; 955 if (oldmask & _MM_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:29585,Availability,mask,mask,29585,_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 980 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 981 !defined(__arm64__); 982 Long64_t oldmask;; 983 fegetenvd(oldmask);; 984 ; 985 if (oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) new,MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:29636,Availability,mask,mask,29636,_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 980 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 981 !defined(__arm64__); 982 Long64_t oldmask;; 983 fegetenvd(oldmask);; 984 ; 985 if (oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) new,MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:29689,Availability,mask,mask,29689,_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 980 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 981 !defined(__arm64__); 982 Long64_t oldmask;; 983 fegetenvd(oldmask);; 984 ; 985 if (oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) new,MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:29741,Availability,mask,mask,29741,_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 980 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 981 !defined(__arm64__); 982 Long64_t oldmask;; 983 fegetenvd(oldmask);; 984 ; 985 if (oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) new,MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:29793,Availability,mask,mask,29793,_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 980 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 981 !defined(__arm64__); 982 Long64_t oldmask;; 983 fegetenvd(oldmask);; 984 ; 985 if (oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) new,MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:30095,Availability,mask,mask,30095,_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 980 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 981 !defined(__arm64__); 982 Long64_t oldmask;; 983 fegetenvd(oldmask);; 984 ; 985 if (oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) new,MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:30153,Availability,mask,mask,30153,_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 980 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 981 !defined(__arm64__); 982 Long64_t oldmask;; 983 fegetenvd(oldmask);; 984 ; 985 if (oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) new,MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:30213,Availability,mask,mask,30213,_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 980 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 981 !defined(__arm64__); 982 Long64_t oldmask;; 983 fegetenvd(oldmask);; 984 ; 985 if (oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) new,MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:30272,Availability,mask,mask,30272,_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 980 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 981 !defined(__arm64__); 982 Long64_t oldmask;; 983 fegetenvd(oldmask);; 984 ; 985 if (oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) new,MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:30331,Availability,mask,mask,30331,_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 980 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 981 !defined(__arm64__); 982 Long64_t oldmask;; 983 fegetenvd(oldmask);; 984 ; 985 if (oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) new,MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:30378,Availability,mask,mask,30378,_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 980 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 981 !defined(__arm64__); 982 Long64_t oldmask;; 983 fegetenvd(oldmask);; 984 ; 985 if (oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) new,MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:30639,Availability,mask,mask,30639,"oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1011 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:30662,Availability,mask,mask,30662,"oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1011 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:30679,Availability,mask,mask,30679,"oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1011 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:30914,Availability,mask,mask,30914,"oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1011 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:30962,Availability,mask,mask,30962,"oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1011 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:31013,Availability,mask,mask,31013,"oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1011 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:31063,Availability,mask,mask,31063,"oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1011 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:31138,Availability,mask,mask,31138,"oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1011 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:31809,Availability,mask,mask,31809,";; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK_INEXACT;; 1046 ; 1047 _MM_SET_EXCEPTION_MASK(_MM_GET_EXCEPTION_MASK() & ~newm);; 1048#endif; 1049 ; 1050#if defined(R__MACOSX) && !defined(__SSE2__) && \; 1051 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 1052 Int_t newm = 0;; 1053 if (mask & kInvalid ) newm |= FE_INVALID;; 1054 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1055 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1056 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1057 if (mask & kInexact ) newm |= FE_INEXACT;; 1058 ; 1059 fenv_t cur;; 1060 fegetenv(&cur);; 1061#if defined(__arm__); 1062 cur.__fpscr &= ~newm;; 1063#elif defined(__arm64__); 1064 cur.__fpcr &= ~newm;; 1065#else; 1066 cur.__control &= ~newm;; 1067#endif; 1068 fesetenv(&cur);; 1069#endif; 1070 ; 1071#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 1072 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 1073 !defined(__arm64__); 1074 Int_t newm = 0;; 1075 if (mask & kInvalid ) newm |= FE_ENABLE_INVALID;; 1076 if (mask",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:31863,Availability,mask,mask,31863,";; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK_INEXACT;; 1046 ; 1047 _MM_SET_EXCEPTION_MASK(_MM_GET_EXCEPTION_MASK() & ~newm);; 1048#endif; 1049 ; 1050#if defined(R__MACOSX) && !defined(__SSE2__) && \; 1051 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 1052 Int_t newm = 0;; 1053 if (mask & kInvalid ) newm |= FE_INVALID;; 1054 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1055 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1056 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1057 if (mask & kInexact ) newm |= FE_INEXACT;; 1058 ; 1059 fenv_t cur;; 1060 fegetenv(&cur);; 1061#if defined(__arm__); 1062 cur.__fpscr &= ~newm;; 1063#elif defined(__arm64__); 1064 cur.__fpcr &= ~newm;; 1065#else; 1066 cur.__control &= ~newm;; 1067#endif; 1068 fesetenv(&cur);; 1069#endif; 1070 ; 1071#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 1072 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 1073 !defined(__arm64__); 1074 Int_t newm = 0;; 1075 if (mask & kInvalid ) newm |= FE_ENABLE_INVALID;; 1076 if (mask",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:31919,Availability,mask,mask,31919,";; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK_INEXACT;; 1046 ; 1047 _MM_SET_EXCEPTION_MASK(_MM_GET_EXCEPTION_MASK() & ~newm);; 1048#endif; 1049 ; 1050#if defined(R__MACOSX) && !defined(__SSE2__) && \; 1051 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 1052 Int_t newm = 0;; 1053 if (mask & kInvalid ) newm |= FE_INVALID;; 1054 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1055 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1056 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1057 if (mask & kInexact ) newm |= FE_INEXACT;; 1058 ; 1059 fenv_t cur;; 1060 fegetenv(&cur);; 1061#if defined(__arm__); 1062 cur.__fpscr &= ~newm;; 1063#elif defined(__arm64__); 1064 cur.__fpcr &= ~newm;; 1065#else; 1066 cur.__control &= ~newm;; 1067#endif; 1068 fesetenv(&cur);; 1069#endif; 1070 ; 1071#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 1072 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 1073 !defined(__arm64__); 1074 Int_t newm = 0;; 1075 if (mask & kInvalid ) newm |= FE_ENABLE_INVALID;; 1076 if (mask",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:31975,Availability,mask,mask,31975,";; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK_INEXACT;; 1046 ; 1047 _MM_SET_EXCEPTION_MASK(_MM_GET_EXCEPTION_MASK() & ~newm);; 1048#endif; 1049 ; 1050#if defined(R__MACOSX) && !defined(__SSE2__) && \; 1051 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 1052 Int_t newm = 0;; 1053 if (mask & kInvalid ) newm |= FE_INVALID;; 1054 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1055 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1056 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1057 if (mask & kInexact ) newm |= FE_INEXACT;; 1058 ; 1059 fenv_t cur;; 1060 fegetenv(&cur);; 1061#if defined(__arm__); 1062 cur.__fpscr &= ~newm;; 1063#elif defined(__arm64__); 1064 cur.__fpcr &= ~newm;; 1065#else; 1066 cur.__control &= ~newm;; 1067#endif; 1068 fesetenv(&cur);; 1069#endif; 1070 ; 1071#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 1072 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 1073 !defined(__arm64__); 1074 Int_t newm = 0;; 1075 if (mask & kInvalid ) newm |= FE_ENABLE_INVALID;; 1076 if (mask",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:32032,Availability,mask,mask,32032,";; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK_INEXACT;; 1046 ; 1047 _MM_SET_EXCEPTION_MASK(_MM_GET_EXCEPTION_MASK() & ~newm);; 1048#endif; 1049 ; 1050#if defined(R__MACOSX) && !defined(__SSE2__) && \; 1051 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 1052 Int_t newm = 0;; 1053 if (mask & kInvalid ) newm |= FE_INVALID;; 1054 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1055 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1056 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1057 if (mask & kInexact ) newm |= FE_INEXACT;; 1058 ; 1059 fenv_t cur;; 1060 fegetenv(&cur);; 1061#if defined(__arm__); 1062 cur.__fpscr &= ~newm;; 1063#elif defined(__arm64__); 1064 cur.__fpcr &= ~newm;; 1065#else; 1066 cur.__control &= ~newm;; 1067#endif; 1068 fesetenv(&cur);; 1069#endif; 1070 ; 1071#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 1072 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 1073 !defined(__arm64__); 1074 Int_t newm = 0;; 1075 if (mask & kInvalid ) newm |= FE_ENABLE_INVALID;; 1076 if (mask",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:32344,Availability,mask,mask,32344,";; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK_INEXACT;; 1046 ; 1047 _MM_SET_EXCEPTION_MASK(_MM_GET_EXCEPTION_MASK() & ~newm);; 1048#endif; 1049 ; 1050#if defined(R__MACOSX) && !defined(__SSE2__) && \; 1051 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 1052 Int_t newm = 0;; 1053 if (mask & kInvalid ) newm |= FE_INVALID;; 1054 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1055 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1056 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1057 if (mask & kInexact ) newm |= FE_INEXACT;; 1058 ; 1059 fenv_t cur;; 1060 fegetenv(&cur);; 1061#if defined(__arm__); 1062 cur.__fpscr &= ~newm;; 1063#elif defined(__arm64__); 1064 cur.__fpcr &= ~newm;; 1065#else; 1066 cur.__control &= ~newm;; 1067#endif; 1068 fesetenv(&cur);; 1069#endif; 1070 ; 1071#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 1072 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 1073 !defined(__arm64__); 1074 Int_t newm = 0;; 1075 if (mask & kInvalid ) newm |= FE_ENABLE_INVALID;; 1076 if (mask",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:32392,Availability,mask,mask,32392,";; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK_INEXACT;; 1046 ; 1047 _MM_SET_EXCEPTION_MASK(_MM_GET_EXCEPTION_MASK() & ~newm);; 1048#endif; 1049 ; 1050#if defined(R__MACOSX) && !defined(__SSE2__) && \; 1051 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 1052 Int_t newm = 0;; 1053 if (mask & kInvalid ) newm |= FE_INVALID;; 1054 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1055 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1056 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1057 if (mask & kInexact ) newm |= FE_INEXACT;; 1058 ; 1059 fenv_t cur;; 1060 fegetenv(&cur);; 1061#if defined(__arm__); 1062 cur.__fpscr &= ~newm;; 1063#elif defined(__arm64__); 1064 cur.__fpcr &= ~newm;; 1065#else; 1066 cur.__control &= ~newm;; 1067#endif; 1068 fesetenv(&cur);; 1069#endif; 1070 ; 1071#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 1072 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 1073 !defined(__arm64__); 1074 Int_t newm = 0;; 1075 if (mask & kInvalid ) newm |= FE_ENABLE_INVALID;; 1076 if (mask",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:32443,Availability,mask,mask,32443,";; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK_INEXACT;; 1046 ; 1047 _MM_SET_EXCEPTION_MASK(_MM_GET_EXCEPTION_MASK() & ~newm);; 1048#endif; 1049 ; 1050#if defined(R__MACOSX) && !defined(__SSE2__) && \; 1051 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 1052 Int_t newm = 0;; 1053 if (mask & kInvalid ) newm |= FE_INVALID;; 1054 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1055 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1056 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1057 if (mask & kInexact ) newm |= FE_INEXACT;; 1058 ; 1059 fenv_t cur;; 1060 fegetenv(&cur);; 1061#if defined(__arm__); 1062 cur.__fpscr &= ~newm;; 1063#elif defined(__arm64__); 1064 cur.__fpcr &= ~newm;; 1065#else; 1066 cur.__control &= ~newm;; 1067#endif; 1068 fesetenv(&cur);; 1069#endif; 1070 ; 1071#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 1072 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 1073 !defined(__arm64__); 1074 Int_t newm = 0;; 1075 if (mask & kInvalid ) newm |= FE_ENABLE_INVALID;; 1076 if (mask",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:32493,Availability,mask,mask,32493,";; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK_INEXACT;; 1046 ; 1047 _MM_SET_EXCEPTION_MASK(_MM_GET_EXCEPTION_MASK() & ~newm);; 1048#endif; 1049 ; 1050#if defined(R__MACOSX) && !defined(__SSE2__) && \; 1051 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 1052 Int_t newm = 0;; 1053 if (mask & kInvalid ) newm |= FE_INVALID;; 1054 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1055 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1056 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1057 if (mask & kInexact ) newm |= FE_INEXACT;; 1058 ; 1059 fenv_t cur;; 1060 fegetenv(&cur);; 1061#if defined(__arm__); 1062 cur.__fpscr &= ~newm;; 1063#elif defined(__arm64__); 1064 cur.__fpcr &= ~newm;; 1065#else; 1066 cur.__control &= ~newm;; 1067#endif; 1068 fesetenv(&cur);; 1069#endif; 1070 ; 1071#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 1072 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 1073 !defined(__arm64__); 1074 Int_t newm = 0;; 1075 if (mask & kInvalid ) newm |= FE_ENABLE_INVALID;; 1076 if (mask",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:32544,Availability,mask,mask,32544,";; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK_INEXACT;; 1046 ; 1047 _MM_SET_EXCEPTION_MASK(_MM_GET_EXCEPTION_MASK() & ~newm);; 1048#endif; 1049 ; 1050#if defined(R__MACOSX) && !defined(__SSE2__) && \; 1051 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 1052 Int_t newm = 0;; 1053 if (mask & kInvalid ) newm |= FE_INVALID;; 1054 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1055 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1056 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1057 if (mask & kInexact ) newm |= FE_INEXACT;; 1058 ; 1059 fenv_t cur;; 1060 fegetenv(&cur);; 1061#if defined(__arm__); 1062 cur.__fpscr &= ~newm;; 1063#elif defined(__arm64__); 1064 cur.__fpcr &= ~newm;; 1065#else; 1066 cur.__control &= ~newm;; 1067#endif; 1068 fesetenv(&cur);; 1069#endif; 1070 ; 1071#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 1072 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 1073 !defined(__arm64__); 1074 Int_t newm = 0;; 1075 if (mask & kInvalid ) newm |= FE_ENABLE_INVALID;; 1076 if (mask",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:33043,Availability,mask,mask,33043,&& !defined(__SSE2__) && \; 1051 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 1052 Int_t newm = 0;; 1053 if (mask & kInvalid ) newm |= FE_INVALID;; 1054 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1055 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1056 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1057 if (mask & kInexact ) newm |= FE_INEXACT;; 1058 ; 1059 fenv_t cur;; 1060 fegetenv(&cur);; 1061#if defined(__arm__); 1062 cur.__fpscr &= ~newm;; 1063#elif defined(__arm64__); 1064 cur.__fpcr &= ~newm;; 1065#else; 1066 cur.__control &= ~newm;; 1067#endif; 1068 fesetenv(&cur);; 1069#endif; 1070 ; 1071#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 1072 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 1073 !defined(__arm64__); 1074 Int_t newm = 0;; 1075 if (mask & kInvalid ) newm |= FE_ENABLE_INVALID;; 1076 if (mask & kDivByZero) newm |= FE_ENABLE_DIVBYZERO;; 1077 if (mask & kOverflow ) newm |= FE_ENABLE_OVERFLOW;; 1078 if (mask & kUnderflow) newm |= FE_ENABLE_UNDERFLOW;; 1079 if (mask & kInexact ) newm |= FE_ENABLE_INEXACT;; 1080 ; 1081 Long64_t curmask;; 1082 fegetenvd(curmask);; 1083 curmask = (curmask & ~FE_ENABLE_ALL_EXCEPT) | newm;; 1084 fesetenvd(curmask);; 1085#endif; 1086 ; 1087 return old;; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Dispatch a single event.; 1092 ; 1093void TUnixSystem::DispatchOneEvent(Bool_t pendingOnly); 1094{; 1095 Bool_t pollOnce = pendingOnly;; 1096 ; 1097 while (1) {; 1098 // first handle any X11 events; 1099 if (gXDisplay && gXDisplay->Notify()) {; 1100 if (fReadready->IsSet(gXDisplay->GetFd())) {; 1101 fReadready->Clr(gXDisplay->GetFd());; 1102 fNfd--;; 1103 }; 1104 if (!pendingOnly) return;; 1105 }; 1106 ; 1107 // check for file descriptors ready for reading/writing; 1108 if (fNfd > 0 && fFileHandler && fFileHandler->GetSize() > 0); 1109 if (CheckDescriptors()); 1110 if (!pendingOnly) r,MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:33098,Availability,mask,mask,33098,&& !defined(__SSE2__) && \; 1051 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 1052 Int_t newm = 0;; 1053 if (mask & kInvalid ) newm |= FE_INVALID;; 1054 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1055 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1056 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1057 if (mask & kInexact ) newm |= FE_INEXACT;; 1058 ; 1059 fenv_t cur;; 1060 fegetenv(&cur);; 1061#if defined(__arm__); 1062 cur.__fpscr &= ~newm;; 1063#elif defined(__arm64__); 1064 cur.__fpcr &= ~newm;; 1065#else; 1066 cur.__control &= ~newm;; 1067#endif; 1068 fesetenv(&cur);; 1069#endif; 1070 ; 1071#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 1072 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 1073 !defined(__arm64__); 1074 Int_t newm = 0;; 1075 if (mask & kInvalid ) newm |= FE_ENABLE_INVALID;; 1076 if (mask & kDivByZero) newm |= FE_ENABLE_DIVBYZERO;; 1077 if (mask & kOverflow ) newm |= FE_ENABLE_OVERFLOW;; 1078 if (mask & kUnderflow) newm |= FE_ENABLE_UNDERFLOW;; 1079 if (mask & kInexact ) newm |= FE_ENABLE_INEXACT;; 1080 ; 1081 Long64_t curmask;; 1082 fegetenvd(curmask);; 1083 curmask = (curmask & ~FE_ENABLE_ALL_EXCEPT) | newm;; 1084 fesetenvd(curmask);; 1085#endif; 1086 ; 1087 return old;; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Dispatch a single event.; 1092 ; 1093void TUnixSystem::DispatchOneEvent(Bool_t pendingOnly); 1094{; 1095 Bool_t pollOnce = pendingOnly;; 1096 ; 1097 while (1) {; 1098 // first handle any X11 events; 1099 if (gXDisplay && gXDisplay->Notify()) {; 1100 if (fReadready->IsSet(gXDisplay->GetFd())) {; 1101 fReadready->Clr(gXDisplay->GetFd());; 1102 fNfd--;; 1103 }; 1104 if (!pendingOnly) return;; 1105 }; 1106 ; 1107 // check for file descriptors ready for reading/writing; 1108 if (fNfd > 0 && fFileHandler && fFileHandler->GetSize() > 0); 1109 if (CheckDescriptors()); 1110 if (!pendingOnly) r,MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:33156,Availability,mask,mask,33156,&& !defined(__SSE2__) && \; 1051 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 1052 Int_t newm = 0;; 1053 if (mask & kInvalid ) newm |= FE_INVALID;; 1054 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1055 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1056 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1057 if (mask & kInexact ) newm |= FE_INEXACT;; 1058 ; 1059 fenv_t cur;; 1060 fegetenv(&cur);; 1061#if defined(__arm__); 1062 cur.__fpscr &= ~newm;; 1063#elif defined(__arm64__); 1064 cur.__fpcr &= ~newm;; 1065#else; 1066 cur.__control &= ~newm;; 1067#endif; 1068 fesetenv(&cur);; 1069#endif; 1070 ; 1071#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 1072 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 1073 !defined(__arm64__); 1074 Int_t newm = 0;; 1075 if (mask & kInvalid ) newm |= FE_ENABLE_INVALID;; 1076 if (mask & kDivByZero) newm |= FE_ENABLE_DIVBYZERO;; 1077 if (mask & kOverflow ) newm |= FE_ENABLE_OVERFLOW;; 1078 if (mask & kUnderflow) newm |= FE_ENABLE_UNDERFLOW;; 1079 if (mask & kInexact ) newm |= FE_ENABLE_INEXACT;; 1080 ; 1081 Long64_t curmask;; 1082 fegetenvd(curmask);; 1083 curmask = (curmask & ~FE_ENABLE_ALL_EXCEPT) | newm;; 1084 fesetenvd(curmask);; 1085#endif; 1086 ; 1087 return old;; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Dispatch a single event.; 1092 ; 1093void TUnixSystem::DispatchOneEvent(Bool_t pendingOnly); 1094{; 1095 Bool_t pollOnce = pendingOnly;; 1096 ; 1097 while (1) {; 1098 // first handle any X11 events; 1099 if (gXDisplay && gXDisplay->Notify()) {; 1100 if (fReadready->IsSet(gXDisplay->GetFd())) {; 1101 fReadready->Clr(gXDisplay->GetFd());; 1102 fNfd--;; 1103 }; 1104 if (!pendingOnly) return;; 1105 }; 1106 ; 1107 // check for file descriptors ready for reading/writing; 1108 if (fNfd > 0 && fFileHandler && fFileHandler->GetSize() > 0); 1109 if (CheckDescriptors()); 1110 if (!pendingOnly) r,MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:33213,Availability,mask,mask,33213,&& !defined(__SSE2__) && \; 1051 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 1052 Int_t newm = 0;; 1053 if (mask & kInvalid ) newm |= FE_INVALID;; 1054 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1055 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1056 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1057 if (mask & kInexact ) newm |= FE_INEXACT;; 1058 ; 1059 fenv_t cur;; 1060 fegetenv(&cur);; 1061#if defined(__arm__); 1062 cur.__fpscr &= ~newm;; 1063#elif defined(__arm64__); 1064 cur.__fpcr &= ~newm;; 1065#else; 1066 cur.__control &= ~newm;; 1067#endif; 1068 fesetenv(&cur);; 1069#endif; 1070 ; 1071#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 1072 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 1073 !defined(__arm64__); 1074 Int_t newm = 0;; 1075 if (mask & kInvalid ) newm |= FE_ENABLE_INVALID;; 1076 if (mask & kDivByZero) newm |= FE_ENABLE_DIVBYZERO;; 1077 if (mask & kOverflow ) newm |= FE_ENABLE_OVERFLOW;; 1078 if (mask & kUnderflow) newm |= FE_ENABLE_UNDERFLOW;; 1079 if (mask & kInexact ) newm |= FE_ENABLE_INEXACT;; 1080 ; 1081 Long64_t curmask;; 1082 fegetenvd(curmask);; 1083 curmask = (curmask & ~FE_ENABLE_ALL_EXCEPT) | newm;; 1084 fesetenvd(curmask);; 1085#endif; 1086 ; 1087 return old;; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Dispatch a single event.; 1092 ; 1093void TUnixSystem::DispatchOneEvent(Bool_t pendingOnly); 1094{; 1095 Bool_t pollOnce = pendingOnly;; 1096 ; 1097 while (1) {; 1098 // first handle any X11 events; 1099 if (gXDisplay && gXDisplay->Notify()) {; 1100 if (fReadready->IsSet(gXDisplay->GetFd())) {; 1101 fReadready->Clr(gXDisplay->GetFd());; 1102 fNfd--;; 1103 }; 1104 if (!pendingOnly) return;; 1105 }; 1106 ; 1107 // check for file descriptors ready for reading/writing; 1108 if (fNfd > 0 && fFileHandler && fFileHandler->GetSize() > 0); 1109 if (CheckDescriptors()); 1110 if (!pendingOnly) r,MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:33271,Availability,mask,mask,33271,&& !defined(__SSE2__) && \; 1051 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 1052 Int_t newm = 0;; 1053 if (mask & kInvalid ) newm |= FE_INVALID;; 1054 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1055 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1056 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1057 if (mask & kInexact ) newm |= FE_INEXACT;; 1058 ; 1059 fenv_t cur;; 1060 fegetenv(&cur);; 1061#if defined(__arm__); 1062 cur.__fpscr &= ~newm;; 1063#elif defined(__arm64__); 1064 cur.__fpcr &= ~newm;; 1065#else; 1066 cur.__control &= ~newm;; 1067#endif; 1068 fesetenv(&cur);; 1069#endif; 1070 ; 1071#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 1072 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 1073 !defined(__arm64__); 1074 Int_t newm = 0;; 1075 if (mask & kInvalid ) newm |= FE_ENABLE_INVALID;; 1076 if (mask & kDivByZero) newm |= FE_ENABLE_DIVBYZERO;; 1077 if (mask & kOverflow ) newm |= FE_ENABLE_OVERFLOW;; 1078 if (mask & kUnderflow) newm |= FE_ENABLE_UNDERFLOW;; 1079 if (mask & kInexact ) newm |= FE_ENABLE_INEXACT;; 1080 ; 1081 Long64_t curmask;; 1082 fegetenvd(curmask);; 1083 curmask = (curmask & ~FE_ENABLE_ALL_EXCEPT) | newm;; 1084 fesetenvd(curmask);; 1085#endif; 1086 ; 1087 return old;; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Dispatch a single event.; 1092 ; 1093void TUnixSystem::DispatchOneEvent(Bool_t pendingOnly); 1094{; 1095 Bool_t pollOnce = pendingOnly;; 1096 ; 1097 while (1) {; 1098 // first handle any X11 events; 1099 if (gXDisplay && gXDisplay->Notify()) {; 1100 if (fReadready->IsSet(gXDisplay->GetFd())) {; 1101 fReadready->Clr(gXDisplay->GetFd());; 1102 fNfd--;; 1103 }; 1104 if (!pendingOnly) return;; 1105 }; 1106 ; 1107 // check for file descriptors ready for reading/writing; 1108 if (fNfd > 0 && fFileHandler && fFileHandler->GetSize() > 0); 1109 if (CheckDescriptors()); 1110 if (!pendingOnly) r,MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:35759,Availability,error,error,35759,"= -1); 1132 return;; 1133 }; 1134 ; 1135 // if in pendingOnly mode poll once file descriptor activity; 1136 nextto = NextTimeOut(kTRUE);; 1137 if (pendingOnly) {; 1138 if (fFileHandler && fFileHandler->GetSize() == 0); 1139 return;; 1140 nextto = 0;; 1141 pollOnce = kFALSE;; 1142 }; 1143 ; 1144 // nothing ready, so setup select call; 1145 *fReadready = *fReadmask;; 1146 *fWriteready = *fWritemask;; 1147 ; 1148 int mxfd = TMath::Max(fMaxrfd, fMaxwfd);; 1149 mxfd++;; 1150 ; 1151 // if nothing to select (socket or timer) return; 1152 if (mxfd == 0 && nextto == -1); 1153 return;; 1154 ; 1155 fNfd = UnixSelect(mxfd, fReadready, fWriteready, nextto);; 1156 if (fNfd < 0 && fNfd != -2) {; 1157 int fd, rc;; 1158 TFdSet t;; 1159 for (fd = 0; fd < mxfd; fd++) {; 1160 t.Set(fd);; 1161 if (fReadmask->IsSet(fd)) {; 1162 rc = UnixSelect(fd+1, &t, nullptr, 0);; 1163 if (rc < 0 && rc != -2) {; 1164 SysError(""DispatchOneEvent"", ""select: read error on %d"", fd);; 1165 fReadmask->Clr(fd);; 1166 }; 1167 }; 1168 if (fWritemask->IsSet(fd)) {; 1169 rc = UnixSelect(fd+1, nullptr, &t, 0);; 1170 if (rc < 0 && rc != -2) {; 1171 SysError(""DispatchOneEvent"", ""select: write error on %d"", fd);; 1172 fWritemask->Clr(fd);; 1173 }; 1174 }; 1175 t.Clr(fd);; 1176 }; 1177 }; 1178 }; 1179}; 1180 ; 1181////////////////////////////////////////////////////////////////////////////////; 1182/// Sleep milliSec milliseconds.; 1183 ; 1184void TUnixSystem::Sleep(UInt_t milliSec); 1185{; 1186 struct timeval tv;; 1187 ; 1188 tv.tv_sec = milliSec / 1000;; 1189 tv.tv_usec = (milliSec % 1000) * 1000;; 1190 ; 1191 select(0, nullptr, nullptr, nullptr, &tv);; 1192}; 1193 ; 1194////////////////////////////////////////////////////////////////////////////////; 1195/// Select on file descriptors. The timeout to is in millisec. Returns; 1196/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 1197/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 1198/// the errno has been reset and t",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:35982,Availability,error,error,35982,"= -1); 1132 return;; 1133 }; 1134 ; 1135 // if in pendingOnly mode poll once file descriptor activity; 1136 nextto = NextTimeOut(kTRUE);; 1137 if (pendingOnly) {; 1138 if (fFileHandler && fFileHandler->GetSize() == 0); 1139 return;; 1140 nextto = 0;; 1141 pollOnce = kFALSE;; 1142 }; 1143 ; 1144 // nothing ready, so setup select call; 1145 *fReadready = *fReadmask;; 1146 *fWriteready = *fWritemask;; 1147 ; 1148 int mxfd = TMath::Max(fMaxrfd, fMaxwfd);; 1149 mxfd++;; 1150 ; 1151 // if nothing to select (socket or timer) return; 1152 if (mxfd == 0 && nextto == -1); 1153 return;; 1154 ; 1155 fNfd = UnixSelect(mxfd, fReadready, fWriteready, nextto);; 1156 if (fNfd < 0 && fNfd != -2) {; 1157 int fd, rc;; 1158 TFdSet t;; 1159 for (fd = 0; fd < mxfd; fd++) {; 1160 t.Set(fd);; 1161 if (fReadmask->IsSet(fd)) {; 1162 rc = UnixSelect(fd+1, &t, nullptr, 0);; 1163 if (rc < 0 && rc != -2) {; 1164 SysError(""DispatchOneEvent"", ""select: read error on %d"", fd);; 1165 fReadmask->Clr(fd);; 1166 }; 1167 }; 1168 if (fWritemask->IsSet(fd)) {; 1169 rc = UnixSelect(fd+1, nullptr, &t, 0);; 1170 if (rc < 0 && rc != -2) {; 1171 SysError(""DispatchOneEvent"", ""select: write error on %d"", fd);; 1172 fWritemask->Clr(fd);; 1173 }; 1174 }; 1175 t.Clr(fd);; 1176 }; 1177 }; 1178 }; 1179}; 1180 ; 1181////////////////////////////////////////////////////////////////////////////////; 1182/// Sleep milliSec milliseconds.; 1183 ; 1184void TUnixSystem::Sleep(UInt_t milliSec); 1185{; 1186 struct timeval tv;; 1187 ; 1188 tv.tv_sec = milliSec / 1000;; 1189 tv.tv_usec = (milliSec % 1000) * 1000;; 1190 ; 1191 select(0, nullptr, nullptr, nullptr, &tv);; 1192}; 1193 ; 1194////////////////////////////////////////////////////////////////////////////////; 1195/// Select on file descriptors. The timeout to is in millisec. Returns; 1196/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 1197/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 1198/// the errno has been reset and t",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:36724,Availability,error,error,36724,"< 0 && rc != -2) {; 1164 SysError(""DispatchOneEvent"", ""select: read error on %d"", fd);; 1165 fReadmask->Clr(fd);; 1166 }; 1167 }; 1168 if (fWritemask->IsSet(fd)) {; 1169 rc = UnixSelect(fd+1, nullptr, &t, 0);; 1170 if (rc < 0 && rc != -2) {; 1171 SysError(""DispatchOneEvent"", ""select: write error on %d"", fd);; 1172 fWritemask->Clr(fd);; 1173 }; 1174 }; 1175 t.Clr(fd);; 1176 }; 1177 }; 1178 }; 1179}; 1180 ; 1181////////////////////////////////////////////////////////////////////////////////; 1182/// Sleep milliSec milliseconds.; 1183 ; 1184void TUnixSystem::Sleep(UInt_t milliSec); 1185{; 1186 struct timeval tv;; 1187 ; 1188 tv.tv_sec = milliSec / 1000;; 1189 tv.tv_usec = (milliSec % 1000) * 1000;; 1190 ; 1191 select(0, nullptr, nullptr, nullptr, &tv);; 1192}; 1193 ; 1194////////////////////////////////////////////////////////////////////////////////; 1195/// Select on file descriptors. The timeout to is in millisec. Returns; 1196/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 1197/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 1198/// the errno has been reset and the method can be called again. Returns; 1199/// -4 in case the list did not contain any file handlers or file handlers; 1200/// with file descriptor >= 0.; 1201 ; 1202Int_t TUnixSystem::Select(TList *act, Long_t to); 1203{; 1204 Int_t rc = -4;; 1205 ; 1206 TFdSet rd, wr;; 1207 Int_t mxfd = -1;; 1208 TIter next(act);; 1209 TFileHandler *h = nullptr;; 1210 while ((h = (TFileHandler *) next())) {; 1211 Int_t fd = h->GetFd();; 1212 if (fd > -1) {; 1213 if (h->HasReadInterest()) {; 1214 rd.Set(fd);; 1215 mxfd = TMath::Max(mxfd, fd);; 1216 }; 1217 if (h->HasWriteInterest()) {; 1218 wr.Set(fd);; 1219 mxfd = TMath::Max(mxfd, fd);; 1220 }; 1221 h->ResetReadyMask();; 1222 }; 1223 }; 1224 if (mxfd > -1); 1225 rc = UnixSelect(mxfd+1, &rd, &wr, to);; 1226 ; 1227 // Set readiness bits; 1228 if (rc > 0) {; 1229 next.Reset();; 1230 while ((h = (TFileHandler *) next())) {; 1",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:38159,Availability,error,error,38159,"t);; 1209 TFileHandler *h = nullptr;; 1210 while ((h = (TFileHandler *) next())) {; 1211 Int_t fd = h->GetFd();; 1212 if (fd > -1) {; 1213 if (h->HasReadInterest()) {; 1214 rd.Set(fd);; 1215 mxfd = TMath::Max(mxfd, fd);; 1216 }; 1217 if (h->HasWriteInterest()) {; 1218 wr.Set(fd);; 1219 mxfd = TMath::Max(mxfd, fd);; 1220 }; 1221 h->ResetReadyMask();; 1222 }; 1223 }; 1224 if (mxfd > -1); 1225 rc = UnixSelect(mxfd+1, &rd, &wr, to);; 1226 ; 1227 // Set readiness bits; 1228 if (rc > 0) {; 1229 next.Reset();; 1230 while ((h = (TFileHandler *) next())) {; 1231 Int_t fd = h->GetFd();; 1232 if (rd.IsSet(fd)); 1233 h->SetReadReady();; 1234 if (wr.IsSet(fd)); 1235 h->SetWriteReady();; 1236 }; 1237 }; 1238 ; 1239 return rc;; 1240}; 1241 ; 1242////////////////////////////////////////////////////////////////////////////////; 1243/// Select on the file descriptor related to file handler h.; 1244/// The timeout to is in millisec. Returns the number of ready descriptors,; 1245/// or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; 1246/// and -3 EBADF. In case of EINTR the errno has been reset and the method; 1247/// can be called again. Returns -4 in case the file handler is 0 or does; 1248/// not have a file descriptor >= 0.; 1249 ; 1250Int_t TUnixSystem::Select(TFileHandler *h, Long_t to); 1251{; 1252 Int_t rc = -4;; 1253 ; 1254 TFdSet rd, wr;; 1255 Int_t mxfd = -1;; 1256 Int_t fd = -1;; 1257 if (h) {; 1258 fd = h->GetFd();; 1259 if (fd > -1) {; 1260 if (h->HasReadInterest()); 1261 rd.Set(fd);; 1262 if (h->HasWriteInterest()); 1263 wr.Set(fd);; 1264 h->ResetReadyMask();; 1265 mxfd = fd;; 1266 rc = UnixSelect(mxfd+1, &rd, &wr, to);; 1267 }; 1268 }; 1269 ; 1270 // Fill output lists, if required; 1271 if (rc > 0) {; 1272 if (rd.IsSet(fd)); 1273 h->SetReadReady();; 1274 if (wr.IsSet(fd)); 1275 h->SetWriteReady();; 1276 }; 1277 ; 1278 return rc;; 1279}; 1280 ; 1281//---- handling of system events -----------------------------------------------; 1282 ; 1283///////",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:46514,Availability,error,error,46514,"/////////////////////////////////////////////////////////////////////////////; 1500/// Return a user configured or systemwide directory to create; 1501/// temporary files in.; 1502 ; 1503const char *TUnixSystem::TempDirectory() const; 1504{; 1505 const char *dir = gSystem->Getenv(""TMPDIR"");; 1506 if (!dir || gSystem->AccessPathName(dir, kWritePermission)); 1507 dir = ""/tmp"";; 1508 ; 1509 return dir;; 1510}; 1511 ; 1512////////////////////////////////////////////////////////////////////////////////; 1513/// Create a secure temporary file by appending a unique; 1514/// 6 letter string to base. The file will be created in; 1515/// a standard (system) directory or in the directory; 1516/// provided in dir. Optionally one can provide suffix; 1517/// append to the final name - like extension "".txt"" or "".html"".; 1518/// The full filename is returned in base; 1519/// and a filepointer is returned for safely writing to the file; 1520/// (this avoids certain security problems). Returns 0 in case; 1521/// of error.; 1522 ; 1523FILE *TUnixSystem::TempFileName(TString &base, const char *dir, const char *suffix); 1524{; 1525 char *b = ConcatFileName(dir ? dir : TempDirectory(), base);; 1526 base = b;; 1527 base += ""XXXXXX"";; 1528 const bool hasSuffix = suffix && *suffix;; 1529 if (hasSuffix); 1530 base.Append(suffix);; 1531 delete [] b;; 1532 ; 1533 char *arg = StrDup(base);; 1534 int fd = hasSuffix ? mkstemps(arg, strlen(suffix)) : mkstemp(arg);; 1535 base = arg;; 1536 delete [] arg;; 1537 ; 1538 if (fd == -1) {; 1539 SysError(""TempFileName"", ""%s"", base.Data());; 1540 return nullptr;; 1541 } else {; 1542 FILE *fp = fdopen(fd, ""w+"");; 1543 if (!fp); 1544 SysError(""TempFileName"", ""converting filedescriptor (%d)"", fd);; 1545 return fp;; 1546 }; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// Concatenate a directory and a file name.; 1551 ; 1552const char *TUnixSystem::PrependPathName(const char *dir, TString& name); 1553{; ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:48887,Availability,failure,failure,48887,"----------------------------------------------------------; 1573 ; 1574////////////////////////////////////////////////////////////////////////////////; 1575/// Returns FALSE if one can access a file using the specified access mode.; 1576/// Mode is the same as for the Unix access(2) function.; 1577/// Attention, bizarre convention of return value!!; 1578 ; 1579Bool_t TUnixSystem::AccessPathName(const char *path, EAccessMode mode); 1580{; 1581 TSystem *helper = FindHelper(path);; 1582 if (helper); 1583 return helper->AccessPathName(path, mode);; 1584 ; 1585 if (::access(StripOffProto(path, ""file:""), mode) == 0); 1586 return kFALSE;; 1587 GetLastErrorString() = GetError();; 1588 ; 1589 return kTRUE;; 1590}; 1591 ; 1592////////////////////////////////////////////////////////////////////////////////; 1593/// Copy a file. If overwrite is true and file already exists the; 1594/// file will be overwritten. Returns 0 when successful, -1 in case; 1595/// of file open failure, -2 in case the file already exists and overwrite; 1596/// was false and -3 in case of error during copy.; 1597 ; 1598int TUnixSystem::CopyFile(const char *f, const char *t, Bool_t overwrite); 1599{; 1600 if (!AccessPathName(t) && !overwrite); 1601 return -2;; 1602 ; 1603 FILE *from = fopen(f, ""r"");; 1604 if (!from); 1605 return -1;; 1606 ; 1607 FILE *to = fopen(t, ""w"");; 1608 if (!to) {; 1609 fclose(from);; 1610 return -1;; 1611 }; 1612 ; 1613 const int bufsize = 1024;; 1614 char buf[bufsize];; 1615 int ret = 0;; 1616 while (!ret && !feof(from)) {; 1617 size_t numread = fread (buf, sizeof(char), bufsize, from);; 1618 size_t numwritten = fwrite(buf, sizeof(char), numread, to);; 1619 if (numread != numwritten); 1620 ret = -3;; 1621 }; 1622 ; 1623 fclose(from);; 1624 fclose(to);; 1625 ; 1626 return ret;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Rename a file. Returns 0 when successful, -1 in case of failure.; 1631 ; 1632int TUnixSystem::Re",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:48982,Availability,error,error,48982,"----------------------------------------------------------; 1573 ; 1574////////////////////////////////////////////////////////////////////////////////; 1575/// Returns FALSE if one can access a file using the specified access mode.; 1576/// Mode is the same as for the Unix access(2) function.; 1577/// Attention, bizarre convention of return value!!; 1578 ; 1579Bool_t TUnixSystem::AccessPathName(const char *path, EAccessMode mode); 1580{; 1581 TSystem *helper = FindHelper(path);; 1582 if (helper); 1583 return helper->AccessPathName(path, mode);; 1584 ; 1585 if (::access(StripOffProto(path, ""file:""), mode) == 0); 1586 return kFALSE;; 1587 GetLastErrorString() = GetError();; 1588 ; 1589 return kTRUE;; 1590}; 1591 ; 1592////////////////////////////////////////////////////////////////////////////////; 1593/// Copy a file. If overwrite is true and file already exists the; 1594/// file will be overwritten. Returns 0 when successful, -1 in case; 1595/// of file open failure, -2 in case the file already exists and overwrite; 1596/// was false and -3 in case of error during copy.; 1597 ; 1598int TUnixSystem::CopyFile(const char *f, const char *t, Bool_t overwrite); 1599{; 1600 if (!AccessPathName(t) && !overwrite); 1601 return -2;; 1602 ; 1603 FILE *from = fopen(f, ""r"");; 1604 if (!from); 1605 return -1;; 1606 ; 1607 FILE *to = fopen(t, ""w"");; 1608 if (!to) {; 1609 fclose(from);; 1610 return -1;; 1611 }; 1612 ; 1613 const int bufsize = 1024;; 1614 char buf[bufsize];; 1615 int ret = 0;; 1616 while (!ret && !feof(from)) {; 1617 size_t numread = fread (buf, sizeof(char), bufsize, from);; 1618 size_t numwritten = fwrite(buf, sizeof(char), numread, to);; 1619 if (numread != numwritten); 1620 ret = -3;; 1621 }; 1622 ; 1623 fclose(from);; 1624 fclose(to);; 1625 ; 1626 return ret;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Rename a file. Returns 0 when successful, -1 in case of failure.; 1631 ; 1632int TUnixSystem::Re",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:49873,Availability,failure,failure,49873," in case; 1595/// of file open failure, -2 in case the file already exists and overwrite; 1596/// was false and -3 in case of error during copy.; 1597 ; 1598int TUnixSystem::CopyFile(const char *f, const char *t, Bool_t overwrite); 1599{; 1600 if (!AccessPathName(t) && !overwrite); 1601 return -2;; 1602 ; 1603 FILE *from = fopen(f, ""r"");; 1604 if (!from); 1605 return -1;; 1606 ; 1607 FILE *to = fopen(t, ""w"");; 1608 if (!to) {; 1609 fclose(from);; 1610 return -1;; 1611 }; 1612 ; 1613 const int bufsize = 1024;; 1614 char buf[bufsize];; 1615 int ret = 0;; 1616 while (!ret && !feof(from)) {; 1617 size_t numread = fread (buf, sizeof(char), bufsize, from);; 1618 size_t numwritten = fwrite(buf, sizeof(char), numread, to);; 1619 if (numread != numwritten); 1620 ret = -3;; 1621 }; 1622 ; 1623 fclose(from);; 1624 fclose(to);; 1625 ; 1626 return ret;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Rename a file. Returns 0 when successful, -1 in case of failure.; 1631 ; 1632int TUnixSystem::Rename(const char *f, const char *t); 1633{; 1634 int ret = ::rename(f, t);; 1635 GetLastErrorString() = GetError();; 1636 return ret;; 1637}; 1638 ; 1639////////////////////////////////////////////////////////////////////////////////; 1640/// Returns TRUE if the url in 'path' points to the local file system.; 1641/// This is used to avoid going through the NIC card for local operations.; 1642 ; 1643Bool_t TUnixSystem::IsPathLocal(const char *path); 1644{; 1645 TSystem *helper = FindHelper(path);; 1646 if (helper); 1647 return helper->IsPathLocal(path);; 1648 ; 1649 return TSystem::IsPathLocal(path);; 1650}; 1651 ; 1652////////////////////////////////////////////////////////////////////////////////; 1653/// Get info about a file. Info is returned in the form of a FileStat_t; 1654/// structure (see TSystem.h).; 1655/// The function returns 0 in case of success and 1 if the file could; 1656/// not be stat'ed.; 1657 ; 1658int TUnixSys",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:51938,Availability,failure,failure,51938,"1660 TSystem *helper = FindHelper(path);; 1661 if (helper); 1662 return helper->GetPathInfo(path, buf);; 1663 ; 1664 return UnixFilestat(path, buf);; 1665}; 1666 ; 1667////////////////////////////////////////////////////////////////////////////////; 1668/// Get info about a file system: id, bsize, bfree, blocks.; 1669/// Id is file system type (machine dependend, see statfs()); 1670/// Bsize is block size of file system; 1671/// Blocks is total number of blocks in file system; 1672/// Bfree is number of free blocks in file system; 1673/// The function returns 0 in case of success and 1 if the file system could; 1674/// not be stat'ed.; 1675 ; 1676int TUnixSystem::GetFsInfo(const char *path, Long_t *id, Long_t *bsize,; 1677 Long_t *blocks, Long_t *bfree); 1678{; 1679 return UnixFSstat(path, id, bsize, blocks, bfree);; 1680}; 1681 ; 1682////////////////////////////////////////////////////////////////////////////////; 1683/// Create a link from file1 to file2. Returns 0 when successful,; 1684/// -1 in case of failure.; 1685 ; 1686int TUnixSystem::Link(const char *from, const char *to); 1687{; 1688 return ::link(from, to);; 1689}; 1690 ; 1691////////////////////////////////////////////////////////////////////////////////; 1692/// Create a symlink from file1 to file2. Returns 0 when successful,; 1693/// -1 in case of failure.; 1694 ; 1695int TUnixSystem::Symlink(const char *from, const char *to); 1696{; 1697#if defined(R__AIX); 1698 return ::symlink((char*)from, (char*)to);; 1699#else; 1700 return ::symlink(from, to);; 1701#endif; 1702}; 1703 ; 1704////////////////////////////////////////////////////////////////////////////////; 1705/// Unlink, i.e. remove, a file or directory. Returns 0 when successful,; 1706/// -1 in case of failure.; 1707 ; 1708int TUnixSystem::Unlink(const char *name); 1709{; 1710 TSystem *helper = FindHelper(name);; 1711 if (helper); 1712 return helper->Unlink(name);; 1713 ; 1714#if defined(R__SEEK64); 1715 struct stat64 finfo;; 1716 if (lstat64(name",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:52250,Availability,failure,failure,52250,".; 1669/// Id is file system type (machine dependend, see statfs()); 1670/// Bsize is block size of file system; 1671/// Blocks is total number of blocks in file system; 1672/// Bfree is number of free blocks in file system; 1673/// The function returns 0 in case of success and 1 if the file system could; 1674/// not be stat'ed.; 1675 ; 1676int TUnixSystem::GetFsInfo(const char *path, Long_t *id, Long_t *bsize,; 1677 Long_t *blocks, Long_t *bfree); 1678{; 1679 return UnixFSstat(path, id, bsize, blocks, bfree);; 1680}; 1681 ; 1682////////////////////////////////////////////////////////////////////////////////; 1683/// Create a link from file1 to file2. Returns 0 when successful,; 1684/// -1 in case of failure.; 1685 ; 1686int TUnixSystem::Link(const char *from, const char *to); 1687{; 1688 return ::link(from, to);; 1689}; 1690 ; 1691////////////////////////////////////////////////////////////////////////////////; 1692/// Create a symlink from file1 to file2. Returns 0 when successful,; 1693/// -1 in case of failure.; 1694 ; 1695int TUnixSystem::Symlink(const char *from, const char *to); 1696{; 1697#if defined(R__AIX); 1698 return ::symlink((char*)from, (char*)to);; 1699#else; 1700 return ::symlink(from, to);; 1701#endif; 1702}; 1703 ; 1704////////////////////////////////////////////////////////////////////////////////; 1705/// Unlink, i.e. remove, a file or directory. Returns 0 when successful,; 1706/// -1 in case of failure.; 1707 ; 1708int TUnixSystem::Unlink(const char *name); 1709{; 1710 TSystem *helper = FindHelper(name);; 1711 if (helper); 1712 return helper->Unlink(name);; 1713 ; 1714#if defined(R__SEEK64); 1715 struct stat64 finfo;; 1716 if (lstat64(name, &finfo) < 0); 1717#else; 1718 struct stat finfo;; 1719 if (lstat(name, &finfo) < 0); 1720#endif; 1721 return -1;; 1722 ; 1723 if (S_ISDIR(finfo.st_mode)); 1724 return ::rmdir(name);; 1725 else; 1726 return ::unlink(name);; 1727}; 1728 ; 1729//---- expand the metacharacters as in the shell --------------------",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:52668,Availability,failure,failure,52668,"77 Long_t *blocks, Long_t *bfree); 1678{; 1679 return UnixFSstat(path, id, bsize, blocks, bfree);; 1680}; 1681 ; 1682////////////////////////////////////////////////////////////////////////////////; 1683/// Create a link from file1 to file2. Returns 0 when successful,; 1684/// -1 in case of failure.; 1685 ; 1686int TUnixSystem::Link(const char *from, const char *to); 1687{; 1688 return ::link(from, to);; 1689}; 1690 ; 1691////////////////////////////////////////////////////////////////////////////////; 1692/// Create a symlink from file1 to file2. Returns 0 when successful,; 1693/// -1 in case of failure.; 1694 ; 1695int TUnixSystem::Symlink(const char *from, const char *to); 1696{; 1697#if defined(R__AIX); 1698 return ::symlink((char*)from, (char*)to);; 1699#else; 1700 return ::symlink(from, to);; 1701#endif; 1702}; 1703 ; 1704////////////////////////////////////////////////////////////////////////////////; 1705/// Unlink, i.e. remove, a file or directory. Returns 0 when successful,; 1706/// -1 in case of failure.; 1707 ; 1708int TUnixSystem::Unlink(const char *name); 1709{; 1710 TSystem *helper = FindHelper(name);; 1711 if (helper); 1712 return helper->Unlink(name);; 1713 ; 1714#if defined(R__SEEK64); 1715 struct stat64 finfo;; 1716 if (lstat64(name, &finfo) < 0); 1717#else; 1718 struct stat finfo;; 1719 if (lstat(name, &finfo) < 0); 1720#endif; 1721 return -1;; 1722 ; 1723 if (S_ISDIR(finfo.st_mode)); 1724 return ::rmdir(name);; 1725 else; 1726 return ::unlink(name);; 1727}; 1728 ; 1729//---- expand the metacharacters as in the shell -------------------------------; 1730 ; 1731// expand the metacharacters as in the shell; 1732 ; 1733const char; 1734#ifdef G__OLDEXPAND; 1735 kShellEscape = '\\',; 1736 *kShellStuff = ""(){}<>\""'"",; 1737#endif; 1738 *kShellMeta = ""~*[]{}?$"";; 1739 ; 1740 ; 1741#ifndef G__OLDEXPAND; 1742////////////////////////////////////////////////////////////////////////////////; 1743/// Expand a pathname getting rid of special shell characters lik",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:53921,Availability,error,error,53921,"o;; 1716 if (lstat64(name, &finfo) < 0); 1717#else; 1718 struct stat finfo;; 1719 if (lstat(name, &finfo) < 0); 1720#endif; 1721 return -1;; 1722 ; 1723 if (S_ISDIR(finfo.st_mode)); 1724 return ::rmdir(name);; 1725 else; 1726 return ::unlink(name);; 1727}; 1728 ; 1729//---- expand the metacharacters as in the shell -------------------------------; 1730 ; 1731// expand the metacharacters as in the shell; 1732 ; 1733const char; 1734#ifdef G__OLDEXPAND; 1735 kShellEscape = '\\',; 1736 *kShellStuff = ""(){}<>\""'"",; 1737#endif; 1738 *kShellMeta = ""~*[]{}?$"";; 1739 ; 1740 ; 1741#ifndef G__OLDEXPAND; 1742////////////////////////////////////////////////////////////////////////////////; 1743/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1744/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1745/// environment variables in a pathname. If compatibility is not an issue; 1746/// you can use on Unix directly $XXX. Returns kFALSE in case of success; 1747/// or kTRUE in case of error.; 1748 ; 1749Bool_t TUnixSystem::ExpandPathName(TString &path); 1750{; 1751 const char *p, *patbuf = (const char *)path;; 1752 ; 1753 // skip leading blanks; 1754 while (*patbuf == ' '); 1755 patbuf++;; 1756 ; 1757 // any shell meta characters ?; 1758 for (p = patbuf; *p; p++); 1759 if (strchr(kShellMeta, *p)); 1760 goto expand;; 1761 ; 1762 return kFALSE;; 1763 ; 1764expand:; 1765 // replace $(XXX) by $XXX; 1766 path.ReplaceAll(""$("",""$"");; 1767 path.ReplaceAll("")"","""");; 1768 ; 1769 return ExpandFileName(path);; 1770}; 1771#endif; 1772 ; 1773#ifdef G__OLDEXPAND; 1774////////////////////////////////////////////////////////////////////////////////; 1775/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1776/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1777/// environment variables in a pathname. If compatibility is not an issue; 1778/// you can use on Unix directly $XXX. Returns kFALSE in case of succ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:54925,Availability,error,error,54925,"7/// or kTRUE in case of error.; 1748 ; 1749Bool_t TUnixSystem::ExpandPathName(TString &path); 1750{; 1751 const char *p, *patbuf = (const char *)path;; 1752 ; 1753 // skip leading blanks; 1754 while (*patbuf == ' '); 1755 patbuf++;; 1756 ; 1757 // any shell meta characters ?; 1758 for (p = patbuf; *p; p++); 1759 if (strchr(kShellMeta, *p)); 1760 goto expand;; 1761 ; 1762 return kFALSE;; 1763 ; 1764expand:; 1765 // replace $(XXX) by $XXX; 1766 path.ReplaceAll(""$("",""$"");; 1767 path.ReplaceAll("")"","""");; 1768 ; 1769 return ExpandFileName(path);; 1770}; 1771#endif; 1772 ; 1773#ifdef G__OLDEXPAND; 1774////////////////////////////////////////////////////////////////////////////////; 1775/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1776/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1777/// environment variables in a pathname. If compatibility is not an issue; 1778/// you can use on Unix directly $XXX. Returns kFALSE in case of success; 1779/// or kTRUE in case of error.; 1780 ; 1781Bool_t TUnixSystem::ExpandPathName(TString &patbuf0); 1782{; 1783 const char *patbuf = (const char *)patbuf0;; 1784 const char *hd, *p;; 1785 // char cmd[kMAXPATHLEN],; 1786 char stuffedPat[kMAXPATHLEN], name[70];; 1787 char *q;; 1788 FILE *pf;; 1789 int ch;; 1790 ; 1791 // skip leading blanks; 1792 while (*patbuf == ' '); 1793 patbuf++;; 1794 ; 1795 // any shell meta characters ?; 1796 for (p = patbuf; *p; p++); 1797 if (strchr(kShellMeta, *p)); 1798 goto needshell;; 1799 ; 1800 return kFALSE;; 1801 ; 1802needshell:; 1803 // replace $(XXX) by $XXX; 1804 patbuf0.ReplaceAll(""$("",""$"");; 1805 patbuf0.ReplaceAll("")"","""");; 1806 ; 1807 // escape shell quote characters; 1808 EscChar(patbuf, stuffedPat, sizeof(stuffedPat), (char*)kShellStuff, kShellEscape);; 1809 ; 1810 TString cmd(""echo "");; 1811 ; 1812 // emulate csh -> popen executes sh; 1813 if (stuffedPat[0] == '~') {; 1814 if (stuffedPat[1] != '\0' && stuffedPat[1] != '/') {; 1815 // extrac",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:55730,Availability,echo,echo,55730,"Name(TString &patbuf0); 1782{; 1783 const char *patbuf = (const char *)patbuf0;; 1784 const char *hd, *p;; 1785 // char cmd[kMAXPATHLEN],; 1786 char stuffedPat[kMAXPATHLEN], name[70];; 1787 char *q;; 1788 FILE *pf;; 1789 int ch;; 1790 ; 1791 // skip leading blanks; 1792 while (*patbuf == ' '); 1793 patbuf++;; 1794 ; 1795 // any shell meta characters ?; 1796 for (p = patbuf; *p; p++); 1797 if (strchr(kShellMeta, *p)); 1798 goto needshell;; 1799 ; 1800 return kFALSE;; 1801 ; 1802needshell:; 1803 // replace $(XXX) by $XXX; 1804 patbuf0.ReplaceAll(""$("",""$"");; 1805 patbuf0.ReplaceAll("")"","""");; 1806 ; 1807 // escape shell quote characters; 1808 EscChar(patbuf, stuffedPat, sizeof(stuffedPat), (char*)kShellStuff, kShellEscape);; 1809 ; 1810 TString cmd(""echo "");; 1811 ; 1812 // emulate csh -> popen executes sh; 1813 if (stuffedPat[0] == '~') {; 1814 if (stuffedPat[1] != '\0' && stuffedPat[1] != '/') {; 1815 // extract user name; 1816 for (p = &stuffedPat[1], q = name; *p && *p !='/';); 1817 *q++ = *p++;; 1818 *q = '\0';; 1819 hd = UnixHomedirectory(name);; 1820 if (!hd); 1821 cmd += stuffedPat;; 1822 else {; 1823 cmd += hd;; 1824 cmd += p;; 1825 }; 1826 } else {; 1827 hd = UnixHomedirectory(nullptr);; 1828 if (!hd) {; 1829 GetLastErrorString() = GetError();; 1830 return kTRUE;; 1831 }; 1832 cmd += hd;; 1833 cmd += &stuffedPat[1];; 1834 }; 1835 } else; 1836 cmd += stuffedPat;; 1837 ; 1838 if ((pf = ::popen(cmd.Data(), ""r"")) == 0) {; 1839 GetLastErrorString() = GetError();; 1840 return kTRUE;; 1841 }; 1842 ; 1843 // read first argument; 1844 patbuf0 = """";; 1845 int cnt = 0;; 1846#if defined(R__AIX); 1847again:; 1848#endif; 1849 for (ch = fgetc(pf); ch != EOF && ch != ' ' && ch != '\n'; ch = fgetc(pf)) {; 1850 patbuf0.Append(ch);; 1851 cnt++;; 1852 }; 1853#if defined(R__AIX); 1854 // Work around bug timing problem due to delay in forking a large program; 1855 if (cnt == 0 && ch == EOF) goto again;; 1856#endif; 1857 ; 1858 // skip rest of pipe; 1859 while (ch != EOF) {; 1860 ch",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:57675,Availability,error,error,57675," && ch != ' ' && ch != '\n'; ch = fgetc(pf)) {; 1850 patbuf0.Append(ch);; 1851 cnt++;; 1852 }; 1853#if defined(R__AIX); 1854 // Work around bug timing problem due to delay in forking a large program; 1855 if (cnt == 0 && ch == EOF) goto again;; 1856#endif; 1857 ; 1858 // skip rest of pipe; 1859 while (ch != EOF) {; 1860 ch = fgetc(pf);; 1861 if (ch == ' ' || ch == '\t') {; 1862 GetLastErrorString() = ""expression ambigous"";; 1863 ::pclose(pf);; 1864 return kTRUE;; 1865 }; 1866 }; 1867 ; 1868 ::pclose(pf);; 1869 ; 1870 return kFALSE;; 1871}; 1872#endif; 1873 ; 1874////////////////////////////////////////////////////////////////////////////////; 1875/// Expand a pathname getting rid of special shell characaters like ~.$, etc.; 1876/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1877/// environment variables in a pathname. If compatibility is not an issue; 1878/// you can use on Unix directly $XXX. The user must delete returned string.; 1879/// Returns the expanded pathname or 0 in case of error.; 1880/// The user must delete returned string (delete []).; 1881 ; 1882char *TUnixSystem::ExpandPathName(const char *path); 1883{; 1884 TString patbuf = path;; 1885 if (ExpandPathName(patbuf)); 1886 return nullptr;; 1887 return StrDup(patbuf.Data());; 1888}; 1889 ; 1890////////////////////////////////////////////////////////////////////////////////; 1891/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1892 ; 1893int TUnixSystem::Chmod(const char *file, UInt_t mode); 1894{; 1895 return ::chmod(file, mode);; 1896}; 1897 ; 1898////////////////////////////////////////////////////////////////////////////////; 1899/// Set the process file creation mode mask.; 1900 ; 1901int TUnixSystem::Umask(Int_t mask); 1902{; 1903 return ::umask(mask);; 1904}; 1905 ; 1906////////////////////////////////////////////////////////////////////////////////; 1907/// Set a files modification and access times. If actime = 0 it will be; 1908/// set to the ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:58094,Availability,error,error,58094,"pf);; 1864 return kTRUE;; 1865 }; 1866 }; 1867 ; 1868 ::pclose(pf);; 1869 ; 1870 return kFALSE;; 1871}; 1872#endif; 1873 ; 1874////////////////////////////////////////////////////////////////////////////////; 1875/// Expand a pathname getting rid of special shell characaters like ~.$, etc.; 1876/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1877/// environment variables in a pathname. If compatibility is not an issue; 1878/// you can use on Unix directly $XXX. The user must delete returned string.; 1879/// Returns the expanded pathname or 0 in case of error.; 1880/// The user must delete returned string (delete []).; 1881 ; 1882char *TUnixSystem::ExpandPathName(const char *path); 1883{; 1884 TString patbuf = path;; 1885 if (ExpandPathName(patbuf)); 1886 return nullptr;; 1887 return StrDup(patbuf.Data());; 1888}; 1889 ; 1890////////////////////////////////////////////////////////////////////////////////; 1891/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1892 ; 1893int TUnixSystem::Chmod(const char *file, UInt_t mode); 1894{; 1895 return ::chmod(file, mode);; 1896}; 1897 ; 1898////////////////////////////////////////////////////////////////////////////////; 1899/// Set the process file creation mode mask.; 1900 ; 1901int TUnixSystem::Umask(Int_t mask); 1902{; 1903 return ::umask(mask);; 1904}; 1905 ; 1906////////////////////////////////////////////////////////////////////////////////; 1907/// Set a files modification and access times. If actime = 0 it will be; 1908/// set to the modtime. Returns 0 on success and -1 in case of error.; 1909 ; 1910int TUnixSystem::Utime(const char *file, Long_t modtime, Long_t actime); 1911{; 1912 if (!actime); 1913 actime = modtime;; 1914 ; 1915 struct utimbuf t;; 1916 t.actime = (time_t)actime;; 1917 t.modtime = (time_t)modtime;; 1918 return ::utime(file, &t);; 1919}; 1920 ; 1921////////////////////////////////////////////////////////////////////////////////; 1922/// Find location",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:58365,Availability,mask,mask,58365,"//////////////////////////////////////////////////////////; 1875/// Expand a pathname getting rid of special shell characaters like ~.$, etc.; 1876/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1877/// environment variables in a pathname. If compatibility is not an issue; 1878/// you can use on Unix directly $XXX. The user must delete returned string.; 1879/// Returns the expanded pathname or 0 in case of error.; 1880/// The user must delete returned string (delete []).; 1881 ; 1882char *TUnixSystem::ExpandPathName(const char *path); 1883{; 1884 TString patbuf = path;; 1885 if (ExpandPathName(patbuf)); 1886 return nullptr;; 1887 return StrDup(patbuf.Data());; 1888}; 1889 ; 1890////////////////////////////////////////////////////////////////////////////////; 1891/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1892 ; 1893int TUnixSystem::Chmod(const char *file, UInt_t mode); 1894{; 1895 return ::chmod(file, mode);; 1896}; 1897 ; 1898////////////////////////////////////////////////////////////////////////////////; 1899/// Set the process file creation mode mask.; 1900 ; 1901int TUnixSystem::Umask(Int_t mask); 1902{; 1903 return ::umask(mask);; 1904}; 1905 ; 1906////////////////////////////////////////////////////////////////////////////////; 1907/// Set a files modification and access times. If actime = 0 it will be; 1908/// set to the modtime. Returns 0 on success and -1 in case of error.; 1909 ; 1910int TUnixSystem::Utime(const char *file, Long_t modtime, Long_t actime); 1911{; 1912 if (!actime); 1913 actime = modtime;; 1914 ; 1915 struct utimbuf t;; 1916 t.actime = (time_t)actime;; 1917 t.modtime = (time_t)modtime;; 1918 return ::utime(file, &t);; 1919}; 1920 ; 1921////////////////////////////////////////////////////////////////////////////////; 1922/// Find location of file ""wfil"" in a search path.; 1923/// The search path is specified as a : separated list of directories.; 1924/// Return value is pointing to wfi",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:58412,Availability,mask,mask,58412,"es in a pathname. If compatibility is not an issue; 1878/// you can use on Unix directly $XXX. The user must delete returned string.; 1879/// Returns the expanded pathname or 0 in case of error.; 1880/// The user must delete returned string (delete []).; 1881 ; 1882char *TUnixSystem::ExpandPathName(const char *path); 1883{; 1884 TString patbuf = path;; 1885 if (ExpandPathName(patbuf)); 1886 return nullptr;; 1887 return StrDup(patbuf.Data());; 1888}; 1889 ; 1890////////////////////////////////////////////////////////////////////////////////; 1891/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1892 ; 1893int TUnixSystem::Chmod(const char *file, UInt_t mode); 1894{; 1895 return ::chmod(file, mode);; 1896}; 1897 ; 1898////////////////////////////////////////////////////////////////////////////////; 1899/// Set the process file creation mode mask.; 1900 ; 1901int TUnixSystem::Umask(Int_t mask); 1902{; 1903 return ::umask(mask);; 1904}; 1905 ; 1906////////////////////////////////////////////////////////////////////////////////; 1907/// Set a files modification and access times. If actime = 0 it will be; 1908/// set to the modtime. Returns 0 on success and -1 in case of error.; 1909 ; 1910int TUnixSystem::Utime(const char *file, Long_t modtime, Long_t actime); 1911{; 1912 if (!actime); 1913 actime = modtime;; 1914 ; 1915 struct utimbuf t;; 1916 t.actime = (time_t)actime;; 1917 t.modtime = (time_t)modtime;; 1918 return ::utime(file, &t);; 1919}; 1920 ; 1921////////////////////////////////////////////////////////////////////////////////; 1922/// Find location of file ""wfil"" in a search path.; 1923/// The search path is specified as a : separated list of directories.; 1924/// Return value is pointing to wfile for compatibility with; 1925/// Which(const char*,const char*,EAccessMode) version.; 1926 ; 1927const char *TUnixSystem::FindFile(const char *search, TString& wfil, EAccessMode mode); 1928{; 1929 TString show;; 1930 if (gEnv->GetValue(""Root.S",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:58446,Availability,mask,mask,58446,"es in a pathname. If compatibility is not an issue; 1878/// you can use on Unix directly $XXX. The user must delete returned string.; 1879/// Returns the expanded pathname or 0 in case of error.; 1880/// The user must delete returned string (delete []).; 1881 ; 1882char *TUnixSystem::ExpandPathName(const char *path); 1883{; 1884 TString patbuf = path;; 1885 if (ExpandPathName(patbuf)); 1886 return nullptr;; 1887 return StrDup(patbuf.Data());; 1888}; 1889 ; 1890////////////////////////////////////////////////////////////////////////////////; 1891/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1892 ; 1893int TUnixSystem::Chmod(const char *file, UInt_t mode); 1894{; 1895 return ::chmod(file, mode);; 1896}; 1897 ; 1898////////////////////////////////////////////////////////////////////////////////; 1899/// Set the process file creation mode mask.; 1900 ; 1901int TUnixSystem::Umask(Int_t mask); 1902{; 1903 return ::umask(mask);; 1904}; 1905 ; 1906////////////////////////////////////////////////////////////////////////////////; 1907/// Set a files modification and access times. If actime = 0 it will be; 1908/// set to the modtime. Returns 0 on success and -1 in case of error.; 1909 ; 1910int TUnixSystem::Utime(const char *file, Long_t modtime, Long_t actime); 1911{; 1912 if (!actime); 1913 actime = modtime;; 1914 ; 1915 struct utimbuf t;; 1916 t.actime = (time_t)actime;; 1917 t.modtime = (time_t)modtime;; 1918 return ::utime(file, &t);; 1919}; 1920 ; 1921////////////////////////////////////////////////////////////////////////////////; 1922/// Find location of file ""wfil"" in a search path.; 1923/// The search path is specified as a : separated list of directories.; 1924/// Return value is pointing to wfile for compatibility with; 1925/// Which(const char*,const char*,EAccessMode) version.; 1926 ; 1927const char *TUnixSystem::FindFile(const char *search, TString& wfil, EAccessMode mode); 1928{; 1929 TString show;; 1930 if (gEnv->GetValue(""Root.S",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:58698,Availability,error,error,58698,"; 1880/// The user must delete returned string (delete []).; 1881 ; 1882char *TUnixSystem::ExpandPathName(const char *path); 1883{; 1884 TString patbuf = path;; 1885 if (ExpandPathName(patbuf)); 1886 return nullptr;; 1887 return StrDup(patbuf.Data());; 1888}; 1889 ; 1890////////////////////////////////////////////////////////////////////////////////; 1891/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1892 ; 1893int TUnixSystem::Chmod(const char *file, UInt_t mode); 1894{; 1895 return ::chmod(file, mode);; 1896}; 1897 ; 1898////////////////////////////////////////////////////////////////////////////////; 1899/// Set the process file creation mode mask.; 1900 ; 1901int TUnixSystem::Umask(Int_t mask); 1902{; 1903 return ::umask(mask);; 1904}; 1905 ; 1906////////////////////////////////////////////////////////////////////////////////; 1907/// Set a files modification and access times. If actime = 0 it will be; 1908/// set to the modtime. Returns 0 on success and -1 in case of error.; 1909 ; 1910int TUnixSystem::Utime(const char *file, Long_t modtime, Long_t actime); 1911{; 1912 if (!actime); 1913 actime = modtime;; 1914 ; 1915 struct utimbuf t;; 1916 t.actime = (time_t)actime;; 1917 t.modtime = (time_t)modtime;; 1918 return ::utime(file, &t);; 1919}; 1920 ; 1921////////////////////////////////////////////////////////////////////////////////; 1922/// Find location of file ""wfil"" in a search path.; 1923/// The search path is specified as a : separated list of directories.; 1924/// Return value is pointing to wfile for compatibility with; 1925/// Which(const char*,const char*,EAccessMode) version.; 1926 ; 1927const char *TUnixSystem::FindFile(const char *search, TString& wfil, EAccessMode mode); 1928{; 1929 TString show;; 1930 if (gEnv->GetValue(""Root.ShowPath"", 0)); 1931 show.Form(""Which: %s ="", wfil.Data());; 1932 ; 1933 gSystem->ExpandPathName(wfil);; 1934 ; 1935 if (wfil[0] == '/') {; 1936#if defined(R__SEEK64); 1937 struct stat64 finfo;; ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:63122,Availability,error,error,63122,"id(); 2022{; 2023 return geteuid();; 2024}; 2025 ; 2026////////////////////////////////////////////////////////////////////////////////; 2027/// Returns the group's id. If group = 0, returns current user's group.; 2028 ; 2029Int_t TUnixSystem::GetGid(const char *group); 2030{; 2031 if (!group || !group[0]); 2032 return getgid();; 2033 else {; 2034 struct group *grp = getgrnam(group);; 2035 if (grp); 2036 return grp->gr_gid;; 2037 }; 2038 return 0;; 2039}; 2040 ; 2041////////////////////////////////////////////////////////////////////////////////; 2042/// Returns the effective group id. The effective group id corresponds; 2043/// to the set id bit on the file being executed.; 2044 ; 2045Int_t TUnixSystem::GetEffectiveGid(); 2046{; 2047 return getegid();; 2048}; 2049 ; 2050////////////////////////////////////////////////////////////////////////////////; 2051/// Returns all user info in the UserGroup_t structure. The returned; 2052/// structure must be deleted by the user. In case of error 0 is returned.; 2053 ; 2054UserGroup_t *TUnixSystem::GetUserInfo(Int_t uid); 2055{; 2056 typedef std::map<Int_t /*uid*/, UserGroup_t> UserInfoCache_t;; 2057 static UserInfoCache_t gUserInfo;; 2058 ; 2059 UserInfoCache_t::const_iterator iUserInfo = gUserInfo.find(uid);; 2060 if (iUserInfo != gUserInfo.end()); 2061 return new UserGroup_t(iUserInfo->second);; 2062 ; 2063 struct passwd *apwd = getpwuid(uid);; 2064 if (apwd) {; 2065 UserGroup_t *ug = new UserGroup_t;; 2066 ug->fUid = apwd->pw_uid;; 2067 ug->fGid = apwd->pw_gid;; 2068 ug->fUser = apwd->pw_name;; 2069 ug->fPasswd = apwd->pw_passwd;; 2070 ug->fRealName = apwd->pw_gecos;; 2071 ug->fShell = apwd->pw_shell;; 2072 UserGroup_t *gr = GetGroupInfo(apwd->pw_gid);; 2073 if (gr) ug->fGroup = gr->fGroup;; 2074 delete gr;; 2075 ; 2076 gUserInfo[uid] = *ug;; 2077 return ug;; 2078 }; 2079 return nullptr;; 2080}; 2081 ; 2082////////////////////////////////////////////////////////////////////////////////; 2083/// Returns all user info in th",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:64277,Availability,error,error,64277,"057 static UserInfoCache_t gUserInfo;; 2058 ; 2059 UserInfoCache_t::const_iterator iUserInfo = gUserInfo.find(uid);; 2060 if (iUserInfo != gUserInfo.end()); 2061 return new UserGroup_t(iUserInfo->second);; 2062 ; 2063 struct passwd *apwd = getpwuid(uid);; 2064 if (apwd) {; 2065 UserGroup_t *ug = new UserGroup_t;; 2066 ug->fUid = apwd->pw_uid;; 2067 ug->fGid = apwd->pw_gid;; 2068 ug->fUser = apwd->pw_name;; 2069 ug->fPasswd = apwd->pw_passwd;; 2070 ug->fRealName = apwd->pw_gecos;; 2071 ug->fShell = apwd->pw_shell;; 2072 UserGroup_t *gr = GetGroupInfo(apwd->pw_gid);; 2073 if (gr) ug->fGroup = gr->fGroup;; 2074 delete gr;; 2075 ; 2076 gUserInfo[uid] = *ug;; 2077 return ug;; 2078 }; 2079 return nullptr;; 2080}; 2081 ; 2082////////////////////////////////////////////////////////////////////////////////; 2083/// Returns all user info in the UserGroup_t structure. If user = 0, returns; 2084/// current user's id info. The returned structure must be deleted by the; 2085/// user. In case of error 0 is returned.; 2086 ; 2087UserGroup_t *TUnixSystem::GetUserInfo(const char *user); 2088{; 2089 return GetUserInfo(GetUid(user));; 2090}; 2091 ; 2092////////////////////////////////////////////////////////////////////////////////; 2093/// Returns all group info in the UserGroup_t structure. The only active; 2094/// fields in the UserGroup_t structure for this call are:; 2095/// fGid and fGroup; 2096/// The returned structure must be deleted by the user. In case of; 2097/// error 0 is returned.; 2098 ; 2099UserGroup_t *TUnixSystem::GetGroupInfo(Int_t gid); 2100{; 2101 struct group *grp = getgrgid(gid);; 2102 if (grp) {; 2103 UserGroup_t *gr = new UserGroup_t;; 2104 gr->fUid = 0;; 2105 gr->fGid = grp->gr_gid;; 2106 gr->fGroup = grp->gr_name;; 2107 return gr;; 2108 }; 2109 return nullptr;; 2110}; 2111 ; 2112////////////////////////////////////////////////////////////////////////////////; 2113/// Returns all group info in the UserGroup_t structure. The only active; 2114/// fields in the ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:64761,Availability,error,error,64761,"cos;; 2071 ug->fShell = apwd->pw_shell;; 2072 UserGroup_t *gr = GetGroupInfo(apwd->pw_gid);; 2073 if (gr) ug->fGroup = gr->fGroup;; 2074 delete gr;; 2075 ; 2076 gUserInfo[uid] = *ug;; 2077 return ug;; 2078 }; 2079 return nullptr;; 2080}; 2081 ; 2082////////////////////////////////////////////////////////////////////////////////; 2083/// Returns all user info in the UserGroup_t structure. If user = 0, returns; 2084/// current user's id info. The returned structure must be deleted by the; 2085/// user. In case of error 0 is returned.; 2086 ; 2087UserGroup_t *TUnixSystem::GetUserInfo(const char *user); 2088{; 2089 return GetUserInfo(GetUid(user));; 2090}; 2091 ; 2092////////////////////////////////////////////////////////////////////////////////; 2093/// Returns all group info in the UserGroup_t structure. The only active; 2094/// fields in the UserGroup_t structure for this call are:; 2095/// fGid and fGroup; 2096/// The returned structure must be deleted by the user. In case of; 2097/// error 0 is returned.; 2098 ; 2099UserGroup_t *TUnixSystem::GetGroupInfo(Int_t gid); 2100{; 2101 struct group *grp = getgrgid(gid);; 2102 if (grp) {; 2103 UserGroup_t *gr = new UserGroup_t;; 2104 gr->fUid = 0;; 2105 gr->fGid = grp->gr_gid;; 2106 gr->fGroup = grp->gr_name;; 2107 return gr;; 2108 }; 2109 return nullptr;; 2110}; 2111 ; 2112////////////////////////////////////////////////////////////////////////////////; 2113/// Returns all group info in the UserGroup_t structure. The only active; 2114/// fields in the UserGroup_t structure for this call are:; 2115/// fGid and fGroup; 2116/// If group = 0, returns current user's group. The returned structure; 2117/// must be deleted by the user. In case of error 0 is returned.; 2118 ; 2119UserGroup_t *TUnixSystem::GetGroupInfo(const char *group); 2120{; 2121 return GetGroupInfo(GetGid(group));; 2122}; 2123 ; 2124//---- environment manipulation ------------------------------------------------; 2125 ; 2126/////////////////////////////////////",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:65472,Availability,error,error,65472,"////////////////////////////////////; 2093/// Returns all group info in the UserGroup_t structure. The only active; 2094/// fields in the UserGroup_t structure for this call are:; 2095/// fGid and fGroup; 2096/// The returned structure must be deleted by the user. In case of; 2097/// error 0 is returned.; 2098 ; 2099UserGroup_t *TUnixSystem::GetGroupInfo(Int_t gid); 2100{; 2101 struct group *grp = getgrgid(gid);; 2102 if (grp) {; 2103 UserGroup_t *gr = new UserGroup_t;; 2104 gr->fUid = 0;; 2105 gr->fGid = grp->gr_gid;; 2106 gr->fGroup = grp->gr_name;; 2107 return gr;; 2108 }; 2109 return nullptr;; 2110}; 2111 ; 2112////////////////////////////////////////////////////////////////////////////////; 2113/// Returns all group info in the UserGroup_t structure. The only active; 2114/// fields in the UserGroup_t structure for this call are:; 2115/// fGid and fGroup; 2116/// If group = 0, returns current user's group. The returned structure; 2117/// must be deleted by the user. In case of error 0 is returned.; 2118 ; 2119UserGroup_t *TUnixSystem::GetGroupInfo(const char *group); 2120{; 2121 return GetGroupInfo(GetGid(group));; 2122}; 2123 ; 2124//---- environment manipulation ------------------------------------------------; 2125 ; 2126////////////////////////////////////////////////////////////////////////////////; 2127/// Set environment variable.; 2128 ; 2129void TUnixSystem::Setenv(const char *name, const char *value); 2130{; 2131 ::setenv(name, value, 1);; 2132}; 2133 ; 2134////////////////////////////////////////////////////////////////////////////////; 2135/// Get environment variable.; 2136 ; 2137const char *TUnixSystem::Getenv(const char *name); 2138{; 2139 return ::getenv(name);; 2140}; 2141 ; 2142////////////////////////////////////////////////////////////////////////////////; 2143/// Unset environment variable.; 2144 ; 2145void TUnixSystem::Unsetenv(const char *name); 2146{; 2147 ::unsetenv(name);; 2148}; 2149 ; 2150//---- Processes -----------------------------",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:75200,Availability,avail,available,75200,""";; 2388#ifdef R__MACOSX; 2389 const char *format2 = "" 0x%08lx in %.200s\n"";; 2390#else; 2391 const char *format2 = "" 0x%08lx in %.200s at %.200s from %.200s\n"";; 2392#endif; 2393 const char *format3 = "" 0x%08lx in %.200s from %.200s\n"";; 2394 const char *format4 = "" 0x%08lx in <unknown function>\n"";; 2395#endif; 2396 ; 2397 char *filter = Which(Getenv(""PATH""), cppfilt, kExecutePermission);; 2398 if (!filter); 2399 demangle = kFALSE;; 2400 ; 2401#if (__GNUC__ >= 3); 2402 // try finding supported format option for g++ v3; 2403 if (filter) {; 2404 FILE *p = OpenPipe(TString::Format(""%s --help 2>&1"", filter), ""r"");; 2405 TString help;; 2406 while (help.Gets(p)) {; 2407 if (help.Index(""gnu-v3"") != kNPOS) {; 2408 cppfiltarg = ""--format=gnu-v3"";; 2409 break;; 2410 } else if (help.Index(""gnu-new-abi"") != kNPOS) {; 2411 cppfiltarg = ""--format=gnu-new-abi"";; 2412 break;; 2413 }; 2414 }; 2415 ClosePipe(p);; 2416 }; 2417#endif; 2418 // gdb-backtrace.sh uses gdb to produce a backtrace. See if it is available.; 2419 // If it is, use it. If not proceed as before.; 2420#if (defined(R__LINUX) && !defined(R__WINGCC)); 2421 // Declare the process that will be generating the stacktrace; 2422 // For more see: http://askubuntu.com/questions/41629/after-upgrade-gdb-wont-attach-to-process; 2423#ifdef PR_SET_PTRACER; 2424 prctl(PR_SET_PTRACER, getpid(), 0, 0, 0);; 2425#endif; 2426#endif; 2427 char *gdb = Which(Getenv(""PATH""), ""gdb"", kExecutePermission);; 2428 if (gdb) {; 2429 // write custom message file; 2430 TString gdbmessf = ""gdb-message"";; 2431 if (gdbmess != """") {; 2432 FILE *f = TempFileName(gdbmessf);; 2433 fprintf(f, ""%s\n"", gdbmess.Data());; 2434 fclose(f);; 2435 }; 2436 ; 2437 // use gdb to get stack trace; 2438#ifdef R__MACOSX; 2439 gdbscript += GetExePath();; 2440 gdbscript += "" "";; 2441#endif; 2442 gdbscript += GetPid();; 2443 if (gdbmess != """") {; 2444 gdbscript += "" "";; 2445 gdbscript += gdbmessf;; 2446 }; 2447 gdbscript += "" 1>&2"";; 2448 Exec(gdbscript);; 2449 delete [] gd",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:84300,Availability,error,error,84300,"ion to system log daemon.; 2662 ; 2663void TUnixSystem::Closelog(); 2664{; 2665 ::closelog();; 2666}; 2667 ; 2668//---- Standard output redirection ---------------------------------------------; 2669 ; 2670////////////////////////////////////////////////////////////////////////////////; 2671/// Redirect standard output (stdout, stderr) to the specified file.; 2672/// If the file argument is 0 the output is set again to stderr, stdout.; 2673/// The second argument specifies whether the output should be added to the; 2674/// file (""a"", default) or the file be truncated before (""w"").; 2675/// This function saves internally the current state into a static structure.; 2676/// The call can be made reentrant by specifying the opaque structure pointed; 2677/// by 'h', which is filled with the relevant information. The handle 'h'; 2678/// obtained on the first call must then be used in any subsequent call,; 2679/// included ShowOutput, to display the redirected output.; 2680/// Returns 0 on success, -1 in case of error.; 2681 ; 2682Int_t TUnixSystem::RedirectOutput(const char *file, const char *mode,; 2683 RedirectHandle_t *h); 2684{; 2685 // Instance to be used if the caller does not passes 'h'; 2686 static RedirectHandle_t loch;; 2687 ; 2688 Int_t rc = 0;; 2689 ; 2690 // Which handle to use ?; 2691 RedirectHandle_t *xh = (h) ? h : &loch;; 2692 ; 2693 if (file) {; 2694 // Save the paths; 2695 Bool_t outdone = kFALSE;; 2696 if (xh->fStdOutTty.IsNull()) {; 2697 const char *tty = ttyname(STDOUT_FILENO);; 2698 if (tty) {; 2699 xh->fStdOutTty = tty;; 2700 } else {; 2701 if ((xh->fStdOutDup = dup(STDOUT_FILENO)) < 0) {; 2702 SysError(""RedirectOutput"", ""could not 'dup' stdout (errno: %d)"", TSystem::GetErrno());; 2703 return -1;; 2704 }; 2705 outdone = kTRUE;; 2706 }; 2707 }; 2708 if (xh->fStdErrTty.IsNull()) {; 2709 const char *tty = ttyname(STDERR_FILENO);; 2710 if (tty) {; 2711 xh->fStdErrTty = tty;; 2712 } else {; 2713 if ((xh->fStdErrDup = dup(STDERR_FILENO)) < 0) {; 2714 SysE",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:89245,Availability,error,error,89245,"original redirected""; 2792 "" file) (errno: %d)"", TSystem::GetErrno());; 2793 rc = -1;; 2794 }; 2795 if (close(xh->fStdErrDup) != 0) {; 2796 SysError(""RedirectOutput"",; 2797 ""problems closing temporary 'err' descriptor %d (errno: %d)"",; 2798 TSystem::GetErrno(), xh->fStdErrDup);; 2799 rc = -1;; 2800 }; 2801 }; 2802 // Reset the static instance, if using that; 2803 if (xh == &loch); 2804 xh->Reset();; 2805 }; 2806 return rc;; 2807}; 2808 ; 2809//---- dynamic loading and linking ---------------------------------------------; 2810 ; 2811////////////////////////////////////////////////////////////////////////////////; 2812///dynamic linking of module; 2813 ; 2814Func_t TUnixSystem::DynFindSymbol(const char * /*module*/, const char *entry); 2815{; 2816 return TSystem::DynFindSymbol(""*"", entry);; 2817}; 2818 ; 2819////////////////////////////////////////////////////////////////////////////////; 2820/// Load a shared library. Returns 0 on successful loading, 1 in; 2821/// case lib was already loaded and -1 in case lib does not exist; 2822/// or in case of error.; 2823 ; 2824int TUnixSystem::Load(const char *module, const char *entry, Bool_t system); 2825{; 2826 return TSystem::Load(module, entry, system);; 2827}; 2828 ; 2829////////////////////////////////////////////////////////////////////////////////; 2830/// Unload a shared library.; 2831 ; 2832void TUnixSystem::Unload(const char *module); 2833{; 2834 if (module) { TSystem::Unload(module); }; 2835}; 2836 ; 2837////////////////////////////////////////////////////////////////////////////////; 2838/// List symbols in a shared library.; 2839 ; 2840void TUnixSystem::ListSymbols(const char * /*module*/, const char * /*regexp*/); 2841{; 2842 Error(""ListSymbols"", ""not yet implemented"");; 2843}; 2844 ; 2845////////////////////////////////////////////////////////////////////////////////; 2846/// List all loaded shared libraries.; 2847 ; 2848void TUnixSystem::ListLibraries(const char *regexp); 2849{; 2850 TSystem::ListLibraries(reg",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:90430,Availability,error,error,90430,"827}; 2828 ; 2829////////////////////////////////////////////////////////////////////////////////; 2830/// Unload a shared library.; 2831 ; 2832void TUnixSystem::Unload(const char *module); 2833{; 2834 if (module) { TSystem::Unload(module); }; 2835}; 2836 ; 2837////////////////////////////////////////////////////////////////////////////////; 2838/// List symbols in a shared library.; 2839 ; 2840void TUnixSystem::ListSymbols(const char * /*module*/, const char * /*regexp*/); 2841{; 2842 Error(""ListSymbols"", ""not yet implemented"");; 2843}; 2844 ; 2845////////////////////////////////////////////////////////////////////////////////; 2846/// List all loaded shared libraries.; 2847 ; 2848void TUnixSystem::ListLibraries(const char *regexp); 2849{; 2850 TSystem::ListLibraries(regexp);; 2851}; 2852 ; 2853////////////////////////////////////////////////////////////////////////////////; 2854/// Get list of shared libraries loaded at the start of the executable.; 2855/// Returns 0 in case list cannot be obtained or in case of error.; 2856 ; 2857const char *TUnixSystem::GetLinkedLibraries(); 2858{; 2859 static TString linkedLibs;; 2860 static Bool_t once = kFALSE;; 2861 ; 2862 R__LOCKGUARD2(gSystemMutex);; 2863 ; 2864 if (!linkedLibs.IsNull()); 2865 return linkedLibs;; 2866 ; 2867 if (once); 2868 return nullptr;; 2869 ; 2870#if !defined(R__MACOSX); 2871 const char *exe = GetExePath();; 2872 if (!exe || !*exe); 2873 return nullptr;; 2874#endif; 2875 ; 2876#if defined(R__MACOSX); 2877 DylibAdded(0, 0);; 2878 linkedLibs = gLinkedDylibs;; 2879#if 0; 2880 FILE *p = OpenPipe(TString::Format(""otool -L %s"", exe), ""r"");; 2881 TString otool;; 2882 while (otool.Gets(p)) {; 2883 TString delim("" \t"");; 2884 TObjArray *tok = otool.Tokenize(delim);; 2885 TString dylib = ((TObjString*)tok->At(0))->String();; 2886 if (dylib.EndsWith("".dylib"") && !dylib.Contains(""/libSystem.B.dylib"")) {; 2887 if (!linkedLibs.IsNull()); 2888 linkedLibs += "" "";; 2889 linkedLibs += dylib;; 2890 }; 2891 delete tok;; ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:92031,Availability,error,error,92031,"; 2882 while (otool.Gets(p)) {; 2883 TString delim("" \t"");; 2884 TObjArray *tok = otool.Tokenize(delim);; 2885 TString dylib = ((TObjString*)tok->At(0))->String();; 2886 if (dylib.EndsWith("".dylib"") && !dylib.Contains(""/libSystem.B.dylib"")) {; 2887 if (!linkedLibs.IsNull()); 2888 linkedLibs += "" "";; 2889 linkedLibs += dylib;; 2890 }; 2891 delete tok;; 2892 }; 2893 if (p) {; 2894 ClosePipe(p);; 2895 }; 2896#endif; 2897#elif defined(R__LINUX) || defined(R__SOLARIS) || defined(R__AIX); 2898#if defined(R__WINGCC ); 2899 const char *cLDD=""cygcheck"";; 2900 const char *cSOEXT="".dll"";; 2901 size_t lenexe = strlen(exe);; 2902 if (strcmp(exe + lenexe - 4, "".exe""); 2903 && strcmp(exe + lenexe - 4, "".dll"")) {; 2904 // it's not a dll and exe doesn't end on "".exe"";; 2905 // need to add it for cygcheck to find it:; 2906 char* longerexe = new char[lenexe + 5];; 2907 strlcpy(longerexe, exe,lenexe+5);; 2908 strlcat(longerexe, "".exe"",lenexe+5);; 2909 exe = longerexe; // memory leak; 2910 #error ""unsupported platform, fix memory leak to use it""; 2911 }; 2912 TRegexp sovers = ""\\.so\\.[0-9]+"";; 2913#else; 2914 const char *cLDD=""ldd"";; 2915#if defined(R__AIX); 2916 const char *cSOEXT="".a"";; 2917 TRegexp sovers = ""\\.a\\.[0-9]+"";; 2918#else; 2919 const char *cSOEXT="".so"";; 2920 TRegexp sovers = ""\\.so\\.[0-9]+"";; 2921#endif; 2922#endif; 2923 FILE *p = OpenPipe(TString::Format(""%s '%s'"", cLDD, exe), ""r"");; 2924 if (p) {; 2925 TString ldd;; 2926 while (ldd.Gets(p)) {; 2927 TString delim("" \t"");; 2928 TObjArray *tok = ldd.Tokenize(delim);; 2929 ; 2930 // expected format:; 2931 // libCore.so => /home/rdm/root/lib/libCore.so (0x40017000); 2932 TObjString *solibName = (TObjString*)tok->At(2);; 2933 if (!solibName) {; 2934 // case where there is only one name of the list:; 2935 // /usr/platform/SUNW,UltraAX-i2/lib/libc_psr.so.1; 2936 solibName = (TObjString*)tok->At(0);; 2937 }; 2938 if (solibName) {; 2939 TString solib = solibName->String();; 2940 Ssiz_t idx = solib.Index(sovers);; 2941 if (sol",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:104773,Availability,error,error,104773,"cpwindowsize);; 3245}; 3246 ; 3247////////////////////////////////////////////////////////////////////////////////; 3248/// Announce UDP service.; 3249 ; 3250int TUnixSystem::AnnounceUdpService(int port, int backlog); 3251{; 3252 return UnixUdpService(port, backlog);; 3253}; 3254 ; 3255////////////////////////////////////////////////////////////////////////////////; 3256/// Announce unix domain service on path ""kServerPath/<port>""; 3257 ; 3258int TUnixSystem::AnnounceUnixService(int port, int backlog); 3259{; 3260 return UnixUnixService(port, backlog);; 3261}; 3262 ; 3263////////////////////////////////////////////////////////////////////////////////; 3264/// Announce unix domain service on path 'sockpath'; 3265 ; 3266int TUnixSystem::AnnounceUnixService(const char *sockpath, int backlog); 3267{; 3268 return UnixUnixService(sockpath, backlog);; 3269}; 3270 ; 3271////////////////////////////////////////////////////////////////////////////////; 3272/// Accept a connection. In case of an error return -1. In case; 3273/// non-blocking I/O is enabled and no connections are available; 3274/// return -2.; 3275 ; 3276int TUnixSystem::AcceptConnection(int sock); 3277{; 3278 int soc = -1;; 3279 ; 3280 while ((soc = ::accept(sock, nullptr, nullptr)) == -1 && GetErrno() == EINTR); 3281 ResetErrno();; 3282 ; 3283 if (soc == -1) {; 3284 if (GetErrno() == EWOULDBLOCK); 3285 return -2;; 3286 else {; 3287 SysError(""AcceptConnection"", ""accept"");; 3288 return -1;; 3289 }; 3290 }; 3291 ; 3292 return soc;; 3293}; 3294 ; 3295////////////////////////////////////////////////////////////////////////////////; 3296/// Close socket.; 3297 ; 3298void TUnixSystem::CloseConnection(int sock, Bool_t force); 3299{; 3300 if (sock < 0) return;; 3301 ; 3302#if !defined(R__AIX) || defined(_AIX41) || defined(_AIX43); 3303 if (force); 3304 ::shutdown(sock, 2); // will also close connection of parent; 3305#endif; 3306 ; 3307 while (::close(sock) == -1 && GetErrno() == EINTR); 3308 ResetErrno();; 3309}; 3310",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:104858,Availability,avail,available,104858,"/////////////////////////////////////////////////; 3248/// Announce UDP service.; 3249 ; 3250int TUnixSystem::AnnounceUdpService(int port, int backlog); 3251{; 3252 return UnixUdpService(port, backlog);; 3253}; 3254 ; 3255////////////////////////////////////////////////////////////////////////////////; 3256/// Announce unix domain service on path ""kServerPath/<port>""; 3257 ; 3258int TUnixSystem::AnnounceUnixService(int port, int backlog); 3259{; 3260 return UnixUnixService(port, backlog);; 3261}; 3262 ; 3263////////////////////////////////////////////////////////////////////////////////; 3264/// Announce unix domain service on path 'sockpath'; 3265 ; 3266int TUnixSystem::AnnounceUnixService(const char *sockpath, int backlog); 3267{; 3268 return UnixUnixService(sockpath, backlog);; 3269}; 3270 ; 3271////////////////////////////////////////////////////////////////////////////////; 3272/// Accept a connection. In case of an error return -1. In case; 3273/// non-blocking I/O is enabled and no connections are available; 3274/// return -2.; 3275 ; 3276int TUnixSystem::AcceptConnection(int sock); 3277{; 3278 int soc = -1;; 3279 ; 3280 while ((soc = ::accept(sock, nullptr, nullptr)) == -1 && GetErrno() == EINTR); 3281 ResetErrno();; 3282 ; 3283 if (soc == -1) {; 3284 if (GetErrno() == EWOULDBLOCK); 3285 return -2;; 3286 else {; 3287 SysError(""AcceptConnection"", ""accept"");; 3288 return -1;; 3289 }; 3290 }; 3291 ; 3292 return soc;; 3293}; 3294 ; 3295////////////////////////////////////////////////////////////////////////////////; 3296/// Close socket.; 3297 ; 3298void TUnixSystem::CloseConnection(int sock, Bool_t force); 3299{; 3300 if (sock < 0) return;; 3301 ; 3302#if !defined(R__AIX) || defined(_AIX41) || defined(_AIX43); 3303 if (force); 3304 ::shutdown(sock, 2); // will also close connection of parent; 3305#endif; 3306 ; 3307 while (::close(sock) == -1 && GetErrno() == EINTR); 3308 ResetErrno();; 3309}; 3310 ; 3311/////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:106031,Availability,error,error,106031,"::accept(sock, nullptr, nullptr)) == -1 && GetErrno() == EINTR); 3281 ResetErrno();; 3282 ; 3283 if (soc == -1) {; 3284 if (GetErrno() == EWOULDBLOCK); 3285 return -2;; 3286 else {; 3287 SysError(""AcceptConnection"", ""accept"");; 3288 return -1;; 3289 }; 3290 }; 3291 ; 3292 return soc;; 3293}; 3294 ; 3295////////////////////////////////////////////////////////////////////////////////; 3296/// Close socket.; 3297 ; 3298void TUnixSystem::CloseConnection(int sock, Bool_t force); 3299{; 3300 if (sock < 0) return;; 3301 ; 3302#if !defined(R__AIX) || defined(_AIX41) || defined(_AIX43); 3303 if (force); 3304 ::shutdown(sock, 2); // will also close connection of parent; 3305#endif; 3306 ; 3307 while (::close(sock) == -1 && GetErrno() == EINTR); 3308 ResetErrno();; 3309}; 3310 ; 3311////////////////////////////////////////////////////////////////////////////////; 3312/// Receive a buffer headed by a length indicator. Length is the size of; 3313/// the buffer. Returns the number of bytes received in buf or -1 in; 3314/// case of error.; 3315 ; 3316int TUnixSystem::RecvBuf(int sock, void *buf, int length); 3317{; 3318 Int_t header;; 3319 ; 3320 if (UnixRecv(sock, &header, sizeof(header), 0) > 0) {; 3321 int count = ntohl(header);; 3322 ; 3323 if (count > length) {; 3324 Error(""RecvBuf"", ""record header exceeds buffer size"");; 3325 return -1;; 3326 } else if (count > 0) {; 3327 if (UnixRecv(sock, buf, count, 0) < 0) {; 3328 Error(""RecvBuf"", ""cannot receive buffer"");; 3329 return -1;; 3330 }; 3331 }; 3332 return count;; 3333 }; 3334 return -1;; 3335}; 3336 ; 3337////////////////////////////////////////////////////////////////////////////////; 3338/// Send a buffer headed by a length indicator. Returns length of sent buffer; 3339/// or -1 in case of error.; 3340 ; 3341int TUnixSystem::SendBuf(int sock, const void *buf, int length); 3342{; 3343 Int_t header = htonl(length);; 3344 ; 3345 if (UnixSend(sock, &header, sizeof(header), 0) < 0) {; 3346 Error(""SendBuf"", ""cannot send header"");",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:106761,Availability,error,error,106761,"EINTR); 3308 ResetErrno();; 3309}; 3310 ; 3311////////////////////////////////////////////////////////////////////////////////; 3312/// Receive a buffer headed by a length indicator. Length is the size of; 3313/// the buffer. Returns the number of bytes received in buf or -1 in; 3314/// case of error.; 3315 ; 3316int TUnixSystem::RecvBuf(int sock, void *buf, int length); 3317{; 3318 Int_t header;; 3319 ; 3320 if (UnixRecv(sock, &header, sizeof(header), 0) > 0) {; 3321 int count = ntohl(header);; 3322 ; 3323 if (count > length) {; 3324 Error(""RecvBuf"", ""record header exceeds buffer size"");; 3325 return -1;; 3326 } else if (count > 0) {; 3327 if (UnixRecv(sock, buf, count, 0) < 0) {; 3328 Error(""RecvBuf"", ""cannot receive buffer"");; 3329 return -1;; 3330 }; 3331 }; 3332 return count;; 3333 }; 3334 return -1;; 3335}; 3336 ; 3337////////////////////////////////////////////////////////////////////////////////; 3338/// Send a buffer headed by a length indicator. Returns length of sent buffer; 3339/// or -1 in case of error.; 3340 ; 3341int TUnixSystem::SendBuf(int sock, const void *buf, int length); 3342{; 3343 Int_t header = htonl(length);; 3344 ; 3345 if (UnixSend(sock, &header, sizeof(header), 0) < 0) {; 3346 Error(""SendBuf"", ""cannot send header"");; 3347 return -1;; 3348 }; 3349 if (length > 0) {; 3350 if (UnixSend(sock, buf, length, 0) < 0) {; 3351 Error(""SendBuf"", ""cannot send buffer"");; 3352 return -1;; 3353 }; 3354 }; 3355 return length;; 3356}; 3357 ; 3358////////////////////////////////////////////////////////////////////////////////; 3359/// Receive exactly length bytes into buffer. Use opt to receive out-of-band; 3360/// data or to have a peek at what is in the buffer (see TSocket). Buffer; 3361/// must be able to store at least length bytes. Returns the number of; 3362/// bytes received (can be 0 if other side of connection was closed) or -1; 3363/// in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3; 3364/// in case of MSG_OOB and errno == EIN",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:107634,Availability,error,error,107634,"8/// Send a buffer headed by a length indicator. Returns length of sent buffer; 3339/// or -1 in case of error.; 3340 ; 3341int TUnixSystem::SendBuf(int sock, const void *buf, int length); 3342{; 3343 Int_t header = htonl(length);; 3344 ; 3345 if (UnixSend(sock, &header, sizeof(header), 0) < 0) {; 3346 Error(""SendBuf"", ""cannot send header"");; 3347 return -1;; 3348 }; 3349 if (length > 0) {; 3350 if (UnixSend(sock, buf, length, 0) < 0) {; 3351 Error(""SendBuf"", ""cannot send buffer"");; 3352 return -1;; 3353 }; 3354 }; 3355 return length;; 3356}; 3357 ; 3358////////////////////////////////////////////////////////////////////////////////; 3359/// Receive exactly length bytes into buffer. Use opt to receive out-of-band; 3360/// data or to have a peek at what is in the buffer (see TSocket). Buffer; 3361/// must be able to store at least length bytes. Returns the number of; 3362/// bytes received (can be 0 if other side of connection was closed) or -1; 3363/// in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3; 3364/// in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and; 3365/// errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; 3366/// (EPIPE || ECONNRESET).; 3367 ; 3368int TUnixSystem::RecvRaw(int sock, void *buf, int length, int opt); 3369{; 3370 int flag;; 3371 ; 3372 switch (opt) {; 3373 case kDefault:; 3374 flag = 0;; 3375 break;; 3376 case kOob:; 3377 flag = MSG_OOB;; 3378 break;; 3379 case kPeek:; 3380 flag = MSG_PEEK;; 3381 break;; 3382 case kDontBlock:; 3383 flag = -1;; 3384 break;; 3385 default:; 3386 flag = 0;; 3387 break;; 3388 }; 3389 ; 3390 int n;; 3391 if ((n = UnixRecv(sock, buf, length, flag)) <= 0) {; 3392 if (n == -1 && GetErrno() != EINTR); 3393 Error(""RecvRaw"", ""cannot receive buffer"");; 3394 return n;; 3395 }; 3396 return n;; 3397}; 3398 ; 3399////////////////////////////////////////////////////////////////////////////////; 3400/// Send exactly length bytes from buffer. Use opt to send out-of-band; 34",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:108741,Availability,error,error,108741,"G_OOB and errno == EINVAL and -4 in case of kNoBlock and; 3365/// errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; 3366/// (EPIPE || ECONNRESET).; 3367 ; 3368int TUnixSystem::RecvRaw(int sock, void *buf, int length, int opt); 3369{; 3370 int flag;; 3371 ; 3372 switch (opt) {; 3373 case kDefault:; 3374 flag = 0;; 3375 break;; 3376 case kOob:; 3377 flag = MSG_OOB;; 3378 break;; 3379 case kPeek:; 3380 flag = MSG_PEEK;; 3381 break;; 3382 case kDontBlock:; 3383 flag = -1;; 3384 break;; 3385 default:; 3386 flag = 0;; 3387 break;; 3388 }; 3389 ; 3390 int n;; 3391 if ((n = UnixRecv(sock, buf, length, flag)) <= 0) {; 3392 if (n == -1 && GetErrno() != EINTR); 3393 Error(""RecvRaw"", ""cannot receive buffer"");; 3394 return n;; 3395 }; 3396 return n;; 3397}; 3398 ; 3399////////////////////////////////////////////////////////////////////////////////; 3400/// Send exactly length bytes from buffer. Use opt to send out-of-band; 3401/// data (see TSocket). Returns the number of bytes sent or -1 in case of; 3402/// error. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK.; 3403/// Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; 3404 ; 3405int TUnixSystem::SendRaw(int sock, const void *buf, int length, int opt); 3406{; 3407 int flag;; 3408 ; 3409 switch (opt) {; 3410 case kDefault:; 3411 flag = 0;; 3412 break;; 3413 case kOob:; 3414 flag = MSG_OOB;; 3415 break;; 3416 case kDontBlock:; 3417 flag = -1;; 3418 break;; 3419 case kPeek: // receive only option (see RecvRaw); 3420 default:; 3421 flag = 0;; 3422 break;; 3423 }; 3424 ; 3425 int n;; 3426 if ((n = UnixSend(sock, buf, length, flag)) <= 0) {; 3427 if (n == -1 && GetErrno() != EINTR); 3428 Error(""SendRaw"", ""cannot send buffer"");; 3429 return n;; 3430 }; 3431 return n;; 3432}; 3433 ; 3434////////////////////////////////////////////////////////////////////////////////; 3435/// Set socket option.; 3436 ; 3437int TUnixSystem::SetSockOpt(int sock, int opt, int val); 3438{; 3439 if (sock < 0) return ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:115063,Availability,error,error,115063,"OCATMARK)"");; 3573 return -1;; 3574 }; 3575#else; 3576 Error(""GetSockOpt"", ""ioctl(SIOCATMARK) not supported on LynxOS"");; 3577 return -1;; 3578#endif; 3579 break;; 3580 case kBytesToRead:; 3581#if !defined(R__LYNXOS); 3582 if (ioctl(sock, FIONREAD, (char*)val) == -1) {; 3583 SysError(""GetSockOpt"", ""ioctl(FIONREAD)"");; 3584 return -1;; 3585 }; 3586#else; 3587 Error(""GetSockOpt"", ""ioctl(FIONREAD) not supported on LynxOS"");; 3588 return -1;; 3589#endif; 3590 break;; 3591 default:; 3592 Error(""GetSockOpt"", ""illegal option (%d)"", opt);; 3593 *val = 0;; 3594 return -1;; 3595 }; 3596 return 0;; 3597}; 3598 ; 3599//////////////////////////////////////////////////////////////////////////; 3600// //; 3601// Static Protected Unix Interface functions. //; 3602// //; 3603//////////////////////////////////////////////////////////////////////////; 3604 ; 3605//---- signals -----------------------------------------------------------------; 3606 ; 3607static struct Signalmap_t {; 3608 int fCode;; 3609 SigHandler_t fHandler;; 3610 struct sigaction *fOldHandler;; 3611 const char *fSigName;; 3612} gSignalMap[kMAXSIGNALS] = { // the order of the signals should be identical; 3613 { SIGBUS, nullptr, nullptr, ""bus error"" }, // to the one in TSysEvtHandler.h; 3614 { SIGSEGV, nullptr, nullptr, ""segmentation violation"" },; 3615 { SIGSYS, nullptr, nullptr, ""bad argument to system call"" },; 3616 { SIGPIPE, nullptr, nullptr, ""write on a pipe with no one to read it"" },; 3617 { SIGILL, nullptr, nullptr, ""illegal instruction"" },; 3618 { SIGABRT, nullptr, nullptr, ""abort"" },; 3619 { SIGQUIT, nullptr, nullptr, ""quit"" },; 3620 { SIGINT, nullptr, nullptr, ""interrupt"" },; 3621 { SIGWINCH, nullptr, nullptr, ""window size change"" },; 3622 { SIGALRM, nullptr, nullptr, ""alarm clock"" },; 3623 { SIGCHLD, nullptr, nullptr, ""death of a child"" },; 3624 { SIGURG, nullptr, nullptr, ""urgent data arrived on an I/O channel"" },; 3625 { SIGFPE, nullptr, nullptr, ""floating point exception"" },; 3626 { SIGTERM, nullptr, nul",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:123600,Availability,error,error,123600,"9 gSignalMap[sig].fHandler = nullptr;; 3830 }; 3831}; 3832 ; 3833////////////////////////////////////////////////////////////////////////////////; 3834/// Restore old signal handlers.; 3835 ; 3836void TUnixSystem::UnixResetSignals(); 3837{; 3838 for (int sig = 0; sig < kMAXSIGNALS; sig++); 3839 UnixResetSignal((ESignals)sig);; 3840}; 3841 ; 3842//---- time --------------------------------------------------------------------; 3843 ; 3844////////////////////////////////////////////////////////////////////////////////; 3845/// Get current time in milliseconds since 0:00 Jan 1 1995.; 3846 ; 3847Long64_t TUnixSystem::UnixNow(); 3848{; 3849 static std::atomic<time_t> jan95{0};; 3850 if (!jan95) {; 3851 struct tm tp;; 3852 tp.tm_year = 95;; 3853 tp.tm_mon = 0;; 3854 tp.tm_mday = 1;; 3855 tp.tm_hour = 0;; 3856 tp.tm_min = 0;; 3857 tp.tm_sec = 0;; 3858 tp.tm_isdst = -1;; 3859 ; 3860 jan95 = mktime(&tp);; 3861 if ((int)jan95 == -1) {; 3862 ::SysError(""TUnixSystem::UnixNow"", ""error converting 950001 0:00 to time_t"");; 3863 return 0;; 3864 }; 3865 }; 3866 ; 3867 struct timeval t;; 3868 gettimeofday(&t, nullptr);; 3869 return Long64_t(t.tv_sec-(Long_t)jan95)*1000 + t.tv_usec/1000;; 3870}; 3871 ; 3872////////////////////////////////////////////////////////////////////////////////; 3873/// Set interval timer to time-out in ms milliseconds.; 3874 ; 3875int TUnixSystem::UnixSetitimer(Long_t ms); 3876{; 3877 struct itimerval itv;; 3878 itv.it_value.tv_sec = 0;; 3879 itv.it_value.tv_usec = 0;; 3880 itv.it_interval.tv_sec = 0;; 3881 itv.it_interval.tv_usec = 0;; 3882 if (ms > 0) {; 3883 itv.it_value.tv_sec = time_t(ms / 1000);; 3884 itv.it_value.tv_usec = time_t((ms % 1000) * 1000);; 3885 }; 3886 int st = setitimer(ITIMER_REAL, &itv, nullptr);; 3887 if (st == -1); 3888 ::SysError(""TUnixSystem::UnixSetitimer"", ""setitimer"");; 3889 return st;; 3890}; 3891 ; 3892//---- file descriptors --------------------------------------------------------; 3893 ; 3894/////////////////////////////////////",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:124765,Availability,mask,masks,124765,"jan95 == -1) {; 3862 ::SysError(""TUnixSystem::UnixNow"", ""error converting 950001 0:00 to time_t"");; 3863 return 0;; 3864 }; 3865 }; 3866 ; 3867 struct timeval t;; 3868 gettimeofday(&t, nullptr);; 3869 return Long64_t(t.tv_sec-(Long_t)jan95)*1000 + t.tv_usec/1000;; 3870}; 3871 ; 3872////////////////////////////////////////////////////////////////////////////////; 3873/// Set interval timer to time-out in ms milliseconds.; 3874 ; 3875int TUnixSystem::UnixSetitimer(Long_t ms); 3876{; 3877 struct itimerval itv;; 3878 itv.it_value.tv_sec = 0;; 3879 itv.it_value.tv_usec = 0;; 3880 itv.it_interval.tv_sec = 0;; 3881 itv.it_interval.tv_usec = 0;; 3882 if (ms > 0) {; 3883 itv.it_value.tv_sec = time_t(ms / 1000);; 3884 itv.it_value.tv_usec = time_t((ms % 1000) * 1000);; 3885 }; 3886 int st = setitimer(ITIMER_REAL, &itv, nullptr);; 3887 if (st == -1); 3888 ::SysError(""TUnixSystem::UnixSetitimer"", ""setitimer"");; 3889 return st;; 3890}; 3891 ; 3892//---- file descriptors --------------------------------------------------------; 3893 ; 3894////////////////////////////////////////////////////////////////////////////////; 3895/// Wait for events on the file descriptors specified in the readready and; 3896/// writeready masks or for timeout (in milliseconds) to occur. Returns; 3897/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 3898/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 3899/// the errno has been reset and the method can be called again.; 3900 ; 3901int TUnixSystem::UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready,; 3902 Long_t timeout); 3903{; 3904 int retcode;; 3905 ; 3906 fd_set *rd = (readready) ? (fd_set*)readready->GetBits() : nullptr;; 3907 fd_set *wr = (writeready) ? (fd_set*)writeready->GetBits() : nullptr;; 3908 ; 3909 if (timeout >= 0) {; 3910 struct timeval tv;; 3911 tv.tv_sec = Int_t(timeout / 1000);; 3912 tv.tv_usec = (timeout % 1000) * 1000;; 3913 retcode = select(nfds, rd, wr, nullptr, &tv);; 3914 ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:124919,Availability,error,error,124919,"////////////////////; 3873/// Set interval timer to time-out in ms milliseconds.; 3874 ; 3875int TUnixSystem::UnixSetitimer(Long_t ms); 3876{; 3877 struct itimerval itv;; 3878 itv.it_value.tv_sec = 0;; 3879 itv.it_value.tv_usec = 0;; 3880 itv.it_interval.tv_sec = 0;; 3881 itv.it_interval.tv_usec = 0;; 3882 if (ms > 0) {; 3883 itv.it_value.tv_sec = time_t(ms / 1000);; 3884 itv.it_value.tv_usec = time_t((ms % 1000) * 1000);; 3885 }; 3886 int st = setitimer(ITIMER_REAL, &itv, nullptr);; 3887 if (st == -1); 3888 ::SysError(""TUnixSystem::UnixSetitimer"", ""setitimer"");; 3889 return st;; 3890}; 3891 ; 3892//---- file descriptors --------------------------------------------------------; 3893 ; 3894////////////////////////////////////////////////////////////////////////////////; 3895/// Wait for events on the file descriptors specified in the readready and; 3896/// writeready masks or for timeout (in milliseconds) to occur. Returns; 3897/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 3898/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 3899/// the errno has been reset and the method can be called again.; 3900 ; 3901int TUnixSystem::UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready,; 3902 Long_t timeout); 3903{; 3904 int retcode;; 3905 ; 3906 fd_set *rd = (readready) ? (fd_set*)readready->GetBits() : nullptr;; 3907 fd_set *wr = (writeready) ? (fd_set*)writeready->GetBits() : nullptr;; 3908 ; 3909 if (timeout >= 0) {; 3910 struct timeval tv;; 3911 tv.tv_sec = Int_t(timeout / 1000);; 3912 tv.tv_usec = (timeout % 1000) * 1000;; 3913 retcode = select(nfds, rd, wr, nullptr, &tv);; 3914 } else {; 3915 retcode = select(nfds, rd, wr, nullptr, nullptr);; 3916 }; 3917 if (retcode == -1) {; 3918 if (GetErrno() == EINTR) {; 3919 ResetErrno(); // errno is not self reseting; 3920 return -2;; 3921 }; 3922 if (GetErrno() == EBADF); 3923 return -3;; 3924 return -1;; 3925 }; 3926 ; 3927 return retcode;; 3928}; 3929 ; 3930//---- direct",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:132837,Availability,error,error,132837,"f_type;; 4117#endif; 4118 *bsize = statfsbuf.f_bsize;; 4119 *blocks = statfsbuf.f_blocks;; 4120 *bfree = statfsbuf.f_bavail;; 4121#endif; 4122 return 0;; 4123 }; 4124 return 1;; 4125}; 4126 ; 4127////////////////////////////////////////////////////////////////////////////////; 4128/// Wait till child is finished.; 4129 ; 4130int TUnixSystem::UnixWaitchild(); 4131{; 4132 int status;; 4133 return (int) waitpid(0, &status, WNOHANG);; 4134}; 4135 ; 4136//---- RPC -------------------------------------------------------------------; 4137 ; 4138////////////////////////////////////////////////////////////////////////////////; 4139/// Open a TCP/IP connection to server and connect to a service (i.e. port).; 4140/// Use tcpwindowsize to specify the size of the receive buffer, it has; 4141/// to be specified here to make sure the window scale option is set (for; 4142/// tcpwindowsize > 65KB and for platforms supporting window scaling).; 4143/// Is called via the TSocket constructor. Returns -1 in case of error.; 4144 ; 4145int TUnixSystem::UnixTcpConnect(const char *hostname, int port,; 4146 int tcpwindowsize); 4147{; 4148 short sport;; 4149 struct servent *sp;; 4150 ; 4151 if ((sp = getservbyport(htons(port), kProtocolName))); 4152 sport = sp->s_port;; 4153 else; 4154 sport = htons(port);; 4155 ; 4156 TInetAddress addr = gSystem->GetHostByName(hostname);; 4157 if (!addr.IsValid()) return -1;; 4158 UInt_t adr = htonl(addr.GetAddress());; 4159 ; 4160 struct sockaddr_in server;; 4161 memset(&server, 0, sizeof(server));; 4162 memcpy(&server.sin_addr, &adr, sizeof(adr));; 4163 server.sin_family = addr.GetFamily();; 4164 server.sin_port = sport;; 4165 ; 4166 // Create socket; 4167 int sock;; 4168 if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {; 4169 ::SysError(""TUnixSystem::UnixTcpConnect"", ""socket (%s:%d)"",; 4170 hostname, port);; 4171 return -1;; 4172 }; 4173 ; 4174 if (tcpwindowsize > 0) {; 4175 gSystem->SetSockOpt(sock, kRecvBuffer, tcpwindowsize);; 4176 gSystem->SetSockOpt(",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:134402,Availability,error,error,134402,"dr, sizeof(adr));; 4163 server.sin_family = addr.GetFamily();; 4164 server.sin_port = sport;; 4165 ; 4166 // Create socket; 4167 int sock;; 4168 if ((sock = socket(AF_INET, SOCK_STREAM, 0)) < 0) {; 4169 ::SysError(""TUnixSystem::UnixTcpConnect"", ""socket (%s:%d)"",; 4170 hostname, port);; 4171 return -1;; 4172 }; 4173 ; 4174 if (tcpwindowsize > 0) {; 4175 gSystem->SetSockOpt(sock, kRecvBuffer, tcpwindowsize);; 4176 gSystem->SetSockOpt(sock, kSendBuffer, tcpwindowsize);; 4177 }; 4178 ; 4179 while (connect(sock, (struct sockaddr*) &server, sizeof(server)) == -1) {; 4180 if (GetErrno() == EINTR); 4181 ResetErrno();; 4182 else {; 4183 ::SysError(""TUnixSystem::UnixTcpConnect"", ""connect (%s:%d)"",; 4184 hostname, port);; 4185 close(sock);; 4186 return -1;; 4187 }; 4188 }; 4189 return sock;; 4190}; 4191 ; 4192 ; 4193////////////////////////////////////////////////////////////////////////////////; 4194/// Creates a UDP socket connection; 4195/// Is called via the TSocket constructor. Returns -1 in case of error.; 4196 ; 4197int TUnixSystem::UnixUdpConnect(const char *hostname, int port); 4198{; 4199 short sport;; 4200 struct servent *sp;; 4201 ; 4202 if ((sp = getservbyport(htons(port), kProtocolName))); 4203 sport = sp->s_port;; 4204 else; 4205 sport = htons(port);; 4206 ; 4207 TInetAddress addr = gSystem->GetHostByName(hostname);; 4208 if (!addr.IsValid()) return -1;; 4209 UInt_t adr = htonl(addr.GetAddress());; 4210 ; 4211 struct sockaddr_in server;; 4212 memset(&server, 0, sizeof(server));; 4213 memcpy(&server.sin_addr, &adr, sizeof(adr));; 4214 server.sin_family = addr.GetFamily();; 4215 server.sin_port = sport;; 4216 ; 4217 // Create socket; 4218 int sock;; 4219 if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {; 4220 ::SysError(""TUnixSystem::UnixUdpConnect"", ""socket (%s:%d)"",; 4221 hostname, port);; 4222 return -1;; 4223 }; 4224 ; 4225 while (connect(sock, (struct sockaddr*) &server, sizeof(server)) == -1) {; 4226 if (GetErrno() == EINTR); 4227 ResetErrno();; 4228 else {;",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:135998,Availability,error,error,135998,"ly();; 4215 server.sin_port = sport;; 4216 ; 4217 // Create socket; 4218 int sock;; 4219 if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {; 4220 ::SysError(""TUnixSystem::UnixUdpConnect"", ""socket (%s:%d)"",; 4221 hostname, port);; 4222 return -1;; 4223 }; 4224 ; 4225 while (connect(sock, (struct sockaddr*) &server, sizeof(server)) == -1) {; 4226 if (GetErrno() == EINTR); 4227 ResetErrno();; 4228 else {; 4229 ::SysError(""TUnixSystem::UnixUdpConnect"", ""connect (%s:%d)"",; 4230 hostname, port);; 4231 close(sock);; 4232 return -1;; 4233 }; 4234 }; 4235 return sock;; 4236}; 4237 ; 4238////////////////////////////////////////////////////////////////////////////////; 4239/// Connect to a Unix domain socket.; 4240 ; 4241int TUnixSystem::UnixUnixConnect(int port); 4242{; 4243 return UnixUnixConnect(TString::Format(""%s/%d"", kServerPath, port));; 4244}; 4245 ; 4246////////////////////////////////////////////////////////////////////////////////; 4247/// Connect to a Unix domain socket. Returns -1 in case of error.; 4248 ; 4249int TUnixSystem::UnixUnixConnect(const char *sockpath); 4250{; 4251 if (!sockpath || strlen(sockpath) <= 0) {; 4252 ::SysError(""TUnixSystem::UnixUnixConnect"", ""socket path undefined"");; 4253 return -1;; 4254 }; 4255 ; 4256 int sock;; 4257 struct sockaddr_un unserver;; 4258 unserver.sun_family = AF_UNIX;; 4259 ; 4260 if (strlen(sockpath) > sizeof(unserver.sun_path)-1) {; 4261 ::Error(""TUnixSystem::UnixUnixConnect"", ""socket path %s, longer than max allowed length (%u)"",; 4262 sockpath, (UInt_t)sizeof(unserver.sun_path)-1);; 4263 return -1;; 4264 }; 4265 strlcpy(unserver.sun_path, sockpath, sizeof(unserver.sun_path));; 4266 ; 4267 // Open socket; 4268 if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {; 4269 ::SysError(""TUnixSystem::UnixUnixConnect"", ""socket"");; 4270 return -1;; 4271 }; 4272 ; 4273 while (connect(sock, (struct sockaddr*) &unserver, strlen(unserver.sun_path)+2) == -1) {; 4274 if (GetErrno() == EINTR); 4275 ResetErrno();; 4276 else {; 4277 ::SysEr",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:144426,Availability,error,error,144426,"(UInt_t)sizeof(unserver.sun_path)-1);; 4475 return -1;; 4476 }; 4477 strlcpy(unserver.sun_path, sockpath, sizeof(unserver.sun_path));; 4478 ; 4479 // Create socket; 4480 if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {; 4481 ::SysError(""TUnixSystem::UnixUnixService"", ""socket"");; 4482 return -1;; 4483 }; 4484 ; 4485 if (::bind(sock, (struct sockaddr*) &unserver, strlen(unserver.sun_path)+2)) {; 4486 ::SysError(""TUnixSystem::UnixUnixService"", ""bind"");; 4487 close(sock);; 4488 return -1;; 4489 }; 4490 ; 4491 // Start accepting connections; 4492 if (::listen(sock, backlog)) {; 4493 ::SysError(""TUnixSystem::UnixUnixService"", ""listen"");; 4494 close(sock);; 4495 return -1;; 4496 }; 4497 ; 4498 return sock;; 4499}; 4500 ; 4501////////////////////////////////////////////////////////////////////////////////; 4502/// Receive exactly length bytes into buffer. Returns number of bytes; 4503/// received. Returns -1 in case of error, -2 in case of MSG_OOB; 4504/// and errno == EWOULDBLOCK, -3 in case of MSG_OOB and errno == EINVAL; 4505/// and -4 in case of kNoBlock and errno == EWOULDBLOCK.; 4506/// Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET).; 4507 ; 4508int TUnixSystem::UnixRecv(int sock, void *buffer, int length, int flag); 4509{; 4510 ResetErrno();; 4511 ; 4512 if (sock < 0) return -1;; 4513 ; 4514 int once = 0;; 4515 if (flag == -1) {; 4516 flag = 0;; 4517 once = 1;; 4518 }; 4519 if (flag == MSG_PEEK); 4520 once = 1;; 4521 ; 4522 int n, nrecv = 0;; 4523 char *buf = (char *)buffer;; 4524 ; 4525 for (n = 0; n < length; n += nrecv) {; 4526 if ((nrecv = recv(sock, buf+n, length-n, flag)) <= 0) {; 4527 if (nrecv == 0); 4528 break; // EOF; 4529 if (flag == MSG_OOB) {; 4530 if (GetErrno() == EWOULDBLOCK); 4531 return -2;; 4532 else if (GetErrno() == EINVAL); 4533 return -3;; 4534 }; 4535 if (GetErrno() == EWOULDBLOCK); 4536 return -4;; 4537 else {; 4538 if (GetErrno() != EINTR); 4539 ::SysError(""TUnixSystem::UnixRecv"", ""recv"");; 4540 if (GetErrno() == EPIPE |",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:145817,Availability,error,error,145817,"4 int once = 0;; 4515 if (flag == -1) {; 4516 flag = 0;; 4517 once = 1;; 4518 }; 4519 if (flag == MSG_PEEK); 4520 once = 1;; 4521 ; 4522 int n, nrecv = 0;; 4523 char *buf = (char *)buffer;; 4524 ; 4525 for (n = 0; n < length; n += nrecv) {; 4526 if ((nrecv = recv(sock, buf+n, length-n, flag)) <= 0) {; 4527 if (nrecv == 0); 4528 break; // EOF; 4529 if (flag == MSG_OOB) {; 4530 if (GetErrno() == EWOULDBLOCK); 4531 return -2;; 4532 else if (GetErrno() == EINVAL); 4533 return -3;; 4534 }; 4535 if (GetErrno() == EWOULDBLOCK); 4536 return -4;; 4537 else {; 4538 if (GetErrno() != EINTR); 4539 ::SysError(""TUnixSystem::UnixRecv"", ""recv"");; 4540 if (GetErrno() == EPIPE || GetErrno() == ECONNRESET); 4541 return -5;; 4542 else; 4543 return -1;; 4544 }; 4545 }; 4546 if (once); 4547 return nrecv;; 4548 }; 4549 return n;; 4550}; 4551 ; 4552////////////////////////////////////////////////////////////////////////////////; 4553/// Send exactly length bytes from buffer. Returns -1 in case of error,; 4554/// otherwise number of sent bytes. Returns -4 in case of kNoBlock and; 4555/// errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; 4556/// (EPIPE || ECONNRESET).; 4557 ; 4558int TUnixSystem::UnixSend(int sock, const void *buffer, int length, int flag); 4559{; 4560 if (sock < 0) return -1;; 4561 ; 4562 int once = 0;; 4563 if (flag == -1) {; 4564 flag = 0;; 4565 once = 1;; 4566 }; 4567 ; 4568 int n, nsent = 0;; 4569 const char *buf = (const char *)buffer;; 4570 ; 4571 for (n = 0; n < length; n += nsent) {; 4572 if ((nsent = send(sock, buf+n, length-n, flag)) <= 0) {; 4573 if (nsent == 0); 4574 break;; 4575 if (GetErrno() == EWOULDBLOCK); 4576 return -4;; 4577 else {; 4578 if (GetErrno() != EINTR); 4579 ::SysError(""TUnixSystem::UnixSend"", ""send"");; 4580 if (GetErrno() == EPIPE || GetErrno() == ECONNRESET); 4581 return -5;; 4582 else; 4583 return -1;; 4584 }; 4585 }; 4586 if (once); 4587 return nsent;; 4588 }; 4589 return n;; 4590}; 4591 ; 4592//---- Dynamic Loading --------",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:155035,Availability,error,error,155035,"tem->FindFile(GetDynamicPath(), sLib, kReadPermission)) {; 4781 return sLib;; 4782 }; 4783 if (!quiet); 4784 Error(""FindDynamicLibrary"",; 4785 ""%s does not exist in %s"", searchFor.Data(), GetDynamicPath());; 4786 return nullptr;; 4787 }; 4788 static const char* exts[] = {; 4789 "".so"", "".dll"", "".dylib"", "".sl"", "".dl"", "".a"", nullptr };; 4790 const char** ext = exts;; 4791 while (*ext) {; 4792 TString fname(sLib);; 4793 fname += *ext;; 4794 ++ext;; 4795 if (gSystem->FindFile(GetDynamicPath(), fname, kReadPermission)) {; 4796 sLib.Swap(fname);; 4797 return sLib;; 4798 }; 4799 }; 4800 ; 4801 if (!quiet); 4802 Error(""FindDynamicLibrary"",; 4803 ""%s[.so | .dll | .dylib | .sl | .dl | .a] does not exist in %s"",; 4804 searchFor.Data(), GetDynamicPath());; 4805 ; 4806 return nullptr;; 4807}; 4808 ; 4809//---- System, CPU and Memory info ---------------------------------------------; 4810 ; 4811#if defined(R__FBSD); 4812///////////////////////////////////////////////////////////////////////////////; 4813//// Get system info for FreeBSD; 4814 ; 4815static void GetFreeBSDSysInfo(SysInfo_t *sysinfo); 4816{; 4817 // it probably would be better to get this information from syscalls; 4818 // this is possibly less error prone; 4819 FILE *p = gSystem->OpenPipe(""sysctl -n kern.ostype hw.model hw.ncpu ""; 4820 ""hw.realmem dev.cpu.0.freq"", ""r"");; 4821 TString s;; 4822 s.Gets(p);; 4823 sysinfo->fOS = s;; 4824 s.Gets(p);; 4825 sysinfo->fCpuType = s;; 4826 s.Gets(p);; 4827 sysinfo->fCpus = s.Atoi();; 4828 s.Gets(p);; 4829 Long64_t t = s.Atoll();; 4830 sysinfo->fPhysRam = Int_t(t / 1024 / 1024);; 4831 s.Gets(p);; 4832 t = s.Atoll();; 4833 sysinfo->fCpuSpeed = Int_t(t);; 4834 gSystem->ClosePipe(p);; 4835}; 4836 ; 4837static void GetFreeBSDCpuInfo(CpuInfo_t*, Int_t); 4838{; 4839 Error(""ListSymbols"", ""not yet implemented"");; 4840}; 4841#endif; 4842 ; 4843#if defined(R__MACOSX); 4844#include <sys/resource.h>; 4845#include <mach/mach.h>; 4846#include <mach/mach_error.h>; 4847 ; 4848///////////////////",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:160829,Availability,avail,avail,160829,") {; 4958 for (int psize = getpagesize(); psize > 1; psize >>= 1); 4959 pshift++;; 4960 }; 4961 ; 4962 // Figure out total swap. This adds up the size of the swapfiles */; 4963 DIR *dirp = opendir(""/private/var/vm"");; 4964 if (!dirp); 4965 return;; 4966 ; 4967 Long64_t swap_total = 0;; 4968 struct dirent *dp;; 4969 while ((dp = readdir(dirp)) != 0) {; 4970 struct stat sb;; 4971 char fname [MAXNAMLEN];; 4972 if (strncmp(dp->d_name, ""swapfile"", 8)); 4973 continue;; 4974 strlcpy(fname, ""/private/var/vm/"",MAXNAMLEN);; 4975 strlcat (fname, dp->d_name,MAXNAMLEN);; 4976 if (stat(fname, &sb) < 0); 4977 continue;; 4978 swap_total += sb.st_size;; 4979 }; 4980 closedir(dirp);; 4981 ; 4982 Long64_t used = (Long64_t)(vm_info.active_count + vm_info.inactive_count + vm_info.wire_count) << pshift;; 4983 Long64_t free = (Long64_t)(vm_info.free_count) << pshift;; 4984 Long64_t total = (Long64_t)(vm_info.active_count + vm_info.inactive_count + vm_info.free_count + vm_info.wire_count) << pshift;; 4985 Long64_t avail = (Long64_t)(vm_info.inactive_count + vm_info.free_count) << pshift;; 4986 ; 4987 // Swap is available at same time as mem, so grab values here.; 4988 Long64_t swap_used = vm_info.pageouts << pshift;; 4989 ; 4990 meminfo->fMemTotal = (Int_t) (total >> 20); // divide by 1024 * 1024; 4991 meminfo->fMemUsed = (Int_t) (used >> 20);; 4992 meminfo->fMemFree = (Int_t) (free >> 20);; 4993 meminfo->fSwapTotal = (Int_t) (swap_total >> 20);; 4994 meminfo->fSwapUsed = (Int_t) (swap_used >> 20);; 4995 meminfo->fSwapFree = meminfo->fSwapTotal - meminfo->fSwapUsed;; 4996 meminfo->fMemAvailable = (Int_t)(avail >> 20);; 4997}; 4998 ; 4999////////////////////////////////////////////////////////////////////////////////; 5000/// Get process info for this process on Mac OS X.; 5001/// Code largely taken from:; 5002/// http://www.opensource.apple.com/source/top/top-15/libtop.c; 5003/// The virtual memory usage is slightly over estimated as we don't; 5004/// subtract shared regions, but the value ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:160928,Availability,avail,available,160928,"igure out total swap. This adds up the size of the swapfiles */; 4963 DIR *dirp = opendir(""/private/var/vm"");; 4964 if (!dirp); 4965 return;; 4966 ; 4967 Long64_t swap_total = 0;; 4968 struct dirent *dp;; 4969 while ((dp = readdir(dirp)) != 0) {; 4970 struct stat sb;; 4971 char fname [MAXNAMLEN];; 4972 if (strncmp(dp->d_name, ""swapfile"", 8)); 4973 continue;; 4974 strlcpy(fname, ""/private/var/vm/"",MAXNAMLEN);; 4975 strlcat (fname, dp->d_name,MAXNAMLEN);; 4976 if (stat(fname, &sb) < 0); 4977 continue;; 4978 swap_total += sb.st_size;; 4979 }; 4980 closedir(dirp);; 4981 ; 4982 Long64_t used = (Long64_t)(vm_info.active_count + vm_info.inactive_count + vm_info.wire_count) << pshift;; 4983 Long64_t free = (Long64_t)(vm_info.free_count) << pshift;; 4984 Long64_t total = (Long64_t)(vm_info.active_count + vm_info.inactive_count + vm_info.free_count + vm_info.wire_count) << pshift;; 4985 Long64_t avail = (Long64_t)(vm_info.inactive_count + vm_info.free_count) << pshift;; 4986 ; 4987 // Swap is available at same time as mem, so grab values here.; 4988 Long64_t swap_used = vm_info.pageouts << pshift;; 4989 ; 4990 meminfo->fMemTotal = (Int_t) (total >> 20); // divide by 1024 * 1024; 4991 meminfo->fMemUsed = (Int_t) (used >> 20);; 4992 meminfo->fMemFree = (Int_t) (free >> 20);; 4993 meminfo->fSwapTotal = (Int_t) (swap_total >> 20);; 4994 meminfo->fSwapUsed = (Int_t) (swap_used >> 20);; 4995 meminfo->fSwapFree = meminfo->fSwapTotal - meminfo->fSwapUsed;; 4996 meminfo->fMemAvailable = (Int_t)(avail >> 20);; 4997}; 4998 ; 4999////////////////////////////////////////////////////////////////////////////////; 5000/// Get process info for this process on Mac OS X.; 5001/// Code largely taken from:; 5002/// http://www.opensource.apple.com/source/top/top-15/libtop.c; 5003/// The virtual memory usage is slightly over estimated as we don't; 5004/// subtract shared regions, but the value makes more sense; 5005/// than using `virtual_size`, which is useless on 64-bit machines.; 5006 ; 5007stat",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:161431,Availability,avail,avail,161431,"me, ""/private/var/vm/"",MAXNAMLEN);; 4975 strlcat (fname, dp->d_name,MAXNAMLEN);; 4976 if (stat(fname, &sb) < 0); 4977 continue;; 4978 swap_total += sb.st_size;; 4979 }; 4980 closedir(dirp);; 4981 ; 4982 Long64_t used = (Long64_t)(vm_info.active_count + vm_info.inactive_count + vm_info.wire_count) << pshift;; 4983 Long64_t free = (Long64_t)(vm_info.free_count) << pshift;; 4984 Long64_t total = (Long64_t)(vm_info.active_count + vm_info.inactive_count + vm_info.free_count + vm_info.wire_count) << pshift;; 4985 Long64_t avail = (Long64_t)(vm_info.inactive_count + vm_info.free_count) << pshift;; 4986 ; 4987 // Swap is available at same time as mem, so grab values here.; 4988 Long64_t swap_used = vm_info.pageouts << pshift;; 4989 ; 4990 meminfo->fMemTotal = (Int_t) (total >> 20); // divide by 1024 * 1024; 4991 meminfo->fMemUsed = (Int_t) (used >> 20);; 4992 meminfo->fMemFree = (Int_t) (free >> 20);; 4993 meminfo->fSwapTotal = (Int_t) (swap_total >> 20);; 4994 meminfo->fSwapUsed = (Int_t) (swap_used >> 20);; 4995 meminfo->fSwapFree = meminfo->fSwapTotal - meminfo->fSwapUsed;; 4996 meminfo->fMemAvailable = (Int_t)(avail >> 20);; 4997}; 4998 ; 4999////////////////////////////////////////////////////////////////////////////////; 5000/// Get process info for this process on Mac OS X.; 5001/// Code largely taken from:; 5002/// http://www.opensource.apple.com/source/top/top-15/libtop.c; 5003/// The virtual memory usage is slightly over estimated as we don't; 5004/// subtract shared regions, but the value makes more sense; 5005/// than using `virtual_size`, which is useless on 64-bit machines.; 5006 ; 5007static void GetDarwinProcInfo(ProcInfo_t *procinfo); 5008{; 5009#ifdef _LP64; 5010#define vm_region vm_region_64; 5011#endif; 5012 ; 5013// taken from <mach/shared_memory_server.h> which is obsoleted in 10.5; 5014#define GLOBAL_SHARED_TEXT_SEGMENT 0x90000000U; 5015#define GLOBAL_SHARED_DATA_SEGMENT 0xA0000000U; 5016#define SHARED_TEXT_REGION_SIZE 0x10000000; 5017#define SHARED_DA",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:172653,Availability,error,error,172653,":SysError(""TUnixSystem::GetLinuxProcInfo"", ""getrusage failed"");; 5291 } else {; 5292 procinfo->fCpuUser = (Float_t)(ru.ru_utime.tv_sec) +; 5293 ((Float_t)(ru.ru_utime.tv_usec) / 1000000.);; 5294 procinfo->fCpuSys = (Float_t)(ru.ru_stime.tv_sec) +; 5295 ((Float_t)(ru.ru_stime.tv_usec) / 1000000.);; 5296 }; 5297 ; 5298 procinfo->fMemVirtual = -1;; 5299 procinfo->fMemResident = -1;; 5300 TString s;; 5301 FILE *f = fopen(TString::Format(""/proc/%d/statm"", gSystem->GetPid()), ""r"");; 5302 if (f) {; 5303 s.Gets(f);; 5304 fclose(f);; 5305 Long_t total, rss;; 5306 sscanf(s.Data(), ""%ld %ld"", &total, &rss);; 5307 procinfo->fMemVirtual = total * (getpagesize() / 1024);; 5308 procinfo->fMemResident = rss * (getpagesize() / 1024);; 5309 }; 5310}; 5311#endif; 5312 ; 5313////////////////////////////////////////////////////////////////////////////////; 5314/// Returns static system info, like OS type, CPU type, number of CPUs; 5315/// RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 5316/// 0 otherwise.; 5317 ; 5318int TUnixSystem::GetSysInfo(SysInfo_t *info) const; 5319{; 5320 if (!info) return -1;; 5321 ; 5322 static SysInfo_t sysinfo;; 5323 ; 5324 if (!sysinfo.fCpus) {; 5325#if defined(R__MACOSX); 5326 GetDarwinSysInfo(&sysinfo);; 5327#elif defined(R__LINUX); 5328 GetLinuxSysInfo(&sysinfo);; 5329#elif defined(R__FBSD); 5330 GetFreeBSDSysInfo(&sysinfo);; 5331#endif; 5332 }; 5333 ; 5334 *info = sysinfo;; 5335 ; 5336 return 0;; 5337}; 5338 ; 5339////////////////////////////////////////////////////////////////////////////////; 5340/// Returns cpu load average and load info into the CpuInfo_t structure.; 5341/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 5342/// interval over which the CPU load will be measured, in ms (default 1000).; 5343 ; 5344int TUnixSystem::GetCpuInfo(CpuInfo_t *info, Int_t sampleTime) const; 5345{; 5346 if (!info) return -1;; 5347 ; 5348#if defined(R__MACOSX); 5349 GetDarwinCpuInfo(info, sampleTime);; 5350#elif d",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:173323,Availability,error,error,173323,"24);; 5308 procinfo->fMemResident = rss * (getpagesize() / 1024);; 5309 }; 5310}; 5311#endif; 5312 ; 5313////////////////////////////////////////////////////////////////////////////////; 5314/// Returns static system info, like OS type, CPU type, number of CPUs; 5315/// RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 5316/// 0 otherwise.; 5317 ; 5318int TUnixSystem::GetSysInfo(SysInfo_t *info) const; 5319{; 5320 if (!info) return -1;; 5321 ; 5322 static SysInfo_t sysinfo;; 5323 ; 5324 if (!sysinfo.fCpus) {; 5325#if defined(R__MACOSX); 5326 GetDarwinSysInfo(&sysinfo);; 5327#elif defined(R__LINUX); 5328 GetLinuxSysInfo(&sysinfo);; 5329#elif defined(R__FBSD); 5330 GetFreeBSDSysInfo(&sysinfo);; 5331#endif; 5332 }; 5333 ; 5334 *info = sysinfo;; 5335 ; 5336 return 0;; 5337}; 5338 ; 5339////////////////////////////////////////////////////////////////////////////////; 5340/// Returns cpu load average and load info into the CpuInfo_t structure.; 5341/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 5342/// interval over which the CPU load will be measured, in ms (default 1000).; 5343 ; 5344int TUnixSystem::GetCpuInfo(CpuInfo_t *info, Int_t sampleTime) const; 5345{; 5346 if (!info) return -1;; 5347 ; 5348#if defined(R__MACOSX); 5349 GetDarwinCpuInfo(info, sampleTime);; 5350#elif defined(R__LINUX); 5351 GetLinuxCpuInfo(info, sampleTime);; 5352#elif defined(R__FBSD); 5353 GetFreeBSDCpuInfo(info, sampleTime);; 5354#endif; 5355 ; 5356 return 0;; 5357}; 5358 ; 5359////////////////////////////////////////////////////////////////////////////////; 5360/// Returns ram and swap memory usage info into the MemInfo_t structure.; 5361/// Returns -1 in case of error, 0 otherwise.; 5362 ; 5363int TUnixSystem::GetMemInfo(MemInfo_t *info) const; 5364{; 5365 if (!info) return -1;; 5366 ; 5367#if defined(R__MACOSX); 5368 GetDarwinMemInfo(info);; 5369#elif defined(R__LINUX); 5370 GetLinuxMemInfo(info);; 5371#endif; 5372 ; 5373 return 0;; 5374}; 5375",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:174029,Availability,error,error,174029,"SysInfo(&sysinfo);; 5331#endif; 5332 }; 5333 ; 5334 *info = sysinfo;; 5335 ; 5336 return 0;; 5337}; 5338 ; 5339////////////////////////////////////////////////////////////////////////////////; 5340/// Returns cpu load average and load info into the CpuInfo_t structure.; 5341/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 5342/// interval over which the CPU load will be measured, in ms (default 1000).; 5343 ; 5344int TUnixSystem::GetCpuInfo(CpuInfo_t *info, Int_t sampleTime) const; 5345{; 5346 if (!info) return -1;; 5347 ; 5348#if defined(R__MACOSX); 5349 GetDarwinCpuInfo(info, sampleTime);; 5350#elif defined(R__LINUX); 5351 GetLinuxCpuInfo(info, sampleTime);; 5352#elif defined(R__FBSD); 5353 GetFreeBSDCpuInfo(info, sampleTime);; 5354#endif; 5355 ; 5356 return 0;; 5357}; 5358 ; 5359////////////////////////////////////////////////////////////////////////////////; 5360/// Returns ram and swap memory usage info into the MemInfo_t structure.; 5361/// Returns -1 in case of error, 0 otherwise.; 5362 ; 5363int TUnixSystem::GetMemInfo(MemInfo_t *info) const; 5364{; 5365 if (!info) return -1;; 5366 ; 5367#if defined(R__MACOSX); 5368 GetDarwinMemInfo(info);; 5369#elif defined(R__LINUX); 5370 GetLinuxMemInfo(info);; 5371#endif; 5372 ; 5373 return 0;; 5374}; 5375 ; 5376////////////////////////////////////////////////////////////////////////////////; 5377/// Returns cpu and memory used by this process into the ProcInfo_t structure.; 5378/// Returns -1 in case of error, 0 otherwise.; 5379 ; 5380int TUnixSystem::GetProcInfo(ProcInfo_t *info) const; 5381{; 5382 if (!info) return -1;; 5383 ; 5384#if defined(R__MACOSX); 5385 GetDarwinProcInfo(info);; 5386#elif defined(R__LINUX); 5387 GetLinuxProcInfo(info);; 5388#endif; 5389 ; 5390 return 0;; 5391}; FoundationUtils.hxxThe file contains utilities which are foundational and could be used across the core component of ROO...; RConfig.hxx; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:174520,Availability,error,error,174520," sampleTime) const; 5345{; 5346 if (!info) return -1;; 5347 ; 5348#if defined(R__MACOSX); 5349 GetDarwinCpuInfo(info, sampleTime);; 5350#elif defined(R__LINUX); 5351 GetLinuxCpuInfo(info, sampleTime);; 5352#elif defined(R__FBSD); 5353 GetFreeBSDCpuInfo(info, sampleTime);; 5354#endif; 5355 ; 5356 return 0;; 5357}; 5358 ; 5359////////////////////////////////////////////////////////////////////////////////; 5360/// Returns ram and swap memory usage info into the MemInfo_t structure.; 5361/// Returns -1 in case of error, 0 otherwise.; 5362 ; 5363int TUnixSystem::GetMemInfo(MemInfo_t *info) const; 5364{; 5365 if (!info) return -1;; 5366 ; 5367#if defined(R__MACOSX); 5368 GetDarwinMemInfo(info);; 5369#elif defined(R__LINUX); 5370 GetLinuxMemInfo(info);; 5371#endif; 5372 ; 5373 return 0;; 5374}; 5375 ; 5376////////////////////////////////////////////////////////////////////////////////; 5377/// Returns cpu and memory used by this process into the ProcInfo_t structure.; 5378/// Returns -1 in case of error, 0 otherwise.; 5379 ; 5380int TUnixSystem::GetProcInfo(ProcInfo_t *info) const; 5381{; 5382 if (!info) return -1;; 5383 ; 5384#if defined(R__MACOSX); 5385 GetDarwinProcInfo(info);; 5386#elif defined(R__LINUX); 5387 GetLinuxProcInfo(info);; 5388#endif; 5389 ; 5390 return 0;; 5391}; FoundationUtils.hxxThe file contains utilities which are foundational and could be used across the core component of ROO...; RConfig.hxx; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Ssiz_tint Ssiz_tDefinition RtypesCore.h:67; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; Long_tlong Long_tDefinition RtypesCore.h:54; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinitio",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:176193,Availability,error,error,176193," RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Ssiz_tint Ssiz_tDefinition RtypesCore.h:67; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; Long_tlong Long_tDefinition RtypesCore.h:54; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; kItimerResolution@ kItimerResolutionDefinition Rtypes.h:62; kMAXSIGNALS@ kMAXSIGNALSDefinition Rtypes.h:59; kMAXPATHLEN@ kMAXPATHLENDefinition Rtypes.h:60; TApplication.h; gApplicationR__EXTERN TApplication * gApplicationDefinition TApplication.h:170; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; TError.h; SysErrorvoid SysError(const char *location, const char *msgfmt,...)Use this function in case a system (OS or GUI) related error occurred.Definition TError.cxx:196; Breakvoid Break(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:207; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; TException.h; gExceptionHandlerR__EXTERN TExceptionHandler * gExceptionHandlerDefinition TException.h:79; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; directwinID h directDefinition TGWin32VirtualGLProxy.cxx:43; maskOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t maskDefinition ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:176325,Availability,error,error,176325,"ypesCore.h:55; Long_tlong Long_tDefinition RtypesCore.h:54; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; kItimerResolution@ kItimerResolutionDefinition Rtypes.h:62; kMAXSIGNALS@ kMAXSIGNALSDefinition Rtypes.h:59; kMAXPATHLEN@ kMAXPATHLENDefinition Rtypes.h:60; TApplication.h; gApplicationR__EXTERN TApplication * gApplicationDefinition TApplication.h:170; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; TError.h; SysErrorvoid SysError(const char *location, const char *msgfmt,...)Use this function in case a system (OS or GUI) related error occurred.Definition TError.cxx:196; Breakvoid Break(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:207; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; TException.h; gExceptionHandlerR__EXTERN TExceptionHandler * gExceptionHandlerDefinition TException.h:79; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; directwinID h directDefinition TGWin32VirtualGLProxy.cxx:43; maskOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t maskDefinition TGWin32VirtualXProxy.cxx:178; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerS",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:176465,Availability,error,error,176465,"FALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; kItimerResolution@ kItimerResolutionDefinition Rtypes.h:62; kMAXSIGNALS@ kMAXSIGNALSDefinition Rtypes.h:59; kMAXPATHLEN@ kMAXPATHLENDefinition Rtypes.h:60; TApplication.h; gApplicationR__EXTERN TApplication * gApplicationDefinition TApplication.h:170; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; TError.h; SysErrorvoid SysError(const char *location, const char *msgfmt,...)Use this function in case a system (OS or GUI) related error occurred.Definition TError.cxx:196; Breakvoid Break(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:207; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; TException.h; gExceptionHandlerR__EXTERN TExceptionHandler * gExceptionHandlerDefinition TException.h:79; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; directwinID h directDefinition TGWin32VirtualGLProxy.cxx:43; maskOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t maskDefinition TGWin32VirtualXProxy.cxx:178; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UIn",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:177158,Availability,mask,maskDefinition,177158,"Definition TEnv.h:170; TError.h; SysErrorvoid SysError(const char *location, const char *msgfmt,...)Use this function in case a system (OS or GUI) related error occurred.Definition TError.cxx:196; Breakvoid Break(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:207; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; TException.h; gExceptionHandlerR__EXTERN TExceptionHandler * gExceptionHandlerDefinition TException.h:79; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; directwinID h directDefinition TGWin32VirtualGLProxy.cxx:43; maskOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t maskDefinition TGWin32VirtualXProxy.cxx:178; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h offsetDefinition TGWin32VirtualXProxy.cxx:245; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetL",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:189561,Availability,error,error,189561,"ition TInetAddress.h:68; TInetAddress::fHostnameTString fHostnameDefinition TInetAddress.h:52; TInterpreter::GetSTLIncludePathvirtual const char * GetSTLIncludePath() constDefinition TInterpreter.h:163; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TListIterIterator of linked list.Definition TList.h:193; TListIter::NextTObject * Next() overrideReturn next object in the list. Returns 0 when no more objects in list.Definition TList.cxx:1109; TListA doubly linked list.Definition TList.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TOrdCollectionIterIterator of ordered collection.Definition TOrdCollection.h:96; TOrdCollectionIter::NextTObject * Next() overrideReturn next object in collection.Definition TOrdCollection.cxx:502; TOrdCollectionOrdered collection.Definition TOrdCollection.h:32; TPRegexpDefinition TPRegexp.h:36; TPRegexp::SubstituteInt_t Substitute(TString &s, const TString &replace, const TString &mods="""", Int_t start=0, Int_t nMatchMax=10)Substitute replaces the string s by a new string in which matching patterns are replaced by the repla...Definition TPRegexp.cxx:561; TROOT::ShutDownstatic void ShutDown()Shut down ROOT.Definition TROOT.cxx:3140; TROOT::GetEtcDirstatic const TString & GetEtcDir",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:189828,Availability,error,error,189828,"on TCollection.h:254; TListIterIterator of linked list.Definition TList.h:193; TListIter::NextTObject * Next() overrideReturn next object in the list. Returns 0 when no more objects in list.Definition TList.cxx:1109; TListA doubly linked list.Definition TList.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TOrdCollectionIterIterator of ordered collection.Definition TOrdCollection.h:96; TOrdCollectionIter::NextTObject * Next() overrideReturn next object in collection.Definition TOrdCollection.cxx:502; TOrdCollectionOrdered collection.Definition TOrdCollection.h:32; TPRegexpDefinition TPRegexp.h:36; TPRegexp::SubstituteInt_t Substitute(TString &s, const TString &replace, const TString &mods="""", Int_t start=0, Int_t nMatchMax=10)Substitute replaces the string s by a new string in which matching patterns are replaced by the repla...Definition TPRegexp.cxx:561; TROOT::ShutDownstatic void ShutDown()Shut down ROOT.Definition TROOT.cxx:3140; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetLibDirstatic const TString & GetLibDir()Get the library directory in the installation. Static utility function.Definition TROOT.cxx:3014; TRegexpRegular expres",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:190473,Availability,down,down,190473,"xx:444; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TOrdCollectionIterIterator of ordered collection.Definition TOrdCollection.h:96; TOrdCollectionIter::NextTObject * Next() overrideReturn next object in collection.Definition TOrdCollection.cxx:502; TOrdCollectionOrdered collection.Definition TOrdCollection.h:32; TPRegexpDefinition TPRegexp.h:36; TPRegexp::SubstituteInt_t Substitute(TString &s, const TString &replace, const TString &mods="""", Int_t start=0, Int_t nMatchMax=10)Substitute replaces the string s by a new string in which matching patterns are replaced by the repla...Definition TPRegexp.cxx:561; TROOT::ShutDownstatic void ShutDown()Shut down ROOT.Definition TROOT.cxx:3140; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetLibDirstatic const TString & GetLibDir()Get the library directory in the installation. Static utility function.Definition TROOT.cxx:3014; TRegexpRegular expression class.Definition TRegexp.h:31; TSignalHandlerDefinition TSysEvtHandler.h:127; TSignalHandler::NotifyBool_t Notify() overrideNotify when signal occurs.Definition TSysEvtHandler.cxx:159; TSignalHandler::IsSyncBool_t IsSync() constDefinition TSysEvtHandler.h:143; TSignalHandler::GetSignalESignals GetSignal() constDefinition TSysEvtHandler.h:141; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::GetsBool_t Gets(FILE *fp, Bool_t chop=kTRUE)Read one line fr",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:193985,Availability,error,error,193985,"t descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TString::AtollLong64_t Atoll() constReturn long long value of string.Definition TString.cxx:2014; TSysEvtHandler::IsActiveBool_t IsActive() constDefinition TSysEvtHandler.h:41; TSystemAbstract base class defining a generic interface to the underlying Operating System.Definition TSystem.h:266; TSystem::Unloadvirtual void Unload(const char *module)Unload a shared library.Definition TSystem.cxx:2052; TSystem::fFileHandlerTSeqCollection * fFileHandlerDefinition TSystem.h:296; TSystem::fMaxrfdInt_t fMaxrfdDefinition TSystem.h:281; TSystem::AddFileHandlervirtual void AddFileHandler(TFileHandler *fh)Add a file handler to the list of system file handlers.Definition TSystem.cxx:554; TSystem::GetLastErrorStringTString & GetLastErrorString()Return the thread local storage for the custom last error message.Definition TSystem.cxx:2102; TSystem::DynFindSymbolvirtual Func_t DynFindSymbol(const char *module, const char *entry)Find specific entry point in specified library.Definition TSystem.cxx:2044; TSystem::ResetErrnostatic void ResetErrno()Static function resetting system error number.Definition TSystem.cxx:284; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::GetErrnostatic Int_t GetErrno()Static function returning system error number.Definition TSystem.cxx:276; TSystem::kDefault@ kDefaultDefinition TSystem.h:269; TSystem::fReadmaskTFdSet * fReadmaskDefinition TSystem.h:275; TSystem::fWdpathTString fWdpathDefinition TSystem.h:284; TSystem::DirNamevirtual const char * DirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1006; TSystem::FreeDirectoryvirtual void FreeDire",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:194269,Availability,error,error,194269,"urn long long value of string.Definition TString.cxx:2014; TSysEvtHandler::IsActiveBool_t IsActive() constDefinition TSysEvtHandler.h:41; TSystemAbstract base class defining a generic interface to the underlying Operating System.Definition TSystem.h:266; TSystem::Unloadvirtual void Unload(const char *module)Unload a shared library.Definition TSystem.cxx:2052; TSystem::fFileHandlerTSeqCollection * fFileHandlerDefinition TSystem.h:296; TSystem::fMaxrfdInt_t fMaxrfdDefinition TSystem.h:281; TSystem::AddFileHandlervirtual void AddFileHandler(TFileHandler *fh)Add a file handler to the list of system file handlers.Definition TSystem.cxx:554; TSystem::GetLastErrorStringTString & GetLastErrorString()Return the thread local storage for the custom last error message.Definition TSystem.cxx:2102; TSystem::DynFindSymbolvirtual Func_t DynFindSymbol(const char *module, const char *entry)Find specific entry point in specified library.Definition TSystem.cxx:2044; TSystem::ResetErrnostatic void ResetErrno()Static function resetting system error number.Definition TSystem.cxx:284; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::GetErrnostatic Int_t GetErrno()Static function returning system error number.Definition TSystem.cxx:276; TSystem::kDefault@ kDefaultDefinition TSystem.h:269; TSystem::fReadmaskTFdSet * fReadmaskDefinition TSystem.h:275; TSystem::fWdpathTString fWdpathDefinition TSystem.h:284; TSystem::DirNamevirtual const char * DirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1006; TSystem::FreeDirectoryvirtual void FreeDirectory(void *dirp)Free a directory.Definition TSystem.cxx:845; TSystem::OpenDirectoryvirtual void * OpenDirectory(const char *name)Open a directory. Returns 0 if directory does not exist.Definition TSystem.cxx:836; TSystem::GetPidvirtual int GetPid()Get process id.Definition TSystem.cxx:707; TSystem:",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:194544,Availability,error,error,194544," void Unload(const char *module)Unload a shared library.Definition TSystem.cxx:2052; TSystem::fFileHandlerTSeqCollection * fFileHandlerDefinition TSystem.h:296; TSystem::fMaxrfdInt_t fMaxrfdDefinition TSystem.h:281; TSystem::AddFileHandlervirtual void AddFileHandler(TFileHandler *fh)Add a file handler to the list of system file handlers.Definition TSystem.cxx:554; TSystem::GetLastErrorStringTString & GetLastErrorString()Return the thread local storage for the custom last error message.Definition TSystem.cxx:2102; TSystem::DynFindSymbolvirtual Func_t DynFindSymbol(const char *module, const char *entry)Find specific entry point in specified library.Definition TSystem.cxx:2044; TSystem::ResetErrnostatic void ResetErrno()Static function resetting system error number.Definition TSystem.cxx:284; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::GetErrnostatic Int_t GetErrno()Static function returning system error number.Definition TSystem.cxx:276; TSystem::kDefault@ kDefaultDefinition TSystem.h:269; TSystem::fReadmaskTFdSet * fReadmaskDefinition TSystem.h:275; TSystem::fWdpathTString fWdpathDefinition TSystem.h:284; TSystem::DirNamevirtual const char * DirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1006; TSystem::FreeDirectoryvirtual void FreeDirectory(void *dirp)Free a directory.Definition TSystem.cxx:845; TSystem::OpenDirectoryvirtual void * OpenDirectory(const char *name)Open a directory. Returns 0 if directory does not exist.Definition TSystem.cxx:836; TSystem::GetPidvirtual int GetPid()Get process id.Definition TSystem.cxx:707; TSystem::fHostnameTString fHostnameDefinition TSystem.h:285; TSystem::NextTimeOutvirtual Long_t NextTimeOut(Bool_t mode)Time when next timer of mode (synchronous=kTRUE or asynchronous=kFALSE) will time-out (in ms).Definition TSystem.cxx:494; TSystem::SetSockOptvirtual int SetSockOpt(",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:203629,Availability,mask,mask,203629,"nect(const char *hostname, int port)Creates a UDP socket connection Is called via the TSocket constructor.Definition TUnixSystem.cxx:4197; TUnixSystem::CopyFileint CopyFile(const char *from, const char *to, Bool_t overwrite=kFALSE) overrideCopy a file.Definition TUnixSystem.cxx:1598; TUnixSystem::RemoveTimerTTimer * RemoveTimer(TTimer *ti) overrideRemove timer from list of system timers.Definition TUnixSystem.cxx:3018; TUnixSystem::AnnounceUdpServiceint AnnounceUdpService(int port, int backlog) overrideAnnounce UDP service.Definition TUnixSystem.cxx:3250; TUnixSystem::AnnounceUnixServiceint AnnounceUnixService(int port, int backlog) overrideAnnounce unix domain service on path ""kServerPath/<port>"".Definition TUnixSystem.cxx:3258; TUnixSystem::UnixTcpConnectstatic int UnixTcpConnect(const char *hostname, int port, int tcpwindowsize)Open a TCP/IP connection to server and connect to a service (i.e.Definition TUnixSystem.cxx:4145; TUnixSystem::SetFPEMaskInt_t SetFPEMask(Int_t mask=kDefaultMask) overrideSet which conditions trigger a floating point exception.Definition TUnixSystem.cxx:999; TUnixSystem::UnixGetdirentrystatic const char * UnixGetdirentry(void *dir)Returns the next directory entry.Definition TUnixSystem.cxx:4010; TUnixSystem::Setenvvoid Setenv(const char *name, const char *value) overrideSet environment variable.Definition TUnixSystem.cxx:2129; TUnixSystem::ConnectServiceint ConnectService(const char *server, int port, int tcpwindowsize, const char *protocol=""tcp"")Connect to service servicename on server servername.Definition TUnixSystem.cxx:3201; TUnixSystem::ChangeDirectoryBool_t ChangeDirectory(const char *path) overrideChange directory. Returns kTRUE in case of success, kFALSE otherwise.Definition TUnixSystem.cxx:1434; TUnixSystem::UnixHomedirectorystatic const char * UnixHomedirectory(const char *user=nullptr)Returns the user's home directory.Definition TUnixSystem.cxx:3935; TUnixSystem::GetServiceByPortchar * GetServiceByPort(int port) overrideGet name",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:209424,Availability,error,error,209424,"n TUnixSystem.cxx:3171; TUnixSystem::FindFileconst char * FindFile(const char *search, TString &file, EAccessMode mode=kFileExists) overrideFind location of file ""wfil"" in a search path.Definition TUnixSystem.cxx:1927; TUnixSystem::SigAlarmInterruptsSyscallsvoid SigAlarmInterruptsSyscalls(Bool_t set) overrideWhen the argument is true the SIGALRM signal handler is set so that interrupted syscalls will not be ...Definition TUnixSystem.cxx:908; TUnixSystem::UnixUdpServicestatic int UnixUdpService(int port, int backlog)Open a socket, bind to it and start listening for UDP connections on the port.Definition TUnixSystem.cxx:4373; TUnixSystem::Utimeint Utime(const char *file, Long_t modtime, Long_t actime) overrideSet a files modification and access times.Definition TUnixSystem.cxx:1910; TUnixSystem::GetLinkedLibrariesconst char * GetLinkedLibraries() overrideGet list of shared libraries loaded at the start of the executable.Definition TUnixSystem.cxx:2857; TUnixSystem::GetErrorconst char * GetError() overrideReturn system error string.Definition TUnixSystem.cxx:719; TUnixSystem::GetWorkingDirectorystd::string GetWorkingDirectory() const overrideReturn working directory.Definition TUnixSystem.cxx:1463; TUnixSystem::AccessPathNameBool_t AccessPathName(const char *path, EAccessMode mode=kFileExists) overrideReturns FALSE if one can access a file using the specified access mode.Definition TUnixSystem.cxx:1579; TUnixSystem::TempFileNameFILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr) overrideCreate a secure temporary file by appending a unique 6 letter string to base.Definition TUnixSystem.cxx:1523; TUnixSystem::DispatchOneEventvoid DispatchOneEvent(Bool_t pendingOnly=kFALSE) overrideDispatch a single event.Definition TUnixSystem.cxx:1093; TUnixSystem::Chmodint Chmod(const char *file, UInt_t mode) overrideSet the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TUnixSystem.cxx:1893; TUnixSystem::PrependPathNamecon",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:210309,Availability,error,error,210309,"f the executable.Definition TUnixSystem.cxx:2857; TUnixSystem::GetErrorconst char * GetError() overrideReturn system error string.Definition TUnixSystem.cxx:719; TUnixSystem::GetWorkingDirectorystd::string GetWorkingDirectory() const overrideReturn working directory.Definition TUnixSystem.cxx:1463; TUnixSystem::AccessPathNameBool_t AccessPathName(const char *path, EAccessMode mode=kFileExists) overrideReturns FALSE if one can access a file using the specified access mode.Definition TUnixSystem.cxx:1579; TUnixSystem::TempFileNameFILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr) overrideCreate a secure temporary file by appending a unique 6 letter string to base.Definition TUnixSystem.cxx:1523; TUnixSystem::DispatchOneEventvoid DispatchOneEvent(Bool_t pendingOnly=kFALSE) overrideDispatch a single event.Definition TUnixSystem.cxx:1093; TUnixSystem::Chmodint Chmod(const char *file, UInt_t mode) overrideSet the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TUnixSystem.cxx:1893; TUnixSystem::PrependPathNameconst char * PrependPathName(const char *dir, TString &name) overrideConcatenate a directory and a file name.Definition TUnixSystem.cxx:1552; TUnixSystem::DispatchTimersBool_t DispatchTimers(Bool_t mode)Handle and dispatch timers.Definition TUnixSystem.cxx:2979; TUnixSystem::IgnoreSignalvoid IgnoreSignal(ESignals sig, Bool_t ignore=kTRUE) overrideIf ignore is true ignore the specified signal, else restore previous behaviour.Definition TUnixSystem.cxx:895; TUnixSystem::ListSymbolsvoid ListSymbols(const char *module, const char *re="""") overrideList symbols in a shared library.Definition TUnixSystem.cxx:2840; TUnixSystem::Loadint Load(const char *module, const char *entry="""", Bool_t system=kFALSE) overrideLoad a shared library.Definition TUnixSystem.cxx:2824; TUnixSystem::StackTracevoid StackTrace() overridePrint a stack trace.Definition TUnixSystem.cxx:2281; TUnixSystem::GetHostByNameTInetAddress GetHostByN",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:215521,Availability,failure,failure,215521,"::UnixTcpServicestatic int UnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize)Open a socket, bind to it and start listening for TCP/IP connections on the port.Definition TUnixSystem.cxx:4297; TUnixSystem::DispatchSignalsvoid DispatchSignals(ESignals sig)Handle and dispatch signals.Definition TUnixSystem.cxx:3648; TUnixSystem::AddFileHandlervoid AddFileHandler(TFileHandler *fh) overrideAdd a file handler to the list of system file handlers.Definition TUnixSystem.cxx:782; TUnixSystem::GetCryptoRandomInt_t GetCryptoRandom(void *buf, Int_t len) overrideReturn cryptographic random number Fill provided buffer with random values Returns number of bytes wr...Definition TUnixSystem.cxx:740; TUnixSystem::OpenDirectoryvoid * OpenDirectory(const char *name) overrideOpen a Unix file system directory. Returns 0 if directory does not exist.Definition TUnixSystem.cxx:1392; TUnixSystem::Renameint Rename(const char *from, const char *to) overrideRename a file. Returns 0 when successful, -1 in case of failure.Definition TUnixSystem.cxx:1632; TUnixSystem::Getenvconst char * Getenv(const char *name) overrideGet environment variable.Definition TUnixSystem.cxx:2137; TUnixSystem::GetPathInfoint GetPathInfo(const char *path, FileStat_t &buf) overrideGet info about a file.Definition TUnixSystem.cxx:1658; TUnixSystem::GetEffectiveGidInt_t GetEffectiveGid() overrideReturns the effective group id.Definition TUnixSystem.cxx:2045; TUnixSystem::UnixSelectstatic int UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready, Long_t timeout)Wait for events on the file descriptors specified in the readready and writeready masks or for timeou...Definition TUnixSystem.cxx:3901; TUnixSystem::GetPidint GetPid() overrideGet process id.Definition TUnixSystem.cxx:2179; TUnixSystem::ExecInt_t Exec(const char *shellcmd) overrideExecute a command.Definition TUnixSystem.cxx:2155; TUnixSystem::ResetTimervoid ResetTimer(TTimer *ti) overrideReset a-sync timer.Definition TUnixSystem.cxx:3033; T",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:216140,Availability,mask,masks,216140,"void *buf, Int_t len) overrideReturn cryptographic random number Fill provided buffer with random values Returns number of bytes wr...Definition TUnixSystem.cxx:740; TUnixSystem::OpenDirectoryvoid * OpenDirectory(const char *name) overrideOpen a Unix file system directory. Returns 0 if directory does not exist.Definition TUnixSystem.cxx:1392; TUnixSystem::Renameint Rename(const char *from, const char *to) overrideRename a file. Returns 0 when successful, -1 in case of failure.Definition TUnixSystem.cxx:1632; TUnixSystem::Getenvconst char * Getenv(const char *name) overrideGet environment variable.Definition TUnixSystem.cxx:2137; TUnixSystem::GetPathInfoint GetPathInfo(const char *path, FileStat_t &buf) overrideGet info about a file.Definition TUnixSystem.cxx:1658; TUnixSystem::GetEffectiveGidInt_t GetEffectiveGid() overrideReturns the effective group id.Definition TUnixSystem.cxx:2045; TUnixSystem::UnixSelectstatic int UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready, Long_t timeout)Wait for events on the file descriptors specified in the readready and writeready masks or for timeou...Definition TUnixSystem.cxx:3901; TUnixSystem::GetPidint GetPid() overrideGet process id.Definition TUnixSystem.cxx:2179; TUnixSystem::ExecInt_t Exec(const char *shellcmd) overrideExecute a command.Definition TUnixSystem.cxx:2155; TUnixSystem::ResetTimervoid ResetTimer(TTimer *ti) overrideReset a-sync timer.Definition TUnixSystem.cxx:3033; TUnixSystem::RemoveSignalHandlerTSignalHandler * RemoveSignalHandler(TSignalHandler *sh) overrideRemove a signal handler from list of signal handlers.Definition TUnixSystem.cxx:849; TUnixSystem::UnixSignalstatic void UnixSignal(ESignals sig, SigHandler_t h)Set a signal handler for a signal.Definition TUnixSystem.cxx:3703; TUnixSystem::CloseConnectionvoid CloseConnection(int sock, Bool_t force=kFALSE) overrideClose socket.Definition TUnixSystem.cxx:3298; TUnixSystem::CheckDescriptorsBool_t CheckDescriptors()Check if there is activity on some",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:217385,Availability,mask,mask,217385,"; TUnixSystem::ResetTimervoid ResetTimer(TTimer *ti) overrideReset a-sync timer.Definition TUnixSystem.cxx:3033; TUnixSystem::RemoveSignalHandlerTSignalHandler * RemoveSignalHandler(TSignalHandler *sh) overrideRemove a signal handler from list of signal handlers.Definition TUnixSystem.cxx:849; TUnixSystem::UnixSignalstatic void UnixSignal(ESignals sig, SigHandler_t h)Set a signal handler for a signal.Definition TUnixSystem.cxx:3703; TUnixSystem::CloseConnectionvoid CloseConnection(int sock, Bool_t force=kFALSE) overrideClose socket.Definition TUnixSystem.cxx:3298; TUnixSystem::CheckDescriptorsBool_t CheckDescriptors()Check if there is activity on some file descriptors and call their Notify() member.Definition TUnixSystem.cxx:1337; TUnixSystem::InitBool_t Init() overrideInitialize Unix system interface.Definition TUnixSystem.cxx:595; TUnixSystem::Unloadvoid Unload(const char *module) overrideUnload a shared library.Definition TUnixSystem.cxx:2832; TUnixSystem::Umaskint Umask(Int_t mask) overrideSet the process file creation mode mask.Definition TUnixSystem.cxx:1901; TUnixSystem::UnixFilestatstatic int UnixFilestat(const char *path, FileStat_t &buf)Get info about a file.Definition TUnixSystem.cxx:4039; TUnixSystem::UnixRecvstatic int UnixRecv(int sock, void *buf, int len, int flag)Receive exactly length bytes into buffer.Definition TUnixSystem.cxx:4508; TUnixSystem::GetEffectiveUidInt_t GetEffectiveUid() overrideReturns the effective user id.Definition TUnixSystem.cxx:2021; TUnixSystem::FillWithCwdvoid FillWithCwd(char *cwd) constFill buffer with current working directory.Definition TUnixSystem.cxx:1473; TUnixSystem::UnixWaitchildstatic int UnixWaitchild()Wait till child is finished.Definition TUnixSystem.cxx:4130; TUnixSystem::Unlinkint Unlink(const char *name) overrideUnlink, i.e.Definition TUnixSystem.cxx:1708; TUnixSystem::ListLibrariesvoid ListLibraries(const char *regexp="""") overrideList all loaded shared libraries.Definition TUnixSystem.cxx:2848; TUnixSystem::C",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:217434,Availability,mask,mask,217434,"; TUnixSystem::ResetTimervoid ResetTimer(TTimer *ti) overrideReset a-sync timer.Definition TUnixSystem.cxx:3033; TUnixSystem::RemoveSignalHandlerTSignalHandler * RemoveSignalHandler(TSignalHandler *sh) overrideRemove a signal handler from list of signal handlers.Definition TUnixSystem.cxx:849; TUnixSystem::UnixSignalstatic void UnixSignal(ESignals sig, SigHandler_t h)Set a signal handler for a signal.Definition TUnixSystem.cxx:3703; TUnixSystem::CloseConnectionvoid CloseConnection(int sock, Bool_t force=kFALSE) overrideClose socket.Definition TUnixSystem.cxx:3298; TUnixSystem::CheckDescriptorsBool_t CheckDescriptors()Check if there is activity on some file descriptors and call their Notify() member.Definition TUnixSystem.cxx:1337; TUnixSystem::InitBool_t Init() overrideInitialize Unix system interface.Definition TUnixSystem.cxx:595; TUnixSystem::Unloadvoid Unload(const char *module) overrideUnload a shared library.Definition TUnixSystem.cxx:2832; TUnixSystem::Umaskint Umask(Int_t mask) overrideSet the process file creation mode mask.Definition TUnixSystem.cxx:1901; TUnixSystem::UnixFilestatstatic int UnixFilestat(const char *path, FileStat_t &buf)Get info about a file.Definition TUnixSystem.cxx:4039; TUnixSystem::UnixRecvstatic int UnixRecv(int sock, void *buf, int len, int flag)Receive exactly length bytes into buffer.Definition TUnixSystem.cxx:4508; TUnixSystem::GetEffectiveUidInt_t GetEffectiveUid() overrideReturns the effective user id.Definition TUnixSystem.cxx:2021; TUnixSystem::FillWithCwdvoid FillWithCwd(char *cwd) constFill buffer with current working directory.Definition TUnixSystem.cxx:1473; TUnixSystem::UnixWaitchildstatic int UnixWaitchild()Wait till child is finished.Definition TUnixSystem.cxx:4130; TUnixSystem::Unlinkint Unlink(const char *name) overrideUnlink, i.e.Definition TUnixSystem.cxx:1708; TUnixSystem::ListLibrariesvoid ListLibraries(const char *regexp="""") overrideList all loaded shared libraries.Definition TUnixSystem.cxx:2848; TUnixSystem::C",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:17666,Deployability,install,install,17666,"//////////////////////////////////////////////; 579/// Reset to original state.; 580 ; 581TUnixSystem::~TUnixSystem(); 582{; 583 UnixResetSignals();; 584 ; 585 delete fReadmask;; 586 delete fWritemask;; 587 delete fReadready;; 588 delete fWriteready;; 589 delete fSignals;; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////; 593/// Initialize Unix system interface.; 594 ; 595Bool_t TUnixSystem::Init(); 596{; 597 if (TSystem::Init()); 598 return kTRUE;; 599 ; 600 fReadmask = new TFdSet;; 601 fWritemask = new TFdSet;; 602 fReadready = new TFdSet;; 603 fWriteready = new TFdSet;; 604 fSignals = new TFdSet;; 605 ; 606 //--- install default handlers; 607 UnixSignal(kSigChild, SigHandler);; 608 UnixSignal(kSigBus, SigHandler);; 609 UnixSignal(kSigSegmentationViolation, SigHandler);; 610 UnixSignal(kSigIllegalInstruction, SigHandler);; 611 UnixSignal(kSigAbort, SigHandler);; 612 UnixSignal(kSigSystem, SigHandler);; 613 UnixSignal(kSigAlarm, SigHandler);; 614 UnixSignal(kSigUrgent, SigHandler);; 615 UnixSignal(kSigFloatingException, SigHandler);; 616 UnixSignal(kSigWindowChanged, SigHandler);; 617 UnixSignal(kSigUser2, SigHandler);; 618 ; 619#if defined(R__MACOSX); 620 // trap loading of all dylibs to register dylib name,; 621 // sets also ROOTSYS if built without ROOTPREFIX; 622 _dyld_register_func_for_add_image(DylibAdded);; 623#elif defined(HAVE_DLADDR); 624 SetRootSys();; 625#endif; 626 ; 627 // This is a fallback in case TROOT::GetRootSys() can't determine ROOTSYS; 628 gRootDir = ROOT::FoundationUtils::GetFallbackRootSys().c_str();; 629 ; 630 return kFALSE;; 631}; 632 ; 633//---- Misc --------------------------------------------------------------------; 634 ; 635////////////////////////////////////////////////////////////////////////////////; 636/// Set the application name (from command line, argv[0]) and copy it in; 637/// gProgName. Copy the application pathname in gProgPath.; 638/// If name is 0 let the system set the actu",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:75450,Deployability,upgrade,upgrade-gdb-wont-attach-to-process,75450,";; 2400 ; 2401#if (__GNUC__ >= 3); 2402 // try finding supported format option for g++ v3; 2403 if (filter) {; 2404 FILE *p = OpenPipe(TString::Format(""%s --help 2>&1"", filter), ""r"");; 2405 TString help;; 2406 while (help.Gets(p)) {; 2407 if (help.Index(""gnu-v3"") != kNPOS) {; 2408 cppfiltarg = ""--format=gnu-v3"";; 2409 break;; 2410 } else if (help.Index(""gnu-new-abi"") != kNPOS) {; 2411 cppfiltarg = ""--format=gnu-new-abi"";; 2412 break;; 2413 }; 2414 }; 2415 ClosePipe(p);; 2416 }; 2417#endif; 2418 // gdb-backtrace.sh uses gdb to produce a backtrace. See if it is available.; 2419 // If it is, use it. If not proceed as before.; 2420#if (defined(R__LINUX) && !defined(R__WINGCC)); 2421 // Declare the process that will be generating the stacktrace; 2422 // For more see: http://askubuntu.com/questions/41629/after-upgrade-gdb-wont-attach-to-process; 2423#ifdef PR_SET_PTRACER; 2424 prctl(PR_SET_PTRACER, getpid(), 0, 0, 0);; 2425#endif; 2426#endif; 2427 char *gdb = Which(Getenv(""PATH""), ""gdb"", kExecutePermission);; 2428 if (gdb) {; 2429 // write custom message file; 2430 TString gdbmessf = ""gdb-message"";; 2431 if (gdbmess != """") {; 2432 FILE *f = TempFileName(gdbmessf);; 2433 fprintf(f, ""%s\n"", gdbmess.Data());; 2434 fclose(f);; 2435 }; 2436 ; 2437 // use gdb to get stack trace; 2438#ifdef R__MACOSX; 2439 gdbscript += GetExePath();; 2440 gdbscript += "" "";; 2441#endif; 2442 gdbscript += GetPid();; 2443 if (gdbmess != """") {; 2444 gdbscript += "" "";; 2445 gdbscript += gdbmessf;; 2446 }; 2447 gdbscript += "" 1>&2"";; 2448 Exec(gdbscript);; 2449 delete [] gdb;; 2450 } else {; 2451 // addr2line uses debug info to convert addresses into file names; 2452 // and line numbers; 2453#ifdef R__MACOSX; 2454 char *addr2line = Which(Getenv(""PATH""), ""atos"", kExecutePermission);; 2455#else; 2456 char *addr2line = Which(Getenv(""PATH""), ""addr2line"", kExecutePermission);; 2457#endif; 2458 if (addr2line) {; 2459 // might take some time so tell what we are doing...; 2460 if (write(fd, message, strlen(me",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:81012,Deployability,update,update,81012,");; 2556 }; 2557 ; 2558 if (demangle) {; 2559 TString tmpf2 = ""gdb-backtrace"";; 2560 FILE *f = TempFileName(tmpf2);; 2561 if (f) fclose(f);; 2562 file1.close();; 2563 snprintf(buffer, sizeof(buffer), ""%s %s < %s > %s"", filter, cppfiltarg, tmpf1.Data(), tmpf2.Data());; 2564 Exec(buffer);; 2565 std::ifstream file2(tmpf2);; 2566 TString line;; 2567 while (file2) {; 2568 line = """";; 2569 line.ReadString(file2);; 2570 if (write(fd, line.Data(), line.Length()) < 0); 2571 Warning(""StackTrace"", ""problems writing line (errno: %d)"", TSystem::GetErrno());; 2572 }; 2573 file2.close();; 2574 Unlink(tmpf1);; 2575 Unlink(tmpf2);; 2576 }; 2577 ; 2578 delete [] addr2line;; 2579 }; 2580 delete [] filter;; 2581#elif defined(HAVE_EXCPT_H) && defined(HAVE_PDSC_H) && \; 2582 defined(HAVE_RLD_INTERFACE_H) // tru64; 2583 // Tru64 stack walk. Uses the exception handling library and the; 2584 // run-time linker's core functions (loader(5)). FIXME: Tru64; 2585 // should have _RLD_DLADDR like IRIX below. Verify and update.; 2586 ; 2587 char buffer [128];; 2588 sigcontext context;; 2589 int rc = 0;; 2590 ; 2591 exc_capture_context (&context);; 2592 while (!rc && context.sc_pc) {; 2593 // FIXME: Elf32?; 2594 pdsc_crd *func, *base, *crd; 2595 = exc_remote_lookup_function_entry(0, 0, context.sc_pc, 0, &func, &base);; 2596 Elf32_Addr addr = PDSC_CRD_BEGIN_ADDRESS(base, func);; 2597 // const char *name = _rld_address_to_name(addr);; 2598 const char *name = ""<unknown function>"";; 2599 sprintf(buffer, "" 0x%012lx %.200s + 0x%lx\n"",; 2600 context.sc_pc, name, context.sc_pc - addr);; 2601 write(fd, buffer, ::strlen(buffer));; 2602 rc = exc_virtual_unwind(0, &context);; 2603 }; 2604#endif; 2605#else //R__MACOSX; 2606 macosx_backtrace();; 2607#endif //R__MACOSX; 2608}; 2609 ; 2610//---- System Logging ----------------------------------------------------------; 2611 ; 2612////////////////////////////////////////////////////////////////////////////////; 2613/// Open connection to system log daemon. For the us",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:148059,Deployability,update,update,148059," search path. Static utility function.; 4596 ; 4597static const char *DynamicPath(const char *newpath = nullptr, Bool_t reset = kFALSE); 4598{; 4599 static TString dynpath_full;; 4600 static std::atomic<bool> initialized(kFALSE);; 4601 static std::atomic<bool> seenCling(kFALSE);; 4602 ; 4603 // If we have not seen Cling but the result has been initialized and gCling; 4604 // is still nullptr, the result won't change.; 4605 if (newpath == nullptr && !reset && (seenCling || (initialized && gCling == nullptr))); 4606 return dynpath_full;; 4607 ; 4608 R__LOCKGUARD2(gSystemMutex);; 4609 ; 4610 if (newpath) {; 4611 dynpath_full = newpath;; 4612 // Don't erase the user given path at the next call.; 4613 initialized = kTRUE;; 4614 // We do not (otherwise) record whether the path was set automatically or; 4615 // whether it was set explicitly by the user. If the user set the path; 4616 // explicitly, we should never automatically over-ride the value; if; 4617 // seenCling stayed false, it would tell this routine that at the next; 4618 // call it should update the value (to insert the Cling provided parts); 4619 // back to the default.; 4620 seenCling = kTRUE;; 4621 return dynpath_full;; 4622 }; 4623 ; 4624 // Another thread might have updated this. Even-though this is executed at the; 4625 // start of the process, we might get there if the user is explicitly; 4626 // 'resetting' the value.; 4627 if (!reset && (seenCling || (initialized && gCling == nullptr))); 4628 return dynpath_full;; 4629 ; 4630 if (!initialized) {; 4631 // force one time initialization of gROOT before we start; 4632 // (otherwise it might be done as a side effect of gEnv->GetValue and; 4633 // TROOT's initialization will call this routine).; 4634 gROOT;; 4635 }; 4636 ; 4637 static TString dynpath_envpart;; 4638 static TString dynpath_syspart;; 4639 ; 4640 if (reset || !initialized) {; 4641 ; 4642 dynpath_envpart = gSystem->Getenv(""ROOT_LIBRARY_PATH"");; 4643 TString rdynpath = gEnv->GetValue(""Root.DynamicP",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:148245,Deployability,update,updated,148245,"c<bool> initialized(kFALSE);; 4601 static std::atomic<bool> seenCling(kFALSE);; 4602 ; 4603 // If we have not seen Cling but the result has been initialized and gCling; 4604 // is still nullptr, the result won't change.; 4605 if (newpath == nullptr && !reset && (seenCling || (initialized && gCling == nullptr))); 4606 return dynpath_full;; 4607 ; 4608 R__LOCKGUARD2(gSystemMutex);; 4609 ; 4610 if (newpath) {; 4611 dynpath_full = newpath;; 4612 // Don't erase the user given path at the next call.; 4613 initialized = kTRUE;; 4614 // We do not (otherwise) record whether the path was set automatically or; 4615 // whether it was set explicitly by the user. If the user set the path; 4616 // explicitly, we should never automatically over-ride the value; if; 4617 // seenCling stayed false, it would tell this routine that at the next; 4618 // call it should update the value (to insert the Cling provided parts); 4619 // back to the default.; 4620 seenCling = kTRUE;; 4621 return dynpath_full;; 4622 }; 4623 ; 4624 // Another thread might have updated this. Even-though this is executed at the; 4625 // start of the process, we might get there if the user is explicitly; 4626 // 'resetting' the value.; 4627 if (!reset && (seenCling || (initialized && gCling == nullptr))); 4628 return dynpath_full;; 4629 ; 4630 if (!initialized) {; 4631 // force one time initialization of gROOT before we start; 4632 // (otherwise it might be done as a side effect of gEnv->GetValue and; 4633 // TROOT's initialization will call this routine).; 4634 gROOT;; 4635 }; 4636 ; 4637 static TString dynpath_envpart;; 4638 static TString dynpath_syspart;; 4639 ; 4640 if (reset || !initialized) {; 4641 ; 4642 dynpath_envpart = gSystem->Getenv(""ROOT_LIBRARY_PATH"");; 4643 TString rdynpath = gEnv->GetValue(""Root.DynamicPath"", (char*)0);; 4644 rdynpath.ReplaceAll("": "", "":""); // in case DynamicPath was extended; 4645 if (rdynpath.IsNull()) {; 4646 rdynpath = "".:""; rdynpath += TROOT::GetLibDir();; 4647 }; 4648 TString l",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:170686,Deployability,patch,patchwork,170686,"fSwapFree = (s.Atoi() / 1024);; 5254 }; 5255 if (s.BeginsWith(""SwapCached"")) {; 5256 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5257 meminfo->fSwapCached = (s.Atoi() / 1024);; 5258 }; 5259 if (s.BeginsWith(""SReclaimable"")) {; 5260 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5261 meminfo->fSReclaimable = (s.Atoi() / 1024);; 5262 }; 5263 ; 5264 }; 5265 fclose(f);; 5266 ; 5267 /*; 5268 * Compute memory partition like procps(free), see https://gitlab.com/procps-ng/procps/-/blob/master/proc/sysinfo.c; 5269 * ; 5270 * fMemShared is a part of Cached (see https://lore.kernel.org/patchwork/patch/648763/), does not subtract twice from used; 5271 */; 5272 ; 5273 meminfo->fMemCached = meminfo->fMemCached + meminfo->fSReclaimable - meminfo->fMemShared;; 5274 const Int_t usedDiff = meminfo->fMemFree + meminfo->fMemCached + meminfo->fSReclaimable + meminfo->fMemBuffer;; 5275 ; 5276 meminfo->fMemUsed = (meminfo->fMemTotal >= usedDiff) ? meminfo->fMemTotal - usedDiff : meminfo->fMemTotal - meminfo->fMemFree;; 5277 meminfo->fMemAvailable = meminfo->fMemAvailable != 0 ? std::min(meminfo->fMemAvailable, meminfo->fMemTotal) : meminfo->fMemFree;; 5278 ; 5279 meminfo->fSwapUsed = meminfo->fSwapTotal - meminfo->fSwapFree - meminfo->fSwapCached;; 5280 ; 5281}; 5282 ; 5283////////////////////////////////////////////////////////////////////////////////; 5284/// Get process info for this process on Linux.; 5285 ; 5286static void GetLinuxProcInfo(ProcInfo_t *procinfo); 5287{; 5288 struct rusage ru;; 5289 if (getrusage(RUSAGE_SELF, &ru) < 0) {; 5290 ::SysError(""TUnixSystem::GetLinuxProcInfo"", ""getrusage failed"");; 5291 } else {; 5292 procinfo->fCpuUser = (Float_t)(ru.ru_utime.tv_sec) +; 5293 ((Float_t)(ru.ru_utime.tv_usec) / 1000000.);; 5294 procinfo->fCpuSys = (Float_t)(ru.ru_stime.tv_sec) +; 5295 ((Float_t)(ru.ru_stime.tv_usec) / 1000000.);; 5296 }; 5297 ; 5298 procinfo->fMemVirtual = -1;; 5299 procinfo->fMemResident = -1;; 5300 TString s;; 5301 FILE *f = fopen(TString::Format(""/p",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:170696,Deployability,patch,patch,170696,"fSwapFree = (s.Atoi() / 1024);; 5254 }; 5255 if (s.BeginsWith(""SwapCached"")) {; 5256 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5257 meminfo->fSwapCached = (s.Atoi() / 1024);; 5258 }; 5259 if (s.BeginsWith(""SReclaimable"")) {; 5260 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5261 meminfo->fSReclaimable = (s.Atoi() / 1024);; 5262 }; 5263 ; 5264 }; 5265 fclose(f);; 5266 ; 5267 /*; 5268 * Compute memory partition like procps(free), see https://gitlab.com/procps-ng/procps/-/blob/master/proc/sysinfo.c; 5269 * ; 5270 * fMemShared is a part of Cached (see https://lore.kernel.org/patchwork/patch/648763/), does not subtract twice from used; 5271 */; 5272 ; 5273 meminfo->fMemCached = meminfo->fMemCached + meminfo->fSReclaimable - meminfo->fMemShared;; 5274 const Int_t usedDiff = meminfo->fMemFree + meminfo->fMemCached + meminfo->fSReclaimable + meminfo->fMemBuffer;; 5275 ; 5276 meminfo->fMemUsed = (meminfo->fMemTotal >= usedDiff) ? meminfo->fMemTotal - usedDiff : meminfo->fMemTotal - meminfo->fMemFree;; 5277 meminfo->fMemAvailable = meminfo->fMemAvailable != 0 ? std::min(meminfo->fMemAvailable, meminfo->fMemTotal) : meminfo->fMemFree;; 5278 ; 5279 meminfo->fSwapUsed = meminfo->fSwapTotal - meminfo->fSwapFree - meminfo->fSwapCached;; 5280 ; 5281}; 5282 ; 5283////////////////////////////////////////////////////////////////////////////////; 5284/// Get process info for this process on Linux.; 5285 ; 5286static void GetLinuxProcInfo(ProcInfo_t *procinfo); 5287{; 5288 struct rusage ru;; 5289 if (getrusage(RUSAGE_SELF, &ru) < 0) {; 5290 ::SysError(""TUnixSystem::GetLinuxProcInfo"", ""getrusage failed"");; 5291 } else {; 5292 procinfo->fCpuUser = (Float_t)(ru.ru_utime.tv_sec) +; 5293 ((Float_t)(ru.ru_utime.tv_usec) / 1000000.);; 5294 procinfo->fCpuSys = (Float_t)(ru.ru_stime.tv_sec) +; 5295 ((Float_t)(ru.ru_stime.tv_usec) / 1000000.);; 5296 }; 5297 ; 5298 procinfo->fMemVirtual = -1;; 5299 procinfo->fMemResident = -1;; 5300 TString s;; 5301 FILE *f = fopen(TString::Format(""/p",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:190595,Deployability,install,installation,190595,"system error message.Definition TObject.cxx:1007; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TOrdCollectionIterIterator of ordered collection.Definition TOrdCollection.h:96; TOrdCollectionIter::NextTObject * Next() overrideReturn next object in collection.Definition TOrdCollection.cxx:502; TOrdCollectionOrdered collection.Definition TOrdCollection.h:32; TPRegexpDefinition TPRegexp.h:36; TPRegexp::SubstituteInt_t Substitute(TString &s, const TString &replace, const TString &mods="""", Int_t start=0, Int_t nMatchMax=10)Substitute replaces the string s by a new string in which matching patterns are replaced by the repla...Definition TPRegexp.cxx:561; TROOT::ShutDownstatic void ShutDown()Shut down ROOT.Definition TROOT.cxx:3140; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetLibDirstatic const TString & GetLibDir()Get the library directory in the installation. Static utility function.Definition TROOT.cxx:3014; TRegexpRegular expression class.Definition TRegexp.h:31; TSignalHandlerDefinition TSysEvtHandler.h:127; TSignalHandler::NotifyBool_t Notify() overrideNotify when signal occurs.Definition TSysEvtHandler.cxx:159; TSignalHandler::IsSyncBool_t IsSync() constDefinition TSysEvtHandler.h:143; TSignalHandler::GetSignalESignals GetSignal() constDefinition TSysEvtHandler.h:141; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::GetsBool_t Gets(FILE *fp, Bool_t chop=kTRUE)Read one line from the stream, including the \n, or until EOF.Definition Stringio.cxx:204; TString::EndsWithBool_t En",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:190743,Deployability,install,installation,190743," message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TOrdCollectionIterIterator of ordered collection.Definition TOrdCollection.h:96; TOrdCollectionIter::NextTObject * Next() overrideReturn next object in collection.Definition TOrdCollection.cxx:502; TOrdCollectionOrdered collection.Definition TOrdCollection.h:32; TPRegexpDefinition TPRegexp.h:36; TPRegexp::SubstituteInt_t Substitute(TString &s, const TString &replace, const TString &mods="""", Int_t start=0, Int_t nMatchMax=10)Substitute replaces the string s by a new string in which matching patterns are replaced by the repla...Definition TPRegexp.cxx:561; TROOT::ShutDownstatic void ShutDown()Shut down ROOT.Definition TROOT.cxx:3140; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetLibDirstatic const TString & GetLibDir()Get the library directory in the installation. Static utility function.Definition TROOT.cxx:3014; TRegexpRegular expression class.Definition TRegexp.h:31; TSignalHandlerDefinition TSysEvtHandler.h:127; TSignalHandler::NotifyBool_t Notify() overrideNotify when signal occurs.Definition TSysEvtHandler.cxx:159; TSignalHandler::IsSyncBool_t IsSync() constDefinition TSysEvtHandler.h:143; TSignalHandler::GetSignalESignals GetSignal() constDefinition TSysEvtHandler.h:141; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::GetsBool_t Gets(FILE *fp, Bool_t chop=kTRUE)Read one line from the stream, including the \n, or until EOF.Definition Stringio.cxx:204; TString::EndsWithBool_t EndsWith(const char *pat, ECaseCompare cmp=kExact) constReturn true if string ends with the specified string.Definition TString.cxx:2244; TString::Stri",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:34727,Energy Efficiency,monitor,monitoring,34727,"tch a single event.; 1092 ; 1093void TUnixSystem::DispatchOneEvent(Bool_t pendingOnly); 1094{; 1095 Bool_t pollOnce = pendingOnly;; 1096 ; 1097 while (1) {; 1098 // first handle any X11 events; 1099 if (gXDisplay && gXDisplay->Notify()) {; 1100 if (fReadready->IsSet(gXDisplay->GetFd())) {; 1101 fReadready->Clr(gXDisplay->GetFd());; 1102 fNfd--;; 1103 }; 1104 if (!pendingOnly) return;; 1105 }; 1106 ; 1107 // check for file descriptors ready for reading/writing; 1108 if (fNfd > 0 && fFileHandler && fFileHandler->GetSize() > 0); 1109 if (CheckDescriptors()); 1110 if (!pendingOnly) return;; 1111 fNfd = 0;; 1112 fReadready->Zero();; 1113 fWriteready->Zero();; 1114 ; 1115 if (pendingOnly && !pollOnce); 1116 return;; 1117 ; 1118 // check synchronous signals; 1119 if (fSigcnt > 0 && fSignalHandler->GetSize() > 0); 1120 if (CheckSignals(kTRUE)); 1121 if (!pendingOnly) return;; 1122 fSigcnt = 0;; 1123 fSignals->Zero();; 1124 ; 1125 // check synchronous timers; 1126 Long_t nextto;; 1127 if (fTimers && fTimers->GetSize() > 0); 1128 if (DispatchTimers(kTRUE)) {; 1129 // prevent timers from blocking file descriptor monitoring; 1130 nextto = NextTimeOut(kTRUE);; 1131 if (nextto > kItimerResolution || nextto == -1); 1132 return;; 1133 }; 1134 ; 1135 // if in pendingOnly mode poll once file descriptor activity; 1136 nextto = NextTimeOut(kTRUE);; 1137 if (pendingOnly) {; 1138 if (fFileHandler && fFileHandler->GetSize() == 0); 1139 return;; 1140 nextto = 0;; 1141 pollOnce = kFALSE;; 1142 }; 1143 ; 1144 // nothing ready, so setup select call; 1145 *fReadready = *fReadmask;; 1146 *fWriteready = *fWritemask;; 1147 ; 1148 int mxfd = TMath::Max(fMaxrfd, fMaxwfd);; 1149 mxfd++;; 1150 ; 1151 // if nothing to select (socket or timer) return; 1152 if (mxfd == 0 && nextto == -1); 1153 return;; 1154 ; 1155 fNfd = UnixSelect(mxfd, fReadready, fWriteready, nextto);; 1156 if (fNfd < 0 && fNfd != -2) {; 1157 int fd, rc;; 1158 TFdSet t;; 1159 for (fd = 0; fd < mxfd; fd++) {; 1160 t.Set(fd);; 1161 if (",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:814,Integrability,interface,interface,814,". ROOT: core/unix/src/TUnixSystem.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TUnixSystem.cxx. Go to the documentation of this file. 1// @(#)root/unix:$Id: 887c618d89c4ed436e4034fc133f468fecad651b $; 2// Author: Fons Rademakers 15/09/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12//////////////////////////////////////////////////////////////////////////; 13// //; 14// TUnixSystem //; 15// //; 16// Class providing an interface to the UNIX Operating System. //; 17// //; 18//////////////////////////////////////////////////////////////////////////; 19 ; 20#include ""RConfigure.h""; 21#include <ROOT/RConfig.hxx>; 22#include <ROOT/FoundationUtils.hxx>; 23#include ""TUnixSystem.h""; 24#include ""TROOT.h""; 25#include ""TError.h""; 26#include ""TOrdCollection.h""; 27#include ""TRegexp.h""; 28#include ""TPRegexp.h""; 29#include ""TException.h""; 30#include ""TEnv.h""; 31#include ""Getline.h""; 32#include ""TInterpreter.h""; 33#include ""TApplication.h""; 34#include ""TObjString.h""; 35#include ""TVirtualMutex.h""; 36#include ""ThreadLocalStorage.h""; 37#include ""TObjArray.h""; 38#include ""snprintf.h""; 39#include ""strlcpy.h""; 40#include <iostream>; 41#include <fstream>; 42#include <map>; 43#include <algorithm>; 44#include <atomic>; 45 ; 46//#define G__OLDEXPAND; 47 ; 48#include <unistd.h>; 49#include <stdlib.h>; 50#include <sys/types.h>; 51#if defined(R__SUN) || defined(R__AIX) || \; 52 defined(R__LINUX) || defined(R__SOLARIS) || \; 53 defined(R__FBSD) || defined(R__OBSD) || \; 54 defined(R__MACOSX) || defined(R__HURD); 55#define HAS_DIRENT; 56#endif; 57#ifdef HAS_DIRENT; 58# include <dirent.h>; 59#else; 60# include <sys",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:17396,Integrability,interface,interface,17396,"ib"") || lib.EndsWith("".so""))) {; 550 sovers = ""\\.[0-9]+\\.*[0-9]*\\.so"";; 551 Ssiz_t idx = lib.Index(sovers);; 552 if (idx != kNPOS) {; 553 lib.Remove(idx);; 554 lib += "".so"";; 555 }; 556 dyvers = ""\\.[0-9]+\\.*[0-9]*\\.dylib"";; 557 idx = lib.Index(dyvers);; 558 if (idx != kNPOS) {; 559 lib.Remove(idx);; 560 lib += "".dylib"";; 561 }; 562 if (!gSystem->AccessPathName(lib, kReadPermission)) {; 563 if (linkedDylibs.Length()); 564 linkedDylibs += "" "";; 565 linkedDylibs += lib;; 566 }; 567 }; 568}; 569#endif; 570 ; 571ClassImp(TUnixSystem);; 572 ; 573////////////////////////////////////////////////////////////////////////////////; 574 ; 575TUnixSystem::TUnixSystem() : TSystem(""Unix"", ""Unix System""); 576{ }; 577 ; 578////////////////////////////////////////////////////////////////////////////////; 579/// Reset to original state.; 580 ; 581TUnixSystem::~TUnixSystem(); 582{; 583 UnixResetSignals();; 584 ; 585 delete fReadmask;; 586 delete fWritemask;; 587 delete fReadready;; 588 delete fWriteready;; 589 delete fSignals;; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////; 593/// Initialize Unix system interface.; 594 ; 595Bool_t TUnixSystem::Init(); 596{; 597 if (TSystem::Init()); 598 return kTRUE;; 599 ; 600 fReadmask = new TFdSet;; 601 fWritemask = new TFdSet;; 602 fReadready = new TFdSet;; 603 fWriteready = new TFdSet;; 604 fSignals = new TFdSet;; 605 ; 606 //--- install default handlers; 607 UnixSignal(kSigChild, SigHandler);; 608 UnixSignal(kSigBus, SigHandler);; 609 UnixSignal(kSigSegmentationViolation, SigHandler);; 610 UnixSignal(kSigIllegalInstruction, SigHandler);; 611 UnixSignal(kSigAbort, SigHandler);; 612 UnixSignal(kSigSystem, SigHandler);; 613 UnixSignal(kSigAlarm, SigHandler);; 614 UnixSignal(kSigUrgent, SigHandler);; 615 UnixSignal(kSigFloatingException, SigHandler);; 616 UnixSignal(kSigWindowChanged, SigHandler);; 617 UnixSignal(kSigUser2, SigHandler);; 618 ; 619#if defined(R__MACOSX); 620 // trap loading of all",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:51271,Integrability,depend,dependend,51271,"= FindHelper(path);; 1646 if (helper); 1647 return helper->IsPathLocal(path);; 1648 ; 1649 return TSystem::IsPathLocal(path);; 1650}; 1651 ; 1652////////////////////////////////////////////////////////////////////////////////; 1653/// Get info about a file. Info is returned in the form of a FileStat_t; 1654/// structure (see TSystem.h).; 1655/// The function returns 0 in case of success and 1 if the file could; 1656/// not be stat'ed.; 1657 ; 1658int TUnixSystem::GetPathInfo(const char *path, FileStat_t &buf); 1659{; 1660 TSystem *helper = FindHelper(path);; 1661 if (helper); 1662 return helper->GetPathInfo(path, buf);; 1663 ; 1664 return UnixFilestat(path, buf);; 1665}; 1666 ; 1667////////////////////////////////////////////////////////////////////////////////; 1668/// Get info about a file system: id, bsize, bfree, blocks.; 1669/// Id is file system type (machine dependend, see statfs()); 1670/// Bsize is block size of file system; 1671/// Blocks is total number of blocks in file system; 1672/// Bfree is number of free blocks in file system; 1673/// The function returns 0 in case of success and 1 if the file system could; 1674/// not be stat'ed.; 1675 ; 1676int TUnixSystem::GetFsInfo(const char *path, Long_t *id, Long_t *bsize,; 1677 Long_t *blocks, Long_t *bfree); 1678{; 1679 return UnixFSstat(path, id, bsize, blocks, bfree);; 1680}; 1681 ; 1682////////////////////////////////////////////////////////////////////////////////; 1683/// Create a link from file1 to file2. Returns 0 when successful,; 1684/// -1 in case of failure.; 1685 ; 1686int TUnixSystem::Link(const char *from, const char *to); 1687{; 1688 return ::link(from, to);; 1689}; 1690 ; 1691////////////////////////////////////////////////////////////////////////////////; 1692/// Create a symlink from file1 to file2. Returns 0 when successful,; 1693/// -1 in case of failure.; 1694 ; 1695int TUnixSystem::Symlink(const char *from, const char *to); 1696{; 1697#if defined(R__AIX); 1698 return ::symlink((char*)fr",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:71920,Integrability,message,message,71920,"83 if (!gEnv->GetValue(""Root.Stacktrace"", 1)); 2284 return;; 2285 ; 2286#ifndef R__MACOSX; 2287 TString gdbscript = gEnv->GetValue(""Root.StacktraceScript"", """");; 2288 gdbscript = gdbscript.Strip();; 2289 if (gdbscript != """") {; 2290 if (AccessPathName(gdbscript, kReadPermission)) {; 2291 fprintf(stderr, ""Root.StacktraceScript %s does not exist\n"", gdbscript.Data());; 2292 gdbscript = """";; 2293 }; 2294 }; 2295 if (gdbscript == """") {; 2296 gdbscript = ""gdb-backtrace.sh"";; 2297 gSystem->PrependPathName(TROOT::GetEtcDir(), gdbscript);; 2298 if (AccessPathName(gdbscript, kReadPermission)) {; 2299 fprintf(stderr, ""Error in <TUnixSystem::StackTrace> script %s is missing\n"", gdbscript.Data());; 2300 return;; 2301 }; 2302 }; 2303 gdbscript += "" "";; 2304 ; 2305 TString gdbmess = gEnv->GetValue(""Root.StacktraceMessage"", """");; 2306 gdbmess = gdbmess.Strip();; 2307 ; 2308 std::cout.flush();; 2309 fflush(stdout);; 2310 ; 2311 std::cerr.flush();; 2312 fflush(stderr);; 2313 ; 2314 int fd = STDERR_FILENO;; 2315 ; 2316 const char *message = "" Generating stack trace...\n"";; 2317 ; 2318 if (fd && message) { } // remove unused warning (remove later); 2319 ; 2320 if (gApplication && !strcmp(gApplication->GetName(), ""TRint"")); 2321 Getlinem(kCleanUp, nullptr);; 2322 ; 2323#if defined(USE_GDB_STACK_TRACE); 2324 char *gdb = Which(Getenv(""PATH""), ""gdb"", kExecutePermission);; 2325 if (!gdb) {; 2326 fprintf(stderr, ""gdb not found, need it for stack trace\n"");; 2327 return;; 2328 }; 2329 ; 2330 // write custom message file; 2331 TString gdbmessf = ""gdb-message"";; 2332 if (gdbmess != """") {; 2333 FILE *f = TempFileName(gdbmessf);; 2334 fprintf(f, ""%s\n"", gdbmess.Data());; 2335 fclose(f);; 2336 }; 2337 ; 2338 // use gdb to get stack trace; 2339 gdbscript += GetExePath();; 2340 gdbscript += "" "";; 2341 gdbscript += GetPid();; 2342 if (gdbmess != """") {; 2343 gdbscript += "" "";; 2344 gdbscript += gdbmessf;; 2345 }; 2346 gdbscript += "" 1>&2"";; 2347 Exec(gdbscript);; 2348 delete [] gdb;; 2349 return;; 23",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:71985,Integrability,message,message,71985,"a());; 2292 gdbscript = """";; 2293 }; 2294 }; 2295 if (gdbscript == """") {; 2296 gdbscript = ""gdb-backtrace.sh"";; 2297 gSystem->PrependPathName(TROOT::GetEtcDir(), gdbscript);; 2298 if (AccessPathName(gdbscript, kReadPermission)) {; 2299 fprintf(stderr, ""Error in <TUnixSystem::StackTrace> script %s is missing\n"", gdbscript.Data());; 2300 return;; 2301 }; 2302 }; 2303 gdbscript += "" "";; 2304 ; 2305 TString gdbmess = gEnv->GetValue(""Root.StacktraceMessage"", """");; 2306 gdbmess = gdbmess.Strip();; 2307 ; 2308 std::cout.flush();; 2309 fflush(stdout);; 2310 ; 2311 std::cerr.flush();; 2312 fflush(stderr);; 2313 ; 2314 int fd = STDERR_FILENO;; 2315 ; 2316 const char *message = "" Generating stack trace...\n"";; 2317 ; 2318 if (fd && message) { } // remove unused warning (remove later); 2319 ; 2320 if (gApplication && !strcmp(gApplication->GetName(), ""TRint"")); 2321 Getlinem(kCleanUp, nullptr);; 2322 ; 2323#if defined(USE_GDB_STACK_TRACE); 2324 char *gdb = Which(Getenv(""PATH""), ""gdb"", kExecutePermission);; 2325 if (!gdb) {; 2326 fprintf(stderr, ""gdb not found, need it for stack trace\n"");; 2327 return;; 2328 }; 2329 ; 2330 // write custom message file; 2331 TString gdbmessf = ""gdb-message"";; 2332 if (gdbmess != """") {; 2333 FILE *f = TempFileName(gdbmessf);; 2334 fprintf(f, ""%s\n"", gdbmess.Data());; 2335 fclose(f);; 2336 }; 2337 ; 2338 // use gdb to get stack trace; 2339 gdbscript += GetExePath();; 2340 gdbscript += "" "";; 2341 gdbscript += GetPid();; 2342 if (gdbmess != """") {; 2343 gdbscript += "" "";; 2344 gdbscript += gdbmessf;; 2345 }; 2346 gdbscript += "" 1>&2"";; 2347 Exec(gdbscript);; 2348 delete [] gdb;; 2349 return;; 2350 ; 2351#elif defined(R__AIX); 2352 TString script = ""procstack "";; 2353 script += GetPid();; 2354 Exec(script);; 2355 return;; 2356#elif defined(R__SOLARIS); 2357 char *cppfilt = Which(Getenv(""PATH""), ""c++filt"", kExecutePermission);; 2358 TString script = ""pstack "";; 2359 script += GetPid();; 2360 if (cppfilt) {; 2361 script += "" | "";; 2362 script += cppfilt;",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:72398,Integrability,message,message,72398,"a());; 2292 gdbscript = """";; 2293 }; 2294 }; 2295 if (gdbscript == """") {; 2296 gdbscript = ""gdb-backtrace.sh"";; 2297 gSystem->PrependPathName(TROOT::GetEtcDir(), gdbscript);; 2298 if (AccessPathName(gdbscript, kReadPermission)) {; 2299 fprintf(stderr, ""Error in <TUnixSystem::StackTrace> script %s is missing\n"", gdbscript.Data());; 2300 return;; 2301 }; 2302 }; 2303 gdbscript += "" "";; 2304 ; 2305 TString gdbmess = gEnv->GetValue(""Root.StacktraceMessage"", """");; 2306 gdbmess = gdbmess.Strip();; 2307 ; 2308 std::cout.flush();; 2309 fflush(stdout);; 2310 ; 2311 std::cerr.flush();; 2312 fflush(stderr);; 2313 ; 2314 int fd = STDERR_FILENO;; 2315 ; 2316 const char *message = "" Generating stack trace...\n"";; 2317 ; 2318 if (fd && message) { } // remove unused warning (remove later); 2319 ; 2320 if (gApplication && !strcmp(gApplication->GetName(), ""TRint"")); 2321 Getlinem(kCleanUp, nullptr);; 2322 ; 2323#if defined(USE_GDB_STACK_TRACE); 2324 char *gdb = Which(Getenv(""PATH""), ""gdb"", kExecutePermission);; 2325 if (!gdb) {; 2326 fprintf(stderr, ""gdb not found, need it for stack trace\n"");; 2327 return;; 2328 }; 2329 ; 2330 // write custom message file; 2331 TString gdbmessf = ""gdb-message"";; 2332 if (gdbmess != """") {; 2333 FILE *f = TempFileName(gdbmessf);; 2334 fprintf(f, ""%s\n"", gdbmess.Data());; 2335 fclose(f);; 2336 }; 2337 ; 2338 // use gdb to get stack trace; 2339 gdbscript += GetExePath();; 2340 gdbscript += "" "";; 2341 gdbscript += GetPid();; 2342 if (gdbmess != """") {; 2343 gdbscript += "" "";; 2344 gdbscript += gdbmessf;; 2345 }; 2346 gdbscript += "" 1>&2"";; 2347 Exec(gdbscript);; 2348 delete [] gdb;; 2349 return;; 2350 ; 2351#elif defined(R__AIX); 2352 TString script = ""procstack "";; 2353 script += GetPid();; 2354 Exec(script);; 2355 return;; 2356#elif defined(R__SOLARIS); 2357 char *cppfilt = Which(Getenv(""PATH""), ""c++filt"", kExecutePermission);; 2358 TString script = ""pstack "";; 2359 script += GetPid();; 2360 if (cppfilt) {; 2361 script += "" | "";; 2362 script += cppfilt;",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:72441,Integrability,message,message,72441,"a());; 2292 gdbscript = """";; 2293 }; 2294 }; 2295 if (gdbscript == """") {; 2296 gdbscript = ""gdb-backtrace.sh"";; 2297 gSystem->PrependPathName(TROOT::GetEtcDir(), gdbscript);; 2298 if (AccessPathName(gdbscript, kReadPermission)) {; 2299 fprintf(stderr, ""Error in <TUnixSystem::StackTrace> script %s is missing\n"", gdbscript.Data());; 2300 return;; 2301 }; 2302 }; 2303 gdbscript += "" "";; 2304 ; 2305 TString gdbmess = gEnv->GetValue(""Root.StacktraceMessage"", """");; 2306 gdbmess = gdbmess.Strip();; 2307 ; 2308 std::cout.flush();; 2309 fflush(stdout);; 2310 ; 2311 std::cerr.flush();; 2312 fflush(stderr);; 2313 ; 2314 int fd = STDERR_FILENO;; 2315 ; 2316 const char *message = "" Generating stack trace...\n"";; 2317 ; 2318 if (fd && message) { } // remove unused warning (remove later); 2319 ; 2320 if (gApplication && !strcmp(gApplication->GetName(), ""TRint"")); 2321 Getlinem(kCleanUp, nullptr);; 2322 ; 2323#if defined(USE_GDB_STACK_TRACE); 2324 char *gdb = Which(Getenv(""PATH""), ""gdb"", kExecutePermission);; 2325 if (!gdb) {; 2326 fprintf(stderr, ""gdb not found, need it for stack trace\n"");; 2327 return;; 2328 }; 2329 ; 2330 // write custom message file; 2331 TString gdbmessf = ""gdb-message"";; 2332 if (gdbmess != """") {; 2333 FILE *f = TempFileName(gdbmessf);; 2334 fprintf(f, ""%s\n"", gdbmess.Data());; 2335 fclose(f);; 2336 }; 2337 ; 2338 // use gdb to get stack trace; 2339 gdbscript += GetExePath();; 2340 gdbscript += "" "";; 2341 gdbscript += GetPid();; 2342 if (gdbmess != """") {; 2343 gdbscript += "" "";; 2344 gdbscript += gdbmessf;; 2345 }; 2346 gdbscript += "" 1>&2"";; 2347 Exec(gdbscript);; 2348 delete [] gdb;; 2349 return;; 2350 ; 2351#elif defined(R__AIX); 2352 TString script = ""procstack "";; 2353 script += GetPid();; 2354 Exec(script);; 2355 return;; 2356#elif defined(R__SOLARIS); 2357 char *cppfilt = Which(Getenv(""PATH""), ""c++filt"", kExecutePermission);; 2358 TString script = ""pstack "";; 2359 script += GetPid();; 2360 if (cppfilt) {; 2361 script += "" | "";; 2362 script += cppfilt;",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:75691,Integrability,message,message,75691,";; 2400 ; 2401#if (__GNUC__ >= 3); 2402 // try finding supported format option for g++ v3; 2403 if (filter) {; 2404 FILE *p = OpenPipe(TString::Format(""%s --help 2>&1"", filter), ""r"");; 2405 TString help;; 2406 while (help.Gets(p)) {; 2407 if (help.Index(""gnu-v3"") != kNPOS) {; 2408 cppfiltarg = ""--format=gnu-v3"";; 2409 break;; 2410 } else if (help.Index(""gnu-new-abi"") != kNPOS) {; 2411 cppfiltarg = ""--format=gnu-new-abi"";; 2412 break;; 2413 }; 2414 }; 2415 ClosePipe(p);; 2416 }; 2417#endif; 2418 // gdb-backtrace.sh uses gdb to produce a backtrace. See if it is available.; 2419 // If it is, use it. If not proceed as before.; 2420#if (defined(R__LINUX) && !defined(R__WINGCC)); 2421 // Declare the process that will be generating the stacktrace; 2422 // For more see: http://askubuntu.com/questions/41629/after-upgrade-gdb-wont-attach-to-process; 2423#ifdef PR_SET_PTRACER; 2424 prctl(PR_SET_PTRACER, getpid(), 0, 0, 0);; 2425#endif; 2426#endif; 2427 char *gdb = Which(Getenv(""PATH""), ""gdb"", kExecutePermission);; 2428 if (gdb) {; 2429 // write custom message file; 2430 TString gdbmessf = ""gdb-message"";; 2431 if (gdbmess != """") {; 2432 FILE *f = TempFileName(gdbmessf);; 2433 fprintf(f, ""%s\n"", gdbmess.Data());; 2434 fclose(f);; 2435 }; 2436 ; 2437 // use gdb to get stack trace; 2438#ifdef R__MACOSX; 2439 gdbscript += GetExePath();; 2440 gdbscript += "" "";; 2441#endif; 2442 gdbscript += GetPid();; 2443 if (gdbmess != """") {; 2444 gdbscript += "" "";; 2445 gdbscript += gdbmessf;; 2446 }; 2447 gdbscript += "" 1>&2"";; 2448 Exec(gdbscript);; 2449 delete [] gdb;; 2450 } else {; 2451 // addr2line uses debug info to convert addresses into file names; 2452 // and line numbers; 2453#ifdef R__MACOSX; 2454 char *addr2line = Which(Getenv(""PATH""), ""atos"", kExecutePermission);; 2455#else; 2456 char *addr2line = Which(Getenv(""PATH""), ""addr2line"", kExecutePermission);; 2457#endif; 2458 if (addr2line) {; 2459 // might take some time so tell what we are doing...; 2460 if (write(fd, message, strlen(me",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:75734,Integrability,message,message,75734,";; 2400 ; 2401#if (__GNUC__ >= 3); 2402 // try finding supported format option for g++ v3; 2403 if (filter) {; 2404 FILE *p = OpenPipe(TString::Format(""%s --help 2>&1"", filter), ""r"");; 2405 TString help;; 2406 while (help.Gets(p)) {; 2407 if (help.Index(""gnu-v3"") != kNPOS) {; 2408 cppfiltarg = ""--format=gnu-v3"";; 2409 break;; 2410 } else if (help.Index(""gnu-new-abi"") != kNPOS) {; 2411 cppfiltarg = ""--format=gnu-new-abi"";; 2412 break;; 2413 }; 2414 }; 2415 ClosePipe(p);; 2416 }; 2417#endif; 2418 // gdb-backtrace.sh uses gdb to produce a backtrace. See if it is available.; 2419 // If it is, use it. If not proceed as before.; 2420#if (defined(R__LINUX) && !defined(R__WINGCC)); 2421 // Declare the process that will be generating the stacktrace; 2422 // For more see: http://askubuntu.com/questions/41629/after-upgrade-gdb-wont-attach-to-process; 2423#ifdef PR_SET_PTRACER; 2424 prctl(PR_SET_PTRACER, getpid(), 0, 0, 0);; 2425#endif; 2426#endif; 2427 char *gdb = Which(Getenv(""PATH""), ""gdb"", kExecutePermission);; 2428 if (gdb) {; 2429 // write custom message file; 2430 TString gdbmessf = ""gdb-message"";; 2431 if (gdbmess != """") {; 2432 FILE *f = TempFileName(gdbmessf);; 2433 fprintf(f, ""%s\n"", gdbmess.Data());; 2434 fclose(f);; 2435 }; 2436 ; 2437 // use gdb to get stack trace; 2438#ifdef R__MACOSX; 2439 gdbscript += GetExePath();; 2440 gdbscript += "" "";; 2441#endif; 2442 gdbscript += GetPid();; 2443 if (gdbmess != """") {; 2444 gdbscript += "" "";; 2445 gdbscript += gdbmessf;; 2446 }; 2447 gdbscript += "" 1>&2"";; 2448 Exec(gdbscript);; 2449 delete [] gdb;; 2450 } else {; 2451 // addr2line uses debug info to convert addresses into file names; 2452 // and line numbers; 2453#ifdef R__MACOSX; 2454 char *addr2line = Which(Getenv(""PATH""), ""atos"", kExecutePermission);; 2455#else; 2456 char *addr2line = Which(Getenv(""PATH""), ""addr2line"", kExecutePermission);; 2457#endif; 2458 if (addr2line) {; 2459 // might take some time so tell what we are doing...; 2460 if (write(fd, message, strlen(me",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:76616,Integrability,message,message,76616," *f = TempFileName(gdbmessf);; 2433 fprintf(f, ""%s\n"", gdbmess.Data());; 2434 fclose(f);; 2435 }; 2436 ; 2437 // use gdb to get stack trace; 2438#ifdef R__MACOSX; 2439 gdbscript += GetExePath();; 2440 gdbscript += "" "";; 2441#endif; 2442 gdbscript += GetPid();; 2443 if (gdbmess != """") {; 2444 gdbscript += "" "";; 2445 gdbscript += gdbmessf;; 2446 }; 2447 gdbscript += "" 1>&2"";; 2448 Exec(gdbscript);; 2449 delete [] gdb;; 2450 } else {; 2451 // addr2line uses debug info to convert addresses into file names; 2452 // and line numbers; 2453#ifdef R__MACOSX; 2454 char *addr2line = Which(Getenv(""PATH""), ""atos"", kExecutePermission);; 2455#else; 2456 char *addr2line = Which(Getenv(""PATH""), ""addr2line"", kExecutePermission);; 2457#endif; 2458 if (addr2line) {; 2459 // might take some time so tell what we are doing...; 2460 if (write(fd, message, strlen(message)) < 0); 2461 Warning(""StackTrace"", ""problems writing line numbers (errno: %d)"", TSystem::GetErrno());; 2462 }; 2463 ; 2464 // open tmp file for demangled stack trace; 2465 TString tmpf1 = ""gdb-backtrace"";; 2466 std::ofstream file1;; 2467 if (demangle) {; 2468 FILE *f = TempFileName(tmpf1);; 2469 if (f) fclose(f);; 2470 file1.open(tmpf1);; 2471 if (!file1) {; 2472 Error(""StackTrace"", ""could not open file %s"", tmpf1.Data());; 2473 Unlink(tmpf1);; 2474 demangle = kFALSE;; 2475 }; 2476 }; 2477 ; 2478#ifdef R__MACOSX; 2479 if (addr2line); 2480 demangle = kFALSE; // atos always demangles; 2481#endif; 2482 ; 2483 char buffer[4096];; 2484 void *trace[kMAX_BACKTRACE_DEPTH];; 2485 int depth = backtrace(trace, kMAX_BACKTRACE_DEPTH);; 2486 for (int n = 5; n < depth; n++) {; 2487 ULong_t addr = (ULong_t) trace[n];; 2488 Dl_info info;; 2489 ; 2490 if (dladdr(trace[n], &info) && info.dli_fname && info.dli_fname[0]) {; 2491 const char *libname = info.dli_fname;; 2492 const char *symname = (info.dli_sname && info.dli_sname[0]) ?; 2493 info.dli_sname : ""<unknown>"";; 2494 ULong_t libaddr = (ULong_t) info.dli_fbase;; 2495 ULong_t symaddr = (UL",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:76632,Integrability,message,message,76632," *f = TempFileName(gdbmessf);; 2433 fprintf(f, ""%s\n"", gdbmess.Data());; 2434 fclose(f);; 2435 }; 2436 ; 2437 // use gdb to get stack trace; 2438#ifdef R__MACOSX; 2439 gdbscript += GetExePath();; 2440 gdbscript += "" "";; 2441#endif; 2442 gdbscript += GetPid();; 2443 if (gdbmess != """") {; 2444 gdbscript += "" "";; 2445 gdbscript += gdbmessf;; 2446 }; 2447 gdbscript += "" 1>&2"";; 2448 Exec(gdbscript);; 2449 delete [] gdb;; 2450 } else {; 2451 // addr2line uses debug info to convert addresses into file names; 2452 // and line numbers; 2453#ifdef R__MACOSX; 2454 char *addr2line = Which(Getenv(""PATH""), ""atos"", kExecutePermission);; 2455#else; 2456 char *addr2line = Which(Getenv(""PATH""), ""addr2line"", kExecutePermission);; 2457#endif; 2458 if (addr2line) {; 2459 // might take some time so tell what we are doing...; 2460 if (write(fd, message, strlen(message)) < 0); 2461 Warning(""StackTrace"", ""problems writing line numbers (errno: %d)"", TSystem::GetErrno());; 2462 }; 2463 ; 2464 // open tmp file for demangled stack trace; 2465 TString tmpf1 = ""gdb-backtrace"";; 2466 std::ofstream file1;; 2467 if (demangle) {; 2468 FILE *f = TempFileName(tmpf1);; 2469 if (f) fclose(f);; 2470 file1.open(tmpf1);; 2471 if (!file1) {; 2472 Error(""StackTrace"", ""could not open file %s"", tmpf1.Data());; 2473 Unlink(tmpf1);; 2474 demangle = kFALSE;; 2475 }; 2476 }; 2477 ; 2478#ifdef R__MACOSX; 2479 if (addr2line); 2480 demangle = kFALSE; // atos always demangles; 2481#endif; 2482 ; 2483 char buffer[4096];; 2484 void *trace[kMAX_BACKTRACE_DEPTH];; 2485 int depth = backtrace(trace, kMAX_BACKTRACE_DEPTH);; 2486 for (int n = 5; n < depth; n++) {; 2487 ULong_t addr = (ULong_t) trace[n];; 2488 Dl_info info;; 2489 ; 2490 if (dladdr(trace[n], &info) && info.dli_fname && info.dli_fname[0]) {; 2491 const char *libname = info.dli_fname;; 2492 const char *symname = (info.dli_sname && info.dli_sname[0]) ?; 2493 info.dli_sname : ""<unknown>"";; 2494 ULong_t libaddr = (ULong_t) info.dli_fbase;; 2495 ULong_t symaddr = (UL",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:82951,Integrability,message,message,82951,"//////; 2613/// Open connection to system log daemon. For the use of the options and; 2614/// facility see the Unix openlog man page.; 2615 ; 2616void TUnixSystem::Openlog(const char *name, Int_t options, ELogFacility facility); 2617{; 2618 int fac = 0;; 2619 ; 2620 switch (facility) {; 2621 case kLogLocal0:; 2622 fac = LOG_LOCAL0;; 2623 break;; 2624 case kLogLocal1:; 2625 fac = LOG_LOCAL1;; 2626 break;; 2627 case kLogLocal2:; 2628 fac = LOG_LOCAL2;; 2629 break;; 2630 case kLogLocal3:; 2631 fac = LOG_LOCAL3;; 2632 break;; 2633 case kLogLocal4:; 2634 fac = LOG_LOCAL4;; 2635 break;; 2636 case kLogLocal5:; 2637 fac = LOG_LOCAL5;; 2638 break;; 2639 case kLogLocal6:; 2640 fac = LOG_LOCAL6;; 2641 break;; 2642 case kLogLocal7:; 2643 fac = LOG_LOCAL7;; 2644 break;; 2645 }; 2646 ; 2647 ::openlog(name, options, fac);; 2648}; 2649 ; 2650////////////////////////////////////////////////////////////////////////////////; 2651/// Send mess to syslog daemon. Level is the logging level and mess the; 2652/// message that will be written on the log.; 2653 ; 2654void TUnixSystem::Syslog(ELogLevel level, const char *mess); 2655{; 2656 // ELogLevel matches exactly the Unix values.; 2657 ::syslog(level, ""%s"", mess);; 2658}; 2659 ; 2660////////////////////////////////////////////////////////////////////////////////; 2661/// Close connection to system log daemon.; 2662 ; 2663void TUnixSystem::Closelog(); 2664{; 2665 ::closelog();; 2666}; 2667 ; 2668//---- Standard output redirection ---------------------------------------------; 2669 ; 2670////////////////////////////////////////////////////////////////////////////////; 2671/// Redirect standard output (stdout, stderr) to the specified file.; 2672/// If the file argument is 0 the output is set again to stderr, stdout.; 2673/// The second argument specifies whether the output should be added to the; 2674/// file (""a"", default) or the file be truncated before (""w"").; 2675/// This function saves internally the current state into a static struct",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:96377,Integrability,protocol,protocol,96377,"; 3028}; 3029 ; 3030////////////////////////////////////////////////////////////////////////////////; 3031/// Reset a-sync timer.; 3032 ; 3033void TUnixSystem::ResetTimer(TTimer *ti); 3034{; 3035 if (!fInsideNotify && ti && ti->IsAsync()); 3036 UnixSetitimer(NextTimeOut(kFALSE));; 3037}; 3038 ; 3039//---- RPC ---------------------------------------------------------------------; 3040 ; 3041////////////////////////////////////////////////////////////////////////////////; 3042/// Get Internet Protocol (IP) address of host. Returns an TInetAddress; 3043/// object. To see if the hostname lookup was successfull call; 3044/// TInetAddress::IsValid().; 3045 ; 3046TInetAddress TUnixSystem::GetHostByName(const char *hostname); 3047{; 3048 TInetAddress ia;; 3049 struct addrinfo hints;; 3050 struct addrinfo *result, *rp;; 3051 memset(&hints, 0, sizeof(struct addrinfo));; 3052 hints.ai_family = AF_INET; // only IPv4; 3053 hints.ai_socktype = 0; // any socket type; 3054 hints.ai_protocol = 0; // any protocol; 3055 hints.ai_flags = AI_CANONNAME; // get canonical name; 3056#ifdef R__MACOSX; 3057 // Anything ending on "".local"" causes a 5 second delay in getaddrinfo().; 3058 // See e.g. https://apple.stackexchange.com/questions/175320/why-is-my-hostname-resolution-taking-so-long; 3059 // Only reasonable solution: remove the ""domain"" part if it's "".local"".; 3060 size_t lenHostname = strlen(hostname);; 3061 std::string hostnameWithoutLocal{hostname};; 3062 if (lenHostname > 6 && !strcmp(hostname + lenHostname - 6, "".local"")) {; 3063 hostnameWithoutLocal.erase(lenHostname - 6);; 3064 hostname = hostnameWithoutLocal.c_str();; 3065 }; 3066#endif; 3067 ; 3068 // obsolete gethostbyname() replaced by getaddrinfo(); 3069 int rc = getaddrinfo(hostname, nullptr, &hints, &result);; 3070 if (rc != 0) {; 3071 if (rc == EAI_NONAME) {; 3072 if (gDebug > 0) Error(""GetHostByName"", ""unknown host '%s'"", hostname);; 3073 ia.fHostname = ""UnNamedHost"";; 3074 } else {; 3075 Error(""GetHostByName"", ""getaddrin",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:100975,Integrability,protocol,protocol,100975," SysError(""GetPeerName"", ""getpeername failed"");; 3149 return ia;; 3150 }; 3151 ; 3152 if (addr.sa_family != AF_INET) return ia; // only IPv4; 3153 ia.fFamily = addr.sa_family;; 3154 struct sockaddr_in *addrin = (struct sockaddr_in *)&addr;; 3155 ia.fPort = ntohs(addrin->sin_port);; 3156 ia.fAddresses[0] = ntohl(addrin->sin_addr.s_addr);; 3157 ; 3158 char hbuf[NI_MAXHOST];; 3159 if (getnameinfo(&addr, sizeof(struct sockaddr), hbuf, sizeof(hbuf), nullptr, 0, 0) != 0) {; 3160 Error(""GetPeerName"", ""getnameinfo failed"");; 3161 ia.fHostname = ""????"";; 3162 } else; 3163 ia.fHostname = hbuf;; 3164 ; 3165 return ia;; 3166}; 3167 ; 3168////////////////////////////////////////////////////////////////////////////////; 3169/// Get port # of internet service.; 3170 ; 3171int TUnixSystem::GetServiceByName(const char *servicename); 3172{; 3173 struct servent *sp;; 3174 ; 3175 if ((sp = getservbyname(servicename, kProtocolName)) == nullptr) {; 3176 Error(""GetServiceByName"", ""no service \""%s\"" with protocol \""%s\""\n"",; 3177 servicename, kProtocolName);; 3178 return -1;; 3179 }; 3180 return ntohs(sp->s_port);; 3181}; 3182 ; 3183////////////////////////////////////////////////////////////////////////////////; 3184/// Get name of internet service.; 3185 ; 3186char *TUnixSystem::GetServiceByPort(int port); 3187{; 3188 struct servent *sp;; 3189 ; 3190 if ((sp = getservbyport(htons(port), kProtocolName)) == nullptr) {; 3191 //::Error(""GetServiceByPort"", ""no service \""%d\"" with protocol \""%s\"""",; 3192 // port, kProtocolName);; 3193 return Form(""%d"", port);; 3194 }; 3195 return sp->s_name;; 3196}; 3197 ; 3198////////////////////////////////////////////////////////////////////////////////; 3199/// Connect to service servicename on server servername.; 3200 ; 3201int TUnixSystem::ConnectService(const char *servername, int port,; 3202 int tcpwindowsize, const char *protocol); 3203{; 3204 if (!strcmp(servername, ""unix"")) {; 3205 return UnixUnixConnect(port);; 3206 } else if (!gSystem->AccessPathNa",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:101457,Integrability,protocol,protocol,101457,"""getnameinfo failed"");; 3161 ia.fHostname = ""????"";; 3162 } else; 3163 ia.fHostname = hbuf;; 3164 ; 3165 return ia;; 3166}; 3167 ; 3168////////////////////////////////////////////////////////////////////////////////; 3169/// Get port # of internet service.; 3170 ; 3171int TUnixSystem::GetServiceByName(const char *servicename); 3172{; 3173 struct servent *sp;; 3174 ; 3175 if ((sp = getservbyname(servicename, kProtocolName)) == nullptr) {; 3176 Error(""GetServiceByName"", ""no service \""%s\"" with protocol \""%s\""\n"",; 3177 servicename, kProtocolName);; 3178 return -1;; 3179 }; 3180 return ntohs(sp->s_port);; 3181}; 3182 ; 3183////////////////////////////////////////////////////////////////////////////////; 3184/// Get name of internet service.; 3185 ; 3186char *TUnixSystem::GetServiceByPort(int port); 3187{; 3188 struct servent *sp;; 3189 ; 3190 if ((sp = getservbyport(htons(port), kProtocolName)) == nullptr) {; 3191 //::Error(""GetServiceByPort"", ""no service \""%d\"" with protocol \""%s\"""",; 3192 // port, kProtocolName);; 3193 return Form(""%d"", port);; 3194 }; 3195 return sp->s_name;; 3196}; 3197 ; 3198////////////////////////////////////////////////////////////////////////////////; 3199/// Connect to service servicename on server servername.; 3200 ; 3201int TUnixSystem::ConnectService(const char *servername, int port,; 3202 int tcpwindowsize, const char *protocol); 3203{; 3204 if (!strcmp(servername, ""unix"")) {; 3205 return UnixUnixConnect(port);; 3206 } else if (!gSystem->AccessPathName(servername) || servername[0] == '/') {; 3207 return UnixUnixConnect(servername);; 3208 }; 3209 ; 3210 if (!strcmp(protocol, ""udp"")){; 3211 return UnixUdpConnect(servername, port);; 3212 }; 3213 ; 3214 return UnixTcpConnect(servername, port, tcpwindowsize);; 3215}; 3216 ; 3217////////////////////////////////////////////////////////////////////////////////; 3218/// Open a connection to a service on a server. Returns -1 in case; 3219/// connection cannot be opened.; 3220/// Use tcpwindowsize t",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:101847,Integrability,protocol,protocol,101847,"return ntohs(sp->s_port);; 3181}; 3182 ; 3183////////////////////////////////////////////////////////////////////////////////; 3184/// Get name of internet service.; 3185 ; 3186char *TUnixSystem::GetServiceByPort(int port); 3187{; 3188 struct servent *sp;; 3189 ; 3190 if ((sp = getservbyport(htons(port), kProtocolName)) == nullptr) {; 3191 //::Error(""GetServiceByPort"", ""no service \""%d\"" with protocol \""%s\"""",; 3192 // port, kProtocolName);; 3193 return Form(""%d"", port);; 3194 }; 3195 return sp->s_name;; 3196}; 3197 ; 3198////////////////////////////////////////////////////////////////////////////////; 3199/// Connect to service servicename on server servername.; 3200 ; 3201int TUnixSystem::ConnectService(const char *servername, int port,; 3202 int tcpwindowsize, const char *protocol); 3203{; 3204 if (!strcmp(servername, ""unix"")) {; 3205 return UnixUnixConnect(port);; 3206 } else if (!gSystem->AccessPathName(servername) || servername[0] == '/') {; 3207 return UnixUnixConnect(servername);; 3208 }; 3209 ; 3210 if (!strcmp(protocol, ""udp"")){; 3211 return UnixUdpConnect(servername, port);; 3212 }; 3213 ; 3214 return UnixTcpConnect(servername, port, tcpwindowsize);; 3215}; 3216 ; 3217////////////////////////////////////////////////////////////////////////////////; 3218/// Open a connection to a service on a server. Returns -1 in case; 3219/// connection cannot be opened.; 3220/// Use tcpwindowsize to specify the size of the receive buffer, it has; 3221/// to be specified here to make sure the window scale option is set (for; 3222/// tcpwindowsize > 65KB and for platforms supporting window scaling).; 3223/// Is called via the TSocket constructor.; 3224 ; 3225int TUnixSystem::OpenConnection(const char *server, int port, int tcpwindowsize, const char *protocol); 3226{; 3227 return ConnectService(server, port, tcpwindowsize, protocol);; 3228}; 3229 ; 3230////////////////////////////////////////////////////////////////////////////////; 3231/// Announce TCP/IP service.; 3232///",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:102097,Integrability,protocol,protocol,102097,"return ntohs(sp->s_port);; 3181}; 3182 ; 3183////////////////////////////////////////////////////////////////////////////////; 3184/// Get name of internet service.; 3185 ; 3186char *TUnixSystem::GetServiceByPort(int port); 3187{; 3188 struct servent *sp;; 3189 ; 3190 if ((sp = getservbyport(htons(port), kProtocolName)) == nullptr) {; 3191 //::Error(""GetServiceByPort"", ""no service \""%d\"" with protocol \""%s\"""",; 3192 // port, kProtocolName);; 3193 return Form(""%d"", port);; 3194 }; 3195 return sp->s_name;; 3196}; 3197 ; 3198////////////////////////////////////////////////////////////////////////////////; 3199/// Connect to service servicename on server servername.; 3200 ; 3201int TUnixSystem::ConnectService(const char *servername, int port,; 3202 int tcpwindowsize, const char *protocol); 3203{; 3204 if (!strcmp(servername, ""unix"")) {; 3205 return UnixUnixConnect(port);; 3206 } else if (!gSystem->AccessPathName(servername) || servername[0] == '/') {; 3207 return UnixUnixConnect(servername);; 3208 }; 3209 ; 3210 if (!strcmp(protocol, ""udp"")){; 3211 return UnixUdpConnect(servername, port);; 3212 }; 3213 ; 3214 return UnixTcpConnect(servername, port, tcpwindowsize);; 3215}; 3216 ; 3217////////////////////////////////////////////////////////////////////////////////; 3218/// Open a connection to a service on a server. Returns -1 in case; 3219/// connection cannot be opened.; 3220/// Use tcpwindowsize to specify the size of the receive buffer, it has; 3221/// to be specified here to make sure the window scale option is set (for; 3222/// tcpwindowsize > 65KB and for platforms supporting window scaling).; 3223/// Is called via the TSocket constructor.; 3224 ; 3225int TUnixSystem::OpenConnection(const char *server, int port, int tcpwindowsize, const char *protocol); 3226{; 3227 return ConnectService(server, port, tcpwindowsize, protocol);; 3228}; 3229 ; 3230////////////////////////////////////////////////////////////////////////////////; 3231/// Announce TCP/IP service.; 3232///",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:102835,Integrability,protocol,protocol,102835,"e, ""unix"")) {; 3205 return UnixUnixConnect(port);; 3206 } else if (!gSystem->AccessPathName(servername) || servername[0] == '/') {; 3207 return UnixUnixConnect(servername);; 3208 }; 3209 ; 3210 if (!strcmp(protocol, ""udp"")){; 3211 return UnixUdpConnect(servername, port);; 3212 }; 3213 ; 3214 return UnixTcpConnect(servername, port, tcpwindowsize);; 3215}; 3216 ; 3217////////////////////////////////////////////////////////////////////////////////; 3218/// Open a connection to a service on a server. Returns -1 in case; 3219/// connection cannot be opened.; 3220/// Use tcpwindowsize to specify the size of the receive buffer, it has; 3221/// to be specified here to make sure the window scale option is set (for; 3222/// tcpwindowsize > 65KB and for platforms supporting window scaling).; 3223/// Is called via the TSocket constructor.; 3224 ; 3225int TUnixSystem::OpenConnection(const char *server, int port, int tcpwindowsize, const char *protocol); 3226{; 3227 return ConnectService(server, port, tcpwindowsize, protocol);; 3228}; 3229 ; 3230////////////////////////////////////////////////////////////////////////////////; 3231/// Announce TCP/IP service.; 3232/// Open a socket, bind to it and start listening for TCP/IP connections; 3233/// on the port. If reuse is true reuse the address, backlog specifies; 3234/// how many sockets can be waiting to be accepted.; 3235/// Use tcpwindowsize to specify the size of the receive buffer, it has; 3236/// to be specified here to make sure the window scale option is set (for; 3237/// tcpwindowsize > 65KB and for platforms supporting window scaling).; 3238/// Returns socket fd or -1 if socket() failed, -2 if bind() failed; 3239/// or -3 if listen() failed.; 3240 ; 3241int TUnixSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog,; 3242 int tcpwindowsize); 3243{; 3244 return UnixTcpService(port, reuse, backlog, tcpwindowsize);; 3245}; 3246 ; 3247////////////////////////////////////////////////////////////////////////////////; 32",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:102909,Integrability,protocol,protocol,102909,"e, ""unix"")) {; 3205 return UnixUnixConnect(port);; 3206 } else if (!gSystem->AccessPathName(servername) || servername[0] == '/') {; 3207 return UnixUnixConnect(servername);; 3208 }; 3209 ; 3210 if (!strcmp(protocol, ""udp"")){; 3211 return UnixUdpConnect(servername, port);; 3212 }; 3213 ; 3214 return UnixTcpConnect(servername, port, tcpwindowsize);; 3215}; 3216 ; 3217////////////////////////////////////////////////////////////////////////////////; 3218/// Open a connection to a service on a server. Returns -1 in case; 3219/// connection cannot be opened.; 3220/// Use tcpwindowsize to specify the size of the receive buffer, it has; 3221/// to be specified here to make sure the window scale option is set (for; 3222/// tcpwindowsize > 65KB and for platforms supporting window scaling).; 3223/// Is called via the TSocket constructor.; 3224 ; 3225int TUnixSystem::OpenConnection(const char *server, int port, int tcpwindowsize, const char *protocol); 3226{; 3227 return ConnectService(server, port, tcpwindowsize, protocol);; 3228}; 3229 ; 3230////////////////////////////////////////////////////////////////////////////////; 3231/// Announce TCP/IP service.; 3232/// Open a socket, bind to it and start listening for TCP/IP connections; 3233/// on the port. If reuse is true reuse the address, backlog specifies; 3234/// how many sockets can be waiting to be accepted.; 3235/// Use tcpwindowsize to specify the size of the receive buffer, it has; 3236/// to be specified here to make sure the window scale option is set (for; 3237/// tcpwindowsize > 65KB and for platforms supporting window scaling).; 3238/// Returns socket fd or -1 if socket() failed, -2 if bind() failed; 3239/// or -3 if listen() failed.; 3240 ; 3241int TUnixSystem::AnnounceTcpService(int port, Bool_t reuse, int backlog,; 3242 int tcpwindowsize); 3243{; 3244 return UnixTcpService(port, reuse, backlog, tcpwindowsize);; 3245}; 3246 ; 3247////////////////////////////////////////////////////////////////////////////////; 32",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:130272,Integrability,depend,dependend,130272,"ned(R__SEEK64); 4045 struct stat64 sbuf;; 4046 if (path && lstat64(path, &sbuf) == 0) {; 4047#else; 4048 struct stat sbuf;; 4049 if (path && lstat(path, &sbuf) == 0) {; 4050#endif; 4051 buf.fIsLink = S_ISLNK(sbuf.st_mode);; 4052 if (buf.fIsLink) {; 4053#if defined(R__SEEK64); 4054 if (stat64(path, &sbuf) == -1) {; 4055#else; 4056 if (stat(path, &sbuf) == -1) {; 4057#endif; 4058 return 1;; 4059 }; 4060 }; 4061 buf.fDev = sbuf.st_dev;; 4062 buf.fIno = sbuf.st_ino;; 4063 buf.fMode = sbuf.st_mode;; 4064 buf.fUid = sbuf.st_uid;; 4065 buf.fGid = sbuf.st_gid;; 4066 buf.fSize = sbuf.st_size;; 4067 buf.fMtime = sbuf.st_mtime;; 4068 ; 4069 return 0;; 4070 }; 4071 return 1;; 4072}; 4073 ; 4074////////////////////////////////////////////////////////////////////////////////; 4075/// Get info about a file system: id, bsize, bfree, blocks.; 4076/// Id is file system type (machine dependend, see statfs()); 4077/// Bsize is block size of file system; 4078/// Blocks is total number of blocks in file system; 4079/// Bfree is number of free blocks in file system; 4080/// The function returns 0 in case of success and 1 if the file system could; 4081/// not be stat'ed.; 4082 ; 4083int TUnixSystem::UnixFSstat(const char *path, Long_t *id, Long_t *bsize,; 4084 Long_t *blocks, Long_t *bfree); 4085{; 4086 struct statfs statfsbuf;; 4087#if (defined(R__SOLARIS) && !defined(R__LINUX)); 4088 if (statfs(path, &statfsbuf, sizeof(struct statfs), 0) == 0) {; 4089 *id = statfsbuf.f_fstyp;; 4090 *bsize = statfsbuf.f_bsize;; 4091 *blocks = statfsbuf.f_blocks;; 4092 *bfree = statfsbuf.f_bfree;; 4093#else; 4094 if (statfs((char*)path, &statfsbuf) == 0) {; 4095#ifdef R__OBSD; 4096 // Convert BSD filesystem names to Linux filesystem type numbers; 4097 // where possible. Linux statfs uses a value of -1 to indicate; 4098 // an unsupported field.; 4099 ; 4100 if (!strcmp(statfsbuf.f_fstypename, MOUNT_FFS) ||; 4101 !strcmp(statfsbuf.f_fstypename, MOUNT_MFS)); 4102 *id = 0x11954;; 4103 else if (!strcmp(statfsbuf",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:148010,Integrability,rout,routine,148010," search path. Static utility function.; 4596 ; 4597static const char *DynamicPath(const char *newpath = nullptr, Bool_t reset = kFALSE); 4598{; 4599 static TString dynpath_full;; 4600 static std::atomic<bool> initialized(kFALSE);; 4601 static std::atomic<bool> seenCling(kFALSE);; 4602 ; 4603 // If we have not seen Cling but the result has been initialized and gCling; 4604 // is still nullptr, the result won't change.; 4605 if (newpath == nullptr && !reset && (seenCling || (initialized && gCling == nullptr))); 4606 return dynpath_full;; 4607 ; 4608 R__LOCKGUARD2(gSystemMutex);; 4609 ; 4610 if (newpath) {; 4611 dynpath_full = newpath;; 4612 // Don't erase the user given path at the next call.; 4613 initialized = kTRUE;; 4614 // We do not (otherwise) record whether the path was set automatically or; 4615 // whether it was set explicitly by the user. If the user set the path; 4616 // explicitly, we should never automatically over-ride the value; if; 4617 // seenCling stayed false, it would tell this routine that at the next; 4618 // call it should update the value (to insert the Cling provided parts); 4619 // back to the default.; 4620 seenCling = kTRUE;; 4621 return dynpath_full;; 4622 }; 4623 ; 4624 // Another thread might have updated this. Even-though this is executed at the; 4625 // start of the process, we might get there if the user is explicitly; 4626 // 'resetting' the value.; 4627 if (!reset && (seenCling || (initialized && gCling == nullptr))); 4628 return dynpath_full;; 4629 ; 4630 if (!initialized) {; 4631 // force one time initialization of gROOT before we start; 4632 // (otherwise it might be done as a side effect of gEnv->GetValue and; 4633 // TROOT's initialization will call this routine).; 4634 gROOT;; 4635 }; 4636 ; 4637 static TString dynpath_envpart;; 4638 static TString dynpath_syspart;; 4639 ; 4640 if (reset || !initialized) {; 4641 ; 4642 dynpath_envpart = gSystem->Getenv(""ROOT_LIBRARY_PATH"");; 4643 TString rdynpath = gEnv->GetValue(""Root.DynamicP",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:148721,Integrability,rout,routine,148721,"(gSystemMutex);; 4609 ; 4610 if (newpath) {; 4611 dynpath_full = newpath;; 4612 // Don't erase the user given path at the next call.; 4613 initialized = kTRUE;; 4614 // We do not (otherwise) record whether the path was set automatically or; 4615 // whether it was set explicitly by the user. If the user set the path; 4616 // explicitly, we should never automatically over-ride the value; if; 4617 // seenCling stayed false, it would tell this routine that at the next; 4618 // call it should update the value (to insert the Cling provided parts); 4619 // back to the default.; 4620 seenCling = kTRUE;; 4621 return dynpath_full;; 4622 }; 4623 ; 4624 // Another thread might have updated this. Even-though this is executed at the; 4625 // start of the process, we might get there if the user is explicitly; 4626 // 'resetting' the value.; 4627 if (!reset && (seenCling || (initialized && gCling == nullptr))); 4628 return dynpath_full;; 4629 ; 4630 if (!initialized) {; 4631 // force one time initialization of gROOT before we start; 4632 // (otherwise it might be done as a side effect of gEnv->GetValue and; 4633 // TROOT's initialization will call this routine).; 4634 gROOT;; 4635 }; 4636 ; 4637 static TString dynpath_envpart;; 4638 static TString dynpath_syspart;; 4639 ; 4640 if (reset || !initialized) {; 4641 ; 4642 dynpath_envpart = gSystem->Getenv(""ROOT_LIBRARY_PATH"");; 4643 TString rdynpath = gEnv->GetValue(""Root.DynamicPath"", (char*)0);; 4644 rdynpath.ReplaceAll("": "", "":""); // in case DynamicPath was extended; 4645 if (rdynpath.IsNull()) {; 4646 rdynpath = "".:""; rdynpath += TROOT::GetLibDir();; 4647 }; 4648 TString ldpath;; 4649 #if defined (R__AIX); 4650 ldpath = gSystem->Getenv(""LIBPATH"");; 4651 #elif defined(R__MACOSX); 4652 ldpath = gSystem->Getenv(""DYLD_LIBRARY_PATH"");; 4653 if (!ldpath.IsNull()); 4654 ldpath += "":"";; 4655 ldpath += gSystem->Getenv(""LD_LIBRARY_PATH"");; 4656 if (!ldpath.IsNull()); 4657 ldpath += "":"";; 4658 ldpath += gSystem->Getenv(""DYLD_FALLBACK_LIBRARY_",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:189567,Integrability,message,message,189567,"ition TInetAddress.h:68; TInetAddress::fHostnameTString fHostnameDefinition TInetAddress.h:52; TInterpreter::GetSTLIncludePathvirtual const char * GetSTLIncludePath() constDefinition TInterpreter.h:163; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TListIterIterator of linked list.Definition TList.h:193; TListIter::NextTObject * Next() overrideReturn next object in the list. Returns 0 when no more objects in list.Definition TList.cxx:1109; TListA doubly linked list.Definition TList.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TOrdCollectionIterIterator of ordered collection.Definition TOrdCollection.h:96; TOrdCollectionIter::NextTObject * Next() overrideReturn next object in collection.Definition TOrdCollection.cxx:502; TOrdCollectionOrdered collection.Definition TOrdCollection.h:32; TPRegexpDefinition TPRegexp.h:36; TPRegexp::SubstituteInt_t Substitute(TString &s, const TString &replace, const TString &mods="""", Int_t start=0, Int_t nMatchMax=10)Substitute replaces the string s by a new string in which matching patterns are replaced by the repla...Definition TPRegexp.cxx:561; TROOT::ShutDownstatic void ShutDown()Shut down ROOT.Definition TROOT.cxx:3140; TROOT::GetEtcDirstatic const TString & GetEtcDir",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:189704,Integrability,message,message,189704," char * GetSTLIncludePath() constDefinition TInterpreter.h:163; TIterDefinition TCollection.h:235; TIter::Resetvoid Reset()Definition TCollection.h:254; TListIterIterator of linked list.Definition TList.h:193; TListIter::NextTObject * Next() overrideReturn next object in the list. Returns 0 when no more objects in list.Definition TList.cxx:1109; TListA doubly linked list.Definition TList.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TOrdCollectionIterIterator of ordered collection.Definition TOrdCollection.h:96; TOrdCollectionIter::NextTObject * Next() overrideReturn next object in collection.Definition TOrdCollection.cxx:502; TOrdCollectionOrdered collection.Definition TOrdCollection.h:32; TPRegexpDefinition TPRegexp.h:36; TPRegexp::SubstituteInt_t Substitute(TString &s, const TString &replace, const TString &mods="""", Int_t start=0, Int_t nMatchMax=10)Substitute replaces the string s by a new string in which matching patterns are replaced by the repla...Definition TPRegexp.cxx:561; TROOT::ShutDownstatic void ShutDown()Shut down ROOT.Definition TROOT.cxx:3140; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetLibDirstatic const TString &",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:189834,Integrability,message,message,189834,"on TCollection.h:254; TListIterIterator of linked list.Definition TList.h:193; TListIter::NextTObject * Next() overrideReturn next object in the list. Returns 0 when no more objects in list.Definition TList.cxx:1109; TListA doubly linked list.Definition TList.h:38; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObjStringCollectable string class.Definition TObjString.h:28; TObjString::StringTString & String()Definition TObjString.h:48; TObject::GetNamevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::SysErrorvirtual void SysError(const char *method, const char *msgfmt,...) constIssue system error message.Definition TObject.cxx:1007; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TOrdCollectionIterIterator of ordered collection.Definition TOrdCollection.h:96; TOrdCollectionIter::NextTObject * Next() overrideReturn next object in collection.Definition TOrdCollection.cxx:502; TOrdCollectionOrdered collection.Definition TOrdCollection.h:32; TPRegexpDefinition TPRegexp.h:36; TPRegexp::SubstituteInt_t Substitute(TString &s, const TString &replace, const TString &mods="""", Int_t start=0, Int_t nMatchMax=10)Substitute replaces the string s by a new string in which matching patterns are replaced by the repla...Definition TPRegexp.cxx:561; TROOT::ShutDownstatic void ShutDown()Shut down ROOT.Definition TROOT.cxx:3140; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TROOT::GetLibDirstatic const TString & GetLibDir()Get the library directory in the installation. Static utility function.Definition TROOT.cxx:3014; TRegexpRegular expres",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:193416,Integrability,interface,interface,193416,"& Swap(TString &other)Definition TString.h:716; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TString::AtollLong64_t Atoll() constReturn long long value of string.Definition TString.cxx:2014; TSysEvtHandler::IsActiveBool_t IsActive() constDefinition TSysEvtHandler.h:41; TSystemAbstract base class defining a generic interface to the underlying Operating System.Definition TSystem.h:266; TSystem::Unloadvirtual void Unload(const char *module)Unload a shared library.Definition TSystem.cxx:2052; TSystem::fFileHandlerTSeqCollection * fFileHandlerDefinition TSystem.h:296; TSystem::fMaxrfdInt_t fMaxrfdDefinition TSystem.h:281; TSystem::AddFileHandlervirtual void AddFileHandler(TFileHandler *fh)Add a file handler to the list of system file handlers.Definition TSystem.cxx:554; TSystem::GetLastErrorStringTString & GetLastErrorString()Return the thread local storage for the custom last error message.Definition TSystem.cxx:2102; TSystem::DynFindSymbolvirtual Func_t DynFindSymbol(const char *module, const char *entry)Find specific entry point in specified library.Definition TSystem.cxx:2044; TSystem::ResetErrnostatic void ResetErrno()Static function resetting system error number.Definition TSystem.cxx:284; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of spe",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:193991,Integrability,message,message,193991,"t descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TString::AtollLong64_t Atoll() constReturn long long value of string.Definition TString.cxx:2014; TSysEvtHandler::IsActiveBool_t IsActive() constDefinition TSysEvtHandler.h:41; TSystemAbstract base class defining a generic interface to the underlying Operating System.Definition TSystem.h:266; TSystem::Unloadvirtual void Unload(const char *module)Unload a shared library.Definition TSystem.cxx:2052; TSystem::fFileHandlerTSeqCollection * fFileHandlerDefinition TSystem.h:296; TSystem::fMaxrfdInt_t fMaxrfdDefinition TSystem.h:281; TSystem::AddFileHandlervirtual void AddFileHandler(TFileHandler *fh)Add a file handler to the list of system file handlers.Definition TSystem.cxx:554; TSystem::GetLastErrorStringTString & GetLastErrorString()Return the thread local storage for the custom last error message.Definition TSystem.cxx:2102; TSystem::DynFindSymbolvirtual Func_t DynFindSymbol(const char *module, const char *entry)Find specific entry point in specified library.Definition TSystem.cxx:2044; TSystem::ResetErrnostatic void ResetErrno()Static function resetting system error number.Definition TSystem.cxx:284; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::GetErrnostatic Int_t GetErrno()Static function returning system error number.Definition TSystem.cxx:276; TSystem::kDefault@ kDefaultDefinition TSystem.h:269; TSystem::fReadmaskTFdSet * fReadmaskDefinition TSystem.h:275; TSystem::fWdpathTString fWdpathDefinition TSystem.h:284; TSystem::DirNamevirtual const char * DirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1006; TSystem::FreeDirectoryvirtual void FreeDire",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:198203,Integrability,interface,interface,198203," TSystem.cxx:1857; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::GetDirEntryvirtual const char * GetDirEntry(void *dirp)Get a directory entry. Returns 0 if no more entries.Definition TSystem.cxx:853; TSystem::Initvirtual Bool_t Init()Initialize the OS interface.Definition TSystem.cxx:183; TSystem::AddTimervirtual void AddTimer(TTimer *t)Add timer to list of system timers.Definition TSystem.cxx:471; TSystem::fWritereadyTFdSet * fWritereadyFiles with reads waiting.Definition TSystem.h:278; TSystem::ClosePipevirtual int ClosePipe(FILE *pipe)Close the pipe.Definition TSystem.cxx:671; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TSystem::AddSignalHandlervirtual void AddSignalHandler(TSignalHandler *sh)Add a signal handler to list of system signal handlers.Definition TSystem.cxx:532; TSystem::fSignalHandlerTSeqCollection * fSignalHandlerDefinition TSystem.h:295; TSystem::fReadreadyTFdSet * fReadreadyFiles that should be checked for write events.Definition TSystem.h:277; TSystem::FindHelperTSystem * FindHelper(const char *path, void *dirptr=nullptr)Create helper TSystem to handle file and directory operation",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:200461,Integrability,protocol,protocol,200461," > fInsideNotifyDefinition TSystem.h:286; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TSystem::fMaxwfdInt_t fMaxwfdDefinition TSystem.h:282; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::GetHostByNamevirtual TInetAddress GetHostByName(const char *server)Get Internet Protocol (IP) address of host.Definition TSystem.cxx:2291; TSystem::RemoveSignalHandlervirtual TSignalHandler * RemoveSignalHandler(TSignalHandler *sh)Remove a signal handler from list of signal handlers.Definition TSystem.cxx:542; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set environment variable.Definition TSystem.cxx:1649; TSystem::StripOffProtostatic const char * StripOffProto(const char *path, const char *proto)Strip off protocol string from specified path.Definition TSystem.cxx:117; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TTimeBasic time type with millisecond precision.Definition TTime.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::IsAsyncBool_t IsAsync() constDefinition TTimer.h:81; TTimer::CheckTimerBool_t CheckTimer(const TTime &now)Check if timer timed out.Definition TTimer.cxx:130; TTimer::IsSyncBool_t IsSync() constDefinition TTimer.h:80; TUnixSystemDefinition TUnixSystem.h:32; TUnixSystem::AddTimervoid AddTimer(TTimer *ti) overrideAdd timer to list of system timers.Definition TUnixSystem.cxx:3009; TUnix",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:201688,Integrability,protocol,protocol,201688,"GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TTimeBasic time type with millisecond precision.Definition TTime.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::IsAsyncBool_t IsAsync() constDefinition TTimer.h:81; TTimer::CheckTimerBool_t CheckTimer(const TTime &now)Check if timer timed out.Definition TTimer.cxx:130; TTimer::IsSyncBool_t IsSync() constDefinition TTimer.h:80; TUnixSystemDefinition TUnixSystem.h:32; TUnixSystem::AddTimervoid AddTimer(TTimer *ti) overrideAdd timer to list of system timers.Definition TUnixSystem.cxx:3009; TUnixSystem::RecvRawint RecvRaw(int sock, void *buffer, int length, int flag) overrideReceive exactly length bytes into buffer.Definition TUnixSystem.cxx:3368; TUnixSystem::OpenConnectionint OpenConnection(const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"") overrideOpen a connection to a service on a server.Definition TUnixSystem.cxx:3225; TUnixSystem::GetMemInfoint GetMemInfo(MemInfo_t *info) const overrideReturns ram and swap memory usage info into the MemInfo_t structure.Definition TUnixSystem.cxx:5363; TUnixSystem::IsPathLocalBool_t IsPathLocal(const char *path) overrideReturns TRUE if the url in 'path' points to the local file system.Definition TUnixSystem.cxx:1643; TUnixSystem::Symlinkint Symlink(const char *from, const char *to) overrideCreate a symlink from file1 to file2.Definition TUnixSystem.cxx:1695; TUnixSystem::HomeDirectoryconst char * HomeDirectory(const char *userName=nullptr) overrideReturn the user's home directory.Definition TUnixSystem.cxx:1483; TUnixSystem::GetGidInt_t GetGid(const char *group=nullptr) overrideReturns the group's id. If group = 0, returns current user's group.Definition TUnixSystem.cxx:2029; TUnixSystem::UnixUdpConnectstatic int UnixUdpConnect(const char *hos",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:204125,Integrability,protocol,protocol,204125,"AnnounceUdpService(int port, int backlog) overrideAnnounce UDP service.Definition TUnixSystem.cxx:3250; TUnixSystem::AnnounceUnixServiceint AnnounceUnixService(int port, int backlog) overrideAnnounce unix domain service on path ""kServerPath/<port>"".Definition TUnixSystem.cxx:3258; TUnixSystem::UnixTcpConnectstatic int UnixTcpConnect(const char *hostname, int port, int tcpwindowsize)Open a TCP/IP connection to server and connect to a service (i.e.Definition TUnixSystem.cxx:4145; TUnixSystem::SetFPEMaskInt_t SetFPEMask(Int_t mask=kDefaultMask) overrideSet which conditions trigger a floating point exception.Definition TUnixSystem.cxx:999; TUnixSystem::UnixGetdirentrystatic const char * UnixGetdirentry(void *dir)Returns the next directory entry.Definition TUnixSystem.cxx:4010; TUnixSystem::Setenvvoid Setenv(const char *name, const char *value) overrideSet environment variable.Definition TUnixSystem.cxx:2129; TUnixSystem::ConnectServiceint ConnectService(const char *server, int port, int tcpwindowsize, const char *protocol=""tcp"")Connect to service servicename on server servername.Definition TUnixSystem.cxx:3201; TUnixSystem::ChangeDirectoryBool_t ChangeDirectory(const char *path) overrideChange directory. Returns kTRUE in case of success, kFALSE otherwise.Definition TUnixSystem.cxx:1434; TUnixSystem::UnixHomedirectorystatic const char * UnixHomedirectory(const char *user=nullptr)Returns the user's home directory.Definition TUnixSystem.cxx:3935; TUnixSystem::GetServiceByPortchar * GetServiceByPort(int port) overrideGet name of internet service.Definition TUnixSystem.cxx:3186; TUnixSystem::CheckSignalsBool_t CheckSignals(Bool_t sync)Check if some signals were raised and call their Notify() member.Definition TUnixSystem.cxx:1286; TUnixSystem::UnixMakedirstatic int UnixMakedir(const char *name)Make a Unix file system directory.Definition TUnixSystem.cxx:3976; TUnixSystem::UnixSigAlarmInterruptsSyscallsstatic void UnixSigAlarmInterruptsSyscalls(Bool_t set)When the argument is",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:217193,Integrability,interface,interface,217193,"Definition TUnixSystem.cxx:3901; TUnixSystem::GetPidint GetPid() overrideGet process id.Definition TUnixSystem.cxx:2179; TUnixSystem::ExecInt_t Exec(const char *shellcmd) overrideExecute a command.Definition TUnixSystem.cxx:2155; TUnixSystem::ResetTimervoid ResetTimer(TTimer *ti) overrideReset a-sync timer.Definition TUnixSystem.cxx:3033; TUnixSystem::RemoveSignalHandlerTSignalHandler * RemoveSignalHandler(TSignalHandler *sh) overrideRemove a signal handler from list of signal handlers.Definition TUnixSystem.cxx:849; TUnixSystem::UnixSignalstatic void UnixSignal(ESignals sig, SigHandler_t h)Set a signal handler for a signal.Definition TUnixSystem.cxx:3703; TUnixSystem::CloseConnectionvoid CloseConnection(int sock, Bool_t force=kFALSE) overrideClose socket.Definition TUnixSystem.cxx:3298; TUnixSystem::CheckDescriptorsBool_t CheckDescriptors()Check if there is activity on some file descriptors and call their Notify() member.Definition TUnixSystem.cxx:1337; TUnixSystem::InitBool_t Init() overrideInitialize Unix system interface.Definition TUnixSystem.cxx:595; TUnixSystem::Unloadvoid Unload(const char *module) overrideUnload a shared library.Definition TUnixSystem.cxx:2832; TUnixSystem::Umaskint Umask(Int_t mask) overrideSet the process file creation mode mask.Definition TUnixSystem.cxx:1901; TUnixSystem::UnixFilestatstatic int UnixFilestat(const char *path, FileStat_t &buf)Get info about a file.Definition TUnixSystem.cxx:4039; TUnixSystem::UnixRecvstatic int UnixRecv(int sock, void *buf, int len, int flag)Receive exactly length bytes into buffer.Definition TUnixSystem.cxx:4508; TUnixSystem::GetEffectiveUidInt_t GetEffectiveUid() overrideReturns the effective user id.Definition TUnixSystem.cxx:2021; TUnixSystem::FillWithCwdvoid FillWithCwd(char *cwd) constFill buffer with current working directory.Definition TUnixSystem.cxx:1473; TUnixSystem::UnixWaitchildstatic int UnixWaitchild()Wait till child is finished.Definition TUnixSystem.cxx:4130; TUnixSystem::Unlinkint Unlink",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:19653,Modifiability,variab,variable,19653,"dded);; 623#elif defined(HAVE_DLADDR); 624 SetRootSys();; 625#endif; 626 ; 627 // This is a fallback in case TROOT::GetRootSys() can't determine ROOTSYS; 628 gRootDir = ROOT::FoundationUtils::GetFallbackRootSys().c_str();; 629 ; 630 return kFALSE;; 631}; 632 ; 633//---- Misc --------------------------------------------------------------------; 634 ; 635////////////////////////////////////////////////////////////////////////////////; 636/// Set the application name (from command line, argv[0]) and copy it in; 637/// gProgName. Copy the application pathname in gProgPath.; 638/// If name is 0 let the system set the actual executable name and path; 639/// (works on MacOS X and Linux).; 640 ; 641void TUnixSystem::SetProgname(const char *name); 642{; 643 if (gProgName); 644 delete [] gProgName;; 645 if (gProgPath); 646 delete [] gProgPath;; 647 ; 648 if (!name || !*name) {; 649 name = GetExePath();; 650 gProgName = StrDup(BaseName(name));; 651 gProgPath = StrDup(DirName(name));; 652 } else {; 653 gProgName = StrDup(BaseName(name));; 654 char *w = Which(Getenv(""PATH""), gProgName);; 655 gProgPath = StrDup(DirName(w));; 656 delete [] w;; 657 }; 658}; 659 ; 660////////////////////////////////////////////////////////////////////////////////; 661/// Set DISPLAY environment variable based on utmp entry. Only for UNIX.; 662 ; 663void TUnixSystem::SetDisplay(); 664{; 665 if (!Getenv(""DISPLAY"")) {; 666 char *tty = ::ttyname(0); // device user is logged in on; 667 if (tty) {; 668 tty += 5; // remove ""/dev/""; 669 ; 670 TUtmpContent utmp;; 671 utmp.ReadUtmpFile();; 672 ; 673 STRUCT_UTMP *utmp_entry = utmp.SearchUtmpEntry(tty);; 674 if (utmp_entry) {; 675 if (utmp_entry->ut_host[0]) {; 676 TString disp;; 677 for (unsigned n = 0; (n < sizeof(utmp_entry->ut_host)) && utmp_entry->ut_host[n]; n++); 678 disp.Append(utmp_entry->ut_host[n]);; 679 if (disp.First(':') == kNPOS); 680 disp.Append("":0.0"");; 681 Setenv(""DISPLAY"", disp.Data());; 682 Warning(""SetDisplay"", ""DISPLAY not set, setting it",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:45602,Modifiability,config,configured,45602,"67 return std::string(cwd);; 1468}; 1469 ; 1470//////////////////////////////////////////////////////////////////////////////; 1471/// Fill buffer with current working directory.; 1472 ; 1473void TUnixSystem::FillWithCwd(char *cwd) const; 1474{; 1475 if (::getcwd(cwd, kMAXPATHLEN) == nullptr) {; 1476 Error(""WorkingDirectory"", ""getcwd() failed"");; 1477 }; 1478}; 1479 ; 1480////////////////////////////////////////////////////////////////////////////////; 1481/// Return the user's home directory.; 1482 ; 1483const char *TUnixSystem::HomeDirectory(const char *userName); 1484{; 1485 return UnixHomedirectory(userName);; 1486}; 1487 ; 1488//////////////////////////////////////////////////////////////////////////////; 1489/// Return the user's home directory.; 1490 ; 1491std::string TUnixSystem::GetHomeDirectory(const char *userName) const; 1492{; 1493 char path[kMAXPATHLEN], mydir[kMAXPATHLEN] = { '\0' };; 1494 auto res = UnixHomedirectory(userName, path, mydir);; 1495 if (res) return std::string(res);; 1496 else return std::string();; 1497}; 1498 ; 1499////////////////////////////////////////////////////////////////////////////////; 1500/// Return a user configured or systemwide directory to create; 1501/// temporary files in.; 1502 ; 1503const char *TUnixSystem::TempDirectory() const; 1504{; 1505 const char *dir = gSystem->Getenv(""TMPDIR"");; 1506 if (!dir || gSystem->AccessPathName(dir, kWritePermission)); 1507 dir = ""/tmp"";; 1508 ; 1509 return dir;; 1510}; 1511 ; 1512////////////////////////////////////////////////////////////////////////////////; 1513/// Create a secure temporary file by appending a unique; 1514/// 6 letter string to base. The file will be created in; 1515/// a standard (system) directory or in the directory; 1516/// provided in dir. Optionally one can provide suffix; 1517/// append to the final name - like extension "".txt"" or "".html"".; 1518/// The full filename is returned in base; 1519/// and a filepointer is returned for safely writing to the file; 1",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:53756,Modifiability,variab,variables,53756,"char *name); 1709{; 1710 TSystem *helper = FindHelper(name);; 1711 if (helper); 1712 return helper->Unlink(name);; 1713 ; 1714#if defined(R__SEEK64); 1715 struct stat64 finfo;; 1716 if (lstat64(name, &finfo) < 0); 1717#else; 1718 struct stat finfo;; 1719 if (lstat(name, &finfo) < 0); 1720#endif; 1721 return -1;; 1722 ; 1723 if (S_ISDIR(finfo.st_mode)); 1724 return ::rmdir(name);; 1725 else; 1726 return ::unlink(name);; 1727}; 1728 ; 1729//---- expand the metacharacters as in the shell -------------------------------; 1730 ; 1731// expand the metacharacters as in the shell; 1732 ; 1733const char; 1734#ifdef G__OLDEXPAND; 1735 kShellEscape = '\\',; 1736 *kShellStuff = ""(){}<>\""'"",; 1737#endif; 1738 *kShellMeta = ""~*[]{}?$"";; 1739 ; 1740 ; 1741#ifndef G__OLDEXPAND; 1742////////////////////////////////////////////////////////////////////////////////; 1743/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1744/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1745/// environment variables in a pathname. If compatibility is not an issue; 1746/// you can use on Unix directly $XXX. Returns kFALSE in case of success; 1747/// or kTRUE in case of error.; 1748 ; 1749Bool_t TUnixSystem::ExpandPathName(TString &path); 1750{; 1751 const char *p, *patbuf = (const char *)path;; 1752 ; 1753 // skip leading blanks; 1754 while (*patbuf == ' '); 1755 patbuf++;; 1756 ; 1757 // any shell meta characters ?; 1758 for (p = patbuf; *p; p++); 1759 if (strchr(kShellMeta, *p)); 1760 goto expand;; 1761 ; 1762 return kFALSE;; 1763 ; 1764expand:; 1765 // replace $(XXX) by $XXX; 1766 path.ReplaceAll(""$("",""$"");; 1767 path.ReplaceAll("")"","""");; 1768 ; 1769 return ExpandFileName(path);; 1770}; 1771#endif; 1772 ; 1773#ifdef G__OLDEXPAND; 1774////////////////////////////////////////////////////////////////////////////////; 1775/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1776/// For Unix/Win32 compatibility use $(XXX) instead",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:54760,Modifiability,variab,variables,54760," when using; 1745/// environment variables in a pathname. If compatibility is not an issue; 1746/// you can use on Unix directly $XXX. Returns kFALSE in case of success; 1747/// or kTRUE in case of error.; 1748 ; 1749Bool_t TUnixSystem::ExpandPathName(TString &path); 1750{; 1751 const char *p, *patbuf = (const char *)path;; 1752 ; 1753 // skip leading blanks; 1754 while (*patbuf == ' '); 1755 patbuf++;; 1756 ; 1757 // any shell meta characters ?; 1758 for (p = patbuf; *p; p++); 1759 if (strchr(kShellMeta, *p)); 1760 goto expand;; 1761 ; 1762 return kFALSE;; 1763 ; 1764expand:; 1765 // replace $(XXX) by $XXX; 1766 path.ReplaceAll(""$("",""$"");; 1767 path.ReplaceAll("")"","""");; 1768 ; 1769 return ExpandFileName(path);; 1770}; 1771#endif; 1772 ; 1773#ifdef G__OLDEXPAND; 1774////////////////////////////////////////////////////////////////////////////////; 1775/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1776/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1777/// environment variables in a pathname. If compatibility is not an issue; 1778/// you can use on Unix directly $XXX. Returns kFALSE in case of success; 1779/// or kTRUE in case of error.; 1780 ; 1781Bool_t TUnixSystem::ExpandPathName(TString &patbuf0); 1782{; 1783 const char *patbuf = (const char *)patbuf0;; 1784 const char *hd, *p;; 1785 // char cmd[kMAXPATHLEN],; 1786 char stuffedPat[kMAXPATHLEN], name[70];; 1787 char *q;; 1788 FILE *pf;; 1789 int ch;; 1790 ; 1791 // skip leading blanks; 1792 while (*patbuf == ' '); 1793 patbuf++;; 1794 ; 1795 // any shell meta characters ?; 1796 for (p = patbuf; *p; p++); 1797 if (strchr(kShellMeta, *p)); 1798 goto needshell;; 1799 ; 1800 return kFALSE;; 1801 ; 1802needshell:; 1803 // replace $(XXX) by $XXX; 1804 patbuf0.ReplaceAll(""$("",""$"");; 1805 patbuf0.ReplaceAll("")"","""");; 1806 ; 1807 // escape shell quote characters; 1808 EscChar(patbuf, stuffedPat, sizeof(stuffedPat), (char*)kShellStuff, kShellEscape);; 1809 ; 1810 TStrin",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:57480,Modifiability,variab,variables,57480,"ng() = GetError();; 1840 return kTRUE;; 1841 }; 1842 ; 1843 // read first argument; 1844 patbuf0 = """";; 1845 int cnt = 0;; 1846#if defined(R__AIX); 1847again:; 1848#endif; 1849 for (ch = fgetc(pf); ch != EOF && ch != ' ' && ch != '\n'; ch = fgetc(pf)) {; 1850 patbuf0.Append(ch);; 1851 cnt++;; 1852 }; 1853#if defined(R__AIX); 1854 // Work around bug timing problem due to delay in forking a large program; 1855 if (cnt == 0 && ch == EOF) goto again;; 1856#endif; 1857 ; 1858 // skip rest of pipe; 1859 while (ch != EOF) {; 1860 ch = fgetc(pf);; 1861 if (ch == ' ' || ch == '\t') {; 1862 GetLastErrorString() = ""expression ambigous"";; 1863 ::pclose(pf);; 1864 return kTRUE;; 1865 }; 1866 }; 1867 ; 1868 ::pclose(pf);; 1869 ; 1870 return kFALSE;; 1871}; 1872#endif; 1873 ; 1874////////////////////////////////////////////////////////////////////////////////; 1875/// Expand a pathname getting rid of special shell characaters like ~.$, etc.; 1876/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1877/// environment variables in a pathname. If compatibility is not an issue; 1878/// you can use on Unix directly $XXX. The user must delete returned string.; 1879/// Returns the expanded pathname or 0 in case of error.; 1880/// The user must delete returned string (delete []).; 1881 ; 1882char *TUnixSystem::ExpandPathName(const char *path); 1883{; 1884 TString patbuf = path;; 1885 if (ExpandPathName(patbuf)); 1886 return nullptr;; 1887 return StrDup(patbuf.Data());; 1888}; 1889 ; 1890////////////////////////////////////////////////////////////////////////////////; 1891/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1892 ; 1893int TUnixSystem::Chmod(const char *file, UInt_t mode); 1894{; 1895 return ::chmod(file, mode);; 1896}; 1897 ; 1898////////////////////////////////////////////////////////////////////////////////; 1899/// Set the process file creation mode mask.; 1900 ; 1901int TUnixSystem::Umask(Int_t mask); 1902{; 1903 return ::uma",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:65830,Modifiability,variab,variable,65830,"Gid and fGroup; 2096/// The returned structure must be deleted by the user. In case of; 2097/// error 0 is returned.; 2098 ; 2099UserGroup_t *TUnixSystem::GetGroupInfo(Int_t gid); 2100{; 2101 struct group *grp = getgrgid(gid);; 2102 if (grp) {; 2103 UserGroup_t *gr = new UserGroup_t;; 2104 gr->fUid = 0;; 2105 gr->fGid = grp->gr_gid;; 2106 gr->fGroup = grp->gr_name;; 2107 return gr;; 2108 }; 2109 return nullptr;; 2110}; 2111 ; 2112////////////////////////////////////////////////////////////////////////////////; 2113/// Returns all group info in the UserGroup_t structure. The only active; 2114/// fields in the UserGroup_t structure for this call are:; 2115/// fGid and fGroup; 2116/// If group = 0, returns current user's group. The returned structure; 2117/// must be deleted by the user. In case of error 0 is returned.; 2118 ; 2119UserGroup_t *TUnixSystem::GetGroupInfo(const char *group); 2120{; 2121 return GetGroupInfo(GetGid(group));; 2122}; 2123 ; 2124//---- environment manipulation ------------------------------------------------; 2125 ; 2126////////////////////////////////////////////////////////////////////////////////; 2127/// Set environment variable.; 2128 ; 2129void TUnixSystem::Setenv(const char *name, const char *value); 2130{; 2131 ::setenv(name, value, 1);; 2132}; 2133 ; 2134////////////////////////////////////////////////////////////////////////////////; 2135/// Get environment variable.; 2136 ; 2137const char *TUnixSystem::Getenv(const char *name); 2138{; 2139 return ::getenv(name);; 2140}; 2141 ; 2142////////////////////////////////////////////////////////////////////////////////; 2143/// Unset environment variable.; 2144 ; 2145void TUnixSystem::Unsetenv(const char *name); 2146{; 2147 ::unsetenv(name);; 2148}; 2149 ; 2150//---- Processes ---------------------------------------------------------------; 2151 ; 2152////////////////////////////////////////////////////////////////////////////////; 2153/// Execute a command.; 2154 ; 2155int TUnixSystem::Exec(",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:66078,Modifiability,variab,variable,66078,"d = 0;; 2105 gr->fGid = grp->gr_gid;; 2106 gr->fGroup = grp->gr_name;; 2107 return gr;; 2108 }; 2109 return nullptr;; 2110}; 2111 ; 2112////////////////////////////////////////////////////////////////////////////////; 2113/// Returns all group info in the UserGroup_t structure. The only active; 2114/// fields in the UserGroup_t structure for this call are:; 2115/// fGid and fGroup; 2116/// If group = 0, returns current user's group. The returned structure; 2117/// must be deleted by the user. In case of error 0 is returned.; 2118 ; 2119UserGroup_t *TUnixSystem::GetGroupInfo(const char *group); 2120{; 2121 return GetGroupInfo(GetGid(group));; 2122}; 2123 ; 2124//---- environment manipulation ------------------------------------------------; 2125 ; 2126////////////////////////////////////////////////////////////////////////////////; 2127/// Set environment variable.; 2128 ; 2129void TUnixSystem::Setenv(const char *name, const char *value); 2130{; 2131 ::setenv(name, value, 1);; 2132}; 2133 ; 2134////////////////////////////////////////////////////////////////////////////////; 2135/// Get environment variable.; 2136 ; 2137const char *TUnixSystem::Getenv(const char *name); 2138{; 2139 return ::getenv(name);; 2140}; 2141 ; 2142////////////////////////////////////////////////////////////////////////////////; 2143/// Unset environment variable.; 2144 ; 2145void TUnixSystem::Unsetenv(const char *name); 2146{; 2147 ::unsetenv(name);; 2148}; 2149 ; 2150//---- Processes ---------------------------------------------------------------; 2151 ; 2152////////////////////////////////////////////////////////////////////////////////; 2153/// Execute a command.; 2154 ; 2155int TUnixSystem::Exec(const char *shellcmd); 2156{; 2157 return ::system(shellcmd);; 2158}; 2159 ; 2160////////////////////////////////////////////////////////////////////////////////; 2161/// Open a pipe.; 2162 ; 2163FILE *TUnixSystem::OpenPipe(const char *command, const char *mode); 2164{; 2165 return ::popen(comman",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:66313,Modifiability,variab,variable,66313,"up info in the UserGroup_t structure. The only active; 2114/// fields in the UserGroup_t structure for this call are:; 2115/// fGid and fGroup; 2116/// If group = 0, returns current user's group. The returned structure; 2117/// must be deleted by the user. In case of error 0 is returned.; 2118 ; 2119UserGroup_t *TUnixSystem::GetGroupInfo(const char *group); 2120{; 2121 return GetGroupInfo(GetGid(group));; 2122}; 2123 ; 2124//---- environment manipulation ------------------------------------------------; 2125 ; 2126////////////////////////////////////////////////////////////////////////////////; 2127/// Set environment variable.; 2128 ; 2129void TUnixSystem::Setenv(const char *name, const char *value); 2130{; 2131 ::setenv(name, value, 1);; 2132}; 2133 ; 2134////////////////////////////////////////////////////////////////////////////////; 2135/// Get environment variable.; 2136 ; 2137const char *TUnixSystem::Getenv(const char *name); 2138{; 2139 return ::getenv(name);; 2140}; 2141 ; 2142////////////////////////////////////////////////////////////////////////////////; 2143/// Unset environment variable.; 2144 ; 2145void TUnixSystem::Unsetenv(const char *name); 2146{; 2147 ::unsetenv(name);; 2148}; 2149 ; 2150//---- Processes ---------------------------------------------------------------; 2151 ; 2152////////////////////////////////////////////////////////////////////////////////; 2153/// Execute a command.; 2154 ; 2155int TUnixSystem::Exec(const char *shellcmd); 2156{; 2157 return ::system(shellcmd);; 2158}; 2159 ; 2160////////////////////////////////////////////////////////////////////////////////; 2161/// Open a pipe.; 2162 ; 2163FILE *TUnixSystem::OpenPipe(const char *command, const char *mode); 2164{; 2165 return ::popen(command, mode);; 2166}; 2167 ; 2168////////////////////////////////////////////////////////////////////////////////; 2169/// Close the pipe.; 2170 ; 2171int TUnixSystem::ClosePipe(FILE *pipe); 2172{; 2173 return ::pclose(pipe);; 2174}; 2175 ; 2176/",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:149082,Modifiability,extend,extended,149082,"alue (to insert the Cling provided parts); 4619 // back to the default.; 4620 seenCling = kTRUE;; 4621 return dynpath_full;; 4622 }; 4623 ; 4624 // Another thread might have updated this. Even-though this is executed at the; 4625 // start of the process, we might get there if the user is explicitly; 4626 // 'resetting' the value.; 4627 if (!reset && (seenCling || (initialized && gCling == nullptr))); 4628 return dynpath_full;; 4629 ; 4630 if (!initialized) {; 4631 // force one time initialization of gROOT before we start; 4632 // (otherwise it might be done as a side effect of gEnv->GetValue and; 4633 // TROOT's initialization will call this routine).; 4634 gROOT;; 4635 }; 4636 ; 4637 static TString dynpath_envpart;; 4638 static TString dynpath_syspart;; 4639 ; 4640 if (reset || !initialized) {; 4641 ; 4642 dynpath_envpart = gSystem->Getenv(""ROOT_LIBRARY_PATH"");; 4643 TString rdynpath = gEnv->GetValue(""Root.DynamicPath"", (char*)0);; 4644 rdynpath.ReplaceAll("": "", "":""); // in case DynamicPath was extended; 4645 if (rdynpath.IsNull()) {; 4646 rdynpath = "".:""; rdynpath += TROOT::GetLibDir();; 4647 }; 4648 TString ldpath;; 4649 #if defined (R__AIX); 4650 ldpath = gSystem->Getenv(""LIBPATH"");; 4651 #elif defined(R__MACOSX); 4652 ldpath = gSystem->Getenv(""DYLD_LIBRARY_PATH"");; 4653 if (!ldpath.IsNull()); 4654 ldpath += "":"";; 4655 ldpath += gSystem->Getenv(""LD_LIBRARY_PATH"");; 4656 if (!ldpath.IsNull()); 4657 ldpath += "":"";; 4658 ldpath += gSystem->Getenv(""DYLD_FALLBACK_LIBRARY_PATH"");; 4659 #else; 4660 ldpath = gSystem->Getenv(""LD_LIBRARY_PATH"");; 4661 #endif; 4662 if (!ldpath.IsNull()) {; 4663 if (!dynpath_envpart.IsNull()); 4664 dynpath_envpart += "":"";; 4665 dynpath_envpart += ldpath;; 4666 }; 4667 if (!rdynpath.IsNull()) {; 4668 if (!dynpath_envpart.IsNull()); 4669 dynpath_envpart += "":"";; 4670 dynpath_envpart += rdynpath;; 4671 }; 4672 if (!dynpath_envpart.Contains(TROOT::GetLibDir())) {; 4673 dynpath_envpart += "":""; dynpath_envpart += TROOT::GetLibDir();; 4674 }; 4675",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:195659,Modifiability,variab,variable,195659,"n TSystem.h:269; TSystem::fReadmaskTFdSet * fReadmaskDefinition TSystem.h:275; TSystem::fWdpathTString fWdpathDefinition TSystem.h:284; TSystem::DirNamevirtual const char * DirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1006; TSystem::FreeDirectoryvirtual void FreeDirectory(void *dirp)Free a directory.Definition TSystem.cxx:845; TSystem::OpenDirectoryvirtual void * OpenDirectory(const char *name)Open a directory. Returns 0 if directory does not exist.Definition TSystem.cxx:836; TSystem::GetPidvirtual int GetPid()Get process id.Definition TSystem.cxx:707; TSystem::fHostnameTString fHostnameDefinition TSystem.h:285; TSystem::NextTimeOutvirtual Long_t NextTimeOut(Bool_t mode)Time when next timer of mode (synchronous=kTRUE or asynchronous=kFALSE) will time-out (in ms).Definition TSystem.cxx:494; TSystem::SetSockOptvirtual int SetSockOpt(int sock, int kind, int val)Set socket option.Definition TSystem.cxx:2436; TSystem::Getenvvirtual const char * Getenv(const char *env)Get environment variable.Definition TSystem.cxx:1665; TSystem::fWritemaskTFdSet * fWritemaskFiles that should be checked for read events.Definition TSystem.h:276; TSystem::fSignalsTFdSet * fSignalsFiles with writes waiting.Definition TSystem.h:279; TSystem::ConcatFileNamevirtual char * ConcatFileName(const char *dir, const char *name)Concatenate a directory and a file name. User must delete returned string.Definition TSystem.cxx:1071; TSystem::IsPathLocalvirtual Bool_t IsPathLocal(const char *path)Returns TRUE if the url in 'path' points to the local file system.Definition TSystem.cxx:1305; TSystem::FindFilevirtual const char * FindFile(const char *search, TString &file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1538; TSystem::mkdirvirtual int mkdir(const char *name, Bool_t recursive=kFALSE)Make a file system directory.Definition TSystem.cxx:906; TSystem::MakeDirectoryvirtual int MakeDirectory(const char *name)Make ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:200321,Modifiability,variab,variable,200321,"mersDefinition TSystem.h:294; TSystem::fNfdInt_t fNfdSignals that were trapped.Definition TSystem.h:280; TSystem::fInsideNotifystd::atomic< Bool_t > fInsideNotifyDefinition TSystem.h:286; TSystem::Sleepvirtual void Sleep(UInt_t milliSec)Sleep milliSec milli seconds.Definition TSystem.cxx:437; TSystem::fMaxwfdInt_t fMaxwfdDefinition TSystem.h:282; TSystem::WorkingDirectoryvirtual const char * WorkingDirectory()Return working directory.Definition TSystem.cxx:871; TSystem::Whichvirtual char * Which(const char *search, const char *file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1548; TSystem::GetHostByNamevirtual TInetAddress GetHostByName(const char *server)Get Internet Protocol (IP) address of host.Definition TSystem.cxx:2291; TSystem::RemoveSignalHandlervirtual TSignalHandler * RemoveSignalHandler(TSignalHandler *sh)Remove a signal handler from list of signal handlers.Definition TSystem.cxx:542; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set environment variable.Definition TSystem.cxx:1649; TSystem::StripOffProtostatic const char * StripOffProto(const char *path, const char *proto)Strip off protocol string from specified path.Definition TSystem.cxx:117; TSystem::RemoveTimervirtual TTimer * RemoveTimer(TTimer *t)Remove timer from list of system timers.Definition TSystem.cxx:481; TSystem::GetDirNamevirtual TString GetDirName(const char *pathname)Return the directory name in pathname.Definition TSystem.cxx:1032; TSystem::Unlinkvirtual int Unlink(const char *name)Unlink, i.e.Definition TSystem.cxx:1381; TTimeBasic time type with millisecond precision.Definition TTime.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TTimer::IsAsyncBool_t IsAsync() constDefinition TTimer.h:81; TTimer::CheckTimerBool_t CheckTimer(const TTime &now)Check if timer timed out.Definition TTimer.cxx:130; TTimer::IsSyncBool_t IsSync() constDefinition TTimer.h:80; TUnixSystemDefinition T",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:203976,Modifiability,variab,variable,203976,"nixSystem::RemoveTimerTTimer * RemoveTimer(TTimer *ti) overrideRemove timer from list of system timers.Definition TUnixSystem.cxx:3018; TUnixSystem::AnnounceUdpServiceint AnnounceUdpService(int port, int backlog) overrideAnnounce UDP service.Definition TUnixSystem.cxx:3250; TUnixSystem::AnnounceUnixServiceint AnnounceUnixService(int port, int backlog) overrideAnnounce unix domain service on path ""kServerPath/<port>"".Definition TUnixSystem.cxx:3258; TUnixSystem::UnixTcpConnectstatic int UnixTcpConnect(const char *hostname, int port, int tcpwindowsize)Open a TCP/IP connection to server and connect to a service (i.e.Definition TUnixSystem.cxx:4145; TUnixSystem::SetFPEMaskInt_t SetFPEMask(Int_t mask=kDefaultMask) overrideSet which conditions trigger a floating point exception.Definition TUnixSystem.cxx:999; TUnixSystem::UnixGetdirentrystatic const char * UnixGetdirentry(void *dir)Returns the next directory entry.Definition TUnixSystem.cxx:4010; TUnixSystem::Setenvvoid Setenv(const char *name, const char *value) overrideSet environment variable.Definition TUnixSystem.cxx:2129; TUnixSystem::ConnectServiceint ConnectService(const char *server, int port, int tcpwindowsize, const char *protocol=""tcp"")Connect to service servicename on server servername.Definition TUnixSystem.cxx:3201; TUnixSystem::ChangeDirectoryBool_t ChangeDirectory(const char *path) overrideChange directory. Returns kTRUE in case of success, kFALSE otherwise.Definition TUnixSystem.cxx:1434; TUnixSystem::UnixHomedirectorystatic const char * UnixHomedirectory(const char *user=nullptr)Returns the user's home directory.Definition TUnixSystem.cxx:3935; TUnixSystem::GetServiceByPortchar * GetServiceByPort(int port) overrideGet name of internet service.Definition TUnixSystem.cxx:3186; TUnixSystem::CheckSignalsBool_t CheckSignals(Bool_t sync)Check if some signals were raised and call their Notify() member.Definition TUnixSystem.cxx:1286; TUnixSystem::UnixMakedirstatic int UnixMakedir(const char *name)Make a Unix fi",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:206839,Modifiability,variab,variable,206839,"on TUnixSystem.cxx:2187; TUnixSystem::AnnounceTcpServiceint AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize=-1) overrideAnnounce TCP/IP service.Definition TUnixSystem.cxx:3241; TUnixSystem::TUnixSystemTUnixSystem()Definition TUnixSystem.cxx:575; TUnixSystem::AddDynamicPathvoid AddDynamicPath(const char *lib) overrideAdd a new directory to the dynamic path.Definition TUnixSystem.cxx:4725; TUnixSystem::SetDynamicPathvoid SetDynamicPath(const char *lib) overrideSet the dynamic path to a new value.Definition TUnixSystem.cxx:4748; TUnixSystem::ClosePipeint ClosePipe(FILE *pipe) overrideClose the pipe.Definition TUnixSystem.cxx:2171; TUnixSystem::GetHomeDirectorystd::string GetHomeDirectory(const char *userName=nullptr) const overrideReturn the user's home directory.Definition TUnixSystem.cxx:1491; TUnixSystem::SelectInt_t Select(TList *active, Long_t timeout) overrideSelect on file descriptors.Definition TUnixSystem.cxx:1202; TUnixSystem::Unsetenvvoid Unsetenv(const char *name) overrideUnset environment variable.Definition TUnixSystem.cxx:2145; TUnixSystem::~TUnixSystemvirtual ~TUnixSystem()Reset to original state.Definition TUnixSystem.cxx:581; TUnixSystem::Abortvoid Abort(int code=0) overrideAbort the application.Definition TUnixSystem.cxx:2202; TUnixSystem::Syslogvoid Syslog(ELogLevel level, const char *mess) overrideSend mess to syslog daemon.Definition TUnixSystem.cxx:2654; TUnixSystem::GetGroupInfoUserGroup_t * GetGroupInfo(Int_t gid) overrideReturns all group info in the UserGroup_t structure.Definition TUnixSystem.cxx:2099; TUnixSystem::GetUidInt_t GetUid(const char *user=nullptr) overrideReturns the user's id. If user = 0, returns current user's id.Definition TUnixSystem.cxx:2005; TUnixSystem::ExpandPathNameBool_t ExpandPathName(TString &patbuf) overrideExpand a pathname getting rid of special shell characters like ~.Definition TUnixSystem.cxx:1749; TUnixSystem::Openlogvoid Openlog(const char *name, Int_t options, ELogFacility facility)",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:212366,Modifiability,variab,variable,212366,"Get Internet Protocol (IP) address of host.Definition TUnixSystem.cxx:3046; TUnixSystem::SendBufint SendBuf(int sock, const void *buffer, int length) overrideSend a buffer headed by a length indicator.Definition TUnixSystem.cxx:3341; TUnixSystem::HostNameconst char * HostName() overrideReturn the system's host name.Definition TUnixSystem.cxx:762; TUnixSystem::CheckChildsvoid CheckChilds()Check if children have finished.Definition TUnixSystem.cxx:1317; TUnixSystem::RecvBufint RecvBuf(int sock, void *buffer, int length) overrideReceive a buffer headed by a length indicator.Definition TUnixSystem.cxx:3316; TUnixSystem::UnixUnixServicestatic int UnixUnixService(int port, int backlog)Open a socket, bind to it and start listening for Unix domain connections to it.Definition TUnixSystem.cxx:4432; TUnixSystem::GetUserInfoUserGroup_t * GetUserInfo(Int_t uid) overrideReturns all user info in the UserGroup_t structure.Definition TUnixSystem.cxx:2054; TUnixSystem::SetDisplayvoid SetDisplay() overrideSet DISPLAY environment variable based on utmp entry. Only for UNIX.Definition TUnixSystem.cxx:663; TUnixSystem::RemoveFileHandlerTFileHandler * RemoveFileHandler(TFileHandler *fh) overrideRemove a file handler from the list of file handlers.Definition TUnixSystem.cxx:804; TUnixSystem::UnixSignamestatic const char * UnixSigname(ESignals sig)Return the signal name associated with a signal.Definition TUnixSystem.cxx:3813; TUnixSystem::UnixNowstatic Long64_t UnixNow()Get current time in milliseconds since 0:00 Jan 1 1995.Definition TUnixSystem.cxx:3847; TUnixSystem::UnixFSstatstatic int UnixFSstat(const char *path, Long_t *id, Long_t *bsize, Long_t *blocks, Long_t *bfree)Get info about a file system: id, bsize, bfree, blocks.Definition TUnixSystem.cxx:4083; TUnixSystem::ResetSignalsvoid ResetSignals() overrideReset signals handlers to previous behaviour.Definition TUnixSystem.cxx:886; TUnixSystem::GetSockNameTInetAddress GetSockName(int sock) overrideGet Internet Protocol (IP) address ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:215643,Modifiability,variab,variable,215643,"pen a socket, bind to it and start listening for TCP/IP connections on the port.Definition TUnixSystem.cxx:4297; TUnixSystem::DispatchSignalsvoid DispatchSignals(ESignals sig)Handle and dispatch signals.Definition TUnixSystem.cxx:3648; TUnixSystem::AddFileHandlervoid AddFileHandler(TFileHandler *fh) overrideAdd a file handler to the list of system file handlers.Definition TUnixSystem.cxx:782; TUnixSystem::GetCryptoRandomInt_t GetCryptoRandom(void *buf, Int_t len) overrideReturn cryptographic random number Fill provided buffer with random values Returns number of bytes wr...Definition TUnixSystem.cxx:740; TUnixSystem::OpenDirectoryvoid * OpenDirectory(const char *name) overrideOpen a Unix file system directory. Returns 0 if directory does not exist.Definition TUnixSystem.cxx:1392; TUnixSystem::Renameint Rename(const char *from, const char *to) overrideRename a file. Returns 0 when successful, -1 in case of failure.Definition TUnixSystem.cxx:1632; TUnixSystem::Getenvconst char * Getenv(const char *name) overrideGet environment variable.Definition TUnixSystem.cxx:2137; TUnixSystem::GetPathInfoint GetPathInfo(const char *path, FileStat_t &buf) overrideGet info about a file.Definition TUnixSystem.cxx:1658; TUnixSystem::GetEffectiveGidInt_t GetEffectiveGid() overrideReturns the effective group id.Definition TUnixSystem.cxx:2045; TUnixSystem::UnixSelectstatic int UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready, Long_t timeout)Wait for events on the file descriptors specified in the readready and writeready masks or for timeou...Definition TUnixSystem.cxx:3901; TUnixSystem::GetPidint GetPid() overrideGet process id.Definition TUnixSystem.cxx:2179; TUnixSystem::ExecInt_t Exec(const char *shellcmd) overrideExecute a command.Definition TUnixSystem.cxx:2155; TUnixSystem::ResetTimervoid ResetTimer(TTimer *ti) overrideReset a-sync timer.Definition TUnixSystem.cxx:3033; TUnixSystem::RemoveSignalHandlerTSignalHandler * RemoveSignalHandler(TSignalHandler *sh) overrideRe",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:219120,Modifiability,config,configured,219120,"tion TUnixSystem.cxx:4130; TUnixSystem::Unlinkint Unlink(const char *name) overrideUnlink, i.e.Definition TUnixSystem.cxx:1708; TUnixSystem::ListLibrariesvoid ListLibraries(const char *regexp="""") overrideList all loaded shared libraries.Definition TUnixSystem.cxx:2848; TUnixSystem::Closelogvoid Closelog() overrideClose connection to system log daemon.Definition TUnixSystem.cxx:2663; TUnixSystem::RedirectOutputInt_t RedirectOutput(const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr) overrideRedirect standard output (stdout, stderr) to the specified file.Definition TUnixSystem.cxx:2682; TUnixSystem::Sleepvoid Sleep(UInt_t milliSec) overrideSleep milliSec milliseconds.Definition TUnixSystem.cxx:1184; TUnixSystem::ResetSignalvoid ResetSignal(ESignals sig, Bool_t reset=kTRUE) overrideIf reset is true reset the signal handler for the specified signal to the default handler,...Definition TUnixSystem.cxx:875; TUnixSystem::TempDirectoryconst char * TempDirectory() const overrideReturn a user configured or systemwide directory to create temporary files in.Definition TUnixSystem.cxx:1503; TUnixSystem::DynFindSymbolFunc_t DynFindSymbol(const char *module, const char *entry) overridedynamic linking of moduleDefinition TUnixSystem.cxx:2814; TUnixSystem::GetDynamicPathconst char * GetDynamicPath() overrideReturn the dynamic path (used to find shared libraries).Definition TUnixSystem.cxx:4738; TUnixSystem::OpenPipeFILE * OpenPipe(const char *shellcmd, const char *mode) overrideOpen a pipe.Definition TUnixSystem.cxx:2163; TUnixSystem::FreeDirectoryvoid FreeDirectory(void *dirp) overrideClose a Unix file system directory.Definition TUnixSystem.cxx:1404; TUnixSystem::UnixResetSignalsstatic void UnixResetSignals()Restore old signal handlers.Definition TUnixSystem.cxx:3836; TUnixSystem::GetCpuInfoint GetCpuInfo(CpuInfo_t *info, Int_t sampleTime=1000) const overrideReturns cpu load average and load info into the CpuInfo_t structure.Definition TUnixSystem.cxx:5344; TUnixSy",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:2814,Performance,queue,queue,2814," \; 53 defined(R__FBSD) || defined(R__OBSD) || \; 54 defined(R__MACOSX) || defined(R__HURD); 55#define HAS_DIRENT; 56#endif; 57#ifdef HAS_DIRENT; 58# include <dirent.h>; 59#else; 60# include <sys/dir.h>; 61#endif; 62#if defined(ULTRIX) || defined(R__SUN); 63# include <sgtty.h>; 64#endif; 65#if defined(R__AIX) || defined(R__LINUX) || \; 66 defined(R__FBSD) || defined(R__OBSD) || \; 67 defined(R__LYNXOS) || defined(R__MACOSX) || defined(R__HURD); 68# include <sys/ioctl.h>; 69#endif; 70#if defined(R__AIX) || defined(R__SOLARIS); 71# include <sys/select.h>; 72#endif; 73#if defined(R__MACOSX); 74# include <mach-o/dyld.h>; 75# include <sys/mount.h>; 76 extern ""C"" int statfs(const char *file, struct statfs *buffer);; 77#elif defined(R__LINUX) || defined(R__HURD); 78# include <sys/vfs.h>; 79#elif defined(R__FBSD) || defined(R__OBSD); 80# include <sys/param.h>; 81# include <sys/mount.h>; 82# ifdef R__FBSD; 83# include <sys/user.h>; 84# include <sys/types.h>; 85# include <sys/param.h>; 86# include <sys/queue.h>; 87# include <libprocstat.h>; 88# include <libutil.h>; 89# endif; 90#else; 91# include <sys/statfs.h>; 92#endif; 93 ; 94#include <utime.h>; 95#include <syslog.h>; 96#include <sys/stat.h>; 97#include <setjmp.h>; 98#include <signal.h>; 99#include <sys/param.h>; 100#include <pwd.h>; 101#include <grp.h>; 102#include <errno.h>; 103#include <sys/resource.h>; 104#include <sys/wait.h>; 105#include <time.h>; 106#include <sys/time.h>; 107#include <sys/file.h>; 108#include <sys/socket.h>; 109#include <netinet/in.h>; 110#include <netinet/tcp.h>; 111#if defined(R__AIX); 112# define _XOPEN_EXTENDED_SOURCE; 113# include <arpa/inet.h>; 114# undef _XOPEN_EXTENDED_SOURCE; 115# if !defined(_AIX41) && !defined(_AIX43); 116 // AIX 3.2 doesn't have it; 117# define HASNOT_INETATON; 118# endif; 119#else; 120# include <arpa/inet.h>; 121#endif; 122#include <sys/un.h>; 123#include <netdb.h>; 124#include <fcntl.h>; 125#if defined(R__SOLARIS); 126# include <sys/systeminfo.h>; 127# include <sys/fili",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:15561,Performance,load,loaded,15561," function with mh==0; 506 if (!mh) {; 507 gLinkedDylibs = linkedDylibs;; 508 return;; 509 }; 510 ; 511 TString lib = _dyld_get_image_name(i++);; 512 ; 513 TRegexp sovers = ""libCore\\.[0-9]+\\.*[0-9]*\\.*[0-9]*\\.so"";; 514 TRegexp dyvers = ""libCore\\.[0-9]+\\.*[0-9]*\\.*[0-9]*\\.dylib"";; 515 ; 516#ifdef ROOTPREFIX; 517 if (gSystem->Getenv(""ROOTIGNOREPREFIX"")) {; 518#endif; 519 if (lib.EndsWith(""libCore.dylib"") || lib.EndsWith(""libCore.so"") ||; 520 lib.Index(sovers) != kNPOS || lib.Index(dyvers) != kNPOS) {; 521 char respath[kMAXPATHLEN];; 522 if (!realpath(lib, respath)) {; 523 if (!gSystem->Getenv(""ROOTSYS"")); 524 ::SysError(""TUnixSystem::DylibAdded"", ""error getting realpath of libCore, please set ROOTSYS in the shell"");; 525 } else {; 526 TString rs = gSystem->GetDirName(respath);; 527 gSystem->Setenv(""ROOTSYS"", gSystem->GetDirName(rs.Data()).Data());; 528 }; 529 }; 530#ifdef ROOTPREFIX; 531 }; 532#endif; 533 ; 534 // when libSystem.B.dylib is loaded we have finished loading all dylibs; 535 // explicitly linked against the executable. Additional dylibs; 536 // come when they are explicitly linked against loaded so's, currently; 537 // we are not interested in these; 538 if (lib.EndsWith(""/libSystem.B.dylib"")) {; 539 gotFirstSo = kTRUE;; 540 if (linkedDylibs.IsNull()) {; 541 // TSystem::GetLibraries() assumes that an empty GetLinkedLibraries(); 542 // means failure to extract the linked libraries. Signal ""we did; 543 // manage, but it's empty"" by returning a single space.; 544 linkedDylibs = ' ';; 545 }; 546 }; 547 ; 548 // add all libs loaded before libSystem.B.dylib; 549 if (!gotFirstSo && (lib.EndsWith("".dylib"") || lib.EndsWith("".so""))) {; 550 sovers = ""\\.[0-9]+\\.*[0-9]*\\.so"";; 551 Ssiz_t idx = lib.Index(sovers);; 552 if (idx != kNPOS) {; 553 lib.Remove(idx);; 554 lib += "".so"";; 555 }; 556 dyvers = ""\\.[0-9]+\\.*[0-9]*\\.dylib"";; 557 idx = lib.Index(dyvers);; 558 if (idx != kNPOS) {; 559 lib.Remove(idx);; 560 lib += "".dylib"";; 561 }; 562 if (!gSystem->AccessPat",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:15585,Performance,load,loading,15585," function with mh==0; 506 if (!mh) {; 507 gLinkedDylibs = linkedDylibs;; 508 return;; 509 }; 510 ; 511 TString lib = _dyld_get_image_name(i++);; 512 ; 513 TRegexp sovers = ""libCore\\.[0-9]+\\.*[0-9]*\\.*[0-9]*\\.so"";; 514 TRegexp dyvers = ""libCore\\.[0-9]+\\.*[0-9]*\\.*[0-9]*\\.dylib"";; 515 ; 516#ifdef ROOTPREFIX; 517 if (gSystem->Getenv(""ROOTIGNOREPREFIX"")) {; 518#endif; 519 if (lib.EndsWith(""libCore.dylib"") || lib.EndsWith(""libCore.so"") ||; 520 lib.Index(sovers) != kNPOS || lib.Index(dyvers) != kNPOS) {; 521 char respath[kMAXPATHLEN];; 522 if (!realpath(lib, respath)) {; 523 if (!gSystem->Getenv(""ROOTSYS"")); 524 ::SysError(""TUnixSystem::DylibAdded"", ""error getting realpath of libCore, please set ROOTSYS in the shell"");; 525 } else {; 526 TString rs = gSystem->GetDirName(respath);; 527 gSystem->Setenv(""ROOTSYS"", gSystem->GetDirName(rs.Data()).Data());; 528 }; 529 }; 530#ifdef ROOTPREFIX; 531 }; 532#endif; 533 ; 534 // when libSystem.B.dylib is loaded we have finished loading all dylibs; 535 // explicitly linked against the executable. Additional dylibs; 536 // come when they are explicitly linked against loaded so's, currently; 537 // we are not interested in these; 538 if (lib.EndsWith(""/libSystem.B.dylib"")) {; 539 gotFirstSo = kTRUE;; 540 if (linkedDylibs.IsNull()) {; 541 // TSystem::GetLibraries() assumes that an empty GetLinkedLibraries(); 542 // means failure to extract the linked libraries. Signal ""we did; 543 // manage, but it's empty"" by returning a single space.; 544 linkedDylibs = ' ';; 545 }; 546 }; 547 ; 548 // add all libs loaded before libSystem.B.dylib; 549 if (!gotFirstSo && (lib.EndsWith("".dylib"") || lib.EndsWith("".so""))) {; 550 sovers = ""\\.[0-9]+\\.*[0-9]*\\.so"";; 551 Ssiz_t idx = lib.Index(sovers);; 552 if (idx != kNPOS) {; 553 lib.Remove(idx);; 554 lib += "".so"";; 555 }; 556 dyvers = ""\\.[0-9]+\\.*[0-9]*\\.dylib"";; 557 idx = lib.Index(dyvers);; 558 if (idx != kNPOS) {; 559 lib.Remove(idx);; 560 lib += "".dylib"";; 561 }; 562 if (!gSystem->AccessPat",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:15725,Performance,load,loaded,15725,"et_image_name(i++);; 512 ; 513 TRegexp sovers = ""libCore\\.[0-9]+\\.*[0-9]*\\.*[0-9]*\\.so"";; 514 TRegexp dyvers = ""libCore\\.[0-9]+\\.*[0-9]*\\.*[0-9]*\\.dylib"";; 515 ; 516#ifdef ROOTPREFIX; 517 if (gSystem->Getenv(""ROOTIGNOREPREFIX"")) {; 518#endif; 519 if (lib.EndsWith(""libCore.dylib"") || lib.EndsWith(""libCore.so"") ||; 520 lib.Index(sovers) != kNPOS || lib.Index(dyvers) != kNPOS) {; 521 char respath[kMAXPATHLEN];; 522 if (!realpath(lib, respath)) {; 523 if (!gSystem->Getenv(""ROOTSYS"")); 524 ::SysError(""TUnixSystem::DylibAdded"", ""error getting realpath of libCore, please set ROOTSYS in the shell"");; 525 } else {; 526 TString rs = gSystem->GetDirName(respath);; 527 gSystem->Setenv(""ROOTSYS"", gSystem->GetDirName(rs.Data()).Data());; 528 }; 529 }; 530#ifdef ROOTPREFIX; 531 }; 532#endif; 533 ; 534 // when libSystem.B.dylib is loaded we have finished loading all dylibs; 535 // explicitly linked against the executable. Additional dylibs; 536 // come when they are explicitly linked against loaded so's, currently; 537 // we are not interested in these; 538 if (lib.EndsWith(""/libSystem.B.dylib"")) {; 539 gotFirstSo = kTRUE;; 540 if (linkedDylibs.IsNull()) {; 541 // TSystem::GetLibraries() assumes that an empty GetLinkedLibraries(); 542 // means failure to extract the linked libraries. Signal ""we did; 543 // manage, but it's empty"" by returning a single space.; 544 linkedDylibs = ' ';; 545 }; 546 }; 547 ; 548 // add all libs loaded before libSystem.B.dylib; 549 if (!gotFirstSo && (lib.EndsWith("".dylib"") || lib.EndsWith("".so""))) {; 550 sovers = ""\\.[0-9]+\\.*[0-9]*\\.so"";; 551 Ssiz_t idx = lib.Index(sovers);; 552 if (idx != kNPOS) {; 553 lib.Remove(idx);; 554 lib += "".so"";; 555 }; 556 dyvers = ""\\.[0-9]+\\.*[0-9]*\\.dylib"";; 557 idx = lib.Index(dyvers);; 558 if (idx != kNPOS) {; 559 lib.Remove(idx);; 560 lib += "".dylib"";; 561 }; 562 if (!gSystem->AccessPathName(lib, kReadPermission)) {; 563 if (linkedDylibs.Length()); 564 linkedDylibs += "" "";; 565 linkedDylibs += lib;; 566 }; 5",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:16165,Performance,load,loaded,16165,";; 522 if (!realpath(lib, respath)) {; 523 if (!gSystem->Getenv(""ROOTSYS"")); 524 ::SysError(""TUnixSystem::DylibAdded"", ""error getting realpath of libCore, please set ROOTSYS in the shell"");; 525 } else {; 526 TString rs = gSystem->GetDirName(respath);; 527 gSystem->Setenv(""ROOTSYS"", gSystem->GetDirName(rs.Data()).Data());; 528 }; 529 }; 530#ifdef ROOTPREFIX; 531 }; 532#endif; 533 ; 534 // when libSystem.B.dylib is loaded we have finished loading all dylibs; 535 // explicitly linked against the executable. Additional dylibs; 536 // come when they are explicitly linked against loaded so's, currently; 537 // we are not interested in these; 538 if (lib.EndsWith(""/libSystem.B.dylib"")) {; 539 gotFirstSo = kTRUE;; 540 if (linkedDylibs.IsNull()) {; 541 // TSystem::GetLibraries() assumes that an empty GetLinkedLibraries(); 542 // means failure to extract the linked libraries. Signal ""we did; 543 // manage, but it's empty"" by returning a single space.; 544 linkedDylibs = ' ';; 545 }; 546 }; 547 ; 548 // add all libs loaded before libSystem.B.dylib; 549 if (!gotFirstSo && (lib.EndsWith("".dylib"") || lib.EndsWith("".so""))) {; 550 sovers = ""\\.[0-9]+\\.*[0-9]*\\.so"";; 551 Ssiz_t idx = lib.Index(sovers);; 552 if (idx != kNPOS) {; 553 lib.Remove(idx);; 554 lib += "".so"";; 555 }; 556 dyvers = ""\\.[0-9]+\\.*[0-9]*\\.dylib"";; 557 idx = lib.Index(dyvers);; 558 if (idx != kNPOS) {; 559 lib.Remove(idx);; 560 lib += "".dylib"";; 561 }; 562 if (!gSystem->AccessPathName(lib, kReadPermission)) {; 563 if (linkedDylibs.Length()); 564 linkedDylibs += "" "";; 565 linkedDylibs += lib;; 566 }; 567 }; 568}; 569#endif; 570 ; 571ClassImp(TUnixSystem);; 572 ; 573////////////////////////////////////////////////////////////////////////////////; 574 ; 575TUnixSystem::TUnixSystem() : TSystem(""Unix"", ""Unix System""); 576{ }; 577 ; 578////////////////////////////////////////////////////////////////////////////////; 579/// Reset to original state.; 580 ; 581TUnixSystem::~TUnixSystem(); 582{; 583 UnixResetSignals();;",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:18226,Performance,load,loading,18226,"//////////////////////////////////////////////; 579/// Reset to original state.; 580 ; 581TUnixSystem::~TUnixSystem(); 582{; 583 UnixResetSignals();; 584 ; 585 delete fReadmask;; 586 delete fWritemask;; 587 delete fReadready;; 588 delete fWriteready;; 589 delete fSignals;; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////; 593/// Initialize Unix system interface.; 594 ; 595Bool_t TUnixSystem::Init(); 596{; 597 if (TSystem::Init()); 598 return kTRUE;; 599 ; 600 fReadmask = new TFdSet;; 601 fWritemask = new TFdSet;; 602 fReadready = new TFdSet;; 603 fWriteready = new TFdSet;; 604 fSignals = new TFdSet;; 605 ; 606 //--- install default handlers; 607 UnixSignal(kSigChild, SigHandler);; 608 UnixSignal(kSigBus, SigHandler);; 609 UnixSignal(kSigSegmentationViolation, SigHandler);; 610 UnixSignal(kSigIllegalInstruction, SigHandler);; 611 UnixSignal(kSigAbort, SigHandler);; 612 UnixSignal(kSigSystem, SigHandler);; 613 UnixSignal(kSigAlarm, SigHandler);; 614 UnixSignal(kSigUrgent, SigHandler);; 615 UnixSignal(kSigFloatingException, SigHandler);; 616 UnixSignal(kSigWindowChanged, SigHandler);; 617 UnixSignal(kSigUser2, SigHandler);; 618 ; 619#if defined(R__MACOSX); 620 // trap loading of all dylibs to register dylib name,; 621 // sets also ROOTSYS if built without ROOTPREFIX; 622 _dyld_register_func_for_add_image(DylibAdded);; 623#elif defined(HAVE_DLADDR); 624 SetRootSys();; 625#endif; 626 ; 627 // This is a fallback in case TROOT::GetRootSys() can't determine ROOTSYS; 628 gRootDir = ROOT::FoundationUtils::GetFallbackRootSys().c_str();; 629 ; 630 return kFALSE;; 631}; 632 ; 633//---- Misc --------------------------------------------------------------------; 634 ; 635////////////////////////////////////////////////////////////////////////////////; 636/// Set the application name (from command line, argv[0]) and copy it in; 637/// gProgName. Copy the application pathname in gProgPath.; 638/// If name is 0 let the system set the actu",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:43653,Performance,cache,cache,43653,"y(void *dirp); 1405{; 1406 TSystem *helper = FindHelper(nullptr, dirp);; 1407 if (helper) {; 1408 helper->FreeDirectory(dirp);; 1409 return;; 1410 }; 1411 ; 1412 if (dirp); 1413 ::closedir((DIR*)dirp);; 1414}; 1415 ; 1416////////////////////////////////////////////////////////////////////////////////; 1417/// Get next Unix file system directory entry. Returns 0 if no more entries.; 1418 ; 1419const char *TUnixSystem::GetDirEntry(void *dirp); 1420{; 1421 TSystem *helper = FindHelper(nullptr, dirp);; 1422 if (helper); 1423 return helper->GetDirEntry(dirp);; 1424 ; 1425 if (dirp); 1426 return UnixGetdirentry(dirp);; 1427 ; 1428 return nullptr;; 1429}; 1430 ; 1431////////////////////////////////////////////////////////////////////////////////; 1432/// Change directory. Returns kTRUE in case of success, kFALSE otherwise.; 1433 ; 1434Bool_t TUnixSystem::ChangeDirectory(const char *path); 1435{; 1436 Bool_t ret = (Bool_t) (::chdir(path) == 0);; 1437 if (fWdpath != """"); 1438 fWdpath = """"; // invalidate path cache; 1439 return ret;; 1440}; 1441 ; 1442////////////////////////////////////////////////////////////////////////////////; 1443/// Return working directory.; 1444 ; 1445const char *TUnixSystem::WorkingDirectory(); 1446{; 1447 // don't use cache as user can call chdir() directly somewhere else; 1448 //if (fWdpath != """"); 1449 // return fWdpath.Data();; 1450 ; 1451 R__LOCKGUARD2(gSystemMutex);; 1452 ; 1453 static char cwd[kMAXPATHLEN];; 1454 FillWithCwd(cwd);; 1455 fWdpath = cwd;; 1456 ; 1457 return fWdpath.Data();; 1458}; 1459 ; 1460//////////////////////////////////////////////////////////////////////////////; 1461/// Return working directory.; 1462 ; 1463std::string TUnixSystem::GetWorkingDirectory() const; 1464{; 1465 char cwd[kMAXPATHLEN];; 1466 FillWithCwd(cwd);; 1467 return std::string(cwd);; 1468}; 1469 ; 1470//////////////////////////////////////////////////////////////////////////////; 1471/// Fill buffer with current working directory.; 1472 ; 1473void TUnixSy",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:43894,Performance,cache,cache,43894,"//////////////////////////////////; 1417/// Get next Unix file system directory entry. Returns 0 if no more entries.; 1418 ; 1419const char *TUnixSystem::GetDirEntry(void *dirp); 1420{; 1421 TSystem *helper = FindHelper(nullptr, dirp);; 1422 if (helper); 1423 return helper->GetDirEntry(dirp);; 1424 ; 1425 if (dirp); 1426 return UnixGetdirentry(dirp);; 1427 ; 1428 return nullptr;; 1429}; 1430 ; 1431////////////////////////////////////////////////////////////////////////////////; 1432/// Change directory. Returns kTRUE in case of success, kFALSE otherwise.; 1433 ; 1434Bool_t TUnixSystem::ChangeDirectory(const char *path); 1435{; 1436 Bool_t ret = (Bool_t) (::chdir(path) == 0);; 1437 if (fWdpath != """"); 1438 fWdpath = """"; // invalidate path cache; 1439 return ret;; 1440}; 1441 ; 1442////////////////////////////////////////////////////////////////////////////////; 1443/// Return working directory.; 1444 ; 1445const char *TUnixSystem::WorkingDirectory(); 1446{; 1447 // don't use cache as user can call chdir() directly somewhere else; 1448 //if (fWdpath != """"); 1449 // return fWdpath.Data();; 1450 ; 1451 R__LOCKGUARD2(gSystemMutex);; 1452 ; 1453 static char cwd[kMAXPATHLEN];; 1454 FillWithCwd(cwd);; 1455 fWdpath = cwd;; 1456 ; 1457 return fWdpath.Data();; 1458}; 1459 ; 1460//////////////////////////////////////////////////////////////////////////////; 1461/// Return working directory.; 1462 ; 1463std::string TUnixSystem::GetWorkingDirectory() const; 1464{; 1465 char cwd[kMAXPATHLEN];; 1466 FillWithCwd(cwd);; 1467 return std::string(cwd);; 1468}; 1469 ; 1470//////////////////////////////////////////////////////////////////////////////; 1471/// Fill buffer with current working directory.; 1472 ; 1473void TUnixSystem::FillWithCwd(char *cwd) const; 1474{; 1475 if (::getcwd(cwd, kMAXPATHLEN) == nullptr) {; 1476 Error(""WorkingDirectory"", ""getcwd() failed"");; 1477 }; 1478}; 1479 ; 1480////////////////////////////////////////////////////////////////////////////////; 1481/// Return",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:80926,Performance,load,loader,80926,"(fd, buffer, ::strlen(buffer)) < 0); 2555 Warning(""StackTrace"", ""problems writing buffer (errno: %d)"", TSystem::GetErrno());; 2556 }; 2557 ; 2558 if (demangle) {; 2559 TString tmpf2 = ""gdb-backtrace"";; 2560 FILE *f = TempFileName(tmpf2);; 2561 if (f) fclose(f);; 2562 file1.close();; 2563 snprintf(buffer, sizeof(buffer), ""%s %s < %s > %s"", filter, cppfiltarg, tmpf1.Data(), tmpf2.Data());; 2564 Exec(buffer);; 2565 std::ifstream file2(tmpf2);; 2566 TString line;; 2567 while (file2) {; 2568 line = """";; 2569 line.ReadString(file2);; 2570 if (write(fd, line.Data(), line.Length()) < 0); 2571 Warning(""StackTrace"", ""problems writing line (errno: %d)"", TSystem::GetErrno());; 2572 }; 2573 file2.close();; 2574 Unlink(tmpf1);; 2575 Unlink(tmpf2);; 2576 }; 2577 ; 2578 delete [] addr2line;; 2579 }; 2580 delete [] filter;; 2581#elif defined(HAVE_EXCPT_H) && defined(HAVE_PDSC_H) && \; 2582 defined(HAVE_RLD_INTERFACE_H) // tru64; 2583 // Tru64 stack walk. Uses the exception handling library and the; 2584 // run-time linker's core functions (loader(5)). FIXME: Tru64; 2585 // should have _RLD_DLADDR like IRIX below. Verify and update.; 2586 ; 2587 char buffer [128];; 2588 sigcontext context;; 2589 int rc = 0;; 2590 ; 2591 exc_capture_context (&context);; 2592 while (!rc && context.sc_pc) {; 2593 // FIXME: Elf32?; 2594 pdsc_crd *func, *base, *crd; 2595 = exc_remote_lookup_function_entry(0, 0, context.sc_pc, 0, &func, &base);; 2596 Elf32_Addr addr = PDSC_CRD_BEGIN_ADDRESS(base, func);; 2597 // const char *name = _rld_address_to_name(addr);; 2598 const char *name = ""<unknown function>"";; 2599 sprintf(buffer, "" 0x%012lx %.200s + 0x%lx\n"",; 2600 context.sc_pc, name, context.sc_pc - addr);; 2601 write(fd, buffer, ::strlen(buffer));; 2602 rc = exc_virtual_unwind(0, &context);; 2603 }; 2604#endif; 2605#else //R__MACOSX; 2606 macosx_backtrace();; 2607#endif //R__MACOSX; 2608}; 2609 ; 2610//---- System Logging ----------------------------------------------------------; 2611 ; 2612////////////////",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:88642,Performance,load,loading,88642,"; 2770 SysError(""RedirectOutput"",; 2771 ""problems closing temporary 'out' descriptor %d (errno: %d)"",; 2772 TSystem::GetErrno(), xh->fStdOutDup);; 2773 rc = -1;; 2774 }; 2775 }; 2776 fflush(stderr);; 2777 if (!(xh->fStdErrTty.IsNull())) {; 2778 if (freopen(xh->fStdErrTty.Data(), ""a"", stderr) == nullptr) {; 2779 SysError(""RedirectOutput"", ""could not restore stderr (errno: %d)"", TSystem::GetErrno());; 2780 rc = -1;; 2781 }; 2782 xh->fStdErrTty = """";; 2783 } else {; 2784 if (close(STDERR_FILENO) != 0) {; 2785 SysError(""RedirectOutput"",; 2786 ""problems closing STDERR_FILENO (%d) before 'dup2' (errno: %d)"",; 2787 STDERR_FILENO, TSystem::GetErrno());; 2788 rc = -1;; 2789 }; 2790 if (dup2(xh->fStdErrDup, STDERR_FILENO) < 0) {; 2791 SysError(""RedirectOutput"", ""could not restore stderr (back to original redirected""; 2792 "" file) (errno: %d)"", TSystem::GetErrno());; 2793 rc = -1;; 2794 }; 2795 if (close(xh->fStdErrDup) != 0) {; 2796 SysError(""RedirectOutput"",; 2797 ""problems closing temporary 'err' descriptor %d (errno: %d)"",; 2798 TSystem::GetErrno(), xh->fStdErrDup);; 2799 rc = -1;; 2800 }; 2801 }; 2802 // Reset the static instance, if using that; 2803 if (xh == &loch); 2804 xh->Reset();; 2805 }; 2806 return rc;; 2807}; 2808 ; 2809//---- dynamic loading and linking ---------------------------------------------; 2810 ; 2811////////////////////////////////////////////////////////////////////////////////; 2812///dynamic linking of module; 2813 ; 2814Func_t TUnixSystem::DynFindSymbol(const char * /*module*/, const char *entry); 2815{; 2816 return TSystem::DynFindSymbol(""*"", entry);; 2817}; 2818 ; 2819////////////////////////////////////////////////////////////////////////////////; 2820/// Load a shared library. Returns 0 on successful loading, 1 in; 2821/// case lib was already loaded and -1 in case lib does not exist; 2822/// or in case of error.; 2823 ; 2824int TUnixSystem::Load(const char *module, const char *entry, Bool_t system); 2825{; 2826 return TSystem::Load(module, en",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:89137,Performance,load,loading,89137,"original redirected""; 2792 "" file) (errno: %d)"", TSystem::GetErrno());; 2793 rc = -1;; 2794 }; 2795 if (close(xh->fStdErrDup) != 0) {; 2796 SysError(""RedirectOutput"",; 2797 ""problems closing temporary 'err' descriptor %d (errno: %d)"",; 2798 TSystem::GetErrno(), xh->fStdErrDup);; 2799 rc = -1;; 2800 }; 2801 }; 2802 // Reset the static instance, if using that; 2803 if (xh == &loch); 2804 xh->Reset();; 2805 }; 2806 return rc;; 2807}; 2808 ; 2809//---- dynamic loading and linking ---------------------------------------------; 2810 ; 2811////////////////////////////////////////////////////////////////////////////////; 2812///dynamic linking of module; 2813 ; 2814Func_t TUnixSystem::DynFindSymbol(const char * /*module*/, const char *entry); 2815{; 2816 return TSystem::DynFindSymbol(""*"", entry);; 2817}; 2818 ; 2819////////////////////////////////////////////////////////////////////////////////; 2820/// Load a shared library. Returns 0 on successful loading, 1 in; 2821/// case lib was already loaded and -1 in case lib does not exist; 2822/// or in case of error.; 2823 ; 2824int TUnixSystem::Load(const char *module, const char *entry, Bool_t system); 2825{; 2826 return TSystem::Load(module, entry, system);; 2827}; 2828 ; 2829////////////////////////////////////////////////////////////////////////////////; 2830/// Unload a shared library.; 2831 ; 2832void TUnixSystem::Unload(const char *module); 2833{; 2834 if (module) { TSystem::Unload(module); }; 2835}; 2836 ; 2837////////////////////////////////////////////////////////////////////////////////; 2838/// List symbols in a shared library.; 2839 ; 2840void TUnixSystem::ListSymbols(const char * /*module*/, const char * /*regexp*/); 2841{; 2842 Error(""ListSymbols"", ""not yet implemented"");; 2843}; 2844 ; 2845////////////////////////////////////////////////////////////////////////////////; 2846/// List all loaded shared libraries.; 2847 ; 2848void TUnixSystem::ListLibraries(const char *regexp); 2849{; 2850 TSystem::ListLibraries(reg",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:89181,Performance,load,loaded,89181,"original redirected""; 2792 "" file) (errno: %d)"", TSystem::GetErrno());; 2793 rc = -1;; 2794 }; 2795 if (close(xh->fStdErrDup) != 0) {; 2796 SysError(""RedirectOutput"",; 2797 ""problems closing temporary 'err' descriptor %d (errno: %d)"",; 2798 TSystem::GetErrno(), xh->fStdErrDup);; 2799 rc = -1;; 2800 }; 2801 }; 2802 // Reset the static instance, if using that; 2803 if (xh == &loch); 2804 xh->Reset();; 2805 }; 2806 return rc;; 2807}; 2808 ; 2809//---- dynamic loading and linking ---------------------------------------------; 2810 ; 2811////////////////////////////////////////////////////////////////////////////////; 2812///dynamic linking of module; 2813 ; 2814Func_t TUnixSystem::DynFindSymbol(const char * /*module*/, const char *entry); 2815{; 2816 return TSystem::DynFindSymbol(""*"", entry);; 2817}; 2818 ; 2819////////////////////////////////////////////////////////////////////////////////; 2820/// Load a shared library. Returns 0 on successful loading, 1 in; 2821/// case lib was already loaded and -1 in case lib does not exist; 2822/// or in case of error.; 2823 ; 2824int TUnixSystem::Load(const char *module, const char *entry, Bool_t system); 2825{; 2826 return TSystem::Load(module, entry, system);; 2827}; 2828 ; 2829////////////////////////////////////////////////////////////////////////////////; 2830/// Unload a shared library.; 2831 ; 2832void TUnixSystem::Unload(const char *module); 2833{; 2834 if (module) { TSystem::Unload(module); }; 2835}; 2836 ; 2837////////////////////////////////////////////////////////////////////////////////; 2838/// List symbols in a shared library.; 2839 ; 2840void TUnixSystem::ListSymbols(const char * /*module*/, const char * /*regexp*/); 2841{; 2842 Error(""ListSymbols"", ""not yet implemented"");; 2843}; 2844 ; 2845////////////////////////////////////////////////////////////////////////////////; 2846/// List all loaded shared libraries.; 2847 ; 2848void TUnixSystem::ListLibraries(const char *regexp); 2849{; 2850 TSystem::ListLibraries(reg",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:90054,Performance,load,loaded,90054,"; 2816 return TSystem::DynFindSymbol(""*"", entry);; 2817}; 2818 ; 2819////////////////////////////////////////////////////////////////////////////////; 2820/// Load a shared library. Returns 0 on successful loading, 1 in; 2821/// case lib was already loaded and -1 in case lib does not exist; 2822/// or in case of error.; 2823 ; 2824int TUnixSystem::Load(const char *module, const char *entry, Bool_t system); 2825{; 2826 return TSystem::Load(module, entry, system);; 2827}; 2828 ; 2829////////////////////////////////////////////////////////////////////////////////; 2830/// Unload a shared library.; 2831 ; 2832void TUnixSystem::Unload(const char *module); 2833{; 2834 if (module) { TSystem::Unload(module); }; 2835}; 2836 ; 2837////////////////////////////////////////////////////////////////////////////////; 2838/// List symbols in a shared library.; 2839 ; 2840void TUnixSystem::ListSymbols(const char * /*module*/, const char * /*regexp*/); 2841{; 2842 Error(""ListSymbols"", ""not yet implemented"");; 2843}; 2844 ; 2845////////////////////////////////////////////////////////////////////////////////; 2846/// List all loaded shared libraries.; 2847 ; 2848void TUnixSystem::ListLibraries(const char *regexp); 2849{; 2850 TSystem::ListLibraries(regexp);; 2851}; 2852 ; 2853////////////////////////////////////////////////////////////////////////////////; 2854/// Get list of shared libraries loaded at the start of the executable.; 2855/// Returns 0 in case list cannot be obtained or in case of error.; 2856 ; 2857const char *TUnixSystem::GetLinkedLibraries(); 2858{; 2859 static TString linkedLibs;; 2860 static Bool_t once = kFALSE;; 2861 ; 2862 R__LOCKGUARD2(gSystemMutex);; 2863 ; 2864 if (!linkedLibs.IsNull()); 2865 return linkedLibs;; 2866 ; 2867 if (once); 2868 return nullptr;; 2869 ; 2870#if !defined(R__MACOSX); 2871 const char *exe = GetExePath();; 2872 if (!exe || !*exe); 2873 return nullptr;; 2874#endif; 2875 ; 2876#if defined(R__MACOSX); 2877 DylibAdded(0, 0);; 2878 linkedLibs = ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:90326,Performance,load,loaded,90326,"; 2822/// or in case of error.; 2823 ; 2824int TUnixSystem::Load(const char *module, const char *entry, Bool_t system); 2825{; 2826 return TSystem::Load(module, entry, system);; 2827}; 2828 ; 2829////////////////////////////////////////////////////////////////////////////////; 2830/// Unload a shared library.; 2831 ; 2832void TUnixSystem::Unload(const char *module); 2833{; 2834 if (module) { TSystem::Unload(module); }; 2835}; 2836 ; 2837////////////////////////////////////////////////////////////////////////////////; 2838/// List symbols in a shared library.; 2839 ; 2840void TUnixSystem::ListSymbols(const char * /*module*/, const char * /*regexp*/); 2841{; 2842 Error(""ListSymbols"", ""not yet implemented"");; 2843}; 2844 ; 2845////////////////////////////////////////////////////////////////////////////////; 2846/// List all loaded shared libraries.; 2847 ; 2848void TUnixSystem::ListLibraries(const char *regexp); 2849{; 2850 TSystem::ListLibraries(regexp);; 2851}; 2852 ; 2853////////////////////////////////////////////////////////////////////////////////; 2854/// Get list of shared libraries loaded at the start of the executable.; 2855/// Returns 0 in case list cannot be obtained or in case of error.; 2856 ; 2857const char *TUnixSystem::GetLinkedLibraries(); 2858{; 2859 static TString linkedLibs;; 2860 static Bool_t once = kFALSE;; 2861 ; 2862 R__LOCKGUARD2(gSystemMutex);; 2863 ; 2864 if (!linkedLibs.IsNull()); 2865 return linkedLibs;; 2866 ; 2867 if (once); 2868 return nullptr;; 2869 ; 2870#if !defined(R__MACOSX); 2871 const char *exe = GetExePath();; 2872 if (!exe || !*exe); 2873 return nullptr;; 2874#endif; 2875 ; 2876#if defined(R__MACOSX); 2877 DylibAdded(0, 0);; 2878 linkedLibs = gLinkedDylibs;; 2879#if 0; 2880 FILE *p = OpenPipe(TString::Format(""otool -L %s"", exe), ""r"");; 2881 TString otool;; 2882 while (otool.Gets(p)) {; 2883 TString delim("" \t"");; 2884 TObjArray *tok = otool.Tokenize(delim);; 2885 TString dylib = ((TObjString*)tok->At(0))->String();; 2886 if (d",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:157023,Performance,load,load,157023,"4850 ; 4851static void GetDarwinSysInfo(SysInfo_t *sysinfo); 4852{; 4853 FILE *p = gSystem->OpenPipe(""sysctl -n kern.ostype hw.model hw.ncpu hw.cpufrequency ""; 4854 ""hw.busfrequency hw.l2cachesize hw.memsize"", ""r"");; 4855 TString s;; 4856 s.Gets(p);; 4857 sysinfo->fOS = s;; 4858 s.Gets(p);; 4859 sysinfo->fModel = s;; 4860 s.Gets(p);; 4861 sysinfo->fCpus = s.Atoi();; 4862 s.Gets(p);; 4863 Long64_t t = s.Atoll();; 4864 sysinfo->fCpuSpeed = Int_t(t / 1000000);; 4865 s.Gets(p);; 4866 t = s.Atoll();; 4867 sysinfo->fBusSpeed = Int_t(t / 1000000);; 4868 s.Gets(p);; 4869 sysinfo->fL2Cache = s.Atoi() / 1024;; 4870 s.Gets(p);; 4871 t = s.Atoll();; 4872 sysinfo->fPhysRam = Int_t(t / 1024 / 1024);; 4873 gSystem->ClosePipe(p);; 4874 p = gSystem->OpenPipe(""hostinfo"", ""r"");; 4875 while (s.Gets(p)) {; 4876 if (s.BeginsWith(""Processor type: "")) {; 4877 TPRegexp(""Processor type: ([^ ]+).*"").Substitute(s, ""$1"");; 4878 sysinfo->fCpuType = s;; 4879 }; 4880 }; 4881 gSystem->ClosePipe(p);; 4882}; 4883 ; 4884////////////////////////////////////////////////////////////////////////////////; 4885/// Get CPU load on Mac OS X.; 4886 ; 4887static void ReadDarwinCpu(long *ticks); 4888{; 4889 mach_msg_type_number_t count;; 4890 kern_return_t kr;; 4891 host_cpu_load_info_data_t cpu;; 4892 ; 4893 ticks[0] = ticks[1] = ticks[2] = ticks[3] = 0;; 4894 ; 4895 count = HOST_CPU_LOAD_INFO_COUNT;; 4896 kr = host_statistics(mach_host_self(), HOST_CPU_LOAD_INFO, (host_info_t)&cpu, &count);; 4897 if (kr != KERN_SUCCESS) {; 4898 ::Error(""TUnixSystem::ReadDarwinCpu"", ""host_statistics: %s"", mach_error_string(kr));; 4899 } else {; 4900 ticks[0] = cpu.cpu_ticks[CPU_STATE_USER];; 4901 ticks[1] = cpu.cpu_ticks[CPU_STATE_SYSTEM];; 4902 ticks[2] = cpu.cpu_ticks[CPU_STATE_IDLE];; 4903 ticks[3] = cpu.cpu_ticks[CPU_STATE_NICE];; 4904 }; 4905}; 4906 ; 4907////////////////////////////////////////////////////////////////////////////////; 4908/// Get CPU stat for Mac OS X. Use sampleTime to set the interval over which; 4909///",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:157935,Performance,load,load,157935,"////////////////////////////////////////////////////////////////////////////////; 4885/// Get CPU load on Mac OS X.; 4886 ; 4887static void ReadDarwinCpu(long *ticks); 4888{; 4889 mach_msg_type_number_t count;; 4890 kern_return_t kr;; 4891 host_cpu_load_info_data_t cpu;; 4892 ; 4893 ticks[0] = ticks[1] = ticks[2] = ticks[3] = 0;; 4894 ; 4895 count = HOST_CPU_LOAD_INFO_COUNT;; 4896 kr = host_statistics(mach_host_self(), HOST_CPU_LOAD_INFO, (host_info_t)&cpu, &count);; 4897 if (kr != KERN_SUCCESS) {; 4898 ::Error(""TUnixSystem::ReadDarwinCpu"", ""host_statistics: %s"", mach_error_string(kr));; 4899 } else {; 4900 ticks[0] = cpu.cpu_ticks[CPU_STATE_USER];; 4901 ticks[1] = cpu.cpu_ticks[CPU_STATE_SYSTEM];; 4902 ticks[2] = cpu.cpu_ticks[CPU_STATE_IDLE];; 4903 ticks[3] = cpu.cpu_ticks[CPU_STATE_NICE];; 4904 }; 4905}; 4906 ; 4907////////////////////////////////////////////////////////////////////////////////; 4908/// Get CPU stat for Mac OS X. Use sampleTime to set the interval over which; 4909/// the CPU load will be measured, in ms (default 1000).; 4910 ; 4911static void GetDarwinCpuInfo(CpuInfo_t *cpuinfo, Int_t sampleTime); 4912{; 4913 Double_t avg[3];; 4914 if (getloadavg(avg, sizeof(avg)) < 0) {; 4915 ::Error(""TUnixSystem::GetDarwinCpuInfo"", ""getloadavg failed"");; 4916 } else {; 4917 cpuinfo->fLoad1m = (Float_t)avg[0];; 4918 cpuinfo->fLoad5m = (Float_t)avg[1];; 4919 cpuinfo->fLoad15m = (Float_t)avg[2];; 4920 }; 4921 ; 4922 Long_t cpu_ticks1[4], cpu_ticks2[4];; 4923 ReadDarwinCpu(cpu_ticks1);; 4924 gSystem->Sleep(sampleTime);; 4925 ReadDarwinCpu(cpu_ticks2);; 4926 ; 4927 Long_t userticks = (cpu_ticks2[0] + cpu_ticks2[3]) -; 4928 (cpu_ticks1[0] + cpu_ticks1[3]);; 4929 Long_t systicks = cpu_ticks2[1] - cpu_ticks1[1];; 4930 Long_t idleticks = cpu_ticks2[2] - cpu_ticks1[2];; 4931 if (userticks < 0) userticks = 0;; 4932 if (systicks < 0) systicks = 0;; 4933 if (idleticks < 0) idleticks = 0;; 4934 Long_t totalticks = userticks + systicks + idleticks;; 4935 if (totalticks) {; 49",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:165805,Performance,cache,cache,165805,"lse {; 5087 vprvt += info.private_pages_resident * getpagesize();; 5088 }; 5089 break;; 5090 }; 5091 case SM_PRIVATE: {; 5092 vprvt += size;; 5093 break;; 5094 }; 5095 default:; 5096 break;; 5097 }; 5098 }; 5099 ; 5100 procinfo->fMemResident = (Long_t)(rsize / 1024);; 5101 procinfo->fMemVirtual = (Long_t)(vprvt / 1024);; 5102 }; 5103}; 5104#endif; 5105 ; 5106#if defined(R__LINUX); 5107////////////////////////////////////////////////////////////////////////////////; 5108/// Get system info for Linux. Only fBusSpeed is not set.; 5109 ; 5110static void GetLinuxSysInfo(SysInfo_t *sysinfo); 5111{; 5112 TString s;; 5113 FILE *f = fopen(""/proc/cpuinfo"", ""r"");; 5114 if (f) {; 5115 while (s.Gets(f)) {; 5116 if (s.BeginsWith(""model name"")) {; 5117 TPRegexp(""^.+: *(.*$)"").Substitute(s, ""$1"");; 5118 sysinfo->fModel = s;; 5119 }; 5120 if (s.BeginsWith(""cpu MHz"")) {; 5121 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5122 sysinfo->fCpuSpeed = s.Atoi();; 5123 }; 5124 if (s.BeginsWith(""cache size"")) {; 5125 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5126 sysinfo->fL2Cache = s.Atoi();; 5127 }; 5128 if (s.BeginsWith(""processor"")) {; 5129 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5130 sysinfo->fCpus = s.Atoi();; 5131 sysinfo->fCpus++;; 5132 }; 5133 }; 5134 fclose(f);; 5135 }; 5136 ; 5137 f = fopen(""/proc/meminfo"", ""r"");; 5138 if (f) {; 5139 while (s.Gets(f)) {; 5140 if (s.BeginsWith(""MemTotal"")) {; 5141 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5142 sysinfo->fPhysRam = (s.Atoi() / 1024);; 5143 break;; 5144 }; 5145 }; 5146 fclose(f);; 5147 }; 5148 ; 5149 f = gSystem->OpenPipe(""uname -s -p"", ""r"");; 5150 if (f) {; 5151 s.Gets(f);; 5152 Ssiz_t from = 0;; 5153 s.Tokenize(sysinfo->fOS, from);; 5154 s.Tokenize(sysinfo->fCpuType, from);; 5155 gSystem->ClosePipe(f);; 5156 }; 5157}; 5158 ; 5159////////////////////////////////////////////////////////////////////////////////; 5160/// Get CPU load on Linux.; 5161 ; 5162static void ReadLinuxCpu(long *ticks); 5163{; 5164 t",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:166737,Performance,load,load,166737," if (s.BeginsWith(""cpu MHz"")) {; 5121 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5122 sysinfo->fCpuSpeed = s.Atoi();; 5123 }; 5124 if (s.BeginsWith(""cache size"")) {; 5125 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5126 sysinfo->fL2Cache = s.Atoi();; 5127 }; 5128 if (s.BeginsWith(""processor"")) {; 5129 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5130 sysinfo->fCpus = s.Atoi();; 5131 sysinfo->fCpus++;; 5132 }; 5133 }; 5134 fclose(f);; 5135 }; 5136 ; 5137 f = fopen(""/proc/meminfo"", ""r"");; 5138 if (f) {; 5139 while (s.Gets(f)) {; 5140 if (s.BeginsWith(""MemTotal"")) {; 5141 TPRegexp(""^.+: *([^ ]+).*"").Substitute(s, ""$1"");; 5142 sysinfo->fPhysRam = (s.Atoi() / 1024);; 5143 break;; 5144 }; 5145 }; 5146 fclose(f);; 5147 }; 5148 ; 5149 f = gSystem->OpenPipe(""uname -s -p"", ""r"");; 5150 if (f) {; 5151 s.Gets(f);; 5152 Ssiz_t from = 0;; 5153 s.Tokenize(sysinfo->fOS, from);; 5154 s.Tokenize(sysinfo->fCpuType, from);; 5155 gSystem->ClosePipe(f);; 5156 }; 5157}; 5158 ; 5159////////////////////////////////////////////////////////////////////////////////; 5160/// Get CPU load on Linux.; 5161 ; 5162static void ReadLinuxCpu(long *ticks); 5163{; 5164 ticks[0] = ticks[1] = ticks[2] = ticks[3] = 0;; 5165 ; 5166 TString s;; 5167 FILE *f = fopen(""/proc/stat"", ""r"");; 5168 if (!f) return;; 5169 s.Gets(f);; 5170 // user, user nice, sys, idle; 5171 sscanf(s.Data(), ""%*s %ld %ld %ld %ld"", &ticks[0], &ticks[3], &ticks[1], &ticks[2]);; 5172 fclose(f);; 5173}; 5174 ; 5175////////////////////////////////////////////////////////////////////////////////; 5176/// Get CPU stat for Linux. Use sampleTime to set the interval over which; 5177/// the CPU load will be measured, in ms (default 1000).; 5178 ; 5179static void GetLinuxCpuInfo(CpuInfo_t *cpuinfo, Int_t sampleTime); 5180{; 5181 Double_t avg[3] = { -1., -1., -1. };; 5182#ifndef R__WINGCC; 5183 if (getloadavg(avg, sizeof(avg)) < 0) {; 5184 ::Error(""TUnixSystem::GetLinuxCpuInfo"", ""getloadavg failed"");; 5185 } else; 5186#endif; 5187 {;",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:167307,Performance,load,load,167307," sysinfo->fPhysRam = (s.Atoi() / 1024);; 5143 break;; 5144 }; 5145 }; 5146 fclose(f);; 5147 }; 5148 ; 5149 f = gSystem->OpenPipe(""uname -s -p"", ""r"");; 5150 if (f) {; 5151 s.Gets(f);; 5152 Ssiz_t from = 0;; 5153 s.Tokenize(sysinfo->fOS, from);; 5154 s.Tokenize(sysinfo->fCpuType, from);; 5155 gSystem->ClosePipe(f);; 5156 }; 5157}; 5158 ; 5159////////////////////////////////////////////////////////////////////////////////; 5160/// Get CPU load on Linux.; 5161 ; 5162static void ReadLinuxCpu(long *ticks); 5163{; 5164 ticks[0] = ticks[1] = ticks[2] = ticks[3] = 0;; 5165 ; 5166 TString s;; 5167 FILE *f = fopen(""/proc/stat"", ""r"");; 5168 if (!f) return;; 5169 s.Gets(f);; 5170 // user, user nice, sys, idle; 5171 sscanf(s.Data(), ""%*s %ld %ld %ld %ld"", &ticks[0], &ticks[3], &ticks[1], &ticks[2]);; 5172 fclose(f);; 5173}; 5174 ; 5175////////////////////////////////////////////////////////////////////////////////; 5176/// Get CPU stat for Linux. Use sampleTime to set the interval over which; 5177/// the CPU load will be measured, in ms (default 1000).; 5178 ; 5179static void GetLinuxCpuInfo(CpuInfo_t *cpuinfo, Int_t sampleTime); 5180{; 5181 Double_t avg[3] = { -1., -1., -1. };; 5182#ifndef R__WINGCC; 5183 if (getloadavg(avg, sizeof(avg)) < 0) {; 5184 ::Error(""TUnixSystem::GetLinuxCpuInfo"", ""getloadavg failed"");; 5185 } else; 5186#endif; 5187 {; 5188 cpuinfo->fLoad1m = (Float_t)avg[0];; 5189 cpuinfo->fLoad5m = (Float_t)avg[1];; 5190 cpuinfo->fLoad15m = (Float_t)avg[2];; 5191 }; 5192 ; 5193 Long_t cpu_ticks1[4], cpu_ticks2[4];; 5194 ReadLinuxCpu(cpu_ticks1);; 5195 gSystem->Sleep(sampleTime);; 5196 ReadLinuxCpu(cpu_ticks2);; 5197 ; 5198 Long_t userticks = (cpu_ticks2[0] + cpu_ticks2[3]) -; 5199 (cpu_ticks1[0] + cpu_ticks1[3]);; 5200 Long_t systicks = cpu_ticks2[1] - cpu_ticks1[1];; 5201 Long_t idleticks = cpu_ticks2[2] - cpu_ticks1[2];; 5202 if (userticks < 0) userticks = 0;; 5203 if (systicks < 0) systicks = 0;; 5204 if (idleticks < 0) idleticks = 0;; 5205 Long_t totalticks = user",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:173235,Performance,load,load,173235,"= fopen(TString::Format(""/proc/%d/statm"", gSystem->GetPid()), ""r"");; 5302 if (f) {; 5303 s.Gets(f);; 5304 fclose(f);; 5305 Long_t total, rss;; 5306 sscanf(s.Data(), ""%ld %ld"", &total, &rss);; 5307 procinfo->fMemVirtual = total * (getpagesize() / 1024);; 5308 procinfo->fMemResident = rss * (getpagesize() / 1024);; 5309 }; 5310}; 5311#endif; 5312 ; 5313////////////////////////////////////////////////////////////////////////////////; 5314/// Returns static system info, like OS type, CPU type, number of CPUs; 5315/// RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 5316/// 0 otherwise.; 5317 ; 5318int TUnixSystem::GetSysInfo(SysInfo_t *info) const; 5319{; 5320 if (!info) return -1;; 5321 ; 5322 static SysInfo_t sysinfo;; 5323 ; 5324 if (!sysinfo.fCpus) {; 5325#if defined(R__MACOSX); 5326 GetDarwinSysInfo(&sysinfo);; 5327#elif defined(R__LINUX); 5328 GetLinuxSysInfo(&sysinfo);; 5329#elif defined(R__FBSD); 5330 GetFreeBSDSysInfo(&sysinfo);; 5331#endif; 5332 }; 5333 ; 5334 *info = sysinfo;; 5335 ; 5336 return 0;; 5337}; 5338 ; 5339////////////////////////////////////////////////////////////////////////////////; 5340/// Returns cpu load average and load info into the CpuInfo_t structure.; 5341/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 5342/// interval over which the CPU load will be measured, in ms (default 1000).; 5343 ; 5344int TUnixSystem::GetCpuInfo(CpuInfo_t *info, Int_t sampleTime) const; 5345{; 5346 if (!info) return -1;; 5347 ; 5348#if defined(R__MACOSX); 5349 GetDarwinCpuInfo(info, sampleTime);; 5350#elif defined(R__LINUX); 5351 GetLinuxCpuInfo(info, sampleTime);; 5352#elif defined(R__FBSD); 5353 GetFreeBSDCpuInfo(info, sampleTime);; 5354#endif; 5355 ; 5356 return 0;; 5357}; 5358 ; 5359////////////////////////////////////////////////////////////////////////////////; 5360/// Returns ram and swap memory usage info into the MemInfo_t structure.; 5361/// Returns -1 in case of error, 0 otherwise.; 5362 ; 5363int TUn",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:173252,Performance,load,load,173252,"= fopen(TString::Format(""/proc/%d/statm"", gSystem->GetPid()), ""r"");; 5302 if (f) {; 5303 s.Gets(f);; 5304 fclose(f);; 5305 Long_t total, rss;; 5306 sscanf(s.Data(), ""%ld %ld"", &total, &rss);; 5307 procinfo->fMemVirtual = total * (getpagesize() / 1024);; 5308 procinfo->fMemResident = rss * (getpagesize() / 1024);; 5309 }; 5310}; 5311#endif; 5312 ; 5313////////////////////////////////////////////////////////////////////////////////; 5314/// Returns static system info, like OS type, CPU type, number of CPUs; 5315/// RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 5316/// 0 otherwise.; 5317 ; 5318int TUnixSystem::GetSysInfo(SysInfo_t *info) const; 5319{; 5320 if (!info) return -1;; 5321 ; 5322 static SysInfo_t sysinfo;; 5323 ; 5324 if (!sysinfo.fCpus) {; 5325#if defined(R__MACOSX); 5326 GetDarwinSysInfo(&sysinfo);; 5327#elif defined(R__LINUX); 5328 GetLinuxSysInfo(&sysinfo);; 5329#elif defined(R__FBSD); 5330 GetFreeBSDSysInfo(&sysinfo);; 5331#endif; 5332 }; 5333 ; 5334 *info = sysinfo;; 5335 ; 5336 return 0;; 5337}; 5338 ; 5339////////////////////////////////////////////////////////////////////////////////; 5340/// Returns cpu load average and load info into the CpuInfo_t structure.; 5341/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 5342/// interval over which the CPU load will be measured, in ms (default 1000).; 5343 ; 5344int TUnixSystem::GetCpuInfo(CpuInfo_t *info, Int_t sampleTime) const; 5345{; 5346 if (!info) return -1;; 5347 ; 5348#if defined(R__MACOSX); 5349 GetDarwinCpuInfo(info, sampleTime);; 5350#elif defined(R__LINUX); 5351 GetLinuxCpuInfo(info, sampleTime);; 5352#elif defined(R__FBSD); 5353 GetFreeBSDCpuInfo(info, sampleTime);; 5354#endif; 5355 ; 5356 return 0;; 5357}; 5358 ; 5359////////////////////////////////////////////////////////////////////////////////; 5360/// Returns ram and swap memory usage info into the MemInfo_t structure.; 5361/// Returns -1 in case of error, 0 otherwise.; 5362 ; 5363int TUn",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:173406,Performance,load,load,173406,"; 5311#endif; 5312 ; 5313////////////////////////////////////////////////////////////////////////////////; 5314/// Returns static system info, like OS type, CPU type, number of CPUs; 5315/// RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 5316/// 0 otherwise.; 5317 ; 5318int TUnixSystem::GetSysInfo(SysInfo_t *info) const; 5319{; 5320 if (!info) return -1;; 5321 ; 5322 static SysInfo_t sysinfo;; 5323 ; 5324 if (!sysinfo.fCpus) {; 5325#if defined(R__MACOSX); 5326 GetDarwinSysInfo(&sysinfo);; 5327#elif defined(R__LINUX); 5328 GetLinuxSysInfo(&sysinfo);; 5329#elif defined(R__FBSD); 5330 GetFreeBSDSysInfo(&sysinfo);; 5331#endif; 5332 }; 5333 ; 5334 *info = sysinfo;; 5335 ; 5336 return 0;; 5337}; 5338 ; 5339////////////////////////////////////////////////////////////////////////////////; 5340/// Returns cpu load average and load info into the CpuInfo_t structure.; 5341/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 5342/// interval over which the CPU load will be measured, in ms (default 1000).; 5343 ; 5344int TUnixSystem::GetCpuInfo(CpuInfo_t *info, Int_t sampleTime) const; 5345{; 5346 if (!info) return -1;; 5347 ; 5348#if defined(R__MACOSX); 5349 GetDarwinCpuInfo(info, sampleTime);; 5350#elif defined(R__LINUX); 5351 GetLinuxCpuInfo(info, sampleTime);; 5352#elif defined(R__FBSD); 5353 GetFreeBSDCpuInfo(info, sampleTime);; 5354#endif; 5355 ; 5356 return 0;; 5357}; 5358 ; 5359////////////////////////////////////////////////////////////////////////////////; 5360/// Returns ram and swap memory usage info into the MemInfo_t structure.; 5361/// Returns -1 in case of error, 0 otherwise.; 5362 ; 5363int TUnixSystem::GetMemInfo(MemInfo_t *info) const; 5364{; 5365 if (!info) return -1;; 5366 ; 5367#if defined(R__MACOSX); 5368 GetDarwinMemInfo(info);; 5369#elif defined(R__LINUX); 5370 GetLinuxMemInfo(info);; 5371#endif; 5372 ; 5373 return 0;; 5374}; 5375 ; 5376////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:197276,Performance,load,loaded,197276,"ystem::FindFilevirtual const char * FindFile(const char *search, TString &file, EAccessMode mode=kFileExists)Find location of file in a search path.Definition TSystem.cxx:1538; TSystem::mkdirvirtual int mkdir(const char *name, Bool_t recursive=kFALSE)Make a file system directory.Definition TSystem.cxx:906; TSystem::MakeDirectoryvirtual int MakeDirectory(const char *name)Make a directory.Definition TSystem.cxx:827; TSystem::ExpandFileNamevirtual const char * ExpandFileName(const char *fname)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1098; TSystem::RemoveFileHandlervirtual TFileHandler * RemoveFileHandler(TFileHandler *fh)Remove a file handler from the list of file handlers.Definition TSystem.cxx:564; TSystem::fSigcntInt_t fSigcntDefinition TSystem.h:283; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::GetDirEntryvirtual const char * GetDirEntry(void *dirp)Get a directory entry. Returns 0 if no more entries.Definition TSystem.cxx:853; TSystem::Initvirtual Bool_t Init()Initialize the OS interface.Definition TSystem.cxx:183; TS",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:209286,Performance,load,loaded,209286,"n TUnixSystem.cxx:3821; TUnixSystem::GetServiceByNameint GetServiceByName(const char *service) overrideGet port # of internet service.Definition TUnixSystem.cxx:3171; TUnixSystem::FindFileconst char * FindFile(const char *search, TString &file, EAccessMode mode=kFileExists) overrideFind location of file ""wfil"" in a search path.Definition TUnixSystem.cxx:1927; TUnixSystem::SigAlarmInterruptsSyscallsvoid SigAlarmInterruptsSyscalls(Bool_t set) overrideWhen the argument is true the SIGALRM signal handler is set so that interrupted syscalls will not be ...Definition TUnixSystem.cxx:908; TUnixSystem::UnixUdpServicestatic int UnixUdpService(int port, int backlog)Open a socket, bind to it and start listening for UDP connections on the port.Definition TUnixSystem.cxx:4373; TUnixSystem::Utimeint Utime(const char *file, Long_t modtime, Long_t actime) overrideSet a files modification and access times.Definition TUnixSystem.cxx:1910; TUnixSystem::GetLinkedLibrariesconst char * GetLinkedLibraries() overrideGet list of shared libraries loaded at the start of the executable.Definition TUnixSystem.cxx:2857; TUnixSystem::GetErrorconst char * GetError() overrideReturn system error string.Definition TUnixSystem.cxx:719; TUnixSystem::GetWorkingDirectorystd::string GetWorkingDirectory() const overrideReturn working directory.Definition TUnixSystem.cxx:1463; TUnixSystem::AccessPathNameBool_t AccessPathName(const char *path, EAccessMode mode=kFileExists) overrideReturns FALSE if one can access a file using the specified access mode.Definition TUnixSystem.cxx:1579; TUnixSystem::TempFileNameFILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr) overrideCreate a secure temporary file by appending a unique 6 letter string to base.Definition TUnixSystem.cxx:1523; TUnixSystem::DispatchOneEventvoid DispatchOneEvent(Bool_t pendingOnly=kFALSE) overrideDispatch a single event.Definition TUnixSystem.cxx:1093; TUnixSystem::Chmodint Chmod(const char *file, UInt_t mode) ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:218319,Performance,load,loaded,218319,"e) overrideUnload a shared library.Definition TUnixSystem.cxx:2832; TUnixSystem::Umaskint Umask(Int_t mask) overrideSet the process file creation mode mask.Definition TUnixSystem.cxx:1901; TUnixSystem::UnixFilestatstatic int UnixFilestat(const char *path, FileStat_t &buf)Get info about a file.Definition TUnixSystem.cxx:4039; TUnixSystem::UnixRecvstatic int UnixRecv(int sock, void *buf, int len, int flag)Receive exactly length bytes into buffer.Definition TUnixSystem.cxx:4508; TUnixSystem::GetEffectiveUidInt_t GetEffectiveUid() overrideReturns the effective user id.Definition TUnixSystem.cxx:2021; TUnixSystem::FillWithCwdvoid FillWithCwd(char *cwd) constFill buffer with current working directory.Definition TUnixSystem.cxx:1473; TUnixSystem::UnixWaitchildstatic int UnixWaitchild()Wait till child is finished.Definition TUnixSystem.cxx:4130; TUnixSystem::Unlinkint Unlink(const char *name) overrideUnlink, i.e.Definition TUnixSystem.cxx:1708; TUnixSystem::ListLibrariesvoid ListLibraries(const char *regexp="""") overrideList all loaded shared libraries.Definition TUnixSystem.cxx:2848; TUnixSystem::Closelogvoid Closelog() overrideClose connection to system log daemon.Definition TUnixSystem.cxx:2663; TUnixSystem::RedirectOutputInt_t RedirectOutput(const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr) overrideRedirect standard output (stdout, stderr) to the specified file.Definition TUnixSystem.cxx:2682; TUnixSystem::Sleepvoid Sleep(UInt_t milliSec) overrideSleep milliSec milliseconds.Definition TUnixSystem.cxx:1184; TUnixSystem::ResetSignalvoid ResetSignal(ESignals sig, Bool_t reset=kTRUE) overrideIf reset is true reset the signal handler for the specified signal to the default handler,...Definition TUnixSystem.cxx:875; TUnixSystem::TempDirectoryconst char * TempDirectory() const overrideReturn a user configured or systemwide directory to create temporary files in.Definition TUnixSystem.cxx:1503; TUnixSystem::DynFindSymbolFunc_t DynFindSymbol(const char *module, ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:220010,Performance,load,load,220010," the default handler,...Definition TUnixSystem.cxx:875; TUnixSystem::TempDirectoryconst char * TempDirectory() const overrideReturn a user configured or systemwide directory to create temporary files in.Definition TUnixSystem.cxx:1503; TUnixSystem::DynFindSymbolFunc_t DynFindSymbol(const char *module, const char *entry) overridedynamic linking of moduleDefinition TUnixSystem.cxx:2814; TUnixSystem::GetDynamicPathconst char * GetDynamicPath() overrideReturn the dynamic path (used to find shared libraries).Definition TUnixSystem.cxx:4738; TUnixSystem::OpenPipeFILE * OpenPipe(const char *shellcmd, const char *mode) overrideOpen a pipe.Definition TUnixSystem.cxx:2163; TUnixSystem::FreeDirectoryvoid FreeDirectory(void *dirp) overrideClose a Unix file system directory.Definition TUnixSystem.cxx:1404; TUnixSystem::UnixResetSignalsstatic void UnixResetSignals()Restore old signal handlers.Definition TUnixSystem.cxx:3836; TUnixSystem::GetCpuInfoint GetCpuInfo(CpuInfo_t *info, Int_t sampleTime=1000) const overrideReturns cpu load average and load info into the CpuInfo_t structure.Definition TUnixSystem.cxx:5344; TUnixSystem::AddSignalHandlervoid AddSignalHandler(TSignalHandler *sh) overrideAdd a signal handler to list of system signal handlers.Definition TUnixSystem.cxx:837; TUnixSystem::UnixOpendirstatic void * UnixOpendir(const char *name)Open a directory.Definition TUnixSystem.cxx:3984; TUnixSystem::SendRawint SendRaw(int sock, const void *buffer, int length, int flag) overrideSend exactly length bytes from buffer.Definition TUnixSystem.cxx:3405; TUnixSystem::WorkingDirectoryconst char * WorkingDirectory() overrideReturn working directory.Definition TUnixSystem.cxx:1445; TUnixSystem::GetSockOptint GetSockOpt(int sock, int option, int *val) overrideGet socket option.Definition TUnixSystem.cxx:3507; TUnixSystem::FindDynamicLibraryconst char * FindDynamicLibrary(TString &lib, Bool_t quiet=kFALSE) overrideReturns the path of a shared library (searches for library in the shared l",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:220027,Performance,load,load,220027," the default handler,...Definition TUnixSystem.cxx:875; TUnixSystem::TempDirectoryconst char * TempDirectory() const overrideReturn a user configured or systemwide directory to create temporary files in.Definition TUnixSystem.cxx:1503; TUnixSystem::DynFindSymbolFunc_t DynFindSymbol(const char *module, const char *entry) overridedynamic linking of moduleDefinition TUnixSystem.cxx:2814; TUnixSystem::GetDynamicPathconst char * GetDynamicPath() overrideReturn the dynamic path (used to find shared libraries).Definition TUnixSystem.cxx:4738; TUnixSystem::OpenPipeFILE * OpenPipe(const char *shellcmd, const char *mode) overrideOpen a pipe.Definition TUnixSystem.cxx:2163; TUnixSystem::FreeDirectoryvoid FreeDirectory(void *dirp) overrideClose a Unix file system directory.Definition TUnixSystem.cxx:1404; TUnixSystem::UnixResetSignalsstatic void UnixResetSignals()Restore old signal handlers.Definition TUnixSystem.cxx:3836; TUnixSystem::GetCpuInfoint GetCpuInfo(CpuInfo_t *info, Int_t sampleTime=1000) const overrideReturns cpu load average and load info into the CpuInfo_t structure.Definition TUnixSystem.cxx:5344; TUnixSystem::AddSignalHandlervoid AddSignalHandler(TSignalHandler *sh) overrideAdd a signal handler to list of system signal handlers.Definition TUnixSystem.cxx:837; TUnixSystem::UnixOpendirstatic void * UnixOpendir(const char *name)Open a directory.Definition TUnixSystem.cxx:3984; TUnixSystem::SendRawint SendRaw(int sock, const void *buffer, int length, int flag) overrideSend exactly length bytes from buffer.Definition TUnixSystem.cxx:3405; TUnixSystem::WorkingDirectoryconst char * WorkingDirectory() overrideReturn working directory.Definition TUnixSystem.cxx:1445; TUnixSystem::GetSockOptint GetSockOpt(int sock, int option, int *val) overrideGet socket option.Definition TUnixSystem.cxx:3507; TUnixSystem::FindDynamicLibraryconst char * FindDynamicLibrary(TString &lib, Bool_t quiet=kFALSE) overrideReturns the path of a shared library (searches for library in the shared l",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:27319,Safety,timeout,timeout,27319,"restore previous behaviour.; 874 ; 875void TUnixSystem::ResetSignal(ESignals sig, Bool_t reset); 876{; 877 if (reset); 878 UnixResetSignal(sig);; 879 else; 880 UnixSignal(sig, SigHandler);; 881}; 882 ; 883////////////////////////////////////////////////////////////////////////////////; 884/// Reset signals handlers to previous behaviour.; 885 ; 886void TUnixSystem::ResetSignals(); 887{; 888 UnixResetSignals();; 889}; 890 ; 891////////////////////////////////////////////////////////////////////////////////; 892/// If ignore is true ignore the specified signal, else restore previous; 893/// behaviour.; 894 ; 895void TUnixSystem::IgnoreSignal(ESignals sig, Bool_t ignore); 896{; 897 UnixIgnoreSignal(sig, ignore);; 898}; 899 ; 900////////////////////////////////////////////////////////////////////////////////; 901/// When the argument is true the SIGALRM signal handler is set so that; 902/// interrupted syscalls will not be restarted by the kernel. This is; 903/// typically used in case one wants to put a timeout on an I/O operation.; 904/// By default interrupted syscalls will always be restarted (for all; 905/// signals). This can be controlled for each a-synchronous TTimer via; 906/// the method TTimer::SetInterruptSyscalls().; 907 ; 908void TUnixSystem::SigAlarmInterruptsSyscalls(Bool_t set); 909{; 910 UnixSigAlarmInterruptsSyscalls(set);; 911}; 912 ; 913////////////////////////////////////////////////////////////////////////////////; 914/// Return the bitmap of conditions that trigger a floating point exception.; 915 ; 916Int_t TUnixSystem::GetFPEMask(); 917{; 918 Int_t mask = 0;; 919 ; 920#if defined(R__LINUX) && !defined(__powerpc__); 921#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 922 ; 923#if __GLIBC_MINOR__>=3; 924 ; 925 Int_t oldmask = fegetexcept();; 926 ; 927#else; 928 fenv_t oldenv;; 929 fegetenv(&oldenv);; 930 fesetenv(&oldenv);; 931#if __ia64__; 932 Int_t oldmask = ~oldenv;; 933#else; 934 Int_t oldmask = ~oldenv.__control_",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:30687,Safety,avoid,avoid,30687,"oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1011 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:36592,Safety,timeout,timeout,36592,"61 if (fReadmask->IsSet(fd)) {; 1162 rc = UnixSelect(fd+1, &t, nullptr, 0);; 1163 if (rc < 0 && rc != -2) {; 1164 SysError(""DispatchOneEvent"", ""select: read error on %d"", fd);; 1165 fReadmask->Clr(fd);; 1166 }; 1167 }; 1168 if (fWritemask->IsSet(fd)) {; 1169 rc = UnixSelect(fd+1, nullptr, &t, 0);; 1170 if (rc < 0 && rc != -2) {; 1171 SysError(""DispatchOneEvent"", ""select: write error on %d"", fd);; 1172 fWritemask->Clr(fd);; 1173 }; 1174 }; 1175 t.Clr(fd);; 1176 }; 1177 }; 1178 }; 1179}; 1180 ; 1181////////////////////////////////////////////////////////////////////////////////; 1182/// Sleep milliSec milliseconds.; 1183 ; 1184void TUnixSystem::Sleep(UInt_t milliSec); 1185{; 1186 struct timeval tv;; 1187 ; 1188 tv.tv_sec = milliSec / 1000;; 1189 tv.tv_usec = (milliSec % 1000) * 1000;; 1190 ; 1191 select(0, nullptr, nullptr, nullptr, &tv);; 1192}; 1193 ; 1194////////////////////////////////////////////////////////////////////////////////; 1195/// Select on file descriptors. The timeout to is in millisec. Returns; 1196/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 1197/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 1198/// the errno has been reset and the method can be called again. Returns; 1199/// -4 in case the list did not contain any file handlers or file handlers; 1200/// with file descriptor >= 0.; 1201 ; 1202Int_t TUnixSystem::Select(TList *act, Long_t to); 1203{; 1204 Int_t rc = -4;; 1205 ; 1206 TFdSet rd, wr;; 1207 Int_t mxfd = -1;; 1208 TIter next(act);; 1209 TFileHandler *h = nullptr;; 1210 while ((h = (TFileHandler *) next())) {; 1211 Int_t fd = h->GetFd();; 1212 if (fd > -1) {; 1213 if (h->HasReadInterest()) {; 1214 rd.Set(fd);; 1215 mxfd = TMath::Max(mxfd, fd);; 1216 }; 1217 if (h->HasWriteInterest()) {; 1218 wr.Set(fd);; 1219 mxfd = TMath::Max(mxfd, fd);; 1220 }; 1221 h->ResetReadyMask();; 1222 }; 1223 }; 1224 if (mxfd > -1); 1225 rc = UnixSelect(mxfd+1, &rd, &wr, to);; 1226 ; 1227 // Set readiness bits;",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:36685,Safety,timeout,timeout,36685,"< 0 && rc != -2) {; 1164 SysError(""DispatchOneEvent"", ""select: read error on %d"", fd);; 1165 fReadmask->Clr(fd);; 1166 }; 1167 }; 1168 if (fWritemask->IsSet(fd)) {; 1169 rc = UnixSelect(fd+1, nullptr, &t, 0);; 1170 if (rc < 0 && rc != -2) {; 1171 SysError(""DispatchOneEvent"", ""select: write error on %d"", fd);; 1172 fWritemask->Clr(fd);; 1173 }; 1174 }; 1175 t.Clr(fd);; 1176 }; 1177 }; 1178 }; 1179}; 1180 ; 1181////////////////////////////////////////////////////////////////////////////////; 1182/// Sleep milliSec milliseconds.; 1183 ; 1184void TUnixSystem::Sleep(UInt_t milliSec); 1185{; 1186 struct timeval tv;; 1187 ; 1188 tv.tv_sec = milliSec / 1000;; 1189 tv.tv_usec = (milliSec % 1000) * 1000;; 1190 ; 1191 select(0, nullptr, nullptr, nullptr, &tv);; 1192}; 1193 ; 1194////////////////////////////////////////////////////////////////////////////////; 1195/// Select on file descriptors. The timeout to is in millisec. Returns; 1196/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 1197/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 1198/// the errno has been reset and the method can be called again. Returns; 1199/// -4 in case the list did not contain any file handlers or file handlers; 1200/// with file descriptor >= 0.; 1201 ; 1202Int_t TUnixSystem::Select(TList *act, Long_t to); 1203{; 1204 Int_t rc = -4;; 1205 ; 1206 TFdSet rd, wr;; 1207 Int_t mxfd = -1;; 1208 TIter next(act);; 1209 TFileHandler *h = nullptr;; 1210 while ((h = (TFileHandler *) next())) {; 1211 Int_t fd = h->GetFd();; 1212 if (fd > -1) {; 1213 if (h->HasReadInterest()) {; 1214 rd.Set(fd);; 1215 mxfd = TMath::Max(mxfd, fd);; 1216 }; 1217 if (h->HasWriteInterest()) {; 1218 wr.Set(fd);; 1219 mxfd = TMath::Max(mxfd, fd);; 1220 }; 1221 h->ResetReadyMask();; 1222 }; 1223 }; 1224 if (mxfd > -1); 1225 rc = UnixSelect(mxfd+1, &rd, &wr, to);; 1226 ; 1227 // Set readiness bits; 1228 if (rc > 0) {; 1229 next.Reset();; 1230 while ((h = (TFileHandler *) next())) {; 1",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:38036,Safety,timeout,timeout,38036,"{; 1204 Int_t rc = -4;; 1205 ; 1206 TFdSet rd, wr;; 1207 Int_t mxfd = -1;; 1208 TIter next(act);; 1209 TFileHandler *h = nullptr;; 1210 while ((h = (TFileHandler *) next())) {; 1211 Int_t fd = h->GetFd();; 1212 if (fd > -1) {; 1213 if (h->HasReadInterest()) {; 1214 rd.Set(fd);; 1215 mxfd = TMath::Max(mxfd, fd);; 1216 }; 1217 if (h->HasWriteInterest()) {; 1218 wr.Set(fd);; 1219 mxfd = TMath::Max(mxfd, fd);; 1220 }; 1221 h->ResetReadyMask();; 1222 }; 1223 }; 1224 if (mxfd > -1); 1225 rc = UnixSelect(mxfd+1, &rd, &wr, to);; 1226 ; 1227 // Set readiness bits; 1228 if (rc > 0) {; 1229 next.Reset();; 1230 while ((h = (TFileHandler *) next())) {; 1231 Int_t fd = h->GetFd();; 1232 if (rd.IsSet(fd)); 1233 h->SetReadReady();; 1234 if (wr.IsSet(fd)); 1235 h->SetWriteReady();; 1236 }; 1237 }; 1238 ; 1239 return rc;; 1240}; 1241 ; 1242////////////////////////////////////////////////////////////////////////////////; 1243/// Select on the file descriptor related to file handler h.; 1244/// The timeout to is in millisec. Returns the number of ready descriptors,; 1245/// or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; 1246/// and -3 EBADF. In case of EINTR the errno has been reset and the method; 1247/// can be called again. Returns -4 in case the file handler is 0 or does; 1248/// not have a file descriptor >= 0.; 1249 ; 1250Int_t TUnixSystem::Select(TFileHandler *h, Long_t to); 1251{; 1252 Int_t rc = -4;; 1253 ; 1254 TFdSet rd, wr;; 1255 Int_t mxfd = -1;; 1256 Int_t fd = -1;; 1257 if (h) {; 1258 fd = h->GetFd();; 1259 if (fd > -1) {; 1260 if (h->HasReadInterest()); 1261 rd.Set(fd);; 1262 if (h->HasWriteInterest()); 1263 wr.Set(fd);; 1264 h->ResetReadyMask();; 1265 mxfd = fd;; 1266 rc = UnixSelect(mxfd+1, &rd, &wr, to);; 1267 }; 1268 }; 1269 ; 1270 // Fill output lists, if required; 1271 if (rc > 0) {; 1272 if (rd.IsSet(fd)); 1273 h->SetReadReady();; 1274 if (wr.IsSet(fd)); 1275 h->SetWriteReady();; 1276 }; 1277 ; 1278 return rc;; 1279}; 1280 ; 1281//---- ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:38129,Safety,timeout,timeout,38129,"t);; 1209 TFileHandler *h = nullptr;; 1210 while ((h = (TFileHandler *) next())) {; 1211 Int_t fd = h->GetFd();; 1212 if (fd > -1) {; 1213 if (h->HasReadInterest()) {; 1214 rd.Set(fd);; 1215 mxfd = TMath::Max(mxfd, fd);; 1216 }; 1217 if (h->HasWriteInterest()) {; 1218 wr.Set(fd);; 1219 mxfd = TMath::Max(mxfd, fd);; 1220 }; 1221 h->ResetReadyMask();; 1222 }; 1223 }; 1224 if (mxfd > -1); 1225 rc = UnixSelect(mxfd+1, &rd, &wr, to);; 1226 ; 1227 // Set readiness bits; 1228 if (rc > 0) {; 1229 next.Reset();; 1230 while ((h = (TFileHandler *) next())) {; 1231 Int_t fd = h->GetFd();; 1232 if (rd.IsSet(fd)); 1233 h->SetReadReady();; 1234 if (wr.IsSet(fd)); 1235 h->SetWriteReady();; 1236 }; 1237 }; 1238 ; 1239 return rc;; 1240}; 1241 ; 1242////////////////////////////////////////////////////////////////////////////////; 1243/// Select on the file descriptor related to file handler h.; 1244/// The timeout to is in millisec. Returns the number of ready descriptors,; 1245/// or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; 1246/// and -3 EBADF. In case of EINTR the errno has been reset and the method; 1247/// can be called again. Returns -4 in case the file handler is 0 or does; 1248/// not have a file descriptor >= 0.; 1249 ; 1250Int_t TUnixSystem::Select(TFileHandler *h, Long_t to); 1251{; 1252 Int_t rc = -4;; 1253 ; 1254 TFdSet rd, wr;; 1255 Int_t mxfd = -1;; 1256 Int_t fd = -1;; 1257 if (h) {; 1258 fd = h->GetFd();; 1259 if (fd > -1) {; 1260 if (h->HasReadInterest()); 1261 rd.Set(fd);; 1262 if (h->HasWriteInterest()); 1263 wr.Set(fd);; 1264 h->ResetReadyMask();; 1265 mxfd = fd;; 1266 rc = UnixSelect(mxfd+1, &rd, &wr, to);; 1267 }; 1268 }; 1269 ; 1270 // Fill output lists, if required; 1271 if (rc > 0) {; 1272 if (rd.IsSet(fd)); 1273 h->SetReadReady();; 1274 if (wr.IsSet(fd)); 1275 h->SetWriteReady();; 1276 }; 1277 ; 1278 return rc;; 1279}; 1280 ; 1281//---- handling of system events -----------------------------------------------; 1282 ; 1283///////",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:46407,Safety,safe,safely,46407,"ydir);; 1495 if (res) return std::string(res);; 1496 else return std::string();; 1497}; 1498 ; 1499////////////////////////////////////////////////////////////////////////////////; 1500/// Return a user configured or systemwide directory to create; 1501/// temporary files in.; 1502 ; 1503const char *TUnixSystem::TempDirectory() const; 1504{; 1505 const char *dir = gSystem->Getenv(""TMPDIR"");; 1506 if (!dir || gSystem->AccessPathName(dir, kWritePermission)); 1507 dir = ""/tmp"";; 1508 ; 1509 return dir;; 1510}; 1511 ; 1512////////////////////////////////////////////////////////////////////////////////; 1513/// Create a secure temporary file by appending a unique; 1514/// 6 letter string to base. The file will be created in; 1515/// a standard (system) directory or in the directory; 1516/// provided in dir. Optionally one can provide suffix; 1517/// append to the final name - like extension "".txt"" or "".html"".; 1518/// The full filename is returned in base; 1519/// and a filepointer is returned for safely writing to the file; 1520/// (this avoids certain security problems). Returns 0 in case; 1521/// of error.; 1522 ; 1523FILE *TUnixSystem::TempFileName(TString &base, const char *dir, const char *suffix); 1524{; 1525 char *b = ConcatFileName(dir ? dir : TempDirectory(), base);; 1526 base = b;; 1527 base += ""XXXXXX"";; 1528 const bool hasSuffix = suffix && *suffix;; 1529 if (hasSuffix); 1530 base.Append(suffix);; 1531 delete [] b;; 1532 ; 1533 char *arg = StrDup(base);; 1534 int fd = hasSuffix ? mkstemps(arg, strlen(suffix)) : mkstemp(arg);; 1535 base = arg;; 1536 delete [] arg;; 1537 ; 1538 if (fd == -1) {; 1539 SysError(""TempFileName"", ""%s"", base.Data());; 1540 return nullptr;; 1541 } else {; 1542 FILE *fp = fdopen(fd, ""w+"");; 1543 if (!fp); 1544 SysError(""TempFileName"", ""converting filedescriptor (%d)"", fd);; 1545 return fp;; 1546 }; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// Concatenate a directory and a fi",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:46449,Safety,avoid,avoids,46449,"ydir);; 1495 if (res) return std::string(res);; 1496 else return std::string();; 1497}; 1498 ; 1499////////////////////////////////////////////////////////////////////////////////; 1500/// Return a user configured or systemwide directory to create; 1501/// temporary files in.; 1502 ; 1503const char *TUnixSystem::TempDirectory() const; 1504{; 1505 const char *dir = gSystem->Getenv(""TMPDIR"");; 1506 if (!dir || gSystem->AccessPathName(dir, kWritePermission)); 1507 dir = ""/tmp"";; 1508 ; 1509 return dir;; 1510}; 1511 ; 1512////////////////////////////////////////////////////////////////////////////////; 1513/// Create a secure temporary file by appending a unique; 1514/// 6 letter string to base. The file will be created in; 1515/// a standard (system) directory or in the directory; 1516/// provided in dir. Optionally one can provide suffix; 1517/// append to the final name - like extension "".txt"" or "".html"".; 1518/// The full filename is returned in base; 1519/// and a filepointer is returned for safely writing to the file; 1520/// (this avoids certain security problems). Returns 0 in case; 1521/// of error.; 1522 ; 1523FILE *TUnixSystem::TempFileName(TString &base, const char *dir, const char *suffix); 1524{; 1525 char *b = ConcatFileName(dir ? dir : TempDirectory(), base);; 1526 base = b;; 1527 base += ""XXXXXX"";; 1528 const bool hasSuffix = suffix && *suffix;; 1529 if (hasSuffix); 1530 base.Append(suffix);; 1531 delete [] b;; 1532 ; 1533 char *arg = StrDup(base);; 1534 int fd = hasSuffix ? mkstemps(arg, strlen(suffix)) : mkstemp(arg);; 1535 base = arg;; 1536 delete [] arg;; 1537 ; 1538 if (fd == -1) {; 1539 SysError(""TempFileName"", ""%s"", base.Data());; 1540 return nullptr;; 1541 } else {; 1542 FILE *fp = fdopen(fd, ""w+"");; 1543 if (!fp); 1544 SysError(""TempFileName"", ""converting filedescriptor (%d)"", fd);; 1545 return fp;; 1546 }; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// Concatenate a directory and a fi",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:50247,Safety,avoid,avoid,50247,", ""w"");; 1608 if (!to) {; 1609 fclose(from);; 1610 return -1;; 1611 }; 1612 ; 1613 const int bufsize = 1024;; 1614 char buf[bufsize];; 1615 int ret = 0;; 1616 while (!ret && !feof(from)) {; 1617 size_t numread = fread (buf, sizeof(char), bufsize, from);; 1618 size_t numwritten = fwrite(buf, sizeof(char), numread, to);; 1619 if (numread != numwritten); 1620 ret = -3;; 1621 }; 1622 ; 1623 fclose(from);; 1624 fclose(to);; 1625 ; 1626 return ret;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Rename a file. Returns 0 when successful, -1 in case of failure.; 1631 ; 1632int TUnixSystem::Rename(const char *f, const char *t); 1633{; 1634 int ret = ::rename(f, t);; 1635 GetLastErrorString() = GetError();; 1636 return ret;; 1637}; 1638 ; 1639////////////////////////////////////////////////////////////////////////////////; 1640/// Returns TRUE if the url in 'path' points to the local file system.; 1641/// This is used to avoid going through the NIC card for local operations.; 1642 ; 1643Bool_t TUnixSystem::IsPathLocal(const char *path); 1644{; 1645 TSystem *helper = FindHelper(path);; 1646 if (helper); 1647 return helper->IsPathLocal(path);; 1648 ; 1649 return TSystem::IsPathLocal(path);; 1650}; 1651 ; 1652////////////////////////////////////////////////////////////////////////////////; 1653/// Get info about a file. Info is returned in the form of a FileStat_t; 1654/// structure (see TSystem.h).; 1655/// The function returns 0 in case of success and 1 if the file could; 1656/// not be stat'ed.; 1657 ; 1658int TUnixSystem::GetPathInfo(const char *path, FileStat_t &buf); 1659{; 1660 TSystem *helper = FindHelper(path);; 1661 if (helper); 1662 return helper->GetPathInfo(path, buf);; 1663 ; 1664 return UnixFilestat(path, buf);; 1665}; 1666 ; 1667////////////////////////////////////////////////////////////////////////////////; 1668/// Get info about a file system: id, bsize, bfree, blocks.; 1669/// Id is file system type",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:68016,Safety,abort,abort,68016,"/////////////////////////////////////////////; 2169/// Close the pipe.; 2170 ; 2171int TUnixSystem::ClosePipe(FILE *pipe); 2172{; 2173 return ::pclose(pipe);; 2174}; 2175 ; 2176////////////////////////////////////////////////////////////////////////////////; 2177/// Get process id.; 2178 ; 2179int TUnixSystem::GetPid(); 2180{; 2181 return ::getpid();; 2182}; 2183 ; 2184////////////////////////////////////////////////////////////////////////////////; 2185/// Exit the application.; 2186 ; 2187void TUnixSystem::Exit(int code, Bool_t mode); 2188{; 2189 // Insures that the files and sockets are closed before any library is unloaded; 2190 // and before emptying CINT.; 2191 TROOT::ShutDown();; 2192 ; 2193 if (mode); 2194 ::exit(code);; 2195 else; 2196 ::_exit(code);; 2197}; 2198 ; 2199////////////////////////////////////////////////////////////////////////////////; 2200/// Abort the application.; 2201 ; 2202void TUnixSystem::Abort(int); 2203{; 2204 IgnoreSignal(kSigAbort);; 2205 ::abort();; 2206}; 2207 ; 2208 ; 2209#ifdef R__MACOSX; 2210/// Use CoreSymbolication to retrieve the stacktrace.; 2211#include <mach/mach.h>; 2212extern ""C"" {; 2213 // Adapted from https://github.com/mountainstorm/CoreSymbolication; 2214 // Under the hood the framework basically just calls through to a set of C++ libraries; 2215 typedef struct {; 2216 void* csCppData;; 2217 void* csCppObj;; 2218 } CSTypeRef;; 2219 typedef CSTypeRef CSSymbolicatorRef;; 2220 typedef CSTypeRef CSSourceInfoRef;; 2221 typedef CSTypeRef CSSymbolOwnerRef;; 2222 typedef CSTypeRef CSSymbolRef;; 2223 ; 2224 CSSymbolicatorRef CSSymbolicatorCreateWithPid(pid_t pid);; 2225 CSSymbolRef CSSymbolicatorGetSymbolWithAddressAtTime(CSSymbolicatorRef cs, vm_address_t addr, uint64_t time);; 2226 CSSourceInfoRef CSSymbolicatorGetSourceInfoWithAddressAtTime(CSSymbolicatorRef cs, vm_address_t addr, uint64_t time);; 2227 const char* CSSymbolGetName(CSSymbolRef sym);; 2228 CSSymbolOwnerRef CSSymbolGetSymbolOwner(CSSymbolRef sym);; 2229 const",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:115411,Safety,abort,abort,115411,"////////////////////////////////////////////////////////; 3604 ; 3605//---- signals -----------------------------------------------------------------; 3606 ; 3607static struct Signalmap_t {; 3608 int fCode;; 3609 SigHandler_t fHandler;; 3610 struct sigaction *fOldHandler;; 3611 const char *fSigName;; 3612} gSignalMap[kMAXSIGNALS] = { // the order of the signals should be identical; 3613 { SIGBUS, nullptr, nullptr, ""bus error"" }, // to the one in TSysEvtHandler.h; 3614 { SIGSEGV, nullptr, nullptr, ""segmentation violation"" },; 3615 { SIGSYS, nullptr, nullptr, ""bad argument to system call"" },; 3616 { SIGPIPE, nullptr, nullptr, ""write on a pipe with no one to read it"" },; 3617 { SIGILL, nullptr, nullptr, ""illegal instruction"" },; 3618 { SIGABRT, nullptr, nullptr, ""abort"" },; 3619 { SIGQUIT, nullptr, nullptr, ""quit"" },; 3620 { SIGINT, nullptr, nullptr, ""interrupt"" },; 3621 { SIGWINCH, nullptr, nullptr, ""window size change"" },; 3622 { SIGALRM, nullptr, nullptr, ""alarm clock"" },; 3623 { SIGCHLD, nullptr, nullptr, ""death of a child"" },; 3624 { SIGURG, nullptr, nullptr, ""urgent data arrived on an I/O channel"" },; 3625 { SIGFPE, nullptr, nullptr, ""floating point exception"" },; 3626 { SIGTERM, nullptr, nullptr, ""termination signal"" },; 3627 { SIGUSR1, nullptr, nullptr, ""user-defined signal 1"" },; 3628 { SIGUSR2, nullptr, nullptr, ""user-defined signal 2"" }; 3629};; 3630 ; 3631 ; 3632////////////////////////////////////////////////////////////////////////////////; 3633/// Call the signal handler associated with the signal.; 3634 ; 3635static void sighandler(int sig); 3636{; 3637 for (int i= 0; i < kMAXSIGNALS; i++) {; 3638 if (gSignalMap[i].fCode == sig) {; 3639 (*gSignalMap[i].fHandler)((ESignals)i);; 3640 return;; 3641 }; 3642 }; 3643}; 3644 ; 3645////////////////////////////////////////////////////////////////////////////////; 3646/// Handle and dispatch signals.; 3647 ; 3648void TUnixSystem::DispatchSignals(ESignals sig); 3649{; 3650 switch (sig) {; 3651 case kSigAlarm:; 365",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:120624,Safety,timeout,timeout,120624,"ct);; 3746 ; 3747 if (ignore != ignoreSig[sig]) {; 3748 ignoreSig[sig] = ignore;; 3749 if (ignore) {; 3750 struct sigaction sigact;; 3751#if defined(R__SUN); 3752 sigact.sa_handler = (void (*)())SIG_IGN;; 3753#elif defined(R__SOLARIS); 3754 sigact.sa_handler = (void (*)(int))SIG_IGN;; 3755#else; 3756 sigact.sa_handler = SIG_IGN;; 3757#endif; 3758 sigemptyset(&sigact.sa_mask);; 3759 sigact.sa_flags = 0;; 3760 if (sigaction(gSignalMap[sig].fCode, &sigact, &oldsigact[sig]) < 0); 3761 ::SysError(""TUnixSystem::UnixIgnoreSignal"", ""sigaction"");; 3762 } else {; 3763 if (sigaction(gSignalMap[sig].fCode, &oldsigact[sig], nullptr) < 0); 3764 ::SysError(""TUnixSystem::UnixIgnoreSignal"", ""sigaction"");; 3765 }; 3766 }; 3767}; 3768 ; 3769////////////////////////////////////////////////////////////////////////////////; 3770/// When the argument is true the SIGALRM signal handler is set so that; 3771/// interrupted syscalls will not be restarted by the kernel. This is; 3772/// typically used in case one wants to put a timeout on an I/O operation.; 3773/// By default interrupted syscalls will always be restarted (for all; 3774/// signals). This can be controlled for each a-synchronous TTimer via; 3775/// the method TTimer::SetInterruptSyscalls().; 3776 ; 3777void TUnixSystem::UnixSigAlarmInterruptsSyscalls(Bool_t set); 3778{; 3779 if (gSignalMap[kSigAlarm].fHandler) {; 3780 struct sigaction sigact;; 3781#if defined(R__SUN); 3782 sigact.sa_handler = (void (*)())sighandler;; 3783#elif defined(R__SOLARIS); 3784 sigact.sa_handler = sighandler;; 3785#elif defined(R__LYNXOS); 3786# if (__GNUG__>=3); 3787 sigact.sa_handler = sighandler;; 3788# else; 3789 sigact.sa_handler = (void (*)(...))sighandler;; 3790# endif; 3791#else; 3792 sigact.sa_handler = sighandler;; 3793#endif; 3794 sigemptyset(&sigact.sa_mask);; 3795 sigact.sa_flags = 0;; 3796 if (set) {; 3797#if defined(SA_INTERRUPT) // SunOS; 3798 sigact.sa_flags |= SA_INTERRUPT;; 3799#endif; 3800 } else {; 3801#if defined(SA_RESTART); 3802 s",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:124778,Safety,timeout,timeout,124778,"jan95 == -1) {; 3862 ::SysError(""TUnixSystem::UnixNow"", ""error converting 950001 0:00 to time_t"");; 3863 return 0;; 3864 }; 3865 }; 3866 ; 3867 struct timeval t;; 3868 gettimeofday(&t, nullptr);; 3869 return Long64_t(t.tv_sec-(Long_t)jan95)*1000 + t.tv_usec/1000;; 3870}; 3871 ; 3872////////////////////////////////////////////////////////////////////////////////; 3873/// Set interval timer to time-out in ms milliseconds.; 3874 ; 3875int TUnixSystem::UnixSetitimer(Long_t ms); 3876{; 3877 struct itimerval itv;; 3878 itv.it_value.tv_sec = 0;; 3879 itv.it_value.tv_usec = 0;; 3880 itv.it_interval.tv_sec = 0;; 3881 itv.it_interval.tv_usec = 0;; 3882 if (ms > 0) {; 3883 itv.it_value.tv_sec = time_t(ms / 1000);; 3884 itv.it_value.tv_usec = time_t((ms % 1000) * 1000);; 3885 }; 3886 int st = setitimer(ITIMER_REAL, &itv, nullptr);; 3887 if (st == -1); 3888 ::SysError(""TUnixSystem::UnixSetitimer"", ""setitimer"");; 3889 return st;; 3890}; 3891 ; 3892//---- file descriptors --------------------------------------------------------; 3893 ; 3894////////////////////////////////////////////////////////////////////////////////; 3895/// Wait for events on the file descriptors specified in the readready and; 3896/// writeready masks or for timeout (in milliseconds) to occur. Returns; 3897/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 3898/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 3899/// the errno has been reset and the method can be called again.; 3900 ; 3901int TUnixSystem::UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready,; 3902 Long_t timeout); 3903{; 3904 int retcode;; 3905 ; 3906 fd_set *rd = (readready) ? (fd_set*)readready->GetBits() : nullptr;; 3907 fd_set *wr = (writeready) ? (fd_set*)writeready->GetBits() : nullptr;; 3908 ; 3909 if (timeout >= 0) {; 3910 struct timeval tv;; 3911 tv.tv_sec = Int_t(timeout / 1000);; 3912 tv.tv_usec = (timeout % 1000) * 1000;; 3913 retcode = select(nfds, rd, wr, nullptr, &tv);; 3914 ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:124880,Safety,timeout,timeout,124880,"////////////////////; 3873/// Set interval timer to time-out in ms milliseconds.; 3874 ; 3875int TUnixSystem::UnixSetitimer(Long_t ms); 3876{; 3877 struct itimerval itv;; 3878 itv.it_value.tv_sec = 0;; 3879 itv.it_value.tv_usec = 0;; 3880 itv.it_interval.tv_sec = 0;; 3881 itv.it_interval.tv_usec = 0;; 3882 if (ms > 0) {; 3883 itv.it_value.tv_sec = time_t(ms / 1000);; 3884 itv.it_value.tv_usec = time_t((ms % 1000) * 1000);; 3885 }; 3886 int st = setitimer(ITIMER_REAL, &itv, nullptr);; 3887 if (st == -1); 3888 ::SysError(""TUnixSystem::UnixSetitimer"", ""setitimer"");; 3889 return st;; 3890}; 3891 ; 3892//---- file descriptors --------------------------------------------------------; 3893 ; 3894////////////////////////////////////////////////////////////////////////////////; 3895/// Wait for events on the file descriptors specified in the readready and; 3896/// writeready masks or for timeout (in milliseconds) to occur. Returns; 3897/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 3898/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 3899/// the errno has been reset and the method can be called again.; 3900 ; 3901int TUnixSystem::UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready,; 3902 Long_t timeout); 3903{; 3904 int retcode;; 3905 ; 3906 fd_set *rd = (readready) ? (fd_set*)readready->GetBits() : nullptr;; 3907 fd_set *wr = (writeready) ? (fd_set*)writeready->GetBits() : nullptr;; 3908 ; 3909 if (timeout >= 0) {; 3910 struct timeval tv;; 3911 tv.tv_sec = Int_t(timeout / 1000);; 3912 tv.tv_usec = (timeout % 1000) * 1000;; 3913 retcode = select(nfds, rd, wr, nullptr, &tv);; 3914 } else {; 3915 retcode = select(nfds, rd, wr, nullptr, nullptr);; 3916 }; 3917 if (retcode == -1) {; 3918 if (GetErrno() == EINTR) {; 3919 ResetErrno(); // errno is not self reseting; 3920 return -2;; 3921 }; 3922 if (GetErrno() == EBADF); 3923 return -3;; 3924 return -1;; 3925 }; 3926 ; 3927 return retcode;; 3928}; 3929 ; 3930//---- direct",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:125151,Safety,timeout,timeout,125151,"v_sec = time_t(ms / 1000);; 3884 itv.it_value.tv_usec = time_t((ms % 1000) * 1000);; 3885 }; 3886 int st = setitimer(ITIMER_REAL, &itv, nullptr);; 3887 if (st == -1); 3888 ::SysError(""TUnixSystem::UnixSetitimer"", ""setitimer"");; 3889 return st;; 3890}; 3891 ; 3892//---- file descriptors --------------------------------------------------------; 3893 ; 3894////////////////////////////////////////////////////////////////////////////////; 3895/// Wait for events on the file descriptors specified in the readready and; 3896/// writeready masks or for timeout (in milliseconds) to occur. Returns; 3897/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 3898/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 3899/// the errno has been reset and the method can be called again.; 3900 ; 3901int TUnixSystem::UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready,; 3902 Long_t timeout); 3903{; 3904 int retcode;; 3905 ; 3906 fd_set *rd = (readready) ? (fd_set*)readready->GetBits() : nullptr;; 3907 fd_set *wr = (writeready) ? (fd_set*)writeready->GetBits() : nullptr;; 3908 ; 3909 if (timeout >= 0) {; 3910 struct timeval tv;; 3911 tv.tv_sec = Int_t(timeout / 1000);; 3912 tv.tv_usec = (timeout % 1000) * 1000;; 3913 retcode = select(nfds, rd, wr, nullptr, &tv);; 3914 } else {; 3915 retcode = select(nfds, rd, wr, nullptr, nullptr);; 3916 }; 3917 if (retcode == -1) {; 3918 if (GetErrno() == EINTR) {; 3919 ResetErrno(); // errno is not self reseting; 3920 return -2;; 3921 }; 3922 if (GetErrno() == EBADF); 3923 return -3;; 3924 return -1;; 3925 }; 3926 ; 3927 return retcode;; 3928}; 3929 ; 3930//---- directories -------------------------------------------------------------; 3931 ; 3932////////////////////////////////////////////////////////////////////////////////; 3933/// Returns the user's home directory.; 3934 ; 3935const char *TUnixSystem::UnixHomedirectory(const char *name); 3936{; 3937 static char path[kMAXPATHLEN], mydir[kMAXPATHLEN] =",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:125360,Safety,timeout,timeout,125360,"v_sec = time_t(ms / 1000);; 3884 itv.it_value.tv_usec = time_t((ms % 1000) * 1000);; 3885 }; 3886 int st = setitimer(ITIMER_REAL, &itv, nullptr);; 3887 if (st == -1); 3888 ::SysError(""TUnixSystem::UnixSetitimer"", ""setitimer"");; 3889 return st;; 3890}; 3891 ; 3892//---- file descriptors --------------------------------------------------------; 3893 ; 3894////////////////////////////////////////////////////////////////////////////////; 3895/// Wait for events on the file descriptors specified in the readready and; 3896/// writeready masks or for timeout (in milliseconds) to occur. Returns; 3897/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 3898/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 3899/// the errno has been reset and the method can be called again.; 3900 ; 3901int TUnixSystem::UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready,; 3902 Long_t timeout); 3903{; 3904 int retcode;; 3905 ; 3906 fd_set *rd = (readready) ? (fd_set*)readready->GetBits() : nullptr;; 3907 fd_set *wr = (writeready) ? (fd_set*)writeready->GetBits() : nullptr;; 3908 ; 3909 if (timeout >= 0) {; 3910 struct timeval tv;; 3911 tv.tv_sec = Int_t(timeout / 1000);; 3912 tv.tv_usec = (timeout % 1000) * 1000;; 3913 retcode = select(nfds, rd, wr, nullptr, &tv);; 3914 } else {; 3915 retcode = select(nfds, rd, wr, nullptr, nullptr);; 3916 }; 3917 if (retcode == -1) {; 3918 if (GetErrno() == EINTR) {; 3919 ResetErrno(); // errno is not self reseting; 3920 return -2;; 3921 }; 3922 if (GetErrno() == EBADF); 3923 return -3;; 3924 return -1;; 3925 }; 3926 ; 3927 return retcode;; 3928}; 3929 ; 3930//---- directories -------------------------------------------------------------; 3931 ; 3932////////////////////////////////////////////////////////////////////////////////; 3933/// Returns the user's home directory.; 3934 ; 3935const char *TUnixSystem::UnixHomedirectory(const char *name); 3936{; 3937 static char path[kMAXPATHLEN], mydir[kMAXPATHLEN] =",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:125425,Safety,timeout,timeout,125425,"etitimer"", ""setitimer"");; 3889 return st;; 3890}; 3891 ; 3892//---- file descriptors --------------------------------------------------------; 3893 ; 3894////////////////////////////////////////////////////////////////////////////////; 3895/// Wait for events on the file descriptors specified in the readready and; 3896/// writeready masks or for timeout (in milliseconds) to occur. Returns; 3897/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 3898/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 3899/// the errno has been reset and the method can be called again.; 3900 ; 3901int TUnixSystem::UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready,; 3902 Long_t timeout); 3903{; 3904 int retcode;; 3905 ; 3906 fd_set *rd = (readready) ? (fd_set*)readready->GetBits() : nullptr;; 3907 fd_set *wr = (writeready) ? (fd_set*)writeready->GetBits() : nullptr;; 3908 ; 3909 if (timeout >= 0) {; 3910 struct timeval tv;; 3911 tv.tv_sec = Int_t(timeout / 1000);; 3912 tv.tv_usec = (timeout % 1000) * 1000;; 3913 retcode = select(nfds, rd, wr, nullptr, &tv);; 3914 } else {; 3915 retcode = select(nfds, rd, wr, nullptr, nullptr);; 3916 }; 3917 if (retcode == -1) {; 3918 if (GetErrno() == EINTR) {; 3919 ResetErrno(); // errno is not self reseting; 3920 return -2;; 3921 }; 3922 if (GetErrno() == EBADF); 3923 return -3;; 3924 return -1;; 3925 }; 3926 ; 3927 return retcode;; 3928}; 3929 ; 3930//---- directories -------------------------------------------------------------; 3931 ; 3932////////////////////////////////////////////////////////////////////////////////; 3933/// Returns the user's home directory.; 3934 ; 3935const char *TUnixSystem::UnixHomedirectory(const char *name); 3936{; 3937 static char path[kMAXPATHLEN], mydir[kMAXPATHLEN] = { '\0' };; 3938 return UnixHomedirectory(name, path, mydir);; 3939}; 3940 ; 3941////////////////////////////////////////////////////////////////////////////; 3942/// Returns the user's home directory.; ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:125462,Safety,timeout,timeout,125462," or for timeout (in milliseconds) to occur. Returns; 3897/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 3898/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 3899/// the errno has been reset and the method can be called again.; 3900 ; 3901int TUnixSystem::UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready,; 3902 Long_t timeout); 3903{; 3904 int retcode;; 3905 ; 3906 fd_set *rd = (readready) ? (fd_set*)readready->GetBits() : nullptr;; 3907 fd_set *wr = (writeready) ? (fd_set*)writeready->GetBits() : nullptr;; 3908 ; 3909 if (timeout >= 0) {; 3910 struct timeval tv;; 3911 tv.tv_sec = Int_t(timeout / 1000);; 3912 tv.tv_usec = (timeout % 1000) * 1000;; 3913 retcode = select(nfds, rd, wr, nullptr, &tv);; 3914 } else {; 3915 retcode = select(nfds, rd, wr, nullptr, nullptr);; 3916 }; 3917 if (retcode == -1) {; 3918 if (GetErrno() == EINTR) {; 3919 ResetErrno(); // errno is not self reseting; 3920 return -2;; 3921 }; 3922 if (GetErrno() == EBADF); 3923 return -3;; 3924 return -1;; 3925 }; 3926 ; 3927 return retcode;; 3928}; 3929 ; 3930//---- directories -------------------------------------------------------------; 3931 ; 3932////////////////////////////////////////////////////////////////////////////////; 3933/// Returns the user's home directory.; 3934 ; 3935const char *TUnixSystem::UnixHomedirectory(const char *name); 3936{; 3937 static char path[kMAXPATHLEN], mydir[kMAXPATHLEN] = { '\0' };; 3938 return UnixHomedirectory(name, path, mydir);; 3939}; 3940 ; 3941////////////////////////////////////////////////////////////////////////////; 3942/// Returns the user's home directory.; 3943 ; 3944const char *TUnixSystem::UnixHomedirectory(const char *name, char *path, char *mydir); 3945{; 3946 struct passwd *pw;; 3947 if (name) {; 3948 pw = getpwnam(name);; 3949 if (pw) {; 3950 strncpy(path, pw->pw_dir, kMAXPATHLEN-1);; 3951 path[kMAXPATHLEN-1] = '\0';; 3952 return path;; 3953 }; 3954 } else {; 3955 if (mydir[0]); 3956 ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:176480,Safety,abort,abort,176480,"uble_tdouble Double_tDefinition RtypesCore.h:59; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; kItimerResolution@ kItimerResolutionDefinition Rtypes.h:62; kMAXSIGNALS@ kMAXSIGNALSDefinition Rtypes.h:59; kMAXPATHLEN@ kMAXPATHLENDefinition Rtypes.h:60; TApplication.h; gApplicationR__EXTERN TApplication * gApplicationDefinition TApplication.h:170; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; TError.h; SysErrorvoid SysError(const char *location, const char *msgfmt,...)Use this function in case a system (OS or GUI) related error occurred.Definition TError.cxx:196; Breakvoid Break(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:207; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; TException.h; gExceptionHandlerR__EXTERN TExceptionHandler * gExceptionHandlerDefinition TException.h:79; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; directwinID h directDefinition TGWin32VirtualGLProxy.cxx:43; maskOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t maskDefinition TGWin32VirtualXProxy.cxx:178; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t W",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:206683,Safety,timeout,timeout,206683,"Definition TUnixSystem.cxx:5318; TUnixSystem::Exitvoid Exit(int code, Bool_t mode=kTRUE) overrideExit the application.Definition TUnixSystem.cxx:2187; TUnixSystem::AnnounceTcpServiceint AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize=-1) overrideAnnounce TCP/IP service.Definition TUnixSystem.cxx:3241; TUnixSystem::TUnixSystemTUnixSystem()Definition TUnixSystem.cxx:575; TUnixSystem::AddDynamicPathvoid AddDynamicPath(const char *lib) overrideAdd a new directory to the dynamic path.Definition TUnixSystem.cxx:4725; TUnixSystem::SetDynamicPathvoid SetDynamicPath(const char *lib) overrideSet the dynamic path to a new value.Definition TUnixSystem.cxx:4748; TUnixSystem::ClosePipeint ClosePipe(FILE *pipe) overrideClose the pipe.Definition TUnixSystem.cxx:2171; TUnixSystem::GetHomeDirectorystd::string GetHomeDirectory(const char *userName=nullptr) const overrideReturn the user's home directory.Definition TUnixSystem.cxx:1491; TUnixSystem::SelectInt_t Select(TList *active, Long_t timeout) overrideSelect on file descriptors.Definition TUnixSystem.cxx:1202; TUnixSystem::Unsetenvvoid Unsetenv(const char *name) overrideUnset environment variable.Definition TUnixSystem.cxx:2145; TUnixSystem::~TUnixSystemvirtual ~TUnixSystem()Reset to original state.Definition TUnixSystem.cxx:581; TUnixSystem::Abortvoid Abort(int code=0) overrideAbort the application.Definition TUnixSystem.cxx:2202; TUnixSystem::Syslogvoid Syslog(ELogLevel level, const char *mess) overrideSend mess to syslog daemon.Definition TUnixSystem.cxx:2654; TUnixSystem::GetGroupInfoUserGroup_t * GetGroupInfo(Int_t gid) overrideReturns all group info in the UserGroup_t structure.Definition TUnixSystem.cxx:2099; TUnixSystem::GetUidInt_t GetUid(const char *user=nullptr) overrideReturns the user's id. If user = 0, returns current user's id.Definition TUnixSystem.cxx:2005; TUnixSystem::ExpandPathNameBool_t ExpandPathName(TString &patbuf) overrideExpand a pathname getting rid of special shell characters li",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:216050,Safety,timeout,timeout,216050,"void *buf, Int_t len) overrideReturn cryptographic random number Fill provided buffer with random values Returns number of bytes wr...Definition TUnixSystem.cxx:740; TUnixSystem::OpenDirectoryvoid * OpenDirectory(const char *name) overrideOpen a Unix file system directory. Returns 0 if directory does not exist.Definition TUnixSystem.cxx:1392; TUnixSystem::Renameint Rename(const char *from, const char *to) overrideRename a file. Returns 0 when successful, -1 in case of failure.Definition TUnixSystem.cxx:1632; TUnixSystem::Getenvconst char * Getenv(const char *name) overrideGet environment variable.Definition TUnixSystem.cxx:2137; TUnixSystem::GetPathInfoint GetPathInfo(const char *path, FileStat_t &buf) overrideGet info about a file.Definition TUnixSystem.cxx:1658; TUnixSystem::GetEffectiveGidInt_t GetEffectiveGid() overrideReturns the effective group id.Definition TUnixSystem.cxx:2045; TUnixSystem::UnixSelectstatic int UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready, Long_t timeout)Wait for events on the file descriptors specified in the readready and writeready masks or for timeou...Definition TUnixSystem.cxx:3901; TUnixSystem::GetPidint GetPid() overrideGet process id.Definition TUnixSystem.cxx:2179; TUnixSystem::ExecInt_t Exec(const char *shellcmd) overrideExecute a command.Definition TUnixSystem.cxx:2155; TUnixSystem::ResetTimervoid ResetTimer(TTimer *ti) overrideReset a-sync timer.Definition TUnixSystem.cxx:3033; TUnixSystem::RemoveSignalHandlerTSignalHandler * RemoveSignalHandler(TSignalHandler *sh) overrideRemove a signal handler from list of signal handlers.Definition TUnixSystem.cxx:849; TUnixSystem::UnixSignalstatic void UnixSignal(ESignals sig, SigHandler_t h)Set a signal handler for a signal.Definition TUnixSystem.cxx:3703; TUnixSystem::CloseConnectionvoid CloseConnection(int sock, Bool_t force=kFALSE) overrideClose socket.Definition TUnixSystem.cxx:3298; TUnixSystem::CheckDescriptorsBool_t CheckDescriptors()Check if there is activity on some",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:46022,Security,secur,secure,46022,"///; 1481/// Return the user's home directory.; 1482 ; 1483const char *TUnixSystem::HomeDirectory(const char *userName); 1484{; 1485 return UnixHomedirectory(userName);; 1486}; 1487 ; 1488//////////////////////////////////////////////////////////////////////////////; 1489/// Return the user's home directory.; 1490 ; 1491std::string TUnixSystem::GetHomeDirectory(const char *userName) const; 1492{; 1493 char path[kMAXPATHLEN], mydir[kMAXPATHLEN] = { '\0' };; 1494 auto res = UnixHomedirectory(userName, path, mydir);; 1495 if (res) return std::string(res);; 1496 else return std::string();; 1497}; 1498 ; 1499////////////////////////////////////////////////////////////////////////////////; 1500/// Return a user configured or systemwide directory to create; 1501/// temporary files in.; 1502 ; 1503const char *TUnixSystem::TempDirectory() const; 1504{; 1505 const char *dir = gSystem->Getenv(""TMPDIR"");; 1506 if (!dir || gSystem->AccessPathName(dir, kWritePermission)); 1507 dir = ""/tmp"";; 1508 ; 1509 return dir;; 1510}; 1511 ; 1512////////////////////////////////////////////////////////////////////////////////; 1513/// Create a secure temporary file by appending a unique; 1514/// 6 letter string to base. The file will be created in; 1515/// a standard (system) directory or in the directory; 1516/// provided in dir. Optionally one can provide suffix; 1517/// append to the final name - like extension "".txt"" or "".html"".; 1518/// The full filename is returned in base; 1519/// and a filepointer is returned for safely writing to the file; 1520/// (this avoids certain security problems). Returns 0 in case; 1521/// of error.; 1522 ; 1523FILE *TUnixSystem::TempFileName(TString &base, const char *dir, const char *suffix); 1524{; 1525 char *b = ConcatFileName(dir ? dir : TempDirectory(), base);; 1526 base = b;; 1527 base += ""XXXXXX"";; 1528 const bool hasSuffix = suffix && *suffix;; 1529 if (hasSuffix); 1530 base.Append(suffix);; 1531 delete [] b;; 1532 ; 1533 char *arg = StrDup(base);; 1",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:46464,Security,secur,security,46464,"ydir);; 1495 if (res) return std::string(res);; 1496 else return std::string();; 1497}; 1498 ; 1499////////////////////////////////////////////////////////////////////////////////; 1500/// Return a user configured or systemwide directory to create; 1501/// temporary files in.; 1502 ; 1503const char *TUnixSystem::TempDirectory() const; 1504{; 1505 const char *dir = gSystem->Getenv(""TMPDIR"");; 1506 if (!dir || gSystem->AccessPathName(dir, kWritePermission)); 1507 dir = ""/tmp"";; 1508 ; 1509 return dir;; 1510}; 1511 ; 1512////////////////////////////////////////////////////////////////////////////////; 1513/// Create a secure temporary file by appending a unique; 1514/// 6 letter string to base. The file will be created in; 1515/// a standard (system) directory or in the directory; 1516/// provided in dir. Optionally one can provide suffix; 1517/// append to the final name - like extension "".txt"" or "".html"".; 1518/// The full filename is returned in base; 1519/// and a filepointer is returned for safely writing to the file; 1520/// (this avoids certain security problems). Returns 0 in case; 1521/// of error.; 1522 ; 1523FILE *TUnixSystem::TempFileName(TString &base, const char *dir, const char *suffix); 1524{; 1525 char *b = ConcatFileName(dir ? dir : TempDirectory(), base);; 1526 base = b;; 1527 base += ""XXXXXX"";; 1528 const bool hasSuffix = suffix && *suffix;; 1529 if (hasSuffix); 1530 base.Append(suffix);; 1531 delete [] b;; 1532 ; 1533 char *arg = StrDup(base);; 1534 int fd = hasSuffix ? mkstemps(arg, strlen(suffix)) : mkstemp(arg);; 1535 base = arg;; 1536 delete [] arg;; 1537 ; 1538 if (fd == -1) {; 1539 SysError(""TempFileName"", ""%s"", base.Data());; 1540 return nullptr;; 1541 } else {; 1542 FILE *fp = fdopen(fd, ""w+"");; 1543 if (!fp); 1544 SysError(""TempFileName"", ""converting filedescriptor (%d)"", fd);; 1545 return fp;; 1546 }; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// Concatenate a directory and a fi",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:48099,Security,access,access,48099," 1538 if (fd == -1) {; 1539 SysError(""TempFileName"", ""%s"", base.Data());; 1540 return nullptr;; 1541 } else {; 1542 FILE *fp = fdopen(fd, ""w+"");; 1543 if (!fp); 1544 SysError(""TempFileName"", ""converting filedescriptor (%d)"", fd);; 1545 return fp;; 1546 }; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// Concatenate a directory and a file name.; 1551 ; 1552const char *TUnixSystem::PrependPathName(const char *dir, TString& name); 1553{; 1554 if (name.IsNull() || name == ""."") {; 1555 if (dir) {; 1556 name = dir;; 1557 if (dir[strlen(dir) - 1] != '/'); 1558 name += '/';; 1559 } else name = """";; 1560 return name.Data();; 1561 }; 1562 ; 1563 if (!dir || !dir[0]); 1564 dir = ""/"";; 1565 else if (dir[strlen(dir) - 1] != '/'); 1566 name.Prepend('/');; 1567 name.Prepend(dir);; 1568 ; 1569 return name.Data();; 1570}; 1571 ; 1572//---- Paths & Files -----------------------------------------------------------; 1573 ; 1574////////////////////////////////////////////////////////////////////////////////; 1575/// Returns FALSE if one can access a file using the specified access mode.; 1576/// Mode is the same as for the Unix access(2) function.; 1577/// Attention, bizarre convention of return value!!; 1578 ; 1579Bool_t TUnixSystem::AccessPathName(const char *path, EAccessMode mode); 1580{; 1581 TSystem *helper = FindHelper(path);; 1582 if (helper); 1583 return helper->AccessPathName(path, mode);; 1584 ; 1585 if (::access(StripOffProto(path, ""file:""), mode) == 0); 1586 return kFALSE;; 1587 GetLastErrorString() = GetError();; 1588 ; 1589 return kTRUE;; 1590}; 1591 ; 1592////////////////////////////////////////////////////////////////////////////////; 1593/// Copy a file. If overwrite is true and file already exists the; 1594/// file will be overwritten. Returns 0 when successful, -1 in case; 1595/// of file open failure, -2 in case the file already exists and overwrite; 1596/// was false and -3 in case of error during copy.; 159",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:48133,Security,access,access,48133," 1538 if (fd == -1) {; 1539 SysError(""TempFileName"", ""%s"", base.Data());; 1540 return nullptr;; 1541 } else {; 1542 FILE *fp = fdopen(fd, ""w+"");; 1543 if (!fp); 1544 SysError(""TempFileName"", ""converting filedescriptor (%d)"", fd);; 1545 return fp;; 1546 }; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// Concatenate a directory and a file name.; 1551 ; 1552const char *TUnixSystem::PrependPathName(const char *dir, TString& name); 1553{; 1554 if (name.IsNull() || name == ""."") {; 1555 if (dir) {; 1556 name = dir;; 1557 if (dir[strlen(dir) - 1] != '/'); 1558 name += '/';; 1559 } else name = """";; 1560 return name.Data();; 1561 }; 1562 ; 1563 if (!dir || !dir[0]); 1564 dir = ""/"";; 1565 else if (dir[strlen(dir) - 1] != '/'); 1566 name.Prepend('/');; 1567 name.Prepend(dir);; 1568 ; 1569 return name.Data();; 1570}; 1571 ; 1572//---- Paths & Files -----------------------------------------------------------; 1573 ; 1574////////////////////////////////////////////////////////////////////////////////; 1575/// Returns FALSE if one can access a file using the specified access mode.; 1576/// Mode is the same as for the Unix access(2) function.; 1577/// Attention, bizarre convention of return value!!; 1578 ; 1579Bool_t TUnixSystem::AccessPathName(const char *path, EAccessMode mode); 1580{; 1581 TSystem *helper = FindHelper(path);; 1582 if (helper); 1583 return helper->AccessPathName(path, mode);; 1584 ; 1585 if (::access(StripOffProto(path, ""file:""), mode) == 0); 1586 return kFALSE;; 1587 GetLastErrorString() = GetError();; 1588 ; 1589 return kTRUE;; 1590}; 1591 ; 1592////////////////////////////////////////////////////////////////////////////////; 1593/// Copy a file. If overwrite is true and file already exists the; 1594/// file will be overwritten. Returns 0 when successful, -1 in case; 1595/// of file open failure, -2 in case the file already exists and overwrite; 1596/// was false and -3 in case of error during copy.; 159",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:48188,Security,access,access,48188,"or(""TempFileName"", ""converting filedescriptor (%d)"", fd);; 1545 return fp;; 1546 }; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// Concatenate a directory and a file name.; 1551 ; 1552const char *TUnixSystem::PrependPathName(const char *dir, TString& name); 1553{; 1554 if (name.IsNull() || name == ""."") {; 1555 if (dir) {; 1556 name = dir;; 1557 if (dir[strlen(dir) - 1] != '/'); 1558 name += '/';; 1559 } else name = """";; 1560 return name.Data();; 1561 }; 1562 ; 1563 if (!dir || !dir[0]); 1564 dir = ""/"";; 1565 else if (dir[strlen(dir) - 1] != '/'); 1566 name.Prepend('/');; 1567 name.Prepend(dir);; 1568 ; 1569 return name.Data();; 1570}; 1571 ; 1572//---- Paths & Files -----------------------------------------------------------; 1573 ; 1574////////////////////////////////////////////////////////////////////////////////; 1575/// Returns FALSE if one can access a file using the specified access mode.; 1576/// Mode is the same as for the Unix access(2) function.; 1577/// Attention, bizarre convention of return value!!; 1578 ; 1579Bool_t TUnixSystem::AccessPathName(const char *path, EAccessMode mode); 1580{; 1581 TSystem *helper = FindHelper(path);; 1582 if (helper); 1583 return helper->AccessPathName(path, mode);; 1584 ; 1585 if (::access(StripOffProto(path, ""file:""), mode) == 0); 1586 return kFALSE;; 1587 GetLastErrorString() = GetError();; 1588 ; 1589 return kTRUE;; 1590}; 1591 ; 1592////////////////////////////////////////////////////////////////////////////////; 1593/// Copy a file. If overwrite is true and file already exists the; 1594/// file will be overwritten. Returns 0 when successful, -1 in case; 1595/// of file open failure, -2 in case the file already exists and overwrite; 1596/// was false and -3 in case of error during copy.; 1597 ; 1598int TUnixSystem::CopyFile(const char *f, const char *t, Bool_t overwrite); 1599{; 1600 if (!AccessPathName(t) && !overwrite); 1601 return -2;; 1602 ; 1603 FILE *fr",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:48483,Security,access,access,48483,"dir, TString& name); 1553{; 1554 if (name.IsNull() || name == ""."") {; 1555 if (dir) {; 1556 name = dir;; 1557 if (dir[strlen(dir) - 1] != '/'); 1558 name += '/';; 1559 } else name = """";; 1560 return name.Data();; 1561 }; 1562 ; 1563 if (!dir || !dir[0]); 1564 dir = ""/"";; 1565 else if (dir[strlen(dir) - 1] != '/'); 1566 name.Prepend('/');; 1567 name.Prepend(dir);; 1568 ; 1569 return name.Data();; 1570}; 1571 ; 1572//---- Paths & Files -----------------------------------------------------------; 1573 ; 1574////////////////////////////////////////////////////////////////////////////////; 1575/// Returns FALSE if one can access a file using the specified access mode.; 1576/// Mode is the same as for the Unix access(2) function.; 1577/// Attention, bizarre convention of return value!!; 1578 ; 1579Bool_t TUnixSystem::AccessPathName(const char *path, EAccessMode mode); 1580{; 1581 TSystem *helper = FindHelper(path);; 1582 if (helper); 1583 return helper->AccessPathName(path, mode);; 1584 ; 1585 if (::access(StripOffProto(path, ""file:""), mode) == 0); 1586 return kFALSE;; 1587 GetLastErrorString() = GetError();; 1588 ; 1589 return kTRUE;; 1590}; 1591 ; 1592////////////////////////////////////////////////////////////////////////////////; 1593/// Copy a file. If overwrite is true and file already exists the; 1594/// file will be overwritten. Returns 0 when successful, -1 in case; 1595/// of file open failure, -2 in case the file already exists and overwrite; 1596/// was false and -3 in case of error during copy.; 1597 ; 1598int TUnixSystem::CopyFile(const char *f, const char *t, Bool_t overwrite); 1599{; 1600 if (!AccessPathName(t) && !overwrite); 1601 return -2;; 1602 ; 1603 FILE *from = fopen(f, ""r"");; 1604 if (!from); 1605 return -1;; 1606 ; 1607 FILE *to = fopen(t, ""w"");; 1608 if (!to) {; 1609 fclose(from);; 1610 return -1;; 1611 }; 1612 ; 1613 const int bufsize = 1024;; 1614 char buf[bufsize];; 1615 int ret = 0;; 1616 while (!ret && !feof(from)) {; 1617 size_t numread = fr",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:58591,Security,access,access,58591,"es in a pathname. If compatibility is not an issue; 1878/// you can use on Unix directly $XXX. The user must delete returned string.; 1879/// Returns the expanded pathname or 0 in case of error.; 1880/// The user must delete returned string (delete []).; 1881 ; 1882char *TUnixSystem::ExpandPathName(const char *path); 1883{; 1884 TString patbuf = path;; 1885 if (ExpandPathName(patbuf)); 1886 return nullptr;; 1887 return StrDup(patbuf.Data());; 1888}; 1889 ; 1890////////////////////////////////////////////////////////////////////////////////; 1891/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1892 ; 1893int TUnixSystem::Chmod(const char *file, UInt_t mode); 1894{; 1895 return ::chmod(file, mode);; 1896}; 1897 ; 1898////////////////////////////////////////////////////////////////////////////////; 1899/// Set the process file creation mode mask.; 1900 ; 1901int TUnixSystem::Umask(Int_t mask); 1902{; 1903 return ::umask(mask);; 1904}; 1905 ; 1906////////////////////////////////////////////////////////////////////////////////; 1907/// Set a files modification and access times. If actime = 0 it will be; 1908/// set to the modtime. Returns 0 on success and -1 in case of error.; 1909 ; 1910int TUnixSystem::Utime(const char *file, Long_t modtime, Long_t actime); 1911{; 1912 if (!actime); 1913 actime = modtime;; 1914 ; 1915 struct utimbuf t;; 1916 t.actime = (time_t)actime;; 1917 t.modtime = (time_t)modtime;; 1918 return ::utime(file, &t);; 1919}; 1920 ; 1921////////////////////////////////////////////////////////////////////////////////; 1922/// Find location of file ""wfil"" in a search path.; 1923/// The search path is specified as a : separated list of directories.; 1924/// Return value is pointing to wfile for compatibility with; 1925/// Which(const char*,const char*,EAccessMode) version.; 1926 ; 1927const char *TUnixSystem::FindFile(const char *search, TString& wfil, EAccessMode mode); 1928{; 1929 TString show;; 1930 if (gEnv->GetValue(""Root.S",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:59690,Security,access,access,59690,"it will be; 1908/// set to the modtime. Returns 0 on success and -1 in case of error.; 1909 ; 1910int TUnixSystem::Utime(const char *file, Long_t modtime, Long_t actime); 1911{; 1912 if (!actime); 1913 actime = modtime;; 1914 ; 1915 struct utimbuf t;; 1916 t.actime = (time_t)actime;; 1917 t.modtime = (time_t)modtime;; 1918 return ::utime(file, &t);; 1919}; 1920 ; 1921////////////////////////////////////////////////////////////////////////////////; 1922/// Find location of file ""wfil"" in a search path.; 1923/// The search path is specified as a : separated list of directories.; 1924/// Return value is pointing to wfile for compatibility with; 1925/// Which(const char*,const char*,EAccessMode) version.; 1926 ; 1927const char *TUnixSystem::FindFile(const char *search, TString& wfil, EAccessMode mode); 1928{; 1929 TString show;; 1930 if (gEnv->GetValue(""Root.ShowPath"", 0)); 1931 show.Form(""Which: %s ="", wfil.Data());; 1932 ; 1933 gSystem->ExpandPathName(wfil);; 1934 ; 1935 if (wfil[0] == '/') {; 1936#if defined(R__SEEK64); 1937 struct stat64 finfo;; 1938 if (access(wfil.Data(), mode) == 0 &&; 1939 stat64(wfil.Data(), &finfo) == 0 && S_ISREG(finfo.st_mode)) {; 1940#else; 1941 struct stat finfo;; 1942 if (access(wfil.Data(), mode) == 0 &&; 1943 stat(wfil.Data(), &finfo) == 0 && S_ISREG(finfo.st_mode)) {; 1944#endif; 1945 if (show != """"); 1946 Printf(""%s %s"", show.Data(), wfil.Data());; 1947 return wfil.Data();; 1948 }; 1949 if (show != """"); 1950 Printf(""%s <not found>"", show.Data());; 1951 wfil = """";; 1952 return nullptr;; 1953 }; 1954 ; 1955 if (!search); 1956 search = ""."";; 1957 ; 1958 TString apwd(gSystem->WorkingDirectory());; 1959 apwd += ""/"";; 1960 for (const char* ptr = search; *ptr;) {; 1961 TString name;; 1962 if (*ptr != '/' && *ptr !='$' && *ptr != '~'); 1963 name = apwd;; 1964 const char* posEndOfPart = strchr(ptr, ':');; 1965 if (posEndOfPart) {; 1966 name.Append(ptr, posEndOfPart - ptr);; 1967 ptr = posEndOfPart + 1; // skip ':'; 1968 } else {; 1969 name.Appe",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:59838,Security,access,access,59838," 1913 actime = modtime;; 1914 ; 1915 struct utimbuf t;; 1916 t.actime = (time_t)actime;; 1917 t.modtime = (time_t)modtime;; 1918 return ::utime(file, &t);; 1919}; 1920 ; 1921////////////////////////////////////////////////////////////////////////////////; 1922/// Find location of file ""wfil"" in a search path.; 1923/// The search path is specified as a : separated list of directories.; 1924/// Return value is pointing to wfile for compatibility with; 1925/// Which(const char*,const char*,EAccessMode) version.; 1926 ; 1927const char *TUnixSystem::FindFile(const char *search, TString& wfil, EAccessMode mode); 1928{; 1929 TString show;; 1930 if (gEnv->GetValue(""Root.ShowPath"", 0)); 1931 show.Form(""Which: %s ="", wfil.Data());; 1932 ; 1933 gSystem->ExpandPathName(wfil);; 1934 ; 1935 if (wfil[0] == '/') {; 1936#if defined(R__SEEK64); 1937 struct stat64 finfo;; 1938 if (access(wfil.Data(), mode) == 0 &&; 1939 stat64(wfil.Data(), &finfo) == 0 && S_ISREG(finfo.st_mode)) {; 1940#else; 1941 struct stat finfo;; 1942 if (access(wfil.Data(), mode) == 0 &&; 1943 stat(wfil.Data(), &finfo) == 0 && S_ISREG(finfo.st_mode)) {; 1944#endif; 1945 if (show != """"); 1946 Printf(""%s %s"", show.Data(), wfil.Data());; 1947 return wfil.Data();; 1948 }; 1949 if (show != """"); 1950 Printf(""%s <not found>"", show.Data());; 1951 wfil = """";; 1952 return nullptr;; 1953 }; 1954 ; 1955 if (!search); 1956 search = ""."";; 1957 ; 1958 TString apwd(gSystem->WorkingDirectory());; 1959 apwd += ""/"";; 1960 for (const char* ptr = search; *ptr;) {; 1961 TString name;; 1962 if (*ptr != '/' && *ptr !='$' && *ptr != '~'); 1963 name = apwd;; 1964 const char* posEndOfPart = strchr(ptr, ':');; 1965 if (posEndOfPart) {; 1966 name.Append(ptr, posEndOfPart - ptr);; 1967 ptr = posEndOfPart + 1; // skip ':'; 1968 } else {; 1969 name.Append(ptr);; 1970 ptr += strlen(ptr);; 1971 }; 1972 ; 1973 if (!name.EndsWith(""/"")); 1974 name += '/';; 1975 name += wfil;; 1976 ; 1977 gSystem->ExpandPathName(name);; 1978#if defined(R__SEEK64); 19",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:60849,Security,access,access,60849,"(finfo.st_mode)) {; 1940#else; 1941 struct stat finfo;; 1942 if (access(wfil.Data(), mode) == 0 &&; 1943 stat(wfil.Data(), &finfo) == 0 && S_ISREG(finfo.st_mode)) {; 1944#endif; 1945 if (show != """"); 1946 Printf(""%s %s"", show.Data(), wfil.Data());; 1947 return wfil.Data();; 1948 }; 1949 if (show != """"); 1950 Printf(""%s <not found>"", show.Data());; 1951 wfil = """";; 1952 return nullptr;; 1953 }; 1954 ; 1955 if (!search); 1956 search = ""."";; 1957 ; 1958 TString apwd(gSystem->WorkingDirectory());; 1959 apwd += ""/"";; 1960 for (const char* ptr = search; *ptr;) {; 1961 TString name;; 1962 if (*ptr != '/' && *ptr !='$' && *ptr != '~'); 1963 name = apwd;; 1964 const char* posEndOfPart = strchr(ptr, ':');; 1965 if (posEndOfPart) {; 1966 name.Append(ptr, posEndOfPart - ptr);; 1967 ptr = posEndOfPart + 1; // skip ':'; 1968 } else {; 1969 name.Append(ptr);; 1970 ptr += strlen(ptr);; 1971 }; 1972 ; 1973 if (!name.EndsWith(""/"")); 1974 name += '/';; 1975 name += wfil;; 1976 ; 1977 gSystem->ExpandPathName(name);; 1978#if defined(R__SEEK64); 1979 struct stat64 finfo;; 1980 if (access(name.Data(), mode) == 0 &&; 1981 stat64(name.Data(), &finfo) == 0 && S_ISREG(finfo.st_mode)) {; 1982#else; 1983 struct stat finfo;; 1984 if (access(name.Data(), mode) == 0 &&; 1985 stat(name.Data(), &finfo) == 0 && S_ISREG(finfo.st_mode)) {; 1986#endif; 1987 if (show != """"); 1988 Printf(""%s %s"", show.Data(), name.Data());; 1989 wfil = name;; 1990 return wfil.Data();; 1991 }; 1992 }; 1993 ; 1994 if (show != """"); 1995 Printf(""%s <not found>"", show.Data());; 1996 wfil = """";; 1997 return nullptr;; 1998}; 1999 ; 2000//---- Users & Groups ----------------------------------------------------------; 2001 ; 2002////////////////////////////////////////////////////////////////////////////////; 2003/// Returns the user's id. If user = 0, returns current user's id.; 2004 ; 2005Int_t TUnixSystem::GetUid(const char *user); 2006{; 2007 if (!user || !user[0]); 2008 return getuid();; 2009 else {; 2010 struct passwd *apwd =",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:60997,Security,access,access,60997,"946 Printf(""%s %s"", show.Data(), wfil.Data());; 1947 return wfil.Data();; 1948 }; 1949 if (show != """"); 1950 Printf(""%s <not found>"", show.Data());; 1951 wfil = """";; 1952 return nullptr;; 1953 }; 1954 ; 1955 if (!search); 1956 search = ""."";; 1957 ; 1958 TString apwd(gSystem->WorkingDirectory());; 1959 apwd += ""/"";; 1960 for (const char* ptr = search; *ptr;) {; 1961 TString name;; 1962 if (*ptr != '/' && *ptr !='$' && *ptr != '~'); 1963 name = apwd;; 1964 const char* posEndOfPart = strchr(ptr, ':');; 1965 if (posEndOfPart) {; 1966 name.Append(ptr, posEndOfPart - ptr);; 1967 ptr = posEndOfPart + 1; // skip ':'; 1968 } else {; 1969 name.Append(ptr);; 1970 ptr += strlen(ptr);; 1971 }; 1972 ; 1973 if (!name.EndsWith(""/"")); 1974 name += '/';; 1975 name += wfil;; 1976 ; 1977 gSystem->ExpandPathName(name);; 1978#if defined(R__SEEK64); 1979 struct stat64 finfo;; 1980 if (access(name.Data(), mode) == 0 &&; 1981 stat64(name.Data(), &finfo) == 0 && S_ISREG(finfo.st_mode)) {; 1982#else; 1983 struct stat finfo;; 1984 if (access(name.Data(), mode) == 0 &&; 1985 stat(name.Data(), &finfo) == 0 && S_ISREG(finfo.st_mode)) {; 1986#endif; 1987 if (show != """"); 1988 Printf(""%s %s"", show.Data(), name.Data());; 1989 wfil = name;; 1990 return wfil.Data();; 1991 }; 1992 }; 1993 ; 1994 if (show != """"); 1995 Printf(""%s <not found>"", show.Data());; 1996 wfil = """";; 1997 return nullptr;; 1998}; 1999 ; 2000//---- Users & Groups ----------------------------------------------------------; 2001 ; 2002////////////////////////////////////////////////////////////////////////////////; 2003/// Returns the user's id. If user = 0, returns current user's id.; 2004 ; 2005Int_t TUnixSystem::GetUid(const char *user); 2006{; 2007 if (!user || !user[0]); 2008 return getuid();; 2009 else {; 2010 struct passwd *apwd = getpwnam(user);; 2011 if (apwd); 2012 return apwd->pw_uid;; 2013 }; 2014 return 0;; 2015}; 2016 ; 2017////////////////////////////////////////////////////////////////////////////////; 2018/// Returns",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:197932,Security,access,access,197932,"FileHandler(TFileHandler *fh)Remove a file handler from the list of file handlers.Definition TSystem.cxx:564; TSystem::fSigcntInt_t fSigcntDefinition TSystem.h:283; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::GetDirEntryvirtual const char * GetDirEntry(void *dirp)Get a directory entry. Returns 0 if no more entries.Definition TSystem.cxx:853; TSystem::Initvirtual Bool_t Init()Initialize the OS interface.Definition TSystem.cxx:183; TSystem::AddTimervirtual void AddTimer(TTimer *t)Add timer to list of system timers.Definition TSystem.cxx:471; TSystem::fWritereadyTFdSet * fWritereadyFiles with reads waiting.Definition TSystem.h:278; TSystem::ClosePipevirtual int ClosePipe(FILE *pipe)Close the pipe.Definition TSystem.cxx:671; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TSystem::AddSignalHandlervirtual void AddSignalHandler(TSignalHandler *sh)Add a signal handler to list of system signal handlers.Definition TSystem.cxx:532; TSystem::fSignalHandlerTSeqCollection *",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:197966,Security,access,access,197966,"FileHandler(TFileHandler *fh)Remove a file handler from the list of file handlers.Definition TSystem.cxx:564; TSystem::fSigcntInt_t fSigcntDefinition TSystem.h:283; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; TSystem::ListLibrariesvirtual void ListLibraries(const char *regexp="""")List the loaded shared libraries.Definition TSystem.cxx:2085; TSystem::OpenPipevirtual FILE * OpenPipe(const char *command, const char *mode)Open a pipe.Definition TSystem.cxx:662; TSystem::GetPathInfoint GetPathInfo(const char *path, Long_t *id, Long_t *size, Long_t *flags, Long_t *modtime)Get info about a file: id, size, flags, modification time.Definition TSystem.cxx:1398; TSystem::PrependPathNamevirtual const char * PrependPathName(const char *dir, TString &name)Concatenate a directory and a file name.Definition TSystem.cxx:1081; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::GetDirEntryvirtual const char * GetDirEntry(void *dirp)Get a directory entry. Returns 0 if no more entries.Definition TSystem.cxx:853; TSystem::Initvirtual Bool_t Init()Initialize the OS interface.Definition TSystem.cxx:183; TSystem::AddTimervirtual void AddTimer(TTimer *t)Add timer to list of system timers.Definition TSystem.cxx:471; TSystem::fWritereadyTFdSet * fWritereadyFiles with reads waiting.Definition TSystem.h:278; TSystem::ClosePipevirtual int ClosePipe(FILE *pipe)Close the pipe.Definition TSystem.cxx:671; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TSystem::AddSignalHandlervirtual void AddSignalHandler(TSignalHandler *sh)Add a signal handler to list of system signal handlers.Definition TSystem.cxx:532; TSystem::fSignalHandlerTSeqCollection *",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:209138,Security,access,access,209138," 1 1995.Definition TUnixSystem.cxx:2970; TUnixSystem::UnixResetSignalstatic void UnixResetSignal(ESignals sig)Restore old signal handler for specified signal.Definition TUnixSystem.cxx:3821; TUnixSystem::GetServiceByNameint GetServiceByName(const char *service) overrideGet port # of internet service.Definition TUnixSystem.cxx:3171; TUnixSystem::FindFileconst char * FindFile(const char *search, TString &file, EAccessMode mode=kFileExists) overrideFind location of file ""wfil"" in a search path.Definition TUnixSystem.cxx:1927; TUnixSystem::SigAlarmInterruptsSyscallsvoid SigAlarmInterruptsSyscalls(Bool_t set) overrideWhen the argument is true the SIGALRM signal handler is set so that interrupted syscalls will not be ...Definition TUnixSystem.cxx:908; TUnixSystem::UnixUdpServicestatic int UnixUdpService(int port, int backlog)Open a socket, bind to it and start listening for UDP connections on the port.Definition TUnixSystem.cxx:4373; TUnixSystem::Utimeint Utime(const char *file, Long_t modtime, Long_t actime) overrideSet a files modification and access times.Definition TUnixSystem.cxx:1910; TUnixSystem::GetLinkedLibrariesconst char * GetLinkedLibraries() overrideGet list of shared libraries loaded at the start of the executable.Definition TUnixSystem.cxx:2857; TUnixSystem::GetErrorconst char * GetError() overrideReturn system error string.Definition TUnixSystem.cxx:719; TUnixSystem::GetWorkingDirectorystd::string GetWorkingDirectory() const overrideReturn working directory.Definition TUnixSystem.cxx:1463; TUnixSystem::AccessPathNameBool_t AccessPathName(const char *path, EAccessMode mode=kFileExists) overrideReturns FALSE if one can access a file using the specified access mode.Definition TUnixSystem.cxx:1579; TUnixSystem::TempFileNameFILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr) overrideCreate a secure temporary file by appending a unique 6 letter string to base.Definition TUnixSystem.cxx:1523; TUnixSystem::DispatchOneEventvoid Di",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:209737,Security,access,access,209737,"et) overrideWhen the argument is true the SIGALRM signal handler is set so that interrupted syscalls will not be ...Definition TUnixSystem.cxx:908; TUnixSystem::UnixUdpServicestatic int UnixUdpService(int port, int backlog)Open a socket, bind to it and start listening for UDP connections on the port.Definition TUnixSystem.cxx:4373; TUnixSystem::Utimeint Utime(const char *file, Long_t modtime, Long_t actime) overrideSet a files modification and access times.Definition TUnixSystem.cxx:1910; TUnixSystem::GetLinkedLibrariesconst char * GetLinkedLibraries() overrideGet list of shared libraries loaded at the start of the executable.Definition TUnixSystem.cxx:2857; TUnixSystem::GetErrorconst char * GetError() overrideReturn system error string.Definition TUnixSystem.cxx:719; TUnixSystem::GetWorkingDirectorystd::string GetWorkingDirectory() const overrideReturn working directory.Definition TUnixSystem.cxx:1463; TUnixSystem::AccessPathNameBool_t AccessPathName(const char *path, EAccessMode mode=kFileExists) overrideReturns FALSE if one can access a file using the specified access mode.Definition TUnixSystem.cxx:1579; TUnixSystem::TempFileNameFILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr) overrideCreate a secure temporary file by appending a unique 6 letter string to base.Definition TUnixSystem.cxx:1523; TUnixSystem::DispatchOneEventvoid DispatchOneEvent(Bool_t pendingOnly=kFALSE) overrideDispatch a single event.Definition TUnixSystem.cxx:1093; TUnixSystem::Chmodint Chmod(const char *file, UInt_t mode) overrideSet the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TUnixSystem.cxx:1893; TUnixSystem::PrependPathNameconst char * PrependPathName(const char *dir, TString &name) overrideConcatenate a directory and a file name.Definition TUnixSystem.cxx:1552; TUnixSystem::DispatchTimersBool_t DispatchTimers(Bool_t mode)Handle and dispatch timers.Definition TUnixSystem.cxx:2979; TUnixSystem::IgnoreSignalvoid IgnoreSi",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:209771,Security,access,access,209771,"et) overrideWhen the argument is true the SIGALRM signal handler is set so that interrupted syscalls will not be ...Definition TUnixSystem.cxx:908; TUnixSystem::UnixUdpServicestatic int UnixUdpService(int port, int backlog)Open a socket, bind to it and start listening for UDP connections on the port.Definition TUnixSystem.cxx:4373; TUnixSystem::Utimeint Utime(const char *file, Long_t modtime, Long_t actime) overrideSet a files modification and access times.Definition TUnixSystem.cxx:1910; TUnixSystem::GetLinkedLibrariesconst char * GetLinkedLibraries() overrideGet list of shared libraries loaded at the start of the executable.Definition TUnixSystem.cxx:2857; TUnixSystem::GetErrorconst char * GetError() overrideReturn system error string.Definition TUnixSystem.cxx:719; TUnixSystem::GetWorkingDirectorystd::string GetWorkingDirectory() const overrideReturn working directory.Definition TUnixSystem.cxx:1463; TUnixSystem::AccessPathNameBool_t AccessPathName(const char *path, EAccessMode mode=kFileExists) overrideReturns FALSE if one can access a file using the specified access mode.Definition TUnixSystem.cxx:1579; TUnixSystem::TempFileNameFILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr) overrideCreate a secure temporary file by appending a unique 6 letter string to base.Definition TUnixSystem.cxx:1523; TUnixSystem::DispatchOneEventvoid DispatchOneEvent(Bool_t pendingOnly=kFALSE) overrideDispatch a single event.Definition TUnixSystem.cxx:1093; TUnixSystem::Chmodint Chmod(const char *file, UInt_t mode) overrideSet the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TUnixSystem.cxx:1893; TUnixSystem::PrependPathNameconst char * PrependPathName(const char *dir, TString &name) overrideConcatenate a directory and a file name.Definition TUnixSystem.cxx:1552; TUnixSystem::DispatchTimersBool_t DispatchTimers(Bool_t mode)Handle and dispatch timers.Definition TUnixSystem.cxx:2979; TUnixSystem::IgnoreSignalvoid IgnoreSi",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:209946,Security,secur,secure,209946,"og)Open a socket, bind to it and start listening for UDP connections on the port.Definition TUnixSystem.cxx:4373; TUnixSystem::Utimeint Utime(const char *file, Long_t modtime, Long_t actime) overrideSet a files modification and access times.Definition TUnixSystem.cxx:1910; TUnixSystem::GetLinkedLibrariesconst char * GetLinkedLibraries() overrideGet list of shared libraries loaded at the start of the executable.Definition TUnixSystem.cxx:2857; TUnixSystem::GetErrorconst char * GetError() overrideReturn system error string.Definition TUnixSystem.cxx:719; TUnixSystem::GetWorkingDirectorystd::string GetWorkingDirectory() const overrideReturn working directory.Definition TUnixSystem.cxx:1463; TUnixSystem::AccessPathNameBool_t AccessPathName(const char *path, EAccessMode mode=kFileExists) overrideReturns FALSE if one can access a file using the specified access mode.Definition TUnixSystem.cxx:1579; TUnixSystem::TempFileNameFILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr) overrideCreate a secure temporary file by appending a unique 6 letter string to base.Definition TUnixSystem.cxx:1523; TUnixSystem::DispatchOneEventvoid DispatchOneEvent(Bool_t pendingOnly=kFALSE) overrideDispatch a single event.Definition TUnixSystem.cxx:1093; TUnixSystem::Chmodint Chmod(const char *file, UInt_t mode) overrideSet the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TUnixSystem.cxx:1893; TUnixSystem::PrependPathNameconst char * PrependPathName(const char *dir, TString &name) overrideConcatenate a directory and a file name.Definition TUnixSystem.cxx:1552; TUnixSystem::DispatchTimersBool_t DispatchTimers(Bool_t mode)Handle and dispatch timers.Definition TUnixSystem.cxx:2979; TUnixSystem::IgnoreSignalvoid IgnoreSignal(ESignals sig, Bool_t ignore=kTRUE) overrideIf ignore is true ignore the specified signal, else restore previous behaviour.Definition TUnixSystem.cxx:895; TUnixSystem::ListSymbolsvoid ListSymbols(const char *module, ",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:19825,Testability,log,logged,19825,"// Set the application name (from command line, argv[0]) and copy it in; 637/// gProgName. Copy the application pathname in gProgPath.; 638/// If name is 0 let the system set the actual executable name and path; 639/// (works on MacOS X and Linux).; 640 ; 641void TUnixSystem::SetProgname(const char *name); 642{; 643 if (gProgName); 644 delete [] gProgName;; 645 if (gProgPath); 646 delete [] gProgPath;; 647 ; 648 if (!name || !*name) {; 649 name = GetExePath();; 650 gProgName = StrDup(BaseName(name));; 651 gProgPath = StrDup(DirName(name));; 652 } else {; 653 gProgName = StrDup(BaseName(name));; 654 char *w = Which(Getenv(""PATH""), gProgName);; 655 gProgPath = StrDup(DirName(w));; 656 delete [] w;; 657 }; 658}; 659 ; 660////////////////////////////////////////////////////////////////////////////////; 661/// Set DISPLAY environment variable based on utmp entry. Only for UNIX.; 662 ; 663void TUnixSystem::SetDisplay(); 664{; 665 if (!Getenv(""DISPLAY"")) {; 666 char *tty = ::ttyname(0); // device user is logged in on; 667 if (tty) {; 668 tty += 5; // remove ""/dev/""; 669 ; 670 TUtmpContent utmp;; 671 utmp.ReadUtmpFile();; 672 ; 673 STRUCT_UTMP *utmp_entry = utmp.SearchUtmpEntry(tty);; 674 if (utmp_entry) {; 675 if (utmp_entry->ut_host[0]) {; 676 TString disp;; 677 for (unsigned n = 0; (n < sizeof(utmp_entry->ut_host)) && utmp_entry->ut_host[n]; n++); 678 disp.Append(utmp_entry->ut_host[n]);; 679 if (disp.First(':') == kNPOS); 680 disp.Append("":0.0"");; 681 Setenv(""DISPLAY"", disp.Data());; 682 Warning(""SetDisplay"", ""DISPLAY not set, setting it to %s"", disp.Data());; 683 }; 684#ifndef UTMP_NO_ADDR; 685 else if (utmp_entry->ut_addr) {; 686 ; 687 struct sockaddr_in addr;; 688 addr.sin_family = AF_INET;; 689 addr.sin_port = 0;; 690 memcpy(&addr.sin_addr, &utmp_entry->ut_addr, sizeof(addr.sin_addr));; 691 memset(&addr.sin_zero[0], 0, sizeof(addr.sin_zero));; 692 struct sockaddr *sa = (struct sockaddr *) &addr; // input; 693 ; 694 char hbuf[NI_MAXHOST + 4];; 695 if (getnameinfo(sa,",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:20896,Testability,assert,assert,20896,"e user is logged in on; 667 if (tty) {; 668 tty += 5; // remove ""/dev/""; 669 ; 670 TUtmpContent utmp;; 671 utmp.ReadUtmpFile();; 672 ; 673 STRUCT_UTMP *utmp_entry = utmp.SearchUtmpEntry(tty);; 674 if (utmp_entry) {; 675 if (utmp_entry->ut_host[0]) {; 676 TString disp;; 677 for (unsigned n = 0; (n < sizeof(utmp_entry->ut_host)) && utmp_entry->ut_host[n]; n++); 678 disp.Append(utmp_entry->ut_host[n]);; 679 if (disp.First(':') == kNPOS); 680 disp.Append("":0.0"");; 681 Setenv(""DISPLAY"", disp.Data());; 682 Warning(""SetDisplay"", ""DISPLAY not set, setting it to %s"", disp.Data());; 683 }; 684#ifndef UTMP_NO_ADDR; 685 else if (utmp_entry->ut_addr) {; 686 ; 687 struct sockaddr_in addr;; 688 addr.sin_family = AF_INET;; 689 addr.sin_port = 0;; 690 memcpy(&addr.sin_addr, &utmp_entry->ut_addr, sizeof(addr.sin_addr));; 691 memset(&addr.sin_zero[0], 0, sizeof(addr.sin_zero));; 692 struct sockaddr *sa = (struct sockaddr *) &addr; // input; 693 ; 694 char hbuf[NI_MAXHOST + 4];; 695 if (getnameinfo(sa, sizeof(struct sockaddr), hbuf, sizeof(hbuf), nullptr, 0, NI_NAMEREQD) == 0) {; 696 assert( strlen(hbuf) < NI_MAXHOST );; 697 strlcat(hbuf, "":0.0"", sizeof(hbuf));; 698 Setenv(""DISPLAY"", hbuf);; 699 Warning(""SetDisplay"", ""DISPLAY not set, setting it to %s"",; 700 hbuf);; 701 }; 702 }; 703#endif; 704 }; 705 }; 706#ifndef R__HAS_COCOA; 707 if (!gROOT->IsBatch() && !getenv(""DISPLAY"")) {; 708 Error(""SetDisplay"", ""Can't figure out DISPLAY, set it manually\n""; 709 ""In case you run a remote ssh session, restart your ssh session with:\n""; 710 ""=========> ssh -Y"");; 711 }; 712#endif; 713 }; 714}; 715 ; 716////////////////////////////////////////////////////////////////////////////////; 717/// Return system error string.; 718 ; 719const char *TUnixSystem::GetError(); 720{; 721 Int_t err = GetErrno();; 722 if (err == 0 && GetLastErrorString() != """"); 723 return GetLastErrorString();; 724 ; 725#if defined(R__SOLARIS) || defined (R__LINUX) || defined(R__AIX) || \; 726 defined(R__FBSD) || defined(R__OBSD)",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:81988,Testability,log,log,81988,"AVE_RLD_INTERFACE_H) // tru64; 2583 // Tru64 stack walk. Uses the exception handling library and the; 2584 // run-time linker's core functions (loader(5)). FIXME: Tru64; 2585 // should have _RLD_DLADDR like IRIX below. Verify and update.; 2586 ; 2587 char buffer [128];; 2588 sigcontext context;; 2589 int rc = 0;; 2590 ; 2591 exc_capture_context (&context);; 2592 while (!rc && context.sc_pc) {; 2593 // FIXME: Elf32?; 2594 pdsc_crd *func, *base, *crd; 2595 = exc_remote_lookup_function_entry(0, 0, context.sc_pc, 0, &func, &base);; 2596 Elf32_Addr addr = PDSC_CRD_BEGIN_ADDRESS(base, func);; 2597 // const char *name = _rld_address_to_name(addr);; 2598 const char *name = ""<unknown function>"";; 2599 sprintf(buffer, "" 0x%012lx %.200s + 0x%lx\n"",; 2600 context.sc_pc, name, context.sc_pc - addr);; 2601 write(fd, buffer, ::strlen(buffer));; 2602 rc = exc_virtual_unwind(0, &context);; 2603 }; 2604#endif; 2605#else //R__MACOSX; 2606 macosx_backtrace();; 2607#endif //R__MACOSX; 2608}; 2609 ; 2610//---- System Logging ----------------------------------------------------------; 2611 ; 2612////////////////////////////////////////////////////////////////////////////////; 2613/// Open connection to system log daemon. For the use of the options and; 2614/// facility see the Unix openlog man page.; 2615 ; 2616void TUnixSystem::Openlog(const char *name, Int_t options, ELogFacility facility); 2617{; 2618 int fac = 0;; 2619 ; 2620 switch (facility) {; 2621 case kLogLocal0:; 2622 fac = LOG_LOCAL0;; 2623 break;; 2624 case kLogLocal1:; 2625 fac = LOG_LOCAL1;; 2626 break;; 2627 case kLogLocal2:; 2628 fac = LOG_LOCAL2;; 2629 break;; 2630 case kLogLocal3:; 2631 fac = LOG_LOCAL3;; 2632 break;; 2633 case kLogLocal4:; 2634 fac = LOG_LOCAL4;; 2635 break;; 2636 case kLogLocal5:; 2637 fac = LOG_LOCAL5;; 2638 break;; 2639 case kLogLocal6:; 2640 fac = LOG_LOCAL6;; 2641 break;; 2642 case kLogLocal7:; 2643 fac = LOG_LOCAL7;; 2644 break;; 2645 }; 2646 ; 2647 ::openlog(name, options, fac);; 2648}; 2649 ; 26",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:82915,Testability,log,logging,82915,"//////; 2613/// Open connection to system log daemon. For the use of the options and; 2614/// facility see the Unix openlog man page.; 2615 ; 2616void TUnixSystem::Openlog(const char *name, Int_t options, ELogFacility facility); 2617{; 2618 int fac = 0;; 2619 ; 2620 switch (facility) {; 2621 case kLogLocal0:; 2622 fac = LOG_LOCAL0;; 2623 break;; 2624 case kLogLocal1:; 2625 fac = LOG_LOCAL1;; 2626 break;; 2627 case kLogLocal2:; 2628 fac = LOG_LOCAL2;; 2629 break;; 2630 case kLogLocal3:; 2631 fac = LOG_LOCAL3;; 2632 break;; 2633 case kLogLocal4:; 2634 fac = LOG_LOCAL4;; 2635 break;; 2636 case kLogLocal5:; 2637 fac = LOG_LOCAL5;; 2638 break;; 2639 case kLogLocal6:; 2640 fac = LOG_LOCAL6;; 2641 break;; 2642 case kLogLocal7:; 2643 fac = LOG_LOCAL7;; 2644 break;; 2645 }; 2646 ; 2647 ::openlog(name, options, fac);; 2648}; 2649 ; 2650////////////////////////////////////////////////////////////////////////////////; 2651/// Send mess to syslog daemon. Level is the logging level and mess the; 2652/// message that will be written on the log.; 2653 ; 2654void TUnixSystem::Syslog(ELogLevel level, const char *mess); 2655{; 2656 // ELogLevel matches exactly the Unix values.; 2657 ::syslog(level, ""%s"", mess);; 2658}; 2659 ; 2660////////////////////////////////////////////////////////////////////////////////; 2661/// Close connection to system log daemon.; 2662 ; 2663void TUnixSystem::Closelog(); 2664{; 2665 ::closelog();; 2666}; 2667 ; 2668//---- Standard output redirection ---------------------------------------------; 2669 ; 2670////////////////////////////////////////////////////////////////////////////////; 2671/// Redirect standard output (stdout, stderr) to the specified file.; 2672/// If the file argument is 0 the output is set again to stderr, stdout.; 2673/// The second argument specifies whether the output should be added to the; 2674/// file (""a"", default) or the file be truncated before (""w"").; 2675/// This function saves internally the current state into a static struct",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:82987,Testability,log,log,82987,"//////; 2613/// Open connection to system log daemon. For the use of the options and; 2614/// facility see the Unix openlog man page.; 2615 ; 2616void TUnixSystem::Openlog(const char *name, Int_t options, ELogFacility facility); 2617{; 2618 int fac = 0;; 2619 ; 2620 switch (facility) {; 2621 case kLogLocal0:; 2622 fac = LOG_LOCAL0;; 2623 break;; 2624 case kLogLocal1:; 2625 fac = LOG_LOCAL1;; 2626 break;; 2627 case kLogLocal2:; 2628 fac = LOG_LOCAL2;; 2629 break;; 2630 case kLogLocal3:; 2631 fac = LOG_LOCAL3;; 2632 break;; 2633 case kLogLocal4:; 2634 fac = LOG_LOCAL4;; 2635 break;; 2636 case kLogLocal5:; 2637 fac = LOG_LOCAL5;; 2638 break;; 2639 case kLogLocal6:; 2640 fac = LOG_LOCAL6;; 2641 break;; 2642 case kLogLocal7:; 2643 fac = LOG_LOCAL7;; 2644 break;; 2645 }; 2646 ; 2647 ::openlog(name, options, fac);; 2648}; 2649 ; 2650////////////////////////////////////////////////////////////////////////////////; 2651/// Send mess to syslog daemon. Level is the logging level and mess the; 2652/// message that will be written on the log.; 2653 ; 2654void TUnixSystem::Syslog(ELogLevel level, const char *mess); 2655{; 2656 // ELogLevel matches exactly the Unix values.; 2657 ::syslog(level, ""%s"", mess);; 2658}; 2659 ; 2660////////////////////////////////////////////////////////////////////////////////; 2661/// Close connection to system log daemon.; 2662 ; 2663void TUnixSystem::Closelog(); 2664{; 2665 ::closelog();; 2666}; 2667 ; 2668//---- Standard output redirection ---------------------------------------------; 2669 ; 2670////////////////////////////////////////////////////////////////////////////////; 2671/// Redirect standard output (stdout, stderr) to the specified file.; 2672/// If the file argument is 0 the output is set again to stderr, stdout.; 2673/// The second argument specifies whether the output should be added to the; 2674/// file (""a"", default) or the file be truncated before (""w"").; 2675/// This function saves internally the current state into a static struct",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:83294,Testability,log,log,83294,"switch (facility) {; 2621 case kLogLocal0:; 2622 fac = LOG_LOCAL0;; 2623 break;; 2624 case kLogLocal1:; 2625 fac = LOG_LOCAL1;; 2626 break;; 2627 case kLogLocal2:; 2628 fac = LOG_LOCAL2;; 2629 break;; 2630 case kLogLocal3:; 2631 fac = LOG_LOCAL3;; 2632 break;; 2633 case kLogLocal4:; 2634 fac = LOG_LOCAL4;; 2635 break;; 2636 case kLogLocal5:; 2637 fac = LOG_LOCAL5;; 2638 break;; 2639 case kLogLocal6:; 2640 fac = LOG_LOCAL6;; 2641 break;; 2642 case kLogLocal7:; 2643 fac = LOG_LOCAL7;; 2644 break;; 2645 }; 2646 ; 2647 ::openlog(name, options, fac);; 2648}; 2649 ; 2650////////////////////////////////////////////////////////////////////////////////; 2651/// Send mess to syslog daemon. Level is the logging level and mess the; 2652/// message that will be written on the log.; 2653 ; 2654void TUnixSystem::Syslog(ELogLevel level, const char *mess); 2655{; 2656 // ELogLevel matches exactly the Unix values.; 2657 ::syslog(level, ""%s"", mess);; 2658}; 2659 ; 2660////////////////////////////////////////////////////////////////////////////////; 2661/// Close connection to system log daemon.; 2662 ; 2663void TUnixSystem::Closelog(); 2664{; 2665 ::closelog();; 2666}; 2667 ; 2668//---- Standard output redirection ---------------------------------------------; 2669 ; 2670////////////////////////////////////////////////////////////////////////////////; 2671/// Redirect standard output (stdout, stderr) to the specified file.; 2672/// If the file argument is 0 the output is set again to stderr, stdout.; 2673/// The second argument specifies whether the output should be added to the; 2674/// file (""a"", default) or the file be truncated before (""w"").; 2675/// This function saves internally the current state into a static structure.; 2676/// The call can be made reentrant by specifying the opaque structure pointed; 2677/// by 'h', which is filled with the relevant information. The handle 'h'; 2678/// obtained on the first call must then be used in any subsequent call,; 2679/// included ShowO",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:207834,Testability,log,log,207834,"Unsetenvvoid Unsetenv(const char *name) overrideUnset environment variable.Definition TUnixSystem.cxx:2145; TUnixSystem::~TUnixSystemvirtual ~TUnixSystem()Reset to original state.Definition TUnixSystem.cxx:581; TUnixSystem::Abortvoid Abort(int code=0) overrideAbort the application.Definition TUnixSystem.cxx:2202; TUnixSystem::Syslogvoid Syslog(ELogLevel level, const char *mess) overrideSend mess to syslog daemon.Definition TUnixSystem.cxx:2654; TUnixSystem::GetGroupInfoUserGroup_t * GetGroupInfo(Int_t gid) overrideReturns all group info in the UserGroup_t structure.Definition TUnixSystem.cxx:2099; TUnixSystem::GetUidInt_t GetUid(const char *user=nullptr) overrideReturns the user's id. If user = 0, returns current user's id.Definition TUnixSystem.cxx:2005; TUnixSystem::ExpandPathNameBool_t ExpandPathName(TString &patbuf) overrideExpand a pathname getting rid of special shell characters like ~.Definition TUnixSystem.cxx:1749; TUnixSystem::Openlogvoid Openlog(const char *name, Int_t options, ELogFacility facility) overrideOpen connection to system log daemon.Definition TUnixSystem.cxx:2616; TUnixSystem::AcceptConnectionint AcceptConnection(int sock) overrideAccept a connection.Definition TUnixSystem.cxx:3276; TUnixSystem::NowTTime Now() overrideGet current time in milliseconds since 0:00 Jan 1 1995.Definition TUnixSystem.cxx:2970; TUnixSystem::UnixResetSignalstatic void UnixResetSignal(ESignals sig)Restore old signal handler for specified signal.Definition TUnixSystem.cxx:3821; TUnixSystem::GetServiceByNameint GetServiceByName(const char *service) overrideGet port # of internet service.Definition TUnixSystem.cxx:3171; TUnixSystem::FindFileconst char * FindFile(const char *search, TString &file, EAccessMode mode=kFileExists) overrideFind location of file ""wfil"" in a search path.Definition TUnixSystem.cxx:1927; TUnixSystem::SigAlarmInterruptsSyscallsvoid SigAlarmInterruptsSyscalls(Bool_t set) overrideWhen the argument is true the SIGALRM signal handler is set so that int",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:218448,Testability,log,log,218448,"ss file creation mode mask.Definition TUnixSystem.cxx:1901; TUnixSystem::UnixFilestatstatic int UnixFilestat(const char *path, FileStat_t &buf)Get info about a file.Definition TUnixSystem.cxx:4039; TUnixSystem::UnixRecvstatic int UnixRecv(int sock, void *buf, int len, int flag)Receive exactly length bytes into buffer.Definition TUnixSystem.cxx:4508; TUnixSystem::GetEffectiveUidInt_t GetEffectiveUid() overrideReturns the effective user id.Definition TUnixSystem.cxx:2021; TUnixSystem::FillWithCwdvoid FillWithCwd(char *cwd) constFill buffer with current working directory.Definition TUnixSystem.cxx:1473; TUnixSystem::UnixWaitchildstatic int UnixWaitchild()Wait till child is finished.Definition TUnixSystem.cxx:4130; TUnixSystem::Unlinkint Unlink(const char *name) overrideUnlink, i.e.Definition TUnixSystem.cxx:1708; TUnixSystem::ListLibrariesvoid ListLibraries(const char *regexp="""") overrideList all loaded shared libraries.Definition TUnixSystem.cxx:2848; TUnixSystem::Closelogvoid Closelog() overrideClose connection to system log daemon.Definition TUnixSystem.cxx:2663; TUnixSystem::RedirectOutputInt_t RedirectOutput(const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr) overrideRedirect standard output (stdout, stderr) to the specified file.Definition TUnixSystem.cxx:2682; TUnixSystem::Sleepvoid Sleep(UInt_t milliSec) overrideSleep milliSec milliseconds.Definition TUnixSystem.cxx:1184; TUnixSystem::ResetSignalvoid ResetSignal(ESignals sig, Bool_t reset=kTRUE) overrideIf reset is true reset the signal handler for the specified signal to the default handler,...Definition TUnixSystem.cxx:875; TUnixSystem::TempDirectoryconst char * TempDirectory() const overrideReturn a user configured or systemwide directory to create temporary files in.Definition TUnixSystem.cxx:1503; TUnixSystem::DynFindSymbolFunc_t DynFindSymbol(const char *module, const char *entry) overridedynamic linking of moduleDefinition TUnixSystem.cxx:2814; TUnixSystem::GetDynamicPathconst char * GetD",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8cxx_source.html:31240,Usability,clear,clear,31240,"oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) newm |= FE_OVERFLOW;; 1011 if (mask & kUnderflow) newm |= FE_UNDERFLOW;; 1012# ifdef FE_INEXACT; 1013 if (mask & kInexact ) newm |= FE_INEXACT;; 1014# endif; 1015 ; 1016#if __GLIBC_MINOR__>=3; 1017 ; 1018 // clear pending exceptions so feenableexcept does not trigger them; 1019 feclearexcept(FE_ALL_EXCEPT);; 1020 fedisableexcept(FE_ALL_EXCEPT);; 1021 feenableexcept(newm);; 1022 ; 1023#else; 1024 ; 1025 fenv_t cur;; 1026 fegetenv(&cur);; 1027#if defined __ia64__; 1028 cur &= ~newm;; 1029#else; 1030 cur.__control_word &= ~newm;; 1031#endif; 1032 fesetenv(&cur);; 1033 ; 1034#endif; 1035#endif; 1036#endif; 1037 ; 1038#if defined(R__MACOSX) && defined(__SSE2__); 1039 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 1040 Int_t newm = 0;; 1041 if (mask & kInvalid ) newm |= _MM_MASK_INVALID;; 1042 if (mask & kDivByZero) newm |= _MM_MASK_DIV_ZERO;; 1043 if (mask & kOverflow ) newm |= _MM_MASK_OVERFLOW;; 1044 if (mask & kUnderflow) newm |= _MM_MASK_UNDERFLOW;; 1045 if (mask & kInexact ) newm |= _MM_MASK",MatchSource.WIKI,doc/master/TUnixSystem_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html
https://root.cern/doc/master/TUnixSystem_8h.html:284,Integrability,depend,dependency,284,". ROOT: core/unix/inc/TUnixSystem.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Typedefs ; TUnixSystem.h File Reference. #include ""TSystem.h""; #include ""TSysEvtHandler.h""; #include ""TTimer.h""; #include <string>. Include dependency graph for TUnixSystem.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TUnixSystem;  . Typedefs; typedef void(* SigHandler_t) (ESignals);  . Typedef Documentation. ◆ SigHandler_t. typedef void(* SigHandler_t) (ESignals). Definition at line 29 of file TUnixSystem.h. coreunixincTUnixSystem.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:15 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TUnixSystem_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:4431,Availability,mask,mask,4431,"--; 85 void DispatchOneEvent(Bool_t pendingOnly = kFALSE) override;; 86 Int_t Select(TList *active, Long_t timeout) override;; 87 Int_t Select(TFileHandler *fh, Long_t timeout) override;; 88 ; 89 //---- Handling of system events ----------------------------; 90 void CheckChilds();; 91 Bool_t CheckSignals(Bool_t sync);; 92 Bool_t CheckDescriptors();; 93 void DispatchSignals(ESignals sig);; 94 void AddSignalHandler(TSignalHandler *sh) override;; 95 TSignalHandler *RemoveSignalHandler(TSignalHandler *sh) override;; 96 void ResetSignal(ESignals sig, Bool_t reset = kTRUE) override;; 97 void ResetSignals() override;; 98 void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE) override;; 99 void SigAlarmInterruptsSyscalls(Bool_t set) override;; 100 void AddFileHandler(TFileHandler *fh) override;; 101 TFileHandler *RemoveFileHandler(TFileHandler *fh) override;; 102 ; 103 //---- Floating Point Exceptions Control --------------------; 104 Int_t GetFPEMask() override;; 105 Int_t SetFPEMask(Int_t mask = kDefaultMask) override;; 106 ; 107 //---- Time & Date ------------------------------------------; 108 TTime Now() override;; 109 void AddTimer(TTimer *ti) override;; 110 TTimer *RemoveTimer(TTimer *ti) override;; 111 void ResetTimer(TTimer *ti) override;; 112 Bool_t DispatchTimers(Bool_t mode);; 113 void Sleep(UInt_t milliSec) override;; 114 ; 115 //---- Processes --------------------------------------------; 116 Int_t Exec(const char *shellcmd) override;; 117 FILE *OpenPipe(const char *shellcmd, const char *mode) override;; 118 int ClosePipe(FILE *pipe) override;; 119 int GetPid() override;; 120 void StackTrace() override;; 121 ; 122 [[ noreturn ]] void Exit (int code, Bool_t mode = kTRUE) override;; 123 [[ noreturn ]] void Abort (int code = 0) override;; 124 ; 125 //---- Directories ------------------------------------------; 126 int MakeDirectory(const char *name) override;; 127 void *OpenDirectory(const char *name) override;; 128 void FreeDirectory(void *dirp) override;; 129 co",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:6905,Availability,mask,mask,6905,"nst char *suffix = nullptr) override;; 137 ; 138 //---- Paths & Files ----------------------------------------; 139 const char *PrependPathName(const char *dir, TString& name) override;; 140 Bool_t ExpandPathName(TString &patbuf) override;; 141 char *ExpandPathName(const char *path) override;; 142 Bool_t AccessPathName(const char *path, EAccessMode mode = kFileExists) override;; 143 Bool_t IsPathLocal(const char *path) override;; 144 int CopyFile(const char *from, const char *to, Bool_t overwrite = kFALSE) override;; 145 int Rename(const char *from, const char *to) override;; 146 int Link(const char *from, const char *to) override;; 147 int Symlink(const char *from, const char *to) override;; 148 int Unlink(const char *name) override;; 149 int GetPathInfo(const char *path, FileStat_t &buf) override;; 150 int GetFsInfo(const char *path, Long_t *id, Long_t *bsize,; 151 Long_t *blocks, Long_t *bfree) override;; 152 int Chmod(const char *file, UInt_t mode) override;; 153 int Umask(Int_t mask) override;; 154 int Utime(const char *file, Long_t modtime, Long_t actime) override;; 155 const char *FindFile(const char *search, TString& file, EAccessMode mode = kFileExists) override;; 156 ; 157 //---- Users & Groups ---------------------------------------; 158 Int_t GetUid(const char *user = nullptr) override;; 159 Int_t GetGid(const char *group = nullptr) override;; 160 Int_t GetEffectiveUid() override;; 161 Int_t GetEffectiveGid() override;; 162 UserGroup_t *GetUserInfo(Int_t uid) override;; 163 UserGroup_t *GetUserInfo(const char *user = nullptr) override;; 164 UserGroup_t *GetGroupInfo(Int_t gid) override;; 165 UserGroup_t *GetGroupInfo(const char *group = nullptr) override;; 166 ; 167 //---- Environment Manipulation -----------------------------; 168 const char *Getenv(const char *name) override;; 169 void Setenv(const char *name, const char *value) override;; 170 void Unsetenv(const char *name) override;; 171 ; 172 //---- System Logging ------------------------------------",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:11355,Availability,mask,maskDefinition,11355,"verride;; 211 int GetSockOpt(int sock, int option, int *val) override;; 212 ; 213 //---- System, CPU and Memory info; 214 int GetSysInfo(SysInfo_t *info) const override;; 215 int GetCpuInfo(CpuInfo_t *info, Int_t sampleTime = 1000) const override;; 216 int GetMemInfo(MemInfo_t *info) const override;; 217 int GetProcInfo(ProcInfo_t *info) const override;; 218 ; 219 ClassDefOverride(TUnixSystem,0) //Interface to Unix OS services; 220};; 221 ; 222#endif; h#define h(i)Definition RSha256.hxx:106; Long_tlong Long_tDefinition RtypesCore.h:54; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; maskOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t maskDefinition TGWin32VirtualXProxy.cxx:178; lengthOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h lengthDefinition TGWin32VirtualXProxy.cxx:245; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLi",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:16748,Availability,mask,mask,16748,"nect(const char *hostname, int port)Creates a UDP socket connection Is called via the TSocket constructor.Definition TUnixSystem.cxx:4197; TUnixSystem::CopyFileint CopyFile(const char *from, const char *to, Bool_t overwrite=kFALSE) overrideCopy a file.Definition TUnixSystem.cxx:1598; TUnixSystem::RemoveTimerTTimer * RemoveTimer(TTimer *ti) overrideRemove timer from list of system timers.Definition TUnixSystem.cxx:3018; TUnixSystem::AnnounceUdpServiceint AnnounceUdpService(int port, int backlog) overrideAnnounce UDP service.Definition TUnixSystem.cxx:3250; TUnixSystem::AnnounceUnixServiceint AnnounceUnixService(int port, int backlog) overrideAnnounce unix domain service on path ""kServerPath/<port>"".Definition TUnixSystem.cxx:3258; TUnixSystem::UnixTcpConnectstatic int UnixTcpConnect(const char *hostname, int port, int tcpwindowsize)Open a TCP/IP connection to server and connect to a service (i.e.Definition TUnixSystem.cxx:4145; TUnixSystem::SetFPEMaskInt_t SetFPEMask(Int_t mask=kDefaultMask) overrideSet which conditions trigger a floating point exception.Definition TUnixSystem.cxx:999; TUnixSystem::UnixGetdirentrystatic const char * UnixGetdirentry(void *dir)Returns the next directory entry.Definition TUnixSystem.cxx:4010; TUnixSystem::Setenvvoid Setenv(const char *name, const char *value) overrideSet environment variable.Definition TUnixSystem.cxx:2129; TUnixSystem::ConnectServiceint ConnectService(const char *server, int port, int tcpwindowsize, const char *protocol=""tcp"")Connect to service servicename on server servername.Definition TUnixSystem.cxx:3201; TUnixSystem::ChangeDirectoryBool_t ChangeDirectory(const char *path) overrideChange directory. Returns kTRUE in case of success, kFALSE otherwise.Definition TUnixSystem.cxx:1434; TUnixSystem::UnixHomedirectorystatic const char * UnixHomedirectory(const char *user=nullptr)Returns the user's home directory.Definition TUnixSystem.cxx:3935; TUnixSystem::GetServiceByPortchar * GetServiceByPort(int port) overrideGet name",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:22543,Availability,error,error,22543,"n TUnixSystem.cxx:3171; TUnixSystem::FindFileconst char * FindFile(const char *search, TString &file, EAccessMode mode=kFileExists) overrideFind location of file ""wfil"" in a search path.Definition TUnixSystem.cxx:1927; TUnixSystem::SigAlarmInterruptsSyscallsvoid SigAlarmInterruptsSyscalls(Bool_t set) overrideWhen the argument is true the SIGALRM signal handler is set so that interrupted syscalls will not be ...Definition TUnixSystem.cxx:908; TUnixSystem::UnixUdpServicestatic int UnixUdpService(int port, int backlog)Open a socket, bind to it and start listening for UDP connections on the port.Definition TUnixSystem.cxx:4373; TUnixSystem::Utimeint Utime(const char *file, Long_t modtime, Long_t actime) overrideSet a files modification and access times.Definition TUnixSystem.cxx:1910; TUnixSystem::GetLinkedLibrariesconst char * GetLinkedLibraries() overrideGet list of shared libraries loaded at the start of the executable.Definition TUnixSystem.cxx:2857; TUnixSystem::GetErrorconst char * GetError() overrideReturn system error string.Definition TUnixSystem.cxx:719; TUnixSystem::GetWorkingDirectorystd::string GetWorkingDirectory() const overrideReturn working directory.Definition TUnixSystem.cxx:1463; TUnixSystem::AccessPathNameBool_t AccessPathName(const char *path, EAccessMode mode=kFileExists) overrideReturns FALSE if one can access a file using the specified access mode.Definition TUnixSystem.cxx:1579; TUnixSystem::TempFileNameFILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr) overrideCreate a secure temporary file by appending a unique 6 letter string to base.Definition TUnixSystem.cxx:1523; TUnixSystem::DispatchOneEventvoid DispatchOneEvent(Bool_t pendingOnly=kFALSE) overrideDispatch a single event.Definition TUnixSystem.cxx:1093; TUnixSystem::Chmodint Chmod(const char *file, UInt_t mode) overrideSet the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TUnixSystem.cxx:1893; TUnixSystem::PrependPathNamecon",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:23428,Availability,error,error,23428,"f the executable.Definition TUnixSystem.cxx:2857; TUnixSystem::GetErrorconst char * GetError() overrideReturn system error string.Definition TUnixSystem.cxx:719; TUnixSystem::GetWorkingDirectorystd::string GetWorkingDirectory() const overrideReturn working directory.Definition TUnixSystem.cxx:1463; TUnixSystem::AccessPathNameBool_t AccessPathName(const char *path, EAccessMode mode=kFileExists) overrideReturns FALSE if one can access a file using the specified access mode.Definition TUnixSystem.cxx:1579; TUnixSystem::TempFileNameFILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr) overrideCreate a secure temporary file by appending a unique 6 letter string to base.Definition TUnixSystem.cxx:1523; TUnixSystem::DispatchOneEventvoid DispatchOneEvent(Bool_t pendingOnly=kFALSE) overrideDispatch a single event.Definition TUnixSystem.cxx:1093; TUnixSystem::Chmodint Chmod(const char *file, UInt_t mode) overrideSet the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TUnixSystem.cxx:1893; TUnixSystem::PrependPathNameconst char * PrependPathName(const char *dir, TString &name) overrideConcatenate a directory and a file name.Definition TUnixSystem.cxx:1552; TUnixSystem::DispatchTimersBool_t DispatchTimers(Bool_t mode)Handle and dispatch timers.Definition TUnixSystem.cxx:2979; TUnixSystem::IgnoreSignalvoid IgnoreSignal(ESignals sig, Bool_t ignore=kTRUE) overrideIf ignore is true ignore the specified signal, else restore previous behaviour.Definition TUnixSystem.cxx:895; TUnixSystem::ListSymbolsvoid ListSymbols(const char *module, const char *re="""") overrideList symbols in a shared library.Definition TUnixSystem.cxx:2840; TUnixSystem::Loadint Load(const char *module, const char *entry="""", Bool_t system=kFALSE) overrideLoad a shared library.Definition TUnixSystem.cxx:2824; TUnixSystem::StackTracevoid StackTrace() overridePrint a stack trace.Definition TUnixSystem.cxx:2281; TUnixSystem::GetHostByNameTInetAddress GetHostByN",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:28640,Availability,failure,failure,28640,"::UnixTcpServicestatic int UnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize)Open a socket, bind to it and start listening for TCP/IP connections on the port.Definition TUnixSystem.cxx:4297; TUnixSystem::DispatchSignalsvoid DispatchSignals(ESignals sig)Handle and dispatch signals.Definition TUnixSystem.cxx:3648; TUnixSystem::AddFileHandlervoid AddFileHandler(TFileHandler *fh) overrideAdd a file handler to the list of system file handlers.Definition TUnixSystem.cxx:782; TUnixSystem::GetCryptoRandomInt_t GetCryptoRandom(void *buf, Int_t len) overrideReturn cryptographic random number Fill provided buffer with random values Returns number of bytes wr...Definition TUnixSystem.cxx:740; TUnixSystem::OpenDirectoryvoid * OpenDirectory(const char *name) overrideOpen a Unix file system directory. Returns 0 if directory does not exist.Definition TUnixSystem.cxx:1392; TUnixSystem::Renameint Rename(const char *from, const char *to) overrideRename a file. Returns 0 when successful, -1 in case of failure.Definition TUnixSystem.cxx:1632; TUnixSystem::Getenvconst char * Getenv(const char *name) overrideGet environment variable.Definition TUnixSystem.cxx:2137; TUnixSystem::GetPathInfoint GetPathInfo(const char *path, FileStat_t &buf) overrideGet info about a file.Definition TUnixSystem.cxx:1658; TUnixSystem::GetEffectiveGidInt_t GetEffectiveGid() overrideReturns the effective group id.Definition TUnixSystem.cxx:2045; TUnixSystem::UnixSelectstatic int UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready, Long_t timeout)Wait for events on the file descriptors specified in the readready and writeready masks or for timeou...Definition TUnixSystem.cxx:3901; TUnixSystem::GetPidint GetPid() overrideGet process id.Definition TUnixSystem.cxx:2179; TUnixSystem::ExecInt_t Exec(const char *shellcmd) overrideExecute a command.Definition TUnixSystem.cxx:2155; TUnixSystem::ResetTimervoid ResetTimer(TTimer *ti) overrideReset a-sync timer.Definition TUnixSystem.cxx:3033; T",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:29259,Availability,mask,masks,29259,"void *buf, Int_t len) overrideReturn cryptographic random number Fill provided buffer with random values Returns number of bytes wr...Definition TUnixSystem.cxx:740; TUnixSystem::OpenDirectoryvoid * OpenDirectory(const char *name) overrideOpen a Unix file system directory. Returns 0 if directory does not exist.Definition TUnixSystem.cxx:1392; TUnixSystem::Renameint Rename(const char *from, const char *to) overrideRename a file. Returns 0 when successful, -1 in case of failure.Definition TUnixSystem.cxx:1632; TUnixSystem::Getenvconst char * Getenv(const char *name) overrideGet environment variable.Definition TUnixSystem.cxx:2137; TUnixSystem::GetPathInfoint GetPathInfo(const char *path, FileStat_t &buf) overrideGet info about a file.Definition TUnixSystem.cxx:1658; TUnixSystem::GetEffectiveGidInt_t GetEffectiveGid() overrideReturns the effective group id.Definition TUnixSystem.cxx:2045; TUnixSystem::UnixSelectstatic int UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready, Long_t timeout)Wait for events on the file descriptors specified in the readready and writeready masks or for timeou...Definition TUnixSystem.cxx:3901; TUnixSystem::GetPidint GetPid() overrideGet process id.Definition TUnixSystem.cxx:2179; TUnixSystem::ExecInt_t Exec(const char *shellcmd) overrideExecute a command.Definition TUnixSystem.cxx:2155; TUnixSystem::ResetTimervoid ResetTimer(TTimer *ti) overrideReset a-sync timer.Definition TUnixSystem.cxx:3033; TUnixSystem::RemoveSignalHandlerTSignalHandler * RemoveSignalHandler(TSignalHandler *sh) overrideRemove a signal handler from list of signal handlers.Definition TUnixSystem.cxx:849; TUnixSystem::UnixSignalstatic void UnixSignal(ESignals sig, SigHandler_t h)Set a signal handler for a signal.Definition TUnixSystem.cxx:3703; TUnixSystem::CloseConnectionvoid CloseConnection(int sock, Bool_t force=kFALSE) overrideClose socket.Definition TUnixSystem.cxx:3298; TUnixSystem::CheckDescriptorsBool_t CheckDescriptors()Check if there is activity on some",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:30504,Availability,mask,mask,30504,"; TUnixSystem::ResetTimervoid ResetTimer(TTimer *ti) overrideReset a-sync timer.Definition TUnixSystem.cxx:3033; TUnixSystem::RemoveSignalHandlerTSignalHandler * RemoveSignalHandler(TSignalHandler *sh) overrideRemove a signal handler from list of signal handlers.Definition TUnixSystem.cxx:849; TUnixSystem::UnixSignalstatic void UnixSignal(ESignals sig, SigHandler_t h)Set a signal handler for a signal.Definition TUnixSystem.cxx:3703; TUnixSystem::CloseConnectionvoid CloseConnection(int sock, Bool_t force=kFALSE) overrideClose socket.Definition TUnixSystem.cxx:3298; TUnixSystem::CheckDescriptorsBool_t CheckDescriptors()Check if there is activity on some file descriptors and call their Notify() member.Definition TUnixSystem.cxx:1337; TUnixSystem::InitBool_t Init() overrideInitialize Unix system interface.Definition TUnixSystem.cxx:595; TUnixSystem::Unloadvoid Unload(const char *module) overrideUnload a shared library.Definition TUnixSystem.cxx:2832; TUnixSystem::Umaskint Umask(Int_t mask) overrideSet the process file creation mode mask.Definition TUnixSystem.cxx:1901; TUnixSystem::UnixFilestatstatic int UnixFilestat(const char *path, FileStat_t &buf)Get info about a file.Definition TUnixSystem.cxx:4039; TUnixSystem::UnixRecvstatic int UnixRecv(int sock, void *buf, int len, int flag)Receive exactly length bytes into buffer.Definition TUnixSystem.cxx:4508; TUnixSystem::GetEffectiveUidInt_t GetEffectiveUid() overrideReturns the effective user id.Definition TUnixSystem.cxx:2021; TUnixSystem::FillWithCwdvoid FillWithCwd(char *cwd) constFill buffer with current working directory.Definition TUnixSystem.cxx:1473; TUnixSystem::UnixWaitchildstatic int UnixWaitchild()Wait till child is finished.Definition TUnixSystem.cxx:4130; TUnixSystem::Unlinkint Unlink(const char *name) overrideUnlink, i.e.Definition TUnixSystem.cxx:1708; TUnixSystem::ListLibrariesvoid ListLibraries(const char *regexp="""") overrideList all loaded shared libraries.Definition TUnixSystem.cxx:2848; TUnixSystem::C",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:30553,Availability,mask,mask,30553,"; TUnixSystem::ResetTimervoid ResetTimer(TTimer *ti) overrideReset a-sync timer.Definition TUnixSystem.cxx:3033; TUnixSystem::RemoveSignalHandlerTSignalHandler * RemoveSignalHandler(TSignalHandler *sh) overrideRemove a signal handler from list of signal handlers.Definition TUnixSystem.cxx:849; TUnixSystem::UnixSignalstatic void UnixSignal(ESignals sig, SigHandler_t h)Set a signal handler for a signal.Definition TUnixSystem.cxx:3703; TUnixSystem::CloseConnectionvoid CloseConnection(int sock, Bool_t force=kFALSE) overrideClose socket.Definition TUnixSystem.cxx:3298; TUnixSystem::CheckDescriptorsBool_t CheckDescriptors()Check if there is activity on some file descriptors and call their Notify() member.Definition TUnixSystem.cxx:1337; TUnixSystem::InitBool_t Init() overrideInitialize Unix system interface.Definition TUnixSystem.cxx:595; TUnixSystem::Unloadvoid Unload(const char *module) overrideUnload a shared library.Definition TUnixSystem.cxx:2832; TUnixSystem::Umaskint Umask(Int_t mask) overrideSet the process file creation mode mask.Definition TUnixSystem.cxx:1901; TUnixSystem::UnixFilestatstatic int UnixFilestat(const char *path, FileStat_t &buf)Get info about a file.Definition TUnixSystem.cxx:4039; TUnixSystem::UnixRecvstatic int UnixRecv(int sock, void *buf, int len, int flag)Receive exactly length bytes into buffer.Definition TUnixSystem.cxx:4508; TUnixSystem::GetEffectiveUidInt_t GetEffectiveUid() overrideReturns the effective user id.Definition TUnixSystem.cxx:2021; TUnixSystem::FillWithCwdvoid FillWithCwd(char *cwd) constFill buffer with current working directory.Definition TUnixSystem.cxx:1473; TUnixSystem::UnixWaitchildstatic int UnixWaitchild()Wait till child is finished.Definition TUnixSystem.cxx:4130; TUnixSystem::Unlinkint Unlink(const char *name) overrideUnlink, i.e.Definition TUnixSystem.cxx:1708; TUnixSystem::ListLibrariesvoid ListLibraries(const char *regexp="""") overrideList all loaded shared libraries.Definition TUnixSystem.cxx:2848; TUnixSystem::C",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:833,Integrability,interface,interface,833,". ROOT: core/unix/inc/TUnixSystem.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TUnixSystem.h. Go to the documentation of this file. 1// @(#)root/unix:$Id$; 2// Author: Fons Rademakers 15/09/95; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TUnixSystem; 13#define ROOT_TUnixSystem; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TUnixSystem //; 19// //; 20// Class providing an interface to the UNIX Operating System. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TSystem.h""; 25#include ""TSysEvtHandler.h""; 26#include ""TTimer.h""; 27#include <string>; 28 ; 29typedef void (*SigHandler_t)(ESignals);; 30 ; 31 ; 32class TUnixSystem : public TSystem {; 33 ; 34private:; 35 void FillWithCwd(char *cwd) const;; 36 ; 37protected:; 38 const char *GetLinkedLibraries() override;; 39 ; 40 // static functions providing semi-low level interface to raw Unix; 41 static int UnixMakedir(const char *name);; 42 static void *UnixOpendir(const char *name);; 43 static const char *UnixGetdirentry(void *dir);; 44 static const char *UnixHomedirectory(const char *user = nullptr);; 45 static const char *UnixHomedirectory(const char *user, char *path, char *mydir);; 46 static Long64_t UnixNow();; 47 static int UnixWaitchild();; 48 static int UnixSetitimer(Long_t ms);; 49 static int UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready,; 50 Long_t timeout);; 51 static void UnixSignal(ESignals sig, SigHandler_t h);; 52 static const char *UnixSigname(ESignals sig);; 53 static void UnixSigAlarm",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:1341,Integrability,interface,interface,1341,"h""; 27#include <string>; 28 ; 29typedef void (*SigHandler_t)(ESignals);; 30 ; 31 ; 32class TUnixSystem : public TSystem {; 33 ; 34private:; 35 void FillWithCwd(char *cwd) const;; 36 ; 37protected:; 38 const char *GetLinkedLibraries() override;; 39 ; 40 // static functions providing semi-low level interface to raw Unix; 41 static int UnixMakedir(const char *name);; 42 static void *UnixOpendir(const char *name);; 43 static const char *UnixGetdirentry(void *dir);; 44 static const char *UnixHomedirectory(const char *user = nullptr);; 45 static const char *UnixHomedirectory(const char *user, char *path, char *mydir);; 46 static Long64_t UnixNow();; 47 static int UnixWaitchild();; 48 static int UnixSetitimer(Long_t ms);; 49 static int UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready,; 50 Long_t timeout);; 51 static void UnixSignal(ESignals sig, SigHandler_t h);; 52 static const char *UnixSigname(ESignals sig);; 53 static void UnixSigAlarm",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:9351,Integrability,protocol,protocol,9351,"oid AddDynamicPath(const char *lib) override;; 183 const char *GetDynamicPath() override;; 184 void SetDynamicPath(const char *lib) override;; 185 const char *FindDynamicLibrary(TString &lib, Bool_t quiet = kFALSE) override;; 186 Func_t DynFindSymbol(const char *module, const char *entry) override;; 187 int Load(const char *module, const char *entry = """", Bool_t system = kFALSE) override;; 188 void Unload(const char *module) override;; 189 void ListSymbols(const char *module, const char *re = """") override;; 190 void ListLibraries(const char *regexp = """") override;; 191 ; 192 //---- RPC --------------------------------------------------; 193 TInetAddress GetHostByName(const char *server) override;; 194 TInetAddress GetPeerName(int sock) override;; 195 TInetAddress GetSockName(int sock) override;; 196 int GetServiceByName(const char *service) override;; 197 char *GetServiceByPort(int port) override;; 198 int ConnectService(const char *server, int port, int tcpwindowsize, const char *protocol = ""tcp"");; 199 int OpenConnection(const char *server, int port, int tcpwindowsize = -1, const char *protocol = ""tcp"") override;; 200 int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1) override;; 201 int AnnounceUdpService(int port, int backlog) override;; 202 int AnnounceUnixService(int port, int backlog) override;; 203 int AnnounceUnixService(const char *sockpath, int backlog) override;; 204 int AcceptConnection(int sock) override;; 205 void CloseConnection(int sock, Bool_t force = kFALSE) override;; 206 int RecvRaw(int sock, void *buffer, int length, int flag) override;; 207 int SendRaw(int sock, const void *buffer, int length, int flag) override;; 208 int RecvBuf(int sock, void *buffer, int length) override;; 209 int SendBuf(int sock, const void *buffer, int length) override;; 210 int SetSockOpt(int sock, int option, int val) override;; 211 int GetSockOpt(int sock, int option, int *val) override;; 212 ; 213 //---- System, CPU and Memory info; 214",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:9460,Integrability,protocol,protocol,9460,"cPath(const char *lib) override;; 185 const char *FindDynamicLibrary(TString &lib, Bool_t quiet = kFALSE) override;; 186 Func_t DynFindSymbol(const char *module, const char *entry) override;; 187 int Load(const char *module, const char *entry = """", Bool_t system = kFALSE) override;; 188 void Unload(const char *module) override;; 189 void ListSymbols(const char *module, const char *re = """") override;; 190 void ListLibraries(const char *regexp = """") override;; 191 ; 192 //---- RPC --------------------------------------------------; 193 TInetAddress GetHostByName(const char *server) override;; 194 TInetAddress GetPeerName(int sock) override;; 195 TInetAddress GetSockName(int sock) override;; 196 int GetServiceByName(const char *service) override;; 197 char *GetServiceByPort(int port) override;; 198 int ConnectService(const char *server, int port, int tcpwindowsize, const char *protocol = ""tcp"");; 199 int OpenConnection(const char *server, int port, int tcpwindowsize = -1, const char *protocol = ""tcp"") override;; 200 int AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize = -1) override;; 201 int AnnounceUdpService(int port, int backlog) override;; 202 int AnnounceUnixService(int port, int backlog) override;; 203 int AnnounceUnixService(const char *sockpath, int backlog) override;; 204 int AcceptConnection(int sock) override;; 205 void CloseConnection(int sock, Bool_t force = kFALSE) override;; 206 int RecvRaw(int sock, void *buffer, int length, int flag) override;; 207 int SendRaw(int sock, const void *buffer, int length, int flag) override;; 208 int RecvBuf(int sock, void *buffer, int length) override;; 209 int SendBuf(int sock, const void *buffer, int length) override;; 210 int SetSockOpt(int sock, int option, int val) override;; 211 int GetSockOpt(int sock, int option, int *val) override;; 212 ; 213 //---- System, CPU and Memory info; 214 int GetSysInfo(SysInfo_t *info) const override;; 215 int GetCpuInfo(CpuInfo_t *info, Int_t sampleTime = 1000",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:14151,Integrability,interface,interface,14151,"har_t lenDefinition TGWin32VirtualXProxy.cxx:249; modeOption_t Option_t TPoint TPoint const char modeDefinition TGWin32VirtualXProxy.cxx:68; namechar name[80]Definition TGX11.cxx:110; TSysEvtHandler.h; ESignalsESignalsDefinition TSysEvtHandler.h:107; TSystem.h; Func_tvoid(* Func_t)()Definition TSystem.h:239; EAccessModeEAccessModeDefinition TSystem.h:41; kFileExists@ kFileExistsDefinition TSystem.h:42; ELogFacilityELogFacilityDefinition TSystem.h:64; ELogLevelELogLevelDefinition TSystem.h:53; kDefaultMask@ kDefaultMaskDefinition TSystem.h:82; TTimer.h; SigHandler_tvoid(* SigHandler_t)(ESignals)Definition TUnixSystem.h:29; TFdSetDefinition TMacOSXSystem.mm:90; TFileHandlerDefinition TSysEvtHandler.h:65; TInetAddressThis class represents an Internet Protocol (IP) address.Definition TInetAddress.h:36; TListA doubly linked list.Definition TList.h:38; TSignalHandlerDefinition TSysEvtHandler.h:127; TStringBasic string class.Definition TString.h:139; TSystemAbstract base class defining a generic interface to the underlying Operating System.Definition TSystem.h:266; TTimeBasic time type with millisecond precision.Definition TTime.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TUnixSystemDefinition TUnixSystem.h:32; TUnixSystem::AddTimervoid AddTimer(TTimer *ti) overrideAdd timer to list of system timers.Definition TUnixSystem.cxx:3009; TUnixSystem::RecvRawint RecvRaw(int sock, void *buffer, int length, int flag) overrideReceive exactly length bytes into buffer.Definition TUnixSystem.cxx:3368; TUnixSystem::OpenConnectionint OpenConnection(const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"") overrideOpen a connection to a service on a server.Definition TUnixSystem.cxx:3225; TUnixSystem::GetMemInfoint GetMemInfo(MemInfo_t *info) const overrideReturns ram and swap memory usage info into the MemInfo_t structure.Definition TUnixSystem.cxx:5363; TUnixSystem::IsPathLocalBool_t IsPathLocal(const char *path) overrideR",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:14807,Integrability,protocol,protocol,14807,"SetDefinition TMacOSXSystem.mm:90; TFileHandlerDefinition TSysEvtHandler.h:65; TInetAddressThis class represents an Internet Protocol (IP) address.Definition TInetAddress.h:36; TListA doubly linked list.Definition TList.h:38; TSignalHandlerDefinition TSysEvtHandler.h:127; TStringBasic string class.Definition TString.h:139; TSystemAbstract base class defining a generic interface to the underlying Operating System.Definition TSystem.h:266; TTimeBasic time type with millisecond precision.Definition TTime.h:27; TTimerHandles synchronous and a-synchronous timer events.Definition TTimer.h:51; TUnixSystemDefinition TUnixSystem.h:32; TUnixSystem::AddTimervoid AddTimer(TTimer *ti) overrideAdd timer to list of system timers.Definition TUnixSystem.cxx:3009; TUnixSystem::RecvRawint RecvRaw(int sock, void *buffer, int length, int flag) overrideReceive exactly length bytes into buffer.Definition TUnixSystem.cxx:3368; TUnixSystem::OpenConnectionint OpenConnection(const char *server, int port, int tcpwindowsize=-1, const char *protocol=""tcp"") overrideOpen a connection to a service on a server.Definition TUnixSystem.cxx:3225; TUnixSystem::GetMemInfoint GetMemInfo(MemInfo_t *info) const overrideReturns ram and swap memory usage info into the MemInfo_t structure.Definition TUnixSystem.cxx:5363; TUnixSystem::IsPathLocalBool_t IsPathLocal(const char *path) overrideReturns TRUE if the url in 'path' points to the local file system.Definition TUnixSystem.cxx:1643; TUnixSystem::Symlinkint Symlink(const char *from, const char *to) overrideCreate a symlink from file1 to file2.Definition TUnixSystem.cxx:1695; TUnixSystem::HomeDirectoryconst char * HomeDirectory(const char *userName=nullptr) overrideReturn the user's home directory.Definition TUnixSystem.cxx:1483; TUnixSystem::GetGidInt_t GetGid(const char *group=nullptr) overrideReturns the group's id. If group = 0, returns current user's group.Definition TUnixSystem.cxx:2029; TUnixSystem::UnixUdpConnectstatic int UnixUdpConnect(const char *hos",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:17244,Integrability,protocol,protocol,17244,"AnnounceUdpService(int port, int backlog) overrideAnnounce UDP service.Definition TUnixSystem.cxx:3250; TUnixSystem::AnnounceUnixServiceint AnnounceUnixService(int port, int backlog) overrideAnnounce unix domain service on path ""kServerPath/<port>"".Definition TUnixSystem.cxx:3258; TUnixSystem::UnixTcpConnectstatic int UnixTcpConnect(const char *hostname, int port, int tcpwindowsize)Open a TCP/IP connection to server and connect to a service (i.e.Definition TUnixSystem.cxx:4145; TUnixSystem::SetFPEMaskInt_t SetFPEMask(Int_t mask=kDefaultMask) overrideSet which conditions trigger a floating point exception.Definition TUnixSystem.cxx:999; TUnixSystem::UnixGetdirentrystatic const char * UnixGetdirentry(void *dir)Returns the next directory entry.Definition TUnixSystem.cxx:4010; TUnixSystem::Setenvvoid Setenv(const char *name, const char *value) overrideSet environment variable.Definition TUnixSystem.cxx:2129; TUnixSystem::ConnectServiceint ConnectService(const char *server, int port, int tcpwindowsize, const char *protocol=""tcp"")Connect to service servicename on server servername.Definition TUnixSystem.cxx:3201; TUnixSystem::ChangeDirectoryBool_t ChangeDirectory(const char *path) overrideChange directory. Returns kTRUE in case of success, kFALSE otherwise.Definition TUnixSystem.cxx:1434; TUnixSystem::UnixHomedirectorystatic const char * UnixHomedirectory(const char *user=nullptr)Returns the user's home directory.Definition TUnixSystem.cxx:3935; TUnixSystem::GetServiceByPortchar * GetServiceByPort(int port) overrideGet name of internet service.Definition TUnixSystem.cxx:3186; TUnixSystem::CheckSignalsBool_t CheckSignals(Bool_t sync)Check if some signals were raised and call their Notify() member.Definition TUnixSystem.cxx:1286; TUnixSystem::UnixMakedirstatic int UnixMakedir(const char *name)Make a Unix file system directory.Definition TUnixSystem.cxx:3976; TUnixSystem::UnixSigAlarmInterruptsSyscallsstatic void UnixSigAlarmInterruptsSyscalls(Bool_t set)When the argument is",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:30312,Integrability,interface,interface,30312,"Definition TUnixSystem.cxx:3901; TUnixSystem::GetPidint GetPid() overrideGet process id.Definition TUnixSystem.cxx:2179; TUnixSystem::ExecInt_t Exec(const char *shellcmd) overrideExecute a command.Definition TUnixSystem.cxx:2155; TUnixSystem::ResetTimervoid ResetTimer(TTimer *ti) overrideReset a-sync timer.Definition TUnixSystem.cxx:3033; TUnixSystem::RemoveSignalHandlerTSignalHandler * RemoveSignalHandler(TSignalHandler *sh) overrideRemove a signal handler from list of signal handlers.Definition TUnixSystem.cxx:849; TUnixSystem::UnixSignalstatic void UnixSignal(ESignals sig, SigHandler_t h)Set a signal handler for a signal.Definition TUnixSystem.cxx:3703; TUnixSystem::CloseConnectionvoid CloseConnection(int sock, Bool_t force=kFALSE) overrideClose socket.Definition TUnixSystem.cxx:3298; TUnixSystem::CheckDescriptorsBool_t CheckDescriptors()Check if there is activity on some file descriptors and call their Notify() member.Definition TUnixSystem.cxx:1337; TUnixSystem::InitBool_t Init() overrideInitialize Unix system interface.Definition TUnixSystem.cxx:595; TUnixSystem::Unloadvoid Unload(const char *module) overrideUnload a shared library.Definition TUnixSystem.cxx:2832; TUnixSystem::Umaskint Umask(Int_t mask) overrideSet the process file creation mode mask.Definition TUnixSystem.cxx:1901; TUnixSystem::UnixFilestatstatic int UnixFilestat(const char *path, FileStat_t &buf)Get info about a file.Definition TUnixSystem.cxx:4039; TUnixSystem::UnixRecvstatic int UnixRecv(int sock, void *buf, int len, int flag)Receive exactly length bytes into buffer.Definition TUnixSystem.cxx:4508; TUnixSystem::GetEffectiveUidInt_t GetEffectiveUid() overrideReturns the effective user id.Definition TUnixSystem.cxx:2021; TUnixSystem::FillWithCwdvoid FillWithCwd(char *cwd) constFill buffer with current working directory.Definition TUnixSystem.cxx:1473; TUnixSystem::UnixWaitchildstatic int UnixWaitchild()Wait till child is finished.Definition TUnixSystem.cxx:4130; TUnixSystem::Unlinkint Unlink",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:17095,Modifiability,variab,variable,17095,"nixSystem::RemoveTimerTTimer * RemoveTimer(TTimer *ti) overrideRemove timer from list of system timers.Definition TUnixSystem.cxx:3018; TUnixSystem::AnnounceUdpServiceint AnnounceUdpService(int port, int backlog) overrideAnnounce UDP service.Definition TUnixSystem.cxx:3250; TUnixSystem::AnnounceUnixServiceint AnnounceUnixService(int port, int backlog) overrideAnnounce unix domain service on path ""kServerPath/<port>"".Definition TUnixSystem.cxx:3258; TUnixSystem::UnixTcpConnectstatic int UnixTcpConnect(const char *hostname, int port, int tcpwindowsize)Open a TCP/IP connection to server and connect to a service (i.e.Definition TUnixSystem.cxx:4145; TUnixSystem::SetFPEMaskInt_t SetFPEMask(Int_t mask=kDefaultMask) overrideSet which conditions trigger a floating point exception.Definition TUnixSystem.cxx:999; TUnixSystem::UnixGetdirentrystatic const char * UnixGetdirentry(void *dir)Returns the next directory entry.Definition TUnixSystem.cxx:4010; TUnixSystem::Setenvvoid Setenv(const char *name, const char *value) overrideSet environment variable.Definition TUnixSystem.cxx:2129; TUnixSystem::ConnectServiceint ConnectService(const char *server, int port, int tcpwindowsize, const char *protocol=""tcp"")Connect to service servicename on server servername.Definition TUnixSystem.cxx:3201; TUnixSystem::ChangeDirectoryBool_t ChangeDirectory(const char *path) overrideChange directory. Returns kTRUE in case of success, kFALSE otherwise.Definition TUnixSystem.cxx:1434; TUnixSystem::UnixHomedirectorystatic const char * UnixHomedirectory(const char *user=nullptr)Returns the user's home directory.Definition TUnixSystem.cxx:3935; TUnixSystem::GetServiceByPortchar * GetServiceByPort(int port) overrideGet name of internet service.Definition TUnixSystem.cxx:3186; TUnixSystem::CheckSignalsBool_t CheckSignals(Bool_t sync)Check if some signals were raised and call their Notify() member.Definition TUnixSystem.cxx:1286; TUnixSystem::UnixMakedirstatic int UnixMakedir(const char *name)Make a Unix fi",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:19958,Modifiability,variab,variable,19958,"on TUnixSystem.cxx:2187; TUnixSystem::AnnounceTcpServiceint AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize=-1) overrideAnnounce TCP/IP service.Definition TUnixSystem.cxx:3241; TUnixSystem::TUnixSystemTUnixSystem()Definition TUnixSystem.cxx:575; TUnixSystem::AddDynamicPathvoid AddDynamicPath(const char *lib) overrideAdd a new directory to the dynamic path.Definition TUnixSystem.cxx:4725; TUnixSystem::SetDynamicPathvoid SetDynamicPath(const char *lib) overrideSet the dynamic path to a new value.Definition TUnixSystem.cxx:4748; TUnixSystem::ClosePipeint ClosePipe(FILE *pipe) overrideClose the pipe.Definition TUnixSystem.cxx:2171; TUnixSystem::GetHomeDirectorystd::string GetHomeDirectory(const char *userName=nullptr) const overrideReturn the user's home directory.Definition TUnixSystem.cxx:1491; TUnixSystem::SelectInt_t Select(TList *active, Long_t timeout) overrideSelect on file descriptors.Definition TUnixSystem.cxx:1202; TUnixSystem::Unsetenvvoid Unsetenv(const char *name) overrideUnset environment variable.Definition TUnixSystem.cxx:2145; TUnixSystem::~TUnixSystemvirtual ~TUnixSystem()Reset to original state.Definition TUnixSystem.cxx:581; TUnixSystem::Abortvoid Abort(int code=0) overrideAbort the application.Definition TUnixSystem.cxx:2202; TUnixSystem::Syslogvoid Syslog(ELogLevel level, const char *mess) overrideSend mess to syslog daemon.Definition TUnixSystem.cxx:2654; TUnixSystem::GetGroupInfoUserGroup_t * GetGroupInfo(Int_t gid) overrideReturns all group info in the UserGroup_t structure.Definition TUnixSystem.cxx:2099; TUnixSystem::GetUidInt_t GetUid(const char *user=nullptr) overrideReturns the user's id. If user = 0, returns current user's id.Definition TUnixSystem.cxx:2005; TUnixSystem::ExpandPathNameBool_t ExpandPathName(TString &patbuf) overrideExpand a pathname getting rid of special shell characters like ~.Definition TUnixSystem.cxx:1749; TUnixSystem::Openlogvoid Openlog(const char *name, Int_t options, ELogFacility facility)",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:25485,Modifiability,variab,variable,25485,"Get Internet Protocol (IP) address of host.Definition TUnixSystem.cxx:3046; TUnixSystem::SendBufint SendBuf(int sock, const void *buffer, int length) overrideSend a buffer headed by a length indicator.Definition TUnixSystem.cxx:3341; TUnixSystem::HostNameconst char * HostName() overrideReturn the system's host name.Definition TUnixSystem.cxx:762; TUnixSystem::CheckChildsvoid CheckChilds()Check if children have finished.Definition TUnixSystem.cxx:1317; TUnixSystem::RecvBufint RecvBuf(int sock, void *buffer, int length) overrideReceive a buffer headed by a length indicator.Definition TUnixSystem.cxx:3316; TUnixSystem::UnixUnixServicestatic int UnixUnixService(int port, int backlog)Open a socket, bind to it and start listening for Unix domain connections to it.Definition TUnixSystem.cxx:4432; TUnixSystem::GetUserInfoUserGroup_t * GetUserInfo(Int_t uid) overrideReturns all user info in the UserGroup_t structure.Definition TUnixSystem.cxx:2054; TUnixSystem::SetDisplayvoid SetDisplay() overrideSet DISPLAY environment variable based on utmp entry. Only for UNIX.Definition TUnixSystem.cxx:663; TUnixSystem::RemoveFileHandlerTFileHandler * RemoveFileHandler(TFileHandler *fh) overrideRemove a file handler from the list of file handlers.Definition TUnixSystem.cxx:804; TUnixSystem::UnixSignamestatic const char * UnixSigname(ESignals sig)Return the signal name associated with a signal.Definition TUnixSystem.cxx:3813; TUnixSystem::UnixNowstatic Long64_t UnixNow()Get current time in milliseconds since 0:00 Jan 1 1995.Definition TUnixSystem.cxx:3847; TUnixSystem::UnixFSstatstatic int UnixFSstat(const char *path, Long_t *id, Long_t *bsize, Long_t *blocks, Long_t *bfree)Get info about a file system: id, bsize, bfree, blocks.Definition TUnixSystem.cxx:4083; TUnixSystem::ResetSignalsvoid ResetSignals() overrideReset signals handlers to previous behaviour.Definition TUnixSystem.cxx:886; TUnixSystem::GetSockNameTInetAddress GetSockName(int sock) overrideGet Internet Protocol (IP) address ",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:28762,Modifiability,variab,variable,28762,"pen a socket, bind to it and start listening for TCP/IP connections on the port.Definition TUnixSystem.cxx:4297; TUnixSystem::DispatchSignalsvoid DispatchSignals(ESignals sig)Handle and dispatch signals.Definition TUnixSystem.cxx:3648; TUnixSystem::AddFileHandlervoid AddFileHandler(TFileHandler *fh) overrideAdd a file handler to the list of system file handlers.Definition TUnixSystem.cxx:782; TUnixSystem::GetCryptoRandomInt_t GetCryptoRandom(void *buf, Int_t len) overrideReturn cryptographic random number Fill provided buffer with random values Returns number of bytes wr...Definition TUnixSystem.cxx:740; TUnixSystem::OpenDirectoryvoid * OpenDirectory(const char *name) overrideOpen a Unix file system directory. Returns 0 if directory does not exist.Definition TUnixSystem.cxx:1392; TUnixSystem::Renameint Rename(const char *from, const char *to) overrideRename a file. Returns 0 when successful, -1 in case of failure.Definition TUnixSystem.cxx:1632; TUnixSystem::Getenvconst char * Getenv(const char *name) overrideGet environment variable.Definition TUnixSystem.cxx:2137; TUnixSystem::GetPathInfoint GetPathInfo(const char *path, FileStat_t &buf) overrideGet info about a file.Definition TUnixSystem.cxx:1658; TUnixSystem::GetEffectiveGidInt_t GetEffectiveGid() overrideReturns the effective group id.Definition TUnixSystem.cxx:2045; TUnixSystem::UnixSelectstatic int UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready, Long_t timeout)Wait for events on the file descriptors specified in the readready and writeready masks or for timeou...Definition TUnixSystem.cxx:3901; TUnixSystem::GetPidint GetPid() overrideGet process id.Definition TUnixSystem.cxx:2179; TUnixSystem::ExecInt_t Exec(const char *shellcmd) overrideExecute a command.Definition TUnixSystem.cxx:2155; TUnixSystem::ResetTimervoid ResetTimer(TTimer *ti) overrideReset a-sync timer.Definition TUnixSystem.cxx:3033; TUnixSystem::RemoveSignalHandlerTSignalHandler * RemoveSignalHandler(TSignalHandler *sh) overrideRe",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:32239,Modifiability,config,configured,32239,"tion TUnixSystem.cxx:4130; TUnixSystem::Unlinkint Unlink(const char *name) overrideUnlink, i.e.Definition TUnixSystem.cxx:1708; TUnixSystem::ListLibrariesvoid ListLibraries(const char *regexp="""") overrideList all loaded shared libraries.Definition TUnixSystem.cxx:2848; TUnixSystem::Closelogvoid Closelog() overrideClose connection to system log daemon.Definition TUnixSystem.cxx:2663; TUnixSystem::RedirectOutputInt_t RedirectOutput(const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr) overrideRedirect standard output (stdout, stderr) to the specified file.Definition TUnixSystem.cxx:2682; TUnixSystem::Sleepvoid Sleep(UInt_t milliSec) overrideSleep milliSec milliseconds.Definition TUnixSystem.cxx:1184; TUnixSystem::ResetSignalvoid ResetSignal(ESignals sig, Bool_t reset=kTRUE) overrideIf reset is true reset the signal handler for the specified signal to the default handler,...Definition TUnixSystem.cxx:875; TUnixSystem::TempDirectoryconst char * TempDirectory() const overrideReturn a user configured or systemwide directory to create temporary files in.Definition TUnixSystem.cxx:1503; TUnixSystem::DynFindSymbolFunc_t DynFindSymbol(const char *module, const char *entry) overridedynamic linking of moduleDefinition TUnixSystem.cxx:2814; TUnixSystem::GetDynamicPathconst char * GetDynamicPath() overrideReturn the dynamic path (used to find shared libraries).Definition TUnixSystem.cxx:4738; TUnixSystem::OpenPipeFILE * OpenPipe(const char *shellcmd, const char *mode) overrideOpen a pipe.Definition TUnixSystem.cxx:2163; TUnixSystem::FreeDirectoryvoid FreeDirectory(void *dirp) overrideClose a Unix file system directory.Definition TUnixSystem.cxx:1404; TUnixSystem::UnixResetSignalsstatic void UnixResetSignals()Restore old signal handlers.Definition TUnixSystem.cxx:3836; TUnixSystem::GetCpuInfoint GetCpuInfo(CpuInfo_t *info, Int_t sampleTime=1000) const overrideReturns cpu load average and load info into the CpuInfo_t structure.Definition TUnixSystem.cxx:5344; TUnixSy",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:22405,Performance,load,loaded,22405,"n TUnixSystem.cxx:3821; TUnixSystem::GetServiceByNameint GetServiceByName(const char *service) overrideGet port # of internet service.Definition TUnixSystem.cxx:3171; TUnixSystem::FindFileconst char * FindFile(const char *search, TString &file, EAccessMode mode=kFileExists) overrideFind location of file ""wfil"" in a search path.Definition TUnixSystem.cxx:1927; TUnixSystem::SigAlarmInterruptsSyscallsvoid SigAlarmInterruptsSyscalls(Bool_t set) overrideWhen the argument is true the SIGALRM signal handler is set so that interrupted syscalls will not be ...Definition TUnixSystem.cxx:908; TUnixSystem::UnixUdpServicestatic int UnixUdpService(int port, int backlog)Open a socket, bind to it and start listening for UDP connections on the port.Definition TUnixSystem.cxx:4373; TUnixSystem::Utimeint Utime(const char *file, Long_t modtime, Long_t actime) overrideSet a files modification and access times.Definition TUnixSystem.cxx:1910; TUnixSystem::GetLinkedLibrariesconst char * GetLinkedLibraries() overrideGet list of shared libraries loaded at the start of the executable.Definition TUnixSystem.cxx:2857; TUnixSystem::GetErrorconst char * GetError() overrideReturn system error string.Definition TUnixSystem.cxx:719; TUnixSystem::GetWorkingDirectorystd::string GetWorkingDirectory() const overrideReturn working directory.Definition TUnixSystem.cxx:1463; TUnixSystem::AccessPathNameBool_t AccessPathName(const char *path, EAccessMode mode=kFileExists) overrideReturns FALSE if one can access a file using the specified access mode.Definition TUnixSystem.cxx:1579; TUnixSystem::TempFileNameFILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr) overrideCreate a secure temporary file by appending a unique 6 letter string to base.Definition TUnixSystem.cxx:1523; TUnixSystem::DispatchOneEventvoid DispatchOneEvent(Bool_t pendingOnly=kFALSE) overrideDispatch a single event.Definition TUnixSystem.cxx:1093; TUnixSystem::Chmodint Chmod(const char *file, UInt_t mode) ",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:31438,Performance,load,loaded,31438,"e) overrideUnload a shared library.Definition TUnixSystem.cxx:2832; TUnixSystem::Umaskint Umask(Int_t mask) overrideSet the process file creation mode mask.Definition TUnixSystem.cxx:1901; TUnixSystem::UnixFilestatstatic int UnixFilestat(const char *path, FileStat_t &buf)Get info about a file.Definition TUnixSystem.cxx:4039; TUnixSystem::UnixRecvstatic int UnixRecv(int sock, void *buf, int len, int flag)Receive exactly length bytes into buffer.Definition TUnixSystem.cxx:4508; TUnixSystem::GetEffectiveUidInt_t GetEffectiveUid() overrideReturns the effective user id.Definition TUnixSystem.cxx:2021; TUnixSystem::FillWithCwdvoid FillWithCwd(char *cwd) constFill buffer with current working directory.Definition TUnixSystem.cxx:1473; TUnixSystem::UnixWaitchildstatic int UnixWaitchild()Wait till child is finished.Definition TUnixSystem.cxx:4130; TUnixSystem::Unlinkint Unlink(const char *name) overrideUnlink, i.e.Definition TUnixSystem.cxx:1708; TUnixSystem::ListLibrariesvoid ListLibraries(const char *regexp="""") overrideList all loaded shared libraries.Definition TUnixSystem.cxx:2848; TUnixSystem::Closelogvoid Closelog() overrideClose connection to system log daemon.Definition TUnixSystem.cxx:2663; TUnixSystem::RedirectOutputInt_t RedirectOutput(const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr) overrideRedirect standard output (stdout, stderr) to the specified file.Definition TUnixSystem.cxx:2682; TUnixSystem::Sleepvoid Sleep(UInt_t milliSec) overrideSleep milliSec milliseconds.Definition TUnixSystem.cxx:1184; TUnixSystem::ResetSignalvoid ResetSignal(ESignals sig, Bool_t reset=kTRUE) overrideIf reset is true reset the signal handler for the specified signal to the default handler,...Definition TUnixSystem.cxx:875; TUnixSystem::TempDirectoryconst char * TempDirectory() const overrideReturn a user configured or systemwide directory to create temporary files in.Definition TUnixSystem.cxx:1503; TUnixSystem::DynFindSymbolFunc_t DynFindSymbol(const char *module, ",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:33129,Performance,load,load,33129," the default handler,...Definition TUnixSystem.cxx:875; TUnixSystem::TempDirectoryconst char * TempDirectory() const overrideReturn a user configured or systemwide directory to create temporary files in.Definition TUnixSystem.cxx:1503; TUnixSystem::DynFindSymbolFunc_t DynFindSymbol(const char *module, const char *entry) overridedynamic linking of moduleDefinition TUnixSystem.cxx:2814; TUnixSystem::GetDynamicPathconst char * GetDynamicPath() overrideReturn the dynamic path (used to find shared libraries).Definition TUnixSystem.cxx:4738; TUnixSystem::OpenPipeFILE * OpenPipe(const char *shellcmd, const char *mode) overrideOpen a pipe.Definition TUnixSystem.cxx:2163; TUnixSystem::FreeDirectoryvoid FreeDirectory(void *dirp) overrideClose a Unix file system directory.Definition TUnixSystem.cxx:1404; TUnixSystem::UnixResetSignalsstatic void UnixResetSignals()Restore old signal handlers.Definition TUnixSystem.cxx:3836; TUnixSystem::GetCpuInfoint GetCpuInfo(CpuInfo_t *info, Int_t sampleTime=1000) const overrideReturns cpu load average and load info into the CpuInfo_t structure.Definition TUnixSystem.cxx:5344; TUnixSystem::AddSignalHandlervoid AddSignalHandler(TSignalHandler *sh) overrideAdd a signal handler to list of system signal handlers.Definition TUnixSystem.cxx:837; TUnixSystem::UnixOpendirstatic void * UnixOpendir(const char *name)Open a directory.Definition TUnixSystem.cxx:3984; TUnixSystem::SendRawint SendRaw(int sock, const void *buffer, int length, int flag) overrideSend exactly length bytes from buffer.Definition TUnixSystem.cxx:3405; TUnixSystem::WorkingDirectoryconst char * WorkingDirectory() overrideReturn working directory.Definition TUnixSystem.cxx:1445; TUnixSystem::GetSockOptint GetSockOpt(int sock, int option, int *val) overrideGet socket option.Definition TUnixSystem.cxx:3507; TUnixSystem::FindDynamicLibraryconst char * FindDynamicLibrary(TString &lib, Bool_t quiet=kFALSE) overrideReturns the path of a shared library (searches for library in the shared l",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:33146,Performance,load,load,33146," the default handler,...Definition TUnixSystem.cxx:875; TUnixSystem::TempDirectoryconst char * TempDirectory() const overrideReturn a user configured or systemwide directory to create temporary files in.Definition TUnixSystem.cxx:1503; TUnixSystem::DynFindSymbolFunc_t DynFindSymbol(const char *module, const char *entry) overridedynamic linking of moduleDefinition TUnixSystem.cxx:2814; TUnixSystem::GetDynamicPathconst char * GetDynamicPath() overrideReturn the dynamic path (used to find shared libraries).Definition TUnixSystem.cxx:4738; TUnixSystem::OpenPipeFILE * OpenPipe(const char *shellcmd, const char *mode) overrideOpen a pipe.Definition TUnixSystem.cxx:2163; TUnixSystem::FreeDirectoryvoid FreeDirectory(void *dirp) overrideClose a Unix file system directory.Definition TUnixSystem.cxx:1404; TUnixSystem::UnixResetSignalsstatic void UnixResetSignals()Restore old signal handlers.Definition TUnixSystem.cxx:3836; TUnixSystem::GetCpuInfoint GetCpuInfo(CpuInfo_t *info, Int_t sampleTime=1000) const overrideReturns cpu load average and load info into the CpuInfo_t structure.Definition TUnixSystem.cxx:5344; TUnixSystem::AddSignalHandlervoid AddSignalHandler(TSignalHandler *sh) overrideAdd a signal handler to list of system signal handlers.Definition TUnixSystem.cxx:837; TUnixSystem::UnixOpendirstatic void * UnixOpendir(const char *name)Open a directory.Definition TUnixSystem.cxx:3984; TUnixSystem::SendRawint SendRaw(int sock, const void *buffer, int length, int flag) overrideSend exactly length bytes from buffer.Definition TUnixSystem.cxx:3405; TUnixSystem::WorkingDirectoryconst char * WorkingDirectory() overrideReturn working directory.Definition TUnixSystem.cxx:1445; TUnixSystem::GetSockOptint GetSockOpt(int sock, int option, int *val) overrideGet socket option.Definition TUnixSystem.cxx:3507; TUnixSystem::FindDynamicLibraryconst char * FindDynamicLibrary(TString &lib, Bool_t quiet=kFALSE) overrideReturns the path of a shared library (searches for library in the shared l",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:1855,Safety,timeout,timeout,1855,"h""; 27#include <string>; 28 ; 29typedef void (*SigHandler_t)(ESignals);; 30 ; 31 ; 32class TUnixSystem : public TSystem {; 33 ; 34private:; 35 void FillWithCwd(char *cwd) const;; 36 ; 37protected:; 38 const char *GetLinkedLibraries() override;; 39 ; 40 // static functions providing semi-low level interface to raw Unix; 41 static int UnixMakedir(const char *name);; 42 static void *UnixOpendir(const char *name);; 43 static const char *UnixGetdirentry(void *dir);; 44 static const char *UnixHomedirectory(const char *user = nullptr);; 45 static const char *UnixHomedirectory(const char *user, char *path, char *mydir);; 46 static Long64_t UnixNow();; 47 static int UnixWaitchild();; 48 static int UnixSetitimer(Long_t ms);; 49 static int UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready,; 50 Long_t timeout);; 51 static void UnixSignal(ESignals sig, SigHandler_t h);; 52 static const char *UnixSigname(ESignals sig);; 53 static void UnixSigAlarm",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:3540,Safety,timeout,timeout,3540,"tic int UnixUnixConnect(const char *path);; 64 static int UnixTcpService(int port, Bool_t reuse, int backlog,; 65 int tcpwindowsize);; 66 static int UnixUdpService(int port, int backlog);; 67 static int UnixUnixService(int port, int backlog);; 68 static int UnixUnixService(const char *sockpath, int backlog);; 69 static int UnixRecv(int sock, void *buf, int len, int flag);; 70 static int UnixSend(int sock, const void *buf, int len, int flag);; 71 ; 72public:; 73 TUnixSystem();; 74 virtual ~TUnixSystem();; 75 ; 76 //---- Misc -------------------------------------------------; 77 Bool_t Init() override;; 78 void SetProgname(const char *name) override;; 79 void SetDisplay() override;; 80 const char *GetError() override;; 81 Int_t GetCryptoRandom(void *buf, Int_t len) override;; 82 const char *HostName() override;; 83 ; 84 //---- EventLoop --------------------------------------------; 85 void DispatchOneEvent(Bool_t pendingOnly = kFALSE) override;; 86 Int_t Select(TList *active, Long_t timeout) override;; 87 Int_t Select(TFileHandler *fh, Long_t timeout) override;; 88 ; 89 //---- Handling of system events ----------------------------; 90 void CheckChilds();; 91 Bool_t CheckSignals(Bool_t sync);; 92 Bool_t CheckDescriptors();; 93 void DispatchSignals(ESignals sig);; 94 void AddSignalHandler(TSignalHandler *sh) override;; 95 TSignalHandler *RemoveSignalHandler(TSignalHandler *sh) override;; 96 void ResetSignal(ESignals sig, Bool_t reset = kTRUE) override;; 97 void ResetSignals() override;; 98 void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE) override;; 99 void SigAlarmInterruptsSyscalls(Bool_t set) override;; 100 void AddFileHandler(TFileHandler *fh) override;; 101 TFileHandler *RemoveFileHandler(TFileHandler *fh) override;; 102 ; 103 //---- Floating Point Exceptions Control --------------------; 104 Int_t GetFPEMask() override;; 105 Int_t SetFPEMask(Int_t mask = kDefaultMask) override;; 106 ; 107 //---- Time & Date ------------------------------------------; 108 TTim",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:3601,Safety,timeout,timeout,3601,"xTcpService(int port, Bool_t reuse, int backlog,; 65 int tcpwindowsize);; 66 static int UnixUdpService(int port, int backlog);; 67 static int UnixUnixService(int port, int backlog);; 68 static int UnixUnixService(const char *sockpath, int backlog);; 69 static int UnixRecv(int sock, void *buf, int len, int flag);; 70 static int UnixSend(int sock, const void *buf, int len, int flag);; 71 ; 72public:; 73 TUnixSystem();; 74 virtual ~TUnixSystem();; 75 ; 76 //---- Misc -------------------------------------------------; 77 Bool_t Init() override;; 78 void SetProgname(const char *name) override;; 79 void SetDisplay() override;; 80 const char *GetError() override;; 81 Int_t GetCryptoRandom(void *buf, Int_t len) override;; 82 const char *HostName() override;; 83 ; 84 //---- EventLoop --------------------------------------------; 85 void DispatchOneEvent(Bool_t pendingOnly = kFALSE) override;; 86 Int_t Select(TList *active, Long_t timeout) override;; 87 Int_t Select(TFileHandler *fh, Long_t timeout) override;; 88 ; 89 //---- Handling of system events ----------------------------; 90 void CheckChilds();; 91 Bool_t CheckSignals(Bool_t sync);; 92 Bool_t CheckDescriptors();; 93 void DispatchSignals(ESignals sig);; 94 void AddSignalHandler(TSignalHandler *sh) override;; 95 TSignalHandler *RemoveSignalHandler(TSignalHandler *sh) override;; 96 void ResetSignal(ESignals sig, Bool_t reset = kTRUE) override;; 97 void ResetSignals() override;; 98 void IgnoreSignal(ESignals sig, Bool_t ignore = kTRUE) override;; 99 void SigAlarmInterruptsSyscalls(Bool_t set) override;; 100 void AddFileHandler(TFileHandler *fh) override;; 101 TFileHandler *RemoveFileHandler(TFileHandler *fh) override;; 102 ; 103 //---- Floating Point Exceptions Control --------------------; 104 Int_t GetFPEMask() override;; 105 Int_t SetFPEMask(Int_t mask = kDefaultMask) override;; 106 ; 107 //---- Time & Date ------------------------------------------; 108 TTime Now() override;; 109 void AddTimer(TTimer *ti) override;; 1",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:19802,Safety,timeout,timeout,19802,"Definition TUnixSystem.cxx:5318; TUnixSystem::Exitvoid Exit(int code, Bool_t mode=kTRUE) overrideExit the application.Definition TUnixSystem.cxx:2187; TUnixSystem::AnnounceTcpServiceint AnnounceTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize=-1) overrideAnnounce TCP/IP service.Definition TUnixSystem.cxx:3241; TUnixSystem::TUnixSystemTUnixSystem()Definition TUnixSystem.cxx:575; TUnixSystem::AddDynamicPathvoid AddDynamicPath(const char *lib) overrideAdd a new directory to the dynamic path.Definition TUnixSystem.cxx:4725; TUnixSystem::SetDynamicPathvoid SetDynamicPath(const char *lib) overrideSet the dynamic path to a new value.Definition TUnixSystem.cxx:4748; TUnixSystem::ClosePipeint ClosePipe(FILE *pipe) overrideClose the pipe.Definition TUnixSystem.cxx:2171; TUnixSystem::GetHomeDirectorystd::string GetHomeDirectory(const char *userName=nullptr) const overrideReturn the user's home directory.Definition TUnixSystem.cxx:1491; TUnixSystem::SelectInt_t Select(TList *active, Long_t timeout) overrideSelect on file descriptors.Definition TUnixSystem.cxx:1202; TUnixSystem::Unsetenvvoid Unsetenv(const char *name) overrideUnset environment variable.Definition TUnixSystem.cxx:2145; TUnixSystem::~TUnixSystemvirtual ~TUnixSystem()Reset to original state.Definition TUnixSystem.cxx:581; TUnixSystem::Abortvoid Abort(int code=0) overrideAbort the application.Definition TUnixSystem.cxx:2202; TUnixSystem::Syslogvoid Syslog(ELogLevel level, const char *mess) overrideSend mess to syslog daemon.Definition TUnixSystem.cxx:2654; TUnixSystem::GetGroupInfoUserGroup_t * GetGroupInfo(Int_t gid) overrideReturns all group info in the UserGroup_t structure.Definition TUnixSystem.cxx:2099; TUnixSystem::GetUidInt_t GetUid(const char *user=nullptr) overrideReturns the user's id. If user = 0, returns current user's id.Definition TUnixSystem.cxx:2005; TUnixSystem::ExpandPathNameBool_t ExpandPathName(TString &patbuf) overrideExpand a pathname getting rid of special shell characters li",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:29169,Safety,timeout,timeout,29169,"void *buf, Int_t len) overrideReturn cryptographic random number Fill provided buffer with random values Returns number of bytes wr...Definition TUnixSystem.cxx:740; TUnixSystem::OpenDirectoryvoid * OpenDirectory(const char *name) overrideOpen a Unix file system directory. Returns 0 if directory does not exist.Definition TUnixSystem.cxx:1392; TUnixSystem::Renameint Rename(const char *from, const char *to) overrideRename a file. Returns 0 when successful, -1 in case of failure.Definition TUnixSystem.cxx:1632; TUnixSystem::Getenvconst char * Getenv(const char *name) overrideGet environment variable.Definition TUnixSystem.cxx:2137; TUnixSystem::GetPathInfoint GetPathInfo(const char *path, FileStat_t &buf) overrideGet info about a file.Definition TUnixSystem.cxx:1658; TUnixSystem::GetEffectiveGidInt_t GetEffectiveGid() overrideReturns the effective group id.Definition TUnixSystem.cxx:2045; TUnixSystem::UnixSelectstatic int UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready, Long_t timeout)Wait for events on the file descriptors specified in the readready and writeready masks or for timeou...Definition TUnixSystem.cxx:3901; TUnixSystem::GetPidint GetPid() overrideGet process id.Definition TUnixSystem.cxx:2179; TUnixSystem::ExecInt_t Exec(const char *shellcmd) overrideExecute a command.Definition TUnixSystem.cxx:2155; TUnixSystem::ResetTimervoid ResetTimer(TTimer *ti) overrideReset a-sync timer.Definition TUnixSystem.cxx:3033; TUnixSystem::RemoveSignalHandlerTSignalHandler * RemoveSignalHandler(TSignalHandler *sh) overrideRemove a signal handler from list of signal handlers.Definition TUnixSystem.cxx:849; TUnixSystem::UnixSignalstatic void UnixSignal(ESignals sig, SigHandler_t h)Set a signal handler for a signal.Definition TUnixSystem.cxx:3703; TUnixSystem::CloseConnectionvoid CloseConnection(int sock, Bool_t force=kFALSE) overrideClose socket.Definition TUnixSystem.cxx:3298; TUnixSystem::CheckDescriptorsBool_t CheckDescriptors()Check if there is activity on some",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:22257,Security,access,access,22257," 1 1995.Definition TUnixSystem.cxx:2970; TUnixSystem::UnixResetSignalstatic void UnixResetSignal(ESignals sig)Restore old signal handler for specified signal.Definition TUnixSystem.cxx:3821; TUnixSystem::GetServiceByNameint GetServiceByName(const char *service) overrideGet port # of internet service.Definition TUnixSystem.cxx:3171; TUnixSystem::FindFileconst char * FindFile(const char *search, TString &file, EAccessMode mode=kFileExists) overrideFind location of file ""wfil"" in a search path.Definition TUnixSystem.cxx:1927; TUnixSystem::SigAlarmInterruptsSyscallsvoid SigAlarmInterruptsSyscalls(Bool_t set) overrideWhen the argument is true the SIGALRM signal handler is set so that interrupted syscalls will not be ...Definition TUnixSystem.cxx:908; TUnixSystem::UnixUdpServicestatic int UnixUdpService(int port, int backlog)Open a socket, bind to it and start listening for UDP connections on the port.Definition TUnixSystem.cxx:4373; TUnixSystem::Utimeint Utime(const char *file, Long_t modtime, Long_t actime) overrideSet a files modification and access times.Definition TUnixSystem.cxx:1910; TUnixSystem::GetLinkedLibrariesconst char * GetLinkedLibraries() overrideGet list of shared libraries loaded at the start of the executable.Definition TUnixSystem.cxx:2857; TUnixSystem::GetErrorconst char * GetError() overrideReturn system error string.Definition TUnixSystem.cxx:719; TUnixSystem::GetWorkingDirectorystd::string GetWorkingDirectory() const overrideReturn working directory.Definition TUnixSystem.cxx:1463; TUnixSystem::AccessPathNameBool_t AccessPathName(const char *path, EAccessMode mode=kFileExists) overrideReturns FALSE if one can access a file using the specified access mode.Definition TUnixSystem.cxx:1579; TUnixSystem::TempFileNameFILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr) overrideCreate a secure temporary file by appending a unique 6 letter string to base.Definition TUnixSystem.cxx:1523; TUnixSystem::DispatchOneEventvoid Di",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:22856,Security,access,access,22856,"et) overrideWhen the argument is true the SIGALRM signal handler is set so that interrupted syscalls will not be ...Definition TUnixSystem.cxx:908; TUnixSystem::UnixUdpServicestatic int UnixUdpService(int port, int backlog)Open a socket, bind to it and start listening for UDP connections on the port.Definition TUnixSystem.cxx:4373; TUnixSystem::Utimeint Utime(const char *file, Long_t modtime, Long_t actime) overrideSet a files modification and access times.Definition TUnixSystem.cxx:1910; TUnixSystem::GetLinkedLibrariesconst char * GetLinkedLibraries() overrideGet list of shared libraries loaded at the start of the executable.Definition TUnixSystem.cxx:2857; TUnixSystem::GetErrorconst char * GetError() overrideReturn system error string.Definition TUnixSystem.cxx:719; TUnixSystem::GetWorkingDirectorystd::string GetWorkingDirectory() const overrideReturn working directory.Definition TUnixSystem.cxx:1463; TUnixSystem::AccessPathNameBool_t AccessPathName(const char *path, EAccessMode mode=kFileExists) overrideReturns FALSE if one can access a file using the specified access mode.Definition TUnixSystem.cxx:1579; TUnixSystem::TempFileNameFILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr) overrideCreate a secure temporary file by appending a unique 6 letter string to base.Definition TUnixSystem.cxx:1523; TUnixSystem::DispatchOneEventvoid DispatchOneEvent(Bool_t pendingOnly=kFALSE) overrideDispatch a single event.Definition TUnixSystem.cxx:1093; TUnixSystem::Chmodint Chmod(const char *file, UInt_t mode) overrideSet the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TUnixSystem.cxx:1893; TUnixSystem::PrependPathNameconst char * PrependPathName(const char *dir, TString &name) overrideConcatenate a directory and a file name.Definition TUnixSystem.cxx:1552; TUnixSystem::DispatchTimersBool_t DispatchTimers(Bool_t mode)Handle and dispatch timers.Definition TUnixSystem.cxx:2979; TUnixSystem::IgnoreSignalvoid IgnoreSi",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:22890,Security,access,access,22890,"et) overrideWhen the argument is true the SIGALRM signal handler is set so that interrupted syscalls will not be ...Definition TUnixSystem.cxx:908; TUnixSystem::UnixUdpServicestatic int UnixUdpService(int port, int backlog)Open a socket, bind to it and start listening for UDP connections on the port.Definition TUnixSystem.cxx:4373; TUnixSystem::Utimeint Utime(const char *file, Long_t modtime, Long_t actime) overrideSet a files modification and access times.Definition TUnixSystem.cxx:1910; TUnixSystem::GetLinkedLibrariesconst char * GetLinkedLibraries() overrideGet list of shared libraries loaded at the start of the executable.Definition TUnixSystem.cxx:2857; TUnixSystem::GetErrorconst char * GetError() overrideReturn system error string.Definition TUnixSystem.cxx:719; TUnixSystem::GetWorkingDirectorystd::string GetWorkingDirectory() const overrideReturn working directory.Definition TUnixSystem.cxx:1463; TUnixSystem::AccessPathNameBool_t AccessPathName(const char *path, EAccessMode mode=kFileExists) overrideReturns FALSE if one can access a file using the specified access mode.Definition TUnixSystem.cxx:1579; TUnixSystem::TempFileNameFILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr) overrideCreate a secure temporary file by appending a unique 6 letter string to base.Definition TUnixSystem.cxx:1523; TUnixSystem::DispatchOneEventvoid DispatchOneEvent(Bool_t pendingOnly=kFALSE) overrideDispatch a single event.Definition TUnixSystem.cxx:1093; TUnixSystem::Chmodint Chmod(const char *file, UInt_t mode) overrideSet the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TUnixSystem.cxx:1893; TUnixSystem::PrependPathNameconst char * PrependPathName(const char *dir, TString &name) overrideConcatenate a directory and a file name.Definition TUnixSystem.cxx:1552; TUnixSystem::DispatchTimersBool_t DispatchTimers(Bool_t mode)Handle and dispatch timers.Definition TUnixSystem.cxx:2979; TUnixSystem::IgnoreSignalvoid IgnoreSi",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:23065,Security,secur,secure,23065,"og)Open a socket, bind to it and start listening for UDP connections on the port.Definition TUnixSystem.cxx:4373; TUnixSystem::Utimeint Utime(const char *file, Long_t modtime, Long_t actime) overrideSet a files modification and access times.Definition TUnixSystem.cxx:1910; TUnixSystem::GetLinkedLibrariesconst char * GetLinkedLibraries() overrideGet list of shared libraries loaded at the start of the executable.Definition TUnixSystem.cxx:2857; TUnixSystem::GetErrorconst char * GetError() overrideReturn system error string.Definition TUnixSystem.cxx:719; TUnixSystem::GetWorkingDirectorystd::string GetWorkingDirectory() const overrideReturn working directory.Definition TUnixSystem.cxx:1463; TUnixSystem::AccessPathNameBool_t AccessPathName(const char *path, EAccessMode mode=kFileExists) overrideReturns FALSE if one can access a file using the specified access mode.Definition TUnixSystem.cxx:1579; TUnixSystem::TempFileNameFILE * TempFileName(TString &base, const char *dir=nullptr, const char *suffix=nullptr) overrideCreate a secure temporary file by appending a unique 6 letter string to base.Definition TUnixSystem.cxx:1523; TUnixSystem::DispatchOneEventvoid DispatchOneEvent(Bool_t pendingOnly=kFALSE) overrideDispatch a single event.Definition TUnixSystem.cxx:1093; TUnixSystem::Chmodint Chmod(const char *file, UInt_t mode) overrideSet the file permission bits. Returns -1 in case or error, 0 otherwise.Definition TUnixSystem.cxx:1893; TUnixSystem::PrependPathNameconst char * PrependPathName(const char *dir, TString &name) overrideConcatenate a directory and a file name.Definition TUnixSystem.cxx:1552; TUnixSystem::DispatchTimersBool_t DispatchTimers(Bool_t mode)Handle and dispatch timers.Definition TUnixSystem.cxx:2979; TUnixSystem::IgnoreSignalvoid IgnoreSignal(ESignals sig, Bool_t ignore=kTRUE) overrideIf ignore is true ignore the specified signal, else restore previous behaviour.Definition TUnixSystem.cxx:895; TUnixSystem::ListSymbolsvoid ListSymbols(const char *module, ",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:20953,Testability,log,log,20953,"Unsetenvvoid Unsetenv(const char *name) overrideUnset environment variable.Definition TUnixSystem.cxx:2145; TUnixSystem::~TUnixSystemvirtual ~TUnixSystem()Reset to original state.Definition TUnixSystem.cxx:581; TUnixSystem::Abortvoid Abort(int code=0) overrideAbort the application.Definition TUnixSystem.cxx:2202; TUnixSystem::Syslogvoid Syslog(ELogLevel level, const char *mess) overrideSend mess to syslog daemon.Definition TUnixSystem.cxx:2654; TUnixSystem::GetGroupInfoUserGroup_t * GetGroupInfo(Int_t gid) overrideReturns all group info in the UserGroup_t structure.Definition TUnixSystem.cxx:2099; TUnixSystem::GetUidInt_t GetUid(const char *user=nullptr) overrideReturns the user's id. If user = 0, returns current user's id.Definition TUnixSystem.cxx:2005; TUnixSystem::ExpandPathNameBool_t ExpandPathName(TString &patbuf) overrideExpand a pathname getting rid of special shell characters like ~.Definition TUnixSystem.cxx:1749; TUnixSystem::Openlogvoid Openlog(const char *name, Int_t options, ELogFacility facility) overrideOpen connection to system log daemon.Definition TUnixSystem.cxx:2616; TUnixSystem::AcceptConnectionint AcceptConnection(int sock) overrideAccept a connection.Definition TUnixSystem.cxx:3276; TUnixSystem::NowTTime Now() overrideGet current time in milliseconds since 0:00 Jan 1 1995.Definition TUnixSystem.cxx:2970; TUnixSystem::UnixResetSignalstatic void UnixResetSignal(ESignals sig)Restore old signal handler for specified signal.Definition TUnixSystem.cxx:3821; TUnixSystem::GetServiceByNameint GetServiceByName(const char *service) overrideGet port # of internet service.Definition TUnixSystem.cxx:3171; TUnixSystem::FindFileconst char * FindFile(const char *search, TString &file, EAccessMode mode=kFileExists) overrideFind location of file ""wfil"" in a search path.Definition TUnixSystem.cxx:1927; TUnixSystem::SigAlarmInterruptsSyscallsvoid SigAlarmInterruptsSyscalls(Bool_t set) overrideWhen the argument is true the SIGALRM signal handler is set so that int",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnixSystem_8h_source.html:31567,Testability,log,log,31567,"ss file creation mode mask.Definition TUnixSystem.cxx:1901; TUnixSystem::UnixFilestatstatic int UnixFilestat(const char *path, FileStat_t &buf)Get info about a file.Definition TUnixSystem.cxx:4039; TUnixSystem::UnixRecvstatic int UnixRecv(int sock, void *buf, int len, int flag)Receive exactly length bytes into buffer.Definition TUnixSystem.cxx:4508; TUnixSystem::GetEffectiveUidInt_t GetEffectiveUid() overrideReturns the effective user id.Definition TUnixSystem.cxx:2021; TUnixSystem::FillWithCwdvoid FillWithCwd(char *cwd) constFill buffer with current working directory.Definition TUnixSystem.cxx:1473; TUnixSystem::UnixWaitchildstatic int UnixWaitchild()Wait till child is finished.Definition TUnixSystem.cxx:4130; TUnixSystem::Unlinkint Unlink(const char *name) overrideUnlink, i.e.Definition TUnixSystem.cxx:1708; TUnixSystem::ListLibrariesvoid ListLibraries(const char *regexp="""") overrideList all loaded shared libraries.Definition TUnixSystem.cxx:2848; TUnixSystem::Closelogvoid Closelog() overrideClose connection to system log daemon.Definition TUnixSystem.cxx:2663; TUnixSystem::RedirectOutputInt_t RedirectOutput(const char *name, const char *mode=""a"", RedirectHandle_t *h=nullptr) overrideRedirect standard output (stdout, stderr) to the specified file.Definition TUnixSystem.cxx:2682; TUnixSystem::Sleepvoid Sleep(UInt_t milliSec) overrideSleep milliSec milliseconds.Definition TUnixSystem.cxx:1184; TUnixSystem::ResetSignalvoid ResetSignal(ESignals sig, Bool_t reset=kTRUE) overrideIf reset is true reset the signal handler for the specified signal to the default handler,...Definition TUnixSystem.cxx:875; TUnixSystem::TempDirectoryconst char * TempDirectory() const overrideReturn a user configured or systemwide directory to create temporary files in.Definition TUnixSystem.cxx:1503; TUnixSystem::DynFindSymbolFunc_t DynFindSymbol(const char *module, const char *entry) overridedynamic linking of moduleDefinition TUnixSystem.cxx:2814; TUnixSystem::GetDynamicPathconst char * GetD",MatchSource.WIKI,doc/master/TUnixSystem_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnixSystem_8h_source.html
https://root.cern/doc/master/TUnuran_8cxx_source.html:8006,Availability,avail,available,8006,"et in unuran the function pointer for a multivariate distribution; 205 if (fUdistr != nullptr) unur_distr_free(fUdistr);; 206 fUdistr = unur_distr_cvec_new(dist.NDim() );; 207 if (fUdistr == nullptr) return false;; 208 unsigned int ret = 0;; 209 ret |= unur_distr_set_extobj(fUdistr, &dist );; 210 if ( ! dist.IsLogPdf() ) {; 211 ret |= unur_distr_cvec_set_pdf(fUdistr, &MultiDist::Pdf);; 212 ret |= unur_distr_cvec_set_dpdf(fUdistr, &MultiDist::Dpdf);; 213 ret |= unur_distr_cvec_set_pdpdf(fUdistr, &MultiDist::Pdpdf);; 214 }; 215 else {; 216 ret |= unur_distr_cvec_set_logpdf(fUdistr, &MultiDist::Pdf);; 217 ret |= unur_distr_cvec_set_dlogpdf(fUdistr, &MultiDist::Dpdf);; 218 ret |= unur_distr_cvec_set_pdlogpdf(fUdistr, &MultiDist::Pdpdf);; 219 }; 220 ; 221 const double * xmin = dist.GetLowerDomain();; 222 const double * xmax = dist.GetUpperDomain();; 223 if ( xmin != nullptr || xmax != nullptr ) {; 224 ret = unur_distr_cvec_set_domain_rect(fUdistr,xmin,xmax);; 225 if (ret != 0) {; 226 Error(""SetMultiDistribution"",""invalid domain"");; 227 return false;; 228 }; 229#ifdef OLDVERS; 230 Error(""SetMultiDistribution"",""domain setting not available in UNURAN 0.8.1"");; 231#endif; 232 ; 233 }; 234 ; 235 const double * xmode = dist.GetMode();; 236 if (xmode != nullptr) {; 237 ret = unur_distr_cvec_set_mode(fUdistr, xmode);; 238 if (ret != 0) {; 239 Error(""SetMultiDistribution"",""invalid mode"");; 240 return false;; 241 }; 242 }; 243 return (ret ==0) ? true : false;; 244}; 245 ; 246bool TUnuran::SetEmpiricalDistribution(const TUnuranEmpDist & dist) {; 247 ; 248 // internal method to set in unuran the function pointer for am empiral distribution (from histogram); 249 if (fUdistr != nullptr) unur_distr_free(fUdistr);; 250 if (dist.NDim() == 1); 251 fUdistr = unur_distr_cemp_new();; 252 else; 253 fUdistr = unur_distr_cvemp_new(dist.NDim() );; 254 ; 255 if (fUdistr == nullptr) return false;; 256 unsigned int ret = 0;; 257 ; 258 ; 259 // get info from histogram; 260 if (dist.IsBinned() ) {; 26",MatchSource.WIKI,doc/master/TUnuran_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html
https://root.cern/doc/master/TUnuran_8cxx_source.html:9161,Availability,avail,available,9161,"t.GetMode();; 236 if (xmode != nullptr) {; 237 ret = unur_distr_cvec_set_mode(fUdistr, xmode);; 238 if (ret != 0) {; 239 Error(""SetMultiDistribution"",""invalid mode"");; 240 return false;; 241 }; 242 }; 243 return (ret ==0) ? true : false;; 244}; 245 ; 246bool TUnuran::SetEmpiricalDistribution(const TUnuranEmpDist & dist) {; 247 ; 248 // internal method to set in unuran the function pointer for am empiral distribution (from histogram); 249 if (fUdistr != nullptr) unur_distr_free(fUdistr);; 250 if (dist.NDim() == 1); 251 fUdistr = unur_distr_cemp_new();; 252 else; 253 fUdistr = unur_distr_cvemp_new(dist.NDim() );; 254 ; 255 if (fUdistr == nullptr) return false;; 256 unsigned int ret = 0;; 257 ; 258 ; 259 // get info from histogram; 260 if (dist.IsBinned() ) {; 261 int nbins = dist.Data().size();; 262 double min = dist.LowerBin();; 263 double max = dist.UpperBin();; 264 const double * pv = &(dist.Data().front());; 265 ret |= unur_distr_cemp_set_hist(fUdistr, pv, nbins, min, max);; 266#ifdef OLDVERS; 267 Error(""SetEmpiricalDistribution"",""hist method not available in UNURAN 0.8.1"");; 268#endif; 269 }; 270 else {; 271 const double * pv = &dist.Data().front();; 272 // n is number of points (size/ndim); 273 int n = dist.Data().size()/dist.NDim();; 274 if (dist.NDim() == 1); 275 ret |= unur_distr_cemp_set_data(fUdistr, pv, n);; 276 else; 277 ret |= unur_distr_cvemp_set_data(fUdistr, pv, n);; 278 }; 279 if (ret != 0) {; 280 Error(""SetEmpiricalDistribution"",""invalid distribution object"");; 281 return false;; 282 }; 283 return true;; 284}; 285 ; 286 ; 287bool TUnuran::SetDiscreteDistribution(const TUnuranDiscrDist & dist); 288{; 289 // internal method to set in unuran the function pointer for a discrete univariate distribution; 290 if (fUdistr != nullptr) unur_distr_free(fUdistr);; 291 fUdistr = unur_distr_discr_new();; 292 if (fUdistr == nullptr) return false;; 293 unsigned int ret = 0;; 294 // if a probability mesh function is provided; 295 if (dist.ProbVec().empty()) {; 296 r",MatchSource.WIKI,doc/master/TUnuran_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html
https://root.cern/doc/master/TUnuran_8cxx_source.html:11671,Availability,error,error,11671,,MatchSource.WIKI,doc/master/TUnuran_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html
https://root.cern/doc/master/TUnuran_8cxx_source.html:15922,Availability,error,error,15922,"double prob, const std::string & method ) {; 463 // initialization for a Binomial; 464 double par[2];; 465 par[0] = ntot;; 466 par[1] = prob;; 467 fUdistr = unur_distr_binomial(par,2);; 468 ; 469 fMethod = method;; 470 if (fUdistr == nullptr) return false;; 471 if (! SetMethodAndInit() ) return false;; 472 if (! SetRandomGenerator() ) return false;; 473 return true;; 474}; 475 ; 476 ; 477bool TUnuran::ReInitDiscrDist(unsigned int npar, double * par) {; 478 // re-initialization of UNURAN without freeing and creating a new fGen object; 479 // works only for pre-defined distribution by changing their parameters; 480 if (!fGen ) return false;; 481 if (!fUdistr) return false;; 482 unur_distr_discr_set_pmfparams(fUdistr,par,npar);; 483 int iret = unur_reinit(fGen);; 484 if (iret) Warning(""ReInitDiscrDist"",""re-init failed - a full initizialization must be performed"");; 485 return (!iret);; 486}; 487 ; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TUnuranContDist.h; TUnuranDiscrDist.h; TUnuranEmpDist.h; TUnuranMultiContDist.h; TUnuran.h; UnuranDistrAdapter.h; UnuranRng.h; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::SetSeedvirtual void SetSeed(ULong_t seed=0)Set the random generator seed.Definition TRandom.cx",MatchSource.WIKI,doc/master/TUnuran_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html
https://root.cern/doc/master/TUnuran_8cxx_source.html:5288,Deployability,continuous,continuous,5288,"tr, const std::string & method ) {; 123 // initialization with a distribution and and generator; 124 // the distribution object is copied in and managed by this class; 125 // use std::unique_ptr to manage previously existing distribution objects; 126 TUnuranEmpDist * distNew = distr.Clone();; 127 fDist.reset(distNew);; 128 ; 129 fMethod = method;; 130 if (distr.IsBinned()) fMethod = ""hist"";; 131 else if (distr.NDim() > 1) fMethod = ""vempk"";; 132 if (! SetEmpiricalDistribution(*distNew) ) return false;; 133 if (! SetMethodAndInit() ) return false;; 134 if (! SetRandomGenerator() ) return false;; 135 return true;; 136}; 137 ; 138 ; 139bool TUnuran::SetRandomGenerator(); 140{; 141 // set an external random generator; 142 if (fRng == nullptr) return false;; 143 if (fGen == nullptr) return false;; 144 ; 145 fUrng = unur_urng_new(&UnuranRng<TRandom>::Rndm, fRng );; 146 if (fUrng == nullptr) return false;; 147 unsigned int ret = 0;; 148 ret |= unur_urng_set_delete(fUrng, &UnuranRng<TRandom>::Delete);; 149 ret |= unur_urng_set_seed(fUrng, &UnuranRng<TRandom>::Seed);; 150 if (ret != 0) return false;; 151 ; 152 unur_chg_urng( fGen, fUrng);; 153 return true;; 154}; 155 ; 156bool TUnuran::SetContDistribution(const TUnuranContDist & dist ); 157{; 158 // internal method to set in unuran the function pointer for a continuous univariate distribution; 159 if (fUdistr != nullptr) unur_distr_free(fUdistr);; 160 fUdistr = unur_distr_cont_new();; 161 if (fUdistr == nullptr) return false;; 162 unsigned int ret = 0;; 163 ret = unur_distr_set_extobj(fUdistr, &dist);; 164 if ( ! dist.IsLogPdf() ) {; 165 ret |= unur_distr_cont_set_pdf(fUdistr, &ContDist::Pdf);; 166 ret |= unur_distr_cont_set_dpdf(fUdistr, &ContDist::Dpdf);; 167 if (dist.HasCdf() ) ret |= unur_distr_cont_set_cdf(fUdistr, &ContDist::Cdf);; 168 }; 169 else {; 170 // case user provides log of pdf; 171 ret |= unur_distr_cont_set_logpdf(fUdistr, &ContDist::Pdf);; 172 ret |= unur_distr_cont_set_dlogpdf(fUdistr, &ContDist::Dpdf);; 1",MatchSource.WIKI,doc/master/TUnuran_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html
https://root.cern/doc/master/TUnuran_8cxx_source.html:16986,Deployability,continuous,continuous,16986,"5; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TUnuranContDist.h; TUnuranDiscrDist.h; TUnuranEmpDist.h; TUnuranMultiContDist.h; TUnuran.h; UnuranDistrAdapter.h; UnuranRng.h; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::SetSeedvirtual void SetSeed(ULong_t seed=0)Set the random generator seed.Definition TRandom.cxx:615; TUnuranContDistTUnuranContDist class describing one dimensional continuous distribution.Definition TUnuranContDist.h:48; TUnuranContDist::CloneTUnuranContDist * Clone() const overrideClone (required by base class)Definition TUnuranContDist.h:99; TUnuranDiscrDistTUnuranDiscrDist class for one dimensional discrete distribution.Definition TUnuranDiscrDist.h:51; TUnuranDiscrDist::CloneTUnuranDiscrDist * Clone() const overrideClone (required by base class)Definition TUnuranDiscrDist.h:101; TUnuranEmpDistTUnuranEmpDist class for describing empirical distributions.Definition TUnuranEmpDist.h:49; TUnuranEmpDist::NDimunsigned int NDim() constNumber of data dimensions.Definition TUnuranEmpDist.h:136; TUnuranEmpDist::CloneTUnuranEmpDist * Clone() const overrideClone (required by base class)Definition TUnuranEmpDist.h:108; TUnuranEmpDist::IsBinnedbool IsBinned() constFlag to control if data are binned.Definition TUnuranEmpDist.h:119; TUnuranMultiContDistTUnuranMultiContDist class describing multi dimensional continuous distributions.Def",MatchSource.WIKI,doc/master/TUnuran_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html
https://root.cern/doc/master/TUnuran_8cxx_source.html:17934,Deployability,continuous,continuous,17934,TRandom.cxx:615; TUnuranContDistTUnuranContDist class describing one dimensional continuous distribution.Definition TUnuranContDist.h:48; TUnuranContDist::CloneTUnuranContDist * Clone() const overrideClone (required by base class)Definition TUnuranContDist.h:99; TUnuranDiscrDistTUnuranDiscrDist class for one dimensional discrete distribution.Definition TUnuranDiscrDist.h:51; TUnuranDiscrDist::CloneTUnuranDiscrDist * Clone() const overrideClone (required by base class)Definition TUnuranDiscrDist.h:101; TUnuranEmpDistTUnuranEmpDist class for describing empirical distributions.Definition TUnuranEmpDist.h:49; TUnuranEmpDist::NDimunsigned int NDim() constNumber of data dimensions.Definition TUnuranEmpDist.h:136; TUnuranEmpDist::CloneTUnuranEmpDist * Clone() const overrideClone (required by base class)Definition TUnuranEmpDist.h:108; TUnuranEmpDist::IsBinnedbool IsBinned() constFlag to control if data are binned.Definition TUnuranEmpDist.h:119; TUnuranMultiContDistTUnuranMultiContDist class describing multi dimensional continuous distributions.Definition TUnuranMultiContDist.h:47; TUnuranMultiContDist::CloneTUnuranMultiContDist * Clone() const overrideClone (required by base class)Definition TUnuranMultiContDist.h:86; TUnuran::GetGenIdstd::string GetGenId() constReturn an ID string about the unuran generator method.Definition TUnuran.cxx:369; TUnuran::IsDistContbool IsDistCont() constReturn true for a univariate continuous distribution.Definition TUnuran.cxx:390; TUnuran::SetMethodAndInitbool SetMethodAndInit()change the method and initialize Unuran with the previously given distributionDefinition TUnuran.cxx:332; TUnuran::SampleDiscrint SampleDiscr()Sample discrete distributions.Definition TUnuran.cxx:407; TUnuran::fDiststd::unique_ptr< TUnuranBaseDist > fDistDefinition TUnuran.h:308; TUnuran::SetDiscreteDistributionbool SetDiscreteDistribution(const TUnuranDiscrDist &dist)Definition TUnuran.cxx:287; TUnuran::GetDistTypeint GetDistType() constReturn the type of the distr,MatchSource.WIKI,doc/master/TUnuran_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html
https://root.cern/doc/master/TUnuran_8cxx_source.html:18335,Deployability,continuous,continuous,18335,"UnuranDiscrDist * Clone() const overrideClone (required by base class)Definition TUnuranDiscrDist.h:101; TUnuranEmpDistTUnuranEmpDist class for describing empirical distributions.Definition TUnuranEmpDist.h:49; TUnuranEmpDist::NDimunsigned int NDim() constNumber of data dimensions.Definition TUnuranEmpDist.h:136; TUnuranEmpDist::CloneTUnuranEmpDist * Clone() const overrideClone (required by base class)Definition TUnuranEmpDist.h:108; TUnuranEmpDist::IsBinnedbool IsBinned() constFlag to control if data are binned.Definition TUnuranEmpDist.h:119; TUnuranMultiContDistTUnuranMultiContDist class describing multi dimensional continuous distributions.Definition TUnuranMultiContDist.h:47; TUnuranMultiContDist::CloneTUnuranMultiContDist * Clone() const overrideClone (required by base class)Definition TUnuranMultiContDist.h:86; TUnuran::GetGenIdstd::string GetGenId() constReturn an ID string about the unuran generator method.Definition TUnuran.cxx:369; TUnuran::IsDistContbool IsDistCont() constReturn true for a univariate continuous distribution.Definition TUnuran.cxx:390; TUnuran::SetMethodAndInitbool SetMethodAndInit()change the method and initialize Unuran with the previously given distributionDefinition TUnuran.cxx:332; TUnuran::SampleDiscrint SampleDiscr()Sample discrete distributions.Definition TUnuran.cxx:407; TUnuran::fDiststd::unique_ptr< TUnuranBaseDist > fDistDefinition TUnuran.h:308; TUnuran::SetDiscreteDistributionbool SetDiscreteDistribution(const TUnuranDiscrDist &dist)Definition TUnuran.cxx:287; TUnuran::GetDistTypeint GetDistType() constReturn the type of the distribution.Definition TUnuran.cxx:383; TUnuran::InitBinomialbool InitBinomial(unsigned int ntot, double prob, const std::string &method=""dstd"")Initialize method for the Binomial distribution.Definition TUnuran.cxx:462; TUnuran::SetContDistributionbool SetContDistribution(const TUnuranContDist &dist)Definition TUnuran.cxx:156; TUnuran::GetInfostd::string GetInfo(bool extended=false)Return an information",MatchSource.WIKI,doc/master/TUnuran_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html
https://root.cern/doc/master/TUnuran_8cxx_source.html:19947,Deployability,continuous,continuous,19947,"Definition TUnuran.cxx:383; TUnuran::InitBinomialbool InitBinomial(unsigned int ntot, double prob, const std::string &method=""dstd"")Initialize method for the Binomial distribution.Definition TUnuran.cxx:462; TUnuran::SetContDistributionbool SetContDistribution(const TUnuranContDist &dist)Definition TUnuran.cxx:156; TUnuran::GetInfostd::string GetInfo(bool extended=false)Return an information string about the used Unuran generator method.Definition TUnuran.cxx:362; TUnuran::SampleMultibool SampleMulti(double *x)Sample multidimensional distributions.Definition TUnuran.cxx:421; TUnuran::ReInitDiscrDistbool ReInitDiscrDist(unsigned int npar, double *params)Reinitialize UNURAN by changing the distribution parameters but maintaining same distribution and met...Definition TUnuran.cxx:477; TUnuran::TUnuranTUnuran(TRandom *r=nullptr, unsigned int log=0)Constructor with a generator instance and given level of log output.Definition TUnuran.cxx:32; TUnuran::IsDistMultiContbool IsDistMultiCont() constReturn true for a multivariate continuous distribution.Definition TUnuran.cxx:394; TUnuran::fUdistrUNUR_DISTR * fUdistrDefinition TUnuran.h:306; TUnuran::Initbool Init(const std::string &distr, const std::string &method)Initialize with Unuran string API interface.Definition TUnuran.cxx:62; TUnuran::fGenUNUR_GEN * fGenDefinition TUnuran.h:305; TUnuran::SetRandomGeneratorbool SetRandomGenerator()Definition TUnuran.cxx:139; TUnuran::SetLogLevelbool SetLogLevel(unsigned int iflag=1)set log levelDefinition TUnuran.cxx:433; TUnuran::fUrngUNUR_URNG * fUrngDefinition TUnuran.h:307; TUnuran::fRngTRandom * fRngDefinition TUnuran.h:309; TUnuran::SetMultiDistributionbool SetMultiDistribution(const TUnuranMultiContDist &dist)Definition TUnuran.cxx:202; TUnuran::IsDistEmpiricalbool IsDistEmpirical() constReturn true for an empirical distribution.Definition TUnuran.cxx:402; TUnuran::Sampledouble Sample()Sample 1D distribution.Definition TUnuran.cxx:414; TUnuran::SetEmpiricalDistributionbool SetEmpi",MatchSource.WIKI,doc/master/TUnuran_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html
https://root.cern/doc/master/TUnuran_8cxx_source.html:20170,Integrability,interface,interface,20170,"62; TUnuran::SetContDistributionbool SetContDistribution(const TUnuranContDist &dist)Definition TUnuran.cxx:156; TUnuran::GetInfostd::string GetInfo(bool extended=false)Return an information string about the used Unuran generator method.Definition TUnuran.cxx:362; TUnuran::SampleMultibool SampleMulti(double *x)Sample multidimensional distributions.Definition TUnuran.cxx:421; TUnuran::ReInitDiscrDistbool ReInitDiscrDist(unsigned int npar, double *params)Reinitialize UNURAN by changing the distribution parameters but maintaining same distribution and met...Definition TUnuran.cxx:477; TUnuran::TUnuranTUnuran(TRandom *r=nullptr, unsigned int log=0)Constructor with a generator instance and given level of log output.Definition TUnuran.cxx:32; TUnuran::IsDistMultiContbool IsDistMultiCont() constReturn true for a multivariate continuous distribution.Definition TUnuran.cxx:394; TUnuran::fUdistrUNUR_DISTR * fUdistrDefinition TUnuran.h:306; TUnuran::Initbool Init(const std::string &distr, const std::string &method)Initialize with Unuran string API interface.Definition TUnuran.cxx:62; TUnuran::fGenUNUR_GEN * fGenDefinition TUnuran.h:305; TUnuran::SetRandomGeneratorbool SetRandomGenerator()Definition TUnuran.cxx:139; TUnuran::SetLogLevelbool SetLogLevel(unsigned int iflag=1)set log levelDefinition TUnuran.cxx:433; TUnuran::fUrngUNUR_URNG * fUrngDefinition TUnuran.h:307; TUnuran::fRngTRandom * fRngDefinition TUnuran.h:309; TUnuran::SetMultiDistributionbool SetMultiDistribution(const TUnuranMultiContDist &dist)Definition TUnuran.cxx:202; TUnuran::IsDistEmpiricalbool IsDistEmpirical() constReturn true for an empirical distribution.Definition TUnuran.cxx:402; TUnuran::Sampledouble Sample()Sample 1D distribution.Definition TUnuran.cxx:414; TUnuran::SetEmpiricalDistributionbool SetEmpiricalDistribution(const TUnuranEmpDist &dist)Definition TUnuran.cxx:246; TUnuran::~TUnuran~TUnuran()Destructor.Definition TUnuran.cxx:53; TUnuran::InitPoissonbool InitPoisson(double mu, const std::string",MatchSource.WIKI,doc/master/TUnuran_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html
https://root.cern/doc/master/TUnuran_8cxx_source.html:22812,Integrability,interface,interface,22812,"()Destructor.Definition TUnuran.cxx:53; TUnuran::InitPoissonbool InitPoisson(double mu, const std::string &method=""dstd"")Initialize method for the Poisson distribution.Definition TUnuran.cxx:448; TUnuran::fMethodstd::string fMethodDefinition TUnuran.h:310; TUnuran::GetDimensionint GetDimension() constReturn the dimension of unuran generator method.Definition TUnuran.cxx:376; TUnuran::SetSeedvoid SetSeed(unsigned int seed)set the seed for the random number generatorDefinition TUnuran.cxx:429; TUnuran::IsDistDiscretebool IsDistDiscrete() constReturn true for a discrete distribution.Definition TUnuran.cxx:398; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; ContDist::Cdfstatic double Cdf(double x, const UNUR_DISTR *dist)evaluate the Cumulative distribution function, integral of the pdfDefinition UnuranDistrAdapter.h:45; ContDist::Pdfstatic double Pdf(double x, const UNUR_DISTR *dist)evaluate the probality density functionDefinition UnuranDistrAdapter.h:34; ContDist::Dpdfstatic double Dpdf(double x, const UNUR_DISTR *dist)evaluate the derivative of the pdfDefinition UnuranDistrAdapter.h:39; DiscrDist::Pmfstatic double Pmf(int x, const UNUR_DISTR *dist)evaluate the probality mesh functionDefinition UnuranDistrAdapter.h:90; DiscrDist::Cdfstatic double Cdf(int x, const UNUR_DISTR *dist)evaluate the cumulative functionDefinition UnuranDistrAdapter.h:96; MultiDist::Pdfstatic double Pdf(const double *x, UNUR_DISTR *dist)evaluate the probality density functionDefinition UnuranDistrAdapter.h:60; MultiDist::Dpdfstatic int Dpdf(double *grad, const double *x, UNUR_DISTR *dist)Definition UnuranDistrAdapter.h:66; MultiDist::Pdpdfstatic double Pdpdf(const double *x, int coord, UNUR_DISTR *dist)Definition UnuranDistrAdapter.h:73; UnuranRngUnuranRng class for interface ROOT random generators to Unuran.Definition UnuranRng.h:22. mathunuransrcTUnuran.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:45 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TUnuran_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html
https://root.cern/doc/master/TUnuran_8cxx_source.html:12249,Modifiability,extend,extended,12249,,MatchSource.WIKI,doc/master/TUnuran_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html
https://root.cern/doc/master/TUnuran_8cxx_source.html:12401,Modifiability,extend,extended,12401,,MatchSource.WIKI,doc/master/TUnuran_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html
https://root.cern/doc/master/TUnuran_8cxx_source.html:19271,Modifiability,extend,extended,19271," IsDistCont() constReturn true for a univariate continuous distribution.Definition TUnuran.cxx:390; TUnuran::SetMethodAndInitbool SetMethodAndInit()change the method and initialize Unuran with the previously given distributionDefinition TUnuran.cxx:332; TUnuran::SampleDiscrint SampleDiscr()Sample discrete distributions.Definition TUnuran.cxx:407; TUnuran::fDiststd::unique_ptr< TUnuranBaseDist > fDistDefinition TUnuran.h:308; TUnuran::SetDiscreteDistributionbool SetDiscreteDistribution(const TUnuranDiscrDist &dist)Definition TUnuran.cxx:287; TUnuran::GetDistTypeint GetDistType() constReturn the type of the distribution.Definition TUnuran.cxx:383; TUnuran::InitBinomialbool InitBinomial(unsigned int ntot, double prob, const std::string &method=""dstd"")Initialize method for the Binomial distribution.Definition TUnuran.cxx:462; TUnuran::SetContDistributionbool SetContDistribution(const TUnuranContDist &dist)Definition TUnuran.cxx:156; TUnuran::GetInfostd::string GetInfo(bool extended=false)Return an information string about the used Unuran generator method.Definition TUnuran.cxx:362; TUnuran::SampleMultibool SampleMulti(double *x)Sample multidimensional distributions.Definition TUnuran.cxx:421; TUnuran::ReInitDiscrDistbool ReInitDiscrDist(unsigned int npar, double *params)Reinitialize UNURAN by changing the distribution parameters but maintaining same distribution and met...Definition TUnuran.cxx:477; TUnuran::TUnuranTUnuran(TRandom *r=nullptr, unsigned int log=0)Constructor with a generator instance and given level of log output.Definition TUnuran.cxx:32; TUnuran::IsDistMultiContbool IsDistMultiCont() constReturn true for a multivariate continuous distribution.Definition TUnuran.cxx:394; TUnuran::fUdistrUNUR_DISTR * fUdistrDefinition TUnuran.h:306; TUnuran::Initbool Init(const std::string &distr, const std::string &method)Initialize with Unuran string API interface.Definition TUnuran.cxx:62; TUnuran::fGenUNUR_GEN * fGenDefinition TUnuran.h:305; TUnuran::SetRandomGenerator",MatchSource.WIKI,doc/master/TUnuran_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html
https://root.cern/doc/master/TUnuran_8cxx_source.html:15775,Performance,perform,performed,15775,"ouble * x); 422{; 423 // sample multidimensional distribution; 424 if (fGen == nullptr) return false;; 425 unur_sample_vec(fGen,x);; 426 return true;; 427}; 428 ; 429void TUnuran::SetSeed(unsigned int seed) {; 430 return fRng->SetSeed(seed);; 431}; 432 ; 433bool TUnuran::SetLogLevel(unsigned int debugLevel); 434{; 435 if (fGen == nullptr) return false;; 436 int ret = 0;; 437 if ( debugLevel > 1); 438 ret |= unur_chg_debug(fGen, UNUR_DEBUG_ALL);; 439 else if (debugLevel == 1); 440 ret |= unur_chg_debug(fGen, UNUR_DEBUG_ALL);; 441 else; 442 ret |= unur_chg_debug(fGen, UNUR_DEBUG_OFF);; 443 ; 444 return (ret ==0) ? true : false;; 445 ; 446}; 447 ; 448bool TUnuran::InitPoisson(double mu, const std::string & method) {; 449 // initialization for a Poisson; 450 double p[1];; 451 p[0] = mu;; 452 ; 453 fUdistr = unur_distr_poisson(p,1);; 454 ; 455 fMethod = method;; 456 if (fUdistr == nullptr) return false;; 457 if (! SetMethodAndInit() ) return false;; 458 if (! SetRandomGenerator() ) return false;; 459 return true;; 460}; 461 ; 462bool TUnuran::InitBinomial(unsigned int ntot, double prob, const std::string & method ) {; 463 // initialization for a Binomial; 464 double par[2];; 465 par[0] = ntot;; 466 par[1] = prob;; 467 fUdistr = unur_distr_binomial(par,2);; 468 ; 469 fMethod = method;; 470 if (fUdistr == nullptr) return false;; 471 if (! SetMethodAndInit() ) return false;; 472 if (! SetRandomGenerator() ) return false;; 473 return true;; 474}; 475 ; 476 ; 477bool TUnuran::ReInitDiscrDist(unsigned int npar, double * par) {; 478 // re-initialization of UNURAN without freeing and creating a new fGen object; 479 // works only for pre-defined distribution by changing their parameters; 480 if (!fGen ) return false;; 481 if (!fUdistr) return false;; 482 unur_distr_discr_set_pmfparams(fUdistr,par,npar);; 483 int iret = unur_reinit(fGen);; 484 if (iret) Warning(""ReInitDiscrDist"",""re-init failed - a full initizialization must be performed"");; 485 return (!iret);; 486}; 487 ; TError.",MatchSource.WIKI,doc/master/TUnuran_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html
https://root.cern/doc/master/TUnuran_8cxx_source.html:5822,Testability,log,log,5822," return false;; 147 unsigned int ret = 0;; 148 ret |= unur_urng_set_delete(fUrng, &UnuranRng<TRandom>::Delete);; 149 ret |= unur_urng_set_seed(fUrng, &UnuranRng<TRandom>::Seed);; 150 if (ret != 0) return false;; 151 ; 152 unur_chg_urng( fGen, fUrng);; 153 return true;; 154}; 155 ; 156bool TUnuran::SetContDistribution(const TUnuranContDist & dist ); 157{; 158 // internal method to set in unuran the function pointer for a continuous univariate distribution; 159 if (fUdistr != nullptr) unur_distr_free(fUdistr);; 160 fUdistr = unur_distr_cont_new();; 161 if (fUdistr == nullptr) return false;; 162 unsigned int ret = 0;; 163 ret = unur_distr_set_extobj(fUdistr, &dist);; 164 if ( ! dist.IsLogPdf() ) {; 165 ret |= unur_distr_cont_set_pdf(fUdistr, &ContDist::Pdf);; 166 ret |= unur_distr_cont_set_dpdf(fUdistr, &ContDist::Dpdf);; 167 if (dist.HasCdf() ) ret |= unur_distr_cont_set_cdf(fUdistr, &ContDist::Cdf);; 168 }; 169 else {; 170 // case user provides log of pdf; 171 ret |= unur_distr_cont_set_logpdf(fUdistr, &ContDist::Pdf);; 172 ret |= unur_distr_cont_set_dlogpdf(fUdistr, &ContDist::Dpdf);; 173 }; 174 ; 175 double xmin, xmax = 0;; 176 if (dist.GetDomain(xmin,xmax) ) {; 177 ret = unur_distr_cont_set_domain(fUdistr,xmin,xmax);; 178 if (ret != 0) {; 179 Error(""SetContDistribution"",""invalid domain xmin = %g xmax = %g "",xmin,xmax);; 180 return false;; 181 }; 182 }; 183 if (dist.HasMode() ) {; 184 ret = unur_distr_cont_set_mode(fUdistr, dist.Mode());; 185 if (ret != 0) {; 186 Error(""SetContDistribution"",""invalid mode given, mode = %g "",dist.Mode());; 187 return false;; 188 }; 189 }; 190 if (dist.HasPdfArea() ) {; 191 ret = unur_distr_cont_set_pdfarea(fUdistr, dist.PdfArea());; 192 if (ret != 0) {; 193 Error(""SetContDistribution"",""invalid area given, area = %g "",dist.PdfArea());; 194 return false;; 195 }; 196 }; 197 ; 198 return (ret ==0) ? true : false;; 199}; 200 ; 201 ; 202bool TUnuran::SetMultiDistribution(const TUnuranMultiContDist & dist ); 203{; 204 // internal method to ",MatchSource.WIKI,doc/master/TUnuran_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html
https://root.cern/doc/master/TUnuran_8cxx_source.html:13566,Testability,assert,assert,13566,"ur_get_genid(fGen));; 374}; 375 ; 376int TUnuran::GetDimension() const; 377{; 378 // get dimension of the UNURAN generator; 379 if (!fGen) return 0;; 380 return unur_get_dimension(fGen);; 381}; 382 ; 383int TUnuran::GetDistType() const; 384{; 385 // get type of distribution; 386 if (!fGen) return -1;; 387 return unur_distr_get_type (unur_get_distr(fGen));; 388}; 389 ; 390bool TUnuran::IsDistCont() const {; 391 if (!fGen) return false;; 392 return unur_distr_is_cont (unur_get_distr(fGen));; 393}; 394bool TUnuran::IsDistMultiCont() const {; 395 if (!fGen) return false;; 396 return unur_distr_is_cvec (unur_get_distr(fGen));; 397}; 398bool TUnuran::IsDistDiscrete() const {; 399 if (!fGen) return false;; 400 return unur_distr_is_discr (unur_get_distr(fGen));; 401}; 402bool TUnuran::IsDistEmpirical() const {; 403 if (!fGen) return false;; 404 return unur_distr_is_cemp (unur_get_distr(fGen));; 405}; 406 ; 407int TUnuran::SampleDiscr(); 408{; 409 // sample one-dimensional distribution; 410 assert(fGen != nullptr);; 411 return unur_sample_discr(fGen);; 412}; 413 ; 414double TUnuran::Sample(); 415{; 416 // sample one-dimensional distribution; 417 assert(fGen != nullptr);; 418 return unur_sample_cont(fGen);; 419}; 420 ; 421bool TUnuran::SampleMulti(double * x); 422{; 423 // sample multidimensional distribution; 424 if (fGen == nullptr) return false;; 425 unur_sample_vec(fGen,x);; 426 return true;; 427}; 428 ; 429void TUnuran::SetSeed(unsigned int seed) {; 430 return fRng->SetSeed(seed);; 431}; 432 ; 433bool TUnuran::SetLogLevel(unsigned int debugLevel); 434{; 435 if (fGen == nullptr) return false;; 436 int ret = 0;; 437 if ( debugLevel > 1); 438 ret |= unur_chg_debug(fGen, UNUR_DEBUG_ALL);; 439 else if (debugLevel == 1); 440 ret |= unur_chg_debug(fGen, UNUR_DEBUG_ALL);; 441 else; 442 ret |= unur_chg_debug(fGen, UNUR_DEBUG_OFF);; 443 ; 444 return (ret ==0) ? true : false;; 445 ; 446}; 447 ; 448bool TUnuran::InitPoisson(double mu, const std::string & method) {; 449 // initializat",MatchSource.WIKI,doc/master/TUnuran_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html
https://root.cern/doc/master/TUnuran_8cxx_source.html:13724,Testability,assert,assert,13724,"rn unur_get_dimension(fGen);; 381}; 382 ; 383int TUnuran::GetDistType() const; 384{; 385 // get type of distribution; 386 if (!fGen) return -1;; 387 return unur_distr_get_type (unur_get_distr(fGen));; 388}; 389 ; 390bool TUnuran::IsDistCont() const {; 391 if (!fGen) return false;; 392 return unur_distr_is_cont (unur_get_distr(fGen));; 393}; 394bool TUnuran::IsDistMultiCont() const {; 395 if (!fGen) return false;; 396 return unur_distr_is_cvec (unur_get_distr(fGen));; 397}; 398bool TUnuran::IsDistDiscrete() const {; 399 if (!fGen) return false;; 400 return unur_distr_is_discr (unur_get_distr(fGen));; 401}; 402bool TUnuran::IsDistEmpirical() const {; 403 if (!fGen) return false;; 404 return unur_distr_is_cemp (unur_get_distr(fGen));; 405}; 406 ; 407int TUnuran::SampleDiscr(); 408{; 409 // sample one-dimensional distribution; 410 assert(fGen != nullptr);; 411 return unur_sample_discr(fGen);; 412}; 413 ; 414double TUnuran::Sample(); 415{; 416 // sample one-dimensional distribution; 417 assert(fGen != nullptr);; 418 return unur_sample_cont(fGen);; 419}; 420 ; 421bool TUnuran::SampleMulti(double * x); 422{; 423 // sample multidimensional distribution; 424 if (fGen == nullptr) return false;; 425 unur_sample_vec(fGen,x);; 426 return true;; 427}; 428 ; 429void TUnuran::SetSeed(unsigned int seed) {; 430 return fRng->SetSeed(seed);; 431}; 432 ; 433bool TUnuran::SetLogLevel(unsigned int debugLevel); 434{; 435 if (fGen == nullptr) return false;; 436 int ret = 0;; 437 if ( debugLevel > 1); 438 ret |= unur_chg_debug(fGen, UNUR_DEBUG_ALL);; 439 else if (debugLevel == 1); 440 ret |= unur_chg_debug(fGen, UNUR_DEBUG_ALL);; 441 else; 442 ret |= unur_chg_debug(fGen, UNUR_DEBUG_OFF);; 443 ; 444 return (ret ==0) ? true : false;; 445 ; 446}; 447 ; 448bool TUnuran::InitPoisson(double mu, const std::string & method) {; 449 // initialization for a Poisson; 450 double p[1];; 451 p[0] = mu;; 452 ; 453 fUdistr = unur_distr_poisson(p,1);; 454 ; 455 fMethod = method;; 456 if (fUdistr == nullptr) re",MatchSource.WIKI,doc/master/TUnuran_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html
https://root.cern/doc/master/TUnuran_8cxx_source.html:19763,Testability,log,log,19763,"tribution(const TUnuranDiscrDist &dist)Definition TUnuran.cxx:287; TUnuran::GetDistTypeint GetDistType() constReturn the type of the distribution.Definition TUnuran.cxx:383; TUnuran::InitBinomialbool InitBinomial(unsigned int ntot, double prob, const std::string &method=""dstd"")Initialize method for the Binomial distribution.Definition TUnuran.cxx:462; TUnuran::SetContDistributionbool SetContDistribution(const TUnuranContDist &dist)Definition TUnuran.cxx:156; TUnuran::GetInfostd::string GetInfo(bool extended=false)Return an information string about the used Unuran generator method.Definition TUnuran.cxx:362; TUnuran::SampleMultibool SampleMulti(double *x)Sample multidimensional distributions.Definition TUnuran.cxx:421; TUnuran::ReInitDiscrDistbool ReInitDiscrDist(unsigned int npar, double *params)Reinitialize UNURAN by changing the distribution parameters but maintaining same distribution and met...Definition TUnuran.cxx:477; TUnuran::TUnuranTUnuran(TRandom *r=nullptr, unsigned int log=0)Constructor with a generator instance and given level of log output.Definition TUnuran.cxx:32; TUnuran::IsDistMultiContbool IsDistMultiCont() constReturn true for a multivariate continuous distribution.Definition TUnuran.cxx:394; TUnuran::fUdistrUNUR_DISTR * fUdistrDefinition TUnuran.h:306; TUnuran::Initbool Init(const std::string &distr, const std::string &method)Initialize with Unuran string API interface.Definition TUnuran.cxx:62; TUnuran::fGenUNUR_GEN * fGenDefinition TUnuran.h:305; TUnuran::SetRandomGeneratorbool SetRandomGenerator()Definition TUnuran.cxx:139; TUnuran::SetLogLevelbool SetLogLevel(unsigned int iflag=1)set log levelDefinition TUnuran.cxx:433; TUnuran::fUrngUNUR_URNG * fUrngDefinition TUnuran.h:307; TUnuran::fRngTRandom * fRngDefinition TUnuran.h:309; TUnuran::SetMultiDistributionbool SetMultiDistribution(const TUnuranMultiContDist &dist)Definition TUnuran.cxx:202; TUnuran::IsDistEmpiricalbool IsDistEmpirical() constReturn true for an empirical distribution.Definit",MatchSource.WIKI,doc/master/TUnuran_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html
https://root.cern/doc/master/TUnuran_8cxx_source.html:19826,Testability,log,log,19826,"tribution(const TUnuranDiscrDist &dist)Definition TUnuran.cxx:287; TUnuran::GetDistTypeint GetDistType() constReturn the type of the distribution.Definition TUnuran.cxx:383; TUnuran::InitBinomialbool InitBinomial(unsigned int ntot, double prob, const std::string &method=""dstd"")Initialize method for the Binomial distribution.Definition TUnuran.cxx:462; TUnuran::SetContDistributionbool SetContDistribution(const TUnuranContDist &dist)Definition TUnuran.cxx:156; TUnuran::GetInfostd::string GetInfo(bool extended=false)Return an information string about the used Unuran generator method.Definition TUnuran.cxx:362; TUnuran::SampleMultibool SampleMulti(double *x)Sample multidimensional distributions.Definition TUnuran.cxx:421; TUnuran::ReInitDiscrDistbool ReInitDiscrDist(unsigned int npar, double *params)Reinitialize UNURAN by changing the distribution parameters but maintaining same distribution and met...Definition TUnuran.cxx:477; TUnuran::TUnuranTUnuran(TRandom *r=nullptr, unsigned int log=0)Constructor with a generator instance and given level of log output.Definition TUnuran.cxx:32; TUnuran::IsDistMultiContbool IsDistMultiCont() constReturn true for a multivariate continuous distribution.Definition TUnuran.cxx:394; TUnuran::fUdistrUNUR_DISTR * fUdistrDefinition TUnuran.h:306; TUnuran::Initbool Init(const std::string &distr, const std::string &method)Initialize with Unuran string API interface.Definition TUnuran.cxx:62; TUnuran::fGenUNUR_GEN * fGenDefinition TUnuran.h:305; TUnuran::SetRandomGeneratorbool SetRandomGenerator()Definition TUnuran.cxx:139; TUnuran::SetLogLevelbool SetLogLevel(unsigned int iflag=1)set log levelDefinition TUnuran.cxx:433; TUnuran::fUrngUNUR_URNG * fUrngDefinition TUnuran.h:307; TUnuran::fRngTRandom * fRngDefinition TUnuran.h:309; TUnuran::SetMultiDistributionbool SetMultiDistribution(const TUnuranMultiContDist &dist)Definition TUnuran.cxx:202; TUnuran::IsDistEmpiricalbool IsDistEmpirical() constReturn true for an empirical distribution.Definit",MatchSource.WIKI,doc/master/TUnuran_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html
https://root.cern/doc/master/TUnuran_8cxx_source.html:20403,Testability,log,log,20403," TUnuran::SampleMultibool SampleMulti(double *x)Sample multidimensional distributions.Definition TUnuran.cxx:421; TUnuran::ReInitDiscrDistbool ReInitDiscrDist(unsigned int npar, double *params)Reinitialize UNURAN by changing the distribution parameters but maintaining same distribution and met...Definition TUnuran.cxx:477; TUnuran::TUnuranTUnuran(TRandom *r=nullptr, unsigned int log=0)Constructor with a generator instance and given level of log output.Definition TUnuran.cxx:32; TUnuran::IsDistMultiContbool IsDistMultiCont() constReturn true for a multivariate continuous distribution.Definition TUnuran.cxx:394; TUnuran::fUdistrUNUR_DISTR * fUdistrDefinition TUnuran.h:306; TUnuran::Initbool Init(const std::string &distr, const std::string &method)Initialize with Unuran string API interface.Definition TUnuran.cxx:62; TUnuran::fGenUNUR_GEN * fGenDefinition TUnuran.h:305; TUnuran::SetRandomGeneratorbool SetRandomGenerator()Definition TUnuran.cxx:139; TUnuran::SetLogLevelbool SetLogLevel(unsigned int iflag=1)set log levelDefinition TUnuran.cxx:433; TUnuran::fUrngUNUR_URNG * fUrngDefinition TUnuran.h:307; TUnuran::fRngTRandom * fRngDefinition TUnuran.h:309; TUnuran::SetMultiDistributionbool SetMultiDistribution(const TUnuranMultiContDist &dist)Definition TUnuran.cxx:202; TUnuran::IsDistEmpiricalbool IsDistEmpirical() constReturn true for an empirical distribution.Definition TUnuran.cxx:402; TUnuran::Sampledouble Sample()Sample 1D distribution.Definition TUnuran.cxx:414; TUnuran::SetEmpiricalDistributionbool SetEmpiricalDistribution(const TUnuranEmpDist &dist)Definition TUnuran.cxx:246; TUnuran::~TUnuran~TUnuran()Destructor.Definition TUnuran.cxx:53; TUnuran::InitPoissonbool InitPoisson(double mu, const std::string &method=""dstd"")Initialize method for the Poisson distribution.Definition TUnuran.cxx:448; TUnuran::fMethodstd::string fMethodDefinition TUnuran.h:310; TUnuran::GetDimensionint GetDimension() constReturn the dimension of unuran generator method.Definition TUnuran.c",MatchSource.WIKI,doc/master/TUnuran_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8cxx_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:3954,Availability,avail,available,3954,"ned int log = 0);; 87 ; 88 ; 89 /**; 90 Destructor; 91 */; 92 ~TUnuran ();; 93 ; 94 // usually copying is non trivial, so we delete this; 95 TUnuran(const TUnuran &) = delete;; 96 TUnuran & operator = (const TUnuran & rhs) = delete;; 97 TUnuran(TUnuran &&) = delete;; 98 TUnuran & operator = (TUnuran && rhs) = delete;; 99 ; 100 /**; 101 Initialize with Unuran string API interface.; 102 See https://statmath.wu.ac.at/unuran/doc/unuran.html#StringAPI; 103 ; 104 @param distr : UNU.RAN distribution string; 105 @param method : UNU.RAN method string; 106 ; 107 Here is an example using the string API:; 108 ```; 109 Tunuran unr;; 110 unr.Init(""normal(3.,0.75); domain = (0,inf)"", ""method = tdr; c = 0"");; 111 ```; 112 */; 113 bool Init(const std::string & distr, const std::string & method);; 114 ; 115 ; 116 /**; 117 Initialize method for continuous one-dimensional distribution.; 118 User must provide a distribution object (which is copied inside) and a string for a method.; 119 For the list of available method for 1D cont. distribution see the; 120 <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCONT"">UnuRan doc</A>.; 121 A re-initialization is needed whenever distribution parameters have been changed.; 122 Note that the method string can contain in addition to the method name all the specific method; 123 parameters specified using the UNURAN method string API.; 124 For example a valid string can be `""method=arou; max_segments=1000; max_sqhratio = 0.9""`; 125 */; 126 bool Init(const TUnuranContDist & distr, const std::string & method = ""auto"");; 127 ; 128 /**; 129 Initialize method for continuous multi-dimensional distribution.; 130 User must provide a distribution object (which is copied inside) and a string for a method.; 131 For the list of available method for multivariate cont. distribution see the; 132 <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCVEC"">UnuRan doc</A>; 133 A re-initialization is needed wh",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:4752,Availability,avail,available,4752,"116 /**; 117 Initialize method for continuous one-dimensional distribution.; 118 User must provide a distribution object (which is copied inside) and a string for a method.; 119 For the list of available method for 1D cont. distribution see the; 120 <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCONT"">UnuRan doc</A>.; 121 A re-initialization is needed whenever distribution parameters have been changed.; 122 Note that the method string can contain in addition to the method name all the specific method; 123 parameters specified using the UNURAN method string API.; 124 For example a valid string can be `""method=arou; max_segments=1000; max_sqhratio = 0.9""`; 125 */; 126 bool Init(const TUnuranContDist & distr, const std::string & method = ""auto"");; 127 ; 128 /**; 129 Initialize method for continuous multi-dimensional distribution.; 130 User must provide a distribution object (which is copied inside) and a string for a method.; 131 For the list of available method for multivariate cont. distribution see the; 132 <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCVEC"">UnuRan doc</A>; 133 A re-initialization is needed whenever distribution parameters have been changed.; 134 ; 135 The default method used for multi-dimensional distributions is ""vnrou""; 136 Note that some of the multi-dimensional continuous distribution methods like ""hitro"" are based on Markov-CHain sampler and; 137 they are much faster for sampling but require more time to converge. Furthermore, since they are Markov-Chain methods their; 138 generated sample values are correlated and cannot be used as i.i.d., one can instead use the obtained sample distribution.; 139 (see also the ROOT issue: #10222 ).; 140 ; 141 */; 142 bool Init(const TUnuranMultiContDist & distr, const std::string & method = ""vnrou"");; 143 ; 144 ; 145 /**; 146 Initialize method for continuous one-dimensional discrete distribution.; 147 User must provide a distribution objec",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:5836,Availability,avail,available,5836,"/unuran.html#Methods_005ffor_005fCVEC"">UnuRan doc</A>; 133 A re-initialization is needed whenever distribution parameters have been changed.; 134 ; 135 The default method used for multi-dimensional distributions is ""vnrou""; 136 Note that some of the multi-dimensional continuous distribution methods like ""hitro"" are based on Markov-CHain sampler and; 137 they are much faster for sampling but require more time to converge. Furthermore, since they are Markov-Chain methods their; 138 generated sample values are correlated and cannot be used as i.i.d., one can instead use the obtained sample distribution.; 139 (see also the ROOT issue: #10222 ).; 140 ; 141 */; 142 bool Init(const TUnuranMultiContDist & distr, const std::string & method = ""vnrou"");; 143 ; 144 ; 145 /**; 146 Initialize method for continuous one-dimensional discrete distribution.; 147 User must provide a distribution object (which is copied inside) and a string for a method.; 148 For the list of available method for 1D discrete distribution see the; 149 <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fDISCR"">UnuRan doc</A>; 150 A re-initialization is needed whenever distribution parameters have been changed.; 151 ; 152 */; 153 bool Init(const TUnuranDiscrDist & distr, const std::string & method = ""auto"");; 154 ; 155 ; 156 /**; 157 Initialize method for continuous empirical distribution.; 158 User must provide a distribution object (which is copied inside) and a string for a method.; 159 The distribution object can represent binned (only 1D) or unbinned (1D or multi-dim) data; 160 The method for the unbinned empirical distribution are based on the kernel smoothing, see; 161 <A href=""http://statmath.wu-wien.ac.at/software/unuran/doc/unuran.html#EMPK"">UnuRan doc</A>; 162 A re-initialization is needed whenever distribution parameters have been changed.; 163 ; 164 */; 165 bool Init(const TUnuranEmpDist & distr, const std::string & method = ""empk"");; 166 ; 167 ; 168 /**; 169 Initi",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:10467,Availability,error,error,10467,t;; 256 /// Return true for a discrete distribution.; 257 bool IsDistDiscrete() const;; 258 /// Return true for an empirical distribution.; 259 bool IsDistEmpirical() const;; 260 ; 261 ; 262 ; 263 /**; 264 set the seed for the random number generator; 265 */; 266 void SetSeed(unsigned int seed);; 267 ; 268 /**; 269 set log level; 270 */; 271 bool SetLogLevel(unsigned int iflag = 1);; 272 ; 273 /**; 274 set stream for log and error (not yet implemented); 275 */; 276 bool SetLogStream() { return false;}; 277 ; 278 /**; 279 used Unuran method; 280 */; 281 const std::string & MethodName() const { return fMethod; }; 282 ; 283protected:; 284 ; 285 ; 286 bool SetRandomGenerator();; 287 ; 288 bool SetContDistribution(const TUnuranContDist & dist );; 289 ; 290 bool SetMultiDistribution(const TUnuranMultiContDist & dist );; 291 ; 292 bool SetDiscreteDistribution(const TUnuranDiscrDist & dist );; 293 ; 294 bool SetEmpiricalDistribution(const TUnuranEmpDist & dist );; 295 ; 296 /**; 297 change the method and initialize Unuran with the previously given distribution; 298 */; 299 bool SetMethodAndInit();; 300 ; 301 ; 302 ; 303// private:; 304 ; 305 UNUR_GEN * fGen; //pointer to the UnuRan C generator struct; 306 UNUR_DISTR * fUdistr; //pointer to the UnuRan C distribution struct; 307 UNUR_URNG * fUrng; // pointer to Unuran C random generator struct; 308 std::unique_ptr<TUnuranBaseDist> fDist; // pointer for distribution wrapper; 309 TRandom * fRng; //pointer to ROOT random number generator; 310 std::string fMethod; //string representing the method; 311 ; 312};; 313 ; 314 ; 315#endif /* ROOT_Math_TUnuran */; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TUnuranBaseDist.h; UNUR_URNGstruct unur_urng UNUR_URNGDefinition TUnuran.h:73; UNUR_GENstruct unur_gen UNUR_GENDefinition TUnuran,MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:13370,Availability,error,error,13370,"istribution.Definition TUnuranContDist.h:48; TUnuranDiscrDistTUnuranDiscrDist class for one dimensional discrete distribution.Definition TUnuranDiscrDist.h:51; TUnuranEmpDistTUnuranEmpDist class for describing empirical distributions.Definition TUnuranEmpDist.h:49; TUnuranMultiContDistTUnuranMultiContDist class describing multi dimensional continuous distributions.Definition TUnuranMultiContDist.h:47; TUnuranTUnuran class.Definition TUnuran.h:79; TUnuran::GetGenIdstd::string GetGenId() constReturn an ID string about the unuran generator method.Definition TUnuran.cxx:369; TUnuran::IsDistContbool IsDistCont() constReturn true for a univariate continuous distribution.Definition TUnuran.cxx:390; TUnuran::SetMethodAndInitbool SetMethodAndInit()change the method and initialize Unuran with the previously given distributionDefinition TUnuran.cxx:332; TUnuran::SampleDiscrint SampleDiscr()Sample discrete distributions.Definition TUnuran.cxx:407; TUnuran::SetLogStreambool SetLogStream()set stream for log and error (not yet implemented)Definition TUnuran.h:276; TUnuran::MethodNameconst std::string & MethodName() constused Unuran methodDefinition TUnuran.h:281; TUnuran::TUnuranTUnuran(TUnuran &&)=delete; TUnuran::fDiststd::unique_ptr< TUnuranBaseDist > fDistDefinition TUnuran.h:308; TUnuran::SetDiscreteDistributionbool SetDiscreteDistribution(const TUnuranDiscrDist &dist)Definition TUnuran.cxx:287; TUnuran::GetDistTypeint GetDistType() constReturn the type of the distribution.Definition TUnuran.cxx:383; TUnuran::InitBinomialbool InitBinomial(unsigned int ntot, double prob, const std::string &method=""dstd"")Initialize method for the Binomial distribution.Definition TUnuran.cxx:462; TUnuran::SetContDistributionbool SetContDistribution(const TUnuranContDist &dist)Definition TUnuran.cxx:156; TUnuran::GetInfostd::string GetInfo(bool extended=false)Return an information string about the used Unuran generator method.Definition TUnuran.cxx:362; TUnuran::SampleMultibool SampleMulti(double",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:3795,Deployability,continuous,continuous,3795,"ur_urng UNUR_URNG;; 74 ; 75 ; 76class TRandom;; 77class TH1;; 78 ; 79class TUnuran {; 80 ; 81public:; 82 ; 83 /**; 84 Constructor with a generator instance and given level of log output; 85 */; 86 TUnuran (TRandom * r = nullptr, unsigned int log = 0);; 87 ; 88 ; 89 /**; 90 Destructor; 91 */; 92 ~TUnuran ();; 93 ; 94 // usually copying is non trivial, so we delete this; 95 TUnuran(const TUnuran &) = delete;; 96 TUnuran & operator = (const TUnuran & rhs) = delete;; 97 TUnuran(TUnuran &&) = delete;; 98 TUnuran & operator = (TUnuran && rhs) = delete;; 99 ; 100 /**; 101 Initialize with Unuran string API interface.; 102 See https://statmath.wu.ac.at/unuran/doc/unuran.html#StringAPI; 103 ; 104 @param distr : UNU.RAN distribution string; 105 @param method : UNU.RAN method string; 106 ; 107 Here is an example using the string API:; 108 ```; 109 Tunuran unr;; 110 unr.Init(""normal(3.,0.75); domain = (0,inf)"", ""method = tdr; c = 0"");; 111 ```; 112 */; 113 bool Init(const std::string & distr, const std::string & method);; 114 ; 115 ; 116 /**; 117 Initialize method for continuous one-dimensional distribution.; 118 User must provide a distribution object (which is copied inside) and a string for a method.; 119 For the list of available method for 1D cont. distribution see the; 120 <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCONT"">UnuRan doc</A>.; 121 A re-initialization is needed whenever distribution parameters have been changed.; 122 Note that the method string can contain in addition to the method name all the specific method; 123 parameters specified using the UNURAN method string API.; 124 For example a valid string can be `""method=arou; max_segments=1000; max_sqhratio = 0.9""`; 125 */; 126 bool Init(const TUnuranContDist & distr, const std::string & method = ""auto"");; 127 ; 128 /**; 129 Initialize method for continuous multi-dimensional distribution.; 130 User must provide a distribution object (which is copied inside) and a string for a ",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:4591,Deployability,continuous,continuous,4591,"e string API:; 108 ```; 109 Tunuran unr;; 110 unr.Init(""normal(3.,0.75); domain = (0,inf)"", ""method = tdr; c = 0"");; 111 ```; 112 */; 113 bool Init(const std::string & distr, const std::string & method);; 114 ; 115 ; 116 /**; 117 Initialize method for continuous one-dimensional distribution.; 118 User must provide a distribution object (which is copied inside) and a string for a method.; 119 For the list of available method for 1D cont. distribution see the; 120 <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCONT"">UnuRan doc</A>.; 121 A re-initialization is needed whenever distribution parameters have been changed.; 122 Note that the method string can contain in addition to the method name all the specific method; 123 parameters specified using the UNURAN method string API.; 124 For example a valid string can be `""method=arou; max_segments=1000; max_sqhratio = 0.9""`; 125 */; 126 bool Init(const TUnuranContDist & distr, const std::string & method = ""auto"");; 127 ; 128 /**; 129 Initialize method for continuous multi-dimensional distribution.; 130 User must provide a distribution object (which is copied inside) and a string for a method.; 131 For the list of available method for multivariate cont. distribution see the; 132 <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCVEC"">UnuRan doc</A>; 133 A re-initialization is needed whenever distribution parameters have been changed.; 134 ; 135 The default method used for multi-dimensional distributions is ""vnrou""; 136 Note that some of the multi-dimensional continuous distribution methods like ""hitro"" are based on Markov-CHain sampler and; 137 they are much faster for sampling but require more time to converge. Furthermore, since they are Markov-Chain methods their; 138 generated sample values are correlated and cannot be used as i.i.d., one can instead use the obtained sample distribution.; 139 (see also the ROOT issue: #10222 ).; 140 ; 141 */; 142 bool Ini",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:5135,Deployability,continuous,continuous,5135,"whenever distribution parameters have been changed.; 122 Note that the method string can contain in addition to the method name all the specific method; 123 parameters specified using the UNURAN method string API.; 124 For example a valid string can be `""method=arou; max_segments=1000; max_sqhratio = 0.9""`; 125 */; 126 bool Init(const TUnuranContDist & distr, const std::string & method = ""auto"");; 127 ; 128 /**; 129 Initialize method for continuous multi-dimensional distribution.; 130 User must provide a distribution object (which is copied inside) and a string for a method.; 131 For the list of available method for multivariate cont. distribution see the; 132 <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCVEC"">UnuRan doc</A>; 133 A re-initialization is needed whenever distribution parameters have been changed.; 134 ; 135 The default method used for multi-dimensional distributions is ""vnrou""; 136 Note that some of the multi-dimensional continuous distribution methods like ""hitro"" are based on Markov-CHain sampler and; 137 they are much faster for sampling but require more time to converge. Furthermore, since they are Markov-Chain methods their; 138 generated sample values are correlated and cannot be used as i.i.d., one can instead use the obtained sample distribution.; 139 (see also the ROOT issue: #10222 ).; 140 ; 141 */; 142 bool Init(const TUnuranMultiContDist & distr, const std::string & method = ""vnrou"");; 143 ; 144 ; 145 /**; 146 Initialize method for continuous one-dimensional discrete distribution.; 147 User must provide a distribution object (which is copied inside) and a string for a method.; 148 For the list of available method for 1D discrete distribution see the; 149 <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fDISCR"">UnuRan doc</A>; 150 A re-initialization is needed whenever distribution parameters have been changed.; 151 ; 152 */; 153 bool Init(const TUnuranDiscrDist & distr, co",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:5668,Deployability,continuous,continuous,5668,"nal distribution.; 130 User must provide a distribution object (which is copied inside) and a string for a method.; 131 For the list of available method for multivariate cont. distribution see the; 132 <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCVEC"">UnuRan doc</A>; 133 A re-initialization is needed whenever distribution parameters have been changed.; 134 ; 135 The default method used for multi-dimensional distributions is ""vnrou""; 136 Note that some of the multi-dimensional continuous distribution methods like ""hitro"" are based on Markov-CHain sampler and; 137 they are much faster for sampling but require more time to converge. Furthermore, since they are Markov-Chain methods their; 138 generated sample values are correlated and cannot be used as i.i.d., one can instead use the obtained sample distribution.; 139 (see also the ROOT issue: #10222 ).; 140 ; 141 */; 142 bool Init(const TUnuranMultiContDist & distr, const std::string & method = ""vnrou"");; 143 ; 144 ; 145 /**; 146 Initialize method for continuous one-dimensional discrete distribution.; 147 User must provide a distribution object (which is copied inside) and a string for a method.; 148 For the list of available method for 1D discrete distribution see the; 149 <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fDISCR"">UnuRan doc</A>; 150 A re-initialization is needed whenever distribution parameters have been changed.; 151 ; 152 */; 153 bool Init(const TUnuranDiscrDist & distr, const std::string & method = ""auto"");; 154 ; 155 ; 156 /**; 157 Initialize method for continuous empirical distribution.; 158 User must provide a distribution object (which is copied inside) and a string for a method.; 159 The distribution object can represent binned (only 1D) or unbinned (1D or multi-dim) data; 160 The method for the unbinned empirical distribution are based on the kernel smoothing, see; 161 <A href=""http://statmath.wu-wien.ac.at/software/unuran/d",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:6233,Deployability,continuous,continuous,6233,"ro"" are based on Markov-CHain sampler and; 137 they are much faster for sampling but require more time to converge. Furthermore, since they are Markov-Chain methods their; 138 generated sample values are correlated and cannot be used as i.i.d., one can instead use the obtained sample distribution.; 139 (see also the ROOT issue: #10222 ).; 140 ; 141 */; 142 bool Init(const TUnuranMultiContDist & distr, const std::string & method = ""vnrou"");; 143 ; 144 ; 145 /**; 146 Initialize method for continuous one-dimensional discrete distribution.; 147 User must provide a distribution object (which is copied inside) and a string for a method.; 148 For the list of available method for 1D discrete distribution see the; 149 <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fDISCR"">UnuRan doc</A>; 150 A re-initialization is needed whenever distribution parameters have been changed.; 151 ; 152 */; 153 bool Init(const TUnuranDiscrDist & distr, const std::string & method = ""auto"");; 154 ; 155 ; 156 /**; 157 Initialize method for continuous empirical distribution.; 158 User must provide a distribution object (which is copied inside) and a string for a method.; 159 The distribution object can represent binned (only 1D) or unbinned (1D or multi-dim) data; 160 The method for the unbinned empirical distribution are based on the kernel smoothing, see; 161 <A href=""http://statmath.wu-wien.ac.at/software/unuran/doc/unuran.html#EMPK"">UnuRan doc</A>; 162 A re-initialization is needed whenever distribution parameters have been changed.; 163 ; 164 */; 165 bool Init(const TUnuranEmpDist & distr, const std::string & method = ""empk"");; 166 ; 167 ; 168 /**; 169 Initialize method for the Poisson distribution.; 170 Used to generate poisson numbers for a constant parameter mu of the Poisson distribution.; 171 Use after the method TUnuran::SampleDiscr to generate the numbers.; 172 The flag reinit perform a fast re-initialization when only the distribution parameters; 173 ar",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:9886,Deployability,continuous,continuous,9886,to have effect; 215 */; 216 void SetRandom(TRandom * r) {; 217 fRng = r;; 218 }; 219 ; 220 /**; 221 Return instance of the random engine used.; 222 */; 223 TRandom * GetRandom() {; 224 return fRng;; 225 }; 226 ; 227 /**; 228 Return an information string about the used Unuran generator method.; 229 @param extended : if true return some helper information about the existing options of the method.; 230 */; 231 std::string GetInfo(bool extended = false);; 232 ; 233 /**; 234 Return an ID string about the unuran generator method.; 235 */; 236 std::string GetGenId() const;; 237 ; 238 /**; 239 Return the dimension of unuran generator method.; 240 For 1D method returns 1 and for the multi-dimensional case; 241 must be equal to the distribution dimension.; 242 */; 243 int GetDimension() const;; 244 ; 245 /**; 246 Return the type of the distribution.; 247 See documentation of `unuran_distr_get_type` for the possible; 248 types of distributions.; 249 */; 250 int GetDistType() const;; 251 ; 252 /// Return true for a univariate continuous distribution.; 253 bool IsDistCont() const;; 254 /// Return true for a multivariate continuous distribution.; 255 bool IsDistMultiCont() const;; 256 /// Return true for a discrete distribution.; 257 bool IsDistDiscrete() const;; 258 /// Return true for an empirical distribution.; 259 bool IsDistEmpirical() const;; 260 ; 261 ; 262 ; 263 /**; 264 set the seed for the random number generator; 265 */; 266 void SetSeed(unsigned int seed);; 267 ; 268 /**; 269 set log level; 270 */; 271 bool SetLogLevel(unsigned int iflag = 1);; 272 ; 273 /**; 274 set stream for log and error (not yet implemented); 275 */; 276 bool SetLogStream() { return false;}; 277 ; 278 /**; 279 used Unuran method; 280 */; 281 const std::string & MethodName() const { return fMethod; }; 282 ; 283protected:; 284 ; 285 ; 286 bool SetRandomGenerator();; 287 ; 288 bool SetContDistribution(const TUnuranContDist & dist );; 289 ; 290 bool SetMultiDistribution(const TUnuranMultiContDist & di,MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:9981,Deployability,continuous,continuous,9981,eturn instance of the random engine used.; 222 */; 223 TRandom * GetRandom() {; 224 return fRng;; 225 }; 226 ; 227 /**; 228 Return an information string about the used Unuran generator method.; 229 @param extended : if true return some helper information about the existing options of the method.; 230 */; 231 std::string GetInfo(bool extended = false);; 232 ; 233 /**; 234 Return an ID string about the unuran generator method.; 235 */; 236 std::string GetGenId() const;; 237 ; 238 /**; 239 Return the dimension of unuran generator method.; 240 For 1D method returns 1 and for the multi-dimensional case; 241 must be equal to the distribution dimension.; 242 */; 243 int GetDimension() const;; 244 ; 245 /**; 246 Return the type of the distribution.; 247 See documentation of `unuran_distr_get_type` for the possible; 248 types of distributions.; 249 */; 250 int GetDistType() const;; 251 ; 252 /// Return true for a univariate continuous distribution.; 253 bool IsDistCont() const;; 254 /// Return true for a multivariate continuous distribution.; 255 bool IsDistMultiCont() const;; 256 /// Return true for a discrete distribution.; 257 bool IsDistDiscrete() const;; 258 /// Return true for an empirical distribution.; 259 bool IsDistEmpirical() const;; 260 ; 261 ; 262 ; 263 /**; 264 set the seed for the random number generator; 265 */; 266 void SetSeed(unsigned int seed);; 267 ; 268 /**; 269 set log level; 270 */; 271 bool SetLogLevel(unsigned int iflag = 1);; 272 ; 273 /**; 274 set stream for log and error (not yet implemented); 275 */; 276 bool SetLogStream() { return false;}; 277 ; 278 /**; 279 used Unuran method; 280 */; 281 const std::string & MethodName() const { return fMethod; }; 282 ; 283protected:; 284 ; 285 ; 286 bool SetRandomGenerator();; 287 ; 288 bool SetContDistribution(const TUnuranContDist & dist );; 289 ; 290 bool SetMultiDistribution(const TUnuranMultiContDist & dist );; 291 ; 292 bool SetDiscreteDistribution(const TUnuranDiscrDist & dist );; 293 ; 294 bool SetEmp,MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:12345,Deployability,continuous,continuous,12345,; 307 UNUR_URNG * fUrng; // pointer to Unuran C random generator struct; 308 std::unique_ptr<TUnuranBaseDist> fDist; // pointer for distribution wrapper; 309 TRandom * fRng; //pointer to ROOT random number generator; 310 std::string fMethod; //string representing the method; 311 ; 312};; 313 ; 314 ; 315#endif /* ROOT_Math_TUnuran */; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TUnuranBaseDist.h; UNUR_URNGstruct unur_urng UNUR_URNGDefinition TUnuran.h:73; UNUR_GENstruct unur_gen UNUR_GENDefinition TUnuran.h:64; UNUR_DISTRstruct unur_distr UNUR_DISTRDefinition TUnuran.h:70; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TUnuranContDistTUnuranContDist class describing one dimensional continuous distribution.Definition TUnuranContDist.h:48; TUnuranDiscrDistTUnuranDiscrDist class for one dimensional discrete distribution.Definition TUnuranDiscrDist.h:51; TUnuranEmpDistTUnuranEmpDist class for describing empirical distributions.Definition TUnuranEmpDist.h:49; TUnuranMultiContDistTUnuranMultiContDist class describing multi dimensional continuous distributions.Definition TUnuranMultiContDist.h:47; TUnuranTUnuran class.Definition TUnuran.h:79; TUnuran::GetGenIdstd::string GetGenId() constReturn an ID string about the unuran generator method.Definition TUnuran.cxx:369; TUnuran::IsDistContbool IsDistCont() constReturn true for a univariate continuous distribution.Definition TUnuran.cxx:390; TUnuran::SetMethodAndInitbool SetMethodAndInit()change the method and initialize Unuran with the previously given distributionDefinition TUnuran.cxx:332; TUnuran::SampleDiscrint SampleDiscr()Sample discrete distributions.Definition TUnuran.cxx:407; TUnuran::SetLog,MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:12699,Deployability,continuous,continuous,12699,tion_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TUnuranBaseDist.h; UNUR_URNGstruct unur_urng UNUR_URNGDefinition TUnuran.h:73; UNUR_GENstruct unur_gen UNUR_GENDefinition TUnuran.h:64; UNUR_DISTRstruct unur_distr UNUR_DISTRDefinition TUnuran.h:70; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TUnuranContDistTUnuranContDist class describing one dimensional continuous distribution.Definition TUnuranContDist.h:48; TUnuranDiscrDistTUnuranDiscrDist class for one dimensional discrete distribution.Definition TUnuranDiscrDist.h:51; TUnuranEmpDistTUnuranEmpDist class for describing empirical distributions.Definition TUnuranEmpDist.h:49; TUnuranMultiContDistTUnuranMultiContDist class describing multi dimensional continuous distributions.Definition TUnuranMultiContDist.h:47; TUnuranTUnuran class.Definition TUnuran.h:79; TUnuran::GetGenIdstd::string GetGenId() constReturn an ID string about the unuran generator method.Definition TUnuran.cxx:369; TUnuran::IsDistContbool IsDistCont() constReturn true for a univariate continuous distribution.Definition TUnuran.cxx:390; TUnuran::SetMethodAndInitbool SetMethodAndInit()change the method and initialize Unuran with the previously given distributionDefinition TUnuran.cxx:332; TUnuran::SampleDiscrint SampleDiscr()Sample discrete distributions.Definition TUnuran.cxx:407; TUnuran::SetLogStreambool SetLogStream()set stream for log and error (not yet implemented)Definition TUnuran.h:276; TUnuran::MethodNameconst std::string & MethodName() constused Unuran methodDefinition TUnuran.h:281; TUnuran::TUnuranTUnuran(TUnuran &&)=delete; TUnuran::fDiststd::unique_ptr< TUnuranBaseDist > fDistDefinition TUnuran.h:308; TUnuran::SetDiscreteDis,MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:13006,Deployability,continuous,continuous,13006,"uran.h:73; UNUR_GENstruct unur_gen UNUR_GENDefinition TUnuran.h:64; UNUR_DISTRstruct unur_distr UNUR_DISTRDefinition TUnuran.h:70; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TUnuranContDistTUnuranContDist class describing one dimensional continuous distribution.Definition TUnuranContDist.h:48; TUnuranDiscrDistTUnuranDiscrDist class for one dimensional discrete distribution.Definition TUnuranDiscrDist.h:51; TUnuranEmpDistTUnuranEmpDist class for describing empirical distributions.Definition TUnuranEmpDist.h:49; TUnuranMultiContDistTUnuranMultiContDist class describing multi dimensional continuous distributions.Definition TUnuranMultiContDist.h:47; TUnuranTUnuran class.Definition TUnuran.h:79; TUnuran::GetGenIdstd::string GetGenId() constReturn an ID string about the unuran generator method.Definition TUnuran.cxx:369; TUnuran::IsDistContbool IsDistCont() constReturn true for a univariate continuous distribution.Definition TUnuran.cxx:390; TUnuran::SetMethodAndInitbool SetMethodAndInit()change the method and initialize Unuran with the previously given distributionDefinition TUnuran.cxx:332; TUnuran::SampleDiscrint SampleDiscr()Sample discrete distributions.Definition TUnuran.cxx:407; TUnuran::SetLogStreambool SetLogStream()set stream for log and error (not yet implemented)Definition TUnuran.h:276; TUnuran::MethodNameconst std::string & MethodName() constused Unuran methodDefinition TUnuran.h:281; TUnuran::TUnuranTUnuran(TUnuran &&)=delete; TUnuran::fDiststd::unique_ptr< TUnuranBaseDist > fDistDefinition TUnuran.h:308; TUnuran::SetDiscreteDistributionbool SetDiscreteDistribution(const TUnuranDiscrDist &dist)Definition TUnuran.cxx:287; TUnuran::GetDistTypeint GetDistType() constReturn the type of the distribution.Definition TUnuran.cxx:383; TUnuran::InitBinomialbool InitBinomial(unsigned int ntot, double prob, const std::string &method=""dstd"")I",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:14721,Deployability,continuous,continuous,14721,"tDiscreteDistribution(const TUnuranDiscrDist &dist)Definition TUnuran.cxx:287; TUnuran::GetDistTypeint GetDistType() constReturn the type of the distribution.Definition TUnuran.cxx:383; TUnuran::InitBinomialbool InitBinomial(unsigned int ntot, double prob, const std::string &method=""dstd"")Initialize method for the Binomial distribution.Definition TUnuran.cxx:462; TUnuran::SetContDistributionbool SetContDistribution(const TUnuranContDist &dist)Definition TUnuran.cxx:156; TUnuran::GetInfostd::string GetInfo(bool extended=false)Return an information string about the used Unuran generator method.Definition TUnuran.cxx:362; TUnuran::SampleMultibool SampleMulti(double *x)Sample multidimensional distributions.Definition TUnuran.cxx:421; TUnuran::ReInitDiscrDistbool ReInitDiscrDist(unsigned int npar, double *params)Reinitialize UNURAN by changing the distribution parameters but maintaining same distribution and met...Definition TUnuran.cxx:477; TUnuran::IsDistMultiContbool IsDistMultiCont() constReturn true for a multivariate continuous distribution.Definition TUnuran.cxx:394; TUnuran::fUdistrUNUR_DISTR * fUdistrDefinition TUnuran.h:306; TUnuran::Initbool Init(const std::string &distr, const std::string &method)Initialize with Unuran string API interface.Definition TUnuran.cxx:62; TUnuran::operator=TUnuran & operator=(const TUnuran &rhs)=delete; TUnuran::fGenUNUR_GEN * fGenDefinition TUnuran.h:305; TUnuran::SetRandomGeneratorbool SetRandomGenerator()Definition TUnuran.cxx:139; TUnuran::SetLogLevelbool SetLogLevel(unsigned int iflag=1)set log levelDefinition TUnuran.cxx:433; TUnuran::fUrngUNUR_URNG * fUrngDefinition TUnuran.h:307; TUnuran::fRngTRandom * fRngDefinition TUnuran.h:309; TUnuran::SetMultiDistributionbool SetMultiDistribution(const TUnuranMultiContDist &dist)Definition TUnuran.cxx:202; TUnuran::IsDistEmpiricalbool IsDistEmpirical() constReturn true for an empirical distribution.Definition TUnuran.cxx:402; TUnuran::Sampledouble Sample()Sample 1D distribution.Defini",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:964,Integrability,wrap,wraps,964,". ROOT: math/unuran/inc/TUnuran.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TUnuran.h. Go to the documentation of this file. 1// @(#)root/unuran:$Id$; 2// Author: L. Moneta Tue Sep 26 16:25:09 2006; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class TUnuran; 12 ; 13#ifndef ROOT_TUnuran; 14#define ROOT_TUnuran; 15 ; 16#include <string>; 17 ; 18#include ""TUnuranBaseDist.h""; 19 ; 20 ; 21class TUnuranContDist;; 22class TUnuranDiscrDist;; 23class TUnuranMultiContDist;; 24class TUnuranEmpDist;; 25 ; 26#include <memory>; 27 ; 28 ; 29/**; 30 ; 31 \class TUnuran; 32 \ingroup Unuran; 33 ; 34 TUnuran class.; 35 Interface to the UNU.RAN package for generating non uniform random; 36 numbers. This class wraps the UNU.RAN calls in C++ methods.; 37 It provides methods for initializing Unuran and then to sample the; 38 desired distribution.; 39 It provides support for initializing UNU.RAN in these following way (various signatures; 40 for TUnuran::Init); 41 - with string API via TUnuran::Init passing the distribution type and the method; 42 - using a one-dimensional distribution object defined by TUnuranContDist; 43 - using a multi-dimensional distribution object defined by TUnuranMultiContDist; 44 - using a discrete one-dimensional distribution object defined by TUnuranDiscrDist; 45 - using an empirical distribution defined by TUnuranEmpDist; 46 - using pre-defined distributions. Presently only support for Poisson (TUnuran::InitPoisson); 47 and Binomial (TUnuran::InitBinomial) are provided. Other distributions can however be generated; 48 using the previous methods (in particular via the string API); 49 ; 50 The sampling is provided via these methods:; 51 - TUnuran::Sample() returns a double for all one-dimensional distrib",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:3329,Integrability,interface,interface,3329," 49 ; 50 The sampling is provided via these methods:; 51 - TUnuran::Sample() returns a double for all one-dimensional distribution; 52 - TUnuran::SampleDiscr() returns an integer for one-dimensional discrete distribution; 53 - TUnuran::Sample(double *) sample a multi-dimensional distribution. A pointer to a vector with; 54 size at least equal to the distribution dimension must be passed; 55 ; 56 In addition is possible to set the random number generator in the constructor of the class, its seed; 57 via the TUnuran::SetSeed() method.; 58*/; 59 ; 60 ; 61 ; 62//class TUnuranGenerator;; 63struct unur_gen;; 64typedef struct unur_gen UNUR_GEN;; 65 ; 66// struct unur_urng_generic;; 67// typedef struct unur_urng_generic UNUR_URNG;; 68 ; 69struct unur_distr;; 70typedef struct unur_distr UNUR_DISTR;; 71 ; 72struct unur_urng;; 73typedef struct unur_urng UNUR_URNG;; 74 ; 75 ; 76class TRandom;; 77class TH1;; 78 ; 79class TUnuran {; 80 ; 81public:; 82 ; 83 /**; 84 Constructor with a generator instance and given level of log output; 85 */; 86 TUnuran (TRandom * r = nullptr, unsigned int log = 0);; 87 ; 88 ; 89 /**; 90 Destructor; 91 */; 92 ~TUnuran ();; 93 ; 94 // usually copying is non trivial, so we delete this; 95 TUnuran(const TUnuran &) = delete;; 96 TUnuran & operator = (const TUnuran & rhs) = delete;; 97 TUnuran(TUnuran &&) = delete;; 98 TUnuran & operator = (TUnuran && rhs) = delete;; 99 ; 100 /**; 101 Initialize with Unuran string API interface.; 102 See https://statmath.wu.ac.at/unuran/doc/unuran.html#StringAPI; 103 ; 104 @param distr : UNU.RAN distribution string; 105 @param method : UNU.RAN method string; 106 ; 107 Here is an example using the string API:; 108 ```; 109 Tunuran unr;; 110 unr.Init(""normal(3.,0.75); domain = (0,inf)"", ""method = tdr; c = 0"");; 111 ```; 112 */; 113 bool Init(const std::string & distr, const std::string & method);; 114 ; 115 ; 116 /**; 117 Initialize method for continuous one-dimensional distribution.; 118 User must provide a distribution obj",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:11467,Integrability,wrap,wrapper,11467,t;; 256 /// Return true for a discrete distribution.; 257 bool IsDistDiscrete() const;; 258 /// Return true for an empirical distribution.; 259 bool IsDistEmpirical() const;; 260 ; 261 ; 262 ; 263 /**; 264 set the seed for the random number generator; 265 */; 266 void SetSeed(unsigned int seed);; 267 ; 268 /**; 269 set log level; 270 */; 271 bool SetLogLevel(unsigned int iflag = 1);; 272 ; 273 /**; 274 set stream for log and error (not yet implemented); 275 */; 276 bool SetLogStream() { return false;}; 277 ; 278 /**; 279 used Unuran method; 280 */; 281 const std::string & MethodName() const { return fMethod; }; 282 ; 283protected:; 284 ; 285 ; 286 bool SetRandomGenerator();; 287 ; 288 bool SetContDistribution(const TUnuranContDist & dist );; 289 ; 290 bool SetMultiDistribution(const TUnuranMultiContDist & dist );; 291 ; 292 bool SetDiscreteDistribution(const TUnuranDiscrDist & dist );; 293 ; 294 bool SetEmpiricalDistribution(const TUnuranEmpDist & dist );; 295 ; 296 /**; 297 change the method and initialize Unuran with the previously given distribution; 298 */; 299 bool SetMethodAndInit();; 300 ; 301 ; 302 ; 303// private:; 304 ; 305 UNUR_GEN * fGen; //pointer to the UnuRan C generator struct; 306 UNUR_DISTR * fUdistr; //pointer to the UnuRan C distribution struct; 307 UNUR_URNG * fUrng; // pointer to Unuran C random generator struct; 308 std::unique_ptr<TUnuranBaseDist> fDist; // pointer for distribution wrapper; 309 TRandom * fRng; //pointer to ROOT random number generator; 310 std::string fMethod; //string representing the method; 311 ; 312};; 313 ; 314 ; 315#endif /* ROOT_Math_TUnuran */; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TUnuranBaseDist.h; UNUR_URNGstruct unur_urng UNUR_URNGDefinition TUnuran.h:73; UNUR_GENstruct unur_gen UNUR_GENDefinition TUnuran,MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:14944,Integrability,interface,interface,14944,"ialbool InitBinomial(unsigned int ntot, double prob, const std::string &method=""dstd"")Initialize method for the Binomial distribution.Definition TUnuran.cxx:462; TUnuran::SetContDistributionbool SetContDistribution(const TUnuranContDist &dist)Definition TUnuran.cxx:156; TUnuran::GetInfostd::string GetInfo(bool extended=false)Return an information string about the used Unuran generator method.Definition TUnuran.cxx:362; TUnuran::SampleMultibool SampleMulti(double *x)Sample multidimensional distributions.Definition TUnuran.cxx:421; TUnuran::ReInitDiscrDistbool ReInitDiscrDist(unsigned int npar, double *params)Reinitialize UNURAN by changing the distribution parameters but maintaining same distribution and met...Definition TUnuran.cxx:477; TUnuran::IsDistMultiContbool IsDistMultiCont() constReturn true for a multivariate continuous distribution.Definition TUnuran.cxx:394; TUnuran::fUdistrUNUR_DISTR * fUdistrDefinition TUnuran.h:306; TUnuran::Initbool Init(const std::string &distr, const std::string &method)Initialize with Unuran string API interface.Definition TUnuran.cxx:62; TUnuran::operator=TUnuran & operator=(const TUnuran &rhs)=delete; TUnuran::fGenUNUR_GEN * fGenDefinition TUnuran.h:305; TUnuran::SetRandomGeneratorbool SetRandomGenerator()Definition TUnuran.cxx:139; TUnuran::SetLogLevelbool SetLogLevel(unsigned int iflag=1)set log levelDefinition TUnuran.cxx:433; TUnuran::fUrngUNUR_URNG * fUrngDefinition TUnuran.h:307; TUnuran::fRngTRandom * fRngDefinition TUnuran.h:309; TUnuran::SetMultiDistributionbool SetMultiDistribution(const TUnuranMultiContDist &dist)Definition TUnuran.cxx:202; TUnuran::IsDistEmpiricalbool IsDistEmpirical() constReturn true for an empirical distribution.Definition TUnuran.cxx:402; TUnuran::Sampledouble Sample()Sample 1D distribution.Definition TUnuran.cxx:414; TUnuran::SetEmpiricalDistributionbool SetEmpiricalDistribution(const TUnuranEmpDist &dist)Definition TUnuran.cxx:246; TUnuran::GetRandomTRandom * GetRandom()Return instance of the ra",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:9162,Modifiability,extend,extended,9162,"ool ReInitDiscrDist(unsigned int npar, double * params);; 193 ; 194 /**; 195 Sample 1D distribution.; 196 User is responsible for having previously correctly initialized with TUnuran::Init; 197 */; 198 double Sample();; 199 ; 200 /**; 201 Sample multidimensional distributions.; 202 User is responsible for having previously correctly initialized with TUnuran::Init; 203 */; 204 bool SampleMulti(double * x);; 205 ; 206 /**; 207 Sample discrete distributions.; 208 User is responsible for having previously correctly initialized with TUnuran::Init; 209 */; 210 int SampleDiscr();; 211 ; 212 /**; 213 Set the random engine.; 214 Must be called before init to have effect; 215 */; 216 void SetRandom(TRandom * r) {; 217 fRng = r;; 218 }; 219 ; 220 /**; 221 Return instance of the random engine used.; 222 */; 223 TRandom * GetRandom() {; 224 return fRng;; 225 }; 226 ; 227 /**; 228 Return an information string about the used Unuran generator method.; 229 @param extended : if true return some helper information about the existing options of the method.; 230 */; 231 std::string GetInfo(bool extended = false);; 232 ; 233 /**; 234 Return an ID string about the unuran generator method.; 235 */; 236 std::string GetGenId() const;; 237 ; 238 /**; 239 Return the dimension of unuran generator method.; 240 For 1D method returns 1 and for the multi-dimensional case; 241 must be equal to the distribution dimension.; 242 */; 243 int GetDimension() const;; 244 ; 245 /**; 246 Return the type of the distribution.; 247 See documentation of `unuran_distr_get_type` for the possible; 248 types of distributions.; 249 */; 250 int GetDistType() const;; 251 ; 252 /// Return true for a univariate continuous distribution.; 253 bool IsDistCont() const;; 254 /// Return true for a multivariate continuous distribution.; 255 bool IsDistMultiCont() const;; 256 /// Return true for a discrete distribution.; 257 bool IsDistDiscrete() const;; 258 /// Return true for an empirical distribution.; 259 bool IsDistEmpirica",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:9292,Modifiability,extend,extended,9292,onsible for having previously correctly initialized with TUnuran::Init; 197 */; 198 double Sample();; 199 ; 200 /**; 201 Sample multidimensional distributions.; 202 User is responsible for having previously correctly initialized with TUnuran::Init; 203 */; 204 bool SampleMulti(double * x);; 205 ; 206 /**; 207 Sample discrete distributions.; 208 User is responsible for having previously correctly initialized with TUnuran::Init; 209 */; 210 int SampleDiscr();; 211 ; 212 /**; 213 Set the random engine.; 214 Must be called before init to have effect; 215 */; 216 void SetRandom(TRandom * r) {; 217 fRng = r;; 218 }; 219 ; 220 /**; 221 Return instance of the random engine used.; 222 */; 223 TRandom * GetRandom() {; 224 return fRng;; 225 }; 226 ; 227 /**; 228 Return an information string about the used Unuran generator method.; 229 @param extended : if true return some helper information about the existing options of the method.; 230 */; 231 std::string GetInfo(bool extended = false);; 232 ; 233 /**; 234 Return an ID string about the unuran generator method.; 235 */; 236 std::string GetGenId() const;; 237 ; 238 /**; 239 Return the dimension of unuran generator method.; 240 For 1D method returns 1 and for the multi-dimensional case; 241 must be equal to the distribution dimension.; 242 */; 243 int GetDimension() const;; 244 ; 245 /**; 246 Return the type of the distribution.; 247 See documentation of `unuran_distr_get_type` for the possible; 248 types of distributions.; 249 */; 250 int GetDistType() const;; 251 ; 252 /// Return true for a univariate continuous distribution.; 253 bool IsDistCont() const;; 254 /// Return true for a multivariate continuous distribution.; 255 bool IsDistMultiCont() const;; 256 /// Return true for a discrete distribution.; 257 bool IsDistDiscrete() const;; 258 /// Return true for an empirical distribution.; 259 bool IsDistEmpirical() const;; 260 ; 261 ; 262 ; 263 /**; 264 set the seed for the random number generator; 265 */; 266 void SetSeed(unsi,MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:14203,Modifiability,extend,extended,14203,"::SampleDiscrint SampleDiscr()Sample discrete distributions.Definition TUnuran.cxx:407; TUnuran::SetLogStreambool SetLogStream()set stream for log and error (not yet implemented)Definition TUnuran.h:276; TUnuran::MethodNameconst std::string & MethodName() constused Unuran methodDefinition TUnuran.h:281; TUnuran::TUnuranTUnuran(TUnuran &&)=delete; TUnuran::fDiststd::unique_ptr< TUnuranBaseDist > fDistDefinition TUnuran.h:308; TUnuran::SetDiscreteDistributionbool SetDiscreteDistribution(const TUnuranDiscrDist &dist)Definition TUnuran.cxx:287; TUnuran::GetDistTypeint GetDistType() constReturn the type of the distribution.Definition TUnuran.cxx:383; TUnuran::InitBinomialbool InitBinomial(unsigned int ntot, double prob, const std::string &method=""dstd"")Initialize method for the Binomial distribution.Definition TUnuran.cxx:462; TUnuran::SetContDistributionbool SetContDistribution(const TUnuranContDist &dist)Definition TUnuran.cxx:156; TUnuran::GetInfostd::string GetInfo(bool extended=false)Return an information string about the used Unuran generator method.Definition TUnuran.cxx:362; TUnuran::SampleMultibool SampleMulti(double *x)Sample multidimensional distributions.Definition TUnuran.cxx:421; TUnuran::ReInitDiscrDistbool ReInitDiscrDist(unsigned int npar, double *params)Reinitialize UNURAN by changing the distribution parameters but maintaining same distribution and met...Definition TUnuran.cxx:477; TUnuran::IsDistMultiContbool IsDistMultiCont() constReturn true for a multivariate continuous distribution.Definition TUnuran.cxx:394; TUnuran::fUdistrUNUR_DISTR * fUdistrDefinition TUnuran.h:306; TUnuran::Initbool Init(const std::string &distr, const std::string &method)Initialize with Unuran string API interface.Definition TUnuran.cxx:62; TUnuran::operator=TUnuran & operator=(const TUnuran &rhs)=delete; TUnuran::fGenUNUR_GEN * fGenDefinition TUnuran.h:305; TUnuran::SetRandomGeneratorbool SetRandomGenerator()Definition TUnuran.cxx:139; TUnuran::SetLogLevelbool SetLogLevel(un",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:7098,Performance,perform,perform,7098,"tr, const std::string & method = ""auto"");; 154 ; 155 ; 156 /**; 157 Initialize method for continuous empirical distribution.; 158 User must provide a distribution object (which is copied inside) and a string for a method.; 159 The distribution object can represent binned (only 1D) or unbinned (1D or multi-dim) data; 160 The method for the unbinned empirical distribution are based on the kernel smoothing, see; 161 <A href=""http://statmath.wu-wien.ac.at/software/unuran/doc/unuran.html#EMPK"">UnuRan doc</A>; 162 A re-initialization is needed whenever distribution parameters have been changed.; 163 ; 164 */; 165 bool Init(const TUnuranEmpDist & distr, const std::string & method = ""empk"");; 166 ; 167 ; 168 /**; 169 Initialize method for the Poisson distribution.; 170 Used to generate poisson numbers for a constant parameter mu of the Poisson distribution.; 171 Use after the method TUnuran::SampleDiscr to generate the numbers.; 172 The flag reinit perform a fast re-initialization when only the distribution parameters; 173 are changed in the subsequent calls.; 174 If the same TUnuran object is used to generate with other distributions it cannot be used.; 175 */; 176 bool InitPoisson(double mu, const std::string & method = ""dstd"");; 177 ; 178 /**; 179 Initialize method for the Binomial distribution.; 180 Used to generate poisson numbers for a constant parameters (n,p) of the Binomial distribution.; 181 Use after the method TUnuran::SampleDiscr to generate the numbers.; 182 The flag reinit perform a fast re-initialization when only the distribution parameters; 183 are changed in the subsequent calls.; 184 If the same TUnuran object is used to generate with other distributions it cannot be used.; 185 */; 186 bool InitBinomial(unsigned int ntot, double prob, const std::string & method = ""dstd"");; 187 ; 188 /**; 189 Reinitialize UNURAN by changing the distribution parameters but maintaining same distribution and method.; 190 It is implemented now only for predefined discrete dis",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:7648,Performance,perform,perform,7648,"er distribution parameters have been changed.; 163 ; 164 */; 165 bool Init(const TUnuranEmpDist & distr, const std::string & method = ""empk"");; 166 ; 167 ; 168 /**; 169 Initialize method for the Poisson distribution.; 170 Used to generate poisson numbers for a constant parameter mu of the Poisson distribution.; 171 Use after the method TUnuran::SampleDiscr to generate the numbers.; 172 The flag reinit perform a fast re-initialization when only the distribution parameters; 173 are changed in the subsequent calls.; 174 If the same TUnuran object is used to generate with other distributions it cannot be used.; 175 */; 176 bool InitPoisson(double mu, const std::string & method = ""dstd"");; 177 ; 178 /**; 179 Initialize method for the Binomial distribution.; 180 Used to generate poisson numbers for a constant parameters (n,p) of the Binomial distribution.; 181 Use after the method TUnuran::SampleDiscr to generate the numbers.; 182 The flag reinit perform a fast re-initialization when only the distribution parameters; 183 are changed in the subsequent calls.; 184 If the same TUnuran object is used to generate with other distributions it cannot be used.; 185 */; 186 bool InitBinomial(unsigned int ntot, double prob, const std::string & method = ""dstd"");; 187 ; 188 /**; 189 Reinitialize UNURAN by changing the distribution parameters but maintaining same distribution and method.; 190 It is implemented now only for predefined discrete distributions like the poisson or the binomial; 191 */; 192 bool ReInitDiscrDist(unsigned int npar, double * params);; 193 ; 194 /**; 195 Sample 1D distribution.; 196 User is responsible for having previously correctly initialized with TUnuran::Init; 197 */; 198 double Sample();; 199 ; 200 /**; 201 Sample multidimensional distributions.; 202 User is responsible for having previously correctly initialized with TUnuran::Init; 203 */; 204 bool SampleMulti(double * x);; 205 ; 206 /**; 207 Sample discrete distributions.; 208 User is responsible for hav",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:2898,Testability,log,log,2898," 49 ; 50 The sampling is provided via these methods:; 51 - TUnuran::Sample() returns a double for all one-dimensional distribution; 52 - TUnuran::SampleDiscr() returns an integer for one-dimensional discrete distribution; 53 - TUnuran::Sample(double *) sample a multi-dimensional distribution. A pointer to a vector with; 54 size at least equal to the distribution dimension must be passed; 55 ; 56 In addition is possible to set the random number generator in the constructor of the class, its seed; 57 via the TUnuran::SetSeed() method.; 58*/; 59 ; 60 ; 61 ; 62//class TUnuranGenerator;; 63struct unur_gen;; 64typedef struct unur_gen UNUR_GEN;; 65 ; 66// struct unur_urng_generic;; 67// typedef struct unur_urng_generic UNUR_URNG;; 68 ; 69struct unur_distr;; 70typedef struct unur_distr UNUR_DISTR;; 71 ; 72struct unur_urng;; 73typedef struct unur_urng UNUR_URNG;; 74 ; 75 ; 76class TRandom;; 77class TH1;; 78 ; 79class TUnuran {; 80 ; 81public:; 82 ; 83 /**; 84 Constructor with a generator instance and given level of log output; 85 */; 86 TUnuran (TRandom * r = nullptr, unsigned int log = 0);; 87 ; 88 ; 89 /**; 90 Destructor; 91 */; 92 ~TUnuran ();; 93 ; 94 // usually copying is non trivial, so we delete this; 95 TUnuran(const TUnuran &) = delete;; 96 TUnuran & operator = (const TUnuran & rhs) = delete;; 97 TUnuran(TUnuran &&) = delete;; 98 TUnuran & operator = (TUnuran && rhs) = delete;; 99 ; 100 /**; 101 Initialize with Unuran string API interface.; 102 See https://statmath.wu.ac.at/unuran/doc/unuran.html#StringAPI; 103 ; 104 @param distr : UNU.RAN distribution string; 105 @param method : UNU.RAN method string; 106 ; 107 Here is an example using the string API:; 108 ```; 109 Tunuran unr;; 110 unr.Init(""normal(3.,0.75); domain = (0,inf)"", ""method = tdr; c = 0"");; 111 ```; 112 */; 113 bool Init(const std::string & distr, const std::string & method);; 114 ; 115 ; 116 /**; 117 Initialize method for continuous one-dimensional distribution.; 118 User must provide a distribution obj",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:2965,Testability,log,log,2965," 49 ; 50 The sampling is provided via these methods:; 51 - TUnuran::Sample() returns a double for all one-dimensional distribution; 52 - TUnuran::SampleDiscr() returns an integer for one-dimensional discrete distribution; 53 - TUnuran::Sample(double *) sample a multi-dimensional distribution. A pointer to a vector with; 54 size at least equal to the distribution dimension must be passed; 55 ; 56 In addition is possible to set the random number generator in the constructor of the class, its seed; 57 via the TUnuran::SetSeed() method.; 58*/; 59 ; 60 ; 61 ; 62//class TUnuranGenerator;; 63struct unur_gen;; 64typedef struct unur_gen UNUR_GEN;; 65 ; 66// struct unur_urng_generic;; 67// typedef struct unur_urng_generic UNUR_URNG;; 68 ; 69struct unur_distr;; 70typedef struct unur_distr UNUR_DISTR;; 71 ; 72struct unur_urng;; 73typedef struct unur_urng UNUR_URNG;; 74 ; 75 ; 76class TRandom;; 77class TH1;; 78 ; 79class TUnuran {; 80 ; 81public:; 82 ; 83 /**; 84 Constructor with a generator instance and given level of log output; 85 */; 86 TUnuran (TRandom * r = nullptr, unsigned int log = 0);; 87 ; 88 ; 89 /**; 90 Destructor; 91 */; 92 ~TUnuran ();; 93 ; 94 // usually copying is non trivial, so we delete this; 95 TUnuran(const TUnuran &) = delete;; 96 TUnuran & operator = (const TUnuran & rhs) = delete;; 97 TUnuran(TUnuran &&) = delete;; 98 TUnuran & operator = (TUnuran && rhs) = delete;; 99 ; 100 /**; 101 Initialize with Unuran string API interface.; 102 See https://statmath.wu.ac.at/unuran/doc/unuran.html#StringAPI; 103 ; 104 @param distr : UNU.RAN distribution string; 105 @param method : UNU.RAN method string; 106 ; 107 Here is an example using the string API:; 108 ```; 109 Tunuran unr;; 110 unr.Init(""normal(3.,0.75); domain = (0,inf)"", ""method = tdr; c = 0"");; 111 ```; 112 */; 113 bool Init(const std::string & distr, const std::string & method);; 114 ; 115 ; 116 /**; 117 Initialize method for continuous one-dimensional distribution.; 118 User must provide a distribution obj",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:10359,Testability,log,log,10359,t;; 256 /// Return true for a discrete distribution.; 257 bool IsDistDiscrete() const;; 258 /// Return true for an empirical distribution.; 259 bool IsDistEmpirical() const;; 260 ; 261 ; 262 ; 263 /**; 264 set the seed for the random number generator; 265 */; 266 void SetSeed(unsigned int seed);; 267 ; 268 /**; 269 set log level; 270 */; 271 bool SetLogLevel(unsigned int iflag = 1);; 272 ; 273 /**; 274 set stream for log and error (not yet implemented); 275 */; 276 bool SetLogStream() { return false;}; 277 ; 278 /**; 279 used Unuran method; 280 */; 281 const std::string & MethodName() const { return fMethod; }; 282 ; 283protected:; 284 ; 285 ; 286 bool SetRandomGenerator();; 287 ; 288 bool SetContDistribution(const TUnuranContDist & dist );; 289 ; 290 bool SetMultiDistribution(const TUnuranMultiContDist & dist );; 291 ; 292 bool SetDiscreteDistribution(const TUnuranDiscrDist & dist );; 293 ; 294 bool SetEmpiricalDistribution(const TUnuranEmpDist & dist );; 295 ; 296 /**; 297 change the method and initialize Unuran with the previously given distribution; 298 */; 299 bool SetMethodAndInit();; 300 ; 301 ; 302 ; 303// private:; 304 ; 305 UNUR_GEN * fGen; //pointer to the UnuRan C generator struct; 306 UNUR_DISTR * fUdistr; //pointer to the UnuRan C distribution struct; 307 UNUR_URNG * fUrng; // pointer to Unuran C random generator struct; 308 std::unique_ptr<TUnuranBaseDist> fDist; // pointer for distribution wrapper; 309 TRandom * fRng; //pointer to ROOT random number generator; 310 std::string fMethod; //string representing the method; 311 ; 312};; 313 ; 314 ; 315#endif /* ROOT_Math_TUnuran */; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TUnuranBaseDist.h; UNUR_URNGstruct unur_urng UNUR_URNGDefinition TUnuran.h:73; UNUR_GENstruct unur_gen UNUR_GENDefinition TUnuran,MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:10459,Testability,log,log,10459,t;; 256 /// Return true for a discrete distribution.; 257 bool IsDistDiscrete() const;; 258 /// Return true for an empirical distribution.; 259 bool IsDistEmpirical() const;; 260 ; 261 ; 262 ; 263 /**; 264 set the seed for the random number generator; 265 */; 266 void SetSeed(unsigned int seed);; 267 ; 268 /**; 269 set log level; 270 */; 271 bool SetLogLevel(unsigned int iflag = 1);; 272 ; 273 /**; 274 set stream for log and error (not yet implemented); 275 */; 276 bool SetLogStream() { return false;}; 277 ; 278 /**; 279 used Unuran method; 280 */; 281 const std::string & MethodName() const { return fMethod; }; 282 ; 283protected:; 284 ; 285 ; 286 bool SetRandomGenerator();; 287 ; 288 bool SetContDistribution(const TUnuranContDist & dist );; 289 ; 290 bool SetMultiDistribution(const TUnuranMultiContDist & dist );; 291 ; 292 bool SetDiscreteDistribution(const TUnuranDiscrDist & dist );; 293 ; 294 bool SetEmpiricalDistribution(const TUnuranEmpDist & dist );; 295 ; 296 /**; 297 change the method and initialize Unuran with the previously given distribution; 298 */; 299 bool SetMethodAndInit();; 300 ; 301 ; 302 ; 303// private:; 304 ; 305 UNUR_GEN * fGen; //pointer to the UnuRan C generator struct; 306 UNUR_DISTR * fUdistr; //pointer to the UnuRan C distribution struct; 307 UNUR_URNG * fUrng; // pointer to Unuran C random generator struct; 308 std::unique_ptr<TUnuranBaseDist> fDist; // pointer for distribution wrapper; 309 TRandom * fRng; //pointer to ROOT random number generator; 310 std::string fMethod; //string representing the method; 311 ; 312};; 313 ; 314 ; 315#endif /* ROOT_Math_TUnuran */; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TUnuranBaseDist.h; UNUR_URNGstruct unur_urng UNUR_URNGDefinition TUnuran.h:73; UNUR_GENstruct unur_gen UNUR_GENDefinition TUnuran,MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:13362,Testability,log,log,13362,"istribution.Definition TUnuranContDist.h:48; TUnuranDiscrDistTUnuranDiscrDist class for one dimensional discrete distribution.Definition TUnuranDiscrDist.h:51; TUnuranEmpDistTUnuranEmpDist class for describing empirical distributions.Definition TUnuranEmpDist.h:49; TUnuranMultiContDistTUnuranMultiContDist class describing multi dimensional continuous distributions.Definition TUnuranMultiContDist.h:47; TUnuranTUnuran class.Definition TUnuran.h:79; TUnuran::GetGenIdstd::string GetGenId() constReturn an ID string about the unuran generator method.Definition TUnuran.cxx:369; TUnuran::IsDistContbool IsDistCont() constReturn true for a univariate continuous distribution.Definition TUnuran.cxx:390; TUnuran::SetMethodAndInitbool SetMethodAndInit()change the method and initialize Unuran with the previously given distributionDefinition TUnuran.cxx:332; TUnuran::SampleDiscrint SampleDiscr()Sample discrete distributions.Definition TUnuran.cxx:407; TUnuran::SetLogStreambool SetLogStream()set stream for log and error (not yet implemented)Definition TUnuran.h:276; TUnuran::MethodNameconst std::string & MethodName() constused Unuran methodDefinition TUnuran.h:281; TUnuran::TUnuranTUnuran(TUnuran &&)=delete; TUnuran::fDiststd::unique_ptr< TUnuranBaseDist > fDistDefinition TUnuran.h:308; TUnuran::SetDiscreteDistributionbool SetDiscreteDistribution(const TUnuranDiscrDist &dist)Definition TUnuran.cxx:287; TUnuran::GetDistTypeint GetDistType() constReturn the type of the distribution.Definition TUnuran.cxx:383; TUnuran::InitBinomialbool InitBinomial(unsigned int ntot, double prob, const std::string &method=""dstd"")Initialize method for the Binomial distribution.Definition TUnuran.cxx:462; TUnuran::SetContDistributionbool SetContDistribution(const TUnuranContDist &dist)Definition TUnuran.cxx:156; TUnuran::GetInfostd::string GetInfo(bool extended=false)Return an information string about the used Unuran generator method.Definition TUnuran.cxx:362; TUnuran::SampleMultibool SampleMulti(double",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TUnuran_8h_source.html:15243,Testability,log,log,15243,"urn an information string about the used Unuran generator method.Definition TUnuran.cxx:362; TUnuran::SampleMultibool SampleMulti(double *x)Sample multidimensional distributions.Definition TUnuran.cxx:421; TUnuran::ReInitDiscrDistbool ReInitDiscrDist(unsigned int npar, double *params)Reinitialize UNURAN by changing the distribution parameters but maintaining same distribution and met...Definition TUnuran.cxx:477; TUnuran::IsDistMultiContbool IsDistMultiCont() constReturn true for a multivariate continuous distribution.Definition TUnuran.cxx:394; TUnuran::fUdistrUNUR_DISTR * fUdistrDefinition TUnuran.h:306; TUnuran::Initbool Init(const std::string &distr, const std::string &method)Initialize with Unuran string API interface.Definition TUnuran.cxx:62; TUnuran::operator=TUnuran & operator=(const TUnuran &rhs)=delete; TUnuran::fGenUNUR_GEN * fGenDefinition TUnuran.h:305; TUnuran::SetRandomGeneratorbool SetRandomGenerator()Definition TUnuran.cxx:139; TUnuran::SetLogLevelbool SetLogLevel(unsigned int iflag=1)set log levelDefinition TUnuran.cxx:433; TUnuran::fUrngUNUR_URNG * fUrngDefinition TUnuran.h:307; TUnuran::fRngTRandom * fRngDefinition TUnuran.h:309; TUnuran::SetMultiDistributionbool SetMultiDistribution(const TUnuranMultiContDist &dist)Definition TUnuran.cxx:202; TUnuran::IsDistEmpiricalbool IsDistEmpirical() constReturn true for an empirical distribution.Definition TUnuran.cxx:402; TUnuran::Sampledouble Sample()Sample 1D distribution.Definition TUnuran.cxx:414; TUnuran::SetEmpiricalDistributionbool SetEmpiricalDistribution(const TUnuranEmpDist &dist)Definition TUnuran.cxx:246; TUnuran::GetRandomTRandom * GetRandom()Return instance of the random engine used.Definition TUnuran.h:223; TUnuran::TUnuranTUnuran(const TUnuran &)=delete; TUnuran::~TUnuran~TUnuran()Destructor.Definition TUnuran.cxx:53; TUnuran::InitPoissonbool InitPoisson(double mu, const std::string &method=""dstd"")Initialize method for the Poisson distribution.Definition TUnuran.cxx:448; TUnuran::fMethodst",MatchSource.WIKI,doc/master/TUnuran_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html
https://root.cern/doc/master/TVectorDfwd_8h.html:209,Integrability,depend,dependency,209,". ROOT: math/matrix/inc/TVectorDfwd.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Typedefs ; TVectorDfwd.h File Reference. #include ""RtypesCore.h"". Include dependency graph for TVectorDfwd.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Typedefs; typedef TVectorT< Double_t > TVectorD;  . Typedef Documentation. ◆ TVectorD. typedef TVectorT<Double_t> TVectorD. Definition at line 23 of file TVectorDfwd.h. mathmatrixincTVectorDfwd.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TVectorDfwd_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVectorDfwd_8h.html
https://root.cern/doc/master/TVectorFfwd_8h.html:209,Integrability,depend,dependency,209,". ROOT: math/matrix/inc/TVectorFfwd.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Typedefs ; TVectorFfwd.h File Reference. #include ""RtypesCore.h"". Include dependency graph for TVectorFfwd.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Typedefs; typedef TVectorT< Float_t > TVectorF;  . Typedef Documentation. ◆ TVectorF. typedef TVectorT<Float_t> TVectorF. Definition at line 23 of file TVectorFfwd.h. mathmatrixincTVectorFfwd.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:22 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TVectorFfwd_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVectorFfwd_8h.html
https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:9749,Energy Efficiency,allocate,allocated,9749,"=; 188 /// proxied object), `Commit()` should be called on the value returned by this function.; 189 virtual void* Allocate(UInt_t n, Bool_t forceDelete) = 0;; 190 ; 191 /// Commits pending elements in a staging area (see Allocate() for more information).; 192 virtual void Commit(void*) = 0;; 193 ; 194 /// Insert elements into the proxied container. `data` is a C-style array of the value type of the given `size`.; 195 /// For associative containers, e.g. `std::map`, the data type should be `std::pair<Key_t, Value_t>`.; 196 virtual void Insert(const void *data, void *container, size_t size) = 0;; 197 ; 198 /// Return the address of the value at index `idx`; 199 char *operator[](UInt_t idx) const { return (char *)(const_cast<TVirtualCollectionProxy *>(this))->At(idx); }; 200 ; 201 // Functions related to member-wise actions; 202 virtual TStreamerInfoActions::TActionSequence *GetConversionReadMemberWiseActions(TClass *oldClass, Int_t version) = 0;; 203 virtual TStreamerInfoActions::TActionSequence *GetReadMemberWiseActions(Int_t version) = 0;; 204 virtual TStreamerInfoActions::TActionSequence *GetWriteMemberWiseActions() = 0;; 205 ; 206 /// The size of a small buffer that can be allocated on the stack to store iterator-specific information; 207 static const Int_t fgIteratorArenaSize = 16; // greater than sizeof(void*) + sizeof(UInt_t); 208 ; 209 /// `*begin_arena` and `*end_arena` should contain the location of a memory arena of size `fgIteratorArenaSize`.; 210 /// If iterator-specific information is of that size or less, the iterators will be constructed in place in the given; 211 /// locations. Otherwise, iterators will be allocated via `new` and their address returned by modifying the value; 212 /// of `*begin_arena` and `*end_arena`.; 213 /// As a special case, given that iterators for array-backed containers are just pointers, the required information; 214 /// will be directly stored in `*(begin|end)_arena`.; 215 typedef void (*CreateIterators_t)(void *collection,",MatchSource.WIKI,doc/master/TVirtualCollectionProxy_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html
https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:10204,Energy Efficiency,allocate,allocated,10204," idx) const { return (char *)(const_cast<TVirtualCollectionProxy *>(this))->At(idx); }; 200 ; 201 // Functions related to member-wise actions; 202 virtual TStreamerInfoActions::TActionSequence *GetConversionReadMemberWiseActions(TClass *oldClass, Int_t version) = 0;; 203 virtual TStreamerInfoActions::TActionSequence *GetReadMemberWiseActions(Int_t version) = 0;; 204 virtual TStreamerInfoActions::TActionSequence *GetWriteMemberWiseActions() = 0;; 205 ; 206 /// The size of a small buffer that can be allocated on the stack to store iterator-specific information; 207 static const Int_t fgIteratorArenaSize = 16; // greater than sizeof(void*) + sizeof(UInt_t); 208 ; 209 /// `*begin_arena` and `*end_arena` should contain the location of a memory arena of size `fgIteratorArenaSize`.; 210 /// If iterator-specific information is of that size or less, the iterators will be constructed in place in the given; 211 /// locations. Otherwise, iterators will be allocated via `new` and their address returned by modifying the value; 212 /// of `*begin_arena` and `*end_arena`.; 213 /// As a special case, given that iterators for array-backed containers are just pointers, the required information; 214 /// will be directly stored in `*(begin|end)_arena`.; 215 typedef void (*CreateIterators_t)(void *collection, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy);; 216 ; 217 /// Return a pointer to a function that can create an iterator pair, where each iterator points to the begin and end; 218 /// of the collection, respectively (see CreateIterators_t). If `read == kTRUE`, data is to be read from disk, i.e.; 219 /// written to the in-memory collection.; 220 virtual CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE) = 0;; 221 ; 222 /// Copy the iterator `source` into `dest`. `dest` should contain the location of a memory arena of size; 223 /// `fgIteratorArenaSize`.; 224 /// If iterator-specific information is of that size or less, the iterators will be cons",MatchSource.WIKI,doc/master/TVirtualCollectionProxy_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html
https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:11325,Energy Efficiency,allocate,allocated,11325," for array-backed containers are just pointers, the required information; 214 /// will be directly stored in `*(begin|end)_arena`.; 215 typedef void (*CreateIterators_t)(void *collection, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy);; 216 ; 217 /// Return a pointer to a function that can create an iterator pair, where each iterator points to the begin and end; 218 /// of the collection, respectively (see CreateIterators_t). If `read == kTRUE`, data is to be read from disk, i.e.; 219 /// written to the in-memory collection.; 220 virtual CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE) = 0;; 221 ; 222 /// Copy the iterator `source` into `dest`. `dest` should contain the location of a memory arena of size; 223 /// `fgIteratorArenaSize`.; 224 /// If iterator-specific information is of that size or less, the iterators will be constructed in place in the given; 225 /// locations. Otherwise, iterators will be allocated via `new` and their address returned by modifying the value; 226 /// of `*begin_arena` and `*end_arena`. The actual address of the iterator is returned in any case.; 227 typedef void* (*CopyIterator_t)(void *dest, const void *source);; 228 ; 229 /// Return a pointer to a function that can copy an iterator (see CopyIterator_t). If `read == kTRUE`, data is to be; 230 /// read from disk, i.e. written to the in-memory collection.; 231 virtual CopyIterator_t GetFunctionCopyIterator(Bool_t read = kTRUE) = 0;; 232 ; 233 /// `iter` and `end` should be pointers to an iterator to be incremented and an iterator that points to the end of; 234 /// the collection, respectively. If `iter` has not reached the end of the collection, this function increments the; 235 /// iterator and returns a pointer to the element before the increment. Otherwise, `nullptr` is returned.; 236 typedef void* (*Next_t)(void *iter, const void *end);; 237 ; 238 /// Return a pointer to a function that can advance an iterator (see Next_t). If `read == kTRUE`",MatchSource.WIKI,doc/master/TVirtualCollectionProxy_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html
https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:14491,Energy Efficiency,allocate,allocated,14491,"#define BIT(n)Definition Rtypes.h:90; TClassRef.h; TDataType.h; EDataTypeEDataTypeDefinition TDataType.h:28; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; destOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t destDefinition TGWin32VirtualXProxy.cxx:164; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassRef::GetClassTClass * GetClass() constDefinition TClassRef.h:66; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5260; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::DeleteArrayvoid DeleteArray(void *ary, Bool_t dtorOnly=kFALSE)Explicitly call operator delete[] for an array.Definition TClass.cxx:5596; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5276; TClass::NewObjectObjectPtr NewObject(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constDefinition TClass.cxx:5059; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TVirtualCollectionProxy::TPushPopRAII",MatchSource.WIKI,doc/master/TVirtualCollectionProxy_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html
https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:14671,Energy Efficiency,allocate,allocated,14671,"alGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; destOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t destDefinition TGWin32VirtualXProxy.cxx:164; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassRef::GetClassTClass * GetClass() constDefinition TClassRef.h:66; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5260; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::DeleteArrayvoid DeleteArray(void *ary, Bool_t dtorOnly=kFALSE)Explicitly call operator delete[] for an array.Definition TClass.cxx:5596; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5276; TClass::NewObjectObjectPtr NewObject(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constDefinition TClass.cxx:5059; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when entering / leaving a C++...Definition TVirtualCollectionProxy.h:75; TVirtualCollectionProxy::TPushPop::",MatchSource.WIKI,doc/master/TVirtualCollectionProxy_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html
https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:15142,Energy Efficiency,allocate,allocated,15142,"ClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassRef::GetClassTClass * GetClass() constDefinition TClassRef.h:66; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::NewArrayvoid * NewArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5260; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TClass::DeleteArrayvoid DeleteArray(void *ary, Bool_t dtorOnly=kFALSE)Explicitly call operator delete[] for an array.Definition TClass.cxx:5596; TClass::NewObjectArrayObjectPtr NewObjectArray(Long_t nElements, ENewType defConstructor=kClassNew) constReturn a pointer to a newly allocated array of objects of this class.Definition TClass.cxx:5276; TClass::NewObjectObjectPtr NewObject(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constDefinition TClass.cxx:5059; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when entering / leaving a C++...Definition TVirtualCollectionProxy.h:75; TVirtualCollectionProxy::TPushPop::operator=TPushPop & operator=(const TPushPop &)=delete; TVirtualCollectionProxy::TPushPop::TPushPopTPushPop(const TPushPop &)=delete; TVirtualCollectionProxy::TPushPop::TPushPopTPushPop(TVirtualCollectionProxy *proxy, void *objectstart)Definition TVirtualCollectionProxy.h:78; TVirtualCollectionProxy::TPushPop::fProxyTVirtualCollectionProxy * fProxyDefinition TVirtualCollectionProxy.h:77; TVirtualCollectionProxy::TPushPop::~TPushPop~TPushPop()Definition TVirtual",MatchSource.WIKI,doc/master/TVirtualCollectionProxy_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html
https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:22554,Energy Efficiency,allocate,allocated,22554," GetFunctionDeleteTwoIterators(Bool_t read=kTRUE)=0; TVirtualCollectionProxy::Sizevirtual UInt_t Size() const =0Return the current number of elements in the container.; TVirtualCollectionProxy::NewArrayvirtual void * NewArray(Int_t nElements) constConstruct an array of nElements container objects and return the base address of the array.Definition TVirtualCollectionProxy.h:126; TVirtualCollectionProxy::DeleteTwoIterators_tvoid(* DeleteTwoIterators_t)(void *begin, void *end)Definition TVirtualCollectionProxy.h:245; TVirtualCollectionProxy::DeleteIterator_tvoid(* DeleteIterator_t)(void *iter)If the size of the iterator is greater than fgIteratorArenaSize, call delete on the addresses; otherw...Definition TVirtualCollectionProxy.h:244; TVirtualCollectionProxy::Newvirtual void * New(void *arena) constConstruct a new container object at the address given by arenaDefinition TVirtualCollectionProxy.h:113; TVirtualCollectionProxy::fgIteratorArenaSizestatic const Int_t fgIteratorArenaSizeThe size of a small buffer that can be allocated on the stack to store iterator-specific information.Definition TVirtualCollectionProxy.h:207; TVirtualCollectionProxy::Generatevirtual TVirtualCollectionProxy * Generate() const =0Returns a clean object of the actual class that derives from TVirtualCollectionProxy.; TVirtualCollectionProxy::Resetvirtual Bool_t Reset()Reset the information gathered from StreamerInfos and value's TClass.Definition TVirtualCollectionProxy.h:95; TVirtualCollectionProxy::fPropertiesUInt_t fPropertiesDefinition TVirtualCollectionProxy.h:59; TVirtualCollectionProxy::GetFunctionCreateIteratorsvirtual CreateIterators_t GetFunctionCreateIterators(Bool_t read=kTRUE)=0Return a pointer to a function that can create an iterator pair, where each iterator points to the be...; TVirtualCollectionProxy::NewObjectArrayvirtual TClass::ObjectPtr NewObjectArray(Int_t nElements, void *arena) constConstruct an array of nElements container objects at the address given by arenaDefinitio",MatchSource.WIKI,doc/master/TVirtualCollectionProxy_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html
https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:882,Integrability,interface,interface,882,". ROOT: core/cont/inc/TVirtualCollectionProxy.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TVirtualCollectionProxy.h. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Philippe Canal 20/08/2003; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2003, Rene Brun, Fons Rademakers and al. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TVirtualCollectionProxy; 13#define ROOT_TVirtualCollectionProxy; 14 ; 15//////////////////////////////////////////////////////////////////////////; 16// //; 17// TVirtualCollectionProxy //; 18// //; 19// Virtual interface of a proxy object for a collection class //; 20// In particular this is used to implement splitting, emulation, //; 21// and TTreeFormula access to STL containers. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TClassRef.h""; 26#include ""TDataType.h""; 27 ; 28// Macro indicating the version of the Collection Proxy interface followed; 29// by this ROOT build (See also Reflex/Builder/CollectionProxy.h).; 30#define ROOT_COLLECTIONPROXY_VERSION 3; 31 ; 32class TClass;; 33namespace TStreamerInfoActions {; 34 class TActionSequence;; 35}; 36 ; 37// clang-format off; 38/**; 39\class TVirtualCollectionProxy; 40\brief Defines a common interface to inspect/change the contents of an object that represents a collection; 41 ; 42Specifically, an object of a class that derives from TVirtualCollectionProxy relays accesses to any object that; 43matches the proxied collection type.; 44The interface provides two families of functions: (i) for direct manipulation, e.g. `Insert()` or `At()`; and; 45(ii) iterator-based, e.g. `GetFunctionCreateIterators()` o",MatchSource.WIKI,doc/master/TVirtualCollectionProxy_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html
https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:1267,Integrability,interface,interface,1267,"*************************************************************************; 5 * Copyright (C) 1995-2003, Rene Brun, Fons Rademakers and al. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TVirtualCollectionProxy; 13#define ROOT_TVirtualCollectionProxy; 14 ; 15//////////////////////////////////////////////////////////////////////////; 16// //; 17// TVirtualCollectionProxy //; 18// //; 19// Virtual interface of a proxy object for a collection class //; 20// In particular this is used to implement splitting, emulation, //; 21// and TTreeFormula access to STL containers. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TClassRef.h""; 26#include ""TDataType.h""; 27 ; 28// Macro indicating the version of the Collection Proxy interface followed; 29// by this ROOT build (See also Reflex/Builder/CollectionProxy.h).; 30#define ROOT_COLLECTIONPROXY_VERSION 3; 31 ; 32class TClass;; 33namespace TStreamerInfoActions {; 34 class TActionSequence;; 35}; 36 ; 37// clang-format off; 38/**; 39\class TVirtualCollectionProxy; 40\brief Defines a common interface to inspect/change the contents of an object that represents a collection; 41 ; 42Specifically, an object of a class that derives from TVirtualCollectionProxy relays accesses to any object that; 43matches the proxied collection type.; 44The interface provides two families of functions: (i) for direct manipulation, e.g. `Insert()` or `At()`; and; 45(ii) iterator-based, e.g. `GetFunctionCreateIterators()` or `GetFunctionNext()`.; 46TVirtualCollectionProxy objects are stateful; in particular, many functions require to set the object to operate; 47on via `PushProxy()` / `PopProxy()`. The `TPushPop` RAII class is provided for convenience.; 48A collection proxy for a given class c",MatchSource.WIKI,doc/master/TVirtualCollectionProxy_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html
https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:1584,Integrability,interface,interface,1584,"*********************************************************/; 11 ; 12#ifndef ROOT_TVirtualCollectionProxy; 13#define ROOT_TVirtualCollectionProxy; 14 ; 15//////////////////////////////////////////////////////////////////////////; 16// //; 17// TVirtualCollectionProxy //; 18// //; 19// Virtual interface of a proxy object for a collection class //; 20// In particular this is used to implement splitting, emulation, //; 21// and TTreeFormula access to STL containers. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TClassRef.h""; 26#include ""TDataType.h""; 27 ; 28// Macro indicating the version of the Collection Proxy interface followed; 29// by this ROOT build (See also Reflex/Builder/CollectionProxy.h).; 30#define ROOT_COLLECTIONPROXY_VERSION 3; 31 ; 32class TClass;; 33namespace TStreamerInfoActions {; 34 class TActionSequence;; 35}; 36 ; 37// clang-format off; 38/**; 39\class TVirtualCollectionProxy; 40\brief Defines a common interface to inspect/change the contents of an object that represents a collection; 41 ; 42Specifically, an object of a class that derives from TVirtualCollectionProxy relays accesses to any object that; 43matches the proxied collection type.; 44The interface provides two families of functions: (i) for direct manipulation, e.g. `Insert()` or `At()`; and; 45(ii) iterator-based, e.g. `GetFunctionCreateIterators()` or `GetFunctionNext()`.; 46TVirtualCollectionProxy objects are stateful; in particular, many functions require to set the object to operate; 47on via `PushProxy()` / `PopProxy()`. The `TPushPop` RAII class is provided for convenience.; 48A collection proxy for a given class can be permanently set using `TClass::CopyCollectionProxy()`.; 49The `Generate()` function should be overridden in derived classes to return a clean object of the most-derived class.; 50*/; 51// clang-format on; 52class TVirtualCollectionProxy {; 53private:; 54 TVirtualCollectionProxy(const TVirtualCollectionProxy&",MatchSource.WIKI,doc/master/TVirtualCollectionProxy_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html
https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:1834,Integrability,interface,interface,1834," 19// Virtual interface of a proxy object for a collection class //; 20// In particular this is used to implement splitting, emulation, //; 21// and TTreeFormula access to STL containers. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TClassRef.h""; 26#include ""TDataType.h""; 27 ; 28// Macro indicating the version of the Collection Proxy interface followed; 29// by this ROOT build (See also Reflex/Builder/CollectionProxy.h).; 30#define ROOT_COLLECTIONPROXY_VERSION 3; 31 ; 32class TClass;; 33namespace TStreamerInfoActions {; 34 class TActionSequence;; 35}; 36 ; 37// clang-format off; 38/**; 39\class TVirtualCollectionProxy; 40\brief Defines a common interface to inspect/change the contents of an object that represents a collection; 41 ; 42Specifically, an object of a class that derives from TVirtualCollectionProxy relays accesses to any object that; 43matches the proxied collection type.; 44The interface provides two families of functions: (i) for direct manipulation, e.g. `Insert()` or `At()`; and; 45(ii) iterator-based, e.g. `GetFunctionCreateIterators()` or `GetFunctionNext()`.; 46TVirtualCollectionProxy objects are stateful; in particular, many functions require to set the object to operate; 47on via `PushProxy()` / `PopProxy()`. The `TPushPop` RAII class is provided for convenience.; 48A collection proxy for a given class can be permanently set using `TClass::CopyCollectionProxy()`.; 49The `Generate()` function should be overridden in derived classes to return a clean object of the most-derived class.; 50*/; 51// clang-format on; 52class TVirtualCollectionProxy {; 53private:; 54 TVirtualCollectionProxy(const TVirtualCollectionProxy&) = delete;; 55 TVirtualCollectionProxy& operator=(const TVirtualCollectionProxy&) = delete;; 56 ; 57protected:; 58 TClassRef fClass;; 59 UInt_t fProperties;; 60 friend class TClass;; 61 ; 62public:; 63 enum EProperty {; 64 // No longer used; 65 // kIsInitialized = BIT(1),; 66 ",MatchSource.WIKI,doc/master/TVirtualCollectionProxy_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html
https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:4547,Integrability,depend,depends,4547,"(TVirtualCollectionProxy *proxy,; 79 void *objectstart) : fProxy(proxy) { fProxy->PushProxy(objectstart); }; 80 inline ~TPushPop() { fProxy->PopProxy(); }; 81 private:; 82 TPushPop(const TPushPop&) = delete;; 83 TPushPop& operator=(const TPushPop&) = delete;; 84 };; 85 ; 86 TVirtualCollectionProxy() : fClass(), fProperties(0) {}; 87 TVirtualCollectionProxy(TClass *cl) : fClass(cl), fProperties(0) {}; 88 virtual ~TVirtualCollectionProxy() {}; 89 ; 90 /// Returns a clean object of the actual class that derives from TVirtualCollectionProxy. The caller is responsible; 91 /// for deleting the returned object.; 92 virtual TVirtualCollectionProxy *Generate() const = 0;; 93 ; 94 /// Reset the information gathered from StreamerInfos and value's TClass.; 95 virtual Bool_t Reset() { return kTRUE; }; 96 ; 97 /// Return a pointer to the `TClass` representing the proxied _container_ class; 98 virtual TClass *GetCollectionClass() const { return fClass; }; 99 ; 100 /// Return the type of the proxied collection (see enumeration TClassEdit::ESTLType); 101 virtual Int_t GetCollectionType() const = 0;; 102 ; 103 /// Return the offset between two consecutive in-memory values (which depends on the `sizeof()` and alignment of the; 104 /// value type).; 105 virtual ULong_t GetIncrement() const = 0;; 106 ; 107 /// Return miscallenous properties of the proxy (see TVirtualCollectionProxy::EProperty); 108 virtual Int_t GetProperties() const { return fProperties; }; 109 ; 110 /// Construct a new container object and return its address; 111 virtual void *New() const { return !fClass.GetClass() ? nullptr : fClass->New(); }; 112 /// Construct a new container object at the address given by `arena`; 113 virtual void *New(void *arena) const { return !fClass.GetClass() ? nullptr : fClass->New(arena); }; 114 /// Construct a new container object and return its address; 115 virtual TClass::ObjectPtr NewObject() const; 116 {; 117 return !fClass.GetClass() ? TClass::ObjectPtr{} : fClass->NewObject();; 118 }",MatchSource.WIKI,doc/master/TVirtualCollectionProxy_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html
https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:16153,Integrability,interface,interface,16153," this class.Definition TClass.cxx:5276; TClass::NewObjectObjectPtr NewObject(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constDefinition TClass.cxx:5059; TStreamerInfoActions::TActionSequenceDefinition TStreamerInfoActions.h:177; TVirtualCollectionProxy::TPushPopRAII helper class that ensures that PushProxy() / PopProxy() are called when entering / leaving a C++...Definition TVirtualCollectionProxy.h:75; TVirtualCollectionProxy::TPushPop::operator=TPushPop & operator=(const TPushPop &)=delete; TVirtualCollectionProxy::TPushPop::TPushPopTPushPop(const TPushPop &)=delete; TVirtualCollectionProxy::TPushPop::TPushPopTPushPop(TVirtualCollectionProxy *proxy, void *objectstart)Definition TVirtualCollectionProxy.h:78; TVirtualCollectionProxy::TPushPop::fProxyTVirtualCollectionProxy * fProxyDefinition TVirtualCollectionProxy.h:77; TVirtualCollectionProxy::TPushPop::~TPushPop~TPushPop()Definition TVirtualCollectionProxy.h:80; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionProxy::GetPropertiesvirtual Int_t GetProperties() constReturn miscallenous properties of the proxy (see TVirtualCollectionProxy::EProperty)Definition TVirtualCollectionProxy.h:108; TVirtualCollectionProxy::PushProxyvirtual void PushProxy(void *objectstart)=0Set the address of the container being proxied and keep track of the previous one.; TVirtualCollectionProxy::TVirtualCollectionProxyTVirtualCollectionProxy()Definition TVirtualCollectionProxy.h:86; TVirtualCollectionProxy::Sizeofvirtual UInt_t Sizeof() const =0Return the sizeof() of the collection object.; TVirtualCollectionProxy::GetIncrementvirtual ULong_t GetIncrement() const =0Return the offset between two consecutive in-memory values (which depends on the sizeof() and alignme...; TVirtualCollectionProxy::GetReadMemberWiseActionsvirtual TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t v",MatchSource.WIKI,doc/master/TVirtualCollectionProxy_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html
https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:17003,Integrability,depend,depends,17003,"ualCollectionProxy * fProxyDefinition TVirtualCollectionProxy.h:77; TVirtualCollectionProxy::TPushPop::~TPushPop~TPushPop()Definition TVirtualCollectionProxy.h:80; TVirtualCollectionProxyDefines a common interface to inspect/change the contents of an object that represents a collection.Definition TVirtualCollectionProxy.h:52; TVirtualCollectionProxy::GetPropertiesvirtual Int_t GetProperties() constReturn miscallenous properties of the proxy (see TVirtualCollectionProxy::EProperty)Definition TVirtualCollectionProxy.h:108; TVirtualCollectionProxy::PushProxyvirtual void PushProxy(void *objectstart)=0Set the address of the container being proxied and keep track of the previous one.; TVirtualCollectionProxy::TVirtualCollectionProxyTVirtualCollectionProxy()Definition TVirtualCollectionProxy.h:86; TVirtualCollectionProxy::Sizeofvirtual UInt_t Sizeof() const =0Return the sizeof() of the collection object.; TVirtualCollectionProxy::GetIncrementvirtual ULong_t GetIncrement() const =0Return the offset between two consecutive in-memory values (which depends on the sizeof() and alignme...; TVirtualCollectionProxy::GetReadMemberWiseActionsvirtual TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version)=0; TVirtualCollectionProxy::CreateIterators_tvoid(* CreateIterators_t)(void *collection, void **begin_arena, void **end_arena, TVirtualCollectionProxy *proxy)*begin_arena and *end_arena should contain the location of a memory arena of size fgIteratorArenaSize...Definition TVirtualCollectionProxy.h:215; TVirtualCollectionProxy::NewObjectArrayvirtual TClass::ObjectPtr NewObjectArray(Int_t nElements) constConstruct an array of nElements container objects and return the base address of the array.Definition TVirtualCollectionProxy.h:133; TVirtualCollectionProxy::Destructorvirtual void Destructor(void *p, Bool_t dtorOnly=kFALSE) constExecute the container destructor.Definition TVirtualCollectionProxy.h:144; TVirtualCollectionProxy::GetTypevirtual EDataType GetType(",MatchSource.WIKI,doc/master/TVirtualCollectionProxy_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html
https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:1030,Security,access,access,1030,". ROOT: core/cont/inc/TVirtualCollectionProxy.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TVirtualCollectionProxy.h. Go to the documentation of this file. 1// @(#)root/cont:$Id$; 2// Author: Philippe Canal 20/08/2003; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2003, Rene Brun, Fons Rademakers and al. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TVirtualCollectionProxy; 13#define ROOT_TVirtualCollectionProxy; 14 ; 15//////////////////////////////////////////////////////////////////////////; 16// //; 17// TVirtualCollectionProxy //; 18// //; 19// Virtual interface of a proxy object for a collection class //; 20// In particular this is used to implement splitting, emulation, //; 21// and TTreeFormula access to STL containers. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TClassRef.h""; 26#include ""TDataType.h""; 27 ; 28// Macro indicating the version of the Collection Proxy interface followed; 29// by this ROOT build (See also Reflex/Builder/CollectionProxy.h).; 30#define ROOT_COLLECTIONPROXY_VERSION 3; 31 ; 32class TClass;; 33namespace TStreamerInfoActions {; 34 class TActionSequence;; 35}; 36 ; 37// clang-format off; 38/**; 39\class TVirtualCollectionProxy; 40\brief Defines a common interface to inspect/change the contents of an object that represents a collection; 41 ; 42Specifically, an object of a class that derives from TVirtualCollectionProxy relays accesses to any object that; 43matches the proxied collection type.; 44The interface provides two families of functions: (i) for direct manipulation, e.g. `Insert()` or `At()`; and; 45(ii) iterator-based, e.g. `GetFunctionCreateIterators()` o",MatchSource.WIKI,doc/master/TVirtualCollectionProxy_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html
https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html:1759,Security,access,accesses,1759,"*********************************************************/; 11 ; 12#ifndef ROOT_TVirtualCollectionProxy; 13#define ROOT_TVirtualCollectionProxy; 14 ; 15//////////////////////////////////////////////////////////////////////////; 16// //; 17// TVirtualCollectionProxy //; 18// //; 19// Virtual interface of a proxy object for a collection class //; 20// In particular this is used to implement splitting, emulation, //; 21// and TTreeFormula access to STL containers. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TClassRef.h""; 26#include ""TDataType.h""; 27 ; 28// Macro indicating the version of the Collection Proxy interface followed; 29// by this ROOT build (See also Reflex/Builder/CollectionProxy.h).; 30#define ROOT_COLLECTIONPROXY_VERSION 3; 31 ; 32class TClass;; 33namespace TStreamerInfoActions {; 34 class TActionSequence;; 35}; 36 ; 37// clang-format off; 38/**; 39\class TVirtualCollectionProxy; 40\brief Defines a common interface to inspect/change the contents of an object that represents a collection; 41 ; 42Specifically, an object of a class that derives from TVirtualCollectionProxy relays accesses to any object that; 43matches the proxied collection type.; 44The interface provides two families of functions: (i) for direct manipulation, e.g. `Insert()` or `At()`; and; 45(ii) iterator-based, e.g. `GetFunctionCreateIterators()` or `GetFunctionNext()`.; 46TVirtualCollectionProxy objects are stateful; in particular, many functions require to set the object to operate; 47on via `PushProxy()` / `PopProxy()`. The `TPushPop` RAII class is provided for convenience.; 48A collection proxy for a given class can be permanently set using `TClass::CopyCollectionProxy()`.; 49The `Generate()` function should be overridden in derived classes to return a clean object of the most-derived class.; 50*/; 51// clang-format on; 52class TVirtualCollectionProxy {; 53private:; 54 TVirtualCollectionProxy(const TVirtualCollectionProxy&",MatchSource.WIKI,doc/master/TVirtualCollectionProxy_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualCollectionProxy_8h_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:1544,Availability,redundant,redundant,1544,"nd Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TVirtualFFT; 13\ingroup Base; 14 ; 15TVirtualFFT is an interface class for Fast Fourier Transforms.; 16 ; 17The default FFT library is FFTW. To use it, FFTW3 library should already; 18be installed, and ROOT should be have fftw3 module enabled, with the directories; 19of fftw3 include file and library specified (see installation instructions).; 20Function SetDefaultFFT() allows to change the default library.; 21 ; 22## Available transform types:; 23FFT:; 24 - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); 25 in one or more dimensions, -1 in the exponent; 26 - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); 27 in one or more dimensions, +1 in the exponent; 28 - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); 29 in one or more dimensions,; 30 - ""C2R"" - inverse transforms to ""R2C"", taking complex input; 31 (storing the non-redundant half of a logically Hermitian array); 32 to real output; 33 - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; 34 i.e. real and imaginary parts for a transform of size n stored as; 35 r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; 36 - ""HC2R"" - computes the reverse of FFTW_R2HC, above; 37 - ""DHT"" - computes a discrete Hartley transform; 38 ; 39## Sine/cosine transforms:; 40Different types of transforms are specified by parameter kind of the SineCosine() static; 41function. 4 different kinds of sine and cosine transforms are available; 42 ; 43 - DCT-I (REDFT00 in FFTW3 notation)- kind=0; 44 - DCT-II (REDFT01 in FFTW3 notation)- kind=1; 45 - DCT-III(REDFT10 in FFTW3 notation)- kind=2; 46 - DCT-IV (REDFT11 in FFTW3 notation)- kind=3; 47 - DST-I (RODFT00 in FFTW3 notation)- kind=4; 48 - DST-",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:2102,Availability,avail,available,2102,"undant half of a logically Hermitian array); 32 to real output; 33 - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; 34 i.e. real and imaginary parts for a transform of size n stored as; 35 r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; 36 - ""HC2R"" - computes the reverse of FFTW_R2HC, above; 37 - ""DHT"" - computes a discrete Hartley transform; 38 ; 39## Sine/cosine transforms:; 40Different types of transforms are specified by parameter kind of the SineCosine() static; 41function. 4 different kinds of sine and cosine transforms are available; 42 ; 43 - DCT-I (REDFT00 in FFTW3 notation)- kind=0; 44 - DCT-II (REDFT01 in FFTW3 notation)- kind=1; 45 - DCT-III(REDFT10 in FFTW3 notation)- kind=2; 46 - DCT-IV (REDFT11 in FFTW3 notation)- kind=3; 47 - DST-I (RODFT00 in FFTW3 notation)- kind=4; 48 - DST-II (RODFT01 in FFTW3 notation)- kind=5; 49 - DST-III(RODFT10 in FFTW3 notation)- kind=6; 50 - DST-IV (RODFT11 in FFTW3 notation)- kind=7; 51 ; 52Formulas and detailed descriptions can be found in the chapter; 53""What FFTW really computes"" of the FFTW manual; 54 ; 55NOTE: FFTW computes unnormalized transforms, so doing a transform, followed by its; 56 inverse will give the original array, multiplied by normalization constant; 57 (transform size(N) for FFT, 2*(N-1) for DCT-I, 2*(N+1) for DST-I, 2*N for; 58 other sine/cosine transforms); 59 ; 60## How to use it:; 61Call to the static function FFT returns a pointer to a fast Fourier transform; 62with requested parameters. Call to the static function SineCosine returns a; 63pointer to a sine or cosine transform with requested parameters. Example:; 64~~~ {.cpp}; 65{; 66 Int_t N = 10; Double_t *in = new Double_t[N];; 67 TVirtualFFT *fftr2c = TVirtualFFT::FFT(1, &N, ""R2C"");; 68 fftr2c->SetPoints(in);; 69 fftr2c->Transform();; 70 Double_t re, im;; 71 for (Int_t i=0; i<N; i++); 72 fftr2c->GetPointComplex(i, re, im);; 73 ...; 74 fftr2c->SetPoints(in2);; 75 ...; 76 fftr2c->SetPoints(in3);; 77 ...; 78}; 79~~~; 80Different ",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:9372,Availability,avail,available,9372,"gFFT->GetTransformFlag()) || !opt.Contains(fgFFT->GetType())) {; 230 Int_t *kind = new Int_t[1];; 231 if (inputtype==1) {; 232 if (opt.Contains(""R2HC"")) kind[0] = 10;; 233 if (opt.Contains(""HC2R"")) kind[0] = 11;; 234 if (opt.Contains(""DHT"")) kind[0] = 12;; 235 }; 236 fgFFT->Init(flag, sign, kind);; 237 delete [] kind;; 238 }; 239 }; 240 return fgFFT;; 241}; 242 ; 243////////////////////////////////////////////////////////////////////////////////; 244///Returns a pointer to a sine or cosine transform of requested size and kind; 245///; 246///Parameters:; 247/// \param [in] ndim number of transform dimensions; 248/// \param [in] n sizes of each dimension (an array at least ndim long); 249/// \param [in] r2rkind transform kind for each dimension; 250/// 4 different kinds of sine and cosine transforms are available; 251/// - DCT-I - kind=0; 252/// - DCT-II - kind=1; 253/// - DCT-III - kind=2; 254/// - DCT-IV - kind=3; 255/// - DST-I - kind=4; 256/// - DST-II - kind=5; 257/// - DST-III - kind=6; 258/// - DST-IV - kind=7; 259/// \param [in] option : consists of 2 parts; 260/// - flag option and an option to create a new TVirtualFFT; 261/// - flag option: choosing how much time should be spent in planning the transform:; 262/// Possible options:; 263/// - ""ES"" (from ""estimate"") - no time in preparing the transform,; 264/// but probably sub-optimal performance; 265/// - ""M"" (from ""measure"") - some time spend in finding the optimal way; 266/// to do the transform; 267/// - ""P"" (from ""patient"") - more time spend in finding the optimal way; 268/// to do the transform; 269/// - ""EX"" (from ""exhaustive"") - the most optimal way is found; 270/// This option should be chosen depending on how many transforms of the; 271/// same size and type are going to be done.; 272/// Planning is only done once, for the first transform of this size and type.; 273/// - option allowing to choose between the global fgFFT and a new TVirtualFFT object; 274/// - """" - default, changes and returns the glo",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:14462,Availability,error,error,14462,"////////; 375/// static: set name of default fft; 376 ; 377void TVirtualFFT::SetDefaultFFT(const char *name); 378{; 379 if (fgDefault == name) return;; 380 delete fgFFT;; 381 fgFFT = nullptr;; 382 fgDefault = name;; 383}; h#define h(i)Definition RSha256.hxx:106; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; TPluginManager.h; TROOT.h; gROOTMutexR__EXTERN TVirtualMutex * gROOTMutexDefinition TROOT.h:63; gROOT#define gROOTDefinition TROOT.h:406; TVirtualFFT.h; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPluginHandlerDefinition TPluginManager.h:103; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVirtualFFTTVirtualFFT is an interface class for Fast Fourier Transforms.Definition TVirtualFFT.h:88; TVirtualFFT::~TVirtualFFTvirtual ~TVirtualFFT()destructorDefinition TVirtualFFT.cxx:96; TVirtualFFT::SetDefaultFFTstatic void SetDefaultFFT(const char *name="""")static: set name of default fftDefinition TVirtualFFT.cxx:377; TVirtualFFT::SetTransformstatic void SetTransform(TVirtualFFT *fft)static: set the current transfrom to parameterDefinition TVirtualFFT.cxx:361; TVirtualFFT::Initvirtual void Init(Option_t *flag, Int_t sign, const In",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:829,Deployability,install,installed,829,". ROOT: core/base/src/TVirtualFFT.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TVirtualFFT.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Anna Kreshuk 10/04/2006; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TVirtualFFT; 13\ingroup Base; 14 ; 15TVirtualFFT is an interface class for Fast Fourier Transforms.; 16 ; 17The default FFT library is FFTW. To use it, FFTW3 library should already; 18be installed, and ROOT should be have fftw3 module enabled, with the directories; 19of fftw3 include file and library specified (see installation instructions).; 20Function SetDefaultFFT() allows to change the default library.; 21 ; 22## Available transform types:; 23FFT:; 24 - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); 25 in one or more dimensions, -1 in the exponent; 26 - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); 27 in one or more dimensions, +1 in the exponent; 28 - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); 29 in one or more dimensions,; 30 - ""C2R"" - inverse transforms to ""R2C"", taking complex input; 31 (storing the non-redundant half of a logically Hermitian array); 32 to real output; 33 - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; 34 i.e. real and imaginary parts for a transform of size n stored as; 35 r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; 36 - ""HC2R"" - computes the reverse of FFTW_R2HC, above; 37 - ""DHT"" - computes a discrete Hartley transform; 38 ; 39## Sine/cosine transforms:; 40Different types of transforms are specified by parame",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:959,Deployability,install,installation,959,". ROOT: core/base/src/TVirtualFFT.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TVirtualFFT.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Anna Kreshuk 10/04/2006; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TVirtualFFT; 13\ingroup Base; 14 ; 15TVirtualFFT is an interface class for Fast Fourier Transforms.; 16 ; 17The default FFT library is FFTW. To use it, FFTW3 library should already; 18be installed, and ROOT should be have fftw3 module enabled, with the directories; 19of fftw3 include file and library specified (see installation instructions).; 20Function SetDefaultFFT() allows to change the default library.; 21 ; 22## Available transform types:; 23FFT:; 24 - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); 25 in one or more dimensions, -1 in the exponent; 26 - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); 27 in one or more dimensions, +1 in the exponent; 28 - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); 29 in one or more dimensions,; 30 - ""C2R"" - inverse transforms to ""R2C"", taking complex input; 31 (storing the non-redundant half of a logically Hermitian array); 32 to real output; 33 - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; 34 i.e. real and imaginary parts for a transform of size n stored as; 35 r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; 36 - ""HC2R"" - computes the reverse of FFTW_R2HC, above; 37 - ""DHT"" - computes a discrete Hartley transform; 38 ; 39## Sine/cosine transforms:; 40Different types of transforms are specified by parame",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:697,Integrability,interface,interface,697,". ROOT: core/base/src/TVirtualFFT.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TVirtualFFT.cxx. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Anna Kreshuk 10/04/2006; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TVirtualFFT; 13\ingroup Base; 14 ; 15TVirtualFFT is an interface class for Fast Fourier Transforms.; 16 ; 17The default FFT library is FFTW. To use it, FFTW3 library should already; 18be installed, and ROOT should be have fftw3 module enabled, with the directories; 19of fftw3 include file and library specified (see installation instructions).; 20Function SetDefaultFFT() allows to change the default library.; 21 ; 22## Available transform types:; 23FFT:; 24 - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); 25 in one or more dimensions, -1 in the exponent; 26 - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); 27 in one or more dimensions, +1 in the exponent; 28 - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); 29 in one or more dimensions,; 30 - ""C2R"" - inverse transforms to ""R2C"", taking complex input; 31 (storing the non-redundant half of a logically Hermitian array); 32 to real output; 33 - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; 34 i.e. real and imaginary parts for a transform of size n stored as; 35 r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; 36 - ""HC2R"" - computes the reverse of FFTW_R2HC, above; 37 - ""DHT"" - computes a discrete Hartley transform; 38 ; 39## Sine/cosine transforms:; 40Different types of transforms are specified by parame",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:5141,Integrability,depend,depending,5141,"//; 94///destructor; 95 ; 96TVirtualFFT::~TVirtualFFT(); 97{; 98 if (this==fgFFT); 99 fgFFT = nullptr;; 100}; 101 ; 102////////////////////////////////////////////////////////////////////////////////; 103///Returns a pointer to the FFT of requested size and type.; 104///; 105/// \param[in] ndim number of transform dimensions; 106/// \param[in] n sizes of each dimension (an array at least ndim long); 107/// \param [in] option consists of 3 parts - flag option and an option to create a new TVirtualFFT; 108/// 1. transform type option:; 109/// Available transform types are:; 110/// C2CForward, C2CBackward, C2R, R2C, R2HC, HC2R, DHT; 111/// see class description for details; 112/// 2. flag option: choosing how much time should be spent in planning the transform:; 113/// Possible options:; 114/// - ""ES"" (from ""estimate"") - no time in preparing the transform,; 115/// but probably sub-optimal performance; 116/// - ""M"" (from ""measure"") - some time spend in finding the optimal way; 117/// to do the transform; 118/// - ""P"" (from ""patient"") - more time spend in finding the optimal way; 119/// to do the transform; 120/// - ""EX"" (from ""exhaustive"") - the most optimal way is found; 121/// This option should be chosen depending on how many transforms of the; 122/// same size and type are going to be done.; 123/// Planning is only done once, for the first transform of this size and type.; 124/// 3. option allowing to choose between the global fgFFT and a new TVirtualFFT object; 125/// """" - default, changes and returns the global fgFFT variable; 126/// ""K"" (from ""keep"")- without touching the global fgFFT,; 127/// creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; 128///; 129/// Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc.; 130 ; 131TVirtualFFT* TVirtualFFT::FFT(Int_t ndim, Int_t *n, Option_t *option); 132{; 133 ; 134 Int_t inputtype=0, currenttype=0;; 135 TString opt = option;; 136 opt.ToUpper();; 137 //find the tranform flag; 138 ",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:10246,Integrability,depend,depending,10246,"gFFT->GetTransformFlag()) || !opt.Contains(fgFFT->GetType())) {; 230 Int_t *kind = new Int_t[1];; 231 if (inputtype==1) {; 232 if (opt.Contains(""R2HC"")) kind[0] = 10;; 233 if (opt.Contains(""HC2R"")) kind[0] = 11;; 234 if (opt.Contains(""DHT"")) kind[0] = 12;; 235 }; 236 fgFFT->Init(flag, sign, kind);; 237 delete [] kind;; 238 }; 239 }; 240 return fgFFT;; 241}; 242 ; 243////////////////////////////////////////////////////////////////////////////////; 244///Returns a pointer to a sine or cosine transform of requested size and kind; 245///; 246///Parameters:; 247/// \param [in] ndim number of transform dimensions; 248/// \param [in] n sizes of each dimension (an array at least ndim long); 249/// \param [in] r2rkind transform kind for each dimension; 250/// 4 different kinds of sine and cosine transforms are available; 251/// - DCT-I - kind=0; 252/// - DCT-II - kind=1; 253/// - DCT-III - kind=2; 254/// - DCT-IV - kind=3; 255/// - DST-I - kind=4; 256/// - DST-II - kind=5; 257/// - DST-III - kind=6; 258/// - DST-IV - kind=7; 259/// \param [in] option : consists of 2 parts; 260/// - flag option and an option to create a new TVirtualFFT; 261/// - flag option: choosing how much time should be spent in planning the transform:; 262/// Possible options:; 263/// - ""ES"" (from ""estimate"") - no time in preparing the transform,; 264/// but probably sub-optimal performance; 265/// - ""M"" (from ""measure"") - some time spend in finding the optimal way; 266/// to do the transform; 267/// - ""P"" (from ""patient"") - more time spend in finding the optimal way; 268/// to do the transform; 269/// - ""EX"" (from ""exhaustive"") - the most optimal way is found; 270/// This option should be chosen depending on how many transforms of the; 271/// same size and type are going to be done.; 272/// Planning is only done once, for the first transform of this size and type.; 273/// - option allowing to choose between the global fgFFT and a new TVirtualFFT object; 274/// - """" - default, changes and returns the glo",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:14338,Integrability,message,message,14338,"tFFT(); 370{; 371 return fgDefault.Data();; 372}; 373 ; 374////////////////////////////////////////////////////////////////////////////////; 375/// static: set name of default fft; 376 ; 377void TVirtualFFT::SetDefaultFFT(const char *name); 378{; 379 if (fgDefault == name) return;; 380 delete fgFFT;; 381 fgFFT = nullptr;; 382 fgDefault = name;; 383}; h#define h(i)Definition RSha256.hxx:106; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; TPluginManager.h; TROOT.h; gROOTMutexR__EXTERN TVirtualMutex * gROOTMutexDefinition TROOT.h:63; gROOT#define gROOTDefinition TROOT.h:406; TVirtualFFT.h; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPluginHandlerDefinition TPluginManager.h:103; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVirtualFFTTVirtualFFT is an interface class for Fast Fourier Transforms.Definition TVirtualFFT.h:88; TVirtualFFT::~TVirtualFFTvirtual ~TVirtualFFT()destructorDefinition TVirtualFFT.cxx:96; TVirtualFFT::SetDefaultFFTstatic void SetDefaultFFT(const char *name="""")static: set name of default fftDefinition TVirtualFFT.cxx:377; TVirtualFFT::SetTransformstatic void SetTransform(TVirtualFFT *fft)static: set the cu",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:14468,Integrability,message,message,14468,"////////; 375/// static: set name of default fft; 376 ; 377void TVirtualFFT::SetDefaultFFT(const char *name); 378{; 379 if (fgDefault == name) return;; 380 delete fgFFT;; 381 fgFFT = nullptr;; 382 fgDefault = name;; 383}; h#define h(i)Definition RSha256.hxx:106; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; TPluginManager.h; TROOT.h; gROOTMutexR__EXTERN TVirtualMutex * gROOTMutexDefinition TROOT.h:63; gROOT#define gROOTDefinition TROOT.h:406; TVirtualFFT.h; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPluginHandlerDefinition TPluginManager.h:103; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVirtualFFTTVirtualFFT is an interface class for Fast Fourier Transforms.Definition TVirtualFFT.h:88; TVirtualFFT::~TVirtualFFTvirtual ~TVirtualFFT()destructorDefinition TVirtualFFT.cxx:96; TVirtualFFT::SetDefaultFFTstatic void SetDefaultFFT(const char *name="""")static: set name of default fftDefinition TVirtualFFT.cxx:377; TVirtualFFT::SetTransformstatic void SetTransform(TVirtualFFT *fft)static: set the current transfrom to parameterDefinition TVirtualFFT.cxx:361; TVirtualFFT::Initvirtual void Init(Option_t *flag, Int_t sign, const In",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:14951,Integrability,interface,interface,14951,"alXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; TPluginManager.h; TROOT.h; gROOTMutexR__EXTERN TVirtualMutex * gROOTMutexDefinition TROOT.h:63; gROOT#define gROOTDefinition TROOT.h:406; TVirtualFFT.h; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPluginHandlerDefinition TPluginManager.h:103; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVirtualFFTTVirtualFFT is an interface class for Fast Fourier Transforms.Definition TVirtualFFT.h:88; TVirtualFFT::~TVirtualFFTvirtual ~TVirtualFFT()destructorDefinition TVirtualFFT.cxx:96; TVirtualFFT::SetDefaultFFTstatic void SetDefaultFFT(const char *name="""")static: set name of default fftDefinition TVirtualFFT.cxx:377; TVirtualFFT::SetTransformstatic void SetTransform(TVirtualFFT *fft)static: set the current transfrom to parameterDefinition TVirtualFFT.cxx:361; TVirtualFFT::Initvirtual void Init(Option_t *flag, Int_t sign, const Int_t *kind)=0; TVirtualFFT::FFTstatic TVirtualFFT * FFT(Int_t ndim, Int_t *n, Option_t *option)Returns a pointer to the FFT of requested size and type.Definition TVirtualFFT.cxx:131; TVirtualFFT::GetCurrentTransformstatic TVirtualFFT * GetCurrentTransform()static: return current fgFFTDefinition TVirtualFFT.cxx:348; TVirtualFFT::GetNdimvirtual Int_t GetNdim() const =0; TVirtualFFT::SineCosinestatic TVirtualFFT * SineCosine(Int_t ndim, Int_t *n, Int_t *r2rkind, Option_t *option)Returns a po",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:5463,Modifiability,variab,variable,5463,"ion:; 109/// Available transform types are:; 110/// C2CForward, C2CBackward, C2R, R2C, R2HC, HC2R, DHT; 111/// see class description for details; 112/// 2. flag option: choosing how much time should be spent in planning the transform:; 113/// Possible options:; 114/// - ""ES"" (from ""estimate"") - no time in preparing the transform,; 115/// but probably sub-optimal performance; 116/// - ""M"" (from ""measure"") - some time spend in finding the optimal way; 117/// to do the transform; 118/// - ""P"" (from ""patient"") - more time spend in finding the optimal way; 119/// to do the transform; 120/// - ""EX"" (from ""exhaustive"") - the most optimal way is found; 121/// This option should be chosen depending on how many transforms of the; 122/// same size and type are going to be done.; 123/// Planning is only done once, for the first transform of this size and type.; 124/// 3. option allowing to choose between the global fgFFT and a new TVirtualFFT object; 125/// """" - default, changes and returns the global fgFFT variable; 126/// ""K"" (from ""keep"")- without touching the global fgFFT,; 127/// creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; 128///; 129/// Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc.; 130 ; 131TVirtualFFT* TVirtualFFT::FFT(Int_t ndim, Int_t *n, Option_t *option); 132{; 133 ; 134 Int_t inputtype=0, currenttype=0;; 135 TString opt = option;; 136 opt.ToUpper();; 137 //find the tranform flag; 138 Option_t *flag;; 139 flag = ""ES"";; 140 if (opt.Contains(""ES"")) flag = ""ES"";; 141 if (opt.Contains(""M"")) flag = ""M"";; 142 if (opt.Contains(""P"")) flag = ""P"";; 143 if (opt.Contains(""EX"")) flag = ""EX"";; 144 ; 145 Int_t ndiff = 0;; 146 ; 147 if (!opt.Contains(""K"")) {; 148 if (fgFFT){; 149 //if the global transform exists, check if it should be changed; 150 if (fgFFT->GetNdim()!=ndim); 151 ndiff++;; 152 else {; 153 Int_t *ncurrent = fgFFT->GetN();; 154 for (Int_t i=0; i<ndim; i++){; 155 if (n[i]!=ncurrent[i]); 156 ndiff++;; 157 }; 158",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:7165,Modifiability,plugin,pluginname,7165,"Int_t ndiff = 0;; 146 ; 147 if (!opt.Contains(""K"")) {; 148 if (fgFFT){; 149 //if the global transform exists, check if it should be changed; 150 if (fgFFT->GetNdim()!=ndim); 151 ndiff++;; 152 else {; 153 Int_t *ncurrent = fgFFT->GetN();; 154 for (Int_t i=0; i<ndim; i++){; 155 if (n[i]!=ncurrent[i]); 156 ndiff++;; 157 }; 158 }; 159 Option_t *t = fgFFT->GetType();; 160 if (!opt.Contains(t)) {; 161 if (opt.Contains(""HC"") || opt.Contains(""DHT"")); 162 inputtype = 1;; 163 if (strcmp(t,""R2HC"")==0 || strcmp(t,""HC2R"")==0 || strcmp(t,""DHT"")==0); 164 currenttype=1;; 165 ; 166 if (!(inputtype==1 && currenttype==1)); 167 ndiff++;; 168 }; 169 if (ndiff>0){; 170 delete fgFFT;; 171 fgFFT = nullptr;; 172 }; 173 }; 174 }; 175 ; 176 Int_t sign = 0;; 177 if (opt.Contains(""C2CB"") || opt.Contains(""C2R"")); 178 sign = 1;; 179 if (opt.Contains(""C2CF"") || opt.Contains(""R2C"")); 180 sign = -1;; 181 ; 182 TVirtualFFT *fft = nullptr;; 183 if (opt.Contains(""K"") || !fgFFT) {; 184 ; 185 R__LOCKGUARD(gROOTMutex);; 186 ; 187 TPluginHandler *h;; 188 TString pluginname;; 189 if (fgDefault.Length()==0) fgDefault=""fftw"";; 190 if (strcmp(fgDefault.Data(),""fftw"")==0) {; 191 if (opt.Contains(""C2C"")) pluginname = ""fftwc2c"";; 192 if (opt.Contains(""C2R"")) pluginname = ""fftwc2r"";; 193 if (opt.Contains(""R2C"")) pluginname = ""fftwr2c"";; 194 if (opt.Contains(""HC"") || opt.Contains(""DHT"")) pluginname = ""fftwr2r"";; 195 if ((h=gROOT->GetPluginManager()->FindHandler(""TVirtualFFT"", pluginname))) {; 196 if (h->LoadPlugin()==-1) {; 197 ::Error(""TVirtualFFT::FFT"", ""handler not found"");; 198 return nullptr;; 199 }; 200 fft = (TVirtualFFT*)h->ExecPlugin(3, ndim, n, kFALSE);; 201 if (!fft) {; 202 ::Error(""TVirtualFFT::FFT"", ""plugin failed to create TVirtualFFT object"");; 203 return nullptr;; 204 }; 205 Int_t *kind = new Int_t[1];; 206 if (pluginname==""fftwr2r"") {; 207 if (opt.Contains(""R2HC"")) kind[0] = 10;; 208 if (opt.Contains(""HC2R"")) kind[0] = 11;; 209 if (opt.Contains(""DHT"")) kind[0] = 12;; 210 }; 211 fft->Init(flag, sign",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:7304,Modifiability,plugin,pluginname,7304," 152 else {; 153 Int_t *ncurrent = fgFFT->GetN();; 154 for (Int_t i=0; i<ndim; i++){; 155 if (n[i]!=ncurrent[i]); 156 ndiff++;; 157 }; 158 }; 159 Option_t *t = fgFFT->GetType();; 160 if (!opt.Contains(t)) {; 161 if (opt.Contains(""HC"") || opt.Contains(""DHT"")); 162 inputtype = 1;; 163 if (strcmp(t,""R2HC"")==0 || strcmp(t,""HC2R"")==0 || strcmp(t,""DHT"")==0); 164 currenttype=1;; 165 ; 166 if (!(inputtype==1 && currenttype==1)); 167 ndiff++;; 168 }; 169 if (ndiff>0){; 170 delete fgFFT;; 171 fgFFT = nullptr;; 172 }; 173 }; 174 }; 175 ; 176 Int_t sign = 0;; 177 if (opt.Contains(""C2CB"") || opt.Contains(""C2R"")); 178 sign = 1;; 179 if (opt.Contains(""C2CF"") || opt.Contains(""R2C"")); 180 sign = -1;; 181 ; 182 TVirtualFFT *fft = nullptr;; 183 if (opt.Contains(""K"") || !fgFFT) {; 184 ; 185 R__LOCKGUARD(gROOTMutex);; 186 ; 187 TPluginHandler *h;; 188 TString pluginname;; 189 if (fgDefault.Length()==0) fgDefault=""fftw"";; 190 if (strcmp(fgDefault.Data(),""fftw"")==0) {; 191 if (opt.Contains(""C2C"")) pluginname = ""fftwc2c"";; 192 if (opt.Contains(""C2R"")) pluginname = ""fftwc2r"";; 193 if (opt.Contains(""R2C"")) pluginname = ""fftwr2c"";; 194 if (opt.Contains(""HC"") || opt.Contains(""DHT"")) pluginname = ""fftwr2r"";; 195 if ((h=gROOT->GetPluginManager()->FindHandler(""TVirtualFFT"", pluginname))) {; 196 if (h->LoadPlugin()==-1) {; 197 ::Error(""TVirtualFFT::FFT"", ""handler not found"");; 198 return nullptr;; 199 }; 200 fft = (TVirtualFFT*)h->ExecPlugin(3, ndim, n, kFALSE);; 201 if (!fft) {; 202 ::Error(""TVirtualFFT::FFT"", ""plugin failed to create TVirtualFFT object"");; 203 return nullptr;; 204 }; 205 Int_t *kind = new Int_t[1];; 206 if (pluginname==""fftwr2r"") {; 207 if (opt.Contains(""R2HC"")) kind[0] = 10;; 208 if (opt.Contains(""HC2R"")) kind[0] = 11;; 209 if (opt.Contains(""DHT"")) kind[0] = 12;; 210 }; 211 fft->Init(flag, sign, kind);; 212 if (!opt.Contains(""K"")) {; 213 fgFFT = fft;; 214 }; 215 delete [] kind;; 216 return fft;; 217 }; 218 else {; 219 ::Error(""TVirtualFFT::FFT"", ""plugin not found"");; 220 return",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:7358,Modifiability,plugin,pluginname,7358," for (Int_t i=0; i<ndim; i++){; 155 if (n[i]!=ncurrent[i]); 156 ndiff++;; 157 }; 158 }; 159 Option_t *t = fgFFT->GetType();; 160 if (!opt.Contains(t)) {; 161 if (opt.Contains(""HC"") || opt.Contains(""DHT"")); 162 inputtype = 1;; 163 if (strcmp(t,""R2HC"")==0 || strcmp(t,""HC2R"")==0 || strcmp(t,""DHT"")==0); 164 currenttype=1;; 165 ; 166 if (!(inputtype==1 && currenttype==1)); 167 ndiff++;; 168 }; 169 if (ndiff>0){; 170 delete fgFFT;; 171 fgFFT = nullptr;; 172 }; 173 }; 174 }; 175 ; 176 Int_t sign = 0;; 177 if (opt.Contains(""C2CB"") || opt.Contains(""C2R"")); 178 sign = 1;; 179 if (opt.Contains(""C2CF"") || opt.Contains(""R2C"")); 180 sign = -1;; 181 ; 182 TVirtualFFT *fft = nullptr;; 183 if (opt.Contains(""K"") || !fgFFT) {; 184 ; 185 R__LOCKGUARD(gROOTMutex);; 186 ; 187 TPluginHandler *h;; 188 TString pluginname;; 189 if (fgDefault.Length()==0) fgDefault=""fftw"";; 190 if (strcmp(fgDefault.Data(),""fftw"")==0) {; 191 if (opt.Contains(""C2C"")) pluginname = ""fftwc2c"";; 192 if (opt.Contains(""C2R"")) pluginname = ""fftwc2r"";; 193 if (opt.Contains(""R2C"")) pluginname = ""fftwr2c"";; 194 if (opt.Contains(""HC"") || opt.Contains(""DHT"")) pluginname = ""fftwr2r"";; 195 if ((h=gROOT->GetPluginManager()->FindHandler(""TVirtualFFT"", pluginname))) {; 196 if (h->LoadPlugin()==-1) {; 197 ::Error(""TVirtualFFT::FFT"", ""handler not found"");; 198 return nullptr;; 199 }; 200 fft = (TVirtualFFT*)h->ExecPlugin(3, ndim, n, kFALSE);; 201 if (!fft) {; 202 ::Error(""TVirtualFFT::FFT"", ""plugin failed to create TVirtualFFT object"");; 203 return nullptr;; 204 }; 205 Int_t *kind = new Int_t[1];; 206 if (pluginname==""fftwr2r"") {; 207 if (opt.Contains(""R2HC"")) kind[0] = 10;; 208 if (opt.Contains(""HC2R"")) kind[0] = 11;; 209 if (opt.Contains(""DHT"")) kind[0] = 12;; 210 }; 211 fft->Init(flag, sign, kind);; 212 if (!opt.Contains(""K"")) {; 213 fgFFT = fft;; 214 }; 215 delete [] kind;; 216 return fft;; 217 }; 218 else {; 219 ::Error(""TVirtualFFT::FFT"", ""plugin not found"");; 220 return nullptr;; 221 }; 222 }; 223 } else {; 224 ; 225 R__LO",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:7412,Modifiability,plugin,pluginname,7412,"[i]); 156 ndiff++;; 157 }; 158 }; 159 Option_t *t = fgFFT->GetType();; 160 if (!opt.Contains(t)) {; 161 if (opt.Contains(""HC"") || opt.Contains(""DHT"")); 162 inputtype = 1;; 163 if (strcmp(t,""R2HC"")==0 || strcmp(t,""HC2R"")==0 || strcmp(t,""DHT"")==0); 164 currenttype=1;; 165 ; 166 if (!(inputtype==1 && currenttype==1)); 167 ndiff++;; 168 }; 169 if (ndiff>0){; 170 delete fgFFT;; 171 fgFFT = nullptr;; 172 }; 173 }; 174 }; 175 ; 176 Int_t sign = 0;; 177 if (opt.Contains(""C2CB"") || opt.Contains(""C2R"")); 178 sign = 1;; 179 if (opt.Contains(""C2CF"") || opt.Contains(""R2C"")); 180 sign = -1;; 181 ; 182 TVirtualFFT *fft = nullptr;; 183 if (opt.Contains(""K"") || !fgFFT) {; 184 ; 185 R__LOCKGUARD(gROOTMutex);; 186 ; 187 TPluginHandler *h;; 188 TString pluginname;; 189 if (fgDefault.Length()==0) fgDefault=""fftw"";; 190 if (strcmp(fgDefault.Data(),""fftw"")==0) {; 191 if (opt.Contains(""C2C"")) pluginname = ""fftwc2c"";; 192 if (opt.Contains(""C2R"")) pluginname = ""fftwc2r"";; 193 if (opt.Contains(""R2C"")) pluginname = ""fftwr2c"";; 194 if (opt.Contains(""HC"") || opt.Contains(""DHT"")) pluginname = ""fftwr2r"";; 195 if ((h=gROOT->GetPluginManager()->FindHandler(""TVirtualFFT"", pluginname))) {; 196 if (h->LoadPlugin()==-1) {; 197 ::Error(""TVirtualFFT::FFT"", ""handler not found"");; 198 return nullptr;; 199 }; 200 fft = (TVirtualFFT*)h->ExecPlugin(3, ndim, n, kFALSE);; 201 if (!fft) {; 202 ::Error(""TVirtualFFT::FFT"", ""plugin failed to create TVirtualFFT object"");; 203 return nullptr;; 204 }; 205 Int_t *kind = new Int_t[1];; 206 if (pluginname==""fftwr2r"") {; 207 if (opt.Contains(""R2HC"")) kind[0] = 10;; 208 if (opt.Contains(""HC2R"")) kind[0] = 11;; 209 if (opt.Contains(""DHT"")) kind[0] = 12;; 210 }; 211 fft->Init(flag, sign, kind);; 212 if (!opt.Contains(""K"")) {; 213 fgFFT = fft;; 214 }; 215 delete [] kind;; 216 return fft;; 217 }; 218 else {; 219 ::Error(""TVirtualFFT::FFT"", ""plugin not found"");; 220 return nullptr;; 221 }; 222 }; 223 } else {; 224 ; 225 R__LOCKGUARD(gROOTMutex);; 226 ; 227 //if the global transf",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:7488,Modifiability,plugin,pluginname,7488,"urrenttype==1)); 167 ndiff++;; 168 }; 169 if (ndiff>0){; 170 delete fgFFT;; 171 fgFFT = nullptr;; 172 }; 173 }; 174 }; 175 ; 176 Int_t sign = 0;; 177 if (opt.Contains(""C2CB"") || opt.Contains(""C2R"")); 178 sign = 1;; 179 if (opt.Contains(""C2CF"") || opt.Contains(""R2C"")); 180 sign = -1;; 181 ; 182 TVirtualFFT *fft = nullptr;; 183 if (opt.Contains(""K"") || !fgFFT) {; 184 ; 185 R__LOCKGUARD(gROOTMutex);; 186 ; 187 TPluginHandler *h;; 188 TString pluginname;; 189 if (fgDefault.Length()==0) fgDefault=""fftw"";; 190 if (strcmp(fgDefault.Data(),""fftw"")==0) {; 191 if (opt.Contains(""C2C"")) pluginname = ""fftwc2c"";; 192 if (opt.Contains(""C2R"")) pluginname = ""fftwc2r"";; 193 if (opt.Contains(""R2C"")) pluginname = ""fftwr2c"";; 194 if (opt.Contains(""HC"") || opt.Contains(""DHT"")) pluginname = ""fftwr2r"";; 195 if ((h=gROOT->GetPluginManager()->FindHandler(""TVirtualFFT"", pluginname))) {; 196 if (h->LoadPlugin()==-1) {; 197 ::Error(""TVirtualFFT::FFT"", ""handler not found"");; 198 return nullptr;; 199 }; 200 fft = (TVirtualFFT*)h->ExecPlugin(3, ndim, n, kFALSE);; 201 if (!fft) {; 202 ::Error(""TVirtualFFT::FFT"", ""plugin failed to create TVirtualFFT object"");; 203 return nullptr;; 204 }; 205 Int_t *kind = new Int_t[1];; 206 if (pluginname==""fftwr2r"") {; 207 if (opt.Contains(""R2HC"")) kind[0] = 10;; 208 if (opt.Contains(""HC2R"")) kind[0] = 11;; 209 if (opt.Contains(""DHT"")) kind[0] = 12;; 210 }; 211 fft->Init(flag, sign, kind);; 212 if (!opt.Contains(""K"")) {; 213 fgFFT = fft;; 214 }; 215 delete [] kind;; 216 return fft;; 217 }; 218 else {; 219 ::Error(""TVirtualFFT::FFT"", ""plugin not found"");; 220 return nullptr;; 221 }; 222 }; 223 } else {; 224 ; 225 R__LOCKGUARD(gROOTMutex);; 226 ; 227 //if the global transform already exists and just needs to be reinitialised; 228 //with different parameters; 229 if (fgFFT->GetSign()!=sign || !opt.Contains(fgFFT->GetTransformFlag()) || !opt.Contains(fgFFT->GetType())) {; 230 Int_t *kind = new Int_t[1];; 231 if (inputtype==1) {; 232 if (opt.Contains(""R2HC"")) kind[0] = 1",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:7578,Modifiability,plugin,pluginname,7578,"urrenttype==1)); 167 ndiff++;; 168 }; 169 if (ndiff>0){; 170 delete fgFFT;; 171 fgFFT = nullptr;; 172 }; 173 }; 174 }; 175 ; 176 Int_t sign = 0;; 177 if (opt.Contains(""C2CB"") || opt.Contains(""C2R"")); 178 sign = 1;; 179 if (opt.Contains(""C2CF"") || opt.Contains(""R2C"")); 180 sign = -1;; 181 ; 182 TVirtualFFT *fft = nullptr;; 183 if (opt.Contains(""K"") || !fgFFT) {; 184 ; 185 R__LOCKGUARD(gROOTMutex);; 186 ; 187 TPluginHandler *h;; 188 TString pluginname;; 189 if (fgDefault.Length()==0) fgDefault=""fftw"";; 190 if (strcmp(fgDefault.Data(),""fftw"")==0) {; 191 if (opt.Contains(""C2C"")) pluginname = ""fftwc2c"";; 192 if (opt.Contains(""C2R"")) pluginname = ""fftwc2r"";; 193 if (opt.Contains(""R2C"")) pluginname = ""fftwr2c"";; 194 if (opt.Contains(""HC"") || opt.Contains(""DHT"")) pluginname = ""fftwr2r"";; 195 if ((h=gROOT->GetPluginManager()->FindHandler(""TVirtualFFT"", pluginname))) {; 196 if (h->LoadPlugin()==-1) {; 197 ::Error(""TVirtualFFT::FFT"", ""handler not found"");; 198 return nullptr;; 199 }; 200 fft = (TVirtualFFT*)h->ExecPlugin(3, ndim, n, kFALSE);; 201 if (!fft) {; 202 ::Error(""TVirtualFFT::FFT"", ""plugin failed to create TVirtualFFT object"");; 203 return nullptr;; 204 }; 205 Int_t *kind = new Int_t[1];; 206 if (pluginname==""fftwr2r"") {; 207 if (opt.Contains(""R2HC"")) kind[0] = 10;; 208 if (opt.Contains(""HC2R"")) kind[0] = 11;; 209 if (opt.Contains(""DHT"")) kind[0] = 12;; 210 }; 211 fft->Init(flag, sign, kind);; 212 if (!opt.Contains(""K"")) {; 213 fgFFT = fft;; 214 }; 215 delete [] kind;; 216 return fft;; 217 }; 218 else {; 219 ::Error(""TVirtualFFT::FFT"", ""plugin not found"");; 220 return nullptr;; 221 }; 222 }; 223 } else {; 224 ; 225 R__LOCKGUARD(gROOTMutex);; 226 ; 227 //if the global transform already exists and just needs to be reinitialised; 228 //with different parameters; 229 if (fgFFT->GetSign()!=sign || !opt.Contains(fgFFT->GetTransformFlag()) || !opt.Contains(fgFFT->GetType())) {; 230 Int_t *kind = new Int_t[1];; 231 if (inputtype==1) {; 232 if (opt.Contains(""R2HC"")) kind[0] = 1",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:7820,Modifiability,plugin,plugin,7820,"urrenttype==1)); 167 ndiff++;; 168 }; 169 if (ndiff>0){; 170 delete fgFFT;; 171 fgFFT = nullptr;; 172 }; 173 }; 174 }; 175 ; 176 Int_t sign = 0;; 177 if (opt.Contains(""C2CB"") || opt.Contains(""C2R"")); 178 sign = 1;; 179 if (opt.Contains(""C2CF"") || opt.Contains(""R2C"")); 180 sign = -1;; 181 ; 182 TVirtualFFT *fft = nullptr;; 183 if (opt.Contains(""K"") || !fgFFT) {; 184 ; 185 R__LOCKGUARD(gROOTMutex);; 186 ; 187 TPluginHandler *h;; 188 TString pluginname;; 189 if (fgDefault.Length()==0) fgDefault=""fftw"";; 190 if (strcmp(fgDefault.Data(),""fftw"")==0) {; 191 if (opt.Contains(""C2C"")) pluginname = ""fftwc2c"";; 192 if (opt.Contains(""C2R"")) pluginname = ""fftwc2r"";; 193 if (opt.Contains(""R2C"")) pluginname = ""fftwr2c"";; 194 if (opt.Contains(""HC"") || opt.Contains(""DHT"")) pluginname = ""fftwr2r"";; 195 if ((h=gROOT->GetPluginManager()->FindHandler(""TVirtualFFT"", pluginname))) {; 196 if (h->LoadPlugin()==-1) {; 197 ::Error(""TVirtualFFT::FFT"", ""handler not found"");; 198 return nullptr;; 199 }; 200 fft = (TVirtualFFT*)h->ExecPlugin(3, ndim, n, kFALSE);; 201 if (!fft) {; 202 ::Error(""TVirtualFFT::FFT"", ""plugin failed to create TVirtualFFT object"");; 203 return nullptr;; 204 }; 205 Int_t *kind = new Int_t[1];; 206 if (pluginname==""fftwr2r"") {; 207 if (opt.Contains(""R2HC"")) kind[0] = 10;; 208 if (opt.Contains(""HC2R"")) kind[0] = 11;; 209 if (opt.Contains(""DHT"")) kind[0] = 12;; 210 }; 211 fft->Init(flag, sign, kind);; 212 if (!opt.Contains(""K"")) {; 213 fgFFT = fft;; 214 }; 215 delete [] kind;; 216 return fft;; 217 }; 218 else {; 219 ::Error(""TVirtualFFT::FFT"", ""plugin not found"");; 220 return nullptr;; 221 }; 222 }; 223 } else {; 224 ; 225 R__LOCKGUARD(gROOTMutex);; 226 ; 227 //if the global transform already exists and just needs to be reinitialised; 228 //with different parameters; 229 if (fgFFT->GetSign()!=sign || !opt.Contains(fgFFT->GetTransformFlag()) || !opt.Contains(fgFFT->GetType())) {; 230 Int_t *kind = new Int_t[1];; 231 if (inputtype==1) {; 232 if (opt.Contains(""R2HC"")) kind[0] = 1",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:7936,Modifiability,plugin,pluginname,7936,"urrenttype==1)); 167 ndiff++;; 168 }; 169 if (ndiff>0){; 170 delete fgFFT;; 171 fgFFT = nullptr;; 172 }; 173 }; 174 }; 175 ; 176 Int_t sign = 0;; 177 if (opt.Contains(""C2CB"") || opt.Contains(""C2R"")); 178 sign = 1;; 179 if (opt.Contains(""C2CF"") || opt.Contains(""R2C"")); 180 sign = -1;; 181 ; 182 TVirtualFFT *fft = nullptr;; 183 if (opt.Contains(""K"") || !fgFFT) {; 184 ; 185 R__LOCKGUARD(gROOTMutex);; 186 ; 187 TPluginHandler *h;; 188 TString pluginname;; 189 if (fgDefault.Length()==0) fgDefault=""fftw"";; 190 if (strcmp(fgDefault.Data(),""fftw"")==0) {; 191 if (opt.Contains(""C2C"")) pluginname = ""fftwc2c"";; 192 if (opt.Contains(""C2R"")) pluginname = ""fftwc2r"";; 193 if (opt.Contains(""R2C"")) pluginname = ""fftwr2c"";; 194 if (opt.Contains(""HC"") || opt.Contains(""DHT"")) pluginname = ""fftwr2r"";; 195 if ((h=gROOT->GetPluginManager()->FindHandler(""TVirtualFFT"", pluginname))) {; 196 if (h->LoadPlugin()==-1) {; 197 ::Error(""TVirtualFFT::FFT"", ""handler not found"");; 198 return nullptr;; 199 }; 200 fft = (TVirtualFFT*)h->ExecPlugin(3, ndim, n, kFALSE);; 201 if (!fft) {; 202 ::Error(""TVirtualFFT::FFT"", ""plugin failed to create TVirtualFFT object"");; 203 return nullptr;; 204 }; 205 Int_t *kind = new Int_t[1];; 206 if (pluginname==""fftwr2r"") {; 207 if (opt.Contains(""R2HC"")) kind[0] = 10;; 208 if (opt.Contains(""HC2R"")) kind[0] = 11;; 209 if (opt.Contains(""DHT"")) kind[0] = 12;; 210 }; 211 fft->Init(flag, sign, kind);; 212 if (!opt.Contains(""K"")) {; 213 fgFFT = fft;; 214 }; 215 delete [] kind;; 216 return fft;; 217 }; 218 else {; 219 ::Error(""TVirtualFFT::FFT"", ""plugin not found"");; 220 return nullptr;; 221 }; 222 }; 223 } else {; 224 ; 225 R__LOCKGUARD(gROOTMutex);; 226 ; 227 //if the global transform already exists and just needs to be reinitialised; 228 //with different parameters; 229 if (fgFFT->GetSign()!=sign || !opt.Contains(fgFFT->GetTransformFlag()) || !opt.Contains(fgFFT->GetType())) {; 230 Int_t *kind = new Int_t[1];; 231 if (inputtype==1) {; 232 if (opt.Contains(""R2HC"")) kind[0] = 1",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:8283,Modifiability,plugin,plugin,8283,"(""C2R"")) pluginname = ""fftwc2r"";; 193 if (opt.Contains(""R2C"")) pluginname = ""fftwr2c"";; 194 if (opt.Contains(""HC"") || opt.Contains(""DHT"")) pluginname = ""fftwr2r"";; 195 if ((h=gROOT->GetPluginManager()->FindHandler(""TVirtualFFT"", pluginname))) {; 196 if (h->LoadPlugin()==-1) {; 197 ::Error(""TVirtualFFT::FFT"", ""handler not found"");; 198 return nullptr;; 199 }; 200 fft = (TVirtualFFT*)h->ExecPlugin(3, ndim, n, kFALSE);; 201 if (!fft) {; 202 ::Error(""TVirtualFFT::FFT"", ""plugin failed to create TVirtualFFT object"");; 203 return nullptr;; 204 }; 205 Int_t *kind = new Int_t[1];; 206 if (pluginname==""fftwr2r"") {; 207 if (opt.Contains(""R2HC"")) kind[0] = 10;; 208 if (opt.Contains(""HC2R"")) kind[0] = 11;; 209 if (opt.Contains(""DHT"")) kind[0] = 12;; 210 }; 211 fft->Init(flag, sign, kind);; 212 if (!opt.Contains(""K"")) {; 213 fgFFT = fft;; 214 }; 215 delete [] kind;; 216 return fft;; 217 }; 218 else {; 219 ::Error(""TVirtualFFT::FFT"", ""plugin not found"");; 220 return nullptr;; 221 }; 222 }; 223 } else {; 224 ; 225 R__LOCKGUARD(gROOTMutex);; 226 ; 227 //if the global transform already exists and just needs to be reinitialised; 228 //with different parameters; 229 if (fgFFT->GetSign()!=sign || !opt.Contains(fgFFT->GetTransformFlag()) || !opt.Contains(fgFFT->GetType())) {; 230 Int_t *kind = new Int_t[1];; 231 if (inputtype==1) {; 232 if (opt.Contains(""R2HC"")) kind[0] = 10;; 233 if (opt.Contains(""HC2R"")) kind[0] = 11;; 234 if (opt.Contains(""DHT"")) kind[0] = 12;; 235 }; 236 fgFFT->Init(flag, sign, kind);; 237 delete [] kind;; 238 }; 239 }; 240 return fgFFT;; 241}; 242 ; 243////////////////////////////////////////////////////////////////////////////////; 244///Returns a pointer to a sine or cosine transform of requested size and kind; 245///; 246///Parameters:; 247/// \param [in] ndim number of transform dimensions; 248/// \param [in] n sizes of each dimension (an array at least ndim long); 249/// \param [in] r2rkind transform kind for each dimension; 250/// 4 different kinds of sine and ",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:10569,Modifiability,variab,variable,10569,"I - kind=6; 258/// - DST-IV - kind=7; 259/// \param [in] option : consists of 2 parts; 260/// - flag option and an option to create a new TVirtualFFT; 261/// - flag option: choosing how much time should be spent in planning the transform:; 262/// Possible options:; 263/// - ""ES"" (from ""estimate"") - no time in preparing the transform,; 264/// but probably sub-optimal performance; 265/// - ""M"" (from ""measure"") - some time spend in finding the optimal way; 266/// to do the transform; 267/// - ""P"" (from ""patient"") - more time spend in finding the optimal way; 268/// to do the transform; 269/// - ""EX"" (from ""exhaustive"") - the most optimal way is found; 270/// This option should be chosen depending on how many transforms of the; 271/// same size and type are going to be done.; 272/// Planning is only done once, for the first transform of this size and type.; 273/// - option allowing to choose between the global fgFFT and a new TVirtualFFT object; 274/// - """" - default, changes and returns the global fgFFT variable; 275/// - ""K"" (from ""keep"")- without touching the global fgFFT,; 276/// creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; 277/// Examples of valid options: ""ES K"", ""EX"", etc; 278 ; 279TVirtualFFT* TVirtualFFT::SineCosine(Int_t ndim, Int_t *n, Int_t *r2rkind, Option_t *option); 280{; 281 TString opt = option;; 282 //find the tranform flag; 283 Option_t *flag;; 284 flag = ""ES"";; 285 if (opt.Contains(""ES"")) flag = ""ES"";; 286 if (opt.Contains(""M"")) flag = ""M"";; 287 if (opt.Contains(""P"")) flag = ""P"";; 288 if (opt.Contains(""EX"")) flag = ""EX"";; 289 ; 290 if (!opt.Contains(""K"")) {; 291 if (fgFFT){; 292 Int_t ndiff = 0;; 293 if (fgFFT->GetNdim()!=ndim || strcmp(fgFFT->GetType(),""R2R"")!=0); 294 ndiff++;; 295 else {; 296 Int_t *ncurrent = fgFFT->GetN();; 297 for (Int_t i=0; i<ndim; i++) {; 298 if (n[i] != ncurrent[i]); 299 ndiff++;; 300 }; 301 ; 302 }; 303 if (ndiff>0) {; 304 delete fgFFT;; 305 fgFFT = nullptr;; 306 }; 307 }; 308 }; 309 TV",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:11699,Modifiability,plugin,pluginname,11699,"*. User is then responsible for deleting it.; 277/// Examples of valid options: ""ES K"", ""EX"", etc; 278 ; 279TVirtualFFT* TVirtualFFT::SineCosine(Int_t ndim, Int_t *n, Int_t *r2rkind, Option_t *option); 280{; 281 TString opt = option;; 282 //find the tranform flag; 283 Option_t *flag;; 284 flag = ""ES"";; 285 if (opt.Contains(""ES"")) flag = ""ES"";; 286 if (opt.Contains(""M"")) flag = ""M"";; 287 if (opt.Contains(""P"")) flag = ""P"";; 288 if (opt.Contains(""EX"")) flag = ""EX"";; 289 ; 290 if (!opt.Contains(""K"")) {; 291 if (fgFFT){; 292 Int_t ndiff = 0;; 293 if (fgFFT->GetNdim()!=ndim || strcmp(fgFFT->GetType(),""R2R"")!=0); 294 ndiff++;; 295 else {; 296 Int_t *ncurrent = fgFFT->GetN();; 297 for (Int_t i=0; i<ndim; i++) {; 298 if (n[i] != ncurrent[i]); 299 ndiff++;; 300 }; 301 ; 302 }; 303 if (ndiff>0) {; 304 delete fgFFT;; 305 fgFFT = nullptr;; 306 }; 307 }; 308 }; 309 TVirtualFFT *fft = nullptr;; 310 ; 311 R__LOCKGUARD(gROOTMutex);; 312 ; 313 if (!fgFFT || opt.Contains(""K"")) {; 314 TPluginHandler *h;; 315 TString pluginname;; 316 if (fgDefault.Length()==0) fgDefault=""fftw"";; 317 if (strcmp(fgDefault.Data(),""fftw"")==0) {; 318 pluginname = ""fftwr2r"";; 319 if ((h=gROOT->GetPluginManager()->FindHandler(""TVirtualFFT"", pluginname))) {; 320 if (h->LoadPlugin()==-1){; 321 ::Error(""TVirtualFFT::SineCosine"", ""handler not found"");; 322 return nullptr;; 323 }; 324 fft = (TVirtualFFT*)h->ExecPlugin(3, ndim, n, kFALSE);; 325 if (!fft) {; 326 ::Error(""TVirtualFFT::SineCosine"", ""plugin failed to create TVirtualFFT object"");; 327 return nullptr;; 328 }; 329 fft->Init(flag, 0, r2rkind);; 330 if (!opt.Contains(""K"")); 331 fgFFT = fft;; 332 return fft;; 333 } else {; 334 ::Error(""TVirtualFFT::SineCosine"", ""handler not found"");; 335 return nullptr;; 336 }; 337 }; 338 }; 339 ; 340 //if (fgFFT->GetTransformFlag()!=flag); 341 fgFFT->Init(flag,0, r2rkind);; 342 return fgFFT;; 343}; 344 ; 345////////////////////////////////////////////////////////////////////////////////; 346/// static: return current fgFFT; 3",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:11813,Modifiability,plugin,pluginname,11813,"286 if (opt.Contains(""M"")) flag = ""M"";; 287 if (opt.Contains(""P"")) flag = ""P"";; 288 if (opt.Contains(""EX"")) flag = ""EX"";; 289 ; 290 if (!opt.Contains(""K"")) {; 291 if (fgFFT){; 292 Int_t ndiff = 0;; 293 if (fgFFT->GetNdim()!=ndim || strcmp(fgFFT->GetType(),""R2R"")!=0); 294 ndiff++;; 295 else {; 296 Int_t *ncurrent = fgFFT->GetN();; 297 for (Int_t i=0; i<ndim; i++) {; 298 if (n[i] != ncurrent[i]); 299 ndiff++;; 300 }; 301 ; 302 }; 303 if (ndiff>0) {; 304 delete fgFFT;; 305 fgFFT = nullptr;; 306 }; 307 }; 308 }; 309 TVirtualFFT *fft = nullptr;; 310 ; 311 R__LOCKGUARD(gROOTMutex);; 312 ; 313 if (!fgFFT || opt.Contains(""K"")) {; 314 TPluginHandler *h;; 315 TString pluginname;; 316 if (fgDefault.Length()==0) fgDefault=""fftw"";; 317 if (strcmp(fgDefault.Data(),""fftw"")==0) {; 318 pluginname = ""fftwr2r"";; 319 if ((h=gROOT->GetPluginManager()->FindHandler(""TVirtualFFT"", pluginname))) {; 320 if (h->LoadPlugin()==-1){; 321 ::Error(""TVirtualFFT::SineCosine"", ""handler not found"");; 322 return nullptr;; 323 }; 324 fft = (TVirtualFFT*)h->ExecPlugin(3, ndim, n, kFALSE);; 325 if (!fft) {; 326 ::Error(""TVirtualFFT::SineCosine"", ""plugin failed to create TVirtualFFT object"");; 327 return nullptr;; 328 }; 329 fft->Init(flag, 0, r2rkind);; 330 if (!opt.Contains(""K"")); 331 fgFFT = fft;; 332 return fft;; 333 } else {; 334 ::Error(""TVirtualFFT::SineCosine"", ""handler not found"");; 335 return nullptr;; 336 }; 337 }; 338 }; 339 ; 340 //if (fgFFT->GetTransformFlag()!=flag); 341 fgFFT->Init(flag,0, r2rkind);; 342 return fgFFT;; 343}; 344 ; 345////////////////////////////////////////////////////////////////////////////////; 346/// static: return current fgFFT; 347 ; 348TVirtualFFT* TVirtualFFT::GetCurrentTransform(); 349{; 350 if (fgFFT); 351 return fgFFT;; 352 else{; 353 ::Warning(""TVirtualFFT::GetCurrentTransform"", ""fgFFT is not defined yet"");; 354 return nullptr;; 355 }; 356}; 357 ; 358////////////////////////////////////////////////////////////////////////////////; 359/// static: set the current t",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:11903,Modifiability,plugin,pluginname,11903,"286 if (opt.Contains(""M"")) flag = ""M"";; 287 if (opt.Contains(""P"")) flag = ""P"";; 288 if (opt.Contains(""EX"")) flag = ""EX"";; 289 ; 290 if (!opt.Contains(""K"")) {; 291 if (fgFFT){; 292 Int_t ndiff = 0;; 293 if (fgFFT->GetNdim()!=ndim || strcmp(fgFFT->GetType(),""R2R"")!=0); 294 ndiff++;; 295 else {; 296 Int_t *ncurrent = fgFFT->GetN();; 297 for (Int_t i=0; i<ndim; i++) {; 298 if (n[i] != ncurrent[i]); 299 ndiff++;; 300 }; 301 ; 302 }; 303 if (ndiff>0) {; 304 delete fgFFT;; 305 fgFFT = nullptr;; 306 }; 307 }; 308 }; 309 TVirtualFFT *fft = nullptr;; 310 ; 311 R__LOCKGUARD(gROOTMutex);; 312 ; 313 if (!fgFFT || opt.Contains(""K"")) {; 314 TPluginHandler *h;; 315 TString pluginname;; 316 if (fgDefault.Length()==0) fgDefault=""fftw"";; 317 if (strcmp(fgDefault.Data(),""fftw"")==0) {; 318 pluginname = ""fftwr2r"";; 319 if ((h=gROOT->GetPluginManager()->FindHandler(""TVirtualFFT"", pluginname))) {; 320 if (h->LoadPlugin()==-1){; 321 ::Error(""TVirtualFFT::SineCosine"", ""handler not found"");; 322 return nullptr;; 323 }; 324 fft = (TVirtualFFT*)h->ExecPlugin(3, ndim, n, kFALSE);; 325 if (!fft) {; 326 ::Error(""TVirtualFFT::SineCosine"", ""plugin failed to create TVirtualFFT object"");; 327 return nullptr;; 328 }; 329 fft->Init(flag, 0, r2rkind);; 330 if (!opt.Contains(""K"")); 331 fgFFT = fft;; 332 return fft;; 333 } else {; 334 ::Error(""TVirtualFFT::SineCosine"", ""handler not found"");; 335 return nullptr;; 336 }; 337 }; 338 }; 339 ; 340 //if (fgFFT->GetTransformFlag()!=flag); 341 fgFFT->Init(flag,0, r2rkind);; 342 return fgFFT;; 343}; 344 ; 345////////////////////////////////////////////////////////////////////////////////; 346/// static: return current fgFFT; 347 ; 348TVirtualFFT* TVirtualFFT::GetCurrentTransform(); 349{; 350 if (fgFFT); 351 return fgFFT;; 352 else{; 353 ::Warning(""TVirtualFFT::GetCurrentTransform"", ""fgFFT is not defined yet"");; 354 return nullptr;; 355 }; 356}; 357 ; 358////////////////////////////////////////////////////////////////////////////////; 359/// static: set the current t",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:12158,Modifiability,plugin,plugin,12158,"286 if (opt.Contains(""M"")) flag = ""M"";; 287 if (opt.Contains(""P"")) flag = ""P"";; 288 if (opt.Contains(""EX"")) flag = ""EX"";; 289 ; 290 if (!opt.Contains(""K"")) {; 291 if (fgFFT){; 292 Int_t ndiff = 0;; 293 if (fgFFT->GetNdim()!=ndim || strcmp(fgFFT->GetType(),""R2R"")!=0); 294 ndiff++;; 295 else {; 296 Int_t *ncurrent = fgFFT->GetN();; 297 for (Int_t i=0; i<ndim; i++) {; 298 if (n[i] != ncurrent[i]); 299 ndiff++;; 300 }; 301 ; 302 }; 303 if (ndiff>0) {; 304 delete fgFFT;; 305 fgFFT = nullptr;; 306 }; 307 }; 308 }; 309 TVirtualFFT *fft = nullptr;; 310 ; 311 R__LOCKGUARD(gROOTMutex);; 312 ; 313 if (!fgFFT || opt.Contains(""K"")) {; 314 TPluginHandler *h;; 315 TString pluginname;; 316 if (fgDefault.Length()==0) fgDefault=""fftw"";; 317 if (strcmp(fgDefault.Data(),""fftw"")==0) {; 318 pluginname = ""fftwr2r"";; 319 if ((h=gROOT->GetPluginManager()->FindHandler(""TVirtualFFT"", pluginname))) {; 320 if (h->LoadPlugin()==-1){; 321 ::Error(""TVirtualFFT::SineCosine"", ""handler not found"");; 322 return nullptr;; 323 }; 324 fft = (TVirtualFFT*)h->ExecPlugin(3, ndim, n, kFALSE);; 325 if (!fft) {; 326 ::Error(""TVirtualFFT::SineCosine"", ""plugin failed to create TVirtualFFT object"");; 327 return nullptr;; 328 }; 329 fft->Init(flag, 0, r2rkind);; 330 if (!opt.Contains(""K"")); 331 fgFFT = fft;; 332 return fft;; 333 } else {; 334 ::Error(""TVirtualFFT::SineCosine"", ""handler not found"");; 335 return nullptr;; 336 }; 337 }; 338 }; 339 ; 340 //if (fgFFT->GetTransformFlag()!=flag); 341 fgFFT->Init(flag,0, r2rkind);; 342 return fgFFT;; 343}; 344 ; 345////////////////////////////////////////////////////////////////////////////////; 346/// static: return current fgFFT; 347 ; 348TVirtualFFT* TVirtualFFT::GetCurrentTransform(); 349{; 350 if (fgFFT); 351 return fgFFT;; 352 else{; 353 ::Warning(""TVirtualFFT::GetCurrentTransform"", ""fgFFT is not defined yet"");; 354 return nullptr;; 355 }; 356}; 357 ; 358////////////////////////////////////////////////////////////////////////////////; 359/// static: set the current t",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:4817,Performance,perform,performance,4817,"//; 94///destructor; 95 ; 96TVirtualFFT::~TVirtualFFT(); 97{; 98 if (this==fgFFT); 99 fgFFT = nullptr;; 100}; 101 ; 102////////////////////////////////////////////////////////////////////////////////; 103///Returns a pointer to the FFT of requested size and type.; 104///; 105/// \param[in] ndim number of transform dimensions; 106/// \param[in] n sizes of each dimension (an array at least ndim long); 107/// \param [in] option consists of 3 parts - flag option and an option to create a new TVirtualFFT; 108/// 1. transform type option:; 109/// Available transform types are:; 110/// C2CForward, C2CBackward, C2R, R2C, R2HC, HC2R, DHT; 111/// see class description for details; 112/// 2. flag option: choosing how much time should be spent in planning the transform:; 113/// Possible options:; 114/// - ""ES"" (from ""estimate"") - no time in preparing the transform,; 115/// but probably sub-optimal performance; 116/// - ""M"" (from ""measure"") - some time spend in finding the optimal way; 117/// to do the transform; 118/// - ""P"" (from ""patient"") - more time spend in finding the optimal way; 119/// to do the transform; 120/// - ""EX"" (from ""exhaustive"") - the most optimal way is found; 121/// This option should be chosen depending on how many transforms of the; 122/// same size and type are going to be done.; 123/// Planning is only done once, for the first transform of this size and type.; 124/// 3. option allowing to choose between the global fgFFT and a new TVirtualFFT object; 125/// """" - default, changes and returns the global fgFFT variable; 126/// ""K"" (from ""keep"")- without touching the global fgFFT,; 127/// creates and returns a new TVirtualFFT*. User is then responsible for deleting it.; 128///; 129/// Examples of valid options: ""R2C ES K"", ""C2CF M"", ""DHT P K"", etc.; 130 ; 131TVirtualFFT* TVirtualFFT::FFT(Int_t ndim, Int_t *n, Option_t *option); 132{; 133 ; 134 Int_t inputtype=0, currenttype=0;; 135 TString opt = option;; 136 opt.ToUpper();; 137 //find the tranform flag; 138 ",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:9922,Performance,perform,performance,9922,"gFFT->GetTransformFlag()) || !opt.Contains(fgFFT->GetType())) {; 230 Int_t *kind = new Int_t[1];; 231 if (inputtype==1) {; 232 if (opt.Contains(""R2HC"")) kind[0] = 10;; 233 if (opt.Contains(""HC2R"")) kind[0] = 11;; 234 if (opt.Contains(""DHT"")) kind[0] = 12;; 235 }; 236 fgFFT->Init(flag, sign, kind);; 237 delete [] kind;; 238 }; 239 }; 240 return fgFFT;; 241}; 242 ; 243////////////////////////////////////////////////////////////////////////////////; 244///Returns a pointer to a sine or cosine transform of requested size and kind; 245///; 246///Parameters:; 247/// \param [in] ndim number of transform dimensions; 248/// \param [in] n sizes of each dimension (an array at least ndim long); 249/// \param [in] r2rkind transform kind for each dimension; 250/// 4 different kinds of sine and cosine transforms are available; 251/// - DCT-I - kind=0; 252/// - DCT-II - kind=1; 253/// - DCT-III - kind=2; 254/// - DCT-IV - kind=3; 255/// - DST-I - kind=4; 256/// - DST-II - kind=5; 257/// - DST-III - kind=6; 258/// - DST-IV - kind=7; 259/// \param [in] option : consists of 2 parts; 260/// - flag option and an option to create a new TVirtualFFT; 261/// - flag option: choosing how much time should be spent in planning the transform:; 262/// Possible options:; 263/// - ""ES"" (from ""estimate"") - no time in preparing the transform,; 264/// but probably sub-optimal performance; 265/// - ""M"" (from ""measure"") - some time spend in finding the optimal way; 266/// to do the transform; 267/// - ""P"" (from ""patient"") - more time spend in finding the optimal way; 268/// to do the transform; 269/// - ""EX"" (from ""exhaustive"") - the most optimal way is found; 270/// This option should be chosen depending on how many transforms of the; 271/// same size and type are going to be done.; 272/// Planning is only done once, for the first transform of this size and type.; 273/// - option allowing to choose between the global fgFFT and a new TVirtualFFT object; 274/// - """" - default, changes and returns the glo",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:1544,Safety,redund,redundant,1544,"nd Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TVirtualFFT; 13\ingroup Base; 14 ; 15TVirtualFFT is an interface class for Fast Fourier Transforms.; 16 ; 17The default FFT library is FFTW. To use it, FFTW3 library should already; 18be installed, and ROOT should be have fftw3 module enabled, with the directories; 19of fftw3 include file and library specified (see installation instructions).; 20Function SetDefaultFFT() allows to change the default library.; 21 ; 22## Available transform types:; 23FFT:; 24 - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); 25 in one or more dimensions, -1 in the exponent; 26 - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); 27 in one or more dimensions, +1 in the exponent; 28 - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); 29 in one or more dimensions,; 30 - ""C2R"" - inverse transforms to ""R2C"", taking complex input; 31 (storing the non-redundant half of a logically Hermitian array); 32 to real output; 33 - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; 34 i.e. real and imaginary parts for a transform of size n stored as; 35 r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; 36 - ""HC2R"" - computes the reverse of FFTW_R2HC, above; 37 - ""DHT"" - computes a discrete Hartley transform; 38 ; 39## Sine/cosine transforms:; 40Different types of transforms are specified by parameter kind of the SineCosine() static; 41function. 4 different kinds of sine and cosine transforms are available; 42 ; 43 - DCT-I (REDFT00 in FFTW3 notation)- kind=0; 44 - DCT-II (REDFT01 in FFTW3 notation)- kind=1; 45 - DCT-III(REDFT10 in FFTW3 notation)- kind=2; 46 - DCT-IV (REDFT11 in FFTW3 notation)- kind=3; 47 - DST-I (RODFT00 in FFTW3 notation)- kind=4; 48 - DST-",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:1564,Testability,log,logically,1564,"nd Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TVirtualFFT; 13\ingroup Base; 14 ; 15TVirtualFFT is an interface class for Fast Fourier Transforms.; 16 ; 17The default FFT library is FFTW. To use it, FFTW3 library should already; 18be installed, and ROOT should be have fftw3 module enabled, with the directories; 19of fftw3 include file and library specified (see installation instructions).; 20Function SetDefaultFFT() allows to change the default library.; 21 ; 22## Available transform types:; 23FFT:; 24 - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); 25 in one or more dimensions, -1 in the exponent; 26 - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); 27 in one or more dimensions, +1 in the exponent; 28 - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); 29 in one or more dimensions,; 30 - ""C2R"" - inverse transforms to ""R2C"", taking complex input; 31 (storing the non-redundant half of a logically Hermitian array); 32 to real output; 33 - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; 34 i.e. real and imaginary parts for a transform of size n stored as; 35 r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; 36 - ""HC2R"" - computes the reverse of FFTW_R2HC, above; 37 - ""DHT"" - computes a discrete Hartley transform; 38 ; 39## Sine/cosine transforms:; 40Different types of transforms are specified by parameter kind of the SineCosine() static; 41function. 4 different kinds of sine and cosine transforms are available; 42 ; 43 - DCT-I (REDFT00 in FFTW3 notation)- kind=0; 44 - DCT-II (REDFT01 in FFTW3 notation)- kind=1; 45 - DCT-III(REDFT10 in FFTW3 notation)- kind=2; 46 - DCT-IV (REDFT11 in FFTW3 notation)- kind=3; 47 - DST-I (RODFT00 in FFTW3 notation)- kind=4; 48 - DST-",MatchSource.WIKI,doc/master/TVirtualFFT_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html
https://root.cern/doc/master/TVirtualFFT_8h_source.html:1326,Availability,redundant,redundant,1326,". Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Anna Kreshuk 10/04/2006; 3 ; 4#ifndef ROOT_TVirtualFFT; 5#define ROOT_TVirtualFFT; 6 ; 7//////////////////////////////////////////////////////////////////////////; 8//; 9// TVirtualFFT; 10//; 11// TVirtualFFT is an interface class for Fast Fourier Transforms.; 12//; 13//; 14//; 15// The default FFT library is FFTW. To use it, FFTW3 library should already; 16// be installed, and ROOT should be have fftw3 module enabled, with the directories; 17// of fftw3 include file and library specified (see installation instructions).; 18// Function SetDefaultFFT() allows to change the default library.; 19//; 20// Available transform types:; 21// FFT:; 22// - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); 23// in one or more dimensions, -1 in the exponent; 24// - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); 25// in one or more dimensions, +1 in the exponent; 26// - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); 27// in one or more dimensions,; 28// - ""C2R"" - inverse transforms to ""R2C"", taking complex input; 29// (storing the non-redundant half of a logically Hermitian array); 30// to real output; 31// - ""R2HC"" - a real-input DFT with output in ""halfcomplex"" format,; 32// i.e. real and imaginary parts for a transform of size n stored as; 33// r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; 34// - ""HC2R"" - computes the reverse of FFTW_R2HC, above; 35// - ""DHT"" - computes a discrete Hartley transform; 36//; 37// Sine/cosine transforms:; 38// Different types of transforms are specified by parameter kind of the SineCosine() static; 39// function. 4 different kinds of sine and cosine transforms are available; 40// DCT-I (REDFT00 in FFTW3 notation)- kind=0; 41// DCT-II (REDFT10 in FFTW3 notation)- kind=1; 42// DCT-III(REDFT01 in FFTW3 notation)- kind=2; 43// DCT-IV (REDFT11 in FFTW3 notation)- kind=3; 44// DST-I (RODFT00 in FFTW3 notation",MatchSource.WIKI,doc/master/TVirtualFFT_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8h_source.html
https://root.cern/doc/master/TVirtualFFT_8h_source.html:1901,Availability,avail,available,1901,"ly Hermitian array); 30// to real output; 31// - ""R2HC"" - a real-input DFT with output in ""halfcomplex"" format,; 32// i.e. real and imaginary parts for a transform of size n stored as; 33// r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; 34// - ""HC2R"" - computes the reverse of FFTW_R2HC, above; 35// - ""DHT"" - computes a discrete Hartley transform; 36//; 37// Sine/cosine transforms:; 38// Different types of transforms are specified by parameter kind of the SineCosine() static; 39// function. 4 different kinds of sine and cosine transforms are available; 40// DCT-I (REDFT00 in FFTW3 notation)- kind=0; 41// DCT-II (REDFT10 in FFTW3 notation)- kind=1; 42// DCT-III(REDFT01 in FFTW3 notation)- kind=2; 43// DCT-IV (REDFT11 in FFTW3 notation)- kind=3; 44// DST-I (RODFT00 in FFTW3 notation)- kind=4; 45// DST-II (RODFT10 in FFTW3 notation)- kind=5; 46// DST-III(RODFT01 in FFTW3 notation)- kind=6; 47// DST-IV (RODFT11 in FFTW3 notation)- kind=7; 48// Formulas and detailed descriptions can be found in the chapter; 49// ""What FFTW really computes"" of the FFTW manual; 50//; 51// NOTE: FFTW computes unnormalized transforms, so doing a transform, followed by its; 52// inverse will give the original array, multiplied by normalization constant; 53// (transform size(N) for FFT, 2*(N-1) for DCT-I, 2*(N+1) for DST-I, 2*N for; 54// other sine/cosine transforms); 55//; 56// How to use it:; 57// Call to the static function FFT returns a pointer to a fast fourier transform; 58// with requested parameters. Call to the static function SineCosine returns a; 59// pointer to a sine or cosine transform with requested parameters. Example:; 60// {; 61// Int_t N = 10; Double_t *in = new Double_t[N];; 62// TVirtualFFT *fftr2c = TVirtualFFT::FFT(1, &N, ""R2C"");; 63// fftr2c->SetPoints(in);; 64// fftr2c->Transform();; 65// Double_t re, im;; 66// for (Int_t i=0; i<N; i++); 67// fftr2c->GetPointComplex(i, re, im);; 68// ...; 69// fftr2c->SetPoints(in2);; 70// ...; 71// fftr2c->SetPoints(in3);; 72// ...; 7",MatchSource.WIKI,doc/master/TVirtualFFT_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8h_source.html
https://root.cern/doc/master/TVirtualFFT_8h_source.html:585,Deployability,install,installed,585,". ROOT: core/base/inc/TVirtualFFT.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TVirtualFFT.h. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Anna Kreshuk 10/04/2006; 3 ; 4#ifndef ROOT_TVirtualFFT; 5#define ROOT_TVirtualFFT; 6 ; 7//////////////////////////////////////////////////////////////////////////; 8//; 9// TVirtualFFT; 10//; 11// TVirtualFFT is an interface class for Fast Fourier Transforms.; 12//; 13//; 14//; 15// The default FFT library is FFTW. To use it, FFTW3 library should already; 16// be installed, and ROOT should be have fftw3 module enabled, with the directories; 17// of fftw3 include file and library specified (see installation instructions).; 18// Function SetDefaultFFT() allows to change the default library.; 19//; 20// Available transform types:; 21// FFT:; 22// - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); 23// in one or more dimensions, -1 in the exponent; 24// - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); 25// in one or more dimensions, +1 in the exponent; 26// - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); 27// in one or more dimensions,; 28// - ""C2R"" - inverse transforms to ""R2C"", taking complex input; 29// (storing the non-redundant half of a logically Hermitian array); 30// to real output; 31// - ""R2HC"" - a real-input DFT with output in ""halfcomplex"" format,; 32// i.e. real and imaginary parts for a transform of size n stored as; 33// r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; 34// - ""HC2R"" - computes the reverse of FFTW_R2HC, above; 35// - ""DHT"" - computes a discrete Hartley transform; 36//; 37// Sine/cosine transforms:; 38// Different types of transforms are specified by parameter kind of the SineCosine() static; 39// function. 4 different kinds of sine and cosine transforms are available; 40// DCT-I (REDFT00 in FFTW3 notation)- kind=0; 41// DCT-II (REDFT10 in FFTW3 notation)- ",MatchSource.WIKI,doc/master/TVirtualFFT_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8h_source.html
https://root.cern/doc/master/TVirtualFFT_8h_source.html:718,Deployability,install,installation,718,". ROOT: core/base/inc/TVirtualFFT.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TVirtualFFT.h. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Anna Kreshuk 10/04/2006; 3 ; 4#ifndef ROOT_TVirtualFFT; 5#define ROOT_TVirtualFFT; 6 ; 7//////////////////////////////////////////////////////////////////////////; 8//; 9// TVirtualFFT; 10//; 11// TVirtualFFT is an interface class for Fast Fourier Transforms.; 12//; 13//; 14//; 15// The default FFT library is FFTW. To use it, FFTW3 library should already; 16// be installed, and ROOT should be have fftw3 module enabled, with the directories; 17// of fftw3 include file and library specified (see installation instructions).; 18// Function SetDefaultFFT() allows to change the default library.; 19//; 20// Available transform types:; 21// FFT:; 22// - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); 23// in one or more dimensions, -1 in the exponent; 24// - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); 25// in one or more dimensions, +1 in the exponent; 26// - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); 27// in one or more dimensions,; 28// - ""C2R"" - inverse transforms to ""R2C"", taking complex input; 29// (storing the non-redundant half of a logically Hermitian array); 30// to real output; 31// - ""R2HC"" - a real-input DFT with output in ""halfcomplex"" format,; 32// i.e. real and imaginary parts for a transform of size n stored as; 33// r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; 34// - ""HC2R"" - computes the reverse of FFTW_R2HC, above; 35// - ""DHT"" - computes a discrete Hartley transform; 36//; 37// Sine/cosine transforms:; 38// Different types of transforms are specified by parameter kind of the SineCosine() static; 39// function. 4 different kinds of sine and cosine transforms are available; 40// DCT-I (REDFT00 in FFTW3 notation)- kind=0; 41// DCT-II (REDFT10 in FFTW3 notation)- ",MatchSource.WIKI,doc/master/TVirtualFFT_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8h_source.html
https://root.cern/doc/master/TVirtualFFT_8h_source.html:434,Integrability,interface,interface,434,". ROOT: core/base/inc/TVirtualFFT.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TVirtualFFT.h. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Anna Kreshuk 10/04/2006; 3 ; 4#ifndef ROOT_TVirtualFFT; 5#define ROOT_TVirtualFFT; 6 ; 7//////////////////////////////////////////////////////////////////////////; 8//; 9// TVirtualFFT; 10//; 11// TVirtualFFT is an interface class for Fast Fourier Transforms.; 12//; 13//; 14//; 15// The default FFT library is FFTW. To use it, FFTW3 library should already; 16// be installed, and ROOT should be have fftw3 module enabled, with the directories; 17// of fftw3 include file and library specified (see installation instructions).; 18// Function SetDefaultFFT() allows to change the default library.; 19//; 20// Available transform types:; 21// FFT:; 22// - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); 23// in one or more dimensions, -1 in the exponent; 24// - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); 25// in one or more dimensions, +1 in the exponent; 26// - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); 27// in one or more dimensions,; 28// - ""C2R"" - inverse transforms to ""R2C"", taking complex input; 29// (storing the non-redundant half of a logically Hermitian array); 30// to real output; 31// - ""R2HC"" - a real-input DFT with output in ""halfcomplex"" format,; 32// i.e. real and imaginary parts for a transform of size n stored as; 33// r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; 34// - ""HC2R"" - computes the reverse of FFTW_R2HC, above; 35// - ""DHT"" - computes a discrete Hartley transform; 36//; 37// Sine/cosine transforms:; 38// Different types of transforms are specified by parameter kind of the SineCosine() static; 39// function. 4 different kinds of sine and cosine transforms are available; 40// DCT-I (REDFT00 in FFTW3 notation)- kind=0; 41// DCT-II (REDFT10 in FFTW3 notation)- ",MatchSource.WIKI,doc/master/TVirtualFFT_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8h_source.html
https://root.cern/doc/master/TVirtualFFT_8h_source.html:5780,Integrability,interface,interface,5780,"l Int_t *GetN() const = 0;; 100 ; 101 virtual Int_t GetNdim() const = 0;; 102 virtual Option_t *GetType() const = 0;; 103 virtual Int_t GetSign() const = 0;; 104 virtual Option_t *GetTransformFlag() const = 0;; 105 virtual void Init(Option_t *flag,Int_t sign, const Int_t *kind) = 0;; 106 virtual Bool_t IsInplace() const = 0;; 107 ; 108 virtual void GetPoints(Double_t *data, Bool_t fromInput = kFALSE) const = 0;; 109 virtual Double_t GetPointReal(Int_t ipoint, Bool_t fromInput = kFALSE) const = 0;; 110 virtual Double_t GetPointReal(const Int_t *ipoint, Bool_t fromInput = kFALSE) const = 0;; 111 virtual void GetPointComplex(Int_t ipoint, Double_t &re, Double_t &im, Bool_t fromInput=kFALSE) const = 0;; 112 virtual void GetPointComplex(const Int_t *ipoint, Double_t &re, Double_t &im, Bool_t fromInput=kFALSE) const = 0;; 113 virtual Double_t* GetPointsReal(Bool_t fromInput=kFALSE) const = 0;; 114 virtual void GetPointsComplex(Double_t *re, Double_t *im, Bool_t fromInput = kFALSE) const = 0;; 115 virtual void GetPointsComplex(Double_t *data, Bool_t fromInput = kFALSE) const = 0;; 116 ; 117 virtual void SetPoint(Int_t ipoint, Double_t re, Double_t im = 0) = 0;; 118 virtual void SetPoint(const Int_t *ipoint, Double_t re, Double_t im = 0) = 0;; 119 virtual void SetPoints(const Double_t *data) = 0;; 120 virtual void SetPointComplex(Int_t ipoint, TComplex &c) = 0;; 121 virtual void SetPointsComplex(const Double_t *re, const Double_t *im) =0;; 122 virtual void Transform() = 0;; 123 ; 124 static TVirtualFFT* FFT(Int_t ndim, Int_t *n, Option_t *option);; 125 static TVirtualFFT* SineCosine(Int_t ndim, Int_t *n, Int_t *r2rkind, Option_t *option);; 126 static TVirtualFFT* GetCurrentTransform();; 127 ; 128 static void SetTransform(TVirtualFFT *fft);; 129 static const char* GetDefaultFFT();; 130 static void SetDefaultFFT(const char *name ="""");; 131 ; 132 ClassDefOverride(TVirtualFFT, 0); //abstract interface for FFT calculations; 133};; 134 ; 135#endif; c#define c(i)Definition RSha256.",MatchSource.WIKI,doc/master/TVirtualFFT_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8h_source.html
https://root.cern/doc/master/TVirtualFFT_8h_source.html:6579,Integrability,interface,interface,6579,"8 static void SetTransform(TVirtualFFT *fft);; 129 static const char* GetDefaultFFT();; 130 static void SetDefaultFFT(const char *name ="""");; 131 ; 132 ClassDefOverride(TVirtualFFT, 0); //abstract interface for FFT calculations; 133};; 134 ; 135#endif; c#define c(i)Definition RSha256.hxx:101; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; namechar name[80]Definition TGX11.cxx:110; TObject.h; TString.h; TComplexDefinition TComplex.h:29; TObjectMother of all ROOT objects.Definition TObject.h:41; TStringBasic string class.Definition TString.h:139; TVirtualFFTTVirtualFFT is an interface class for Fast Fourier Transforms.Definition TVirtualFFT.h:88; TVirtualFFT::~TVirtualFFTvirtual ~TVirtualFFT()destructorDefinition TVirtualFFT.cxx:96; TVirtualFFT::SetDefaultFFTstatic void SetDefaultFFT(const char *name="""")static: set name of default fftDefinition TVirtualFFT.cxx:377; TVirtualFFT::SetTransformstatic void SetTransform(TVirtualFFT *fft)static: set the current transfrom to parameterDefinition TVirtualFFT.cxx:361; TVirtualFFT::IsInplacevirtual Bool_t IsInplace() const =0; TVirtualFFT::GetPointComplexvirtual void GetPointComplex(const Int_t *ipoint, Double_t &re, Double_t &im, Bool_t fromInput=kFALSE) const =0; TVirtualFFT::GetPointsvirtual void GetPoints(Double_t *data, Bool_t fromInput=kFALSE) const =0; TVirtualFFT::GetPointRealvirtual Double_t GetPointReal(const Int_t *ipoint, Bool_t fromInput=kFALSE) const =0; TVirtualFFT::Initvirtual void Init(Option_t *flag, Int_t sign, const Int_t *kind)=0; TVirtualFFT::FFTstatic TVirtualFFT * FFT(Int_t ndim, Int_t *n, Option_t",MatchSource.WIKI,doc/master/TVirtualFFT_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8h_source.html
https://root.cern/doc/master/TVirtualFFT_8h_source.html:1326,Safety,redund,redundant,1326,". Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Anna Kreshuk 10/04/2006; 3 ; 4#ifndef ROOT_TVirtualFFT; 5#define ROOT_TVirtualFFT; 6 ; 7//////////////////////////////////////////////////////////////////////////; 8//; 9// TVirtualFFT; 10//; 11// TVirtualFFT is an interface class for Fast Fourier Transforms.; 12//; 13//; 14//; 15// The default FFT library is FFTW. To use it, FFTW3 library should already; 16// be installed, and ROOT should be have fftw3 module enabled, with the directories; 17// of fftw3 include file and library specified (see installation instructions).; 18// Function SetDefaultFFT() allows to change the default library.; 19//; 20// Available transform types:; 21// FFT:; 22// - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); 23// in one or more dimensions, -1 in the exponent; 24// - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); 25// in one or more dimensions, +1 in the exponent; 26// - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); 27// in one or more dimensions,; 28// - ""C2R"" - inverse transforms to ""R2C"", taking complex input; 29// (storing the non-redundant half of a logically Hermitian array); 30// to real output; 31// - ""R2HC"" - a real-input DFT with output in ""halfcomplex"" format,; 32// i.e. real and imaginary parts for a transform of size n stored as; 33// r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; 34// - ""HC2R"" - computes the reverse of FFTW_R2HC, above; 35// - ""DHT"" - computes a discrete Hartley transform; 36//; 37// Sine/cosine transforms:; 38// Different types of transforms are specified by parameter kind of the SineCosine() static; 39// function. 4 different kinds of sine and cosine transforms are available; 40// DCT-I (REDFT00 in FFTW3 notation)- kind=0; 41// DCT-II (REDFT10 in FFTW3 notation)- kind=1; 42// DCT-III(REDFT01 in FFTW3 notation)- kind=2; 43// DCT-IV (REDFT11 in FFTW3 notation)- kind=3; 44// DST-I (RODFT00 in FFTW3 notation",MatchSource.WIKI,doc/master/TVirtualFFT_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8h_source.html
https://root.cern/doc/master/TVirtualFFT_8h_source.html:1346,Testability,log,logically,1346,". Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Anna Kreshuk 10/04/2006; 3 ; 4#ifndef ROOT_TVirtualFFT; 5#define ROOT_TVirtualFFT; 6 ; 7//////////////////////////////////////////////////////////////////////////; 8//; 9// TVirtualFFT; 10//; 11// TVirtualFFT is an interface class for Fast Fourier Transforms.; 12//; 13//; 14//; 15// The default FFT library is FFTW. To use it, FFTW3 library should already; 16// be installed, and ROOT should be have fftw3 module enabled, with the directories; 17// of fftw3 include file and library specified (see installation instructions).; 18// Function SetDefaultFFT() allows to change the default library.; 19//; 20// Available transform types:; 21// FFT:; 22// - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); 23// in one or more dimensions, -1 in the exponent; 24// - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); 25// in one or more dimensions, +1 in the exponent; 26// - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); 27// in one or more dimensions,; 28// - ""C2R"" - inverse transforms to ""R2C"", taking complex input; 29// (storing the non-redundant half of a logically Hermitian array); 30// to real output; 31// - ""R2HC"" - a real-input DFT with output in ""halfcomplex"" format,; 32// i.e. real and imaginary parts for a transform of size n stored as; 33// r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; 34// - ""HC2R"" - computes the reverse of FFTW_R2HC, above; 35// - ""DHT"" - computes a discrete Hartley transform; 36//; 37// Sine/cosine transforms:; 38// Different types of transforms are specified by parameter kind of the SineCosine() static; 39// function. 4 different kinds of sine and cosine transforms are available; 40// DCT-I (REDFT00 in FFTW3 notation)- kind=0; 41// DCT-II (REDFT10 in FFTW3 notation)- kind=1; 42// DCT-III(REDFT01 in FFTW3 notation)- kind=2; 43// DCT-IV (REDFT11 in FFTW3 notation)- kind=3; 44// DST-I (RODFT00 in FFTW3 notation",MatchSource.WIKI,doc/master/TVirtualFFT_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8h_source.html
https://root.cern/doc/master/TVirtualFitter_8cxx_source.html:10346,Availability,toler,tolerance,10346,"///////////////////////////////////; 294/// static: Set the maximum number of function calls for the minimization algorithm; 295/// For example for MIGRAD this is the maxcalls value passed as first argument; 296/// (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html ); 297 ; 298void TVirtualFitter::SetMaxIterations(Int_t niter); 299{; 300 ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls(niter);; 301}; 302 ; 303////////////////////////////////////////////////////////////////////////////////; 304/// static: Set the Error Definition (default=1); 305/// For Minuit this is the value passed with the ""SET ERR"" command; 306/// (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html); 307 ; 308void TVirtualFitter::SetErrorDef(Double_t errdef); 309{; 310// fgErrorDef = errdef;; 311 ROOT::Math::MinimizerOptions::SetDefaultErrorDef(errdef);; 312 if (!GetGlobalFitter()) return;; 313 Double_t arglist[1];; 314 arglist[0] = errdef;; 315 GetGlobalFitter()->ExecuteCommand(""SET ERRORDEF"", arglist, 1);; 316}; 317 ; 318////////////////////////////////////////////////////////////////////////////////; 319/// static: Set the tolerance used in the minimization algorithm; 320/// For example for MIGRAD this is tolerance value passed as second argument; 321/// (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html ); 322 ; 323void TVirtualFitter::SetPrecision(Double_t prec); 324{; 325 //fgPrecision = prec;; 326 ROOT::Math::MinimizerOptions::SetDefaultTolerance(prec);; 327}; MinimizerOptions.h; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; namechar name[80]Definition TGX11.cxx:110; TPluginManager.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TVirtualFitter.h; ThreadLocalStorage.h; ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCallsstatic void SetDefaultMaxFunctionCal",MatchSource.WIKI,doc/master/TVirtualFitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html
https://root.cern/doc/master/TVirtualFitter_8cxx_source.html:10430,Availability,toler,tolerance,10430,"///////////////////////////////////; 294/// static: Set the maximum number of function calls for the minimization algorithm; 295/// For example for MIGRAD this is the maxcalls value passed as first argument; 296/// (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html ); 297 ; 298void TVirtualFitter::SetMaxIterations(Int_t niter); 299{; 300 ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls(niter);; 301}; 302 ; 303////////////////////////////////////////////////////////////////////////////////; 304/// static: Set the Error Definition (default=1); 305/// For Minuit this is the value passed with the ""SET ERR"" command; 306/// (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html); 307 ; 308void TVirtualFitter::SetErrorDef(Double_t errdef); 309{; 310// fgErrorDef = errdef;; 311 ROOT::Math::MinimizerOptions::SetDefaultErrorDef(errdef);; 312 if (!GetGlobalFitter()) return;; 313 Double_t arglist[1];; 314 arglist[0] = errdef;; 315 GetGlobalFitter()->ExecuteCommand(""SET ERRORDEF"", arglist, 1);; 316}; 317 ; 318////////////////////////////////////////////////////////////////////////////////; 319/// static: Set the tolerance used in the minimization algorithm; 320/// For example for MIGRAD this is tolerance value passed as second argument; 321/// (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html ); 322 ; 323void TVirtualFitter::SetPrecision(Double_t prec); 324{; 325 //fgPrecision = prec;; 326 ROOT::Math::MinimizerOptions::SetDefaultTolerance(prec);; 327}; MinimizerOptions.h; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; namechar name[80]Definition TGX11.cxx:110; TPluginManager.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TVirtualFitter.h; ThreadLocalStorage.h; ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCallsstatic void SetDefaultMaxFunctionCal",MatchSource.WIKI,doc/master/TVirtualFitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html
https://root.cern/doc/master/TVirtualFitter_8cxx_source.html:11549,Availability,error,errors,11549," (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html ); 322 ; 323void TVirtualFitter::SetPrecision(Double_t prec); 324{; 325 //fgPrecision = prec;; 326 ROOT::Math::MinimizerOptions::SetDefaultTolerance(prec);; 327}; MinimizerOptions.h; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; namechar name[80]Definition TGX11.cxx:110; TPluginManager.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TVirtualFitter.h; ThreadLocalStorage.h; ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCallsstatic void SetDefaultMaxFunctionCalls(int maxcall)Set the maximum number of function calls.Definition MinimizerOptions.cxx:63; ROOT::Math::MinimizerOptions::DefaultTolerancestatic double DefaultTolerance()Definition MinimizerOptions.cxx:92; ROOT::Math::MinimizerOptions::SetDefaultErrorDefstatic void SetDefaultErrorDef(double up)Set the default level for computing the parameter errors.Definition MinimizerOptions.cxx:51; ROOT::Math::MinimizerOptions::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)Set the default Minimizer type and corresponding algorithms.Definition MinimizerOptions.cxx:43; ROOT::Math::MinimizerOptions::DefaultMinimizerTypestatic const std::string & DefaultMinimizerType()Definition MinimizerOptions.cxx:100; ROOT::Math::MinimizerOptions::DefaultMaxFunctionCallsstatic int DefaultMaxFunctionCalls()Definition MinimizerOptions.cxx:94; ROOT::Math::MinimizerOptions::SetDefaultTolerancestatic void SetDefaultTolerance(double tol)Set the Minimization tolerance.Definition MinimizerOptions.cxx:55; ROOT::Math::MinimizerOptions::DefaultErrorDefstatic double DefaultErrorDef()Definition MinimizerOptions.cxx:91; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:49",MatchSource.WIKI,doc/master/TVirtualFitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html
https://root.cern/doc/master/TVirtualFitter_8cxx_source.html:12186,Availability,toler,tolerance,12186,"zerOptions::SetDefaultMaxFunctionCallsstatic void SetDefaultMaxFunctionCalls(int maxcall)Set the maximum number of function calls.Definition MinimizerOptions.cxx:63; ROOT::Math::MinimizerOptions::DefaultTolerancestatic double DefaultTolerance()Definition MinimizerOptions.cxx:92; ROOT::Math::MinimizerOptions::SetDefaultErrorDefstatic void SetDefaultErrorDef(double up)Set the default level for computing the parameter errors.Definition MinimizerOptions.cxx:51; ROOT::Math::MinimizerOptions::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)Set the default Minimizer type and corresponding algorithms.Definition MinimizerOptions.cxx:43; ROOT::Math::MinimizerOptions::DefaultMinimizerTypestatic const std::string & DefaultMinimizerType()Definition MinimizerOptions.cxx:100; ROOT::Math::MinimizerOptions::DefaultMaxFunctionCallsstatic int DefaultMaxFunctionCalls()Definition MinimizerOptions.cxx:94; ROOT::Math::MinimizerOptions::SetDefaultTolerancestatic void SetDefaultTolerance(double tol)Set the Minimization tolerance.Definition MinimizerOptions.cxx:55; ROOT::Math::MinimizerOptions::DefaultErrorDefstatic double DefaultErrorDef()Definition MinimizerOptions.cxx:91; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TObjectMother of all ROOT objects.Definition TObject.h:41; TPluginHandlerDefinition TPluginManager.h:103; TStringBasic string class.Definition TString.h:139; TVirtualFitterAbstract Base Class for Fitting.Definition TVirtualFitter.h:29; TVirtualFitter::fOptionFoption_t fOptionStruct with the fit options.Definition TVirtualFitter.h:32; TVirtualFitter::SetDefaultFitterstatic void SetDefaultFitter(const char *name="""")static: set name of default fitte",MatchSource.WIKI,doc/master/TVirtualFitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html
https://root.cern/doc/master/TVirtualFitter_8cxx_source.html:13255,Availability,toler,tolerance,13255,"izerOptions::DefaultErrorDefstatic double DefaultErrorDef()Definition MinimizerOptions.cxx:91; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TObjectMother of all ROOT objects.Definition TObject.h:41; TPluginHandlerDefinition TPluginManager.h:103; TStringBasic string class.Definition TString.h:139; TVirtualFitterAbstract Base Class for Fitting.Definition TVirtualFitter.h:29; TVirtualFitter::fOptionFoption_t fOptionStruct with the fit options.Definition TVirtualFitter.h:32; TVirtualFitter::SetDefaultFitterstatic void SetDefaultFitter(const char *name="""")static: set name of default fitterDefinition TVirtualFitter.cxx:245; TVirtualFitter::SetPrecisionstatic void SetPrecision(Double_t prec=1e-6)static: Set the tolerance used in the minimization algorithm For example for MIGRAD this is tolerance...Definition TVirtualFitter.cxx:323; TVirtualFitter::fPointSizeInt_t fPointSizeNumber of words per point in the cache.Definition TVirtualFitter.h:40; TVirtualFitter::GetConfidenceIntervalsvirtual void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t *x, Double_t *ci, Double_t cl=0.95)return confidence intervals in array x of dimension ndim implemented in TFitter and TLinearFitterDefinition TVirtualFitter.cxx:185; TVirtualFitter::fUserFuncTObject * fUserFuncPointer to user theoretical function (a TF1*)Definition TVirtualFitter.h:44; TVirtualFitter::fMethodCallTMethodCall * fMethodCallPointer to MethodCall in case of interpreted function.Definition TVirtualFitter.h:45; TVirtualFitter::GetMaxIterationsstatic Int_t GetMaxIterations()static: Return the maximum number of iterations actually max number of function callsDefinition TVirtualFitter.cxx:218; TVirtualFitter::GetPrecisionstatic Doubl",MatchSource.WIKI,doc/master/TVirtualFitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html
https://root.cern/doc/master/TVirtualFitter_8cxx_source.html:13331,Availability,toler,tolerance,13331,"izerOptions::DefaultErrorDefstatic double DefaultErrorDef()Definition MinimizerOptions.cxx:91; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TObjectMother of all ROOT objects.Definition TObject.h:41; TPluginHandlerDefinition TPluginManager.h:103; TStringBasic string class.Definition TString.h:139; TVirtualFitterAbstract Base Class for Fitting.Definition TVirtualFitter.h:29; TVirtualFitter::fOptionFoption_t fOptionStruct with the fit options.Definition TVirtualFitter.h:32; TVirtualFitter::SetDefaultFitterstatic void SetDefaultFitter(const char *name="""")static: set name of default fitterDefinition TVirtualFitter.cxx:245; TVirtualFitter::SetPrecisionstatic void SetPrecision(Double_t prec=1e-6)static: Set the tolerance used in the minimization algorithm For example for MIGRAD this is tolerance...Definition TVirtualFitter.cxx:323; TVirtualFitter::fPointSizeInt_t fPointSizeNumber of words per point in the cache.Definition TVirtualFitter.h:40; TVirtualFitter::GetConfidenceIntervalsvirtual void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t *x, Double_t *ci, Double_t cl=0.95)return confidence intervals in array x of dimension ndim implemented in TFitter and TLinearFitterDefinition TVirtualFitter.cxx:185; TVirtualFitter::fUserFuncTObject * fUserFuncPointer to user theoretical function (a TF1*)Definition TVirtualFitter.h:44; TVirtualFitter::fMethodCallTMethodCall * fMethodCallPointer to MethodCall in case of interpreted function.Definition TVirtualFitter.h:45; TVirtualFitter::GetMaxIterationsstatic Int_t GetMaxIterations()static: Return the maximum number of iterations actually max number of function callsDefinition TVirtualFitter.cxx:218; TVirtualFitter::GetPrecisionstatic Doubl",MatchSource.WIKI,doc/master/TVirtualFitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html
https://root.cern/doc/master/TVirtualFitter_8cxx_source.html:8537,Performance,cache,cache,8537,"////////////////////////////////////////////////////; 225/// static: Return the Error Definition; 226 ; 227Double_t TVirtualFitter::GetErrorDef(); 228{; 229// return fgErrorDef;; 230 return ROOT::Math::MinimizerOptions::DefaultErrorDef();; 231}; 232 ; 233////////////////////////////////////////////////////////////////////////////////; 234/// static: Return the fit relative precision; 235 ; 236Double_t TVirtualFitter::GetPrecision(); 237{; 238 //return fgPrecision;; 239 return ROOT::Math::MinimizerOptions::DefaultTolerance();; 240}; 241 ; 242////////////////////////////////////////////////////////////////////////////////; 243/// static: set name of default fitter; 244 ; 245void TVirtualFitter::SetDefaultFitter(const char *name); 246{; 247 ROOT::Math::MinimizerOptions::SetDefaultMinimizer(name,"""");; 248 if (GetGlobalDefault() == name) return;; 249 delete GetGlobalFitter();; 250 GetGlobalFitter() = nullptr;; 251 GetGlobalDefault() = name;; 252}; 253 ; 254////////////////////////////////////////////////////////////////////////////////; 255/// Static function to set an alternative fitter; 256 ; 257void TVirtualFitter::SetFitter(TVirtualFitter *fitter, Int_t maxpar); 258{; 259 GetGlobalFitter() = fitter;; 260 GetGlobalMaxPar() = maxpar;; 261}; 262 ; 263////////////////////////////////////////////////////////////////////////////////; 264/// To set the address of the minimization objective function; 265/// called by the native compiler (see function below when called by CINT); 266 ; 267void TVirtualFitter::SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); 268{; 269 fFCN = fcn;; 270}; 271 ; 272////////////////////////////////////////////////////////////////////////////////; 273/// Initialize the cache array; 274/// npoints is the number of points to be stored (or already stored) in the cache; 275/// psize is the number of elements per point; 276///; 277/// if (npoints*psize > fCacheSize) the existing cache is deleted; 278/// and a new array is created.",MatchSource.WIKI,doc/master/TVirtualFitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html
https://root.cern/doc/master/TVirtualFitter_8cxx_source.html:8629,Performance,cache,cache,8629,"////////////////////////////////////////////////////; 225/// static: Return the Error Definition; 226 ; 227Double_t TVirtualFitter::GetErrorDef(); 228{; 229// return fgErrorDef;; 230 return ROOT::Math::MinimizerOptions::DefaultErrorDef();; 231}; 232 ; 233////////////////////////////////////////////////////////////////////////////////; 234/// static: Return the fit relative precision; 235 ; 236Double_t TVirtualFitter::GetPrecision(); 237{; 238 //return fgPrecision;; 239 return ROOT::Math::MinimizerOptions::DefaultTolerance();; 240}; 241 ; 242////////////////////////////////////////////////////////////////////////////////; 243/// static: set name of default fitter; 244 ; 245void TVirtualFitter::SetDefaultFitter(const char *name); 246{; 247 ROOT::Math::MinimizerOptions::SetDefaultMinimizer(name,"""");; 248 if (GetGlobalDefault() == name) return;; 249 delete GetGlobalFitter();; 250 GetGlobalFitter() = nullptr;; 251 GetGlobalDefault() = name;; 252}; 253 ; 254////////////////////////////////////////////////////////////////////////////////; 255/// Static function to set an alternative fitter; 256 ; 257void TVirtualFitter::SetFitter(TVirtualFitter *fitter, Int_t maxpar); 258{; 259 GetGlobalFitter() = fitter;; 260 GetGlobalMaxPar() = maxpar;; 261}; 262 ; 263////////////////////////////////////////////////////////////////////////////////; 264/// To set the address of the minimization objective function; 265/// called by the native compiler (see function below when called by CINT); 266 ; 267void TVirtualFitter::SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); 268{; 269 fFCN = fcn;; 270}; 271 ; 272////////////////////////////////////////////////////////////////////////////////; 273/// Initialize the cache array; 274/// npoints is the number of points to be stored (or already stored) in the cache; 275/// psize is the number of elements per point; 276///; 277/// if (npoints*psize > fCacheSize) the existing cache is deleted; 278/// and a new array is created.",MatchSource.WIKI,doc/master/TVirtualFitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html
https://root.cern/doc/master/TVirtualFitter_8cxx_source.html:8746,Performance,cache,cache,8746,"////////////////////////////////////////////////////; 225/// static: Return the Error Definition; 226 ; 227Double_t TVirtualFitter::GetErrorDef(); 228{; 229// return fgErrorDef;; 230 return ROOT::Math::MinimizerOptions::DefaultErrorDef();; 231}; 232 ; 233////////////////////////////////////////////////////////////////////////////////; 234/// static: Return the fit relative precision; 235 ; 236Double_t TVirtualFitter::GetPrecision(); 237{; 238 //return fgPrecision;; 239 return ROOT::Math::MinimizerOptions::DefaultTolerance();; 240}; 241 ; 242////////////////////////////////////////////////////////////////////////////////; 243/// static: set name of default fitter; 244 ; 245void TVirtualFitter::SetDefaultFitter(const char *name); 246{; 247 ROOT::Math::MinimizerOptions::SetDefaultMinimizer(name,"""");; 248 if (GetGlobalDefault() == name) return;; 249 delete GetGlobalFitter();; 250 GetGlobalFitter() = nullptr;; 251 GetGlobalDefault() = name;; 252}; 253 ; 254////////////////////////////////////////////////////////////////////////////////; 255/// Static function to set an alternative fitter; 256 ; 257void TVirtualFitter::SetFitter(TVirtualFitter *fitter, Int_t maxpar); 258{; 259 GetGlobalFitter() = fitter;; 260 GetGlobalMaxPar() = maxpar;; 261}; 262 ; 263////////////////////////////////////////////////////////////////////////////////; 264/// To set the address of the minimization objective function; 265/// called by the native compiler (see function below when called by CINT); 266 ; 267void TVirtualFitter::SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); 268{; 269 fFCN = fcn;; 270}; 271 ; 272////////////////////////////////////////////////////////////////////////////////; 273/// Initialize the cache array; 274/// npoints is the number of points to be stored (or already stored) in the cache; 275/// psize is the number of elements per point; 276///; 277/// if (npoints*psize > fCacheSize) the existing cache is deleted; 278/// and a new array is created.",MatchSource.WIKI,doc/master/TVirtualFitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html
https://root.cern/doc/master/TVirtualFitter_8cxx_source.html:8845,Performance,cache,cache,8845,"/////////////////////////; 264/// To set the address of the minimization objective function; 265/// called by the native compiler (see function below when called by CINT); 266 ; 267void TVirtualFitter::SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t)); 268{; 269 fFCN = fcn;; 270}; 271 ; 272////////////////////////////////////////////////////////////////////////////////; 273/// Initialize the cache array; 274/// npoints is the number of points to be stored (or already stored) in the cache; 275/// psize is the number of elements per point; 276///; 277/// if (npoints*psize > fCacheSize) the existing cache is deleted; 278/// and a new array is created.; 279/// The function returns a pointer to the cache; 280 ; 281Double_t *TVirtualFitter::SetCache(Int_t npoints, Int_t psize); 282{; 283 if (npoints*psize > fCacheSize) {; 284 delete [] fCache;; 285 fCacheSize = npoints*psize;; 286 fCache = new Double_t[fCacheSize];; 287 }; 288 fNpoints = npoints;; 289 fPointSize = psize;; 290 return fCache;; 291}; 292 ; 293////////////////////////////////////////////////////////////////////////////////; 294/// static: Set the maximum number of function calls for the minimization algorithm; 295/// For example for MIGRAD this is the maxcalls value passed as first argument; 296/// (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html ); 297 ; 298void TVirtualFitter::SetMaxIterations(Int_t niter); 299{; 300 ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls(niter);; 301}; 302 ; 303////////////////////////////////////////////////////////////////////////////////; 304/// static: Set the Error Definition (default=1); 305/// For Minuit this is the value passed with the ""SET ERR"" command; 306/// (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html); 307 ; 308void TVirtualFitter::SetErrorDef(Double_t errdef); 309{; 310// fgErrorDef = errdef;; 311 ROOT::Math::MinimizerOptions::SetDefaultErrorDef(errdef);; 312 if (!GetGlobalFitter()) return;; 313 Double_t ",MatchSource.WIKI,doc/master/TVirtualFitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html
https://root.cern/doc/master/TVirtualFitter_8cxx_source.html:13453,Performance,cache,cache,13453,"stReturns the integer value for a resource.Definition TEnv.cxx:491; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::operator=TNamed & operator=(const TNamed &rhs)TNamed assignment operator.Definition TNamed.cxx:51; TObjectMother of all ROOT objects.Definition TObject.h:41; TPluginHandlerDefinition TPluginManager.h:103; TStringBasic string class.Definition TString.h:139; TVirtualFitterAbstract Base Class for Fitting.Definition TVirtualFitter.h:29; TVirtualFitter::fOptionFoption_t fOptionStruct with the fit options.Definition TVirtualFitter.h:32; TVirtualFitter::SetDefaultFitterstatic void SetDefaultFitter(const char *name="""")static: set name of default fitterDefinition TVirtualFitter.cxx:245; TVirtualFitter::SetPrecisionstatic void SetPrecision(Double_t prec=1e-6)static: Set the tolerance used in the minimization algorithm For example for MIGRAD this is tolerance...Definition TVirtualFitter.cxx:323; TVirtualFitter::fPointSizeInt_t fPointSizeNumber of words per point in the cache.Definition TVirtualFitter.h:40; TVirtualFitter::GetConfidenceIntervalsvirtual void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t *x, Double_t *ci, Double_t cl=0.95)return confidence intervals in array x of dimension ndim implemented in TFitter and TLinearFitterDefinition TVirtualFitter.cxx:185; TVirtualFitter::fUserFuncTObject * fUserFuncPointer to user theoretical function (a TF1*)Definition TVirtualFitter.h:44; TVirtualFitter::fMethodCallTMethodCall * fMethodCallPointer to MethodCall in case of interpreted function.Definition TVirtualFitter.h:45; TVirtualFitter::GetMaxIterationsstatic Int_t GetMaxIterations()static: Return the maximum number of iterations actually max number of function callsDefinition TVirtualFitter.cxx:218; TVirtualFitter::GetPrecisionstatic Double_t GetPrecision()static: Return the fit relative precisionDefinition TVirtualFitter.cxx:236; TVirtualFitter::fYlastInt_t fYlastLast bin on Y axis.Definition TVirtu",MatchSource.WIKI,doc/master/TVirtualFitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html
https://root.cern/doc/master/TVirtualFitter_8cxx_source.html:14784,Performance,cache,cache,14784,"itter::fUserFuncTObject * fUserFuncPointer to user theoretical function (a TF1*)Definition TVirtualFitter.h:44; TVirtualFitter::fMethodCallTMethodCall * fMethodCallPointer to MethodCall in case of interpreted function.Definition TVirtualFitter.h:45; TVirtualFitter::GetMaxIterationsstatic Int_t GetMaxIterations()static: Return the maximum number of iterations actually max number of function callsDefinition TVirtualFitter.cxx:218; TVirtualFitter::GetPrecisionstatic Double_t GetPrecision()static: Return the fit relative precisionDefinition TVirtualFitter.cxx:236; TVirtualFitter::fYlastInt_t fYlastLast bin on Y axis.Definition TVirtualFitter.h:36; TVirtualFitter::fXfirstInt_t fXfirstFirst bin on X axis.Definition TVirtualFitter.h:33; TVirtualFitter::fZfirstInt_t fZfirstFirst bin on Z axis.Definition TVirtualFitter.h:37; TVirtualFitter::fXlastInt_t fXlastLast bin on X axis.Definition TVirtualFitter.h:34; TVirtualFitter::SetCachevirtual Double_t * SetCache(Int_t npoints, Int_t psize)Initialize the cache array npoints is the number of points to be stored (or already stored) in the ca...Definition TVirtualFitter.cxx:281; TVirtualFitter::SetFCNvirtual void SetFCN(void(*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, Int_t))To set the address of the minimization objective function called by the native compiler (see function...Definition TVirtualFitter.cxx:267; TVirtualFitter::TVirtualFitterTVirtualFitter()Default constructor.Definition TVirtualFitter.cxx:72; TVirtualFitter::GetDefaultFitterstatic const char * GetDefaultFitter()static: return the name of the default fitterDefinition TVirtualFitter.cxx:200; TVirtualFitter::fCacheDouble_t * fCache[fCacheSize] Array of points data (fNpoints*fPointSize < fCacheSize words)Definition TVirtualFitter.h:42; TVirtualFitter::SetMaxIterationsstatic void SetMaxIterations(Int_t niter=5000)static: Set the maximum number of function calls for the minimization algorithm For example for MIGRA...Definition TVirtualFitter.cxx:298; TVirtualFitte",MatchSource.WIKI,doc/master/TVirtualFitter_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html
https://root.cern/doc/master/TVirtualFitter_8h.html:256,Integrability,depend,dependency,256,". ROOT: hist/hist/inc/TVirtualFitter.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes ; TVirtualFitter.h File Reference. #include ""TNamed.h""; #include ""TMethodCall.h""; #include ""Foption.h"". Include dependency graph for TVirtualFitter.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TVirtualFitter;  Abstract Base Class for Fitting. More...;  . histhistincTVirtualFitter.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TVirtualFitter_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualFitter_8h.html
https://root.cern/doc/master/TVirtualIndex_8h_source.html:829,Integrability,interface,interface,829,". ROOT: tree/tree/inc/TVirtualIndex.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TVirtualIndex.h. Go to the documentation of this file. 1// @(#)root/tree:$Id$; 2// Author: Rene Brun 05/07/2004; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TVirtualIndex; 13#define ROOT_TVirtualIndex; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TVirtualIndex //; 19// //; 20// Abstract interface for Tree Index //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24 ; 25#include ""TNamed.h""; 26 ; 27class TTree;; 28class TTreeFormula;; 29 ; 30class TVirtualIndex : public TNamed {; 31 ; 32protected:; 33 TTree *fTree; //! pointer to Tree; 34 ; 35public:; 36 TVirtualIndex();; 37 ~TVirtualIndex() override;; 38 virtual void Append(const TVirtualIndex *,bool delaySort = false) = 0;; 39 virtual Long64_t GetEntryNumberFriend(const TTree * /*parent*/) = 0;; 40 virtual Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const = 0;; 41 virtual Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const = 0;; 42 virtual const char *GetMajorName() const = 0;; 43 virtual const char *GetMinorName() const = 0;; 44 virtual bool IsValidFor(const TTree *parent) = 0;; 45 virtual Long64_t GetN() const = 0;; 46 virtual TTree *GetTree() const {return fTree;}; 47 virtual void UpdateFormulaLeaves(const TTree *parent) = 0;; 48 virtual void SetTree(TTree *T) = 0;; 49 ; 50 ClassDefOverride(TVirtualIndex,1); //Abstract interface for Tree Index; 51};; 52 ; 53#endif; 54 ; Long64_tlong long Long64_tD",MatchSource.WIKI,doc/master/TVirtualIndex_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualIndex_8h_source.html
https://root.cern/doc/master/TVirtualIndex_8h_source.html:1922,Integrability,interface,interface,1922,"ontributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TVirtualIndex; 13#define ROOT_TVirtualIndex; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TVirtualIndex //; 19// //; 20// Abstract interface for Tree Index //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24 ; 25#include ""TNamed.h""; 26 ; 27class TTree;; 28class TTreeFormula;; 29 ; 30class TVirtualIndex : public TNamed {; 31 ; 32protected:; 33 TTree *fTree; //! pointer to Tree; 34 ; 35public:; 36 TVirtualIndex();; 37 ~TVirtualIndex() override;; 38 virtual void Append(const TVirtualIndex *,bool delaySort = false) = 0;; 39 virtual Long64_t GetEntryNumberFriend(const TTree * /*parent*/) = 0;; 40 virtual Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const = 0;; 41 virtual Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const = 0;; 42 virtual const char *GetMajorName() const = 0;; 43 virtual const char *GetMinorName() const = 0;; 44 virtual bool IsValidFor(const TTree *parent) = 0;; 45 virtual Long64_t GetN() const = 0;; 46 virtual TTree *GetTree() const {return fTree;}; 47 virtual void UpdateFormulaLeaves(const TTree *parent) = 0;; 48 virtual void SetTree(TTree *T) = 0;; 49 ; 50 ClassDefOverride(TVirtualIndex,1); //Abstract interface for Tree Index; 51};; 52 ; 53#endif; 54 ; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TNamed.h; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TTreeFormulaUsed to pass a selection expression to the Tree drawing routine.Definition TTreeFormula.h:58; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TVirtualIndexAbstract interface for Tree Index.Definition TVirtualIndex.h:30; TVirtualIndex::UpdateFormulaLeavesvirtual v",MatchSource.WIKI,doc/master/TVirtualIndex_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualIndex_8h_source.html
https://root.cern/doc/master/TVirtualIndex_8h_source.html:2273,Integrability,rout,routine,2273,"ol delaySort = false) = 0;; 39 virtual Long64_t GetEntryNumberFriend(const TTree * /*parent*/) = 0;; 40 virtual Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const = 0;; 41 virtual Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const = 0;; 42 virtual const char *GetMajorName() const = 0;; 43 virtual const char *GetMinorName() const = 0;; 44 virtual bool IsValidFor(const TTree *parent) = 0;; 45 virtual Long64_t GetN() const = 0;; 46 virtual TTree *GetTree() const {return fTree;}; 47 virtual void UpdateFormulaLeaves(const TTree *parent) = 0;; 48 virtual void SetTree(TTree *T) = 0;; 49 ; 50 ClassDefOverride(TVirtualIndex,1); //Abstract interface for Tree Index; 51};; 52 ; 53#endif; 54 ; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TNamed.h; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TTreeFormulaUsed to pass a selection expression to the Tree drawing routine.Definition TTreeFormula.h:58; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TVirtualIndexAbstract interface for Tree Index.Definition TVirtualIndex.h:30; TVirtualIndex::UpdateFormulaLeavesvirtual void UpdateFormulaLeaves(const TTree *parent)=0; TVirtualIndex::GetMajorNamevirtual const char * GetMajorName() const =0; TVirtualIndex::GetEntryNumberWithIndexvirtual Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const =0; TVirtualIndex::TVirtualIndexTVirtualIndex()pointer to TreeDefinition TVirtualIndex.cxx:25; TVirtualIndex::~TVirtualIndex~TVirtualIndex() overrideDefinition TVirtualIndex.cxx:32; TVirtualIndex::GetEntryNumberFriendvirtual Long64_t GetEntryNumberFriend(const TTree *)=0; TVirtualIndex::GetTreevirtual TTree * GetTree() constDefinition TVirtualIndex.h:46; TVirtualIndex::Appendvirtual void Append(const TVirtualIndex *, bool delaySort=false)=0; TVirtualIndex::GetMinorNamevirtual const char * GetMinorNa",MatchSource.WIKI,doc/master/TVirtualIndex_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualIndex_8h_source.html
https://root.cern/doc/master/TVirtualIndex_8h_source.html:2399,Integrability,interface,interface,2399,"or, Long64_t minor) const = 0;; 41 virtual Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const = 0;; 42 virtual const char *GetMajorName() const = 0;; 43 virtual const char *GetMinorName() const = 0;; 44 virtual bool IsValidFor(const TTree *parent) = 0;; 45 virtual Long64_t GetN() const = 0;; 46 virtual TTree *GetTree() const {return fTree;}; 47 virtual void UpdateFormulaLeaves(const TTree *parent) = 0;; 48 virtual void SetTree(TTree *T) = 0;; 49 ; 50 ClassDefOverride(TVirtualIndex,1); //Abstract interface for Tree Index; 51};; 52 ; 53#endif; 54 ; Long64_tlong long Long64_tDefinition RtypesCore.h:69; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TNamed.h; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TTreeFormulaUsed to pass a selection expression to the Tree drawing routine.Definition TTreeFormula.h:58; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TVirtualIndexAbstract interface for Tree Index.Definition TVirtualIndex.h:30; TVirtualIndex::UpdateFormulaLeavesvirtual void UpdateFormulaLeaves(const TTree *parent)=0; TVirtualIndex::GetMajorNamevirtual const char * GetMajorName() const =0; TVirtualIndex::GetEntryNumberWithIndexvirtual Long64_t GetEntryNumberWithIndex(Long64_t major, Long64_t minor) const =0; TVirtualIndex::TVirtualIndexTVirtualIndex()pointer to TreeDefinition TVirtualIndex.cxx:25; TVirtualIndex::~TVirtualIndex~TVirtualIndex() overrideDefinition TVirtualIndex.cxx:32; TVirtualIndex::GetEntryNumberFriendvirtual Long64_t GetEntryNumberFriend(const TTree *)=0; TVirtualIndex::GetTreevirtual TTree * GetTree() constDefinition TVirtualIndex.h:46; TVirtualIndex::Appendvirtual void Append(const TVirtualIndex *, bool delaySort=false)=0; TVirtualIndex::GetMinorNamevirtual const char * GetMinorName() const =0; TVirtualIndex::SetTreevirtual void SetTree(TTree *T)=0; TVirtualIndex::GetNvirtual Long64_t GetN() const =0; TVirtualIndex::IsValidForvirtual b",MatchSource.WIKI,doc/master/TVirtualIndex_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualIndex_8h_source.html
https://root.cern/doc/master/TVirtualObject_8h_source.html:797,Security,access,access,797,". ROOT: core/meta/inc/TVirtualObject.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TVirtualObject.h. Go to the documentation of this file. 1// @(#)root/io:$Id$; 2// Author: Philippe Canal July, 2008; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TVirtualObject; 13#define ROOT_TVirtualObject; 14 ; 15/**; 16\class TVirtualObject; 17\ingroup IO; 18 ; 19Wrapper around an object and giving indirect access to its content; 20even if the object is not of a class in the Cint/Reflex dictionary.; 21*/; 22 ; 23#include ""TClassRef.h""; 24 ; 25 ; 26class TVirtualObject {; 27private:; 28 ; 29 TVirtualObject(const TVirtualObject&) = delete;; 30 TVirtualObject &operator=(const TVirtualObject&) = delete;; 31 ; 32public:; 33 TClassRef fClass;; 34 void *fObject;; 35 ; 36 TVirtualObject(TClass *cl) : fClass(cl), fObject(cl ? cl->New() : nullptr) { }; 37 ~TVirtualObject() { if (fClass) fClass->Destructor(fObject); }; 38 ; 39 ; 40 TClass *GetClass() const { return fClass; }; 41 void *GetObject() const { return fObject; }; 42 ; 43};; 44 ; 45#endif // ROOT_TVirtualObject; TClassRef.h; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TVirtualObjectWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualObject.h:26; TVirtualObject::fObj",MatchSource.WIKI,doc/master/TVirtualObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualObject_8h_source.html
https://root.cern/doc/master/TVirtualObject_8h_source.html:1890,Security,access,access,1890," 18 ; 19Wrapper around an object and giving indirect access to its content; 20even if the object is not of a class in the Cint/Reflex dictionary.; 21*/; 22 ; 23#include ""TClassRef.h""; 24 ; 25 ; 26class TVirtualObject {; 27private:; 28 ; 29 TVirtualObject(const TVirtualObject&) = delete;; 30 TVirtualObject &operator=(const TVirtualObject&) = delete;; 31 ; 32public:; 33 TClassRef fClass;; 34 void *fObject;; 35 ; 36 TVirtualObject(TClass *cl) : fClass(cl), fObject(cl ? cl->New() : nullptr) { }; 37 ~TVirtualObject() { if (fClass) fClass->Destructor(fObject); }; 38 ; 39 ; 40 TClass *GetClass() const { return fClass; }; 41 void *GetObject() const { return fObject; }; 42 ; 43};; 44 ; 45#endif // ROOT_TVirtualObject; TClassRef.h; TClassRefTClassRef is used to implement a permanent reference to a TClass object.Definition TClassRef.h:28; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Destructorvoid Destructor(void *obj, Bool_t dtorOnly=kFALSE)Explicitly call destructor for object.Definition TClass.cxx:5467; TVirtualObjectWrapper around an object and giving indirect access to its content even if the object is not of a cla...Definition TVirtualObject.h:26; TVirtualObject::fObjectvoid * fObjectDefinition TVirtualObject.h:34; TVirtualObject::GetObjectvoid * GetObject() constDefinition TVirtualObject.h:41; TVirtualObject::fClassTClassRef fClassDefinition TVirtualObject.h:33; TVirtualObject::TVirtualObjectTVirtualObject(TClass *cl)Definition TVirtualObject.h:36; TVirtualObject::GetClassTClass * GetClass() constDefinition TVirtualObject.h:40; TVirtualObject::~TVirtualObject~TVirtualObject()Definition TVirtualObject.h:37; TVirtualObject::TVirtualObjectTVirtualObject(const TVirtualObject &)=delete; TVirtualObject::operator=TVirtualObject & operator=(const TVirtualObject &)=delete. coremetaincTVirtualObject.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:10 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TVirtualObject_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualObject_8h_source.html
https://root.cern/doc/master/TVirtualPad_8h.html:384,Integrability,depend,dependency,384,". ROOT: core/base/inc/TVirtualPad.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Macros |; Variables ; TVirtualPad.h File Reference. #include ""TObject.h""; #include ""TAttLine.h""; #include ""TAttFill.h""; #include ""TAttPad.h""; #include ""TQObject.h""; #include ""GuiTypes.h""; #include ""TString.h""; #include ""Buttons.h"". Include dependency graph for TVirtualPad.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; class  TVirtualPad::TContext;  small helper class to store/restore gPad context in TPad methods More...;  ; class  TPickerStackGuard;  ; class  TVirtualPad;  TVirtualPad is an abstract base class for the Pad and Canvas classes. More...;  . Macros; #define gPad   (TVirtualPad::Pad());  . Variables; R__EXTERN Int_t(* gThreadXAR )(const char *xact, Int_t nb, void **ar, Int_t *iret);  . Macro Definition Documentation. ◆ gPad. #define gPad   (TVirtualPad::Pad()). Definition at line 308 of file TVirtualPad.h. Variable Documentation. ◆ gThreadXAR. R__EXTERN Int_t(* gThreadXAR) (const char *xact, Int_t nb, void **ar, Int_t *iret) ; (; const char * ; xact, . Int_t ; nb, . void ** ; ar, . Int_t * ; iret . ). Definition at line 309 of file TVirtualPad.h. corebaseincTVirtualPad.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:13 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/TVirtualPad_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualPad_8h.html
https://root.cern/doc/master/TVirtualPad_8h_source.html:21592,Usability,clear,cleared,21592,".Definition TQObject.h:48; TQObject::Emitvoid Emit(const char *signal, const T &arg)Activate signal with single parameter.Definition TQObject.h:164; TStringBasic string class.Definition TString.h:139; TViewSee TView3D.Definition TView.h:25; TVirtualPadPainterTo make it possible to use GL for 2D graphic in a TPad/TCanvas.Definition TVirtualPadPainter.h:19; TVirtualPad::TContextsmall helper class to store/restore gPad context in TPad methodsDefinition TVirtualPad.h:61; TVirtualPad::TContext::GetSavedauto GetSaved() constDefinition TVirtualPad.h:69; TVirtualPad::TContext::fInteractiveBool_t fInteractiveDefinition TVirtualPad.h:62; TVirtualPad::TContext::~TContext~TContext()Destructor Restores previous value of gPad.Definition TVirtualPad.cxx:61; TVirtualPad::TContext::IsInteractiveauto IsInteractive() constDefinition TVirtualPad.h:68; TVirtualPad::TContext::fSavedTVirtualPad * fSavedDefinition TVirtualPad.h:63; TVirtualPad::TContext::PadDeletedvoid PadDeleted(TVirtualPad *pad)Inform context that pad deleted or will be deleted soon Reference on that pad should be cleared.Definition TVirtualPad.cxx:73; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::PaintFillAreaNDCvirtual void PaintFillAreaNDC(Int_t n, Double_t *x, Double_t *y, Option_t *option="""")=0; TVirtualPad::Modifiedvirtual void Modified(Bool_t flag=1)=0; TVirtualPad::PadInHighlightModevirtual Bool_t PadInHighlightMode() constShould always return false, unless you can highlight selected object in pad.Definition TVirtualPad.cxx:156; TVirtualPad::SetTickxvirtual void SetTickx(Int_t value=1)=0; TVirtualPad::SetAttMarkerPSvirtual void SetAttMarkerPS(Color_t color, Style_t style, Size_t msize)=0; TVirtualPad::Clipvirtual Int_t Clip(Double_t *x, Double_t *y, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt)=0; TVirtualPad::SetGridvirtual void SetGrid(Int_t valuex=1, Int_t valuey=1)=0; TVirtualPad::CloseToolTipvirtual void CloseTo",MatchSource.WIKI,doc/master/TVirtualPad_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualPad_8h_source.html
https://root.cern/doc/master/TVirtualRWMutex_8h_source.html:940,Availability,avail,available,940,". ROOT: core/base/inc/TVirtualRWMutex.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TVirtualRWMutex.h. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Philippe Canal, 2017; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2017, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TVirtualRWMutex; 13#define ROOT_TVirtualRWMutex; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TVirtualRWMutex //; 19// //; 20// This class implements a read-write mutex interface. The actual work //; 21// is done via TRWSpinLock which is available as soon as the thread //; 22// library is loaded. //; 23// //; 24//////////////////////////////////////////////////////////////////////////; 25 ; 26#include ""TVirtualMutex.h""; 27 ; 28#include <memory>; 29 ; 30namespace ROOT {; 31 ; 32class TVirtualRWMutex;; 33 ; 34// Global mutex set in TThread::Init; 35// Use either R__READ_LOCKGUARD(ROOT::gCoreMutex);; 36// or R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 37R__EXTERN TVirtualRWMutex *gCoreMutex;; 38 ; 39class TVirtualRWMutex : public TVirtualMutex {; 40 ; 41public:; 42 // The following are opaque type and are never really declared; 43 // The specific implementation of TInterpreter will cast the; 44 // value of pointer to this types to the correct type (possibly; 45 // distinct from these); 46 class Hint_t;; 47 ; 48 /// \class State; 49 /// Earlier lock state as returned by `GetState()` that can be passed to; 50 /// `Restore()`; 51 struct State {; 52 virtual ~State(); // implemented in TVirtualMutex.cxx; 53 };; 54 ; 55 struct StateAndRecurseCount {; 56 /// State of gCoreMutex when the first ",MatchSource.WIKI,doc/master/TVirtualRWMutex_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualRWMutex_8h_source.html
https://root.cern/doc/master/TVirtualRWMutex_8h_source.html:871,Integrability,interface,interface,871,". ROOT: core/base/inc/TVirtualRWMutex.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TVirtualRWMutex.h. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Philippe Canal, 2017; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2017, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TVirtualRWMutex; 13#define ROOT_TVirtualRWMutex; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TVirtualRWMutex //; 19// //; 20// This class implements a read-write mutex interface. The actual work //; 21// is done via TRWSpinLock which is available as soon as the thread //; 22// library is loaded. //; 23// //; 24//////////////////////////////////////////////////////////////////////////; 25 ; 26#include ""TVirtualMutex.h""; 27 ; 28#include <memory>; 29 ; 30namespace ROOT {; 31 ; 32class TVirtualRWMutex;; 33 ; 34// Global mutex set in TThread::Init; 35// Use either R__READ_LOCKGUARD(ROOT::gCoreMutex);; 36// or R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 37R__EXTERN TVirtualRWMutex *gCoreMutex;; 38 ; 39class TVirtualRWMutex : public TVirtualMutex {; 40 ; 41public:; 42 // The following are opaque type and are never really declared; 43 // The specific implementation of TInterpreter will cast the; 44 // value of pointer to this types to the correct type (possibly; 45 // distinct from these); 46 class Hint_t;; 47 ; 48 /// \class State; 49 /// Earlier lock state as returned by `GetState()` that can be passed to; 50 /// `Restore()`; 51 struct State {; 52 virtual ~State(); // implemented in TVirtualMutex.cxx; 53 };; 54 ; 55 struct StateAndRecurseCount {; 56 /// State of gCoreMutex when the first ",MatchSource.WIKI,doc/master/TVirtualRWMutex_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualRWMutex_8h_source.html
https://root.cern/doc/master/TVirtualRWMutex_8h_source.html:8497,Integrability,interface,interface,8497,"l Hint_t * ReadLock()=0; ROOT::TVirtualRWMutex::GetStateBeforevirtual std::unique_ptr< State > GetStateBefore()=0; ROOT::TVirtualRWMutex::TryLockInt_t TryLock() overrideDefinition TVirtualRWMutex.h:80; ROOT::TVirtualRWMutex::WriteUnLockvirtual void WriteUnLock(Hint_t *)=0; ROOT::TVirtualRWMutex::LockInt_t Lock() overrideDefinition TVirtualRWMutex.h:79; ROOT::TWriteLockGuardDefinition TVirtualRWMutex.h:131; ROOT::TWriteLockGuard::TWriteLockGuardTWriteLockGuard(TVirtualRWMutex *mutex)Definition TVirtualRWMutex.h:141; ROOT::TWriteLockGuard::operator=TWriteLockGuard & operator=(const TWriteLockGuard &)=delete; ROOT::TWriteLockGuard::fMutexTVirtualRWMutex *const fMutexDefinition TVirtualRWMutex.h:134; ROOT::TWriteLockGuard::TWriteLockGuardTWriteLockGuard(const TWriteLockGuard &)=delete; ROOT::TWriteLockGuard::fHintTVirtualRWMutex::Hint_t * fHintDefinition TVirtualRWMutex.h:135; ROOT::TWriteLockGuard::~TWriteLockGuard~TWriteLockGuard()Definition TVirtualRWMutex.h:145; TVirtualMutexThis class implements a mutex interface.Definition TVirtualMutex.h:32; bool; int; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::gCoreMutexR__EXTERN TVirtualRWMutex * gCoreMutexDefinition TVirtualRWMutex.h:37; ROOT::TVirtualRWMutex::StateAndRecurseCountDefinition TVirtualRWMutex.h:55; ROOT::TVirtualRWMutex::StateAndRecurseCount::fStatestd::unique_ptr< ROOT::TVirtualRWMutex::State > fStateState of gCoreMutex when the first interpreter-related function was invoked.Definition TVirtualRWMutex.h:57; ROOT::TVirtualRWMutex::StateAndRecurseCount::fRecurseCountInt_t fRecurseCountInterpreter-related functions will push the ""entry"" lock state to *this.Definition TVirtualRWMutex.h:62; ROOT::TVirtualRWMutex::StateDeltaState as returned by GetStateDelta() that can be passed to Restore()Definition TVirtualRWMutex.h:70; ROOT::TVirtualRWMutex::StateDelta::~StateDeltavirtual ~StateDelta(); ROOT::TVirtualRWMutex::",MatchSource.WIKI,doc/master/TVirtualRWMutex_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualRWMutex_8h_source.html
https://root.cern/doc/master/TVirtualRWMutex_8h_source.html:992,Performance,load,loaded,992,". ROOT: core/base/inc/TVirtualRWMutex.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. TVirtualRWMutex.h. Go to the documentation of this file. 1// @(#)root/base:$Id$; 2// Author: Philippe Canal, 2017; 3 ; 4/*************************************************************************; 5 * Copyright (C) 1995-2017, Rene Brun and Fons Rademakers. *; 6 * All rights reserved. *; 7 * *; 8 * For the licensing terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12#ifndef ROOT_TVirtualRWMutex; 13#define ROOT_TVirtualRWMutex; 14 ; 15 ; 16//////////////////////////////////////////////////////////////////////////; 17// //; 18// TVirtualRWMutex //; 19// //; 20// This class implements a read-write mutex interface. The actual work //; 21// is done via TRWSpinLock which is available as soon as the thread //; 22// library is loaded. //; 23// //; 24//////////////////////////////////////////////////////////////////////////; 25 ; 26#include ""TVirtualMutex.h""; 27 ; 28#include <memory>; 29 ; 30namespace ROOT {; 31 ; 32class TVirtualRWMutex;; 33 ; 34// Global mutex set in TThread::Init; 35// Use either R__READ_LOCKGUARD(ROOT::gCoreMutex);; 36// or R__WRITE_LOCKGUARD(ROOT::gCoreMutex);; 37R__EXTERN TVirtualRWMutex *gCoreMutex;; 38 ; 39class TVirtualRWMutex : public TVirtualMutex {; 40 ; 41public:; 42 // The following are opaque type and are never really declared; 43 // The specific implementation of TInterpreter will cast the; 44 // value of pointer to this types to the correct type (possibly; 45 // distinct from these); 46 class Hint_t;; 47 ; 48 /// \class State; 49 /// Earlier lock state as returned by `GetState()` that can be passed to; 50 /// `Restore()`; 51 struct State {; 52 virtual ~State(); // implemented in TVirtualMutex.cxx; 53 };; 54 ; 55 struct StateAndRecurseCount {; 56 /// State of gCoreMutex when the first ",MatchSource.WIKI,doc/master/TVirtualRWMutex_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualRWMutex_8h_source.html
https://root.cern/doc/master/TVirtualRWMutex_8h_source.html:3619,Safety,safe,safe,3619,"ter-related functions will push the ""entry"" lock state to *this.; 60 /// Recursive calls will do that, too - but we must only forget about the lock; 61 /// state once this recursion count went to 0.; 62 Int_t fRecurseCount = 0;; 63 ; 64 operator bool() const { return (bool)fState; }; 65 };; 66 ; 67 /// \class StateDelta; 68 /// State as returned by `GetStateDelta()` that can be passed to; 69 /// `Restore()`; 70 struct StateDelta {; 71 virtual ~StateDelta(); // implemented in TVirtualMutex.cxx; 72 };; 73 ; 74 virtual Hint_t *ReadLock() = 0;; 75 virtual void ReadUnLock(Hint_t *) = 0;; 76 virtual Hint_t *WriteLock() = 0;; 77 virtual void WriteUnLock(Hint_t *) = 0;; 78 ; 79 Int_t Lock() override { WriteLock(); return 1; }; 80 Int_t TryLock() override { WriteLock(); return 1; }; 81 Int_t UnLock() override { WriteUnLock(nullptr); return 1; }; 82 Int_t CleanUp() override { WriteUnLock(nullptr); return 1; }; 83 ; 84 virtual std::unique_ptr<State> GetStateBefore() = 0;; 85 virtual std::unique_ptr<StateDelta> Rewind(const State& earlierState) = 0;; 86 virtual void Apply(std::unique_ptr<StateDelta> &&delta) = 0;; 87 ; 88 TVirtualRWMutex *Factory(Bool_t /*recursive*/ = kFALSE) override = 0;; 89 ; 90 ClassDefOverride(TVirtualRWMutex, 0) // Virtual mutex lock class; 91};; 92 ; 93//////////////////////////////////////////////////////////////////////////; 94// //; 95// TReadLockGuard //; 96// //; 97// This class provides RW mutex resource management in a guaranteed and //; 98// exception safe way. Use like this: //; 99// { //; 100// TReadLockGuard guard(mutex); //; 101// ... // read something //; 102// } //; 103// where mutex is a pointer to a TMutex object. //; 104// When guard goes out of scope the mutex is unlocked in the TLockGuard //; 105// destructor. The exception mechanism takes care of calling the dtors //; 106// of local objects so it is exception safe. //; 107// In contrast to std::lock_guard, TLockGuard constructor expects a //; 108// pointer, not the mutex object itsel",MatchSource.WIKI,doc/master/TVirtualRWMutex_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualRWMutex_8h_source.html
https://root.cern/doc/master/TVirtualRWMutex_8h_source.html:3996,Safety,safe,safe,3996,"(nullptr); return 1; }; 82 Int_t CleanUp() override { WriteUnLock(nullptr); return 1; }; 83 ; 84 virtual std::unique_ptr<State> GetStateBefore() = 0;; 85 virtual std::unique_ptr<StateDelta> Rewind(const State& earlierState) = 0;; 86 virtual void Apply(std::unique_ptr<StateDelta> &&delta) = 0;; 87 ; 88 TVirtualRWMutex *Factory(Bool_t /*recursive*/ = kFALSE) override = 0;; 89 ; 90 ClassDefOverride(TVirtualRWMutex, 0) // Virtual mutex lock class; 91};; 92 ; 93//////////////////////////////////////////////////////////////////////////; 94// //; 95// TReadLockGuard //; 96// //; 97// This class provides RW mutex resource management in a guaranteed and //; 98// exception safe way. Use like this: //; 99// { //; 100// TReadLockGuard guard(mutex); //; 101// ... // read something //; 102// } //; 103// where mutex is a pointer to a TMutex object. //; 104// When guard goes out of scope the mutex is unlocked in the TLockGuard //; 105// destructor. The exception mechanism takes care of calling the dtors //; 106// of local objects so it is exception safe. //; 107// In contrast to std::lock_guard, TLockGuard constructor expects a //; 108// pointer, not the mutex object itself. //; 109// //; 110//////////////////////////////////////////////////////////////////////////; 111 ; 112class TReadLockGuard {; 113 ; 114private:; 115 TVirtualRWMutex *const fMutex;; 116 TVirtualRWMutex::Hint_t *fHint;; 117 ; 118 TReadLockGuard(const TReadLockGuard&) = delete;; 119 TReadLockGuard& operator=(const TReadLockGuard&) = delete;; 120 ; 121public:; 122 TReadLockGuard(TVirtualRWMutex *mutex) : fMutex(mutex), fHint(nullptr) {; 123 if (fMutex) fHint = fMutex->ReadLock();; 124 }; 125 ; 126 ~TReadLockGuard() { if (fMutex) fMutex->ReadUnLock(fHint); }; 127 ; 128 ClassDefNV(TReadLockGuard,0) // Exception safe read locking/unlocking of mutex; 129};; 130 ; 131class TWriteLockGuard {; 132 ; 133private:; 134 TVirtualRWMutex *const fMutex;; 135 TVirtualRWMutex::Hint_t *fHint;; 136 ; 137 TWriteLockGuard(const TWrite",MatchSource.WIKI,doc/master/TVirtualRWMutex_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualRWMutex_8h_source.html
https://root.cern/doc/master/TVirtualRWMutex_8h_source.html:4738,Safety,safe,safe,4738,"utex is a pointer to a TMutex object. //; 104// When guard goes out of scope the mutex is unlocked in the TLockGuard //; 105// destructor. The exception mechanism takes care of calling the dtors //; 106// of local objects so it is exception safe. //; 107// In contrast to std::lock_guard, TLockGuard constructor expects a //; 108// pointer, not the mutex object itself. //; 109// //; 110//////////////////////////////////////////////////////////////////////////; 111 ; 112class TReadLockGuard {; 113 ; 114private:; 115 TVirtualRWMutex *const fMutex;; 116 TVirtualRWMutex::Hint_t *fHint;; 117 ; 118 TReadLockGuard(const TReadLockGuard&) = delete;; 119 TReadLockGuard& operator=(const TReadLockGuard&) = delete;; 120 ; 121public:; 122 TReadLockGuard(TVirtualRWMutex *mutex) : fMutex(mutex), fHint(nullptr) {; 123 if (fMutex) fHint = fMutex->ReadLock();; 124 }; 125 ; 126 ~TReadLockGuard() { if (fMutex) fMutex->ReadUnLock(fHint); }; 127 ; 128 ClassDefNV(TReadLockGuard,0) // Exception safe read locking/unlocking of mutex; 129};; 130 ; 131class TWriteLockGuard {; 132 ; 133private:; 134 TVirtualRWMutex *const fMutex;; 135 TVirtualRWMutex::Hint_t *fHint;; 136 ; 137 TWriteLockGuard(const TWriteLockGuard&) = delete;; 138 TWriteLockGuard& operator=(const TWriteLockGuard&) = delete;; 139 ; 140public:; 141 TWriteLockGuard(TVirtualRWMutex *mutex) : fMutex(mutex), fHint(nullptr) {; 142 if (fMutex) fHint = fMutex->WriteLock();; 143 }; 144 ; 145 ~TWriteLockGuard() { if (fMutex) fMutex->WriteUnLock(fHint); }; 146 ; 147 ClassDefNV(TWriteLockGuard,0) // Exception safe read locking/unlocking of mutex; 148};; 149 ; 150} // namespace ROOT.; 151 ; 152// Use with a trailing semicolon and pass a pointer as argument, e.g.:; 153// TMutex m; R__READ_LOCKGUARD(&m);; 154#define R__READ_LOCKGUARD(mutex) ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(mutex); 155#define R__READ_LOCKGUARD_NAMED(name,mutex) ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(mutex); 156 ; 157#define R__WRITE_LOCKGUARD(mutex) ::ROO",MatchSource.WIKI,doc/master/TVirtualRWMutex_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualRWMutex_8h_source.html
https://root.cern/doc/master/TVirtualRWMutex_8h_source.html:5313,Safety,safe,safe,5313,"utex is a pointer to a TMutex object. //; 104// When guard goes out of scope the mutex is unlocked in the TLockGuard //; 105// destructor. The exception mechanism takes care of calling the dtors //; 106// of local objects so it is exception safe. //; 107// In contrast to std::lock_guard, TLockGuard constructor expects a //; 108// pointer, not the mutex object itself. //; 109// //; 110//////////////////////////////////////////////////////////////////////////; 111 ; 112class TReadLockGuard {; 113 ; 114private:; 115 TVirtualRWMutex *const fMutex;; 116 TVirtualRWMutex::Hint_t *fHint;; 117 ; 118 TReadLockGuard(const TReadLockGuard&) = delete;; 119 TReadLockGuard& operator=(const TReadLockGuard&) = delete;; 120 ; 121public:; 122 TReadLockGuard(TVirtualRWMutex *mutex) : fMutex(mutex), fHint(nullptr) {; 123 if (fMutex) fHint = fMutex->ReadLock();; 124 }; 125 ; 126 ~TReadLockGuard() { if (fMutex) fMutex->ReadUnLock(fHint); }; 127 ; 128 ClassDefNV(TReadLockGuard,0) // Exception safe read locking/unlocking of mutex; 129};; 130 ; 131class TWriteLockGuard {; 132 ; 133private:; 134 TVirtualRWMutex *const fMutex;; 135 TVirtualRWMutex::Hint_t *fHint;; 136 ; 137 TWriteLockGuard(const TWriteLockGuard&) = delete;; 138 TWriteLockGuard& operator=(const TWriteLockGuard&) = delete;; 139 ; 140public:; 141 TWriteLockGuard(TVirtualRWMutex *mutex) : fMutex(mutex), fHint(nullptr) {; 142 if (fMutex) fHint = fMutex->WriteLock();; 143 }; 144 ; 145 ~TWriteLockGuard() { if (fMutex) fMutex->WriteUnLock(fHint); }; 146 ; 147 ClassDefNV(TWriteLockGuard,0) // Exception safe read locking/unlocking of mutex; 148};; 149 ; 150} // namespace ROOT.; 151 ; 152// Use with a trailing semicolon and pass a pointer as argument, e.g.:; 153// TMutex m; R__READ_LOCKGUARD(&m);; 154#define R__READ_LOCKGUARD(mutex) ::ROOT::TReadLockGuard _R__UNIQUE_(R__readguard)(mutex); 155#define R__READ_LOCKGUARD_NAMED(name,mutex) ::ROOT::TReadLockGuard _NAME2_(R__readguard,name)(mutex); 156 ; 157#define R__WRITE_LOCKGUARD(mutex) ::ROO",MatchSource.WIKI,doc/master/TVirtualRWMutex_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TVirtualRWMutex_8h_source.html
https://root.cern/doc/master/TwoHistoFit2D_8C.html:2337,Availability,error,errors,2337,"821e+00 3.32869e-02 2.39024e-04 2.42669e-02; 5 p4 2.94271e+00 2.42010e-02 -1.88552e-04 2.78529e-03; 6 p5 2.63145e+01 2.69272e-01 -2.31447e-03 -2.60063e-03; 7 p6 1.19850e+01 3.51596e-02 4.24094e-04 -3.93616e-02; 8 p7 2.90086e+00 2.64547e-02 8.06260e-05 -5.19624e-03; 9 p8 1.09762e+01 1.47334e-02 -6.74372e-05 -1.09627e-02; 10 p9 1.95760e+00 1.14466e-02 2.85422e-05 -1.15591e-01; Chi2 Fit = 4015.63 ndf = 3921 3921; (int) 0; ; #include ""TH2D.h""; #include ""TF2.h""; #include ""TCanvas.h""; #include ""TStyle.h""; #include ""TRandom3.h""; #include ""TVirtualFitter.h""; #include ""TList.h""; ; #include <vector>; #include <map>; #include <iostream>; ; double gauss2D(double *x, double *par) {; double z1 = double((x[0]-par[1])/par[2]);; double z2 = double((x[1]-par[3])/par[4]);; return par[0]*exp(-0.5*(z1*z1+z2*z2));; }; double my2Dfunc(double *x, double *par) {; double *p1 = &par[0];; double *p2 = &par[5];; return gauss2D(x,p1) + gauss2D(x,p2);; }; ; ; ; // data need to be globals to be visible by fcn; ; std::vector<std::pair<double, double> > coords;; std::vector<double > values;; std::vector<double > errors;; ; void myFcn(int & /*nPar*/, double * /*grad*/ , double &fval, double *p, int /*iflag */ ); {; int n = coords.size();; double chi2 = 0;; double tmp,x[2];; for (int i = 0; i <n; ++i ) {; x[0] = coords[i].first;; x[1] = coords[i].second;; tmp = ( values[i] - my2Dfunc(x,p))/errors[i];; chi2 += tmp*tmp;; }; fval = chi2;; }; TRandom3 rndm;; void FillHisto(TH2D * h, int n, double * p) {; ; ; const double mx1 = p[1];; const double my1 = p[3];; const double sx1 = p[2];; const double sy1 = p[4];; const double mx2 = p[6];; const double my2 = p[8];; const double sx2 = p[7];; const double sy2 = p[9];; //const double w1 = p[0]*sx1*sy1/(p[5]*sx2*sy2);; const double w1 = 0.5;; ; double x, y;; for (int i = 0; i < n; ++i) {; // generate randoms with larger Gaussians; rndm.Rannor(x,y);; ; double r = rndm.Rndm(1);; if (r < w1) {; x = x*sx1 + mx1;; y = y*sy1 + my1;; }; else {; x = x*sx2 + mx2;; y = y*sy",MatchSource.WIKI,doc/master/TwoHistoFit2D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TwoHistoFit2D_8C.html
https://root.cern/doc/master/TwoHistoFit2D_8C.html:2618,Availability,error,errors,2618,".h""; #include ""TList.h""; ; #include <vector>; #include <map>; #include <iostream>; ; double gauss2D(double *x, double *par) {; double z1 = double((x[0]-par[1])/par[2]);; double z2 = double((x[1]-par[3])/par[4]);; return par[0]*exp(-0.5*(z1*z1+z2*z2));; }; double my2Dfunc(double *x, double *par) {; double *p1 = &par[0];; double *p2 = &par[5];; return gauss2D(x,p1) + gauss2D(x,p2);; }; ; ; ; // data need to be globals to be visible by fcn; ; std::vector<std::pair<double, double> > coords;; std::vector<double > values;; std::vector<double > errors;; ; void myFcn(int & /*nPar*/, double * /*grad*/ , double &fval, double *p, int /*iflag */ ); {; int n = coords.size();; double chi2 = 0;; double tmp,x[2];; for (int i = 0; i <n; ++i ) {; x[0] = coords[i].first;; x[1] = coords[i].second;; tmp = ( values[i] - my2Dfunc(x,p))/errors[i];; chi2 += tmp*tmp;; }; fval = chi2;; }; TRandom3 rndm;; void FillHisto(TH2D * h, int n, double * p) {; ; ; const double mx1 = p[1];; const double my1 = p[3];; const double sx1 = p[2];; const double sy1 = p[4];; const double mx2 = p[6];; const double my2 = p[8];; const double sx2 = p[7];; const double sy2 = p[9];; //const double w1 = p[0]*sx1*sy1/(p[5]*sx2*sy2);; const double w1 = 0.5;; ; double x, y;; for (int i = 0; i < n; ++i) {; // generate randoms with larger Gaussians; rndm.Rannor(x,y);; ; double r = rndm.Rndm(1);; if (r < w1) {; x = x*sx1 + mx1;; y = y*sy1 + my1;; }; else {; x = x*sx2 + mx2;; y = y*sy2 + my2;; }; h->Fill(x,y);; ; }; }; ; ; ; ; int TwoHistoFit2D(bool global = true) {; ; // create two histograms; ; int nbx1 = 50;; int nby1 = 50;; int nbx2 = 50;; int nby2 = 50;; double xlow1 = 0.;; double ylow1 = 0.;; double xup1 = 10.;; double yup1 = 10.;; double xlow2 = 5.;; double ylow2 = 5.;; double xup2 = 20.;; double yup2 = 20.;; ; TH2D * h1 = new TH2D(""h1"",""core"",nbx1,xlow1,xup1,nby1,ylow1,yup1);; TH2D * h2 = new TH2D(""h2"",""tails"",nbx2,xlow2,xup2,nby2,ylow2,yup2);; ; double iniParams[10] = { 100, 6., 2., 7., 3, 100, 12., 3., 11., 2. };; /",MatchSource.WIKI,doc/master/TwoHistoFit2D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TwoHistoFit2D_8C.html
https://root.cern/doc/master/TwoHistoFit2D_8C.html:4556,Availability,error,errors,4556," // create fit function; TF2 * func = new TF2(""func"",my2Dfunc,xlow2,xup2,ylow2,yup2, 10);; func->SetParameters(iniParams);; ; // fill Histos; int n1 = 50000;; int n2 = 50000;; // h1->FillRandom(""func"", n1);; //h2->FillRandom(""func"",n2);; FillHisto(h1,n1,iniParams);; FillHisto(h2,n2,iniParams);; ; // scale histograms to same heights (for fitting); double dx1 = (xup1-xlow1)/double(nbx1);; double dy1 = (yup1-ylow1)/double(nby1);; double dx2 = (xup2-xlow2)/double(nbx2);; double dy2 = (yup2-ylow2)/double(nby2);; // h1->Sumw2();; // h1->Scale( 1.0 / ( n1 * dx1 * dy1 ) );; // scale histo 2 to scale of 1; h2->Sumw2();; h2->Scale( ( double(n1) * dx1 * dy1 ) / ( double(n2) * dx2 * dy2 ) );; ; ; if (global) {; // fill data structure for fit (coordinates + values + errors); std::cout << ""Do global fit"" << std::endl;; // fit now all the function together; ; // fill data structure for fit (coordinates + values + errors); TAxis *xaxis1 = h1->GetXaxis();; TAxis *yaxis1 = h1->GetYaxis();; TAxis *xaxis2 = h2->GetXaxis();; TAxis *yaxis2 = h2->GetYaxis();; ; int nbinX1 = h1->GetNbinsX();; int nbinY1 = h1->GetNbinsY();; int nbinX2 = h2->GetNbinsX();; int nbinY2 = h2->GetNbinsY();; ; /// reset data structure; coords = std::vector<std::pair<double,double> >();; values = std::vector<double>();; errors = std::vector<double>();; ; ; for (int ix = 1; ix <= nbinX1; ++ix) {; for (int iy = 1; iy <= nbinY1; ++iy) {; if ( h1->GetBinContent(ix,iy) > 0 ) {; coords.push_back( std::make_pair(xaxis1->GetBinCenter(ix), yaxis1->GetBinCenter(iy) ) );; values.push_back( h1->GetBinContent(ix,iy) );; errors.push_back( h1->GetBinError(ix,iy) );; }; }; }; for (int ix = 1; ix <= nbinX2; ++ix) {; for (int iy = 1; iy <= nbinY2; ++iy) {; if ( h2->GetBinContent(ix,iy) > 0 ) {; coords.push_back( std::make_pair(xaxis2->GetBinCenter(ix), yaxis2->GetBinCenter(iy) ) );; values.push_back( h2->GetBinContent(ix,iy) );; errors.push_back( h2->GetBinError(ix,iy) );; }; }; }; ; TVirtualFitter::SetDefaultFitter(""Minuit"");; TVirt",MatchSource.WIKI,doc/master/TwoHistoFit2D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TwoHistoFit2D_8C.html
https://root.cern/doc/master/TwoHistoFit2D_8C.html:4704,Availability,error,errors,4704," // create fit function; TF2 * func = new TF2(""func"",my2Dfunc,xlow2,xup2,ylow2,yup2, 10);; func->SetParameters(iniParams);; ; // fill Histos; int n1 = 50000;; int n2 = 50000;; // h1->FillRandom(""func"", n1);; //h2->FillRandom(""func"",n2);; FillHisto(h1,n1,iniParams);; FillHisto(h2,n2,iniParams);; ; // scale histograms to same heights (for fitting); double dx1 = (xup1-xlow1)/double(nbx1);; double dy1 = (yup1-ylow1)/double(nby1);; double dx2 = (xup2-xlow2)/double(nbx2);; double dy2 = (yup2-ylow2)/double(nby2);; // h1->Sumw2();; // h1->Scale( 1.0 / ( n1 * dx1 * dy1 ) );; // scale histo 2 to scale of 1; h2->Sumw2();; h2->Scale( ( double(n1) * dx1 * dy1 ) / ( double(n2) * dx2 * dy2 ) );; ; ; if (global) {; // fill data structure for fit (coordinates + values + errors); std::cout << ""Do global fit"" << std::endl;; // fit now all the function together; ; // fill data structure for fit (coordinates + values + errors); TAxis *xaxis1 = h1->GetXaxis();; TAxis *yaxis1 = h1->GetYaxis();; TAxis *xaxis2 = h2->GetXaxis();; TAxis *yaxis2 = h2->GetYaxis();; ; int nbinX1 = h1->GetNbinsX();; int nbinY1 = h1->GetNbinsY();; int nbinX2 = h2->GetNbinsX();; int nbinY2 = h2->GetNbinsY();; ; /// reset data structure; coords = std::vector<std::pair<double,double> >();; values = std::vector<double>();; errors = std::vector<double>();; ; ; for (int ix = 1; ix <= nbinX1; ++ix) {; for (int iy = 1; iy <= nbinY1; ++iy) {; if ( h1->GetBinContent(ix,iy) > 0 ) {; coords.push_back( std::make_pair(xaxis1->GetBinCenter(ix), yaxis1->GetBinCenter(iy) ) );; values.push_back( h1->GetBinContent(ix,iy) );; errors.push_back( h1->GetBinError(ix,iy) );; }; }; }; for (int ix = 1; ix <= nbinX2; ++ix) {; for (int iy = 1; iy <= nbinY2; ++iy) {; if ( h2->GetBinContent(ix,iy) > 0 ) {; coords.push_back( std::make_pair(xaxis2->GetBinCenter(ix), yaxis2->GetBinCenter(iy) ) );; values.push_back( h2->GetBinContent(ix,iy) );; errors.push_back( h2->GetBinError(ix,iy) );; }; }; }; ; TVirtualFitter::SetDefaultFitter(""Minuit"");; TVirt",MatchSource.WIKI,doc/master/TwoHistoFit2D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TwoHistoFit2D_8C.html
https://root.cern/doc/master/TwoHistoFit2D_8C.html:5084,Availability,error,errors,5084," // create fit function; TF2 * func = new TF2(""func"",my2Dfunc,xlow2,xup2,ylow2,yup2, 10);; func->SetParameters(iniParams);; ; // fill Histos; int n1 = 50000;; int n2 = 50000;; // h1->FillRandom(""func"", n1);; //h2->FillRandom(""func"",n2);; FillHisto(h1,n1,iniParams);; FillHisto(h2,n2,iniParams);; ; // scale histograms to same heights (for fitting); double dx1 = (xup1-xlow1)/double(nbx1);; double dy1 = (yup1-ylow1)/double(nby1);; double dx2 = (xup2-xlow2)/double(nbx2);; double dy2 = (yup2-ylow2)/double(nby2);; // h1->Sumw2();; // h1->Scale( 1.0 / ( n1 * dx1 * dy1 ) );; // scale histo 2 to scale of 1; h2->Sumw2();; h2->Scale( ( double(n1) * dx1 * dy1 ) / ( double(n2) * dx2 * dy2 ) );; ; ; if (global) {; // fill data structure for fit (coordinates + values + errors); std::cout << ""Do global fit"" << std::endl;; // fit now all the function together; ; // fill data structure for fit (coordinates + values + errors); TAxis *xaxis1 = h1->GetXaxis();; TAxis *yaxis1 = h1->GetYaxis();; TAxis *xaxis2 = h2->GetXaxis();; TAxis *yaxis2 = h2->GetYaxis();; ; int nbinX1 = h1->GetNbinsX();; int nbinY1 = h1->GetNbinsY();; int nbinX2 = h2->GetNbinsX();; int nbinY2 = h2->GetNbinsY();; ; /// reset data structure; coords = std::vector<std::pair<double,double> >();; values = std::vector<double>();; errors = std::vector<double>();; ; ; for (int ix = 1; ix <= nbinX1; ++ix) {; for (int iy = 1; iy <= nbinY1; ++iy) {; if ( h1->GetBinContent(ix,iy) > 0 ) {; coords.push_back( std::make_pair(xaxis1->GetBinCenter(ix), yaxis1->GetBinCenter(iy) ) );; values.push_back( h1->GetBinContent(ix,iy) );; errors.push_back( h1->GetBinError(ix,iy) );; }; }; }; for (int ix = 1; ix <= nbinX2; ++ix) {; for (int iy = 1; iy <= nbinY2; ++iy) {; if ( h2->GetBinContent(ix,iy) > 0 ) {; coords.push_back( std::make_pair(xaxis2->GetBinCenter(ix), yaxis2->GetBinCenter(iy) ) );; values.push_back( h2->GetBinContent(ix,iy) );; errors.push_back( h2->GetBinError(ix,iy) );; }; }; }; ; TVirtualFitter::SetDefaultFitter(""Minuit"");; TVirt",MatchSource.WIKI,doc/master/TwoHistoFit2D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TwoHistoFit2D_8C.html
https://root.cern/doc/master/TwoHistoFit2D_8C.html:5377,Availability,error,errors,5377," );; // scale histo 2 to scale of 1; h2->Sumw2();; h2->Scale( ( double(n1) * dx1 * dy1 ) / ( double(n2) * dx2 * dy2 ) );; ; ; if (global) {; // fill data structure for fit (coordinates + values + errors); std::cout << ""Do global fit"" << std::endl;; // fit now all the function together; ; // fill data structure for fit (coordinates + values + errors); TAxis *xaxis1 = h1->GetXaxis();; TAxis *yaxis1 = h1->GetYaxis();; TAxis *xaxis2 = h2->GetXaxis();; TAxis *yaxis2 = h2->GetYaxis();; ; int nbinX1 = h1->GetNbinsX();; int nbinY1 = h1->GetNbinsY();; int nbinX2 = h2->GetNbinsX();; int nbinY2 = h2->GetNbinsY();; ; /// reset data structure; coords = std::vector<std::pair<double,double> >();; values = std::vector<double>();; errors = std::vector<double>();; ; ; for (int ix = 1; ix <= nbinX1; ++ix) {; for (int iy = 1; iy <= nbinY1; ++iy) {; if ( h1->GetBinContent(ix,iy) > 0 ) {; coords.push_back( std::make_pair(xaxis1->GetBinCenter(ix), yaxis1->GetBinCenter(iy) ) );; values.push_back( h1->GetBinContent(ix,iy) );; errors.push_back( h1->GetBinError(ix,iy) );; }; }; }; for (int ix = 1; ix <= nbinX2; ++ix) {; for (int iy = 1; iy <= nbinY2; ++iy) {; if ( h2->GetBinContent(ix,iy) > 0 ) {; coords.push_back( std::make_pair(xaxis2->GetBinCenter(ix), yaxis2->GetBinCenter(iy) ) );; values.push_back( h2->GetBinContent(ix,iy) );; errors.push_back( h2->GetBinError(ix,iy) );; }; }; }; ; TVirtualFitter::SetDefaultFitter(""Minuit"");; TVirtualFitter * minuit = TVirtualFitter::Fitter(nullptr,10);; for (int i = 0; i < 10; ++i) {; minuit->SetParameter(i, func->GetParName(i), func->GetParameter(i), 0.01, 0,0);; }; minuit->SetFCN(myFcn);; ; double arglist[100];; arglist[0] = 0;; // set print level; minuit->ExecuteCommand(""SET PRINT"",arglist,2);; ; // minimize; arglist[0] = 5000; // number of function calls; arglist[1] = 0.01; // tolerance; minuit->ExecuteCommand(""MIGRAD"",arglist,2);; ; //get result; double minParams[10];; double parErrors[10];; for (int i = 0; i < 10; ++i) {; minParams[i] = minuit->Get",MatchSource.WIKI,doc/master/TwoHistoFit2D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TwoHistoFit2D_8C.html
https://root.cern/doc/master/TwoHistoFit2D_8C.html:5687,Availability,error,errors,5687,"e for fit (coordinates + values + errors); TAxis *xaxis1 = h1->GetXaxis();; TAxis *yaxis1 = h1->GetYaxis();; TAxis *xaxis2 = h2->GetXaxis();; TAxis *yaxis2 = h2->GetYaxis();; ; int nbinX1 = h1->GetNbinsX();; int nbinY1 = h1->GetNbinsY();; int nbinX2 = h2->GetNbinsX();; int nbinY2 = h2->GetNbinsY();; ; /// reset data structure; coords = std::vector<std::pair<double,double> >();; values = std::vector<double>();; errors = std::vector<double>();; ; ; for (int ix = 1; ix <= nbinX1; ++ix) {; for (int iy = 1; iy <= nbinY1; ++iy) {; if ( h1->GetBinContent(ix,iy) > 0 ) {; coords.push_back( std::make_pair(xaxis1->GetBinCenter(ix), yaxis1->GetBinCenter(iy) ) );; values.push_back( h1->GetBinContent(ix,iy) );; errors.push_back( h1->GetBinError(ix,iy) );; }; }; }; for (int ix = 1; ix <= nbinX2; ++ix) {; for (int iy = 1; iy <= nbinY2; ++iy) {; if ( h2->GetBinContent(ix,iy) > 0 ) {; coords.push_back( std::make_pair(xaxis2->GetBinCenter(ix), yaxis2->GetBinCenter(iy) ) );; values.push_back( h2->GetBinContent(ix,iy) );; errors.push_back( h2->GetBinError(ix,iy) );; }; }; }; ; TVirtualFitter::SetDefaultFitter(""Minuit"");; TVirtualFitter * minuit = TVirtualFitter::Fitter(nullptr,10);; for (int i = 0; i < 10; ++i) {; minuit->SetParameter(i, func->GetParName(i), func->GetParameter(i), 0.01, 0,0);; }; minuit->SetFCN(myFcn);; ; double arglist[100];; arglist[0] = 0;; // set print level; minuit->ExecuteCommand(""SET PRINT"",arglist,2);; ; // minimize; arglist[0] = 5000; // number of function calls; arglist[1] = 0.01; // tolerance; minuit->ExecuteCommand(""MIGRAD"",arglist,2);; ; //get result; double minParams[10];; double parErrors[10];; for (int i = 0; i < 10; ++i) {; minParams[i] = minuit->GetParameter(i);; parErrors[i] = minuit->GetParError(i);; }; double chi2, edm, errdef;; int nvpar, nparx;; minuit->GetStats(chi2,edm,errdef,nvpar,nparx);; ; func->SetParameters(minParams);; func->SetParErrors(parErrors);; func->SetChisquare(chi2);; int ndf = coords.size()-nvpar;; func->SetNDF(ndf);; ; std::cout ",MatchSource.WIKI,doc/master/TwoHistoFit2D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TwoHistoFit2D_8C.html
https://root.cern/doc/master/TwoHistoFit2D_8C.html:6185,Availability,toler,tolerance,6185,"tBinError(ix,iy) );; }; }; }; for (int ix = 1; ix <= nbinX2; ++ix) {; for (int iy = 1; iy <= nbinY2; ++iy) {; if ( h2->GetBinContent(ix,iy) > 0 ) {; coords.push_back( std::make_pair(xaxis2->GetBinCenter(ix), yaxis2->GetBinCenter(iy) ) );; values.push_back( h2->GetBinContent(ix,iy) );; errors.push_back( h2->GetBinError(ix,iy) );; }; }; }; ; TVirtualFitter::SetDefaultFitter(""Minuit"");; TVirtualFitter * minuit = TVirtualFitter::Fitter(nullptr,10);; for (int i = 0; i < 10; ++i) {; minuit->SetParameter(i, func->GetParName(i), func->GetParameter(i), 0.01, 0,0);; }; minuit->SetFCN(myFcn);; ; double arglist[100];; arglist[0] = 0;; // set print level; minuit->ExecuteCommand(""SET PRINT"",arglist,2);; ; // minimize; arglist[0] = 5000; // number of function calls; arglist[1] = 0.01; // tolerance; minuit->ExecuteCommand(""MIGRAD"",arglist,2);; ; //get result; double minParams[10];; double parErrors[10];; for (int i = 0; i < 10; ++i) {; minParams[i] = minuit->GetParameter(i);; parErrors[i] = minuit->GetParError(i);; }; double chi2, edm, errdef;; int nvpar, nparx;; minuit->GetStats(chi2,edm,errdef,nvpar,nparx);; ; func->SetParameters(minParams);; func->SetParErrors(parErrors);; func->SetChisquare(chi2);; int ndf = coords.size()-nvpar;; func->SetNDF(ndf);; ; std::cout << ""Chi2 Fit = "" << chi2 << "" ndf = "" << ndf << "" "" << func->GetNDF() << std::endl;; ; // add to list of functions; h1->GetListOfFunctions()->Add(func);; h2->GetListOfFunctions()->Add(func);; }; else {; // fit independently; h1->Fit(func);; h2->Fit(func);; }; ; ; ; // Create a new canvas.; TCanvas * c1 = new TCanvas(""c1"",""Two HIstogram Fit example"",100,10,900,800);; c1->Divide(2,2);; gStyle->SetOptFit();; gStyle->SetStatY(0.6);; ; c1->cd(1);; h1->Draw();; func->SetRange(xlow1,ylow1,xup1,yup1);; func->DrawCopy(""cont1 same"");; c1->cd(2);; h1->Draw(""lego"");; func->DrawCopy(""surf1 same"");; c1->cd(3);; func->SetRange(xlow2,ylow2,xup2,yup2);; h2->Draw();; func->DrawCopy(""cont1 same"");; c1->cd(4);; h2->Draw(""lego"");; gPad->SetL",MatchSource.WIKI,doc/master/TwoHistoFit2D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TwoHistoFit2D_8C.html
https://root.cern/doc/master/TwoHistoFit2D_8C.html:8704,Availability,error,errors,8704,"GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TH2D.h; TList.h; TRandom3.h; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TVirtualFitter.h; gPad#define gPadDefinition TVirtualPad.h:308; TAxisClass to manage histogram axis.Definition TAxis.h:31; TAxis::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn center of bin.Definition TAxis.cxx:478; TCanvasThe Canvas class.Definition TCanvas.h:23; TF1::GetNDFvirtual Int_t GetNDF() constReturn the number of degrees of freedom in the fit the fNDF parameter has been previously computed du...Definition TF1.cxx:1889; TF1::SetNDFvirtual void SetNDF(Int_t ndf)Set the number of degrees of freedom ndf should be the number of points used in a fit - the number of...Definition TF1.cxx:3419; TF1::SetChisquarevirtual void SetChisquare(Double_t chi2)Definition TF1.h:640; TF1::SetParErrorsvirtual void SetParErrors(const Double_t *errors)Set errors for all active parameters when calling this function, the array errors must have at least ...Definition TF1.cxx:3490; TF1::GetParNamevirtual const char * GetParName(Int_t ipar) constDefinition TF1.h:557; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::GetParametervirtual Double_t GetParameter(Int_t ipar) constDefinition TF1.h:540; TF2A 2-Dim function with parameters.Definition TF2.h:29; TF2::DrawCopyTF1 * DrawCopy(Option_t *option="""") const overrideDraw a copy of this function with its current attributes-*.Definition TF2.cxx:286; TF2::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF2.cxx:259; TF2::SetRangevoid SetRange(Double_t xmin, Double_t xmax) overrideInitialize the upper and lower bounds to draw the function.Definition TF2.h:146; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associ",MatchSource.WIKI,doc/master/TwoHistoFit2D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TwoHistoFit2D_8C.html
https://root.cern/doc/master/TwoHistoFit2D_8C.html:8715,Availability,error,errors,8715,"GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TH2D.h; TList.h; TRandom3.h; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TVirtualFitter.h; gPad#define gPadDefinition TVirtualPad.h:308; TAxisClass to manage histogram axis.Definition TAxis.h:31; TAxis::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn center of bin.Definition TAxis.cxx:478; TCanvasThe Canvas class.Definition TCanvas.h:23; TF1::GetNDFvirtual Int_t GetNDF() constReturn the number of degrees of freedom in the fit the fNDF parameter has been previously computed du...Definition TF1.cxx:1889; TF1::SetNDFvirtual void SetNDF(Int_t ndf)Set the number of degrees of freedom ndf should be the number of points used in a fit - the number of...Definition TF1.cxx:3419; TF1::SetChisquarevirtual void SetChisquare(Double_t chi2)Definition TF1.h:640; TF1::SetParErrorsvirtual void SetParErrors(const Double_t *errors)Set errors for all active parameters when calling this function, the array errors must have at least ...Definition TF1.cxx:3490; TF1::GetParNamevirtual const char * GetParName(Int_t ipar) constDefinition TF1.h:557; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::GetParametervirtual Double_t GetParameter(Int_t ipar) constDefinition TF1.h:540; TF2A 2-Dim function with parameters.Definition TF2.h:29; TF2::DrawCopyTF1 * DrawCopy(Option_t *option="""") const overrideDraw a copy of this function with its current attributes-*.Definition TF2.cxx:286; TF2::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF2.cxx:259; TF2::SetRangevoid SetRange(Double_t xmin, Double_t xmax) overrideInitialize the upper and lower bounds to draw the function.Definition TF2.h:146; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associ",MatchSource.WIKI,doc/master/TwoHistoFit2D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TwoHistoFit2D_8C.html
https://root.cern/doc/master/TwoHistoFit2D_8C.html:8786,Availability,error,errors,8786,"GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TH2D.h; TList.h; TRandom3.h; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TVirtualFitter.h; gPad#define gPadDefinition TVirtualPad.h:308; TAxisClass to manage histogram axis.Definition TAxis.h:31; TAxis::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn center of bin.Definition TAxis.cxx:478; TCanvasThe Canvas class.Definition TCanvas.h:23; TF1::GetNDFvirtual Int_t GetNDF() constReturn the number of degrees of freedom in the fit the fNDF parameter has been previously computed du...Definition TF1.cxx:1889; TF1::SetNDFvirtual void SetNDF(Int_t ndf)Set the number of degrees of freedom ndf should be the number of points used in a fit - the number of...Definition TF1.cxx:3419; TF1::SetChisquarevirtual void SetChisquare(Double_t chi2)Definition TF1.h:640; TF1::SetParErrorsvirtual void SetParErrors(const Double_t *errors)Set errors for all active parameters when calling this function, the array errors must have at least ...Definition TF1.cxx:3490; TF1::GetParNamevirtual const char * GetParName(Int_t ipar) constDefinition TF1.h:557; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::GetParametervirtual Double_t GetParameter(Int_t ipar) constDefinition TF1.h:540; TF2A 2-Dim function with parameters.Definition TF2.h:29; TF2::DrawCopyTF1 * DrawCopy(Option_t *option="""") const overrideDraw a copy of this function with its current attributes-*.Definition TF2.cxx:286; TF2::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF2.cxx:259; TF2::SetRangevoid SetRange(Double_t xmin, Double_t xmax) overrideInitialize the upper and lower bounds to draw the function.Definition TF2.h:146; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associ",MatchSource.WIKI,doc/master/TwoHistoFit2D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TwoHistoFit2D_8C.html
https://root.cern/doc/master/TwoHistoFit2D_8C.html:9714,Availability,error,error,9714,"onst Double_t *errors)Set errors for all active parameters when calling this function, the array errors must have at least ...Definition TF1.cxx:3490; TF1::GetParNamevirtual const char * GetParName(Int_t ipar) constDefinition TF1.h:557; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::GetParametervirtual Double_t GetParameter(Int_t ipar) constDefinition TF1.h:540; TF2A 2-Dim function with parameters.Definition TF2.h:29; TF2::DrawCopyTF1 * DrawCopy(Option_t *option="""") const overrideDraw a copy of this function with its current attributes-*.Definition TF2.cxx:286; TF2::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF2.cxx:259; TF2::SetRangevoid SetRange(Double_t xmin, Double_t xmax) overrideInitialize the upper and lower bounds to draw the function.Definition TF2.h:146; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetBinErrorvirtual Double_t GetBinError(Int_t bin) constReturn value of error associated to bin number bin.Definition TH1.cxx:9063; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH2D2-D histogram with a double per channel (see TH1 documentation)Definition TH2.h:357; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TRandom3::RndmDou",MatchSource.WIKI,doc/master/TwoHistoFit2D_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/TwoHistoFit2D_8C.html
https://root.cern/doc/master/UnaryOperators_8h_source.html:13005,Integrability,wrap,wrapper,13005,"Expression.h:138; ROOT::Math::FabsUnary abs Operation Class.Definition UnaryOperators.h:119; ROOT::Math::Fabs::applystatic T apply(const T &rhs)Definition UnaryOperators.h:121; ROOT::Math::MinusUnary Minus Operation Class.Definition UnaryOperators.h:44; ROOT::Math::Minus::applystatic T apply(const T &rhs)Definition UnaryOperators.h:46; ROOT::Math::SMatrixSMatrix: a generic fixed size D1 x D2 Matrix class.Definition SMatrix.h:101; ROOT::Math::SVectorSVector: a generic fixed size Vector class.Definition SVector.h:75; ROOT::Math::SqrUnary Square Operation Class.Definition UnaryOperators.h:194; ROOT::Math::Sqr::applystatic T apply(const T &rhs)Definition UnaryOperators.h:196; ROOT::Math::SqrtUnary Square Root Operation Class.Definition UnaryOperators.h:269; ROOT::Math::Sqrt::applystatic T apply(const T &rhs)Definition UnaryOperators.h:271; ROOT::Math::UnaryOpUnaryOperation class A class representing unary operators in the parse tree.Definition Expression.h:361; ROOT::Math::VecExprExpression wrapper class for Vector objects.Definition Expression.h:64; R; MathNamespace for new Math classes and functions.; ROOT::Math::sqrVecExpr< UnaryOp< Sqr< T >, VecExpr< A, T, D >, T >, T, D > sqr(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:206; ROOT::Math::operator-DisplacementVector2D< CoordSystem1, U > operator-(DisplacementVector2D< CoordSystem1, U > v1, DisplacementVector2D< CoordSystem2, U > const &v2)Difference between two DisplacementVector2D vectors.Definition DisplacementVector2D.h:453; ROOT::Math::sqrtVecExpr< UnaryOp< Sqrt< T >, VecExpr< A, T, D >, T >, T, D > sqrt(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:281; ROOT::Math::fabsVecExpr< UnaryOp< Fabs< T >, VecExpr< A, T, D >, T >, T, D > fabs(const VecExpr< A, T, D > &rhs)Definition UnaryOperators.h:131; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. mathsmatrixincMathUnaryOperators.h. ROOT master - Re",MatchSource.WIKI,doc/master/UnaryOperators_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnaryOperators_8h_source.html
https://root.cern/doc/master/UnBinData_8cxx_source.html:1840,Energy Efficiency,allocate,allocate,1840,"opyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for class UnBinData; 12 ; 13#include ""Fit/UnBinData.h""; 14#include ""Math/Error.h""; 15 ; 16#include <cassert>; 17#include <cmath>; 18 ; 19namespace ROOT {; 20 ; 21 namespace Fit {; 22 ; 23/// copy constructor; 24UnBinData::UnBinData(const UnBinData & rhs) :; 25 FitData(rhs),; 26 fWeighted(rhs.fWeighted); 27{}; 28 ; 29///assignment operator; 30UnBinData & UnBinData::operator= ( const UnBinData & rhs ); 31{; 32 FitData::operator=( rhs );; 33 fWeighted = rhs.fWeighted;; 34 return *this;; 35}; 36 ; 37 ; 38 } // end namespace Fit; 39 ; 40} // end namespace ROOT; 41 ; Error.h; UnBinData.h; ROOT::Fit::FitDataBase class for all the fit data types: Stores the coordinates and the DataOptions.Definition FitData.h:56; ROOT::Fit::FitData::operator=FitData & operator=(const FitData &rhs)Definition FitData.cxx:218; ROOT::Fit::UnBinDataClass describing the un-binned data sets (just x coordinates values) of any dimensions.Definition UnBinData.h:46; ROOT::Fit::UnBinData::operator=UnBinData & operator=(const UnBinData &)assignment operatorDefinition UnBinData.cxx:30; ROOT::Fit::UnBinData::fWeightedbool fWeightedDefinition UnBinData.h:293; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int maxpoints=0, unsigned int dim=1, bool isWeighted=false)constructor from dimension of point and max number of points (to pre-allocate vector)Definition UnBinData.h:54; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. mathmathcoresrcUnBinData.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:41 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/UnBinData_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8cxx_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:1247,Availability,error,error,1247," 2006; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class UnBinData; 12 ; 13#ifndef ROOT_Fit_UnBinData; 14#define ROOT_Fit_UnBinData; 15 ; 16#include ""Fit/FitData.h""; 17#include ""Math/Error.h""; 18 ; 19#include <vector>; 20 ; 21namespace ROOT {; 22 ; 23 namespace Fit {; 24 ; 25 ; 26//___________________________________________________________________________________; 27/**; 28 Class describing the un-binned data sets (just x coordinates values) of any dimensions; 29 ; 30 There is the option to construct UnBindata copying the data inside; 31 (in the base FitData class) or using a pointer to external data, depending on which; 32 constructor of the UnBinData class is used.; 33 It is recommended to copy the input data inside, since this will be more efficient and; 34 less error prone, since the input provided data will have to be kept alive for all the time the; 35 Fit classes will be used.; 36 In case of really large data sets for limiting memory consumption then the other option can be used; 37 with special care.; 38 Specialized constructor exists for using external data up to 3 dimensions.; 39 ; 40 When the data are copying in the number of points can be set later (or re-set) using Initialize and; 41 the data are inserted one by one using the Add method.; 42 It is mandatory to set the size before using the Add method.; 43 ; 44 @ingroup FitData; 45*/; 46class UnBinData : public FitData {; 47 ; 48public :; 49 ; 50 /**; 51 constructor from dimension of point and max number of points (to pre-allocate vector); 52 */; 53 ; 54 explicit UnBinData( unsigned int maxpoints = 0, unsigned int dim = 1,; 55 bool isWeighted = false ) :; 56 FitData( maxpoints, isWeighted ? dim + 1 : dim ),; 57 fWeighted(isWeighted); 58 {; 59 assert( dim >= 1 );; 60 assert( !fWeighted || dim >=",MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:1311,Availability,alive,alive,1311," 2006; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class UnBinData; 12 ; 13#ifndef ROOT_Fit_UnBinData; 14#define ROOT_Fit_UnBinData; 15 ; 16#include ""Fit/FitData.h""; 17#include ""Math/Error.h""; 18 ; 19#include <vector>; 20 ; 21namespace ROOT {; 22 ; 23 namespace Fit {; 24 ; 25 ; 26//___________________________________________________________________________________; 27/**; 28 Class describing the un-binned data sets (just x coordinates values) of any dimensions; 29 ; 30 There is the option to construct UnBindata copying the data inside; 31 (in the base FitData class) or using a pointer to external data, depending on which; 32 constructor of the UnBinData class is used.; 33 It is recommended to copy the input data inside, since this will be more efficient and; 34 less error prone, since the input provided data will have to be kept alive for all the time the; 35 Fit classes will be used.; 36 In case of really large data sets for limiting memory consumption then the other option can be used; 37 with special care.; 38 Specialized constructor exists for using external data up to 3 dimensions.; 39 ; 40 When the data are copying in the number of points can be set later (or re-set) using Initialize and; 41 the data are inserted one by one using the Add method.; 42 It is mandatory to set the size before using the Add method.; 43 ; 44 @ingroup FitData; 45*/; 46class UnBinData : public FitData {; 47 ; 48public :; 49 ; 50 /**; 51 constructor from dimension of point and max number of points (to pre-allocate vector); 52 */; 53 ; 54 explicit UnBinData( unsigned int maxpoints = 0, unsigned int dim = 1,; 55 bool isWeighted = false ) :; 56 FitData( maxpoints, isWeighted ? dim + 1 : dim ),; 57 fWeighted(isWeighted); 58 {; 59 assert( dim >= 1 );; 60 assert( !fWeighted || dim >=",MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:1224,Energy Efficiency,efficient,efficient,1224," 2006; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class UnBinData; 12 ; 13#ifndef ROOT_Fit_UnBinData; 14#define ROOT_Fit_UnBinData; 15 ; 16#include ""Fit/FitData.h""; 17#include ""Math/Error.h""; 18 ; 19#include <vector>; 20 ; 21namespace ROOT {; 22 ; 23 namespace Fit {; 24 ; 25 ; 26//___________________________________________________________________________________; 27/**; 28 Class describing the un-binned data sets (just x coordinates values) of any dimensions; 29 ; 30 There is the option to construct UnBindata copying the data inside; 31 (in the base FitData class) or using a pointer to external data, depending on which; 32 constructor of the UnBinData class is used.; 33 It is recommended to copy the input data inside, since this will be more efficient and; 34 less error prone, since the input provided data will have to be kept alive for all the time the; 35 Fit classes will be used.; 36 In case of really large data sets for limiting memory consumption then the other option can be used; 37 with special care.; 38 Specialized constructor exists for using external data up to 3 dimensions.; 39 ; 40 When the data are copying in the number of points can be set later (or re-set) using Initialize and; 41 the data are inserted one by one using the Add method.; 42 It is mandatory to set the size before using the Add method.; 43 ; 44 @ingroup FitData; 45*/; 46class UnBinData : public FitData {; 47 ; 48public :; 49 ; 50 /**; 51 constructor from dimension of point and max number of points (to pre-allocate vector); 52 */; 53 ; 54 explicit UnBinData( unsigned int maxpoints = 0, unsigned int dim = 1,; 55 bool isWeighted = false ) :; 56 FitData( maxpoints, isWeighted ? dim + 1 : dim ),; 57 fWeighted(isWeighted); 58 {; 59 assert( dim >= 1 );; 60 assert( !fWeighted || dim >=",MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:1426,Energy Efficiency,consumption,consumption,1426,"**************************************************************/; 10 ; 11// Header file for class UnBinData; 12 ; 13#ifndef ROOT_Fit_UnBinData; 14#define ROOT_Fit_UnBinData; 15 ; 16#include ""Fit/FitData.h""; 17#include ""Math/Error.h""; 18 ; 19#include <vector>; 20 ; 21namespace ROOT {; 22 ; 23 namespace Fit {; 24 ; 25 ; 26//___________________________________________________________________________________; 27/**; 28 Class describing the un-binned data sets (just x coordinates values) of any dimensions; 29 ; 30 There is the option to construct UnBindata copying the data inside; 31 (in the base FitData class) or using a pointer to external data, depending on which; 32 constructor of the UnBinData class is used.; 33 It is recommended to copy the input data inside, since this will be more efficient and; 34 less error prone, since the input provided data will have to be kept alive for all the time the; 35 Fit classes will be used.; 36 In case of really large data sets for limiting memory consumption then the other option can be used; 37 with special care.; 38 Specialized constructor exists for using external data up to 3 dimensions.; 39 ; 40 When the data are copying in the number of points can be set later (or re-set) using Initialize and; 41 the data are inserted one by one using the Add method.; 42 It is mandatory to set the size before using the Add method.; 43 ; 44 @ingroup FitData; 45*/; 46class UnBinData : public FitData {; 47 ; 48public :; 49 ; 50 /**; 51 constructor from dimension of point and max number of points (to pre-allocate vector); 52 */; 53 ; 54 explicit UnBinData( unsigned int maxpoints = 0, unsigned int dim = 1,; 55 bool isWeighted = false ) :; 56 FitData( maxpoints, isWeighted ? dim + 1 : dim ),; 57 fWeighted(isWeighted); 58 {; 59 assert( dim >= 1 );; 60 assert( !fWeighted || dim >= 2 );; 61 }; 62 ; 63 ; 64 /**; 65 constructor from range and default option; 66 */; 67 explicit UnBinData ( const DataRange & range, unsigned int maxpoints = 0,; 68 unsigned ",MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:1980,Energy Efficiency,allocate,allocate,1980,; 43 ; 44 @ingroup FitData; 45*/; 46class UnBinData : public FitData {; 47 ; 48public :; 49 ; 50 /**; 51 constructor from dimension of point and max number of points (to pre-allocate vector); 52 ,MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:13021,Energy Efficiency,allocate,allocate,13021,"taUnBinData(const DataOptions &opt, const DataRange &range, unsigned int maxpoints=0, unsigned int dim=1, bool isWeighted=false)constructor from options and rangeDefinition UnBinData.h:79; ROOT::Fit::UnBinData::fWeightedbool fWeightedDefinition UnBinData.h:293; ROOT::Fit::UnBinData::Addvoid Add(double x, double y)add 2-dim coordinate data can also be used to add 1-dim data with a weightDefinition UnBinData.h:207; ROOT::Fit::UnBinData::~UnBinData~UnBinData() overridedestructor, delete pointer to internal data or external data wrapperDefinition UnBinData.h:189; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int n, const double *dataX)constructor for 1D external data (data are not copied inside)Definition UnBinData.h:91; ROOT::Fit::UnBinData::Addvoid Add(double x, double y, double z)add 3-dim coordinate data can also be used to add 2-dim data with a weightDefinition UnBinData.h:219; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int maxpoints=0, unsigned int dim=1, bool isWeighted=false)constructor from dimension of point and max number of points (to pre-allocate vector)Definition UnBinData.h:54; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int n, unsigned int dim, Iterator dataItr, bool isWeighted=false)constructor for multi-dim external data (data are not copied inside) Uses as argument an iterator of ...Definition UnBinData.h:127; ROOT::Fit::UnBinData::Addvoid Add(const double *x)add multi-dim coordinate dataDefinition UnBinData.h:230; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int maxpoints, const double *dataX, const double *dataY, const double *dataZ, const DataRange &range, bool isWeighted=false)constructor for 3D data and a range (data are copied inside according to the given range) or a 2D dat...Definition UnBinData.h:161; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int maxpoints, const double *dataX, const double *dataY, const DataRange &range, bool isWeighted=false)constructor for 2D data and a range (data are copied inside according ",MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:1080,Integrability,depend,depending,1080,". ROOT: math/mathcore/inc/Fit/UnBinData.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. UnBinData.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Author: L. Moneta Wed Aug 30 11:15:23 2006; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class UnBinData; 12 ; 13#ifndef ROOT_Fit_UnBinData; 14#define ROOT_Fit_UnBinData; 15 ; 16#include ""Fit/FitData.h""; 17#include ""Math/Error.h""; 18 ; 19#include <vector>; 20 ; 21namespace ROOT {; 22 ; 23 namespace Fit {; 24 ; 25 ; 26//___________________________________________________________________________________; 27/**; 28 Class describing the un-binned data sets (just x coordinates values) of any dimensions; 29 ; 30 There is the option to construct UnBindata copying the data inside; 31 (in the base FitData class) or using a pointer to external data, depending on which; 32 constructor of the UnBinData class is used.; 33 It is recommended to copy the input data inside, since this will be more efficient and; 34 less error prone, since the input provided data will have to be kept alive for all the time the; 35 Fit classes will be used.; 36 In case of really large data sets for limiting memory consumption then the other option can be used; 37 with special care.; 38 Specialized constructor exists for using external data up to 3 dimensions.; 39 ; 40 When the data are copying in the number of points can be set later (or re-set) using Initialize and; 41 the data are inserted one by one using the Add method.; 42 It is mandatory to set the size before using the Add method.; 43 ; 44 @ingroup FitData; 45*/; 46class UnBinData : public FitData {; 47 ; 48public :; 49 ; 50 /**; 51 constructor from dimension of point and max number of points (to pre-allocate vector); 52 ",MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:6559,Integrability,wrap,wrapper,6559,"nst double * dataX, const double * dataY,; 162 const double * dataZ, const DataRange & range, bool isWeighted = false) :; 163 FitData( range, maxpoints, dataX, dataY, dataZ ),; 164 fWeighted( isWeighted ); 165 {; 166 }; 167 ; 168 /**; 169 constructor for multi-dim external data and a range (data are copied inside according to the range); 170 Uses as argument an iterator of a list (or vector) containing the const double * of the data; 171 An example could be the std::vector<const double *>::begin; 172 */; 173 template<class Iterator>; 174 UnBinData( unsigned int maxpoints, unsigned int dim, Iterator dataItr, const DataRange & range, bool isWeighted = false ) :; 175 FitData( range, maxpoints, dim, dataItr ),; 176 fWeighted( isWeighted ); 177 {; 178 }; 179 ; 180 /// copy constructor; 181 UnBinData(const UnBinData &);; 182 /// assignment operator; 183 UnBinData & operator= (const UnBinData &);; 184 ; 185public:; 186 /**; 187 destructor, delete pointer to internal data or external data wrapper; 188 */; 189 ~UnBinData() override {; 190 }; 191 ; 192 /**; 193 add one dim coordinate data (unweighted); 194 */; 195 void Add(double x); 196 {; 197 assert( !fWeighted );; 198 ; 199 FitData::Add( x );; 200 }; 201 ; 202 ; 203 /**; 204 add 2-dim coordinate data; 205 can also be used to add 1-dim data with a weight; 206 */; 207 void Add(double x, double y); 208 {; 209 assert( fDim == 2 );; 210 double dataTmp[] = { x, y };; 211 ; 212 FitData::Add( dataTmp );; 213 }; 214 ; 215 /**; 216 add 3-dim coordinate data; 217 can also be used to add 2-dim data with a weight; 218 */; 219 void Add(double x, double y, double z); 220 {; 221 assert( fDim == 3 );; 222 double dataTmp[] = { x, y, z };; 223 ; 224 FitData::Add( dataTmp );; 225 }; 226 ; 227 /**; 228 add multi-dim coordinate data; 229 */; 230 void Add( const double* x ); 231 {; 232 FitData::Add( x );; 233 }; 234 ; 235 /**; 236 add multi-dim coordinate data + weight; 237 */; 238 void Add(const double *x, double w); 239 {; 240 assert( fWeighte",MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:12478,Integrability,wrap,wrapperDefinition,12478,"ructor for 3D external data (data are not copied inside) or 2D data with a weight (if isWeighted...Definition UnBinData.h:112; ROOT::Fit::UnBinData::Appendvoid Append(unsigned int newPoints, unsigned int dim=1, bool isWeighted=false)Definition UnBinData.h:283; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int maxpoints, const double *dataX, const DataRange &range)constructor for 1D data and a range (data are copied inside according to the given range)Definition UnBinData.h:139; ROOT::Fit::UnBinData::UnBinDataUnBinData(const DataOptions &opt, const DataRange &range, unsigned int maxpoints=0, unsigned int dim=1, bool isWeighted=false)constructor from options and rangeDefinition UnBinData.h:79; ROOT::Fit::UnBinData::fWeightedbool fWeightedDefinition UnBinData.h:293; ROOT::Fit::UnBinData::Addvoid Add(double x, double y)add 2-dim coordinate data can also be used to add 1-dim data with a weightDefinition UnBinData.h:207; ROOT::Fit::UnBinData::~UnBinData~UnBinData() overridedestructor, delete pointer to internal data or external data wrapperDefinition UnBinData.h:189; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int n, const double *dataX)constructor for 1D external data (data are not copied inside)Definition UnBinData.h:91; ROOT::Fit::UnBinData::Addvoid Add(double x, double y, double z)add 3-dim coordinate data can also be used to add 2-dim data with a weightDefinition UnBinData.h:219; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int maxpoints=0, unsigned int dim=1, bool isWeighted=false)constructor from dimension of point and max number of points (to pre-allocate vector)Definition UnBinData.h:54; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int n, unsigned int dim, Iterator dataItr, bool isWeighted=false)constructor for multi-dim external data (data are not copied inside) Uses as argument an iterator of ...Definition UnBinData.h:127; ROOT::Fit::UnBinData::Addvoid Add(const double *x)add multi-dim coordinate dataDefinition UnBinData.h:230; ROOT::Fit::UnB",MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:2205,Testability,assert,assert,2205,; 43 ; 44 @ingroup FitData; 45*/; 46class UnBinData : public FitData {; 47 ; 48public :; 49 ; 50 /**; 51 constructor from dimension of point and max number of points (to pre-allocate vector); 52 ,MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:2229,Testability,assert,assert,2229,; 43 ; 44 @ingroup FitData; 45*/; 46class UnBinData : public FitData {; 47 ; 48public :; 49 ; 50 /**; 51 constructor from dimension of point and max number of points (to pre-allocate vector); 52 ,MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:2569,Testability,assert,assert,2569,; 43 ; 44 @ingroup FitData; 45*/; 46class UnBinData : public FitData {; 47 ; 48public :; 49 ; 50 /**; 51 constructor from dimension of point and max number of points (to pre-allocate vector); 52 ,MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:2593,Testability,assert,assert,2593,; 43 ; 44 @ingroup FitData; 45*/; 46class UnBinData : public FitData {; 47 ; 48public :; 49 ; 50 /**; 51 constructor from dimension of point and max number of points (to pre-allocate vector); 52 ,MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:2941,Testability,assert,assert,2941,"nt and max number of points (to pre-allocate vector); 52 */; 53 ; 54 explicit UnBinData( unsigned int maxpoints = 0, unsigned int dim = 1,; 55 bool isWeighted = false ) :; 56 FitData( maxpoints, isWeighted ? dim + 1 : dim ),; 57 fWeighted(isWeighted); 58 {; 59 assert( dim >= 1 );; 60 assert( !fWeighted || dim >= 2 );; 61 }; 62 ; 63 ; 64 /**; 65 constructor from range and default option; 66 */; 67 explicit UnBinData ( const DataRange & range, unsigned int maxpoints = 0,; 68 unsigned int dim = 1, bool isWeighted = false ) :; 69 FitData( range, maxpoints, isWeighted ? dim + 1 : dim ),; 70 fWeighted(isWeighted); 71 {; 72 assert( dim >= 1 );; 73 assert( !fWeighted || dim >= 2 );; 74 }; 75 ; 76 /**; 77 constructor from options and range; 78 */; 79 UnBinData (const DataOptions & opt, const DataRange & range,; 80 unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false ) :; 81 FitData( opt, range, maxpoints, isWeighted ? dim + 1 : dim ),; 82 fWeighted(isWeighted); 83 {; 84 assert( dim >= 1 );; 85 assert( !fWeighted || dim >= 2 );; 86 }; 87 ; 88 /**; 89 constructor for 1D external data (data are not copied inside); 90 */; 91 UnBinData(unsigned int n, const double * dataX ) :; 92 FitData( n, dataX ),; 93 fWeighted( false ); 94 {; 95 }; 96 ; 97 /**; 98 constructor for 2D external data (data are not copied inside); 99 or 1D data with a weight (if isWeighted = true); 100 */; 101 UnBinData(unsigned int n, const double * dataX, const double * dataY,; 102 bool isWeighted = false ) :; 103 FitData( n, dataX, dataY ),; 104 fWeighted( isWeighted ); 105 {; 106 }; 107 ; 108 /**; 109 constructor for 3D external data (data are not copied inside); 110 or 2D data with a weight (if isWeighted = true); 111 */; 112 UnBinData(unsigned int n, const double * dataX, const double * dataY,; 113 const double * dataZ, bool isWeighted = false ) :; 114 FitData( n, dataX, dataY, dataZ ),; 115 fWeighted( isWeighted ); 116 {; 117 }; 118 ; 119 /**; 120 constructor for multi-dim external data ",MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:2965,Testability,assert,assert,2965,"nts (to pre-allocate vector); 52 */; 53 ; 54 explicit UnBinData( unsigned int maxpoints = 0, unsigned int dim = 1,; 55 bool isWeighted = false ) :; 56 FitData( maxpoints, isWeighted ? dim + 1 : dim ),; 57 fWeighted(isWeighted); 58 {; 59 assert( dim >= 1 );; 60 assert( !fWeighted || dim >= 2 );; 61 }; 62 ; 63 ; 64 /**; 65 constructor from range and default option; 66 */; 67 explicit UnBinData ( const DataRange & range, unsigned int maxpoints = 0,; 68 unsigned int dim = 1, bool isWeighted = false ) :; 69 FitData( range, maxpoints, isWeighted ? dim + 1 : dim ),; 70 fWeighted(isWeighted); 71 {; 72 assert( dim >= 1 );; 73 assert( !fWeighted || dim >= 2 );; 74 }; 75 ; 76 /**; 77 constructor from options and range; 78 */; 79 UnBinData (const DataOptions & opt, const DataRange & range,; 80 unsigned int maxpoints = 0, unsigned int dim = 1, bool isWeighted = false ) :; 81 FitData( opt, range, maxpoints, isWeighted ? dim + 1 : dim ),; 82 fWeighted(isWeighted); 83 {; 84 assert( dim >= 1 );; 85 assert( !fWeighted || dim >= 2 );; 86 }; 87 ; 88 /**; 89 constructor for 1D external data (data are not copied inside); 90 */; 91 UnBinData(unsigned int n, const double * dataX ) :; 92 FitData( n, dataX ),; 93 fWeighted( false ); 94 {; 95 }; 96 ; 97 /**; 98 constructor for 2D external data (data are not copied inside); 99 or 1D data with a weight (if isWeighted = true); 100 */; 101 UnBinData(unsigned int n, const double * dataX, const double * dataY,; 102 bool isWeighted = false ) :; 103 FitData( n, dataX, dataY ),; 104 fWeighted( isWeighted ); 105 {; 106 }; 107 ; 108 /**; 109 constructor for 3D external data (data are not copied inside); 110 or 2D data with a weight (if isWeighted = true); 111 */; 112 UnBinData(unsigned int n, const double * dataX, const double * dataY,; 113 const double * dataZ, bool isWeighted = false ) :; 114 FitData( n, dataX, dataY, dataZ ),; 115 fWeighted( isWeighted ); 116 {; 117 }; 118 ; 119 /**; 120 constructor for multi-dim external data (data are not copied ins",MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:4507,Testability,assert,assert,4507,"; 87 ; 88 /**; 89 constructor for 1D external data (data are not copied inside); 90 */; 91 UnBinData(unsigned int n, const double * dataX ) :; 92 FitData( n, dataX ),; 93 fWeighted( false ); 94 {; 95 }; 96 ; 97 /**; 98 constructor for 2D external data (data are not copied inside); 99 or 1D data with a weight (if isWeighted = true); 100 */; 101 UnBinData(unsigned int n, const double * dataX, const double * dataY,; 102 bool isWeighted = false ) :; 103 FitData( n, dataX, dataY ),; 104 fWeighted( isWeighted ); 105 {; 106 }; 107 ; 108 /**; 109 constructor for 3D external data (data are not copied inside); 110 or 2D data with a weight (if isWeighted = true); 111 */; 112 UnBinData(unsigned int n, const double * dataX, const double * dataY,; 113 const double * dataZ, bool isWeighted = false ) :; 114 FitData( n, dataX, dataY, dataZ ),; 115 fWeighted( isWeighted ); 116 {; 117 }; 118 ; 119 /**; 120 constructor for multi-dim external data (data are not copied inside); 121 Uses as argument an iterator of a list (or vector) containing the const double * of the data; 122 An example could be the std::vector<const double *>::begin; 123 In case of weighted data, the external data must have a dim+1 lists of data; 124 The passed dim refers just to the coordinate size; 125 */; 126 template<class Iterator>; 127 UnBinData(unsigned int n, unsigned int dim, Iterator dataItr,; 128 bool isWeighted = false ) :; 129 FitData( n, isWeighted ? dim + 1 : dim, dataItr ),; 130 fWeighted( isWeighted ); 131 {; 132 assert( dim >= 1 );; 133 assert( !fWeighted || dim >= 2 );; 134 }; 135 ; 136 /**; 137 constructor for 1D data and a range (data are copied inside according to the given range); 138 */; 139 UnBinData(unsigned int maxpoints, const double * dataX, const DataRange & range) :; 140 FitData( range, maxpoints, dataX ),; 141 fWeighted( false ); 142 {; 143 }; 144 ; 145 ; 146 /**; 147 constructor for 2D data and a range (data are copied inside according to the given range); 148 or 1 1D data set + weight.",MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:4532,Testability,assert,assert,4532,"; 87 ; 88 /**; 89 constructor for 1D external data (data are not copied inside); 90 */; 91 UnBinData(unsigned int n, const double * dataX ) :; 92 FitData( n, dataX ),; 93 fWeighted( false ); 94 {; 95 }; 96 ; 97 /**; 98 constructor for 2D external data (data are not copied inside); 99 or 1D data with a weight (if isWeighted = true); 100 */; 101 UnBinData(unsigned int n, const double * dataX, const double * dataY,; 102 bool isWeighted = false ) :; 103 FitData( n, dataX, dataY ),; 104 fWeighted( isWeighted ); 105 {; 106 }; 107 ; 108 /**; 109 constructor for 3D external data (data are not copied inside); 110 or 2D data with a weight (if isWeighted = true); 111 */; 112 UnBinData(unsigned int n, const double * dataX, const double * dataY,; 113 const double * dataZ, bool isWeighted = false ) :; 114 FitData( n, dataX, dataY, dataZ ),; 115 fWeighted( isWeighted ); 116 {; 117 }; 118 ; 119 /**; 120 constructor for multi-dim external data (data are not copied inside); 121 Uses as argument an iterator of a list (or vector) containing the const double * of the data; 122 An example could be the std::vector<const double *>::begin; 123 In case of weighted data, the external data must have a dim+1 lists of data; 124 The passed dim refers just to the coordinate size; 125 */; 126 template<class Iterator>; 127 UnBinData(unsigned int n, unsigned int dim, Iterator dataItr,; 128 bool isWeighted = false ) :; 129 FitData( n, isWeighted ? dim + 1 : dim, dataItr ),; 130 fWeighted( isWeighted ); 131 {; 132 assert( dim >= 1 );; 133 assert( !fWeighted || dim >= 2 );; 134 }; 135 ; 136 /**; 137 constructor for 1D data and a range (data are copied inside according to the given range); 138 */; 139 UnBinData(unsigned int maxpoints, const double * dataX, const DataRange & range) :; 140 FitData( range, maxpoints, dataX ),; 141 fWeighted( false ); 142 {; 143 }; 144 ; 145 ; 146 /**; 147 constructor for 2D data and a range (data are copied inside according to the given range); 148 or 1 1D data set + weight.",MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:6716,Testability,assert,assert,6716,"nge, bool isWeighted = false) :; 163 FitData( range, maxpoints, dataX, dataY, dataZ ),; 164 fWeighted( isWeighted ); 165 {; 166 }; 167 ; 168 /**; 169 constructor for multi-dim external data and a range (data are copied inside according to the range); 170 Uses as argument an iterator of a list (or vector) containing the const double * of the data; 171 An example could be the std::vector<const double *>::begin; 172 */; 173 template<class Iterator>; 174 UnBinData( unsigned int maxpoints, unsigned int dim, Iterator dataItr, const DataRange & range, bool isWeighted = false ) :; 175 FitData( range, maxpoints, dim, dataItr ),; 176 fWeighted( isWeighted ); 177 {; 178 }; 179 ; 180 /// copy constructor; 181 UnBinData(const UnBinData &);; 182 /// assignment operator; 183 UnBinData & operator= (const UnBinData &);; 184 ; 185public:; 186 /**; 187 destructor, delete pointer to internal data or external data wrapper; 188 */; 189 ~UnBinData() override {; 190 }; 191 ; 192 /**; 193 add one dim coordinate data (unweighted); 194 */; 195 void Add(double x); 196 {; 197 assert( !fWeighted );; 198 ; 199 FitData::Add( x );; 200 }; 201 ; 202 ; 203 /**; 204 add 2-dim coordinate data; 205 can also be used to add 1-dim data with a weight; 206 */; 207 void Add(double x, double y); 208 {; 209 assert( fDim == 2 );; 210 double dataTmp[] = { x, y };; 211 ; 212 FitData::Add( dataTmp );; 213 }; 214 ; 215 /**; 216 add 3-dim coordinate data; 217 can also be used to add 2-dim data with a weight; 218 */; 219 void Add(double x, double y, double z); 220 {; 221 assert( fDim == 3 );; 222 double dataTmp[] = { x, y, z };; 223 ; 224 FitData::Add( dataTmp );; 225 }; 226 ; 227 /**; 228 add multi-dim coordinate data; 229 */; 230 void Add( const double* x ); 231 {; 232 FitData::Add( x );; 233 }; 234 ; 235 /**; 236 add multi-dim coordinate data + weight; 237 */; 238 void Add(const double *x, double w); 239 {; 240 assert( fWeighted );; 241 ; 242 std::vector<double> tmpVec(fDim);; 243 std::copy( x, x + fDim - 1, tmpVec.",MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:6935,Testability,assert,assert,6935,"nge, bool isWeighted = false) :; 163 FitData( range, maxpoints, dataX, dataY, dataZ ),; 164 fWeighted( isWeighted ); 165 {; 166 }; 167 ; 168 /**; 169 constructor for multi-dim external data and a range (data are copied inside according to the range); 170 Uses as argument an iterator of a list (or vector) containing the const double * of the data; 171 An example could be the std::vector<const double *>::begin; 172 */; 173 template<class Iterator>; 174 UnBinData( unsigned int maxpoints, unsigned int dim, Iterator dataItr, const DataRange & range, bool isWeighted = false ) :; 175 FitData( range, maxpoints, dim, dataItr ),; 176 fWeighted( isWeighted ); 177 {; 178 }; 179 ; 180 /// copy constructor; 181 UnBinData(const UnBinData &);; 182 /// assignment operator; 183 UnBinData & operator= (const UnBinData &);; 184 ; 185public:; 186 /**; 187 destructor, delete pointer to internal data or external data wrapper; 188 */; 189 ~UnBinData() override {; 190 }; 191 ; 192 /**; 193 add one dim coordinate data (unweighted); 194 */; 195 void Add(double x); 196 {; 197 assert( !fWeighted );; 198 ; 199 FitData::Add( x );; 200 }; 201 ; 202 ; 203 /**; 204 add 2-dim coordinate data; 205 can also be used to add 1-dim data with a weight; 206 */; 207 void Add(double x, double y); 208 {; 209 assert( fDim == 2 );; 210 double dataTmp[] = { x, y };; 211 ; 212 FitData::Add( dataTmp );; 213 }; 214 ; 215 /**; 216 add 3-dim coordinate data; 217 can also be used to add 2-dim data with a weight; 218 */; 219 void Add(double x, double y, double z); 220 {; 221 assert( fDim == 3 );; 222 double dataTmp[] = { x, y, z };; 223 ; 224 FitData::Add( dataTmp );; 225 }; 226 ; 227 /**; 228 add multi-dim coordinate data; 229 */; 230 void Add( const double* x ); 231 {; 232 FitData::Add( x );; 233 }; 234 ; 235 /**; 236 add multi-dim coordinate data + weight; 237 */; 238 void Add(const double *x, double w); 239 {; 240 assert( fWeighted );; 241 ; 242 std::vector<double> tmpVec(fDim);; 243 std::copy( x, x + fDim - 1, tmpVec.",MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:7197,Testability,assert,assert,7197,"nge, bool isWeighted = false) :; 163 FitData( range, maxpoints, dataX, dataY, dataZ ),; 164 fWeighted( isWeighted ); 165 {; 166 }; 167 ; 168 /**; 169 constructor for multi-dim external data and a range (data are copied inside according to the range); 170 Uses as argument an iterator of a list (or vector) containing the const double * of the data; 171 An example could be the std::vector<const double *>::begin; 172 */; 173 template<class Iterator>; 174 UnBinData( unsigned int maxpoints, unsigned int dim, Iterator dataItr, const DataRange & range, bool isWeighted = false ) :; 175 FitData( range, maxpoints, dim, dataItr ),; 176 fWeighted( isWeighted ); 177 {; 178 }; 179 ; 180 /// copy constructor; 181 UnBinData(const UnBinData &);; 182 /// assignment operator; 183 UnBinData & operator= (const UnBinData &);; 184 ; 185public:; 186 /**; 187 destructor, delete pointer to internal data or external data wrapper; 188 */; 189 ~UnBinData() override {; 190 }; 191 ; 192 /**; 193 add one dim coordinate data (unweighted); 194 */; 195 void Add(double x); 196 {; 197 assert( !fWeighted );; 198 ; 199 FitData::Add( x );; 200 }; 201 ; 202 ; 203 /**; 204 add 2-dim coordinate data; 205 can also be used to add 1-dim data with a weight; 206 */; 207 void Add(double x, double y); 208 {; 209 assert( fDim == 2 );; 210 double dataTmp[] = { x, y };; 211 ; 212 FitData::Add( dataTmp );; 213 }; 214 ; 215 /**; 216 add 3-dim coordinate data; 217 can also be used to add 2-dim data with a weight; 218 */; 219 void Add(double x, double y, double z); 220 {; 221 assert( fDim == 3 );; 222 double dataTmp[] = { x, y, z };; 223 ; 224 FitData::Add( dataTmp );; 225 }; 226 ; 227 /**; 228 add multi-dim coordinate data; 229 */; 230 void Add( const double* x ); 231 {; 232 FitData::Add( x );; 233 }; 234 ; 235 /**; 236 add multi-dim coordinate data + weight; 237 */; 238 void Add(const double *x, double w); 239 {; 240 assert( fWeighted );; 241 ; 242 std::vector<double> tmpVec(fDim);; 243 std::copy( x, x + fDim - 1, tmpVec.",MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:7547,Testability,assert,assert,7547,"nge, bool isWeighted = false) :; 163 FitData( range, maxpoints, dataX, dataY, dataZ ),; 164 fWeighted( isWeighted ); 165 {; 166 }; 167 ; 168 /**; 169 constructor for multi-dim external data and a range (data are copied inside according to the range); 170 Uses as argument an iterator of a list (or vector) containing the const double * of the data; 171 An example could be the std::vector<const double *>::begin; 172 */; 173 template<class Iterator>; 174 UnBinData( unsigned int maxpoints, unsigned int dim, Iterator dataItr, const DataRange & range, bool isWeighted = false ) :; 175 FitData( range, maxpoints, dim, dataItr ),; 176 fWeighted( isWeighted ); 177 {; 178 }; 179 ; 180 /// copy constructor; 181 UnBinData(const UnBinData &);; 182 /// assignment operator; 183 UnBinData & operator= (const UnBinData &);; 184 ; 185public:; 186 /**; 187 destructor, delete pointer to internal data or external data wrapper; 188 */; 189 ~UnBinData() override {; 190 }; 191 ; 192 /**; 193 add one dim coordinate data (unweighted); 194 */; 195 void Add(double x); 196 {; 197 assert( !fWeighted );; 198 ; 199 FitData::Add( x );; 200 }; 201 ; 202 ; 203 /**; 204 add 2-dim coordinate data; 205 can also be used to add 1-dim data with a weight; 206 */; 207 void Add(double x, double y); 208 {; 209 assert( fDim == 2 );; 210 double dataTmp[] = { x, y };; 211 ; 212 FitData::Add( dataTmp );; 213 }; 214 ; 215 /**; 216 add 3-dim coordinate data; 217 can also be used to add 2-dim data with a weight; 218 */; 219 void Add(double x, double y, double z); 220 {; 221 assert( fDim == 3 );; 222 double dataTmp[] = { x, y, z };; 223 ; 224 FitData::Add( dataTmp );; 225 }; 226 ; 227 /**; 228 add multi-dim coordinate data; 229 */; 230 void Add( const double* x ); 231 {; 232 FitData::Add( x );; 233 }; 234 ; 235 /**; 236 add multi-dim coordinate data + weight; 237 */; 238 void Add(const double *x, double w); 239 {; 240 assert( fWeighted );; 241 ; 242 std::vector<double> tmpVec(fDim);; 243 std::copy( x, x + fDim - 1, tmpVec.",MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:7842,Testability,assert,assert,7842,"dinate data; 205 can also be used to add 1-dim data with a weight; 206 */; 207 void Add(double x, double y); 208 {; 209 assert( fDim == 2 );; 210 double dataTmp[] = { x, y };; 211 ; 212 FitData::Add( dataTmp );; 213 }; 214 ; 215 /**; 216 add 3-dim coordinate data; 217 can also be used to add 2-dim data with a weight; 218 */; 219 void Add(double x, double y, double z); 220 {; 221 assert( fDim == 3 );; 222 double dataTmp[] = { x, y, z };; 223 ; 224 FitData::Add( dataTmp );; 225 }; 226 ; 227 /**; 228 add multi-dim coordinate data; 229 */; 230 void Add( const double* x ); 231 {; 232 FitData::Add( x );; 233 }; 234 ; 235 /**; 236 add multi-dim coordinate data + weight; 237 */; 238 void Add(const double *x, double w); 239 {; 240 assert( fWeighted );; 241 ; 242 std::vector<double> tmpVec(fDim);; 243 std::copy( x, x + fDim - 1, tmpVec.begin() );; 244 tmpVec[fDim-1] = w;; 245 ; 246 FitData::Add( &tmpVec.front() );; 247 }; 248 ; 249 /**; 250 return weight; 251 */; 252 double Weight( unsigned int ipoint ) const; 253 {; 254 assert( ipoint < fNPoints );; 255 ; 256 if ( !fWeighted ) return 1.0;; 257 return *GetCoordComponent(ipoint, fDim-1);; 258 }; 259 ; 260 const double * WeightsPtr( unsigned int ipoint ) const; 261 {; 262 assert( ipoint < fNPoints );; 263 ; 264 if ( !fWeighted ){; 265 MATH_ERROR_MSG(""UnBinData::WeightsPtr"",""The function is unweighted!"");; 266 return nullptr;; 267 }; 268 return GetCoordComponent(ipoint, fDim-1);; 269 }; 270 ; 271 ; 272 /**; 273 return coordinate data dimension; 274 */; 275 unsigned int NDim() const; 276 { return fWeighted ? fDim -1 : fDim; }; 277 ; 278 bool IsWeighted() const; 279 {; 280 return fWeighted;; 281 }; 282 ; 283 void Append( unsigned int newPoints, unsigned int dim = 1, bool isWeighted = false ); 284 {; 285 assert( !fWrapped );; 286 ; 287 fWeighted = isWeighted;; 288 ; 289 FitData::Append( newPoints, dim );; 290 }; 291 ; 292private:; 293 bool fWeighted;; 294 ; 295};; 296 ; 297 ; 298 } // end namespace Fit; 299 ; 300} // end namespace R",MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:8045,Testability,assert,assert,8045,"; 232 FitData::Add( x );; 233 }; 234 ; 235 /**; 236 add multi-dim coordinate data + weight; 237 */; 238 void Add(const double *x, double w); 239 {; 240 assert( fWeighted );; 241 ; 242 std::vector<double> tmpVec(fDim);; 243 std::copy( x, x + fDim - 1, tmpVec.begin() );; 244 tmpVec[fDim-1] = w;; 245 ; 246 FitData::Add( &tmpVec.front() );; 247 }; 248 ; 249 /**; 250 return weight; 251 */; 252 double Weight( unsigned int ipoint ) const; 253 {; 254 assert( ipoint < fNPoints );; 255 ; 256 if ( !fWeighted ) return 1.0;; 257 return *GetCoordComponent(ipoint, fDim-1);; 258 }; 259 ; 260 const double * WeightsPtr( unsigned int ipoint ) const; 261 {; 262 assert( ipoint < fNPoints );; 263 ; 264 if ( !fWeighted ){; 265 MATH_ERROR_MSG(""UnBinData::WeightsPtr"",""The function is unweighted!"");; 266 return nullptr;; 267 }; 268 return GetCoordComponent(ipoint, fDim-1);; 269 }; 270 ; 271 ; 272 /**; 273 return coordinate data dimension; 274 */; 275 unsigned int NDim() const; 276 { return fWeighted ? fDim -1 : fDim; }; 277 ; 278 bool IsWeighted() const; 279 {; 280 return fWeighted;; 281 }; 282 ; 283 void Append( unsigned int newPoints, unsigned int dim = 1, bool isWeighted = false ); 284 {; 285 assert( !fWrapped );; 286 ; 287 fWeighted = isWeighted;; 288 ; 289 FitData::Append( newPoints, dim );; 290 }; 291 ; 292private:; 293 bool fWeighted;; 294 ; 295};; 296 ; 297 ; 298 } // end namespace Fit; 299 ; 300} // end namespace ROOT; 301 ; 302 ; 303 ; 304#endif /* ROOT_Fit_UnBinData */; Error.h; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; FitData.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; ROOT::Fit::DataRangeclass describing the range in the coordinates it supports multiple range in a coordinate.Definition DataRange.h:35; ROOT::Fit::FitDataBase class for all the fit data types: Stores the coordinates and the DataOptions.Definition FitData.h:56; ROOT::Fit::FitData::Addvoid Add(double x)add one dim data with only coordinate and valuesDefinition FitData.h:254; ROOT::",MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:8584,Testability,assert,assert,8584,"; 232 FitData::Add( x );; 233 }; 234 ; 235 /**; 236 add multi-dim coordinate data + weight; 237 */; 238 void Add(const double *x, double w); 239 {; 240 assert( fWeighted );; 241 ; 242 std::vector<double> tmpVec(fDim);; 243 std::copy( x, x + fDim - 1, tmpVec.begin() );; 244 tmpVec[fDim-1] = w;; 245 ; 246 FitData::Add( &tmpVec.front() );; 247 }; 248 ; 249 /**; 250 return weight; 251 */; 252 double Weight( unsigned int ipoint ) const; 253 {; 254 assert( ipoint < fNPoints );; 255 ; 256 if ( !fWeighted ) return 1.0;; 257 return *GetCoordComponent(ipoint, fDim-1);; 258 }; 259 ; 260 const double * WeightsPtr( unsigned int ipoint ) const; 261 {; 262 assert( ipoint < fNPoints );; 263 ; 264 if ( !fWeighted ){; 265 MATH_ERROR_MSG(""UnBinData::WeightsPtr"",""The function is unweighted!"");; 266 return nullptr;; 267 }; 268 return GetCoordComponent(ipoint, fDim-1);; 269 }; 270 ; 271 ; 272 /**; 273 return coordinate data dimension; 274 */; 275 unsigned int NDim() const; 276 { return fWeighted ? fDim -1 : fDim; }; 277 ; 278 bool IsWeighted() const; 279 {; 280 return fWeighted;; 281 }; 282 ; 283 void Append( unsigned int newPoints, unsigned int dim = 1, bool isWeighted = false ); 284 {; 285 assert( !fWrapped );; 286 ; 287 fWeighted = isWeighted;; 288 ; 289 FitData::Append( newPoints, dim );; 290 }; 291 ; 292private:; 293 bool fWeighted;; 294 ; 295};; 296 ; 297 ; 298 } // end namespace Fit; 299 ; 300} // end namespace ROOT; 301 ; 302 ; 303 ; 304#endif /* ROOT_Fit_UnBinData */; Error.h; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; FitData.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; ROOT::Fit::DataRangeclass describing the range in the coordinates it supports multiple range in a coordinate.Definition DataRange.h:35; ROOT::Fit::FitDataBase class for all the fit data types: Stores the coordinates and the DataOptions.Definition FitData.h:56; ROOT::Fit::FitData::Addvoid Add(double x)add one dim data with only coordinate and valuesDefinition FitData.h:254; ROOT::",MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/UnBinData_8h_source.html:14751,Usability,simpl,simple,14751,"of point and max number of points (to pre-allocate vector)Definition UnBinData.h:54; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int n, unsigned int dim, Iterator dataItr, bool isWeighted=false)constructor for multi-dim external data (data are not copied inside) Uses as argument an iterator of ...Definition UnBinData.h:127; ROOT::Fit::UnBinData::Addvoid Add(const double *x)add multi-dim coordinate dataDefinition UnBinData.h:230; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int maxpoints, const double *dataX, const double *dataY, const double *dataZ, const DataRange &range, bool isWeighted=false)constructor for 3D data and a range (data are copied inside according to the given range) or a 2D dat...Definition UnBinData.h:161; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int maxpoints, const double *dataX, const double *dataY, const DataRange &range, bool isWeighted=false)constructor for 2D data and a range (data are copied inside according to the given range) or 1 1D dat...Definition UnBinData.h:150; ROOT::Fit::UnBinData::UnBinDataUnBinData(unsigned int n, const double *dataX, const double *dataY, bool isWeighted=false)constructor for 2D external data (data are not copied inside) or 1D data with a weight (if isWeighted...Definition UnBinData.h:101; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::Fit::DataOptionsDataOptions : simple structure holding the options on how the data are filled.Definition DataOptions.h:28. mathmathcoreincFitUnBinData.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:40 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/UnBinData_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/UnBinData_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:2272,Availability,error,errors,2272,"unctions needed by mathcore; 43 */; 44 namespace Util {; 45 ; 46 /**; 47 Utility function for conversion to strings; 48 */; 49 template <class T>; 50 std::string ToString(const T &val); 51 {; 52 std::ostringstream buf;; 53 buf << val;; 54 ; 55 std::string ret = buf.str();; 56 return ret;; 57 }; 58 ; 59 /// safe evaluation of log(x) with a protections against negative or zero argument to the log; 60 /// smooth linear extrapolation below function values smaller than epsilon; 61 /// (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; 78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that supports index access from a *contiguous* block of memory,; 84 /// compilers such as gcc, clang and icc can auto-vectorise the accumulation. This happens by cycling; 85 /// through the internal accumulators based on the value of ""`index % N`"", so `N` accumulators can be filled from a block; 86 /// of `N` numbers in a single instruction.; 87 ///; 88 /// The usage of multiple accumulators might slightly increase the precision in comparison to the single-accumulator version; 89 /// with `N = 1`.; 90 /// This depends on the order and magnitude of the numbers bei",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:2450,Availability,error,errors,2450,"tringstream buf;; 53 buf << val;; 54 ; 55 std::string ret = buf.str();; 56 return ret;; 57 }; 58 ; 59 /// safe evaluation of log(x) with a protections against negative or zero argument to the log; 60 /// smooth linear extrapolation below function values smaller than epsilon; 61 /// (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; 78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that supports index access from a *contiguous* block of memory,; 84 /// compilers such as gcc, clang and icc can auto-vectorise the accumulation. This happens by cycling; 85 /// through the internal accumulators based on the value of ""`index % N`"", so `N` accumulators can be filled from a block; 86 /// of `N` numbers in a single instruction.; 87 ///; 88 /// The usage of multiple accumulators might slightly increase the precision in comparison to the single-accumulator version; 89 /// with `N = 1`.; 90 /// This depends on the order and magnitude of the numbers being accumulated. Therefore, in rare cases, the accumulation; 91 /// result can change *in dependence of N*, even when the data are identical.; 92 /// The magnitude of such differences is well below the pr",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:8778,Availability,avail,available,8778,"ting_point<typename Container_t::value_type>::value,; 197 ""Container does not hold floating-point values."");; 198 for (std::size_t i=0; i < inputs.size(); ++i) {; 199 AddIndexed(inputs[i], i);; 200 }; 201 }; 202 ; 203 ; 204 /// Iterate over a range and return an instance of a KahanSum.; 205 ///; 206 /// See Add(Iterator,Iterator) for details.; 207 /// \param[in] begin Beginning of a range.; 208 /// \param[in] end End of the range.; 209 /// \param[in] initialValue Optional initial value.; 210 template <class Iterator>; 211 static KahanSum<T, N> Accumulate(Iterator begin, Iterator end,; 212 T initialValue = T{}) {; 213 KahanSum<T, N> theSum(initialValue);; 214 theSum.Add(begin, end);; 215 ; 216 return theSum;; 217 }; 218 ; 219 ; 220 /// Add `input` to the sum.; 221 ///; 222 /// Particularly helpful when filling from a for loop.; 223 /// This function can be inlined and auto-vectorised if; 224 /// the index parameter is used to enumerate *consecutive* fills.; 225 /// Use Add() or Accumulate() when no index is available.; 226 /// \param[in] input Value to accumulate.; 227 /// \param[in] index Index of the value. Determines internal accumulator that this; 228 /// value is added to. Make sure that consecutive fills have consecutive indices; 229 /// to make a loop auto-vectorisable. The actual value of the index does not matter,; 230 /// as long as it is consecutive.; 231 void AddIndexed(T input, std::size_t index) {; 232 const unsigned int i = index % N;; 233 const T y = input - fCarry[i];; 234 const T t = fSum[i] + y;; 235 fCarry[i] = (t - fSum[i]) - y;; 236 fSum[i] = t;; 237 }; 238 ; 239 /// \return Compensated sum.; 240 T Sum() const {; 241 return std::accumulate(std::begin(fSum), std::end(fSum), 0.);; 242 }; 243 ; 244 /// \return Compensated sum.; 245 T Result() const {; 246 return Sum();; 247 }; 248 ; 249 /// \return The sum used for compensation.; 250 T Carry() const {; 251 return std::accumulate(std::begin(fCarry), std::end(fCarry), 0.);; 252 }; 253 ; 254 /// Add `a",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:14842,Availability,error,error,14842,"LineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; ROOT::Math::KahanSumThe Kahan summation is a compensated summation algorithm, which significantly reduces numerical error...Definition Util.h:122; ROOT::Math::KahanSum::SumT Sum() constDefinition Util.h:240; ROOT::Math::KahanSum::operator==bool operator==(KahanSum< U, M > const &other) constDefinition Util.h:305; ROOT::Math::KahanSum::operator-KahanSum< T, N > operator-()Definition Util.h:299; ROOT::Math::KahanSum::Accumulatestatic KahanSum< T, N > Accumulate(Iterator begin, Iterator end, T initialValue=T{})Iterate over a range and return an instance of a KahanSum.Definition Util.h:211; ROOT::Math::KahanSum::ResultT Result() constDefinition Util.h:245; ROOT::Math::KahanSum::Addvoid Add(Iterator begin, Iterator end)Accumulate from a range denoted by iterators.Definition Util.h:180; ROOT::Math::KahanSum::Addvoid Add(const Container_t &inputs)Fill from a container that supports index access.Definition Util.h:195; ROOT::Math::KahanSum::KahanSumKahanSum(KahanSum< T, M > const &other)Constructor to create a KahanSum from another KahanSum with a di",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:2254,Energy Efficiency,reduce,reduces,2254,"unctions needed by mathcore; 43 */; 44 namespace Util {; 45 ; 46 /**; 47 Utility function for conversion to strings; 48 */; 49 template <class T>; 50 std::string ToString(const T &val); 51 {; 52 std::ostringstream buf;; 53 buf << val;; 54 ; 55 std::string ret = buf.str();; 56 return ret;; 57 }; 58 ; 59 /// safe evaluation of log(x) with a protections against negative or zero argument to the log; 60 /// smooth linear extrapolation below function values smaller than epsilon; 61 /// (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; 78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that supports index access from a *contiguous* block of memory,; 84 /// compilers such as gcc, clang and icc can auto-vectorise the accumulation. This happens by cycling; 85 /// through the internal accumulators based on the value of ""`index % N`"", so `N` accumulators can be filled from a block; 86 /// of `N` numbers in a single instruction.; 87 ///; 88 /// The usage of multiple accumulators might slightly increase the precision in comparison to the single-accumulator version; 89 /// with `N = 1`.; 90 /// This depends on the order and magnitude of the numbers bei",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:14824,Energy Efficiency,reduce,reduces,14824,"LineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; ROOT::Math::KahanSumThe Kahan summation is a compensated summation algorithm, which significantly reduces numerical error...Definition Util.h:122; ROOT::Math::KahanSum::SumT Sum() constDefinition Util.h:240; ROOT::Math::KahanSum::operator==bool operator==(KahanSum< U, M > const &other) constDefinition Util.h:305; ROOT::Math::KahanSum::operator-KahanSum< T, N > operator-()Definition Util.h:299; ROOT::Math::KahanSum::Accumulatestatic KahanSum< T, N > Accumulate(Iterator begin, Iterator end, T initialValue=T{})Iterate over a range and return an instance of a KahanSum.Definition Util.h:211; ROOT::Math::KahanSum::ResultT Result() constDefinition Util.h:245; ROOT::Math::KahanSum::Addvoid Add(Iterator begin, Iterator end)Accumulate from a range denoted by iterators.Definition Util.h:180; ROOT::Math::KahanSum::Addvoid Add(const Container_t &inputs)Fill from a container that supports index access.Definition Util.h:195; ROOT::Math::KahanSum::KahanSumKahanSum(KahanSum< T, M > const &other)Constructor to create a KahanSum from another KahanSum with a di",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:1006,Integrability,interface,interfaces,1006,"; 2// Author: L. Moneta Tue Nov 14 15:44:38 2006; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Utility functions for all ROOT Math classes; 12 ; 13#ifndef ROOT_Math_Util; 14#define ROOT_Math_Util; 15 ; 16#include <string>; 17#include <sstream>; 18 ; 19#include <cmath>; 20#include <limits>; 21#include <numeric>; 22 ; 23 ; 24// This can be protected against by defining ROOT_Math_VecTypes; 25// This is only used for the R__HAS_VECCORE define; 26// and a single VecCore function in EvalLog; 27#ifndef ROOT_Math_VecTypes; 28#include ""Types.h""; 29#endif; 30 ; 31 ; 32// for defining unused variables in the interfaces; 33// and have still them in the documentation; 34#define MATH_UNUSED(var) (void)var; 35 ; 36 ; 37namespace ROOT {; 38 ; 39 namespace Math {; 40 ; 41 /**; 42 namespace defining Utility functions needed by mathcore; 43 */; 44 namespace Util {; 45 ; 46 /**; 47 Utility function for conversion to strings; 48 */; 49 template <class T>; 50 std::string ToString(const T &val); 51 {; 52 std::ostringstream buf;; 53 buf << val;; 54 ; 55 std::string ret = buf.str();; 56 return ret;; 57 }; 58 ; 59 /// safe evaluation of log(x) with a protections against negative or zero argument to the log; 60 /// smooth linear extrapolation below function values smaller than epsilon; 61 /// (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a comp",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:3150,Integrability,depend,depends,3150,"he Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; 78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that supports index access from a *contiguous* block of memory,; 84 /// compilers such as gcc, clang and icc can auto-vectorise the accumulation. This happens by cycling; 85 /// through the internal accumulators based on the value of ""`index % N`"", so `N` accumulators can be filled from a block; 86 /// of `N` numbers in a single instruction.; 87 ///; 88 /// The usage of multiple accumulators might slightly increase the precision in comparison to the single-accumulator version; 89 /// with `N = 1`.; 90 /// This depends on the order and magnitude of the numbers being accumulated. Therefore, in rare cases, the accumulation; 91 /// result can change *in dependence of N*, even when the data are identical.; 92 /// The magnitude of such differences is well below the precision of the floating point type, and will therefore mostly show; 93 /// in the compensation sum(see Carry()). Increasing the number of accumulators therefore only makes sense to; 94 /// speed up the accumulation, but not to increase precision.; 95 ///; 96 /// \param T The type of the values to be accumulated.; 97 /// \param N Number of accumulators. Defaults to 1. Ideal values are the widths of a vector register on the relevant architecture.; 98 /// Depending on the instruction set, good values are:; 99 /// - AVX2-float: 8; 100 /// - AVX2-double: 4; 101 /// - AVX512-float: 16; 102 /// - AVX512-double: 8; 103 ///; 104 /// ### Examples; 105 ///; 106 /// ~~~{.cpp}; 107 /// std::vector<double> numbers(1000);; 108 /// for (std::size_t i=0; i<1000; ++i) {; 109 ///",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:3292,Integrability,depend,dependence,3292,"78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that supports index access from a *contiguous* block of memory,; 84 /// compilers such as gcc, clang and icc can auto-vectorise the accumulation. This happens by cycling; 85 /// through the internal accumulators based on the value of ""`index % N`"", so `N` accumulators can be filled from a block; 86 /// of `N` numbers in a single instruction.; 87 ///; 88 /// The usage of multiple accumulators might slightly increase the precision in comparison to the single-accumulator version; 89 /// with `N = 1`.; 90 /// This depends on the order and magnitude of the numbers being accumulated. Therefore, in rare cases, the accumulation; 91 /// result can change *in dependence of N*, even when the data are identical.; 92 /// The magnitude of such differences is well below the precision of the floating point type, and will therefore mostly show; 93 /// in the compensation sum(see Carry()). Increasing the number of accumulators therefore only makes sense to; 94 /// speed up the accumulation, but not to increase precision.; 95 ///; 96 /// \param T The type of the values to be accumulated.; 97 /// \param N Number of accumulators. Defaults to 1. Ideal values are the widths of a vector register on the relevant architecture.; 98 /// Depending on the instruction set, good values are:; 99 /// - AVX2-float: 8; 100 /// - AVX2-double: 4; 101 /// - AVX512-float: 16; 102 /// - AVX512-double: 8; 103 ///; 104 /// ### Examples; 105 ///; 106 /// ~~~{.cpp}; 107 /// std::vector<double> numbers(1000);; 108 /// for (std::size_t i=0; i<1000; ++i) {; 109 /// numbers[i] = rand();; 110 /// }; 111 ///; 112 /// ROOT::Math::KahanSum<double, 4> k;; 113 /// k.Add(num",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:989,Modifiability,variab,variables,989,"; 2// Author: L. Moneta Tue Nov 14 15:44:38 2006; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Utility functions for all ROOT Math classes; 12 ; 13#ifndef ROOT_Math_Util; 14#define ROOT_Math_Util; 15 ; 16#include <string>; 17#include <sstream>; 18 ; 19#include <cmath>; 20#include <limits>; 21#include <numeric>; 22 ; 23 ; 24// This can be protected against by defining ROOT_Math_VecTypes; 25// This is only used for the R__HAS_VECCORE define; 26// and a single VecCore function in EvalLog; 27#ifndef ROOT_Math_VecTypes; 28#include ""Types.h""; 29#endif; 30 ; 31 ; 32// for defining unused variables in the interfaces; 33// and have still them in the documentation; 34#define MATH_UNUSED(var) (void)var; 35 ; 36 ; 37namespace ROOT {; 38 ; 39 namespace Math {; 40 ; 41 /**; 42 namespace defining Utility functions needed by mathcore; 43 */; 44 namespace Util {; 45 ; 46 /**; 47 Utility function for conversion to strings; 48 */; 49 template <class T>; 50 std::string ToString(const T &val); 51 {; 52 std::ostringstream buf;; 53 buf << val;; 54 ; 55 std::string ret = buf.str();; 56 return ret;; 57 }; 58 ; 59 /// safe evaluation of log(x) with a protections against negative or zero argument to the log; 60 /// smooth linear extrapolation below function values smaller than epsilon; 61 /// (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a comp",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:2421,Modifiability,variab,variable,2421,"tringstream buf;; 53 buf << val;; 54 ; 55 std::string ret = buf.str();; 56 return ret;; 57 }; 58 ; 59 /// safe evaluation of log(x) with a protections against negative or zero argument to the log; 60 /// smooth linear extrapolation below function values smaller than epsilon; 61 /// (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; 78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that supports index access from a *contiguous* block of memory,; 84 /// compilers such as gcc, clang and icc can auto-vectorise the accumulation. This happens by cycling; 85 /// through the internal accumulators based on the value of ""`index % N`"", so `N` accumulators can be filled from a block; 86 /// of `N` numbers in a single instruction.; 87 ///; 88 /// The usage of multiple accumulators might slightly increase the precision in comparison to the single-accumulator version; 89 /// with `N = 1`.; 90 /// This depends on the order and magnitude of the numbers being accumulated. Therefore, in rare cases, the accumulation; 91 /// result can change *in dependence of N*, even when the data are identical.; 92 /// The magnitude of such differences is well below the pr",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:10462,Performance,perform,performance,10462,"::accumulate(std::begin(fSum), std::end(fSum), 0.);; 242 }; 243 ; 244 /// \return Compensated sum.; 245 T Result() const {; 246 return Sum();; 247 }; 248 ; 249 /// \return The sum used for compensation.; 250 T Carry() const {; 251 return std::accumulate(std::begin(fCarry), std::end(fCarry), 0.);; 252 }; 253 ; 254 /// Add `arg` into accumulator. Does not vectorise.; 255 KahanSum<T, N>& operator+=(T arg) {; 256 Add(arg);; 257 return *this;; 258 }; 259 ; 260 /// Add other KahanSum into accumulator. Does not vectorise.; 261 ///; 262 /// Based on KahanIncrement from:; 263 /// Y. Tian, S. Tatikonda and B. Reinwald, ""Scalable and Numerically Stable Descriptive Statistics in SystemML,"" 2012 IEEE 28th International Conference on Data Engineering, 2012, pp. 1351-1359, doi: 10.1109/ICDE.2012.12.; 264 /// Note that while Tian et al. add the carry in the first step, we subtract; 265 /// the carry, in accordance with the Add(Indexed) implementation(s) above.; 266 /// This is purely an implementation choice that has no impact on performance.; 267 ///; 268 /// \note Take care when using += (and -=) to add other KahanSums into a zero-initialized; 269 /// KahanSum. The operator behaves correctly in this case, but the result may be slightly; 270 /// off if you expect 0 + x to yield exactly x (where 0 is the zero-initialized KahanSum; 271 /// and x another KahanSum). In particular, x's carry term may get lost. This doesn't; 272 /// just happen with zero-initialized KahanSums; see the SubtractWithABitTooSmallCarry; 273 /// test case in the testKahan unittest for other examples. This behavior is internally; 274 /// consistent: the carry also gets lost if you switch the operands and it also happens with; 275 /// other KahanSum operators.; 276 template<typename U, unsigned int M>; 277 KahanSum<T, N>& operator+=(const KahanSum<U, M>& other) {; 278 U corrected_arg_sum = other.Sum() - (fCarry[0] + other.Carry());; 279 U sum = fSum[0] + corrected_arg_sum;; 280 U correction = (sum - fSum[0]) - ",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:1511,Safety,safe,safe,1511,"tream>; 18 ; 19#include <cmath>; 20#include <limits>; 21#include <numeric>; 22 ; 23 ; 24// This can be protected against by defining ROOT_Math_VecTypes; 25// This is only used for the R__HAS_VECCORE define; 26// and a single VecCore function in EvalLog; 27#ifndef ROOT_Math_VecTypes; 28#include ""Types.h""; 29#endif; 30 ; 31 ; 32// for defining unused variables in the interfaces; 33// and have still them in the documentation; 34#define MATH_UNUSED(var) (void)var; 35 ; 36 ; 37namespace ROOT {; 38 ; 39 namespace Math {; 40 ; 41 /**; 42 namespace defining Utility functions needed by mathcore; 43 */; 44 namespace Util {; 45 ; 46 /**; 47 Utility function for conversion to strings; 48 */; 49 template <class T>; 50 std::string ToString(const T &val); 51 {; 52 std::ostringstream buf;; 53 buf << val;; 54 ; 55 std::string ret = buf.str();; 56 return ret;; 57 }; 58 ; 59 /// safe evaluation of log(x) with a protections against negative or zero argument to the log; 60 /// smooth linear extrapolation below function values smaller than epsilon; 61 /// (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; 78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:17465,Safety,safe,safe,17465,"nSum::fSumT fSum[N]Definition Util.h:315; ROOT::Math::KahanSum::KahanSumKahanSum(T initialValue=T{})Initialise the sum.Definition Util.h:126; ROOT::Math::KahanSum::KahanSumKahanSum(T initialSumValue, T initialCarryValue)Initialise with a sum value and a carry value.Definition Util.h:135; ROOT::Math::KahanSum::Addvoid Add(T x)Single-element accumulation. Will not vectorise.Definition Util.h:165; ROOT::Math::KahanSum::operator-=KahanSum< T, N > & operator-=(KahanSum< U, M > const &other)Subtract other KahanSum.Definition Util.h:290; ROOT::Math::KahanSum::KahanSumKahanSum(Iterator sumBegin, Iterator sumEnd, Iterator carryBegin, Iterator carryEnd)Initialise the sum with a pre-existing state.Definition Util.h:148; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; MathNamespace for new Math classes and functions.; ROOT::MacOSX::UtilDefinition CocoaUtils.h:22; ROOT::Math::Util::EvalLogT EvalLog(T x)safe evaluation of log(x) with a protections against negative or zero argument to the log smooth line...Definition Util.h:64; ROOT::Math::Util::ToStringstd::string ToString(const T &val)Utility function for conversion to strings.Definition Util.h:50; ROOT::Math::operator+DisplacementVector2D< CoordSystem1, U > operator+(DisplacementVector2D< CoordSystem1, U > v1, const DisplacementVector2D< CoordSystem2, U > &v2)Addition of DisplacementVector2D vectors.Definition DisplacementVector2D.h:440; ROOT::Math::operator-DisplacementVector2D< CoordSystem1, U > operator-(DisplacementVector2D< CoordSystem1, U > v1, DisplacementVector2D< CoordSystem2, U > const &v2)Difference between two DisplacementVector2D vectors.Definition DisplacementVector2D.h:453; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; Types.h; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. mathmathcoreincMathUtil.h. ROOT master - Reference Guide Gener",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:2654,Security,access,access,2654," (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; 78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that supports index access from a *contiguous* block of memory,; 84 /// compilers such as gcc, clang and icc can auto-vectorise the accumulation. This happens by cycling; 85 /// through the internal accumulators based on the value of ""`index % N`"", so `N` accumulators can be filled from a block; 86 /// of `N` numbers in a single instruction.; 87 ///; 88 /// The usage of multiple accumulators might slightly increase the precision in comparison to the single-accumulator version; 89 /// with `N = 1`.; 90 /// This depends on the order and magnitude of the numbers being accumulated. Therefore, in rare cases, the accumulation; 91 /// result can change *in dependence of N*, even when the data are identical.; 92 /// The magnitude of such differences is well below the precision of the floating point type, and will therefore mostly show; 93 /// in the compensation sum(see Carry()). Increasing the number of accumulators therefore only makes sense to; 94 /// speed up the accumulation, but not to increase precision.; 95 ///; 96 /// \param T The type ",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:6862,Security,access,access,6862,"erator>; 148 KahanSum(Iterator sumBegin, Iterator sumEnd, Iterator carryBegin, Iterator carryEnd) {; 149 assert(std::distance(sumBegin, sumEnd) == N);; 150 assert(std::distance(carryBegin, carryEnd) == N);; 151 std::copy(sumBegin, sumEnd, std::begin(fSum));; 152 std::copy(carryBegin, carryEnd, std::begin(fCarry));; 153 }; 154 ; 155 /// Constructor to create a KahanSum from another KahanSum with a different number of accumulators; 156 template <unsigned int M>; 157 KahanSum(KahanSum<T,M> const& other) {; 158 fSum[0] = other.Sum();; 159 fCarry[0] = other.Carry();; 160 std::fill(std::begin(fSum)+1, std::end(fSum), 0.);; 161 std::fill(std::begin(fCarry)+1, std::end(fCarry), 0.);; 162 }; 163 ; 164 /// Single-element accumulation. Will not vectorise.; 165 void Add(T x) {; 166 auto y = x - fCarry[0];; 167 auto t = fSum[0] + y;; 168 fCarry[0] = (t - fSum[0]) - y;; 169 fSum[0] = t;; 170 }; 171 ; 172 ; 173 /// Accumulate from a range denoted by iterators.; 174 ///; 175 /// This function will auto-vectorise with random-access iterators.; 176 /// \param[in] begin Beginning of a range. Needs to be a random access iterator for automatic; 177 /// vectorisation, because a contiguous block of memory needs to be read.; 178 /// \param[in] end End of the range.; 179 template <class Iterator>; 180 void Add(Iterator begin, Iterator end) {; 181 static_assert(std::is_floating_point<; 182 typename std::remove_reference<decltype(*begin)>::type>::value,; 183 ""Iterator needs to point to floating-point values."");; 184 const std::size_t n = std::distance(begin, end);; 185 ; 186 for (std::size_t i=0; i<n; ++i) {; 187 AddIndexed(*(begin++), i);; 188 }; 189 }; 190 ; 191 ; 192 /// Fill from a container that supports index access.; 193 /// \param[in] inputs Container with index access such as std::vector or array.; 194 template<class Container_t>; 195 void Add(const Container_t& inputs) {; 196 static_assert(std::is_floating_point<typename Container_t::value_type>::value,; 197 ""Container does not hold",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:6949,Security,access,access,6949,"0 assert(std::distance(carryBegin, carryEnd) == N);; 151 std::copy(sumBegin, sumEnd, std::begin(fSum));; 152 std::copy(carryBegin, carryEnd, std::begin(fCarry));; 153 }; 154 ; 155 /// Constructor to create a KahanSum from another KahanSum with a different number of accumulators; 156 template <unsigned int M>; 157 KahanSum(KahanSum<T,M> const& other) {; 158 fSum[0] = other.Sum();; 159 fCarry[0] = other.Carry();; 160 std::fill(std::begin(fSum)+1, std::end(fSum), 0.);; 161 std::fill(std::begin(fCarry)+1, std::end(fCarry), 0.);; 162 }; 163 ; 164 /// Single-element accumulation. Will not vectorise.; 165 void Add(T x) {; 166 auto y = x - fCarry[0];; 167 auto t = fSum[0] + y;; 168 fCarry[0] = (t - fSum[0]) - y;; 169 fSum[0] = t;; 170 }; 171 ; 172 ; 173 /// Accumulate from a range denoted by iterators.; 174 ///; 175 /// This function will auto-vectorise with random-access iterators.; 176 /// \param[in] begin Beginning of a range. Needs to be a random access iterator for automatic; 177 /// vectorisation, because a contiguous block of memory needs to be read.; 178 /// \param[in] end End of the range.; 179 template <class Iterator>; 180 void Add(Iterator begin, Iterator end) {; 181 static_assert(std::is_floating_point<; 182 typename std::remove_reference<decltype(*begin)>::type>::value,; 183 ""Iterator needs to point to floating-point values."");; 184 const std::size_t n = std::distance(begin, end);; 185 ; 186 for (std::size_t i=0; i<n; ++i) {; 187 AddIndexed(*(begin++), i);; 188 }; 189 }; 190 ; 191 ; 192 /// Fill from a container that supports index access.; 193 /// \param[in] inputs Container with index access such as std::vector or array.; 194 template<class Container_t>; 195 void Add(const Container_t& inputs) {; 196 static_assert(std::is_floating_point<typename Container_t::value_type>::value,; 197 ""Container does not hold floating-point values."");; 198 for (std::size_t i=0; i < inputs.size(); ++i) {; 199 AddIndexed(inputs[i], i);; 200 }; 201 }; 202 ; 203 ; 204 /// Iterate ",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:7556,Security,access,access,7556,"m), 0.);; 161 std::fill(std::begin(fCarry)+1, std::end(fCarry), 0.);; 162 }; 163 ; 164 /// Single-element accumulation. Will not vectorise.; 165 void Add(T x) {; 166 auto y = x - fCarry[0];; 167 auto t = fSum[0] + y;; 168 fCarry[0] = (t - fSum[0]) - y;; 169 fSum[0] = t;; 170 }; 171 ; 172 ; 173 /// Accumulate from a range denoted by iterators.; 174 ///; 175 /// This function will auto-vectorise with random-access iterators.; 176 /// \param[in] begin Beginning of a range. Needs to be a random access iterator for automatic; 177 /// vectorisation, because a contiguous block of memory needs to be read.; 178 /// \param[in] end End of the range.; 179 template <class Iterator>; 180 void Add(Iterator begin, Iterator end) {; 181 static_assert(std::is_floating_point<; 182 typename std::remove_reference<decltype(*begin)>::type>::value,; 183 ""Iterator needs to point to floating-point values."");; 184 const std::size_t n = std::distance(begin, end);; 185 ; 186 for (std::size_t i=0; i<n; ++i) {; 187 AddIndexed(*(begin++), i);; 188 }; 189 }; 190 ; 191 ; 192 /// Fill from a container that supports index access.; 193 /// \param[in] inputs Container with index access such as std::vector or array.; 194 template<class Container_t>; 195 void Add(const Container_t& inputs) {; 196 static_assert(std::is_floating_point<typename Container_t::value_type>::value,; 197 ""Container does not hold floating-point values."");; 198 for (std::size_t i=0; i < inputs.size(); ++i) {; 199 AddIndexed(inputs[i], i);; 200 }; 201 }; 202 ; 203 ; 204 /// Iterate over a range and return an instance of a KahanSum.; 205 ///; 206 /// See Add(Iterator,Iterator) for details.; 207 /// \param[in] begin Beginning of a range.; 208 /// \param[in] end End of the range.; 209 /// \param[in] initialValue Optional initial value.; 210 template <class Iterator>; 211 static KahanSum<T, N> Accumulate(Iterator begin, Iterator end,; 212 T initialValue = T{}) {; 213 KahanSum<T, N> theSum(initialValue);; 214 theSum.Add(begin, end);; 215 ; ",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:7612,Security,access,access,7612,"d(T x) {; 166 auto y = x - fCarry[0];; 167 auto t = fSum[0] + y;; 168 fCarry[0] = (t - fSum[0]) - y;; 169 fSum[0] = t;; 170 }; 171 ; 172 ; 173 /// Accumulate from a range denoted by iterators.; 174 ///; 175 /// This function will auto-vectorise with random-access iterators.; 176 /// \param[in] begin Beginning of a range. Needs to be a random access iterator for automatic; 177 /// vectorisation, because a contiguous block of memory needs to be read.; 178 /// \param[in] end End of the range.; 179 template <class Iterator>; 180 void Add(Iterator begin, Iterator end) {; 181 static_assert(std::is_floating_point<; 182 typename std::remove_reference<decltype(*begin)>::type>::value,; 183 ""Iterator needs to point to floating-point values."");; 184 const std::size_t n = std::distance(begin, end);; 185 ; 186 for (std::size_t i=0; i<n; ++i) {; 187 AddIndexed(*(begin++), i);; 188 }; 189 }; 190 ; 191 ; 192 /// Fill from a container that supports index access.; 193 /// \param[in] inputs Container with index access such as std::vector or array.; 194 template<class Container_t>; 195 void Add(const Container_t& inputs) {; 196 static_assert(std::is_floating_point<typename Container_t::value_type>::value,; 197 ""Container does not hold floating-point values."");; 198 for (std::size_t i=0; i < inputs.size(); ++i) {; 199 AddIndexed(inputs[i], i);; 200 }; 201 }; 202 ; 203 ; 204 /// Iterate over a range and return an instance of a KahanSum.; 205 ///; 206 /// See Add(Iterator,Iterator) for details.; 207 /// \param[in] begin Beginning of a range.; 208 /// \param[in] end End of the range.; 209 /// \param[in] initialValue Optional initial value.; 210 template <class Iterator>; 211 static KahanSum<T, N> Accumulate(Iterator begin, Iterator end,; 212 T initialValue = T{}) {; 213 KahanSum<T, N> theSum(initialValue);; 214 theSum.Add(begin, end);; 215 ; 216 return theSum;; 217 }; 218 ; 219 ; 220 /// Add `input` to the sum.; 221 ///; 222 /// Particularly helpful when filling from a for loop.; 223 /// Thi",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:15620,Security,access,access,15620,"_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; ROOT::Math::KahanSumThe Kahan summation is a compensated summation algorithm, which significantly reduces numerical error...Definition Util.h:122; ROOT::Math::KahanSum::SumT Sum() constDefinition Util.h:240; ROOT::Math::KahanSum::operator==bool operator==(KahanSum< U, M > const &other) constDefinition Util.h:305; ROOT::Math::KahanSum::operator-KahanSum< T, N > operator-()Definition Util.h:299; ROOT::Math::KahanSum::Accumulatestatic KahanSum< T, N > Accumulate(Iterator begin, Iterator end, T initialValue=T{})Iterate over a range and return an instance of a KahanSum.Definition Util.h:211; ROOT::Math::KahanSum::ResultT Result() constDefinition Util.h:245; ROOT::Math::KahanSum::Addvoid Add(Iterator begin, Iterator end)Accumulate from a range denoted by iterators.Definition Util.h:180; ROOT::Math::KahanSum::Addvoid Add(const Container_t &inputs)Fill from a container that supports index access.Definition Util.h:195; ROOT::Math::KahanSum::KahanSumKahanSum(KahanSum< T, M > const &other)Constructor to create a KahanSum from another KahanSum with a different number of accumulators.Definition Util.h:157; ROOT::Math::KahanSum::fCarryT fCarry[N]Definition Util.h:316; ROOT::Math::KahanSum::operator!=bool operator!=(KahanSum< U, M > const &other) constDefinition Util.h:310; ROOT::Math::KahanSum::CarryT Carry() constDefinition Util.h:250; ROOT::Math::KahanSum::AddIndexedvoid AddIndexed(T input, std::size_t index)Add input to the sum.Definition Util.h:231; ROOT::Math::KahanSum::operator+=KahanSum< T, N > & operator+=(T arg)Add arg into accumulator. Does not vectorise.Definition Util.h:255; ROOT::Math::KahanSum::operator+=KahanSum< T, N > & operator+=(const KahanSum< U, M > &other)Add other KahanSum into accumulator.Definition Util.h:277; ROOT::Math::KahanSum::fSumT fSum[N]Definition Util.h:315; ROOT::Math::KahanSum::KahanSumKaha",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:1530,Testability,log,log,1530,"tream>; 18 ; 19#include <cmath>; 20#include <limits>; 21#include <numeric>; 22 ; 23 ; 24// This can be protected against by defining ROOT_Math_VecTypes; 25// This is only used for the R__HAS_VECCORE define; 26// and a single VecCore function in EvalLog; 27#ifndef ROOT_Math_VecTypes; 28#include ""Types.h""; 29#endif; 30 ; 31 ; 32// for defining unused variables in the interfaces; 33// and have still them in the documentation; 34#define MATH_UNUSED(var) (void)var; 35 ; 36 ; 37namespace ROOT {; 38 ; 39 namespace Math {; 40 ; 41 /**; 42 namespace defining Utility functions needed by mathcore; 43 */; 44 namespace Util {; 45 ; 46 /**; 47 Utility function for conversion to strings; 48 */; 49 template <class T>; 50 std::string ToString(const T &val); 51 {; 52 std::ostringstream buf;; 53 buf << val;; 54 ; 55 std::string ret = buf.str();; 56 return ret;; 57 }; 58 ; 59 /// safe evaluation of log(x) with a protections against negative or zero argument to the log; 60 /// smooth linear extrapolation below function values smaller than epsilon; 61 /// (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; 78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:1597,Testability,log,log,1597,"tream>; 18 ; 19#include <cmath>; 20#include <limits>; 21#include <numeric>; 22 ; 23 ; 24// This can be protected against by defining ROOT_Math_VecTypes; 25// This is only used for the R__HAS_VECCORE define; 26// and a single VecCore function in EvalLog; 27#ifndef ROOT_Math_VecTypes; 28#include ""Types.h""; 29#endif; 30 ; 31 ; 32// for defining unused variables in the interfaces; 33// and have still them in the documentation; 34#define MATH_UNUSED(var) (void)var; 35 ; 36 ; 37namespace ROOT {; 38 ; 39 namespace Math {; 40 ; 41 /**; 42 namespace defining Utility functions needed by mathcore; 43 */; 44 namespace Util {; 45 ; 46 /**; 47 Utility function for conversion to strings; 48 */; 49 template <class T>; 50 std::string ToString(const T &val); 51 {; 52 std::ostringstream buf;; 53 buf << val;; 54 ; 55 std::string ret = buf.str();; 56 return ret;; 57 }; 58 ; 59 /// safe evaluation of log(x) with a protections against negative or zero argument to the log; 60 /// smooth linear extrapolation below function values smaller than epsilon; 61 /// (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; 78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:1879,Testability,log,logval,1879," EvalLog; 27#ifndef ROOT_Math_VecTypes; 28#include ""Types.h""; 29#endif; 30 ; 31 ; 32// for defining unused variables in the interfaces; 33// and have still them in the documentation; 34#define MATH_UNUSED(var) (void)var; 35 ; 36 ; 37namespace ROOT {; 38 ; 39 namespace Math {; 40 ; 41 /**; 42 namespace defining Utility functions needed by mathcore; 43 */; 44 namespace Util {; 45 ; 46 /**; 47 Utility function for conversion to strings; 48 */; 49 template <class T>; 50 std::string ToString(const T &val); 51 {; 52 std::ostringstream buf;; 53 buf << val;; 54 ; 55 std::string ret = buf.str();; 56 return ret;; 57 }; 58 ; 59 /// safe evaluation of log(x) with a protections against negative or zero argument to the log; 60 /// smooth linear extrapolation below function values smaller than epsilon; 61 /// (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; 78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that supports index access from a *contiguous* block of memory,; 84 /// compilers such as gcc, clang and icc can auto-vectorise the accumulation. This happens by cycling; 85 /// through the internal accumulators based on the value of ""`index % N`"", ",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:1939,Testability,log,log,1939," EvalLog; 27#ifndef ROOT_Math_VecTypes; 28#include ""Types.h""; 29#endif; 30 ; 31 ; 32// for defining unused variables in the interfaces; 33// and have still them in the documentation; 34#define MATH_UNUSED(var) (void)var; 35 ; 36 ; 37namespace ROOT {; 38 ; 39 namespace Math {; 40 ; 41 /**; 42 namespace defining Utility functions needed by mathcore; 43 */; 44 namespace Util {; 45 ; 46 /**; 47 Utility function for conversion to strings; 48 */; 49 template <class T>; 50 std::string ToString(const T &val); 51 {; 52 std::ostringstream buf;; 53 buf << val;; 54 ; 55 std::string ret = buf.str();; 56 return ret;; 57 }; 58 ; 59 /// safe evaluation of log(x) with a protections against negative or zero argument to the log; 60 /// smooth linear extrapolation below function values smaller than epsilon; 61 /// (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; 78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that supports index access from a *contiguous* block of memory,; 84 /// compilers such as gcc, clang and icc can auto-vectorise the accumulation. This happens by cycling; 85 /// through the internal accumulators based on the value of ""`index % N`"", ",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:1967,Testability,log,log,1967," interfaces; 33// and have still them in the documentation; 34#define MATH_UNUSED(var) (void)var; 35 ; 36 ; 37namespace ROOT {; 38 ; 39 namespace Math {; 40 ; 41 /**; 42 namespace defining Utility functions needed by mathcore; 43 */; 44 namespace Util {; 45 ; 46 /**; 47 Utility function for conversion to strings; 48 */; 49 template <class T>; 50 std::string ToString(const T &val); 51 {; 52 std::ostringstream buf;; 53 buf << val;; 54 ; 55 std::string ret = buf.str();; 56 return ret;; 57 }; 58 ; 59 /// safe evaluation of log(x) with a protections against negative or zero argument to the log; 60 /// smooth linear extrapolation below function values smaller than epsilon; 61 /// (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; 78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that supports index access from a *contiguous* block of memory,; 84 /// compilers such as gcc, clang and icc can auto-vectorise the accumulation. This happens by cycling; 85 /// through the internal accumulators based on the value of ""`index % N`"", so `N` accumulators can be filled from a block; 86 /// of `N` numbers in a single instruction.; 87 ///; 88 /// The usage of",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:1991,Testability,log,logval,1991," interfaces; 33// and have still them in the documentation; 34#define MATH_UNUSED(var) (void)var; 35 ; 36 ; 37namespace ROOT {; 38 ; 39 namespace Math {; 40 ; 41 /**; 42 namespace defining Utility functions needed by mathcore; 43 */; 44 namespace Util {; 45 ; 46 /**; 47 Utility function for conversion to strings; 48 */; 49 template <class T>; 50 std::string ToString(const T &val); 51 {; 52 std::ostringstream buf;; 53 buf << val;; 54 ; 55 std::string ret = buf.str();; 56 return ret;; 57 }; 58 ; 59 /// safe evaluation of log(x) with a protections against negative or zero argument to the log; 60 /// smooth linear extrapolation below function values smaller than epsilon; 61 /// (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; 78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that supports index access from a *contiguous* block of memory,; 84 /// compilers such as gcc, clang and icc can auto-vectorise the accumulation. This happens by cycling; 85 /// through the internal accumulators based on the value of ""`index % N`"", so `N` accumulators can be filled from a block; 86 /// of `N` numbers in a single instruction.; 87 ///; 88 /// The usage of",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:2034,Testability,log,log,2034," interfaces; 33// and have still them in the documentation; 34#define MATH_UNUSED(var) (void)var; 35 ; 36 ; 37namespace ROOT {; 38 ; 39 namespace Math {; 40 ; 41 /**; 42 namespace defining Utility functions needed by mathcore; 43 */; 44 namespace Util {; 45 ; 46 /**; 47 Utility function for conversion to strings; 48 */; 49 template <class T>; 50 std::string ToString(const T &val); 51 {; 52 std::ostringstream buf;; 53 buf << val;; 54 ; 55 std::string ret = buf.str();; 56 return ret;; 57 }; 58 ; 59 /// safe evaluation of log(x) with a protections against negative or zero argument to the log; 60 /// smooth linear extrapolation below function values smaller than epsilon; 61 /// (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; 78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that supports index access from a *contiguous* block of memory,; 84 /// compilers such as gcc, clang and icc can auto-vectorise the accumulation. This happens by cycling; 85 /// through the internal accumulators based on the value of ""`index % N`"", so `N` accumulators can be filled from a block; 86 /// of `N` numbers in a single instruction.; 87 ///; 88 /// The usage of",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:2063,Testability,log,log,2063,"unctions needed by mathcore; 43 */; 44 namespace Util {; 45 ; 46 /**; 47 Utility function for conversion to strings; 48 */; 49 template <class T>; 50 std::string ToString(const T &val); 51 {; 52 std::ostringstream buf;; 53 buf << val;; 54 ; 55 std::string ret = buf.str();; 56 return ret;; 57 }; 58 ; 59 /// safe evaluation of log(x) with a protections against negative or zero argument to the log; 60 /// smooth linear extrapolation below function values smaller than epsilon; 61 /// (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; 78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that supports index access from a *contiguous* block of memory,; 84 /// compilers such as gcc, clang and icc can auto-vectorise the accumulation. This happens by cycling; 85 /// through the internal accumulators based on the value of ""`index % N`"", so `N` accumulators can be filled from a block; 86 /// of `N` numbers in a single instruction.; 87 ///; 88 /// The usage of multiple accumulators might slightly increase the precision in comparison to the single-accumulator version; 89 /// with `N = 1`.; 90 /// This depends on the order and magnitude of the numbers bei",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:2092,Testability,log,logval,2092,"unctions needed by mathcore; 43 */; 44 namespace Util {; 45 ; 46 /**; 47 Utility function for conversion to strings; 48 */; 49 template <class T>; 50 std::string ToString(const T &val); 51 {; 52 std::ostringstream buf;; 53 buf << val;; 54 ; 55 std::string ret = buf.str();; 56 return ret;; 57 }; 58 ; 59 /// safe evaluation of log(x) with a protections against negative or zero argument to the log; 60 /// smooth linear extrapolation below function values smaller than epsilon; 61 /// (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; 78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that supports index access from a *contiguous* block of memory,; 84 /// compilers such as gcc, clang and icc can auto-vectorise the accumulation. This happens by cycling; 85 /// through the internal accumulators based on the value of ""`index % N`"", so `N` accumulators can be filled from a block; 86 /// of `N` numbers in a single instruction.; 87 ///; 88 /// The usage of multiple accumulators might slightly increase the precision in comparison to the single-accumulator version; 89 /// with `N = 1`.; 90 /// This depends on the order and magnitude of the numbers bei",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:5943,Testability,assert,assert,5943,"yValue Initialise the carry with this value.; 135 KahanSum(T initialSumValue, T initialCarryValue) {; 136 fSum[0] = initialSumValue;; 137 fCarry[0] = initialCarryValue;; 138 std::fill(std::begin(fSum)+1, std::end(fSum), 0.);; 139 std::fill(std::begin(fCarry)+1, std::end(fCarry), 0.);; 140 }; 141 ; 142 /// Initialise the sum with a pre-existing state.; 143 /// \param[in] sumBegin Begin of iterator range with values to initialise the sum with.; 144 /// \param[in] sumEnd End of iterator range with values to initialise the sum with.; 145 /// \param[in] carryBegin Begin of iterator range with values to initialise the carry with.; 146 /// \param[in] carryEnd End of iterator range with values to initialise the carry with.; 147 template<class Iterator>; 148 KahanSum(Iterator sumBegin, Iterator sumEnd, Iterator carryBegin, Iterator carryEnd) {; 149 assert(std::distance(sumBegin, sumEnd) == N);; 150 assert(std::distance(carryBegin, carryEnd) == N);; 151 std::copy(sumBegin, sumEnd, std::begin(fSum));; 152 std::copy(carryBegin, carryEnd, std::begin(fCarry));; 153 }; 154 ; 155 /// Constructor to create a KahanSum from another KahanSum with a different number of accumulators; 156 template <unsigned int M>; 157 KahanSum(KahanSum<T,M> const& other) {; 158 fSum[0] = other.Sum();; 159 fCarry[0] = other.Carry();; 160 std::fill(std::begin(fSum)+1, std::end(fSum), 0.);; 161 std::fill(std::begin(fCarry)+1, std::end(fCarry), 0.);; 162 }; 163 ; 164 /// Single-element accumulation. Will not vectorise.; 165 void Add(T x) {; 166 auto y = x - fCarry[0];; 167 auto t = fSum[0] + y;; 168 fCarry[0] = (t - fSum[0]) - y;; 169 fSum[0] = t;; 170 }; 171 ; 172 ; 173 /// Accumulate from a range denoted by iterators.; 174 ///; 175 /// This function will auto-vectorise with random-access iterators.; 176 /// \param[in] begin Beginning of a range. Needs to be a random access iterator for automatic; 177 /// vectorisation, because a contiguous block of memory needs to be read.; 178 /// \param[in] end End of th",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:5994,Testability,assert,assert,5994,"yValue Initialise the carry with this value.; 135 KahanSum(T initialSumValue, T initialCarryValue) {; 136 fSum[0] = initialSumValue;; 137 fCarry[0] = initialCarryValue;; 138 std::fill(std::begin(fSum)+1, std::end(fSum), 0.);; 139 std::fill(std::begin(fCarry)+1, std::end(fCarry), 0.);; 140 }; 141 ; 142 /// Initialise the sum with a pre-existing state.; 143 /// \param[in] sumBegin Begin of iterator range with values to initialise the sum with.; 144 /// \param[in] sumEnd End of iterator range with values to initialise the sum with.; 145 /// \param[in] carryBegin Begin of iterator range with values to initialise the carry with.; 146 /// \param[in] carryEnd End of iterator range with values to initialise the carry with.; 147 template<class Iterator>; 148 KahanSum(Iterator sumBegin, Iterator sumEnd, Iterator carryBegin, Iterator carryEnd) {; 149 assert(std::distance(sumBegin, sumEnd) == N);; 150 assert(std::distance(carryBegin, carryEnd) == N);; 151 std::copy(sumBegin, sumEnd, std::begin(fSum));; 152 std::copy(carryBegin, carryEnd, std::begin(fCarry));; 153 }; 154 ; 155 /// Constructor to create a KahanSum from another KahanSum with a different number of accumulators; 156 template <unsigned int M>; 157 KahanSum(KahanSum<T,M> const& other) {; 158 fSum[0] = other.Sum();; 159 fCarry[0] = other.Carry();; 160 std::fill(std::begin(fSum)+1, std::end(fSum), 0.);; 161 std::fill(std::begin(fCarry)+1, std::end(fCarry), 0.);; 162 }; 163 ; 164 /// Single-element accumulation. Will not vectorise.; 165 void Add(T x) {; 166 auto y = x - fCarry[0];; 167 auto t = fSum[0] + y;; 168 fCarry[0] = (t - fSum[0]) - y;; 169 fSum[0] = t;; 170 }; 171 ; 172 ; 173 /// Accumulate from a range denoted by iterators.; 174 ///; 175 /// This function will auto-vectorise with random-access iterators.; 176 /// \param[in] begin Beginning of a range. Needs to be a random access iterator for automatic; 177 /// vectorisation, because a contiguous block of memory needs to be read.; 178 /// \param[in] end End of th",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:10960,Testability,test,test,10960,"r. Does not vectorise.; 261 ///; 262 /// Based on KahanIncrement from:; 263 /// Y. Tian, S. Tatikonda and B. Reinwald, ""Scalable and Numerically Stable Descriptive Statistics in SystemML,"" 2012 IEEE 28th International Conference on Data Engineering, 2012, pp. 1351-1359, doi: 10.1109/ICDE.2012.12.; 264 /// Note that while Tian et al. add the carry in the first step, we subtract; 265 /// the carry, in accordance with the Add(Indexed) implementation(s) above.; 266 /// This is purely an implementation choice that has no impact on performance.; 267 ///; 268 /// \note Take care when using += (and -=) to add other KahanSums into a zero-initialized; 269 /// KahanSum. The operator behaves correctly in this case, but the result may be slightly; 270 /// off if you expect 0 + x to yield exactly x (where 0 is the zero-initialized KahanSum; 271 /// and x another KahanSum). In particular, x's carry term may get lost. This doesn't; 272 /// just happen with zero-initialized KahanSums; see the SubtractWithABitTooSmallCarry; 273 /// test case in the testKahan unittest for other examples. This behavior is internally; 274 /// consistent: the carry also gets lost if you switch the operands and it also happens with; 275 /// other KahanSum operators.; 276 template<typename U, unsigned int M>; 277 KahanSum<T, N>& operator+=(const KahanSum<U, M>& other) {; 278 U corrected_arg_sum = other.Sum() - (fCarry[0] + other.Carry());; 279 U sum = fSum[0] + corrected_arg_sum;; 280 U correction = (sum - fSum[0]) - corrected_arg_sum;; 281 fSum[0] = sum;; 282 fCarry[0] = correction;; 283 return *this;; 284 }; 285 ; 286 /// Subtract other KahanSum. Does not vectorise.; 287 ///; 288 /// Based on KahanIncrement from: Tian et al., 2012 (see operator+= documentation).; 289 template<typename U, unsigned int M>; 290 KahanSum<T, N>& operator-=(KahanSum<U, M> const& other) {; 291 U corrected_arg_sum = -other.Sum() - (fCarry[0] - other.Carry());; 292 U sum = fSum[0] + corrected_arg_sum;; 293 U correction = (sum - f",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:10977,Testability,test,testKahan,10977,"r. Does not vectorise.; 261 ///; 262 /// Based on KahanIncrement from:; 263 /// Y. Tian, S. Tatikonda and B. Reinwald, ""Scalable and Numerically Stable Descriptive Statistics in SystemML,"" 2012 IEEE 28th International Conference on Data Engineering, 2012, pp. 1351-1359, doi: 10.1109/ICDE.2012.12.; 264 /// Note that while Tian et al. add the carry in the first step, we subtract; 265 /// the carry, in accordance with the Add(Indexed) implementation(s) above.; 266 /// This is purely an implementation choice that has no impact on performance.; 267 ///; 268 /// \note Take care when using += (and -=) to add other KahanSums into a zero-initialized; 269 /// KahanSum. The operator behaves correctly in this case, but the result may be slightly; 270 /// off if you expect 0 + x to yield exactly x (where 0 is the zero-initialized KahanSum; 271 /// and x another KahanSum). In particular, x's carry term may get lost. This doesn't; 272 /// just happen with zero-initialized KahanSums; see the SubtractWithABitTooSmallCarry; 273 /// test case in the testKahan unittest for other examples. This behavior is internally; 274 /// consistent: the carry also gets lost if you switch the operands and it also happens with; 275 /// other KahanSum operators.; 276 template<typename U, unsigned int M>; 277 KahanSum<T, N>& operator+=(const KahanSum<U, M>& other) {; 278 U corrected_arg_sum = other.Sum() - (fCarry[0] + other.Carry());; 279 U sum = fSum[0] + corrected_arg_sum;; 280 U correction = (sum - fSum[0]) - corrected_arg_sum;; 281 fSum[0] = sum;; 282 fCarry[0] = correction;; 283 return *this;; 284 }; 285 ; 286 /// Subtract other KahanSum. Does not vectorise.; 287 ///; 288 /// Based on KahanIncrement from: Tian et al., 2012 (see operator+= documentation).; 289 template<typename U, unsigned int M>; 290 KahanSum<T, N>& operator-=(KahanSum<U, M> const& other) {; 291 U corrected_arg_sum = -other.Sum() - (fCarry[0] - other.Carry());; 292 U sum = fSum[0] + corrected_arg_sum;; 293 U correction = (sum - f",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:17484,Testability,log,log,17484,"nSum::fSumT fSum[N]Definition Util.h:315; ROOT::Math::KahanSum::KahanSumKahanSum(T initialValue=T{})Initialise the sum.Definition Util.h:126; ROOT::Math::KahanSum::KahanSumKahanSum(T initialSumValue, T initialCarryValue)Initialise with a sum value and a carry value.Definition Util.h:135; ROOT::Math::KahanSum::Addvoid Add(T x)Single-element accumulation. Will not vectorise.Definition Util.h:165; ROOT::Math::KahanSum::operator-=KahanSum< T, N > & operator-=(KahanSum< U, M > const &other)Subtract other KahanSum.Definition Util.h:290; ROOT::Math::KahanSum::KahanSumKahanSum(Iterator sumBegin, Iterator sumEnd, Iterator carryBegin, Iterator carryEnd)Initialise the sum with a pre-existing state.Definition Util.h:148; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; MathNamespace for new Math classes and functions.; ROOT::MacOSX::UtilDefinition CocoaUtils.h:22; ROOT::Math::Util::EvalLogT EvalLog(T x)safe evaluation of log(x) with a protections against negative or zero argument to the log smooth line...Definition Util.h:64; ROOT::Math::Util::ToStringstd::string ToString(const T &val)Utility function for conversion to strings.Definition Util.h:50; ROOT::Math::operator+DisplacementVector2D< CoordSystem1, U > operator+(DisplacementVector2D< CoordSystem1, U > v1, const DisplacementVector2D< CoordSystem2, U > &v2)Addition of DisplacementVector2D vectors.Definition DisplacementVector2D.h:440; ROOT::Math::operator-DisplacementVector2D< CoordSystem1, U > operator-(DisplacementVector2D< CoordSystem1, U > v1, DisplacementVector2D< CoordSystem2, U > const &v2)Difference between two DisplacementVector2D vectors.Definition DisplacementVector2D.h:453; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; Types.h; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. mathmathcoreincMathUtil.h. ROOT master - Reference Guide Gener",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:17551,Testability,log,log,17551,"nSum::fSumT fSum[N]Definition Util.h:315; ROOT::Math::KahanSum::KahanSumKahanSum(T initialValue=T{})Initialise the sum.Definition Util.h:126; ROOT::Math::KahanSum::KahanSumKahanSum(T initialSumValue, T initialCarryValue)Initialise with a sum value and a carry value.Definition Util.h:135; ROOT::Math::KahanSum::Addvoid Add(T x)Single-element accumulation. Will not vectorise.Definition Util.h:165; ROOT::Math::KahanSum::operator-=KahanSum< T, N > & operator-=(KahanSum< U, M > const &other)Subtract other KahanSum.Definition Util.h:290; ROOT::Math::KahanSum::KahanSumKahanSum(Iterator sumBegin, Iterator sumEnd, Iterator carryBegin, Iterator carryEnd)Initialise the sum with a pre-existing state.Definition Util.h:148; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; MathNamespace for new Math classes and functions.; ROOT::MacOSX::UtilDefinition CocoaUtils.h:22; ROOT::Math::Util::EvalLogT EvalLog(T x)safe evaluation of log(x) with a protections against negative or zero argument to the log smooth line...Definition Util.h:64; ROOT::Math::Util::ToStringstd::string ToString(const T &val)Utility function for conversion to strings.Definition Util.h:50; ROOT::Math::operator+DisplacementVector2D< CoordSystem1, U > operator+(DisplacementVector2D< CoordSystem1, U > v1, const DisplacementVector2D< CoordSystem2, U > &v2)Addition of DisplacementVector2D vectors.Definition DisplacementVector2D.h:440; ROOT::Math::operator-DisplacementVector2D< CoordSystem1, U > operator-(DisplacementVector2D< CoordSystem1, U > v1, DisplacementVector2D< CoordSystem2, U > const &v2)Difference between two DisplacementVector2D vectors.Definition DisplacementVector2D.h:453; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; Types.h; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. mathmathcoreincMathUtil.h. ROOT master - Reference Guide Gener",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/Util_8h_source.html:1703,Usability,simpl,simple,1703,"tream>; 18 ; 19#include <cmath>; 20#include <limits>; 21#include <numeric>; 22 ; 23 ; 24// This can be protected against by defining ROOT_Math_VecTypes; 25// This is only used for the R__HAS_VECCORE define; 26// and a single VecCore function in EvalLog; 27#ifndef ROOT_Math_VecTypes; 28#include ""Types.h""; 29#endif; 30 ; 31 ; 32// for defining unused variables in the interfaces; 33// and have still them in the documentation; 34#define MATH_UNUSED(var) (void)var; 35 ; 36 ; 37namespace ROOT {; 38 ; 39 namespace Math {; 40 ; 41 /**; 42 namespace defining Utility functions needed by mathcore; 43 */; 44 namespace Util {; 45 ; 46 /**; 47 Utility function for conversion to strings; 48 */; 49 template <class T>; 50 std::string ToString(const T &val); 51 {; 52 std::ostringstream buf;; 53 buf << val;; 54 ; 55 std::string ret = buf.str();; 56 return ret;; 57 }; 58 ; 59 /// safe evaluation of log(x) with a protections against negative or zero argument to the log; 60 /// smooth linear extrapolation below function values smaller than epsilon; 61 /// (better than a simple cut-off); 62 ; 63 template<class T>; 64 inline T EvalLog(T x) {; 65 static const T epsilon = T(2.0 * std::numeric_limits<double>::min());; 66#ifdef R__HAS_VECCORE; 67 T logval = vecCore::Blend<T>(x <= epsilon, x / epsilon + std::log(epsilon) - T(1.0), std::log(x));; 68#else; 69 T logval = x <= epsilon ? x / epsilon + std::log(epsilon) - T(1.0) : std::log(x);; 70#endif; 71 return logval;; 72 }; 73 ; 74 } // end namespace Util; 75 ; 76 /// \class KahanSum; 77 /// The Kahan summation is a compensated summation algorithm, which significantly reduces numerical errors; 78 /// when adding a sequence of finite-precision floating point numbers.; 79 /// This is done by keeping a separate running compensation (a variable to accumulate small errors).; 80 ///; 81 /// ### Auto-vectorisable accumulation; 82 /// This class can internally use multiple accumulators (template parameter `N`).; 83 /// When filled from a collection that",MatchSource.WIKI,doc/master/Util_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Util_8h_source.html
https://root.cern/doc/master/v5_2TFormula_8h_source.html:1946,Modifiability,variab,variable,1946,"ld formula base class f(x,y,z,par) //; 23// mantained for backward compatibility and TTree usage //; 24//////////////////////////////////////////////////////////////////////////; 25 ; 26#include ""TNamed.h""; 27#include ""TBits.h""; 28#include ""TObjArray.h""; 29 ; 30 ; 31const Int_t kMAXFOUND = 500;; 32const Int_t kTFOperMask = 0x7fffff;; 33const UChar_t kTFOperShift = 23;; 34 ; 35 ; 36 ; 37namespace ROOT {; 38 namespace v5 {; 39 ; 40 class TFormulaPrimitive;; 41 ; 42class TOperOffset {; 43 friend class TFormula;; 44public:; 45 enum {; 46 kVariable = 0,; 47 kParameter = 1,; 48 kConstant = 2; 49 };; 50 TOperOffset();; 51protected:; 52 Short_t fType0; // type of operand 0; 53 Short_t fOffset0; // offset of operand 0; 54 Short_t fType1; // type of operand 1; 55 Short_t fOffset1; // offset of operand 1; 56 Short_t fType2; // type of operand 2; 57 Short_t fOffset2; // offset of operand 2; 58 Short_t fType3; // type of operand 3; 59 Short_t fOffset3; // offset of operand 3; 60 Short_t fToJump; // where to jump in case of optimized boolen; 61 Short_t fOldAction; // temporary variable used during optimization; 62};; 63 ; 64 ; 65class TFormula : public TNamed {; 66 ; 67protected:; 68 ; 69 typedef Double_t (TObject::*TFuncG)(const Double_t*,const Double_t*) const;; 70 ; 71 Int_t fNdim; //Dimension of function (1=1-Dim, 2=2-Dim,etc); 72 Int_t fNpar; //Number of parameters; 73 Int_t fNoper; //Number of operators; 74 Int_t fNconst; //Number of constants; 75 Int_t fNumber; //formula number identifier; 76 Int_t fNval; //Number of different variables in expression; 77 Int_t fNstring; //Number of different constants character strings; 78 TString *fExpr; //[fNoper] List of expressions; 79private:; 80 Int_t *fOper; //[fNoper] List of operators. (See documentation for changes made at version 7); 81protected:; 82 Double_t *fConst; //[fNconst] Array of fNconst formula constants; 83 Double_t *fParams; //[fNpar] Array of fNpar parameters; 84 TString *fNames; //[fNpar] Array of parameter names; 8",MatchSource.WIKI,doc/master/v5_2TFormula_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/v5_2TFormula_8h_source.html
https://root.cern/doc/master/v5_2TFormula_8h_source.html:2412,Modifiability,variab,variables,2412,"ld formula base class f(x,y,z,par) //; 23// mantained for backward compatibility and TTree usage //; 24//////////////////////////////////////////////////////////////////////////; 25 ; 26#include ""TNamed.h""; 27#include ""TBits.h""; 28#include ""TObjArray.h""; 29 ; 30 ; 31const Int_t kMAXFOUND = 500;; 32const Int_t kTFOperMask = 0x7fffff;; 33const UChar_t kTFOperShift = 23;; 34 ; 35 ; 36 ; 37namespace ROOT {; 38 namespace v5 {; 39 ; 40 class TFormulaPrimitive;; 41 ; 42class TOperOffset {; 43 friend class TFormula;; 44public:; 45 enum {; 46 kVariable = 0,; 47 kParameter = 1,; 48 kConstant = 2; 49 };; 50 TOperOffset();; 51protected:; 52 Short_t fType0; // type of operand 0; 53 Short_t fOffset0; // offset of operand 0; 54 Short_t fType1; // type of operand 1; 55 Short_t fOffset1; // offset of operand 1; 56 Short_t fType2; // type of operand 2; 57 Short_t fOffset2; // offset of operand 2; 58 Short_t fType3; // type of operand 3; 59 Short_t fOffset3; // offset of operand 3; 60 Short_t fToJump; // where to jump in case of optimized boolen; 61 Short_t fOldAction; // temporary variable used during optimization; 62};; 63 ; 64 ; 65class TFormula : public TNamed {; 66 ; 67protected:; 68 ; 69 typedef Double_t (TObject::*TFuncG)(const Double_t*,const Double_t*) const;; 70 ; 71 Int_t fNdim; //Dimension of function (1=1-Dim, 2=2-Dim,etc); 72 Int_t fNpar; //Number of parameters; 73 Int_t fNoper; //Number of operators; 74 Int_t fNconst; //Number of constants; 75 Int_t fNumber; //formula number identifier; 76 Int_t fNval; //Number of different variables in expression; 77 Int_t fNstring; //Number of different constants character strings; 78 TString *fExpr; //[fNoper] List of expressions; 79private:; 80 Int_t *fOper; //[fNoper] List of operators. (See documentation for changes made at version 7); 81protected:; 82 Double_t *fConst; //[fNconst] Array of fNconst formula constants; 83 Double_t *fParams; //[fNpar] Array of fNpar parameters; 84 TString *fNames; //[fNpar] Array of parameter names; 8",MatchSource.WIKI,doc/master/v5_2TFormula_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/v5_2TFormula_8h_source.html
https://root.cern/doc/master/v5_2TFormula_8h_source.html:8168,Modifiability,variab,variable,8168,"s = 110, kygaus = 111, kzgaus = 112, kxygaus = 115,; 179 klandau = 120 , kxlandau = 120, kylandau = 121, kzlandau = 122, kxylandau = 125,; 180 kpol = 130 , kxpol = 130, kypol = 131, kzpol = 132,; 181 ; 182 kParameter = 140,; 183 kConstant = 141,; 184 kBoolOptimize = 142,; 185 kStringConst = 143,; 186 kVariable = 144,; 187 kFunctionCall = 145,; 188 kData = 146,; 189 kUnary = 147,; 190 kBinary = 148,; 191 kThree = 149,; 192 kDefinedVariable = 150,; 193 kDefinedString = 151,; 194 //; 195 kPlusD = 152,; 196 kPlusDD = 153,; 197 kMultD = 154,; 198 kMultDD = 155,; 199 kBoolOptimizeOr = 156,; 200 kBoolOptimizeAnd = 157,; 201 kBoolSet = 158,; 202 kFDM = 159,; 203 kFD0 = 160,; 204 kFD1 = 161,; 205 kFD2 = 162,; 206 kFD3 = 163; 207 };; 208 ; 209public:; 210 // TFormula status bits; 211 enum {; 212 kNotGlobal = BIT(10), // don't store in gROOT->GetListOfFunction; 213 kNormalized = BIT(14), // set to true if the function (ex gausn) is normalized; 214 kLinear = BIT(16) //set to true if the function is for linear fitting; 215 };; 216 ; 217 TFormula();; 218 TFormula(const char *name,const char *formula);; 219 TFormula(const TFormula &formula);; 220 TFormula& operator=(const TFormula &rhs);; 221 ~TFormula() override;; 222 ; 223 public:; 224 void Optimize();; 225 virtual void Analyze(const char *schain, Int_t &err, Int_t offset=0);; 226 virtual Bool_t AnalyzeFunction(TString &chaine, Int_t &err, Int_t offset=0);; 227 virtual Int_t Compile(const char *expression="""");; 228 void Copy(TObject &formula) const override;; 229 void Clear(Option_t *option="""") override;; 230 virtual char *DefinedString(Int_t code);; 231 virtual Double_t DefinedValue(Int_t code);; 232 virtual Int_t DefinedVariable(TString &variable,Int_t &action);; 233 virtual Double_t Eval(Double_t x, Double_t y=0, Double_t z=0, Double_t t=0) const;; 234 virtual Double_t EvalParOld(const Double_t *x, const Double_t *params=nullptr);; 235 virtual Double_t EvalPar(const Double_t *x, const Double_t *params=nullptr){return ((*this).",MatchSource.WIKI,doc/master/v5_2TFormula_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/v5_2TFormula_8h_source.html
https://root.cern/doc/master/v5_2TFormula_8h_source.html:25332,Modifiability,variab,variable,25332,"eckOperandsvirtual Bool_t CheckOperands(Int_t operation, Int_t &err)Check whether the operand at 'oper-1' is compatible with the operation at 'oper'.Definition TFormula_v5.cxx:2167; ROOT::v5::TFormula::EvalPrimitive3Double_t EvalPrimitive3(const Double_t *x, const Double_t *params)Evaluate primitive formula.Definition TFormula_v5.cxx:4163; ROOT::v5::TFormula::SetParNamesvirtual void SetParNames(const char *name0=""p0"", const char *name1=""p1"", const char *name2=""p2"", const char *name3=""p3"", const char *name4=""p4"", const char *name5=""p5"", const char *name6=""p6"", const char *name7=""p7"", const char *name8=""p8"", const char *name9=""p9"", const char *name10=""p10"")Set up to 11 parameter names.Definition TFormula_v5.cxx:3441; ROOT::v5::TFormula::fOperOptimizedInt_t * fOperOptimized[fNOperOptimized] List of expressionsDefinition TFormula.h:93; ROOT::v5::TFormula::GetNparvirtual Int_t GetNpar() constDefinition TFormula.h:238; ROOT::v5::TFormula::DefinedVariablevirtual Int_t DefinedVariable(TString &variable, Int_t &action)Check if expression is in the list of defined variables.Definition TFormula_v5.cxx:2621; ROOT::v5::TFormula::GetActionParamInt_t GetActionParam(Int_t code) constDefinition TFormula.h:105; ROOT::v5::TFormula::fOptimalTFuncG fOptimal[fNPar] predefined functionDefinition TFormula.h:96; ROOT::v5::TFormula::fAlreadyFoundTBits fAlreadyFoundDefinition TFormula.h:88; ROOT::v5::TFormula::EvalPrimitive4Double_t EvalPrimitive4(const Double_t *x, const Double_t *params)Evaluate primitive formula.Definition TFormula_v5.cxx:4173; ROOT::v5::TFormula::Printvoid Print(Option_t *option="""") const overrideDump this formula with its attributes.Definition TFormula_v5.cxx:3277; ROOT::v5::TFormula::Analyzevirtual void Analyze(const char *schain, Int_t &err, Int_t offset=0)Analyze a sub-expression in one formula.Definition TFormula_v5.cxx:712; ROOT::v5::TFormula::GetExpFormulavirtual TString GetExpFormula(Option_t *option="""") constReconstruct the formula expression from the internal TFo",MatchSource.WIKI,doc/master/v5_2TFormula_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/v5_2TFormula_8h_source.html
https://root.cern/doc/master/v5_2TFormula_8h_source.html:25402,Modifiability,variab,variables,25402,"eckOperandsvirtual Bool_t CheckOperands(Int_t operation, Int_t &err)Check whether the operand at 'oper-1' is compatible with the operation at 'oper'.Definition TFormula_v5.cxx:2167; ROOT::v5::TFormula::EvalPrimitive3Double_t EvalPrimitive3(const Double_t *x, const Double_t *params)Evaluate primitive formula.Definition TFormula_v5.cxx:4163; ROOT::v5::TFormula::SetParNamesvirtual void SetParNames(const char *name0=""p0"", const char *name1=""p1"", const char *name2=""p2"", const char *name3=""p3"", const char *name4=""p4"", const char *name5=""p5"", const char *name6=""p6"", const char *name7=""p7"", const char *name8=""p8"", const char *name9=""p9"", const char *name10=""p10"")Set up to 11 parameter names.Definition TFormula_v5.cxx:3441; ROOT::v5::TFormula::fOperOptimizedInt_t * fOperOptimized[fNOperOptimized] List of expressionsDefinition TFormula.h:93; ROOT::v5::TFormula::GetNparvirtual Int_t GetNpar() constDefinition TFormula.h:238; ROOT::v5::TFormula::DefinedVariablevirtual Int_t DefinedVariable(TString &variable, Int_t &action)Check if expression is in the list of defined variables.Definition TFormula_v5.cxx:2621; ROOT::v5::TFormula::GetActionParamInt_t GetActionParam(Int_t code) constDefinition TFormula.h:105; ROOT::v5::TFormula::fOptimalTFuncG fOptimal[fNPar] predefined functionDefinition TFormula.h:96; ROOT::v5::TFormula::fAlreadyFoundTBits fAlreadyFoundDefinition TFormula.h:88; ROOT::v5::TFormula::EvalPrimitive4Double_t EvalPrimitive4(const Double_t *x, const Double_t *params)Evaluate primitive formula.Definition TFormula_v5.cxx:4173; ROOT::v5::TFormula::Printvoid Print(Option_t *option="""") const overrideDump this formula with its attributes.Definition TFormula_v5.cxx:3277; ROOT::v5::TFormula::Analyzevirtual void Analyze(const char *schain, Int_t &err, Int_t offset=0)Analyze a sub-expression in one formula.Definition TFormula_v5.cxx:712; ROOT::v5::TFormula::GetExpFormulavirtual TString GetExpFormula(Option_t *option="""") constReconstruct the formula expression from the internal TFo",MatchSource.WIKI,doc/master/v5_2TFormula_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/v5_2TFormula_8h_source.html
https://root.cern/doc/master/v5_2TFormula_8h_source.html:26345,Modifiability,variab,variables,26345,"::TFormula::DefinedVariablevirtual Int_t DefinedVariable(TString &variable, Int_t &action)Check if expression is in the list of defined variables.Definition TFormula_v5.cxx:2621; ROOT::v5::TFormula::GetActionParamInt_t GetActionParam(Int_t code) constDefinition TFormula.h:105; ROOT::v5::TFormula::fOptimalTFuncG fOptimal[fNPar] predefined functionDefinition TFormula.h:96; ROOT::v5::TFormula::fAlreadyFoundTBits fAlreadyFoundDefinition TFormula.h:88; ROOT::v5::TFormula::EvalPrimitive4Double_t EvalPrimitive4(const Double_t *x, const Double_t *params)Evaluate primitive formula.Definition TFormula_v5.cxx:4173; ROOT::v5::TFormula::Printvoid Print(Option_t *option="""") const overrideDump this formula with its attributes.Definition TFormula_v5.cxx:3277; ROOT::v5::TFormula::Analyzevirtual void Analyze(const char *schain, Int_t &err, Int_t offset=0)Analyze a sub-expression in one formula.Definition TFormula_v5.cxx:712; ROOT::v5::TFormula::GetExpFormulavirtual TString GetExpFormula(Option_t *option="""") constReconstruct the formula expression from the internal TFormula member variables.Definition TFormula_v5.cxx:3022; ROOT::v5::TFormula::MakePrimitivevoid MakePrimitive(const char *expr, Int_t pos)MakePrimitive find TFormulaPrimitive replacement for some operands.Definition TFormula_v5.cxx:3746; ROOT::v5::TFormula::GetActionParamOptimizedInt_t GetActionParamOptimized(Int_t code) constDefinition TFormula.h:113; ROOT::v5::TFormula::EvalParOldvirtual Double_t EvalParOld(const Double_t *x, const Double_t *params=nullptr)Evaluate this formula.Definition TFormula_v5.cxx:2687; ROOT::v5::TFormula::GetMaximastatic void GetMaxima(Int_t &maxop, Int_t &maxpar, Int_t &maxconst)static function to get the maximum value of 3 parameters -maxop : maximum number of operations -maxpa...Definition TFormula_v5.cxx:4540; ROOT::v5::TFormula::fPredefinedTFormulaPrimitive ** fPredefined[fNOperOptimized] Offsets of operrandsDefinition TFormula.h:95; ROOT::v5::TFormula::fNoperInt_t fNoperDefinition TFormula.h",MatchSource.WIKI,doc/master/v5_2TFormula_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/v5_2TFormula_8h_source.html
https://root.cern/doc/master/v5_2TFormula_8h_source.html:1892,Performance,optimiz,optimized,1892,"ld formula base class f(x,y,z,par) //; 23// mantained for backward compatibility and TTree usage //; 24//////////////////////////////////////////////////////////////////////////; 25 ; 26#include ""TNamed.h""; 27#include ""TBits.h""; 28#include ""TObjArray.h""; 29 ; 30 ; 31const Int_t kMAXFOUND = 500;; 32const Int_t kTFOperMask = 0x7fffff;; 33const UChar_t kTFOperShift = 23;; 34 ; 35 ; 36 ; 37namespace ROOT {; 38 namespace v5 {; 39 ; 40 class TFormulaPrimitive;; 41 ; 42class TOperOffset {; 43 friend class TFormula;; 44public:; 45 enum {; 46 kVariable = 0,; 47 kParameter = 1,; 48 kConstant = 2; 49 };; 50 TOperOffset();; 51protected:; 52 Short_t fType0; // type of operand 0; 53 Short_t fOffset0; // offset of operand 0; 54 Short_t fType1; // type of operand 1; 55 Short_t fOffset1; // offset of operand 1; 56 Short_t fType2; // type of operand 2; 57 Short_t fOffset2; // offset of operand 2; 58 Short_t fType3; // type of operand 3; 59 Short_t fOffset3; // offset of operand 3; 60 Short_t fToJump; // where to jump in case of optimized boolen; 61 Short_t fOldAction; // temporary variable used during optimization; 62};; 63 ; 64 ; 65class TFormula : public TNamed {; 66 ; 67protected:; 68 ; 69 typedef Double_t (TObject::*TFuncG)(const Double_t*,const Double_t*) const;; 70 ; 71 Int_t fNdim; //Dimension of function (1=1-Dim, 2=2-Dim,etc); 72 Int_t fNpar; //Number of parameters; 73 Int_t fNoper; //Number of operators; 74 Int_t fNconst; //Number of constants; 75 Int_t fNumber; //formula number identifier; 76 Int_t fNval; //Number of different variables in expression; 77 Int_t fNstring; //Number of different constants character strings; 78 TString *fExpr; //[fNoper] List of expressions; 79private:; 80 Int_t *fOper; //[fNoper] List of operators. (See documentation for changes made at version 7); 81protected:; 82 Double_t *fConst; //[fNconst] Array of fNconst formula constants; 83 Double_t *fParams; //[fNpar] Array of fNpar parameters; 84 TString *fNames; //[fNpar] Array of parameter names; 8",MatchSource.WIKI,doc/master/v5_2TFormula_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/v5_2TFormula_8h_source.html
https://root.cern/doc/master/v5_2TFormula_8h_source.html:1967,Performance,optimiz,optimization,1967,"ld formula base class f(x,y,z,par) //; 23// mantained for backward compatibility and TTree usage //; 24//////////////////////////////////////////////////////////////////////////; 25 ; 26#include ""TNamed.h""; 27#include ""TBits.h""; 28#include ""TObjArray.h""; 29 ; 30 ; 31const Int_t kMAXFOUND = 500;; 32const Int_t kTFOperMask = 0x7fffff;; 33const UChar_t kTFOperShift = 23;; 34 ; 35 ; 36 ; 37namespace ROOT {; 38 namespace v5 {; 39 ; 40 class TFormulaPrimitive;; 41 ; 42class TOperOffset {; 43 friend class TFormula;; 44public:; 45 enum {; 46 kVariable = 0,; 47 kParameter = 1,; 48 kConstant = 2; 49 };; 50 TOperOffset();; 51protected:; 52 Short_t fType0; // type of operand 0; 53 Short_t fOffset0; // offset of operand 0; 54 Short_t fType1; // type of operand 1; 55 Short_t fOffset1; // offset of operand 1; 56 Short_t fType2; // type of operand 2; 57 Short_t fOffset2; // offset of operand 2; 58 Short_t fType3; // type of operand 3; 59 Short_t fOffset3; // offset of operand 3; 60 Short_t fToJump; // where to jump in case of optimized boolen; 61 Short_t fOldAction; // temporary variable used during optimization; 62};; 63 ; 64 ; 65class TFormula : public TNamed {; 66 ; 67protected:; 68 ; 69 typedef Double_t (TObject::*TFuncG)(const Double_t*,const Double_t*) const;; 70 ; 71 Int_t fNdim; //Dimension of function (1=1-Dim, 2=2-Dim,etc); 72 Int_t fNpar; //Number of parameters; 73 Int_t fNoper; //Number of operators; 74 Int_t fNconst; //Number of constants; 75 Int_t fNumber; //formula number identifier; 76 Int_t fNval; //Number of different variables in expression; 77 Int_t fNstring; //Number of different constants character strings; 78 TString *fExpr; //[fNoper] List of expressions; 79private:; 80 Int_t *fOper; //[fNoper] List of operators. (See documentation for changes made at version 7); 81protected:; 82 Double_t *fConst; //[fNconst] Array of fNconst formula constants; 83 Double_t *fParams; //[fNpar] Array of fNpar parameters; 84 TString *fNames; //[fNpar] Array of parameter names; 8",MatchSource.WIKI,doc/master/v5_2TFormula_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/v5_2TFormula_8h_source.html
https://root.cern/doc/master/v5_2TFormula_8h_source.html:3050,Performance,cache,cache,3050,"ing optimization; 62};; 63 ; 64 ; 65class TFormula : public TNamed {; 66 ; 67protected:; 68 ; 69 typedef Double_t (TObject::*TFuncG)(const Double_t*,const Double_t*) const;; 70 ; 71 Int_t fNdim; //Dimension of function (1=1-Dim, 2=2-Dim,etc); 72 Int_t fNpar; //Number of parameters; 73 Int_t fNoper; //Number of operators; 74 Int_t fNconst; //Number of constants; 75 Int_t fNumber; //formula number identifier; 76 Int_t fNval; //Number of different variables in expression; 77 Int_t fNstring; //Number of different constants character strings; 78 TString *fExpr; //[fNoper] List of expressions; 79private:; 80 Int_t *fOper; //[fNoper] List of operators. (See documentation for changes made at version 7); 81protected:; 82 Double_t *fConst; //[fNconst] Array of fNconst formula constants; 83 Double_t *fParams; //[fNpar] Array of fNpar parameters; 84 TString *fNames; //[fNpar] Array of parameter names; 85 TObjArray fFunctions; //Array of function calls to make; 86 TObjArray fLinearParts; //Linear parts if the formula is linear (contains '|' or ""++""); 87 ; 88 TBits fAlreadyFound; //! cache for information; 89 ; 90 // Optimized expression; 91 Int_t fNOperOptimized; //!Number of operators after optimization; 92 TString *fExprOptimized; //![fNOperOptimized] List of expressions; 93 Int_t *fOperOptimized; //![fNOperOptimized] List of operators. (See documentation for changes made at version 7); 94 TOperOffset *fOperOffset; //![fNOperOptimized] Offsets of operrands; 95 TFormulaPrimitive **fPredefined; //![fNPar] predefined function; 96 TFuncG fOptimal; //!pointer to optimal function; 97 ; 98 Int_t PreCompile();; 99 virtual Bool_t CheckOperands(Int_t operation, Int_t &err);; 100 virtual Bool_t CheckOperands(Int_t leftoperand, Int_t rightoperartion, Int_t &err);; 101 virtual Bool_t StringToNumber(Int_t code);; 102 void MakePrimitive(const char *expr, Int_t pos);; 103 inline Int_t *GetOper() const { return fOper; }; 104 inline Short_t GetAction(Int_t code) const { return fOper[code] >> kT",MatchSource.WIKI,doc/master/v5_2TFormula_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/v5_2TFormula_8h_source.html
https://root.cern/doc/master/v5_2TFormula_8h_source.html:3161,Performance,optimiz,optimization,3161,"ing optimization; 62};; 63 ; 64 ; 65class TFormula : public TNamed {; 66 ; 67protected:; 68 ; 69 typedef Double_t (TObject::*TFuncG)(const Double_t*,const Double_t*) const;; 70 ; 71 Int_t fNdim; //Dimension of function (1=1-Dim, 2=2-Dim,etc); 72 Int_t fNpar; //Number of parameters; 73 Int_t fNoper; //Number of operators; 74 Int_t fNconst; //Number of constants; 75 Int_t fNumber; //formula number identifier; 76 Int_t fNval; //Number of different variables in expression; 77 Int_t fNstring; //Number of different constants character strings; 78 TString *fExpr; //[fNoper] List of expressions; 79private:; 80 Int_t *fOper; //[fNoper] List of operators. (See documentation for changes made at version 7); 81protected:; 82 Double_t *fConst; //[fNconst] Array of fNconst formula constants; 83 Double_t *fParams; //[fNpar] Array of fNpar parameters; 84 TString *fNames; //[fNpar] Array of parameter names; 85 TObjArray fFunctions; //Array of function calls to make; 86 TObjArray fLinearParts; //Linear parts if the formula is linear (contains '|' or ""++""); 87 ; 88 TBits fAlreadyFound; //! cache for information; 89 ; 90 // Optimized expression; 91 Int_t fNOperOptimized; //!Number of operators after optimization; 92 TString *fExprOptimized; //![fNOperOptimized] List of expressions; 93 Int_t *fOperOptimized; //![fNOperOptimized] List of operators. (See documentation for changes made at version 7); 94 TOperOffset *fOperOffset; //![fNOperOptimized] Offsets of operrands; 95 TFormulaPrimitive **fPredefined; //![fNPar] predefined function; 96 TFuncG fOptimal; //!pointer to optimal function; 97 ; 98 Int_t PreCompile();; 99 virtual Bool_t CheckOperands(Int_t operation, Int_t &err);; 100 virtual Bool_t CheckOperands(Int_t leftoperand, Int_t rightoperartion, Int_t &err);; 101 virtual Bool_t StringToNumber(Int_t code);; 102 void MakePrimitive(const char *expr, Int_t pos);; 103 inline Int_t *GetOper() const { return fOper; }; 104 inline Short_t GetAction(Int_t code) const { return fOper[code] >> kT",MatchSource.WIKI,doc/master/v5_2TFormula_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/v5_2TFormula_8h_source.html
https://root.cern/doc/master/v5_2TFormula_8h_source.html:12997,Performance,optimiz,optimization,12997,"nition TGWin32VirtualXProxy.cxx:245; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; TNamed.h; TObjArray.h; ROOT::v5::TFormulaThe FORMULA class (ROOT version 5)Definition TFormula.h:65; ROOT::v5::TFormula::fConstDouble_t * fConstDefinition TFormula.h:82; ROOT::v5::TFormula::Clearvoid Clear(Option_t *option="""") overrideResets the objects.Definition TFormula_v5.cxx:2212; ROOT::v5::TFormula::GetNumbervirtual Int_t GetNumber() constDefinition TFormula.h:239; ROOT::v5::TFormula::StringToNumbervirtual Bool_t StringToNumber(Int_t code)Try to 'demote' a string into an array bytes.Definition TFormula_v5.cxx:2201; ROOT::v5::TFormula::GetParameterDouble_t GetParameter(Int_t ipar) constReturn value of parameter number ipar.Definition TFormula_v5.cxx:3222; ROOT::v5::TFormula::fExprOptimizedTString * fExprOptimizedNumber of operators after optimization.Definition TFormula.h:92; ROOT::v5::TFormula::fNumberInt_t fNumberDefinition TFormula.h:75; ROOT::v5::TFormula::EvalParvirtual Double_t EvalPar(const Double_t *x, const Double_t *params=nullptr)Definition TFormula.h:235; ROOT::v5::TFormula::IsNormalizedvirtual Bool_t IsNormalized() constDefinition TFormula.h:248; ROOT::v5::TFormula::GetParametersvirtual Double_t * GetParameters() constDefinition TFormula.h:243; ROOT::v5::TFormula::DefinedValuevirtual Double_t DefinedValue(Int_t code)Return value corresponding to special code.Definition TFormula_v5.cxx:2586; ROOT::v5::TFormula::Evalvirtual Double_t Eval(Double_t x, Double_t y=0, Double_t z=0, Double_t t=0) constEvaluate this formula.Definition TFormula_v5.cxx:2668; ROOT::v5::TFormula::kLinear@ kLinearDefinition TFormula.h:214; ROOT::v5::TFormula::kNormalized@ kNormalizedDefinition TFormula.h:213; ROOT::v5::TFormula::kNotGlobal@ kNotGlobalDefinition TFormula.h:212; ROOT::v5::TFormula::",MatchSource.WIKI,doc/master/v5_2TFormula_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/v5_2TFormula_8h_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:427,Deployability,integrat,integrated,427,". ROOT: tmva/tmva/src/VariableTransform.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. VariableTransform.cxx. Go to the documentation of this file. 1// @(#)root/tmva $Id$; 2// Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Omar Zapata; 3 ; 4/**********************************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : VariableTransformBase *; 8 * *; 9 * *; 10 * Description: *; 11 * Implementation (see header for description) *; 12 * *; 13 * Authors (alphabetical): *; 14 * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; 15 * Peter Speckmayer <Peter.Speckmayer@cern.ch> - CERN, Switzerland *; 16 * Joerg Stelzer <Joerg.Stelzer@cern.ch> - CERN, Switzerland *; 17 * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; 18 * *; 19 * Copyright (c) 2005: *; 20 * CERN, Switzerland *; 21 * MPI-K Heidelberg, Germany *; 22 * *; 23 * Redistribution and use in source and binary forms, with or without *; 24 * modification, are permitted according to the terms listed in LICENSE *; 25 * (see tmva/doc/LICENSE) *; 26 **********************************************************************************/; 27 ; 28#include ""TMVA/VariableTransformBase.h""; 29#include ""TMVA/VariableIdentityTransform.h""; 30#include ""TMVA/VariableDecorrTransform.h""; 31#include ""TMVA/VariableInfo.h""; 32#include ""TMVA/VariablePCATransform.h""; 33#include ""TMVA/VariableGaussTransform.h""; 34#include ""TMVA/VariableNormalizeTransform.h""; 35 ; 36#include ""TMVA/Config.h""; 37#include ""TMVA/DataSetInfo.h""; 38#include ""TMVA/MsgLogger.h""; 39#include ""TMVA/Ranking.h""; 40#include ""TMVA/Tools.h""; 41#include ""TMVA/Types.h""; 42#include ""TMVA/Version.h""; 43#include ""TMVA/TransformationHandler.h""; 44 ; 45#include ""THashTable.h""; 46#include ""TList.h""; 47#include ""TObjString.h""; 48 ; 49#include <algorithm>; 50#include <cass",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:427,Integrability,integrat,integrated,427,". ROOT: tmva/tmva/src/VariableTransform.cxx Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. VariableTransform.cxx. Go to the documentation of this file. 1// @(#)root/tmva $Id$; 2// Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Omar Zapata; 3 ; 4/**********************************************************************************; 5 * Project: TMVA - a Root-integrated toolkit for multivariate data analysis *; 6 * Package: TMVA *; 7 * Class : VariableTransformBase *; 8 * *; 9 * *; 10 * Description: *; 11 * Implementation (see header for description) *; 12 * *; 13 * Authors (alphabetical): *; 14 * Andreas Hoecker <Andreas.Hocker@cern.ch> - CERN, Switzerland *; 15 * Peter Speckmayer <Peter.Speckmayer@cern.ch> - CERN, Switzerland *; 16 * Joerg Stelzer <Joerg.Stelzer@cern.ch> - CERN, Switzerland *; 17 * Helge Voss <Helge.Voss@cern.ch> - MPI-K Heidelberg, Germany *; 18 * *; 19 * Copyright (c) 2005: *; 20 * CERN, Switzerland *; 21 * MPI-K Heidelberg, Germany *; 22 * *; 23 * Redistribution and use in source and binary forms, with or without *; 24 * modification, are permitted according to the terms listed in LICENSE *; 25 * (see tmva/doc/LICENSE) *; 26 **********************************************************************************/; 27 ; 28#include ""TMVA/VariableTransformBase.h""; 29#include ""TMVA/VariableIdentityTransform.h""; 30#include ""TMVA/VariableDecorrTransform.h""; 31#include ""TMVA/VariableInfo.h""; 32#include ""TMVA/VariablePCATransform.h""; 33#include ""TMVA/VariableGaussTransform.h""; 34#include ""TMVA/VariableNormalizeTransform.h""; 35 ; 36#include ""TMVA/Config.h""; 37#include ""TMVA/DataSetInfo.h""; 38#include ""TMVA/MsgLogger.h""; 39#include ""TMVA/Ranking.h""; 40#include ""TMVA/Tools.h""; 41#include ""TMVA/Types.h""; 42#include ""TMVA/Version.h""; 43#include ""TMVA/TransformationHandler.h""; 44 ; 45#include ""THashTable.h""; 46#include ""TList.h""; 47#include ""TObjString.h""; 48 ; 49#include <algorithm>; 50#include <cass",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:2175,Modifiability,variab,variable,2175,"VA/VariableIdentityTransform.h""; 30#include ""TMVA/VariableDecorrTransform.h""; 31#include ""TMVA/VariableInfo.h""; 32#include ""TMVA/VariablePCATransform.h""; 33#include ""TMVA/VariableGaussTransform.h""; 34#include ""TMVA/VariableNormalizeTransform.h""; 35 ; 36#include ""TMVA/Config.h""; 37#include ""TMVA/DataSetInfo.h""; 38#include ""TMVA/MsgLogger.h""; 39#include ""TMVA/Ranking.h""; 40#include ""TMVA/Tools.h""; 41#include ""TMVA/Types.h""; 42#include ""TMVA/Version.h""; 43#include ""TMVA/TransformationHandler.h""; 44 ; 45#include ""THashTable.h""; 46#include ""TList.h""; 47#include ""TObjString.h""; 48 ; 49#include <algorithm>; 50#include <cassert>; 51#include <exception>; 52#include <stdexcept>; 53#include <set>; 54 ; 55////////////////////////////////////////////////////////////////////////////////; 56/// create variable transformations; 57 ; 58namespace TMVA {; 59void CreateVariableTransforms(const TString& trafoDefinitionIn,; 60 TMVA::DataSetInfo& dataInfo,; 61 TMVA::TransformationHandler& transformationHandler,; 62 TMVA::MsgLogger& log); 63{; 64 TString trafoDefinition(trafoDefinitionIn);; 65 if (trafoDefinition == ""None"") return; // no transformations; 66 ; 67 // workaround for transformations to complicated to be handled by makeclass; 68 // count number of transformations with incomplete set of variables; 69 TString trafoDefinitionCheck(trafoDefinitionIn);; 70 int npartial = 0;; 71 for (Int_t pos = 0, siz = trafoDefinition.Sizeof(); pos < siz; ++pos) {; 72 TString ch = trafoDefinition(pos,1);; 73 if ( ch == ""("" ) npartial++;; 74 }; 75 if (npartial>1) {; 76 log << kWARNING; 77 << ""The use of multiple partial variable transformations during the ""; 78 ""application phase can be properly invoked via the \""Reader\"", but ""; 79 ""it is not yet implemented in \""MakeClass\"", the creation mechanism ""; 80 ""for standalone C++ application classes. The standalone C++ class ""; 81 ""produced by this training job is thus INCOMPLETE AND MUST NOT BE USED! ""; 82 ""The transformation in question is: "" << trafoDe",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:2672,Modifiability,variab,variables,2672,"VA/VariableIdentityTransform.h""; 30#include ""TMVA/VariableDecorrTransform.h""; 31#include ""TMVA/VariableInfo.h""; 32#include ""TMVA/VariablePCATransform.h""; 33#include ""TMVA/VariableGaussTransform.h""; 34#include ""TMVA/VariableNormalizeTransform.h""; 35 ; 36#include ""TMVA/Config.h""; 37#include ""TMVA/DataSetInfo.h""; 38#include ""TMVA/MsgLogger.h""; 39#include ""TMVA/Ranking.h""; 40#include ""TMVA/Tools.h""; 41#include ""TMVA/Types.h""; 42#include ""TMVA/Version.h""; 43#include ""TMVA/TransformationHandler.h""; 44 ; 45#include ""THashTable.h""; 46#include ""TList.h""; 47#include ""TObjString.h""; 48 ; 49#include <algorithm>; 50#include <cassert>; 51#include <exception>; 52#include <stdexcept>; 53#include <set>; 54 ; 55////////////////////////////////////////////////////////////////////////////////; 56/// create variable transformations; 57 ; 58namespace TMVA {; 59void CreateVariableTransforms(const TString& trafoDefinitionIn,; 60 TMVA::DataSetInfo& dataInfo,; 61 TMVA::TransformationHandler& transformationHandler,; 62 TMVA::MsgLogger& log); 63{; 64 TString trafoDefinition(trafoDefinitionIn);; 65 if (trafoDefinition == ""None"") return; // no transformations; 66 ; 67 // workaround for transformations to complicated to be handled by makeclass; 68 // count number of transformations with incomplete set of variables; 69 TString trafoDefinitionCheck(trafoDefinitionIn);; 70 int npartial = 0;; 71 for (Int_t pos = 0, siz = trafoDefinition.Sizeof(); pos < siz; ++pos) {; 72 TString ch = trafoDefinition(pos,1);; 73 if ( ch == ""("" ) npartial++;; 74 }; 75 if (npartial>1) {; 76 log << kWARNING; 77 << ""The use of multiple partial variable transformations during the ""; 78 ""application phase can be properly invoked via the \""Reader\"", but ""; 79 ""it is not yet implemented in \""MakeClass\"", the creation mechanism ""; 80 ""for standalone C++ application classes. The standalone C++ class ""; 81 ""produced by this training job is thus INCOMPLETE AND MUST NOT BE USED! ""; 82 ""The transformation in question is: "" << trafoDe",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:2991,Modifiability,variab,variable,2991,"nclude <exception>; 52#include <stdexcept>; 53#include <set>; 54 ; 55////////////////////////////////////////////////////////////////////////////////; 56/// create variable transformations; 57 ; 58namespace TMVA {; 59void CreateVariableTransforms(const TString& trafoDefinitionIn,; 60 TMVA::DataSetInfo& dataInfo,; 61 TMVA::TransformationHandler& transformationHandler,; 62 TMVA::MsgLogger& log); 63{; 64 TString trafoDefinition(trafoDefinitionIn);; 65 if (trafoDefinition == ""None"") return; // no transformations; 66 ; 67 // workaround for transformations to complicated to be handled by makeclass; 68 // count number of transformations with incomplete set of variables; 69 TString trafoDefinitionCheck(trafoDefinitionIn);; 70 int npartial = 0;; 71 for (Int_t pos = 0, siz = trafoDefinition.Sizeof(); pos < siz; ++pos) {; 72 TString ch = trafoDefinition(pos,1);; 73 if ( ch == ""("" ) npartial++;; 74 }; 75 if (npartial>1) {; 76 log << kWARNING; 77 << ""The use of multiple partial variable transformations during the ""; 78 ""application phase can be properly invoked via the \""Reader\"", but ""; 79 ""it is not yet implemented in \""MakeClass\"", the creation mechanism ""; 80 ""for standalone C++ application classes. The standalone C++ class ""; 81 ""produced by this training job is thus INCOMPLETE AND MUST NOT BE USED! ""; 82 ""The transformation in question is: "" << trafoDefinitionIn << Endl;; 83 // ToDo make info and do not write the standalone class; 84 //; 85 // this does not work since this function is static; 86 // fDisableWriting=true; // disable creation of stand-alone class; 87 // ToDo we need to tell the transformation that it cannot write itself; 88 }; 89 // workaround end; 90 ; 91 Int_t parenthesisCount = 0;; 92 for (Int_t position = 0, size = trafoDefinition.Sizeof(); position < size; ++position) {; 93 TString ch = trafoDefinition(position,1);; 94 if (ch == ""("") ++parenthesisCount;; 95 else if (ch == "")"") --parenthesisCount;; 96 else if (ch == "","" && parenthesisCount == 0) trafoDefin",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:4285,Modifiability,variab,variables,4285," application classes. The standalone C++ class ""; 81 ""produced by this training job is thus INCOMPLETE AND MUST NOT BE USED! ""; 82 ""The transformation in question is: "" << trafoDefinitionIn << Endl;; 83 // ToDo make info and do not write the standalone class; 84 //; 85 // this does not work since this function is static; 86 // fDisableWriting=true; // disable creation of stand-alone class; 87 // ToDo we need to tell the transformation that it cannot write itself; 88 }; 89 // workaround end; 90 ; 91 Int_t parenthesisCount = 0;; 92 for (Int_t position = 0, size = trafoDefinition.Sizeof(); position < size; ++position) {; 93 TString ch = trafoDefinition(position,1);; 94 if (ch == ""("") ++parenthesisCount;; 95 else if (ch == "")"") --parenthesisCount;; 96 else if (ch == "","" && parenthesisCount == 0) trafoDefinition.Replace(position,1,'+');; 97 }; 98 ; 99 TList* trList = gTools().ParseFormatLine( trafoDefinition, ""+"" );; 100 TListIter trIt(trList);; 101 while (TObjString* os = (TObjString*)trIt()) {; 102 TString tdef = os->GetString();; 103 Int_t idxCls = -1;; 104 ; 105 TString variables = """";; 106 if (tdef.Contains(""("")) { // contains selection of variables; 107 Ssiz_t parStart = tdef.Index( ""("" );; 108 Ssiz_t parLen = tdef.Index( "")"", parStart )-parStart+1;; 109 ; 110 variables = tdef(parStart,parLen);; 111 tdef.Remove(parStart,parLen);; 112 variables.Remove(parLen-1,1);; 113 variables.Remove(0,1);; 114 }; 115 ; 116 TList* trClsList = gTools().ParseFormatLine( tdef, ""_"" ); // split entry to get trf-name and class-name; 117 TListIter trClsIt(trClsList);; 118 if (trClsList->GetSize() < 1); 119 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Incorrect transformation string provided."" << Endl;; 120 const TString& trName = ((TObjString*)trClsList->At(0))->GetString();; 121 ; 122 if (trClsList->GetEntries() > 1) {; 123 TString trCls = ""AllClasses"";; 124 ClassInfo *ci = NULL;; 125 trCls = ((TObjString*)trClsList->At(1))->GetString();; 126 if (trCls != ""AllClasses"") {",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:4357,Modifiability,variab,variables,4357,"estion is: "" << trafoDefinitionIn << Endl;; 83 // ToDo make info and do not write the standalone class; 84 //; 85 // this does not work since this function is static; 86 // fDisableWriting=true; // disable creation of stand-alone class; 87 // ToDo we need to tell the transformation that it cannot write itself; 88 }; 89 // workaround end; 90 ; 91 Int_t parenthesisCount = 0;; 92 for (Int_t position = 0, size = trafoDefinition.Sizeof(); position < size; ++position) {; 93 TString ch = trafoDefinition(position,1);; 94 if (ch == ""("") ++parenthesisCount;; 95 else if (ch == "")"") --parenthesisCount;; 96 else if (ch == "","" && parenthesisCount == 0) trafoDefinition.Replace(position,1,'+');; 97 }; 98 ; 99 TList* trList = gTools().ParseFormatLine( trafoDefinition, ""+"" );; 100 TListIter trIt(trList);; 101 while (TObjString* os = (TObjString*)trIt()) {; 102 TString tdef = os->GetString();; 103 Int_t idxCls = -1;; 104 ; 105 TString variables = """";; 106 if (tdef.Contains(""("")) { // contains selection of variables; 107 Ssiz_t parStart = tdef.Index( ""("" );; 108 Ssiz_t parLen = tdef.Index( "")"", parStart )-parStart+1;; 109 ; 110 variables = tdef(parStart,parLen);; 111 tdef.Remove(parStart,parLen);; 112 variables.Remove(parLen-1,1);; 113 variables.Remove(0,1);; 114 }; 115 ; 116 TList* trClsList = gTools().ParseFormatLine( tdef, ""_"" ); // split entry to get trf-name and class-name; 117 TListIter trClsIt(trClsList);; 118 if (trClsList->GetSize() < 1); 119 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Incorrect transformation string provided."" << Endl;; 120 const TString& trName = ((TObjString*)trClsList->At(0))->GetString();; 121 ; 122 if (trClsList->GetEntries() > 1) {; 123 TString trCls = ""AllClasses"";; 124 ClassInfo *ci = NULL;; 125 trCls = ((TObjString*)trClsList->At(1))->GetString();; 126 if (trCls != ""AllClasses"") {; 127 ci = dataInfo.GetClassInfo( trCls );; 128 if (ci == NULL); 129 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Class "" << trCls << "" not ",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:4481,Modifiability,variab,variables,4481,"s not work since this function is static; 86 // fDisableWriting=true; // disable creation of stand-alone class; 87 // ToDo we need to tell the transformation that it cannot write itself; 88 }; 89 // workaround end; 90 ; 91 Int_t parenthesisCount = 0;; 92 for (Int_t position = 0, size = trafoDefinition.Sizeof(); position < size; ++position) {; 93 TString ch = trafoDefinition(position,1);; 94 if (ch == ""("") ++parenthesisCount;; 95 else if (ch == "")"") --parenthesisCount;; 96 else if (ch == "","" && parenthesisCount == 0) trafoDefinition.Replace(position,1,'+');; 97 }; 98 ; 99 TList* trList = gTools().ParseFormatLine( trafoDefinition, ""+"" );; 100 TListIter trIt(trList);; 101 while (TObjString* os = (TObjString*)trIt()) {; 102 TString tdef = os->GetString();; 103 Int_t idxCls = -1;; 104 ; 105 TString variables = """";; 106 if (tdef.Contains(""("")) { // contains selection of variables; 107 Ssiz_t parStart = tdef.Index( ""("" );; 108 Ssiz_t parLen = tdef.Index( "")"", parStart )-parStart+1;; 109 ; 110 variables = tdef(parStart,parLen);; 111 tdef.Remove(parStart,parLen);; 112 variables.Remove(parLen-1,1);; 113 variables.Remove(0,1);; 114 }; 115 ; 116 TList* trClsList = gTools().ParseFormatLine( tdef, ""_"" ); // split entry to get trf-name and class-name; 117 TListIter trClsIt(trClsList);; 118 if (trClsList->GetSize() < 1); 119 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Incorrect transformation string provided."" << Endl;; 120 const TString& trName = ((TObjString*)trClsList->At(0))->GetString();; 121 ; 122 if (trClsList->GetEntries() > 1) {; 123 TString trCls = ""AllClasses"";; 124 ClassInfo *ci = NULL;; 125 trCls = ((TObjString*)trClsList->At(1))->GetString();; 126 if (trCls != ""AllClasses"") {; 127 ci = dataInfo.GetClassInfo( trCls );; 128 if (ci == NULL); 129 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Class "" << trCls << "" not known for variable transformation ""; 130 << trName << "", please check."" << Endl;; 131 else; 132 idxCls = ci->GetNumber();; 133",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:4556,Modifiability,variab,variables,4556,"ue; // disable creation of stand-alone class; 87 // ToDo we need to tell the transformation that it cannot write itself; 88 }; 89 // workaround end; 90 ; 91 Int_t parenthesisCount = 0;; 92 for (Int_t position = 0, size = trafoDefinition.Sizeof(); position < size; ++position) {; 93 TString ch = trafoDefinition(position,1);; 94 if (ch == ""("") ++parenthesisCount;; 95 else if (ch == "")"") --parenthesisCount;; 96 else if (ch == "","" && parenthesisCount == 0) trafoDefinition.Replace(position,1,'+');; 97 }; 98 ; 99 TList* trList = gTools().ParseFormatLine( trafoDefinition, ""+"" );; 100 TListIter trIt(trList);; 101 while (TObjString* os = (TObjString*)trIt()) {; 102 TString tdef = os->GetString();; 103 Int_t idxCls = -1;; 104 ; 105 TString variables = """";; 106 if (tdef.Contains(""("")) { // contains selection of variables; 107 Ssiz_t parStart = tdef.Index( ""("" );; 108 Ssiz_t parLen = tdef.Index( "")"", parStart )-parStart+1;; 109 ; 110 variables = tdef(parStart,parLen);; 111 tdef.Remove(parStart,parLen);; 112 variables.Remove(parLen-1,1);; 113 variables.Remove(0,1);; 114 }; 115 ; 116 TList* trClsList = gTools().ParseFormatLine( tdef, ""_"" ); // split entry to get trf-name and class-name; 117 TListIter trClsIt(trClsList);; 118 if (trClsList->GetSize() < 1); 119 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Incorrect transformation string provided."" << Endl;; 120 const TString& trName = ((TObjString*)trClsList->At(0))->GetString();; 121 ; 122 if (trClsList->GetEntries() > 1) {; 123 TString trCls = ""AllClasses"";; 124 ClassInfo *ci = NULL;; 125 trCls = ((TObjString*)trClsList->At(1))->GetString();; 126 if (trCls != ""AllClasses"") {; 127 ci = dataInfo.GetClassInfo( trCls );; 128 if (ci == NULL); 129 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Class "" << trCls << "" not known for variable transformation ""; 130 << trName << "", please check."" << Endl;; 131 else; 132 idxCls = ci->GetNumber();; 133 }; 134 }; 135 ; 136 VariableTransformBase* transformation = NULL",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:4591,Modifiability,variab,variables,4591,"e class; 87 // ToDo we need to tell the transformation that it cannot write itself; 88 }; 89 // workaround end; 90 ; 91 Int_t parenthesisCount = 0;; 92 for (Int_t position = 0, size = trafoDefinition.Sizeof(); position < size; ++position) {; 93 TString ch = trafoDefinition(position,1);; 94 if (ch == ""("") ++parenthesisCount;; 95 else if (ch == "")"") --parenthesisCount;; 96 else if (ch == "","" && parenthesisCount == 0) trafoDefinition.Replace(position,1,'+');; 97 }; 98 ; 99 TList* trList = gTools().ParseFormatLine( trafoDefinition, ""+"" );; 100 TListIter trIt(trList);; 101 while (TObjString* os = (TObjString*)trIt()) {; 102 TString tdef = os->GetString();; 103 Int_t idxCls = -1;; 104 ; 105 TString variables = """";; 106 if (tdef.Contains(""("")) { // contains selection of variables; 107 Ssiz_t parStart = tdef.Index( ""("" );; 108 Ssiz_t parLen = tdef.Index( "")"", parStart )-parStart+1;; 109 ; 110 variables = tdef(parStart,parLen);; 111 tdef.Remove(parStart,parLen);; 112 variables.Remove(parLen-1,1);; 113 variables.Remove(0,1);; 114 }; 115 ; 116 TList* trClsList = gTools().ParseFormatLine( tdef, ""_"" ); // split entry to get trf-name and class-name; 117 TListIter trClsIt(trClsList);; 118 if (trClsList->GetSize() < 1); 119 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Incorrect transformation string provided."" << Endl;; 120 const TString& trName = ((TObjString*)trClsList->At(0))->GetString();; 121 ; 122 if (trClsList->GetEntries() > 1) {; 123 TString trCls = ""AllClasses"";; 124 ClassInfo *ci = NULL;; 125 trCls = ((TObjString*)trClsList->At(1))->GetString();; 126 if (trCls != ""AllClasses"") {; 127 ci = dataInfo.GetClassInfo( trCls );; 128 if (ci == NULL); 129 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Class "" << trCls << "" not known for variable transformation ""; 130 << trName << "", please check."" << Endl;; 131 else; 132 idxCls = ci->GetNumber();; 133 }; 134 }; 135 ; 136 VariableTransformBase* transformation = NULL;; 137 if (trName == ""I"" || trName == ",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:5365,Modifiability,variab,variable,5365,"7 Ssiz_t parStart = tdef.Index( ""("" );; 108 Ssiz_t parLen = tdef.Index( "")"", parStart )-parStart+1;; 109 ; 110 variables = tdef(parStart,parLen);; 111 tdef.Remove(parStart,parLen);; 112 variables.Remove(parLen-1,1);; 113 variables.Remove(0,1);; 114 }; 115 ; 116 TList* trClsList = gTools().ParseFormatLine( tdef, ""_"" ); // split entry to get trf-name and class-name; 117 TListIter trClsIt(trClsList);; 118 if (trClsList->GetSize() < 1); 119 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Incorrect transformation string provided."" << Endl;; 120 const TString& trName = ((TObjString*)trClsList->At(0))->GetString();; 121 ; 122 if (trClsList->GetEntries() > 1) {; 123 TString trCls = ""AllClasses"";; 124 ClassInfo *ci = NULL;; 125 trCls = ((TObjString*)trClsList->At(1))->GetString();; 126 if (trCls != ""AllClasses"") {; 127 ci = dataInfo.GetClassInfo( trCls );; 128 if (ci == NULL); 129 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Class "" << trCls << "" not known for variable transformation ""; 130 << trName << "", please check."" << Endl;; 131 else; 132 idxCls = ci->GetNumber();; 133 }; 134 }; 135 ; 136 VariableTransformBase* transformation = NULL;; 137 if (trName == ""I"" || trName == ""Ident"" || trName == ""Identity"") {; 138 if (variables.Length() == 0) variables = ""_V_"";; 139 transformation = new VariableIdentityTransform(dataInfo);; 140 }; 141 else if (trName == ""D"" || trName == ""Deco"" || trName == ""Decorrelate"") {; 142 if (variables.Length() == 0) variables = ""_V_"";; 143 transformation = new VariableDecorrTransform(dataInfo);; 144 }; 145 else if (trName == ""P"" || trName == ""PCA"") {; 146 if (variables.Length() == 0) variables = ""_V_"";; 147 transformation = new VariablePCATransform(dataInfo);; 148 }; 149 else if (trName == ""U"" || trName == ""Uniform"") {; 150 if (variables.Length() == 0) variables = ""_V_,_T_"";; 151 transformation = new VariableGaussTransform(dataInfo, ""Uniform"" );; 152 }; 153 else if (trName == ""G"" || trName == ""Gauss"") {; 154 if (variables.",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:5628,Modifiability,variab,variables,5628,"e(parStart,parLen);; 112 variables.Remove(parLen-1,1);; 113 variables.Remove(0,1);; 114 }; 115 ; 116 TList* trClsList = gTools().ParseFormatLine( tdef, ""_"" ); // split entry to get trf-name and class-name; 117 TListIter trClsIt(trClsList);; 118 if (trClsList->GetSize() < 1); 119 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Incorrect transformation string provided."" << Endl;; 120 const TString& trName = ((TObjString*)trClsList->At(0))->GetString();; 121 ; 122 if (trClsList->GetEntries() > 1) {; 123 TString trCls = ""AllClasses"";; 124 ClassInfo *ci = NULL;; 125 trCls = ((TObjString*)trClsList->At(1))->GetString();; 126 if (trCls != ""AllClasses"") {; 127 ci = dataInfo.GetClassInfo( trCls );; 128 if (ci == NULL); 129 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Class "" << trCls << "" not known for variable transformation ""; 130 << trName << "", please check."" << Endl;; 131 else; 132 idxCls = ci->GetNumber();; 133 }; 134 }; 135 ; 136 VariableTransformBase* transformation = NULL;; 137 if (trName == ""I"" || trName == ""Ident"" || trName == ""Identity"") {; 138 if (variables.Length() == 0) variables = ""_V_"";; 139 transformation = new VariableIdentityTransform(dataInfo);; 140 }; 141 else if (trName == ""D"" || trName == ""Deco"" || trName == ""Decorrelate"") {; 142 if (variables.Length() == 0) variables = ""_V_"";; 143 transformation = new VariableDecorrTransform(dataInfo);; 144 }; 145 else if (trName == ""P"" || trName == ""PCA"") {; 146 if (variables.Length() == 0) variables = ""_V_"";; 147 transformation = new VariablePCATransform(dataInfo);; 148 }; 149 else if (trName == ""U"" || trName == ""Uniform"") {; 150 if (variables.Length() == 0) variables = ""_V_,_T_"";; 151 transformation = new VariableGaussTransform(dataInfo, ""Uniform"" );; 152 }; 153 else if (trName == ""G"" || trName == ""Gauss"") {; 154 if (variables.Length() == 0) variables = ""_V_"";; 155 transformation = new VariableGaussTransform(dataInfo);; 156 }; 157 else if (trName == ""N"" || trName == ""Norm"" || trName == ",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:5653,Modifiability,variab,variables,5653,"17 TListIter trClsIt(trClsList);; 118 if (trClsList->GetSize() < 1); 119 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Incorrect transformation string provided."" << Endl;; 120 const TString& trName = ((TObjString*)trClsList->At(0))->GetString();; 121 ; 122 if (trClsList->GetEntries() > 1) {; 123 TString trCls = ""AllClasses"";; 124 ClassInfo *ci = NULL;; 125 trCls = ((TObjString*)trClsList->At(1))->GetString();; 126 if (trCls != ""AllClasses"") {; 127 ci = dataInfo.GetClassInfo( trCls );; 128 if (ci == NULL); 129 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Class "" << trCls << "" not known for variable transformation ""; 130 << trName << "", please check."" << Endl;; 131 else; 132 idxCls = ci->GetNumber();; 133 }; 134 }; 135 ; 136 VariableTransformBase* transformation = NULL;; 137 if (trName == ""I"" || trName == ""Ident"" || trName == ""Identity"") {; 138 if (variables.Length() == 0) variables = ""_V_"";; 139 transformation = new VariableIdentityTransform(dataInfo);; 140 }; 141 else if (trName == ""D"" || trName == ""Deco"" || trName == ""Decorrelate"") {; 142 if (variables.Length() == 0) variables = ""_V_"";; 143 transformation = new VariableDecorrTransform(dataInfo);; 144 }; 145 else if (trName == ""P"" || trName == ""PCA"") {; 146 if (variables.Length() == 0) variables = ""_V_"";; 147 transformation = new VariablePCATransform(dataInfo);; 148 }; 149 else if (trName == ""U"" || trName == ""Uniform"") {; 150 if (variables.Length() == 0) variables = ""_V_,_T_"";; 151 transformation = new VariableGaussTransform(dataInfo, ""Uniform"" );; 152 }; 153 else if (trName == ""G"" || trName == ""Gauss"") {; 154 if (variables.Length() == 0) variables = ""_V_"";; 155 transformation = new VariableGaussTransform(dataInfo);; 156 }; 157 else if (trName == ""N"" || trName == ""Norm"" || trName == ""Normalise"" || trName == ""Normalize"") {; 158 if (variables.Length() == 0) variables = ""_V_,_T_"";; 159 transformation = new VariableNormalizeTransform(dataInfo);; 160 }; 161 else; 162 log << kFATAL << Form(""D",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:5829,Modifiability,variab,variables,5829,"17 TListIter trClsIt(trClsList);; 118 if (trClsList->GetSize() < 1); 119 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Incorrect transformation string provided."" << Endl;; 120 const TString& trName = ((TObjString*)trClsList->At(0))->GetString();; 121 ; 122 if (trClsList->GetEntries() > 1) {; 123 TString trCls = ""AllClasses"";; 124 ClassInfo *ci = NULL;; 125 trCls = ((TObjString*)trClsList->At(1))->GetString();; 126 if (trCls != ""AllClasses"") {; 127 ci = dataInfo.GetClassInfo( trCls );; 128 if (ci == NULL); 129 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Class "" << trCls << "" not known for variable transformation ""; 130 << trName << "", please check."" << Endl;; 131 else; 132 idxCls = ci->GetNumber();; 133 }; 134 }; 135 ; 136 VariableTransformBase* transformation = NULL;; 137 if (trName == ""I"" || trName == ""Ident"" || trName == ""Identity"") {; 138 if (variables.Length() == 0) variables = ""_V_"";; 139 transformation = new VariableIdentityTransform(dataInfo);; 140 }; 141 else if (trName == ""D"" || trName == ""Deco"" || trName == ""Decorrelate"") {; 142 if (variables.Length() == 0) variables = ""_V_"";; 143 transformation = new VariableDecorrTransform(dataInfo);; 144 }; 145 else if (trName == ""P"" || trName == ""PCA"") {; 146 if (variables.Length() == 0) variables = ""_V_"";; 147 transformation = new VariablePCATransform(dataInfo);; 148 }; 149 else if (trName == ""U"" || trName == ""Uniform"") {; 150 if (variables.Length() == 0) variables = ""_V_,_T_"";; 151 transformation = new VariableGaussTransform(dataInfo, ""Uniform"" );; 152 }; 153 else if (trName == ""G"" || trName == ""Gauss"") {; 154 if (variables.Length() == 0) variables = ""_V_"";; 155 transformation = new VariableGaussTransform(dataInfo);; 156 }; 157 else if (trName == ""N"" || trName == ""Norm"" || trName == ""Normalise"" || trName == ""Normalize"") {; 158 if (variables.Length() == 0) variables = ""_V_,_T_"";; 159 transformation = new VariableNormalizeTransform(dataInfo);; 160 }; 161 else; 162 log << kFATAL << Form(""D",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:5854,Modifiability,variab,variables,5854," 120 const TString& trName = ((TObjString*)trClsList->At(0))->GetString();; 121 ; 122 if (trClsList->GetEntries() > 1) {; 123 TString trCls = ""AllClasses"";; 124 ClassInfo *ci = NULL;; 125 trCls = ((TObjString*)trClsList->At(1))->GetString();; 126 if (trCls != ""AllClasses"") {; 127 ci = dataInfo.GetClassInfo( trCls );; 128 if (ci == NULL); 129 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Class "" << trCls << "" not known for variable transformation ""; 130 << trName << "", please check."" << Endl;; 131 else; 132 idxCls = ci->GetNumber();; 133 }; 134 }; 135 ; 136 VariableTransformBase* transformation = NULL;; 137 if (trName == ""I"" || trName == ""Ident"" || trName == ""Identity"") {; 138 if (variables.Length() == 0) variables = ""_V_"";; 139 transformation = new VariableIdentityTransform(dataInfo);; 140 }; 141 else if (trName == ""D"" || trName == ""Deco"" || trName == ""Decorrelate"") {; 142 if (variables.Length() == 0) variables = ""_V_"";; 143 transformation = new VariableDecorrTransform(dataInfo);; 144 }; 145 else if (trName == ""P"" || trName == ""PCA"") {; 146 if (variables.Length() == 0) variables = ""_V_"";; 147 transformation = new VariablePCATransform(dataInfo);; 148 }; 149 else if (trName == ""U"" || trName == ""Uniform"") {; 150 if (variables.Length() == 0) variables = ""_V_,_T_"";; 151 transformation = new VariableGaussTransform(dataInfo, ""Uniform"" );; 152 }; 153 else if (trName == ""G"" || trName == ""Gauss"") {; 154 if (variables.Length() == 0) variables = ""_V_"";; 155 transformation = new VariableGaussTransform(dataInfo);; 156 }; 157 else if (trName == ""N"" || trName == ""Norm"" || trName == ""Normalise"" || trName == ""Normalize"") {; 158 if (variables.Length() == 0) variables = ""_V_,_T_"";; 159 transformation = new VariableNormalizeTransform(dataInfo);; 160 }; 161 else; 162 log << kFATAL << Form(""Dataset[%s] : "",dataInfo.GetName()); 163 << ""<ProcessOptions> Variable transform '""; 164 << trName << ""' unknown."" << Endl;; 165 ; 166 ; 167 if (transformation) {; 168 ClassInfo* clsInfo ",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:6000,Modifiability,variab,variables,6000," 120 const TString& trName = ((TObjString*)trClsList->At(0))->GetString();; 121 ; 122 if (trClsList->GetEntries() > 1) {; 123 TString trCls = ""AllClasses"";; 124 ClassInfo *ci = NULL;; 125 trCls = ((TObjString*)trClsList->At(1))->GetString();; 126 if (trCls != ""AllClasses"") {; 127 ci = dataInfo.GetClassInfo( trCls );; 128 if (ci == NULL); 129 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Class "" << trCls << "" not known for variable transformation ""; 130 << trName << "", please check."" << Endl;; 131 else; 132 idxCls = ci->GetNumber();; 133 }; 134 }; 135 ; 136 VariableTransformBase* transformation = NULL;; 137 if (trName == ""I"" || trName == ""Ident"" || trName == ""Identity"") {; 138 if (variables.Length() == 0) variables = ""_V_"";; 139 transformation = new VariableIdentityTransform(dataInfo);; 140 }; 141 else if (trName == ""D"" || trName == ""Deco"" || trName == ""Decorrelate"") {; 142 if (variables.Length() == 0) variables = ""_V_"";; 143 transformation = new VariableDecorrTransform(dataInfo);; 144 }; 145 else if (trName == ""P"" || trName == ""PCA"") {; 146 if (variables.Length() == 0) variables = ""_V_"";; 147 transformation = new VariablePCATransform(dataInfo);; 148 }; 149 else if (trName == ""U"" || trName == ""Uniform"") {; 150 if (variables.Length() == 0) variables = ""_V_,_T_"";; 151 transformation = new VariableGaussTransform(dataInfo, ""Uniform"" );; 152 }; 153 else if (trName == ""G"" || trName == ""Gauss"") {; 154 if (variables.Length() == 0) variables = ""_V_"";; 155 transformation = new VariableGaussTransform(dataInfo);; 156 }; 157 else if (trName == ""N"" || trName == ""Norm"" || trName == ""Normalise"" || trName == ""Normalize"") {; 158 if (variables.Length() == 0) variables = ""_V_,_T_"";; 159 transformation = new VariableNormalizeTransform(dataInfo);; 160 }; 161 else; 162 log << kFATAL << Form(""Dataset[%s] : "",dataInfo.GetName()); 163 << ""<ProcessOptions> Variable transform '""; 164 << trName << ""' unknown."" << Endl;; 165 ; 166 ; 167 if (transformation) {; 168 ClassInfo* clsInfo ",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:6025,Modifiability,variab,variables,6025,"ci = NULL;; 125 trCls = ((TObjString*)trClsList->At(1))->GetString();; 126 if (trCls != ""AllClasses"") {; 127 ci = dataInfo.GetClassInfo( trCls );; 128 if (ci == NULL); 129 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Class "" << trCls << "" not known for variable transformation ""; 130 << trName << "", please check."" << Endl;; 131 else; 132 idxCls = ci->GetNumber();; 133 }; 134 }; 135 ; 136 VariableTransformBase* transformation = NULL;; 137 if (trName == ""I"" || trName == ""Ident"" || trName == ""Identity"") {; 138 if (variables.Length() == 0) variables = ""_V_"";; 139 transformation = new VariableIdentityTransform(dataInfo);; 140 }; 141 else if (trName == ""D"" || trName == ""Deco"" || trName == ""Decorrelate"") {; 142 if (variables.Length() == 0) variables = ""_V_"";; 143 transformation = new VariableDecorrTransform(dataInfo);; 144 }; 145 else if (trName == ""P"" || trName == ""PCA"") {; 146 if (variables.Length() == 0) variables = ""_V_"";; 147 transformation = new VariablePCATransform(dataInfo);; 148 }; 149 else if (trName == ""U"" || trName == ""Uniform"") {; 150 if (variables.Length() == 0) variables = ""_V_,_T_"";; 151 transformation = new VariableGaussTransform(dataInfo, ""Uniform"" );; 152 }; 153 else if (trName == ""G"" || trName == ""Gauss"") {; 154 if (variables.Length() == 0) variables = ""_V_"";; 155 transformation = new VariableGaussTransform(dataInfo);; 156 }; 157 else if (trName == ""N"" || trName == ""Norm"" || trName == ""Normalise"" || trName == ""Normalize"") {; 158 if (variables.Length() == 0) variables = ""_V_,_T_"";; 159 transformation = new VariableNormalizeTransform(dataInfo);; 160 }; 161 else; 162 log << kFATAL << Form(""Dataset[%s] : "",dataInfo.GetName()); 163 << ""<ProcessOptions> Variable transform '""; 164 << trName << ""' unknown."" << Endl;; 165 ; 166 ; 167 if (transformation) {; 168 ClassInfo* clsInfo = dataInfo.GetClassInfo(idxCls);; 169 if (clsInfo); 170 log << kHEADER << Form(""[%s] : "",dataInfo.GetName()); 171 << ""Create Transformation \"""" << trName << ""\"" with refer",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:6172,Modifiability,variab,variables,6172,"ci = NULL;; 125 trCls = ((TObjString*)trClsList->At(1))->GetString();; 126 if (trCls != ""AllClasses"") {; 127 ci = dataInfo.GetClassInfo( trCls );; 128 if (ci == NULL); 129 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Class "" << trCls << "" not known for variable transformation ""; 130 << trName << "", please check."" << Endl;; 131 else; 132 idxCls = ci->GetNumber();; 133 }; 134 }; 135 ; 136 VariableTransformBase* transformation = NULL;; 137 if (trName == ""I"" || trName == ""Ident"" || trName == ""Identity"") {; 138 if (variables.Length() == 0) variables = ""_V_"";; 139 transformation = new VariableIdentityTransform(dataInfo);; 140 }; 141 else if (trName == ""D"" || trName == ""Deco"" || trName == ""Decorrelate"") {; 142 if (variables.Length() == 0) variables = ""_V_"";; 143 transformation = new VariableDecorrTransform(dataInfo);; 144 }; 145 else if (trName == ""P"" || trName == ""PCA"") {; 146 if (variables.Length() == 0) variables = ""_V_"";; 147 transformation = new VariablePCATransform(dataInfo);; 148 }; 149 else if (trName == ""U"" || trName == ""Uniform"") {; 150 if (variables.Length() == 0) variables = ""_V_,_T_"";; 151 transformation = new VariableGaussTransform(dataInfo, ""Uniform"" );; 152 }; 153 else if (trName == ""G"" || trName == ""Gauss"") {; 154 if (variables.Length() == 0) variables = ""_V_"";; 155 transformation = new VariableGaussTransform(dataInfo);; 156 }; 157 else if (trName == ""N"" || trName == ""Norm"" || trName == ""Normalise"" || trName == ""Normalize"") {; 158 if (variables.Length() == 0) variables = ""_V_,_T_"";; 159 transformation = new VariableNormalizeTransform(dataInfo);; 160 }; 161 else; 162 log << kFATAL << Form(""Dataset[%s] : "",dataInfo.GetName()); 163 << ""<ProcessOptions> Variable transform '""; 164 << trName << ""' unknown."" << Endl;; 165 ; 166 ; 167 if (transformation) {; 168 ClassInfo* clsInfo = dataInfo.GetClassInfo(idxCls);; 169 if (clsInfo); 170 log << kHEADER << Form(""[%s] : "",dataInfo.GetName()); 171 << ""Create Transformation \"""" << trName << ""\"" with refer",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:6197,Modifiability,variab,variables,6197,"FATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Class "" << trCls << "" not known for variable transformation ""; 130 << trName << "", please check."" << Endl;; 131 else; 132 idxCls = ci->GetNumber();; 133 }; 134 }; 135 ; 136 VariableTransformBase* transformation = NULL;; 137 if (trName == ""I"" || trName == ""Ident"" || trName == ""Identity"") {; 138 if (variables.Length() == 0) variables = ""_V_"";; 139 transformation = new VariableIdentityTransform(dataInfo);; 140 }; 141 else if (trName == ""D"" || trName == ""Deco"" || trName == ""Decorrelate"") {; 142 if (variables.Length() == 0) variables = ""_V_"";; 143 transformation = new VariableDecorrTransform(dataInfo);; 144 }; 145 else if (trName == ""P"" || trName == ""PCA"") {; 146 if (variables.Length() == 0) variables = ""_V_"";; 147 transformation = new VariablePCATransform(dataInfo);; 148 }; 149 else if (trName == ""U"" || trName == ""Uniform"") {; 150 if (variables.Length() == 0) variables = ""_V_,_T_"";; 151 transformation = new VariableGaussTransform(dataInfo, ""Uniform"" );; 152 }; 153 else if (trName == ""G"" || trName == ""Gauss"") {; 154 if (variables.Length() == 0) variables = ""_V_"";; 155 transformation = new VariableGaussTransform(dataInfo);; 156 }; 157 else if (trName == ""N"" || trName == ""Norm"" || trName == ""Normalise"" || trName == ""Normalize"") {; 158 if (variables.Length() == 0) variables = ""_V_,_T_"";; 159 transformation = new VariableNormalizeTransform(dataInfo);; 160 }; 161 else; 162 log << kFATAL << Form(""Dataset[%s] : "",dataInfo.GetName()); 163 << ""<ProcessOptions> Variable transform '""; 164 << trName << ""' unknown."" << Endl;; 165 ; 166 ; 167 if (transformation) {; 168 ClassInfo* clsInfo = dataInfo.GetClassInfo(idxCls);; 169 if (clsInfo); 170 log << kHEADER << Form(""[%s] : "",dataInfo.GetName()); 171 << ""Create Transformation \"""" << trName << ""\"" with reference class ""; 172 << clsInfo->GetName() << ""=(""<< idxCls <<"")"" << Endl << Endl;; 173 else; 174 log << kHEADER << Form(""[%s] : "",dataInfo.GetName()); 175 << ""Create Transformation \",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:6360,Modifiability,variab,variables,6360,"FATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Class "" << trCls << "" not known for variable transformation ""; 130 << trName << "", please check."" << Endl;; 131 else; 132 idxCls = ci->GetNumber();; 133 }; 134 }; 135 ; 136 VariableTransformBase* transformation = NULL;; 137 if (trName == ""I"" || trName == ""Ident"" || trName == ""Identity"") {; 138 if (variables.Length() == 0) variables = ""_V_"";; 139 transformation = new VariableIdentityTransform(dataInfo);; 140 }; 141 else if (trName == ""D"" || trName == ""Deco"" || trName == ""Decorrelate"") {; 142 if (variables.Length() == 0) variables = ""_V_"";; 143 transformation = new VariableDecorrTransform(dataInfo);; 144 }; 145 else if (trName == ""P"" || trName == ""PCA"") {; 146 if (variables.Length() == 0) variables = ""_V_"";; 147 transformation = new VariablePCATransform(dataInfo);; 148 }; 149 else if (trName == ""U"" || trName == ""Uniform"") {; 150 if (variables.Length() == 0) variables = ""_V_,_T_"";; 151 transformation = new VariableGaussTransform(dataInfo, ""Uniform"" );; 152 }; 153 else if (trName == ""G"" || trName == ""Gauss"") {; 154 if (variables.Length() == 0) variables = ""_V_"";; 155 transformation = new VariableGaussTransform(dataInfo);; 156 }; 157 else if (trName == ""N"" || trName == ""Norm"" || trName == ""Normalise"" || trName == ""Normalize"") {; 158 if (variables.Length() == 0) variables = ""_V_,_T_"";; 159 transformation = new VariableNormalizeTransform(dataInfo);; 160 }; 161 else; 162 log << kFATAL << Form(""Dataset[%s] : "",dataInfo.GetName()); 163 << ""<ProcessOptions> Variable transform '""; 164 << trName << ""' unknown."" << Endl;; 165 ; 166 ; 167 if (transformation) {; 168 ClassInfo* clsInfo = dataInfo.GetClassInfo(idxCls);; 169 if (clsInfo); 170 log << kHEADER << Form(""[%s] : "",dataInfo.GetName()); 171 << ""Create Transformation \"""" << trName << ""\"" with reference class ""; 172 << clsInfo->GetName() << ""=(""<< idxCls <<"")"" << Endl << Endl;; 173 else; 174 log << kHEADER << Form(""[%s] : "",dataInfo.GetName()); 175 << ""Create Transformation \",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:6385,Modifiability,variab,variables,6385,"3 }; 134 }; 135 ; 136 VariableTransformBase* transformation = NULL;; 137 if (trName == ""I"" || trName == ""Ident"" || trName == ""Identity"") {; 138 if (variables.Length() == 0) variables = ""_V_"";; 139 transformation = new VariableIdentityTransform(dataInfo);; 140 }; 141 else if (trName == ""D"" || trName == ""Deco"" || trName == ""Decorrelate"") {; 142 if (variables.Length() == 0) variables = ""_V_"";; 143 transformation = new VariableDecorrTransform(dataInfo);; 144 }; 145 else if (trName == ""P"" || trName == ""PCA"") {; 146 if (variables.Length() == 0) variables = ""_V_"";; 147 transformation = new VariablePCATransform(dataInfo);; 148 }; 149 else if (trName == ""U"" || trName == ""Uniform"") {; 150 if (variables.Length() == 0) variables = ""_V_,_T_"";; 151 transformation = new VariableGaussTransform(dataInfo, ""Uniform"" );; 152 }; 153 else if (trName == ""G"" || trName == ""Gauss"") {; 154 if (variables.Length() == 0) variables = ""_V_"";; 155 transformation = new VariableGaussTransform(dataInfo);; 156 }; 157 else if (trName == ""N"" || trName == ""Norm"" || trName == ""Normalise"" || trName == ""Normalize"") {; 158 if (variables.Length() == 0) variables = ""_V_,_T_"";; 159 transformation = new VariableNormalizeTransform(dataInfo);; 160 }; 161 else; 162 log << kFATAL << Form(""Dataset[%s] : "",dataInfo.GetName()); 163 << ""<ProcessOptions> Variable transform '""; 164 << trName << ""' unknown."" << Endl;; 165 ; 166 ; 167 if (transformation) {; 168 ClassInfo* clsInfo = dataInfo.GetClassInfo(idxCls);; 169 if (clsInfo); 170 log << kHEADER << Form(""[%s] : "",dataInfo.GetName()); 171 << ""Create Transformation \"""" << trName << ""\"" with reference class ""; 172 << clsInfo->GetName() << ""=(""<< idxCls <<"")"" << Endl << Endl;; 173 else; 174 log << kHEADER << Form(""[%s] : "",dataInfo.GetName()); 175 << ""Create Transformation \"""" << trName << ""\"" with events from all classes.""; 176 << Endl << Endl;; 177 ; 178 transformation->SelectInput(variables);; 179 transformationHandler.AddTransformation(transformation, idxCls);; 180 }; 181",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:6581,Modifiability,variab,variables,6581,"3 }; 134 }; 135 ; 136 VariableTransformBase* transformation = NULL;; 137 if (trName == ""I"" || trName == ""Ident"" || trName == ""Identity"") {; 138 if (variables.Length() == 0) variables = ""_V_"";; 139 transformation = new VariableIdentityTransform(dataInfo);; 140 }; 141 else if (trName == ""D"" || trName == ""Deco"" || trName == ""Decorrelate"") {; 142 if (variables.Length() == 0) variables = ""_V_"";; 143 transformation = new VariableDecorrTransform(dataInfo);; 144 }; 145 else if (trName == ""P"" || trName == ""PCA"") {; 146 if (variables.Length() == 0) variables = ""_V_"";; 147 transformation = new VariablePCATransform(dataInfo);; 148 }; 149 else if (trName == ""U"" || trName == ""Uniform"") {; 150 if (variables.Length() == 0) variables = ""_V_,_T_"";; 151 transformation = new VariableGaussTransform(dataInfo, ""Uniform"" );; 152 }; 153 else if (trName == ""G"" || trName == ""Gauss"") {; 154 if (variables.Length() == 0) variables = ""_V_"";; 155 transformation = new VariableGaussTransform(dataInfo);; 156 }; 157 else if (trName == ""N"" || trName == ""Norm"" || trName == ""Normalise"" || trName == ""Normalize"") {; 158 if (variables.Length() == 0) variables = ""_V_,_T_"";; 159 transformation = new VariableNormalizeTransform(dataInfo);; 160 }; 161 else; 162 log << kFATAL << Form(""Dataset[%s] : "",dataInfo.GetName()); 163 << ""<ProcessOptions> Variable transform '""; 164 << trName << ""' unknown."" << Endl;; 165 ; 166 ; 167 if (transformation) {; 168 ClassInfo* clsInfo = dataInfo.GetClassInfo(idxCls);; 169 if (clsInfo); 170 log << kHEADER << Form(""[%s] : "",dataInfo.GetName()); 171 << ""Create Transformation \"""" << trName << ""\"" with reference class ""; 172 << clsInfo->GetName() << ""=(""<< idxCls <<"")"" << Endl << Endl;; 173 else; 174 log << kHEADER << Form(""[%s] : "",dataInfo.GetName()); 175 << ""Create Transformation \"""" << trName << ""\"" with events from all classes.""; 176 << Endl << Endl;; 177 ; 178 transformation->SelectInput(variables);; 179 transformationHandler.AddTransformation(transformation, idxCls);; 180 }; 181",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:6606,Modifiability,variab,variables,6606,"transformation = new VariableIdentityTransform(dataInfo);; 140 }; 141 else if (trName == ""D"" || trName == ""Deco"" || trName == ""Decorrelate"") {; 142 if (variables.Length() == 0) variables = ""_V_"";; 143 transformation = new VariableDecorrTransform(dataInfo);; 144 }; 145 else if (trName == ""P"" || trName == ""PCA"") {; 146 if (variables.Length() == 0) variables = ""_V_"";; 147 transformation = new VariablePCATransform(dataInfo);; 148 }; 149 else if (trName == ""U"" || trName == ""Uniform"") {; 150 if (variables.Length() == 0) variables = ""_V_,_T_"";; 151 transformation = new VariableGaussTransform(dataInfo, ""Uniform"" );; 152 }; 153 else if (trName == ""G"" || trName == ""Gauss"") {; 154 if (variables.Length() == 0) variables = ""_V_"";; 155 transformation = new VariableGaussTransform(dataInfo);; 156 }; 157 else if (trName == ""N"" || trName == ""Norm"" || trName == ""Normalise"" || trName == ""Normalize"") {; 158 if (variables.Length() == 0) variables = ""_V_,_T_"";; 159 transformation = new VariableNormalizeTransform(dataInfo);; 160 }; 161 else; 162 log << kFATAL << Form(""Dataset[%s] : "",dataInfo.GetName()); 163 << ""<ProcessOptions> Variable transform '""; 164 << trName << ""' unknown."" << Endl;; 165 ; 166 ; 167 if (transformation) {; 168 ClassInfo* clsInfo = dataInfo.GetClassInfo(idxCls);; 169 if (clsInfo); 170 log << kHEADER << Form(""[%s] : "",dataInfo.GetName()); 171 << ""Create Transformation \"""" << trName << ""\"" with reference class ""; 172 << clsInfo->GetName() << ""=(""<< idxCls <<"")"" << Endl << Endl;; 173 else; 174 log << kHEADER << Form(""[%s] : "",dataInfo.GetName()); 175 << ""Create Transformation \"""" << trName << ""\"" with events from all classes.""; 176 << Endl << Endl;; 177 ; 178 transformation->SelectInput(variables);; 179 transformationHandler.AddTransformation(transformation, idxCls);; 180 }; 181 }; 182}; 183 ; 184}; DataSetInfo.h; MsgLogger.h; Ranking.h; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; THashTable.h; TList.h; TObjString.h; Formchar * Form(const ",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:7388,Modifiability,variab,variables,7388,"() == 0) variables = ""_V_"";; 155 transformation = new VariableGaussTransform(dataInfo);; 156 }; 157 else if (trName == ""N"" || trName == ""Norm"" || trName == ""Normalise"" || trName == ""Normalize"") {; 158 if (variables.Length() == 0) variables = ""_V_,_T_"";; 159 transformation = new VariableNormalizeTransform(dataInfo);; 160 }; 161 else; 162 log << kFATAL << Form(""Dataset[%s] : "",dataInfo.GetName()); 163 << ""<ProcessOptions> Variable transform '""; 164 << trName << ""' unknown."" << Endl;; 165 ; 166 ; 167 if (transformation) {; 168 ClassInfo* clsInfo = dataInfo.GetClassInfo(idxCls);; 169 if (clsInfo); 170 log << kHEADER << Form(""[%s] : "",dataInfo.GetName()); 171 << ""Create Transformation \"""" << trName << ""\"" with reference class ""; 172 << clsInfo->GetName() << ""=(""<< idxCls <<"")"" << Endl << Endl;; 173 else; 174 log << kHEADER << Form(""[%s] : "",dataInfo.GetName()); 175 << ""Create Transformation \"""" << trName << ""\"" with events from all classes.""; 176 << Endl << Endl;; 177 ; 178 transformation->SelectInput(variables);; 179 transformationHandler.AddTransformation(transformation, idxCls);; 180 }; 181 }; 182}; 183 ; 184}; DataSetInfo.h; MsgLogger.h; Ranking.h; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; THashTable.h; TList.h; TObjString.h; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; Tools.h; TransformationHandler.h; VariableDecorrTransform.h; VariableGaussTransform.h; VariableIdentityTransform.h; VariableInfo.h; VariableNormalizeTransform.h; VariablePCATransform.h; VariableTransformBase.h; Version.h; TCollection::GetEntriesvirtual Int_t GetEntries() constDefinition TCollection.h:179; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TListIterIterator of linked list.Definition TList.h:193; TListA doubly linked list.Definition TList.h:38; TList::AtTObject * At(Int_t idx) const overrideReturns the object at pos",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:9628,Modifiability,variab,variables,9628," ClassInfo.h:65; TMVA::DataSetInfoClass that contains all the data information.Definition DataSetInfo.h:62; TMVA::DataSetInfo::GetNamevirtual const char * GetName() constReturns name of object.Definition DataSetInfo.h:71; TMVA::DataSetInfo::GetClassInfoClassInfo * GetClassInfo(Int_t clNum) constDefinition DataSetInfo.cxx:146; TMVA::MsgLoggerostringstream derivative to redirect and format outputDefinition MsgLogger.h:57; TMVA::Tools::ParseFormatLineTList * ParseFormatLine(TString theString, const char *sep="":"")Parse the string and cut into labels separated by "":"".Definition Tools.cxx:401; TMVA::TransformationHandlerClass that contains all the data information.Definition TransformationHandler.h:56; TMVA::TransformationHandler::AddTransformationVariableTransformBase * AddTransformation(VariableTransformBase *, Int_t cls)Definition TransformationHandler.cxx:105; TMVA::VariableDecorrTransformLinear interpolation class.Definition VariableDecorrTransform.h:49; TMVA::VariableGaussTransformGaussian Transformation of input variables.Definition VariableGaussTransform.h:72; TMVA::VariableIdentityTransformLinear interpolation class.Definition VariableIdentityTransform.h:45; TMVA::VariableNormalizeTransformLinear interpolation class.Definition VariableNormalizeTransform.h:48; TMVA::VariablePCATransformLinear interpolation class.Definition VariablePCATransform.h:48; TMVA::VariableTransformBaseLinear interpolation class.Definition VariableTransformBase.h:54; TMVA::VariableTransformBase::SelectInputvirtual void SelectInput(const TString &inputVariables, Bool_t putIntoVariables=kFALSE)select the variables/targets/spectators which serve as input to the transformationDefinition VariableTransformBase.cxx:110; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjStringCollectable string class.Definition TObjString.h:28; TStringBasic string class.Definition TString.h:139; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:10204,Modifiability,variab,variables,10204,".cxx:401; TMVA::TransformationHandlerClass that contains all the data information.Definition TransformationHandler.h:56; TMVA::TransformationHandler::AddTransformationVariableTransformBase * AddTransformation(VariableTransformBase *, Int_t cls)Definition TransformationHandler.cxx:105; TMVA::VariableDecorrTransformLinear interpolation class.Definition VariableDecorrTransform.h:49; TMVA::VariableGaussTransformGaussian Transformation of input variables.Definition VariableGaussTransform.h:72; TMVA::VariableIdentityTransformLinear interpolation class.Definition VariableIdentityTransform.h:45; TMVA::VariableNormalizeTransformLinear interpolation class.Definition VariableNormalizeTransform.h:48; TMVA::VariablePCATransformLinear interpolation class.Definition VariablePCATransform.h:48; TMVA::VariableTransformBaseLinear interpolation class.Definition VariableTransformBase.h:54; TMVA::VariableTransformBase::SelectInputvirtual void SelectInput(const TString &inputVariables, Bool_t putIntoVariables=kFALSE)select the variables/targets/spectators which serve as input to the transformationDefinition VariableTransformBase.cxx:110; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjStringCollectable string class.Definition TObjString.h:28; TStringBasic string class.Definition TString.h:139; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Sizeofvirtual Int_t Sizeof() constReturns size string will occupy on I/O buffer.Definition TString.cxx:1401; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; int; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::gToolsTools & gTools(); TMVA::CreateVariableTransformsvoid CreateVariabl",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:11048,Modifiability,variab,variable,11048,"malizeTransformLinear interpolation class.Definition VariableNormalizeTransform.h:48; TMVA::VariablePCATransformLinear interpolation class.Definition VariablePCATransform.h:48; TMVA::VariableTransformBaseLinear interpolation class.Definition VariableTransformBase.h:54; TMVA::VariableTransformBase::SelectInputvirtual void SelectInput(const TString &inputVariables, Bool_t putIntoVariables=kFALSE)select the variables/targets/spectators which serve as input to the transformationDefinition VariableTransformBase.cxx:110; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjStringCollectable string class.Definition TObjString.h:28; TStringBasic string class.Definition TString.h:139; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Sizeofvirtual Int_t Sizeof() constReturns size string will occupy on I/O buffer.Definition TString.cxx:1401; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; int; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::gToolsTools & gTools(); TMVA::CreateVariableTransformsvoid CreateVariableTransforms(const TString &trafoDefinition, TMVA::DataSetInfo &dataInfo, TMVA::TransformationHandler &transformationHandler, TMVA::MsgLogger &log)Definition VariableTransform.cxx:59; TMVA::variablesvoid variables(TString dataset, TString fin=""TMVA.root"", TString dirName=""InputVariables_Id"", TString title=""TMVA Input Variables"", Bool_t isRegression=kFALSE, Bool_t useTMVAStyle=kTRUE); TMVA::EndlMsgLogger & Endl(MsgLogger &ml)Definition MsgLogger.h:148; Config.h; Types.h. tmvatmvasrcVariableTransform.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:01 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:11373,Modifiability,variab,variablesvoid,11373,"malizeTransformLinear interpolation class.Definition VariableNormalizeTransform.h:48; TMVA::VariablePCATransformLinear interpolation class.Definition VariablePCATransform.h:48; TMVA::VariableTransformBaseLinear interpolation class.Definition VariableTransformBase.h:54; TMVA::VariableTransformBase::SelectInputvirtual void SelectInput(const TString &inputVariables, Bool_t putIntoVariables=kFALSE)select the variables/targets/spectators which serve as input to the transformationDefinition VariableTransformBase.cxx:110; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjStringCollectable string class.Definition TObjString.h:28; TStringBasic string class.Definition TString.h:139; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Sizeofvirtual Int_t Sizeof() constReturns size string will occupy on I/O buffer.Definition TString.cxx:1401; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; int; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::gToolsTools & gTools(); TMVA::CreateVariableTransformsvoid CreateVariableTransforms(const TString &trafoDefinition, TMVA::DataSetInfo &dataInfo, TMVA::TransformationHandler &transformationHandler, TMVA::MsgLogger &log)Definition VariableTransform.cxx:59; TMVA::variablesvoid variables(TString dataset, TString fin=""TMVA.root"", TString dirName=""InputVariables_Id"", TString title=""TMVA Input Variables"", Bool_t isRegression=kFALSE, Bool_t useTMVAStyle=kTRUE); TMVA::EndlMsgLogger & Endl(MsgLogger &ml)Definition MsgLogger.h:148; Config.h; Types.h. tmvatmvasrcVariableTransform.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:01 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:11387,Modifiability,variab,variables,11387,"malizeTransformLinear interpolation class.Definition VariableNormalizeTransform.h:48; TMVA::VariablePCATransformLinear interpolation class.Definition VariablePCATransform.h:48; TMVA::VariableTransformBaseLinear interpolation class.Definition VariableTransformBase.h:54; TMVA::VariableTransformBase::SelectInputvirtual void SelectInput(const TString &inputVariables, Bool_t putIntoVariables=kFALSE)select the variables/targets/spectators which serve as input to the transformationDefinition VariableTransformBase.cxx:110; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjStringCollectable string class.Definition TObjString.h:28; TStringBasic string class.Definition TString.h:139; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Sizeofvirtual Int_t Sizeof() constReturns size string will occupy on I/O buffer.Definition TString.cxx:1401; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; int; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::gToolsTools & gTools(); TMVA::CreateVariableTransformsvoid CreateVariableTransforms(const TString &trafoDefinition, TMVA::DataSetInfo &dataInfo, TMVA::TransformationHandler &transformationHandler, TMVA::MsgLogger &log)Definition VariableTransform.cxx:59; TMVA::variablesvoid variables(TString dataset, TString fin=""TMVA.root"", TString dirName=""InputVariables_Id"", TString title=""TMVA Input Variables"", Bool_t isRegression=kFALSE, Bool_t useTMVAStyle=kTRUE); TMVA::EndlMsgLogger & Endl(MsgLogger &ml)Definition MsgLogger.h:148; Config.h; Types.h. tmvatmvasrcVariableTransform.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:01 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:2402,Testability,log,log,2402,"VA/VariableIdentityTransform.h""; 30#include ""TMVA/VariableDecorrTransform.h""; 31#include ""TMVA/VariableInfo.h""; 32#include ""TMVA/VariablePCATransform.h""; 33#include ""TMVA/VariableGaussTransform.h""; 34#include ""TMVA/VariableNormalizeTransform.h""; 35 ; 36#include ""TMVA/Config.h""; 37#include ""TMVA/DataSetInfo.h""; 38#include ""TMVA/MsgLogger.h""; 39#include ""TMVA/Ranking.h""; 40#include ""TMVA/Tools.h""; 41#include ""TMVA/Types.h""; 42#include ""TMVA/Version.h""; 43#include ""TMVA/TransformationHandler.h""; 44 ; 45#include ""THashTable.h""; 46#include ""TList.h""; 47#include ""TObjString.h""; 48 ; 49#include <algorithm>; 50#include <cassert>; 51#include <exception>; 52#include <stdexcept>; 53#include <set>; 54 ; 55////////////////////////////////////////////////////////////////////////////////; 56/// create variable transformations; 57 ; 58namespace TMVA {; 59void CreateVariableTransforms(const TString& trafoDefinitionIn,; 60 TMVA::DataSetInfo& dataInfo,; 61 TMVA::TransformationHandler& transformationHandler,; 62 TMVA::MsgLogger& log); 63{; 64 TString trafoDefinition(trafoDefinitionIn);; 65 if (trafoDefinition == ""None"") return; // no transformations; 66 ; 67 // workaround for transformations to complicated to be handled by makeclass; 68 // count number of transformations with incomplete set of variables; 69 TString trafoDefinitionCheck(trafoDefinitionIn);; 70 int npartial = 0;; 71 for (Int_t pos = 0, siz = trafoDefinition.Sizeof(); pos < siz; ++pos) {; 72 TString ch = trafoDefinition(pos,1);; 73 if ( ch == ""("" ) npartial++;; 74 }; 75 if (npartial>1) {; 76 log << kWARNING; 77 << ""The use of multiple partial variable transformations during the ""; 78 ""application phase can be properly invoked via the \""Reader\"", but ""; 79 ""it is not yet implemented in \""MakeClass\"", the creation mechanism ""; 80 ""for standalone C++ application classes. The standalone C++ class ""; 81 ""produced by this training job is thus INCOMPLETE AND MUST NOT BE USED! ""; 82 ""The transformation in question is: "" << trafoDe",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:2939,Testability,log,log,2939,"nclude <exception>; 52#include <stdexcept>; 53#include <set>; 54 ; 55////////////////////////////////////////////////////////////////////////////////; 56/// create variable transformations; 57 ; 58namespace TMVA {; 59void CreateVariableTransforms(const TString& trafoDefinitionIn,; 60 TMVA::DataSetInfo& dataInfo,; 61 TMVA::TransformationHandler& transformationHandler,; 62 TMVA::MsgLogger& log); 63{; 64 TString trafoDefinition(trafoDefinitionIn);; 65 if (trafoDefinition == ""None"") return; // no transformations; 66 ; 67 // workaround for transformations to complicated to be handled by makeclass; 68 // count number of transformations with incomplete set of variables; 69 TString trafoDefinitionCheck(trafoDefinitionIn);; 70 int npartial = 0;; 71 for (Int_t pos = 0, siz = trafoDefinition.Sizeof(); pos < siz; ++pos) {; 72 TString ch = trafoDefinition(pos,1);; 73 if ( ch == ""("" ) npartial++;; 74 }; 75 if (npartial>1) {; 76 log << kWARNING; 77 << ""The use of multiple partial variable transformations during the ""; 78 ""application phase can be properly invoked via the \""Reader\"", but ""; 79 ""it is not yet implemented in \""MakeClass\"", the creation mechanism ""; 80 ""for standalone C++ application classes. The standalone C++ class ""; 81 ""produced by this training job is thus INCOMPLETE AND MUST NOT BE USED! ""; 82 ""The transformation in question is: "" << trafoDefinitionIn << Endl;; 83 // ToDo make info and do not write the standalone class; 84 //; 85 // this does not work since this function is static; 86 // fDisableWriting=true; // disable creation of stand-alone class; 87 // ToDo we need to tell the transformation that it cannot write itself; 88 }; 89 // workaround end; 90 ; 91 Int_t parenthesisCount = 0;; 92 for (Int_t position = 0, size = trafoDefinition.Sizeof(); position < size; ++position) {; 93 TString ch = trafoDefinition(position,1);; 94 if (ch == ""("") ++parenthesisCount;; 95 else if (ch == "")"") --parenthesisCount;; 96 else if (ch == "","" && parenthesisCount == 0) trafoDefin",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:4811,Testability,log,log,4811," size = trafoDefinition.Sizeof(); position < size; ++position) {; 93 TString ch = trafoDefinition(position,1);; 94 if (ch == ""("") ++parenthesisCount;; 95 else if (ch == "")"") --parenthesisCount;; 96 else if (ch == "","" && parenthesisCount == 0) trafoDefinition.Replace(position,1,'+');; 97 }; 98 ; 99 TList* trList = gTools().ParseFormatLine( trafoDefinition, ""+"" );; 100 TListIter trIt(trList);; 101 while (TObjString* os = (TObjString*)trIt()) {; 102 TString tdef = os->GetString();; 103 Int_t idxCls = -1;; 104 ; 105 TString variables = """";; 106 if (tdef.Contains(""("")) { // contains selection of variables; 107 Ssiz_t parStart = tdef.Index( ""("" );; 108 Ssiz_t parLen = tdef.Index( "")"", parStart )-parStart+1;; 109 ; 110 variables = tdef(parStart,parLen);; 111 tdef.Remove(parStart,parLen);; 112 variables.Remove(parLen-1,1);; 113 variables.Remove(0,1);; 114 }; 115 ; 116 TList* trClsList = gTools().ParseFormatLine( tdef, ""_"" ); // split entry to get trf-name and class-name; 117 TListIter trClsIt(trClsList);; 118 if (trClsList->GetSize() < 1); 119 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Incorrect transformation string provided."" << Endl;; 120 const TString& trName = ((TObjString*)trClsList->At(0))->GetString();; 121 ; 122 if (trClsList->GetEntries() > 1) {; 123 TString trCls = ""AllClasses"";; 124 ClassInfo *ci = NULL;; 125 trCls = ((TObjString*)trClsList->At(1))->GetString();; 126 if (trCls != ""AllClasses"") {; 127 ci = dataInfo.GetClassInfo( trCls );; 128 if (ci == NULL); 129 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Class "" << trCls << "" not known for variable transformation ""; 130 << trName << "", please check."" << Endl;; 131 else; 132 idxCls = ci->GetNumber();; 133 }; 134 }; 135 ; 136 VariableTransformBase* transformation = NULL;; 137 if (trName == ""I"" || trName == ""Ident"" || trName == ""Identity"") {; 138 if (variables.Length() == 0) variables = ""_V_"";; 139 transformation = new VariableIdentityTransform(dataInfo);; 140 }; 141 else if (trN",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:5268,Testability,log,log,5268,"104 ; 105 TString variables = """";; 106 if (tdef.Contains(""("")) { // contains selection of variables; 107 Ssiz_t parStart = tdef.Index( ""("" );; 108 Ssiz_t parLen = tdef.Index( "")"", parStart )-parStart+1;; 109 ; 110 variables = tdef(parStart,parLen);; 111 tdef.Remove(parStart,parLen);; 112 variables.Remove(parLen-1,1);; 113 variables.Remove(0,1);; 114 }; 115 ; 116 TList* trClsList = gTools().ParseFormatLine( tdef, ""_"" ); // split entry to get trf-name and class-name; 117 TListIter trClsIt(trClsList);; 118 if (trClsList->GetSize() < 1); 119 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Incorrect transformation string provided."" << Endl;; 120 const TString& trName = ((TObjString*)trClsList->At(0))->GetString();; 121 ; 122 if (trClsList->GetEntries() > 1) {; 123 TString trCls = ""AllClasses"";; 124 ClassInfo *ci = NULL;; 125 trCls = ((TObjString*)trClsList->At(1))->GetString();; 126 if (trCls != ""AllClasses"") {; 127 ci = dataInfo.GetClassInfo( trCls );; 128 if (ci == NULL); 129 log << kFATAL <<Form(""Dataset[%s] : "",dataInfo.GetName())<< ""Class "" << trCls << "" not known for variable transformation ""; 130 << trName << "", please check."" << Endl;; 131 else; 132 idxCls = ci->GetNumber();; 133 }; 134 }; 135 ; 136 VariableTransformBase* transformation = NULL;; 137 if (trName == ""I"" || trName == ""Ident"" || trName == ""Identity"") {; 138 if (variables.Length() == 0) variables = ""_V_"";; 139 transformation = new VariableIdentityTransform(dataInfo);; 140 }; 141 else if (trName == ""D"" || trName == ""Deco"" || trName == ""Decorrelate"") {; 142 if (variables.Length() == 0) variables = ""_V_"";; 143 transformation = new VariableDecorrTransform(dataInfo);; 144 }; 145 else if (trName == ""P"" || trName == ""PCA"") {; 146 if (variables.Length() == 0) variables = ""_V_"";; 147 transformation = new VariablePCATransform(dataInfo);; 148 }; 149 else if (trName == ""U"" || trName == ""Uniform"") {; 150 if (variables.Length() == 0) variables = ""_V_,_T_"";; 151 transformation = new VariableGaussTransfor",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:6715,Testability,log,log,6715,"transformation = new VariableIdentityTransform(dataInfo);; 140 }; 141 else if (trName == ""D"" || trName == ""Deco"" || trName == ""Decorrelate"") {; 142 if (variables.Length() == 0) variables = ""_V_"";; 143 transformation = new VariableDecorrTransform(dataInfo);; 144 }; 145 else if (trName == ""P"" || trName == ""PCA"") {; 146 if (variables.Length() == 0) variables = ""_V_"";; 147 transformation = new VariablePCATransform(dataInfo);; 148 }; 149 else if (trName == ""U"" || trName == ""Uniform"") {; 150 if (variables.Length() == 0) variables = ""_V_,_T_"";; 151 transformation = new VariableGaussTransform(dataInfo, ""Uniform"" );; 152 }; 153 else if (trName == ""G"" || trName == ""Gauss"") {; 154 if (variables.Length() == 0) variables = ""_V_"";; 155 transformation = new VariableGaussTransform(dataInfo);; 156 }; 157 else if (trName == ""N"" || trName == ""Norm"" || trName == ""Normalise"" || trName == ""Normalize"") {; 158 if (variables.Length() == 0) variables = ""_V_,_T_"";; 159 transformation = new VariableNormalizeTransform(dataInfo);; 160 }; 161 else; 162 log << kFATAL << Form(""Dataset[%s] : "",dataInfo.GetName()); 163 << ""<ProcessOptions> Variable transform '""; 164 << trName << ""' unknown."" << Endl;; 165 ; 166 ; 167 if (transformation) {; 168 ClassInfo* clsInfo = dataInfo.GetClassInfo(idxCls);; 169 if (clsInfo); 170 log << kHEADER << Form(""[%s] : "",dataInfo.GetName()); 171 << ""Create Transformation \"""" << trName << ""\"" with reference class ""; 172 << clsInfo->GetName() << ""=(""<< idxCls <<"")"" << Endl << Endl;; 173 else; 174 log << kHEADER << Form(""[%s] : "",dataInfo.GetName()); 175 << ""Create Transformation \"""" << trName << ""\"" with events from all classes.""; 176 << Endl << Endl;; 177 ; 178 transformation->SelectInput(variables);; 179 transformationHandler.AddTransformation(transformation, idxCls);; 180 }; 181 }; 182}; 183 ; 184}; DataSetInfo.h; MsgLogger.h; Ranking.h; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; THashTable.h; TList.h; TObjString.h; Formchar * Form(const ",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:6981,Testability,log,log,6981,"== ""PCA"") {; 146 if (variables.Length() == 0) variables = ""_V_"";; 147 transformation = new VariablePCATransform(dataInfo);; 148 }; 149 else if (trName == ""U"" || trName == ""Uniform"") {; 150 if (variables.Length() == 0) variables = ""_V_,_T_"";; 151 transformation = new VariableGaussTransform(dataInfo, ""Uniform"" );; 152 }; 153 else if (trName == ""G"" || trName == ""Gauss"") {; 154 if (variables.Length() == 0) variables = ""_V_"";; 155 transformation = new VariableGaussTransform(dataInfo);; 156 }; 157 else if (trName == ""N"" || trName == ""Norm"" || trName == ""Normalise"" || trName == ""Normalize"") {; 158 if (variables.Length() == 0) variables = ""_V_,_T_"";; 159 transformation = new VariableNormalizeTransform(dataInfo);; 160 }; 161 else; 162 log << kFATAL << Form(""Dataset[%s] : "",dataInfo.GetName()); 163 << ""<ProcessOptions> Variable transform '""; 164 << trName << ""' unknown."" << Endl;; 165 ; 166 ; 167 if (transformation) {; 168 ClassInfo* clsInfo = dataInfo.GetClassInfo(idxCls);; 169 if (clsInfo); 170 log << kHEADER << Form(""[%s] : "",dataInfo.GetName()); 171 << ""Create Transformation \"""" << trName << ""\"" with reference class ""; 172 << clsInfo->GetName() << ""=(""<< idxCls <<"")"" << Endl << Endl;; 173 else; 174 log << kHEADER << Form(""[%s] : "",dataInfo.GetName()); 175 << ""Create Transformation \"""" << trName << ""\"" with events from all classes.""; 176 << Endl << Endl;; 177 ; 178 transformation->SelectInput(variables);; 179 transformationHandler.AddTransformation(transformation, idxCls);; 180 }; 181 }; 182}; 183 ; 184}; DataSetInfo.h; MsgLogger.h; Ranking.h; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; THashTable.h; TList.h; TObjString.h; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; Tools.h; TransformationHandler.h; VariableDecorrTransform.h; VariableGaussTransform.h; VariableIdentityTransform.h; VariableInfo.h; VariableNormalizeTransform.h; VariablePCATransform.h; VariableTransformBase.h; ",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:7191,Testability,log,log,7191,"e == ""U"" || trName == ""Uniform"") {; 150 if (variables.Length() == 0) variables = ""_V_,_T_"";; 151 transformation = new VariableGaussTransform(dataInfo, ""Uniform"" );; 152 }; 153 else if (trName == ""G"" || trName == ""Gauss"") {; 154 if (variables.Length() == 0) variables = ""_V_"";; 155 transformation = new VariableGaussTransform(dataInfo);; 156 }; 157 else if (trName == ""N"" || trName == ""Norm"" || trName == ""Normalise"" || trName == ""Normalize"") {; 158 if (variables.Length() == 0) variables = ""_V_,_T_"";; 159 transformation = new VariableNormalizeTransform(dataInfo);; 160 }; 161 else; 162 log << kFATAL << Form(""Dataset[%s] : "",dataInfo.GetName()); 163 << ""<ProcessOptions> Variable transform '""; 164 << trName << ""' unknown."" << Endl;; 165 ; 166 ; 167 if (transformation) {; 168 ClassInfo* clsInfo = dataInfo.GetClassInfo(idxCls);; 169 if (clsInfo); 170 log << kHEADER << Form(""[%s] : "",dataInfo.GetName()); 171 << ""Create Transformation \"""" << trName << ""\"" with reference class ""; 172 << clsInfo->GetName() << ""=(""<< idxCls <<"")"" << Endl << Endl;; 173 else; 174 log << kHEADER << Form(""[%s] : "",dataInfo.GetName()); 175 << ""Create Transformation \"""" << trName << ""\"" with events from all classes.""; 176 << Endl << Endl;; 177 ; 178 transformation->SelectInput(variables);; 179 transformationHandler.AddTransformation(transformation, idxCls);; 180 }; 181 }; 182}; 183 ; 184}; DataSetInfo.h; MsgLogger.h; Ranking.h; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; THashTable.h; TList.h; TObjString.h; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; Tools.h; TransformationHandler.h; VariableDecorrTransform.h; VariableGaussTransform.h; VariableIdentityTransform.h; VariableInfo.h; VariableNormalizeTransform.h; VariablePCATransform.h; VariableTransformBase.h; Version.h; TCollection::GetEntriesvirtual Int_t GetEntries() constDefinition TCollection.h:179; TCollection::GetSizevirtual Int_t GetSize() constRet",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/VariableTransform_8cxx_source.html:11326,Testability,log,log,11326,"malizeTransformLinear interpolation class.Definition VariableNormalizeTransform.h:48; TMVA::VariablePCATransformLinear interpolation class.Definition VariablePCATransform.h:48; TMVA::VariableTransformBaseLinear interpolation class.Definition VariableTransformBase.h:54; TMVA::VariableTransformBase::SelectInputvirtual void SelectInput(const TString &inputVariables, Bool_t putIntoVariables=kFALSE)select the variables/targets/spectators which serve as input to the transformationDefinition VariableTransformBase.cxx:110; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObjStringCollectable string class.Definition TObjString.h:28; TStringBasic string class.Definition TString.h:139; TString::ReplaceTString & Replace(Ssiz_t pos, Ssiz_t n, const char *s)Definition TString.h:694; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Sizeofvirtual Int_t Sizeof() constReturns size string will occupy on I/O buffer.Definition TString.cxx:1401; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; int; TMVAcreate variable transformationsDefinition GeneticMinimizer.h:22; TMVA::gToolsTools & gTools(); TMVA::CreateVariableTransformsvoid CreateVariableTransforms(const TString &trafoDefinition, TMVA::DataSetInfo &dataInfo, TMVA::TransformationHandler &transformationHandler, TMVA::MsgLogger &log)Definition VariableTransform.cxx:59; TMVA::variablesvoid variables(TString dataset, TString fin=""TMVA.root"", TString dirName=""InputVariables_Id"", TString title=""TMVA Input Variables"", Bool_t isRegression=kFALSE, Bool_t useTMVAStyle=kTRUE); TMVA::EndlMsgLogger & Endl(MsgLogger &ml)Definition MsgLogger.h:148; Config.h; Types.h. tmvatmvasrcVariableTransform.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:01 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/VariableTransform_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/VariableTransform_8cxx_source.html
https://root.cern/doc/master/Vavilov_8cxx_source.html:1427,Deployability,update,update,1427,"T Foundation, CERN/PH-SFT *; 8 * *; 9 * This library is free software; you can redistribute it and/or *; 10 * modify it under the terms of the GNU General Public License *; 11 * as published by the Free Software Foundation; either version 2 *; 12 * of the License, or (at your option) any later version. *; 13 * *; 14 * This library is distributed in the hope that it will be useful, *; 15 * but WITHOUT ANY WARRANTY; without even the implied warranty of *; 16 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU *; 17 * General Public License for more details. *; 18 * *; 19 * You should have received a copy of the GNU General Public License *; 20 * along with this library (see file COPYING); if not, write *; 21 * to the Free Software Foundation, Inc., 59 Temple Place, Suite *; 22 * 330, Boston, MA 02111-1307 USA, or contact the author. *; 23 * *; 24 **********************************************************************/; 25 ; 26// Implementation file for class Vavilov; 27//; 28// Created by: blist at Thu Apr 29 11:19:00 2010; 29//; 30// Last update: Thu Apr 29 11:19:00 2010; 31//; 32 ; 33 ; 34#include ""Math/Vavilov.h""; 35#include ""Math/VavilovAccurate.h""; 36#include ""Math/SpecFuncMathCore.h""; 37#include ""Math/SpecFuncMathMore.h""; 38 ; 39#include <cmath>; 40 ; 41namespace ROOT {; 42namespace Math {; 43 ; 44static const double eu = 0.577215664901532860606; // Euler's constant; 45 ; 46Vavilov::Vavilov(); 47{; 48}; 49 ; 50Vavilov::~Vavilov(); 51{; 52 // destructor (clean up resources); 53}; 54 ; 55 ; 56double Vavilov::Mode() const {; 57 double x = -4.22784335098467134e-01-std::log(GetKappa())-GetBeta2();; 58 if (x>-0.223172) x = -0.223172;; 59 double eps = 0.01;; 60 double dx;; 61 ; 62 do {; 63 double p0 = Pdf (x - eps);; 64 double p1 = Pdf (x);; 65 double p2 = Pdf (x + eps);; 66 double y1 = 0.5*(p2-p0)/eps;; 67 double y2 = (p2-2*p1+p0)/(eps*eps);; 68 dx = - y1/y2;; 69 x += dx;; 70 if (fabs(dx) < eps) eps = 0.1*fabs(dx);; 71 } while (fabs(dx) > 1E-5);; 72 retu",MatchSource.WIKI,doc/master/Vavilov_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Vavilov_8cxx_source.html
https://root.cern/doc/master/Vavilov_8cxx_source.html:1969,Testability,log,log,1969," a copy of the GNU General Public License *; 20 * along with this library (see file COPYING); if not, write *; 21 * to the Free Software Foundation, Inc., 59 Temple Place, Suite *; 22 * 330, Boston, MA 02111-1307 USA, or contact the author. *; 23 * *; 24 **********************************************************************/; 25 ; 26// Implementation file for class Vavilov; 27//; 28// Created by: blist at Thu Apr 29 11:19:00 2010; 29//; 30// Last update: Thu Apr 29 11:19:00 2010; 31//; 32 ; 33 ; 34#include ""Math/Vavilov.h""; 35#include ""Math/VavilovAccurate.h""; 36#include ""Math/SpecFuncMathCore.h""; 37#include ""Math/SpecFuncMathMore.h""; 38 ; 39#include <cmath>; 40 ; 41namespace ROOT {; 42namespace Math {; 43 ; 44static const double eu = 0.577215664901532860606; // Euler's constant; 45 ; 46Vavilov::Vavilov(); 47{; 48}; 49 ; 50Vavilov::~Vavilov(); 51{; 52 // destructor (clean up resources); 53}; 54 ; 55 ; 56double Vavilov::Mode() const {; 57 double x = -4.22784335098467134e-01-std::log(GetKappa())-GetBeta2();; 58 if (x>-0.223172) x = -0.223172;; 59 double eps = 0.01;; 60 double dx;; 61 ; 62 do {; 63 double p0 = Pdf (x - eps);; 64 double p1 = Pdf (x);; 65 double p2 = Pdf (x + eps);; 66 double y1 = 0.5*(p2-p0)/eps;; 67 double y2 = (p2-2*p1+p0)/(eps*eps);; 68 dx = - y1/y2;; 69 x += dx;; 70 if (fabs(dx) < eps) eps = 0.1*fabs(dx);; 71 } while (fabs(dx) > 1E-5);; 72 return x;; 73}; 74 ; 75double Vavilov::Mode(double kappa, double beta2) {; 76 SetKappaBeta2 (kappa, beta2);; 77 return Mode();; 78}; 79 ; 80double Vavilov::Mean() const {; 81 return Mean (GetKappa(), GetBeta2());; 82}; 83 ; 84double Vavilov::Mean(double kappa, double beta2) {; 85 return eu-1-std::log(kappa)-beta2;; 86}; 87 ; 88double Vavilov::Variance() const {; 89 return Variance (GetKappa(), GetBeta2());; 90}; 91 ; 92double Vavilov::Variance(double kappa, double beta2) {; 93 return (1-0.5*beta2)/kappa;; 94}; 95 ; 96double Vavilov::Skewness() const {; 97 return Skewness (GetKappa(), GetBeta2());; 98}; 99 ; 100dou",MatchSource.WIKI,doc/master/Vavilov_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Vavilov_8cxx_source.html
https://root.cern/doc/master/Vavilov_8cxx_source.html:2653,Testability,log,log,2653,"""; 37#include ""Math/SpecFuncMathMore.h""; 38 ; 39#include <cmath>; 40 ; 41namespace ROOT {; 42namespace Math {; 43 ; 44static const double eu = 0.577215664901532860606; // Euler's constant; 45 ; 46Vavilov::Vavilov(); 47{; 48}; 49 ; 50Vavilov::~Vavilov(); 51{; 52 // destructor (clean up resources); 53}; 54 ; 55 ; 56double Vavilov::Mode() const {; 57 double x = -4.22784335098467134e-01-std::log(GetKappa())-GetBeta2();; 58 if (x>-0.223172) x = -0.223172;; 59 double eps = 0.01;; 60 double dx;; 61 ; 62 do {; 63 double p0 = Pdf (x - eps);; 64 double p1 = Pdf (x);; 65 double p2 = Pdf (x + eps);; 66 double y1 = 0.5*(p2-p0)/eps;; 67 double y2 = (p2-2*p1+p0)/(eps*eps);; 68 dx = - y1/y2;; 69 x += dx;; 70 if (fabs(dx) < eps) eps = 0.1*fabs(dx);; 71 } while (fabs(dx) > 1E-5);; 72 return x;; 73}; 74 ; 75double Vavilov::Mode(double kappa, double beta2) {; 76 SetKappaBeta2 (kappa, beta2);; 77 return Mode();; 78}; 79 ; 80double Vavilov::Mean() const {; 81 return Mean (GetKappa(), GetBeta2());; 82}; 83 ; 84double Vavilov::Mean(double kappa, double beta2) {; 85 return eu-1-std::log(kappa)-beta2;; 86}; 87 ; 88double Vavilov::Variance() const {; 89 return Variance (GetKappa(), GetBeta2());; 90}; 91 ; 92double Vavilov::Variance(double kappa, double beta2) {; 93 return (1-0.5*beta2)/kappa;; 94}; 95 ; 96double Vavilov::Skewness() const {; 97 return Skewness (GetKappa(), GetBeta2());; 98}; 99 ; 100double Vavilov::Skewness(double kappa, double beta2) {; 101 return (0.5-beta2/3)/(kappa*kappa) * std::pow ((1-0.5*beta2)/kappa, -1.5);; 102}; 103 ; 104 ; 105double Vavilov::Kurtosis() const {; 106 return Kurtosis (GetKappa(), GetBeta2());; 107}; 108 ; 109double Vavilov::Kurtosis(double kappa, double beta2) {; 110 return (1./3-0.25*beta2)*pow (1-0.5*beta2, -2)/kappa;; 111}; 112 ; 113 ; 114} // namespace Math; 115} // namespace ROOT; SpecFuncMathCore.h; SpecFuncMathMore.h; y2Option_t Option_t TPoint TPoint const char y2Definition TGWin32VirtualXProxy.cxx:70; y1Option_t Option_t TPoint TPoint const cha",MatchSource.WIKI,doc/master/Vavilov_8cxx_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Vavilov_8cxx_source.html
https://root.cern/doc/master/Vector2D_8h.html:334,Integrability,depend,dependency,334,". ROOT: math/genvector/inc/Math/Vector2D.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Vector2D.h File Reference. #include ""Math/Vector2Dfwd.h""; #include ""Math/GenVector/Cartesian2D.h""; #include ""Math/GenVector/Polar2D.h""; #include ""Math/GenVector/DisplacementVector2D.h"". Include dependency graph for Vector2D.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. mathgenvectorincMathVector2D.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:21 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/Vector2D_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Vector2D_8h.html
https://root.cern/doc/master/Vector3Dfwd_8h_source.html:616,Deployability,update,update,616,". ROOT: math/genvector/inc/Math/Vector3Dfwd.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Vector3Dfwd.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file Vector3Dfwd; 12//; 13// Created by: Lorenzo Moneta at Mon May 30 18:08:35 2005; 14//; 15// Last update: Mon May 30 18:08:35 2005; 16//; 17#ifndef ROOT_Math_Vector3Dfwd; 18#define ROOT_Math_Vector3Dfwd 1; 19 ; 20// forward declarations of displacement vectors (Vectors) and type defs definitions; 21 ; 22namespace ROOT {; 23 ; 24 namespace Math {; 25 ; 26 ; 27 template<class CoordSystem, class Tag> class DisplacementVector3D;; 28 ; 29 template<typename T> class Cartesian3D;; 30 template<typename T> class CylindricalEta3D;; 31 template<typename T> class Polar3D;; 32 template<typename T> class Cylindrical3D;; 33 ; 34 class DefaultCoordinateSystemTag;; 35 ; 36 ; 37 /**; 38 3D Vector based on the cartesian coordinates x,y,z in double precision; 39 ; 40 To use it add the line `#include <Vector3D.h>`; 41 ; 42 See the documentation on the DisplacementVector3D page.; 43 */; 44 typedef DisplacementVector3D< Cartesian3D<double>, DefaultCoordinateSystemTag > XYZVector;; 45 /**; 46 3D Vector based on the cartesian coordinates x,y,z in single precision; 47 ; 48 To use it add the line `#include <Vector3D.h>`; 49 ; 50 See the documentation on the DisplacementVector3D page.; 51 */; 52 typedef DisplacementVector3D< Cartesian3D<float>, DefaultCoordinateSystemTag > XYZVectorF;; 53 typedef XYZVector XYZVectorD;; 54 ; 55 /**; 56 3D Vector based on the eta based cylindrical coordinates rho, eta, phi in double precision.; 57 ; 58 To use it add the line `#include <Vector3D.h>`; 59 ; ",MatchSource.WIKI,doc/master/Vector3Dfwd_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Vector3Dfwd_8h_source.html
https://root.cern/doc/master/Vector3D_8h.html:423,Integrability,depend,dependency,423,". ROOT: math/genvector/inc/Math/Vector3D.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Vector3D.h File Reference. #include ""Math/Vector3Dfwd.h""; #include ""Math/GenVector/Cartesian3D.h""; #include ""Math/GenVector/CylindricalEta3D.h""; #include ""Math/GenVector/Polar3D.h""; #include ""Math/GenVector/Cylindrical3D.h""; #include ""Math/GenVector/DisplacementVector3D.h"". Include dependency graph for Vector3D.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. mathgenvectorincMathVector3D.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:21 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/Vector3D_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Vector3D_8h.html
https://root.cern/doc/master/Vector4Dfwd_8h_source.html:623,Deployability,update,update,623,". ROOT: math/genvector/inc/Math/Vector4Dfwd.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Vector4Dfwd.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: W. Brown, M. Fischler, L. Moneta 2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class LorentzVectorfwd; 12//; 13// Created by: moneta at Tue May 31 21:06:43 2005; 14//; 15// Last update: Tue May 31 21:06:43 2005; 16//; 17#ifndef ROOT_Math_Vector4Dfwd; 18#define ROOT_Math_Vector4Dfwd 1; 19 ; 20 ; 21namespace ROOT {; 22 ; 23 namespace Math {; 24 ; 25 ; 26 // forward declarations of Lorentz Vectors and type defs definitions; 27 ; 28 template<class CoordSystem> class LorentzVector;; 29 ; 30 template<typename T> class PxPyPzE4D;; 31 template<typename T> class PtEtaPhiE4D;; 32 template<typename T> class PxPyPzM4D;; 33 template<typename T> class PtEtaPhiM4D;; 34// template<typename T> class EEtaPhiMSystem;; 35 ; 36 ; 37 // for LorentzVector have only double classes (define the vector in the global ref frame); 38 ; 39 /**; 40 LorentzVector based on x,y,x,t (or px,py,pz,E) coordinates in double precision with metric (-,-,-,+); 41 ; 42 To use it add the line `#include <Math/Vector4D.h>`; 43 ; 44 See the documentation on the LorentzVector page.; 45 */; 46 typedef LorentzVector<PxPyPzE4D<double> > XYZTVector;; 47 // for consistency; 48 typedef LorentzVector<PxPyPzE4D<double> > PxPyPzEVector;; 49 ; 50 ; 51 /**; 52 LorentzVector based on x,y,x,t (or px,py,pz,E) coordinates in float precision with metric (-,-,-,+); 53 ; 54 To use it add the line `#include <Math/Vector4D.h>`; 55 ; 56 See the documentation on the LorentzVector page.; 57 */; 58 typedef LorentzVector< PxPyPzE4D <float> > XYZTVectorF;; 59 ; 60 ; 61 /**; 62 LorentzVector based on the x",MatchSource.WIKI,doc/master/Vector4Dfwd_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Vector4Dfwd_8h_source.html
https://root.cern/doc/master/Vector4D_8h.html:409,Integrability,depend,dependency,409,". ROOT: math/genvector/inc/Math/Vector4D.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Vector4D.h File Reference. #include ""Math/Vector4Dfwd.h""; #include ""Math/GenVector/PxPyPzE4D.h""; #include ""Math/GenVector/PtEtaPhiE4D.h""; #include ""Math/GenVector/PxPyPzM4D.h""; #include ""Math/GenVector/PtEtaPhiM4D.h""; #include ""Math/GenVector/LorentzVector.h"". Include dependency graph for Vector4D.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. mathgenvectorincMathVector4D.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:21 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/Vector4D_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/Vector4D_8h.html
https://root.cern/doc/master/viewer3DLocal_8C.html:17980,Availability,mask,mask,17980,"TBuffer3D.h:145; TBuffer3DSphere::fPhiMaxDouble_t fPhiMaxDefinition TBuffer3D.h:149; TBuffer3DTypes::kGeneric@ kGenericDefinition TBuffer3DTypes.h:24; TBuffer3DGeneric 3D primitive description class.Definition TBuffer3D.h:18; TBuffer3D::SetLocalMasterIdentityvoid SetLocalMasterIdentity()Set kRaw tessellation section of buffer with supplied sizes.Definition TBuffer3D.cxx:297; TBuffer3D::fPolsInt_t * fPolsDefinition TBuffer3D.h:115; TBuffer3D::kBoundingBox@ kBoundingBoxDefinition TBuffer3D.h:51; TBuffer3D::kNone@ kNoneDefinition TBuffer3D.h:49; TBuffer3D::kShapeSpecific@ kShapeSpecificDefinition TBuffer3D.h:52; TBuffer3D::kRaw@ kRawDefinition TBuffer3D.h:54; TBuffer3D::kRawSizes@ kRawSizesDefinition TBuffer3D.h:53; TBuffer3D::kCore@ kCoreDefinition TBuffer3D.h:50; TBuffer3D::fLocalMasterDouble_t fLocalMaster[16]Definition TBuffer3D.h:93; TBuffer3D::ClearSectionsValidvoid ClearSectionsValid()Clear any sections marked valid.Definition TBuffer3D.cxx:287; TBuffer3D::SetSectionsValidvoid SetSectionsValid(UInt_t mask)Definition TBuffer3D.h:65; TBuffer3D::fSegsInt_t * fSegsDefinition TBuffer3D.h:114; TBuffer3D::fLocalFrameBool_t fLocalFrameDefinition TBuffer3D.h:90; TBuffer3D::fColorInt_t fColorDefinition TBuffer3D.h:88; TBuffer3D::fTransparencyShort_t fTransparencyDefinition TBuffer3D.h:89; TBuffer3D::SetAABoundingBoxvoid SetAABoundingBox(const Double_t origin[3], const Double_t halfLengths[3])Set fBBVertex in kBoundingBox section to a axis aligned (local) BB using supplied origin and box half...Definition TBuffer3D.cxx:321; TBuffer3D::fReflectionBool_t fReflectionDefinition TBuffer3D.h:91; TBuffer3D::fIDTObject * fIDDefinition TBuffer3D.h:87; TBuffer3D::SetRawSizesBool_t SetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity)Set kRaw tessellation section of buffer with supplied sizes.Definition TBuffer3D.cxx:360; TBuffer3D::fPntsDouble_t * fPntsDefinition TBuffer3D.h:113; TObjectMother of all ROOT o",MatchSource.WIKI,doc/master/viewer3DLocal_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/viewer3DLocal_8C.html
https://root.cern/doc/master/viewer3DLocal_8C.html:1186,Performance,load,loads,1186,"Matches. viewer3DLocal.C File ReferenceTutorials » OpenGL tutorials. Detailed Description; Demonstrates 3D viewer architecture TVirtualViewer3D and TBuffer3D in the local frame. ; Here each shape is described in a TBuffer3D class, with a suitible translation matrix to place each instance NOTE: to be executed via .x viewer3DLocal.C+; NOTE: We don't implement raw tesselation of sphere - hence this will not appear in viewers which don't support directly (non-OpenGL) Shows that viewers can at least deal gracefully with these cases; Our abstract base shape class.; As we overload TObject::Paint which is called directly from compiled code, this script must also be compiled to work correctly.; #if defined(__CINT__) && !defined(__MAKECINT__); {; gSystem->CompileMacro(""viewer3DLocal.C"");; viewer3DLocal();; }; #else; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::CompileMacrovirtual int CompileMacro(const char *filename, Option_t *opt="""", const char *library_name="""", const char *build_dir="""", UInt_t dirmode=0)This method compiles and loads a shared library containing the code from the file ""filename"".Definition TSystem.cxx:2836; ; #include ""TVirtualViewer3D.h""; #include ""TBuffer3D.h""; #include ""TBuffer3DTypes.h""; ; #include ""TObject.h""; #include ""TVirtualPad.h""; #include ""TAtt3D.h""; ; #include <vector>; ; class Shape : public TObject; {; public:; Shape(Int_t color, Double_t x, Double_t y, Double_t z);; ~Shape() override {};; virtual TBuffer3D & GetBuffer3D(UInt_t reqSections) = 0;; ; protected:; Double_t fX, fY, fZ; // Origin; Int_t fColor;; ; ClassDefOverride(Shape,0);; };; ; ClassImp(Shape);; ; Shape::Shape(Int_t color, Double_t x, Double_t y, Double_t z) :; fX(x), fY(y), fZ(z), fColor(color); {}; ; class Sphere : public Shape; {; public:; Sphere(Int_t color, Double_t x, Double_t y, Double_t z, Double_t radius);; ~Sphere() override {};; ; TBuffer3D & GetBuffer3D(UInt_t reqSections) override;; ; private:; Double_t fRadius;; ; ClassDefOverride(Sphere,0);;",MatchSource.WIKI,doc/master/viewer3DLocal_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/viewer3DLocal_8C.html
https://root.cern/doc/master/viewer3DLocal_8C.html:2724,Usability,simpl,simple,2724,"; // Origin; Int_t fColor;; ; ClassDefOverride(Shape,0);; };; ; ClassImp(Shape);; ; Shape::Shape(Int_t color, Double_t x, Double_t y, Double_t z) :; fX(x), fY(y), fZ(z), fColor(color); {}; ; class Sphere : public Shape; {; public:; Sphere(Int_t color, Double_t x, Double_t y, Double_t z, Double_t radius);; ~Sphere() override {};; ; TBuffer3D & GetBuffer3D(UInt_t reqSections) override;; ; private:; Double_t fRadius;; ; ClassDefOverride(Sphere,0);; };; ; ClassImp(Sphere);; ; Sphere::Sphere(Int_t color, Double_t x, Double_t y, Double_t z, Double_t radius) :; Shape(color,x,y,z),; fRadius(radius); {}; ; TBuffer3D & Sphere::GetBuffer3D(UInt_t reqSections); {; static TBuffer3DSphere buffer;; ; // Complete kCore section - this could be moved to Shape base class; if (reqSections & TBuffer3D::kCore) {; buffer.ClearSectionsValid();; buffer.fID = this;; buffer.fColor = fColor; // Color index - see gROOT->GetColor(); buffer.fTransparency = 0; // Transparency 0 (opaque) - 100 (fully transparent); ; // Complete local/master transformation matrix - simple x/y/z; // translation. Easiest way to set identity then override the; // translation components; buffer.SetLocalMasterIdentity();; buffer.fLocalMaster[12] = fX;; buffer.fLocalMaster[13] = fY;; buffer.fLocalMaster[14] = fZ;; buffer.fLocalFrame = kTRUE; // Local frame; ; buffer.fReflection = kFALSE;; buffer.SetSectionsValid(TBuffer3D::kCore);; }; // Complete kBoundingBox section; if (reqSections & TBuffer3D::kBoundingBox) {; Double_t origin[3] = { 0.0, 0.0, 0.0 };; Double_t halfLength[3] = { fRadius, fRadius, fRadius };; buffer.SetAABoundingBox(origin, halfLength);; buffer.SetSectionsValid(TBuffer3D::kBoundingBox);; }; // Complete kShapeSpecific section; if (reqSections & TBuffer3D::kShapeSpecific) {; buffer.fRadiusOuter = fRadius;; buffer.fRadiusInner = 0.0;; buffer.fThetaMin = 0.0;; buffer.fThetaMax = 180.0;; buffer.fPhiMin = 0.0;; buffer.fPhiMax = 360.0;; buffer.SetSectionsValid(TBuffer3D::kShapeSpecific);; }; // We don't implement",MatchSource.WIKI,doc/master/viewer3DLocal_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/viewer3DLocal_8C.html
https://root.cern/doc/master/viewer3DLocal_8C.html:4984,Usability,simpl,simple,4984,"ection; if (reqSections & TBuffer3D::kRaw) {; //buffer.SetSectionsValid(TBuffer3D::kRaw);; }; ; return buffer;; }; ; class Box : public Shape; {; public:; Box(Int_t color, Double_t x, Double_t y, Double_t z,; Double_t dX, Double_t dY, Double_t dZ);; ~Box() override {};; ; TBuffer3D & GetBuffer3D(UInt_t reqSections) override;; ; private:; Double_t fDX, fDY, fDZ; // Half lengths; ; ClassDefOverride(Box,0);; };; ; ClassImp(Box);; ; Box::Box(Int_t color, Double_t x, Double_t y, Double_t z,; Double_t dX, Double_t dY, Double_t dZ) :; Shape(color,x,y,z),; fDX(dX), fDY(dY), fDZ(dZ); {}; ; TBuffer3D & Box::GetBuffer3D(UInt_t reqSections); {; static TBuffer3D buffer(TBuffer3DTypes::kGeneric);; ; // Complete kCore section - this could be moved to Shape base class; if (reqSections & TBuffer3D::kCore) {; buffer.ClearSectionsValid();; buffer.fID = this;; buffer.fColor = fColor; // Color index - see gROOT->GetColor(); buffer.fTransparency = 0; // Transparency 0 (opaque) - 100 (fully transparent); ; // Complete local/master transformation matrix - simple x/y/z; // translation. Easiest way to set identity then override the; // translation components; buffer.SetLocalMasterIdentity();; buffer.fLocalMaster[12] = fX;; buffer.fLocalMaster[13] = fY;; buffer.fLocalMaster[14] = fZ;; buffer.fLocalFrame = kTRUE; // Local frame; ; buffer.fReflection = kFALSE;; buffer.SetSectionsValid(TBuffer3D::kCore);; }; // Complete kBoundingBox section; if (reqSections & TBuffer3D::kBoundingBox) {; Double_t origin[3] = { fX, fY, fZ };; Double_t halfLength[3] = { fDX, fDY, fDZ };; buffer.SetAABoundingBox(origin, halfLength);; buffer.SetSectionsValid(TBuffer3D::kBoundingBox);; }; // No kShapeSpecific section; ; // Complete kRawSizes section; if (reqSections & TBuffer3D::kRawSizes) {; buffer.SetRawSizes(8, 3*8, 12, 3*12, 6, 6*6);; buffer.SetSectionsValid(TBuffer3D::kRawSizes);; }; // Complete kRaw section; if (reqSections & TBuffer3D::kRaw) {; // Points (8); // 3 components: x,y,z; buffer.fPnts[ 0] = fX - fDX; ",MatchSource.WIKI,doc/master/viewer3DLocal_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/viewer3DLocal_8C.html
https://root.cern/doc/master/viewer3DLocal_8C.html:9924,Usability,simpl,simple,9924,"5] = 4 ;; ; buffer.SetSectionsValid(TBuffer3D::kRaw);; }; ; return buffer;; }; ; class SBPyramid : public Shape; {; public:; SBPyramid(Int_t color, Double_t d, Double_t y, Double_t z,; Double_t dX, Double_t dY, Double_t dZ);; ~SBPyramid() override {};; ; TBuffer3D & GetBuffer3D(UInt_t reqSections) override;; ; private:; Double_t fDX, fDY, fDZ; // Base half lengths dX,dY; // Pyr. height dZ; ; ClassDefOverride(SBPyramid,0);; };; ; ClassImp(SBPyramid);; ; SBPyramid::SBPyramid(Int_t color, Double_t x, Double_t y, Double_t z,; Double_t dX, Double_t dY, Double_t dZ) :; Shape(color,x,y,z),; fDX(dX), fDY(dY), fDZ(dZ); {}; ; TBuffer3D & SBPyramid::GetBuffer3D(UInt_t reqSections); {; static TBuffer3D buffer(TBuffer3DTypes::kGeneric);; ; // Complete kCore section; if (reqSections & TBuffer3D::kCore) {; buffer.ClearSectionsValid();; buffer.fID = this;; buffer.fColor = fColor; // Color index - see gROOT->GetColor(); buffer.fTransparency = 0; // Transparency 0 (opaque) - 100 (fully transparent); ; // Complete local/master transformation matrix - simple x/y/z; // translation. Easiest way to set identity then override the; // translation components; buffer.SetLocalMasterIdentity();; buffer.fLocalMaster[12] = fX;; buffer.fLocalMaster[13] = fY;; buffer.fLocalMaster[14] = fZ;; buffer.fLocalFrame = kTRUE; // Local frame; ; buffer.fReflection = kFALSE;; buffer.SetSectionsValid(TBuffer3D::kCore);; }; // Complete kBoundingBox section; if (reqSections & TBuffer3D::kBoundingBox) {; Double_t halfLength[3] = { fDX, fDY, fDZ/2.0 };; Double_t origin[3] = { fX , fY, fZ + halfLength[2]};; buffer.SetAABoundingBox(origin, halfLength);; buffer.SetSectionsValid(TBuffer3D::kBoundingBox);; }; // No kShapeSpecific section; ; // Complete kRawSizes section; if (reqSections & TBuffer3D::kRawSizes) {; buffer.SetRawSizes(5, 3*5, 8, 3*8, 5, 6 + 4*5);; buffer.SetSectionsValid(TBuffer3D::kRawSizes);; }; // Complete kRaw section; if (reqSections & TBuffer3D::kRaw) {; // Points (5); // 3 components: x,y,z; buffer.",MatchSource.WIKI,doc/master/viewer3DLocal_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/viewer3DLocal_8C.html
https://root.cern/doc/master/viewer3DLocal_8C.html:13426,Usability,simpl,simple,13426,"ts; // Here n=4 - each polygon defines a rectangle - 4 sides.; buffer.fPols[ 0] = fColor ; buffer.fPols[ 1] = 4 ; buffer.fPols[ 2] = 0 ; // base; buffer.fPols[ 3] = 1 ; buffer.fPols[ 4] = 2 ; buffer.fPols[ 5] = 3 ;; ; buffer.fPols[ 6] = fColor ; buffer.fPols[ 7] = 3 ; buffer.fPols[ 8] = 0 ; // side 0; buffer.fPols[ 9] = 4 ; buffer.fPols[10] = 5 ;; buffer.fPols[11] = fColor ; buffer.fPols[12] = 3 ; buffer.fPols[13] = 1 ; // side 1; buffer.fPols[14] = 5 ; buffer.fPols[15] = 6 ;; buffer.fPols[16] = fColor ; buffer.fPols[17] = 3 ; buffer.fPols[18] = 2 ; // side 2; buffer.fPols[19] = 6 ; buffer.fPols[20] = 7 ;; buffer.fPols[21] = fColor ; buffer.fPols[22] = 3 ; buffer.fPols[23] = 3 ; // side 3; buffer.fPols[24] = 7 ; buffer.fPols[25] = 4 ;; ; buffer.SetSectionsValid(TBuffer3D::kRaw);; }; ; return buffer;; }; ; class MyGeom : public TObject, public TAtt3D; {; public:; MyGeom();; ~MyGeom() override;; ; void Draw(Option_t *option) override;; void Paint(Option_t *option) override;; ; private:; std::vector<Shape *> fShapes;; ; ClassDefOverride(MyGeom,0);; };; ; ClassImp(MyGeom);; ; MyGeom::MyGeom(); {; // Create our simple geometry - sphere, couple of boxes; // and a square base pyramid; Shape * aShape;; aShape = new Sphere(kYellow, 80.0, 60.0, 120.0, 10.0);; fShapes.push_back(aShape);; aShape = new Box(kRed, 0.0, 0.0, 0.0, 20.0, 20.0, 20.0);; fShapes.push_back(aShape);; aShape = new Box(kBlue, 50.0, 100.0, 200.0, 5.0, 10.0, 15.0);; fShapes.push_back(aShape);; aShape = new SBPyramid(kGreen, 20.0, 25.0, 45.0, 30.0, 30.0, 90.0);; fShapes.push_back(aShape);; }; ; MyGeom::~MyGeom(); {; // Clear out fShapes; }; ; void MyGeom::Draw(Option_t *option); {; TObject::Draw(option);; ; // Ask pad to create 3D viewer of type 'option'; gPad->GetViewer3D(option);; }; ; void MyGeom::Paint(Option_t * /*option*/); {; TVirtualViewer3D * viewer = gPad->GetViewer3D();; ; // If MyGeom derives from TAtt3D then pad will recognise; // that the object it is asking to paint is 3D, and open/close; // the ",MatchSource.WIKI,doc/master/viewer3DLocal_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/viewer3DLocal_8C.html
https://root.cern/doc/master/viewer3DMaster_8C.html:10057,Usability,simpl,simple,10057," segments; // Here n=4 - each polygon defines a rectangle - 4 sides.; buffer.fPols[ 0] = fColor ; buffer.fPols[ 1] = 4 ; buffer.fPols[ 2] = 0 ; // base; buffer.fPols[ 3] = 1 ; buffer.fPols[ 4] = 2 ; buffer.fPols[ 5] = 3 ;; ; buffer.fPols[ 6] = fColor ; buffer.fPols[ 7] = 3 ; buffer.fPols[ 8] = 0 ; // side 0; buffer.fPols[ 9] = 4 ; buffer.fPols[10] = 5 ;; buffer.fPols[11] = fColor ; buffer.fPols[12] = 3 ; buffer.fPols[13] = 1 ; // side 1; buffer.fPols[14] = 5 ; buffer.fPols[15] = 6 ;; buffer.fPols[16] = fColor ; buffer.fPols[17] = 3 ; buffer.fPols[18] = 2 ; // side 2; buffer.fPols[19] = 6 ; buffer.fPols[20] = 7 ;; buffer.fPols[21] = fColor ; buffer.fPols[22] = 3 ; buffer.fPols[23] = 3 ; // side 3; buffer.fPols[24] = 7 ; buffer.fPols[25] = 4 ;; ; buffer.SetSectionsValid(TBuffer3D::kRaw);; }; ; return buffer;; }; ; class MyGeom : public TObject, public TAtt3D; {; public:; MyGeom();; ~MyGeom() override;; ; void Draw(Option_t *option) override;; void Paint(Option_t *option) override;; ; private:; std::vector<Shape *> fShapes;; ; ClassDefOverride(MyGeom,0);; };; ; ClassImp(MyGeom);; ; MyGeom::MyGeom(); {; // Create our simple geometry - couple of boxes; // and a square base pyramid; Shape * aShape;; aShape = new Box(kRed, 0.0, 0.0, 0.0, 20.0, 20.0, 20.0);; fShapes.push_back(aShape);; aShape = new Box(kBlue, 50.0, 100.0, 200.0, 5.0, 10.0, 15.0);; fShapes.push_back(aShape);; aShape = new SBPyramid(kGreen, 20.0, 25.0, 45.0, 30.0, 30.0, 90.0);; fShapes.push_back(aShape);; }; ; MyGeom::~MyGeom(); {; // Clear out fShapes; }; ; void MyGeom::Draw(Option_t *option); {; TObject::Draw(option);; ; // Ask pad to create 3D viewer of type 'option'; gPad->GetViewer3D(option);; }; ; void MyGeom::Paint(Option_t * /*option*/); {; TVirtualViewer3D * viewer = gPad->GetViewer3D();; ; // If MyGeom derives from TAtt3D then pad will recognise; // that the object it is asking to paint is 3D, and open/close; // the scene for us. If not Open/Close are required; //viewer->BeginScene();; ; // We are w",MatchSource.WIKI,doc/master/viewer3DMaster_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/viewer3DMaster_8C.html
https://root.cern/doc/master/waves_8C.html:7673,Energy Efficiency,power,power,7673,"tour(Int_t nlevels=20, const Double_t *levels=nullptr)Set the number and values of contour levels.Definition TF2.cxx:892; TF2::SetNpyvirtual void SetNpy(Int_t npy=100)Set the number of points used to draw the function.Definition TF2.cxx:927; TF2::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF2.cxx:259; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::DrawLatexTLatex * DrawLatex(Double_t x, Double_t y, const char *text)Make a copy of this object with the new parameters And copy object attributes.Definition TLatex.cxx:1943; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::Rangevoid Range(Double_t x1, Double_t y1, Double_t x2, Double_t y2) overrideSet world coordinate system for the pad.Definition TPad.cxx:5331; TPad::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet Current pad.Definition TPad.cxx:693; TPad::Drawvoid Draw(Option_t *option="""") overrideDraw Pad in Current pad (re-parent pad if necessary).Definition TPad.cxx:1364; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; lineTLine * lineDefinition entrylistblock_figure1.C:235; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; graphDefinition graph.py:1; AuthorOtto Schaile ; Definition in file waves.C. tutorialsgraphswaves.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/waves_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/waves_8C.html
https://root.cern/doc/master/waves_8C.html:6708,Usability,simpl,simple,6708,"SetNpx(Int_t npx=100)Set the number of points used to draw the function.Definition TF1.cxx:3433; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF2A 2-Dim function with parameters.Definition TF2.h:29; TF2::SetContourvirtual void SetContour(Int_t nlevels=20, const Double_t *levels=nullptr)Set the number and values of contour levels.Definition TF2.cxx:892; TF2::SetNpyvirtual void SetNpy(Int_t npy=100)Set the number of points used to draw the function.Definition TF2.cxx:927; TF2::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF2.cxx:259; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::DrawLatexTLatex * DrawLatex(Double_t x, Double_t y, const char *text)Make a copy of this object with the new parameters And copy object attributes.Definition TLatex.cxx:1943; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPad::Rangevoid Range(Double_t x1, Double_t y1, Double_t x2, Double_t y2) overrideSet world coordinate system for the pad.Definition TPad.cxx:5331; TPad::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet Current pad.Definition TPad.cxx:693; TPad::Drawvoid Draw(Option_t *option="""") overrideDraw Pad in Current pad (re-parent pad if necessary).Definition TPad.cxx:1364; TStyle::SetPalettevoid SetPalette(Int_t ncolors=kBird, Int_t *colors=nullptr, Float_t alpha=1.)See TColor::SetPalette.Definition TStyle.cxx:1888; lineTLine * lineDefinition entrylistblock_figure1.C:235; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definit",MatchSource.WIKI,doc/master/waves_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/waves_8C.html
https://root.cern/doc/master/win32gdk_2src_2gifencode_8c.html:1457,Availability,mask,masks,1457,"h for gifencode.c:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Macros; #define ARGS(alist)   ();  ; #define BITS   12 /* largest code size */;  ; #define HSIZE   5003 /* hash table size */;  ; #define put_byte(A)   (*put_b)((byte)(A)); Nbyte++;  ; #define SHIFT   4 /* shift for hashing */;  ; #define THELIMIT   4096 /* NEVER generate this */;  . Typedefs; typedef unsigned char byte;  . Functions; static void char_flush ();  ; static void char_init ();  ; static void char_out ();  ; static void char_out (int c);  ; long GIFencode (int Width, int Height, int Ncol, R, G, B, ScLine, void *get_scline, pb);  ; static void output ();  ; static void output (int code);  ; static void put_short ();  ; static void put_short (int word);  . Variables; static int a_count;  ; static char accum [256];  ; static int BitsPixel;  ; static int ClearCode;  ; static int CodeTab [5003];  ; static unsigned long cur_accum;  ; static int cur_bits;  ; static int CurCodeSize;  ; static int CurMaxCode;  ; static int EOFCode;  ; static int FreeCode;  ; static long HashTab [5003];  ; static int IniCodeSize;  ; static unsigned long masks [];  ; static long Nbyte;  ; static void(* put_b )();  . Macro Definition Documentation. ◆ ARGS. #define ARGS; (;  ; alist);    (). Definition at line 10 of file gifencode.c. ◆ BITS. #define BITS   12 /* largest code size */. Definition at line 13 of file gifencode.c. ◆ HSIZE. #define HSIZE   5003 /* hash table size */. Definition at line 15 of file gifencode.c. ◆ put_byte. #define put_byte; (;  ; A);    (*put_b)((byte)(A)); Nbyte++. Definition at line 18 of file gifencode.c. ◆ SHIFT. #define SHIFT   4 /* shift for hashing */. Definition at line 16 of file gifencode.c. ◆ THELIMIT. #define THELIMIT   4096 /* NEVER generate this */. Definition at line 14 of file gifencode.c. Typedef Documentation. ◆ byte. typedef unsigned char byte. Definition at line 20 of file gifencode.c. Function Documentation. ◆ char_flush(). static void",MatchSource.WIKI,doc/master/win32gdk_2src_2gifencode_8c.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/win32gdk_2src_2gifencode_8c.html
https://root.cern/doc/master/win32gdk_2src_2gifencode_8c.html:4247,Availability,mask,masks,4247," ). Definition at line 63 of file gifencode.c. ◆ output() [1/2]. static void output ; (; ). static . ◆ output() [2/2]. static void output ; (; int ; code). static . Definition at line 226 of file gifencode.c. ◆ put_short() [1/2]. static void put_short ; (; ). static . ◆ put_short() [2/2]. static void put_short ; (; int ; word). static . Definition at line 301 of file gifencode.c. Variable Documentation. ◆ a_count. int a_count. static . Definition at line 209 of file gifencode.c. ◆ accum. char accum[256]. static . Definition at line 210 of file gifencode.c. ◆ BitsPixel. int BitsPixel. static . Definition at line 25 of file gifencode.c. ◆ ClearCode. int ClearCode. static . Definition at line 29 of file gifencode.c. ◆ CodeTab. int CodeTab[5003]. static . Definition at line 23 of file gifencode.c. ◆ cur_accum. unsigned long cur_accum. static . Definition at line 207 of file gifencode.c. ◆ cur_bits. int cur_bits. static . Definition at line 208 of file gifencode.c. ◆ CurCodeSize. int CurCodeSize. static . Definition at line 27 of file gifencode.c. ◆ CurMaxCode. int CurMaxCode. static . Definition at line 28 of file gifencode.c. ◆ EOFCode. int EOFCode. static . Definition at line 30 of file gifencode.c. ◆ FreeCode. int FreeCode. static . Definition at line 31 of file gifencode.c. ◆ HashTab. long HashTab[5003]. static . Definition at line 22 of file gifencode.c. ◆ IniCodeSize. int IniCodeSize. static . Definition at line 26 of file gifencode.c. ◆ masks. unsigned long masks[]. static . Initial value:= { 0x0000,; 0x0001, 0x0003, 0x0007, 0x000F,; 0x001F, 0x003F, 0x007F, 0x00FF,; 0x01FF, 0x03FF, 0x07FF, 0x0FFF,; 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF }. Definition at line 211 of file gifencode.c. ◆ Nbyte. long Nbyte. static . Definition at line 33 of file gifencode.c. ◆ put_b. void(* put_b) () ; (; ). static . Definition at line 34 of file gifencode.c. graf2dwin32gdksrcgifencode.c. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/win32gdk_2src_2gifencode_8c.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/win32gdk_2src_2gifencode_8c.html
https://root.cern/doc/master/win32gdk_2src_2gifencode_8c.html:4268,Availability,mask,masks,4268," ). Definition at line 63 of file gifencode.c. ◆ output() [1/2]. static void output ; (; ). static . ◆ output() [2/2]. static void output ; (; int ; code). static . Definition at line 226 of file gifencode.c. ◆ put_short() [1/2]. static void put_short ; (; ). static . ◆ put_short() [2/2]. static void put_short ; (; int ; word). static . Definition at line 301 of file gifencode.c. Variable Documentation. ◆ a_count. int a_count. static . Definition at line 209 of file gifencode.c. ◆ accum. char accum[256]. static . Definition at line 210 of file gifencode.c. ◆ BitsPixel. int BitsPixel. static . Definition at line 25 of file gifencode.c. ◆ ClearCode. int ClearCode. static . Definition at line 29 of file gifencode.c. ◆ CodeTab. int CodeTab[5003]. static . Definition at line 23 of file gifencode.c. ◆ cur_accum. unsigned long cur_accum. static . Definition at line 207 of file gifencode.c. ◆ cur_bits. int cur_bits. static . Definition at line 208 of file gifencode.c. ◆ CurCodeSize. int CurCodeSize. static . Definition at line 27 of file gifencode.c. ◆ CurMaxCode. int CurMaxCode. static . Definition at line 28 of file gifencode.c. ◆ EOFCode. int EOFCode. static . Definition at line 30 of file gifencode.c. ◆ FreeCode. int FreeCode. static . Definition at line 31 of file gifencode.c. ◆ HashTab. long HashTab[5003]. static . Definition at line 22 of file gifencode.c. ◆ IniCodeSize. int IniCodeSize. static . Definition at line 26 of file gifencode.c. ◆ masks. unsigned long masks[]. static . Initial value:= { 0x0000,; 0x0001, 0x0003, 0x0007, 0x000F,; 0x001F, 0x003F, 0x007F, 0x00FF,; 0x01FF, 0x03FF, 0x07FF, 0x0FFF,; 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF }. Definition at line 211 of file gifencode.c. ◆ Nbyte. long Nbyte. static . Definition at line 33 of file gifencode.c. ◆ put_b. void(* put_b) () ; (; ). static . Definition at line 34 of file gifencode.c. graf2dwin32gdksrcgifencode.c. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/win32gdk_2src_2gifencode_8c.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/win32gdk_2src_2gifencode_8c.html
https://root.cern/doc/master/win32gdk_2src_2gifencode_8c.html:282,Integrability,depend,dependency,282,". ROOT: graf2d/win32gdk/src/gifencode.c File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Macros |; Typedefs |; Functions |; Variables ; gifencode.c File Reference. #include <stdio.h>; #include <stdlib.h>; #include <string.h>. Include dependency graph for gifencode.c:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Macros; #define ARGS(alist)   ();  ; #define BITS   12 /* largest code size */;  ; #define HSIZE   5003 /* hash table size */;  ; #define put_byte(A)   (*put_b)((byte)(A)); Nbyte++;  ; #define SHIFT   4 /* shift for hashing */;  ; #define THELIMIT   4096 /* NEVER generate this */;  . Typedefs; typedef unsigned char byte;  . Functions; static void char_flush ();  ; static void char_init ();  ; static void char_out ();  ; static void char_out (int c);  ; long GIFencode (int Width, int Height, int Ncol, R, G, B, ScLine, void *get_scline, pb);  ; static void output ();  ; static void output (int code);  ; static void put_short ();  ; static void put_short (int word);  . Variables; static int a_count;  ; static char accum [256];  ; static int BitsPixel;  ; static int ClearCode;  ; static int CodeTab [5003];  ; static unsigned long cur_accum;  ; static int cur_bits;  ; static int CurCodeSize;  ; static int CurMaxCode;  ; static int EOFCode;  ; static int FreeCode;  ; static long HashTab [5003];  ; static int IniCodeSize;  ; static unsigned long masks [];  ; static long Nbyte;  ; static void(* put_b )();  . Macro Definition Documentation. ◆ ARGS. #define ARGS; (;  ; alist);    (). Definition at line 10 of file gifencode.c. ◆ BITS. #define BITS   12 /* largest code size */. Definition at line 13 of file gifencode.c. ◆ HSIZE. #define HSIZE   5003 /* hash table size */. Definition at line 15 of file gifencode.c. ◆ put_byte. #define put_byte; (;  ; A);    (*put_b)((byte)(A)); Nbyte++. Definition at line 18 of file gifencode.c. ◆ SHIFT. #define SHIFT   4 /* shift for hashing */. Defin",MatchSource.WIKI,doc/master/win32gdk_2src_2gifencode_8c.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/win32gdk_2src_2gifencode_8c.html
https://root.cern/doc/master/win32gdk_2src_2gifencode_8c.html:509,Security,hash,hash,509,". ROOT: graf2d/win32gdk/src/gifencode.c File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Macros |; Typedefs |; Functions |; Variables ; gifencode.c File Reference. #include <stdio.h>; #include <stdlib.h>; #include <string.h>. Include dependency graph for gifencode.c:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Macros; #define ARGS(alist)   ();  ; #define BITS   12 /* largest code size */;  ; #define HSIZE   5003 /* hash table size */;  ; #define put_byte(A)   (*put_b)((byte)(A)); Nbyte++;  ; #define SHIFT   4 /* shift for hashing */;  ; #define THELIMIT   4096 /* NEVER generate this */;  . Typedefs; typedef unsigned char byte;  . Functions; static void char_flush ();  ; static void char_init ();  ; static void char_out ();  ; static void char_out (int c);  ; long GIFencode (int Width, int Height, int Ncol, R, G, B, ScLine, void *get_scline, pb);  ; static void output ();  ; static void output (int code);  ; static void put_short ();  ; static void put_short (int word);  . Variables; static int a_count;  ; static char accum [256];  ; static int BitsPixel;  ; static int ClearCode;  ; static int CodeTab [5003];  ; static unsigned long cur_accum;  ; static int cur_bits;  ; static int CurCodeSize;  ; static int CurMaxCode;  ; static int EOFCode;  ; static int FreeCode;  ; static long HashTab [5003];  ; static int IniCodeSize;  ; static unsigned long masks [];  ; static long Nbyte;  ; static void(* put_b )();  . Macro Definition Documentation. ◆ ARGS. #define ARGS; (;  ; alist);    (). Definition at line 10 of file gifencode.c. ◆ BITS. #define BITS   12 /* largest code size */. Definition at line 13 of file gifencode.c. ◆ HSIZE. #define HSIZE   5003 /* hash table size */. Definition at line 15 of file gifencode.c. ◆ put_byte. #define put_byte; (;  ; A);    (*put_b)((byte)(A)); Nbyte++. Definition at line 18 of file gifencode.c. ◆ SHIFT. #define SHIFT   4 /* shift for hashing */. Defin",MatchSource.WIKI,doc/master/win32gdk_2src_2gifencode_8c.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/win32gdk_2src_2gifencode_8c.html
https://root.cern/doc/master/win32gdk_2src_2gifencode_8c.html:618,Security,hash,hashing,618,". ROOT: graf2d/win32gdk/src/gifencode.c File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Macros |; Typedefs |; Functions |; Variables ; gifencode.c File Reference. #include <stdio.h>; #include <stdlib.h>; #include <string.h>. Include dependency graph for gifencode.c:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Macros; #define ARGS(alist)   ();  ; #define BITS   12 /* largest code size */;  ; #define HSIZE   5003 /* hash table size */;  ; #define put_byte(A)   (*put_b)((byte)(A)); Nbyte++;  ; #define SHIFT   4 /* shift for hashing */;  ; #define THELIMIT   4096 /* NEVER generate this */;  . Typedefs; typedef unsigned char byte;  . Functions; static void char_flush ();  ; static void char_init ();  ; static void char_out ();  ; static void char_out (int c);  ; long GIFencode (int Width, int Height, int Ncol, R, G, B, ScLine, void *get_scline, pb);  ; static void output ();  ; static void output (int code);  ; static void put_short ();  ; static void put_short (int word);  . Variables; static int a_count;  ; static char accum [256];  ; static int BitsPixel;  ; static int ClearCode;  ; static int CodeTab [5003];  ; static unsigned long cur_accum;  ; static int cur_bits;  ; static int CurCodeSize;  ; static int CurMaxCode;  ; static int EOFCode;  ; static int FreeCode;  ; static long HashTab [5003];  ; static int IniCodeSize;  ; static unsigned long masks [];  ; static long Nbyte;  ; static void(* put_b )();  . Macro Definition Documentation. ◆ ARGS. #define ARGS; (;  ; alist);    (). Definition at line 10 of file gifencode.c. ◆ BITS. #define BITS   12 /* largest code size */. Definition at line 13 of file gifencode.c. ◆ HSIZE. #define HSIZE   5003 /* hash table size */. Definition at line 15 of file gifencode.c. ◆ put_byte. #define put_byte; (;  ; A);    (*put_b)((byte)(A)); Nbyte++. Definition at line 18 of file gifencode.c. ◆ SHIFT. #define SHIFT   4 /* shift for hashing */. Defin",MatchSource.WIKI,doc/master/win32gdk_2src_2gifencode_8c.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/win32gdk_2src_2gifencode_8c.html
https://root.cern/doc/master/win32gdk_2src_2gifencode_8c.html:1765,Security,hash,hash,1765,"();  ; static void char_init ();  ; static void char_out ();  ; static void char_out (int c);  ; long GIFencode (int Width, int Height, int Ncol, R, G, B, ScLine, void *get_scline, pb);  ; static void output ();  ; static void output (int code);  ; static void put_short ();  ; static void put_short (int word);  . Variables; static int a_count;  ; static char accum [256];  ; static int BitsPixel;  ; static int ClearCode;  ; static int CodeTab [5003];  ; static unsigned long cur_accum;  ; static int cur_bits;  ; static int CurCodeSize;  ; static int CurMaxCode;  ; static int EOFCode;  ; static int FreeCode;  ; static long HashTab [5003];  ; static int IniCodeSize;  ; static unsigned long masks [];  ; static long Nbyte;  ; static void(* put_b )();  . Macro Definition Documentation. ◆ ARGS. #define ARGS; (;  ; alist);    (). Definition at line 10 of file gifencode.c. ◆ BITS. #define BITS   12 /* largest code size */. Definition at line 13 of file gifencode.c. ◆ HSIZE. #define HSIZE   5003 /* hash table size */. Definition at line 15 of file gifencode.c. ◆ put_byte. #define put_byte; (;  ; A);    (*put_b)((byte)(A)); Nbyte++. Definition at line 18 of file gifencode.c. ◆ SHIFT. #define SHIFT   4 /* shift for hashing */. Definition at line 16 of file gifencode.c. ◆ THELIMIT. #define THELIMIT   4096 /* NEVER generate this */. Definition at line 14 of file gifencode.c. Typedef Documentation. ◆ byte. typedef unsigned char byte. Definition at line 20 of file gifencode.c. Function Documentation. ◆ char_flush(). static void char_flush ; (; ). static . Definition at line 289 of file gifencode.c. ◆ char_init(). static void char_init ; (; ). static . Definition at line 274 of file gifencode.c. ◆ char_out() [1/2]. static void char_out ; (; ). static . ◆ char_out() [2/2]. static void char_out ; (; int ; c). static . Definition at line 281 of file gifencode.c. ◆ GIFencode(). long GIFencode ; (; int ; Width, . int ; Height, . int ; Ncol, . R ; , . G ; , . B ; , . ScLine ; , . void * ; ",MatchSource.WIKI,doc/master/win32gdk_2src_2gifencode_8c.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/win32gdk_2src_2gifencode_8c.html
https://root.cern/doc/master/win32gdk_2src_2gifencode_8c.html:1984,Security,hash,hashing,1984,"  ; static void output (int code);  ; static void put_short ();  ; static void put_short (int word);  . Variables; static int a_count;  ; static char accum [256];  ; static int BitsPixel;  ; static int ClearCode;  ; static int CodeTab [5003];  ; static unsigned long cur_accum;  ; static int cur_bits;  ; static int CurCodeSize;  ; static int CurMaxCode;  ; static int EOFCode;  ; static int FreeCode;  ; static long HashTab [5003];  ; static int IniCodeSize;  ; static unsigned long masks [];  ; static long Nbyte;  ; static void(* put_b )();  . Macro Definition Documentation. ◆ ARGS. #define ARGS; (;  ; alist);    (). Definition at line 10 of file gifencode.c. ◆ BITS. #define BITS   12 /* largest code size */. Definition at line 13 of file gifencode.c. ◆ HSIZE. #define HSIZE   5003 /* hash table size */. Definition at line 15 of file gifencode.c. ◆ put_byte. #define put_byte; (;  ; A);    (*put_b)((byte)(A)); Nbyte++. Definition at line 18 of file gifencode.c. ◆ SHIFT. #define SHIFT   4 /* shift for hashing */. Definition at line 16 of file gifencode.c. ◆ THELIMIT. #define THELIMIT   4096 /* NEVER generate this */. Definition at line 14 of file gifencode.c. Typedef Documentation. ◆ byte. typedef unsigned char byte. Definition at line 20 of file gifencode.c. Function Documentation. ◆ char_flush(). static void char_flush ; (; ). static . Definition at line 289 of file gifencode.c. ◆ char_init(). static void char_init ; (; ). static . Definition at line 274 of file gifencode.c. ◆ char_out() [1/2]. static void char_out ; (; ). static . ◆ char_out() [2/2]. static void char_out ; (; int ; c). static . Definition at line 281 of file gifencode.c. ◆ GIFencode(). long GIFencode ; (; int ; Width, . int ; Height, . int ; Ncol, . R ; , . G ; , . B ; , . ScLine ; , . void * ; get_scline, . pb ;  . ). Definition at line 63 of file gifencode.c. ◆ output() [1/2]. static void output ; (; ). static . ◆ output() [2/2]. static void output ; (; int ; code). static . Definition at line 226 of ",MatchSource.WIKI,doc/master/win32gdk_2src_2gifencode_8c.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/win32gdk_2src_2gifencode_8c.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:980,Integrability,wrap,wrap,980,". ROOT: math/mathcore/inc/Math/WrappedFunction.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. WrappedFunction.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: L. Moneta, A. Zsenei 08/2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2004 CERN *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 * *; 12 **********************************************************************/; 13 ; 14#ifndef ROOT_Math_WrappedFunction; 15#define ROOT_Math_WrappedFunction; 16 ; 17#include ""IFunction.h""; 18 ; 19 ; 20namespace ROOT {; 21namespace Math {; 22 ; 23 ; 24 ; 25 ; 26struct NullTypeFunc1D {};; 27 ; 28typedef double(*FreeFunctionPtr)(double);; 29 ; 30typedef double(*FreeMultiFunctionPtr)(const double*);; 31 ; 32/**; 33 Template class to wrap any C++ callable object which takes one argument; 34 i.e. implementing operator() (double x) in a One-dimensional function interface.; 35 It provides a ROOT::Math::IGenFunction-like signature; 36 ; 37 Note: If you want to wrap just the reference (to avoid copying) you need to use; 38 Func& or const Func & as template parameter. The former should be used when the; 39 operator() is not a const method of Func; 40 ; 41 @ingroup GenFunc; 42 ; 43 */; 44template< typename Func = FreeFunctionPtr >; 45class WrappedFunction : public IGenFunction {; 46 ; 47 ; 48 public:; 49 ; 50 /**; 51 construct from the pointer to the object and the member function; 52 */; 53 WrappedFunction( Func f ) :; 54 fFunc( f ); 55 { /* no op */ }; 56 ; 57 // use default copy constructor and assignment operator; 58 ; 59 /// clone (required by the interface); 60 WrappedFunction * Clone() const override {; 61 return new WrappedFunction(fFunc);; 62 }; 63 ; 64 // virtual ~WrappedFunction() { /**/ }; 65 ; 66private:; 67 ; 68 double DoEval (d",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:1108,Integrability,interface,interface,1108,". Reference Guide ; .  . Loading...; Searching...; No Matches. WrappedFunction.h. Go to the documentation of this file. 1// @(#)root/mathcore:$Id$; 2// Authors: L. Moneta, A. Zsenei 08/2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2004 CERN *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 * *; 12 **********************************************************************/; 13 ; 14#ifndef ROOT_Math_WrappedFunction; 15#define ROOT_Math_WrappedFunction; 16 ; 17#include ""IFunction.h""; 18 ; 19 ; 20namespace ROOT {; 21namespace Math {; 22 ; 23 ; 24 ; 25 ; 26struct NullTypeFunc1D {};; 27 ; 28typedef double(*FreeFunctionPtr)(double);; 29 ; 30typedef double(*FreeMultiFunctionPtr)(const double*);; 31 ; 32/**; 33 Template class to wrap any C++ callable object which takes one argument; 34 i.e. implementing operator() (double x) in a One-dimensional function interface.; 35 It provides a ROOT::Math::IGenFunction-like signature; 36 ; 37 Note: If you want to wrap just the reference (to avoid copying) you need to use; 38 Func& or const Func & as template parameter. The former should be used when the; 39 operator() is not a const method of Func; 40 ; 41 @ingroup GenFunc; 42 ; 43 */; 44template< typename Func = FreeFunctionPtr >; 45class WrappedFunction : public IGenFunction {; 46 ; 47 ; 48 public:; 49 ; 50 /**; 51 construct from the pointer to the object and the member function; 52 */; 53 WrappedFunction( Func f ) :; 54 fFunc( f ); 55 { /* no op */ }; 56 ; 57 // use default copy constructor and assignment operator; 58 ; 59 /// clone (required by the interface); 60 WrappedFunction * Clone() const override {; 61 return new WrappedFunction(fFunc);; 62 }; 63 ; 64 // virtual ~WrappedFunction() { /**/ }; 65 ; 66private:; 67 ; 68 double DoEval (double x) const override {; 69 return fFunc( x );; 70 }; 71 ; 72 ; 73 Func fFunc",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:1207,Integrability,wrap,wrap,1207,"hcore:$Id$; 2// Authors: L. Moneta, A. Zsenei 08/2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2004 CERN *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 * *; 12 **********************************************************************/; 13 ; 14#ifndef ROOT_Math_WrappedFunction; 15#define ROOT_Math_WrappedFunction; 16 ; 17#include ""IFunction.h""; 18 ; 19 ; 20namespace ROOT {; 21namespace Math {; 22 ; 23 ; 24 ; 25 ; 26struct NullTypeFunc1D {};; 27 ; 28typedef double(*FreeFunctionPtr)(double);; 29 ; 30typedef double(*FreeMultiFunctionPtr)(const double*);; 31 ; 32/**; 33 Template class to wrap any C++ callable object which takes one argument; 34 i.e. implementing operator() (double x) in a One-dimensional function interface.; 35 It provides a ROOT::Math::IGenFunction-like signature; 36 ; 37 Note: If you want to wrap just the reference (to avoid copying) you need to use; 38 Func& or const Func & as template parameter. The former should be used when the; 39 operator() is not a const method of Func; 40 ; 41 @ingroup GenFunc; 42 ; 43 */; 44template< typename Func = FreeFunctionPtr >; 45class WrappedFunction : public IGenFunction {; 46 ; 47 ; 48 public:; 49 ; 50 /**; 51 construct from the pointer to the object and the member function; 52 */; 53 WrappedFunction( Func f ) :; 54 fFunc( f ); 55 { /* no op */ }; 56 ; 57 // use default copy constructor and assignment operator; 58 ; 59 /// clone (required by the interface); 60 WrappedFunction * Clone() const override {; 61 return new WrappedFunction(fFunc);; 62 }; 63 ; 64 // virtual ~WrappedFunction() { /**/ }; 65 ; 66private:; 67 ; 68 double DoEval (double x) const override {; 69 return fFunc( x );; 70 }; 71 ; 72 ; 73 Func fFunc;; 74 ; 75 ; 76}; // WrappedFunction; 77 ; 78 ; 79/**; 80 Template class to wrap any member function of a class; 81 taking a double and ",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:1808,Integrability,interface,interface,1808,"d copying) you need to use; 38 Func& or const Func & as template parameter. The former should be used when the; 39 operator() is not a const method of Func; 40 ; 41 @ingroup GenFunc; 42 ; 43 */; 44template< typename Func = FreeFunctionPtr >; 45class WrappedFunction : public IGenFunction {; 46 ; 47 ; 48 public:; 49 ; 50 /**; 51 construct from the pointer to the object and the member function; 52 */; 53 WrappedFunction( Func f ) :; 54 fFunc( f ); 55 { /* no op */ }; 56 ; 57 // use default copy constructor and assignment operator; 58 ; 59 /// clone (required by the interface); 60 WrappedFunction * Clone() const override {; 61 return new WrappedFunction(fFunc);; 62 }; 63 ; 64 // virtual ~WrappedFunction() { /**/ }; 65 ; 66private:; 67 ; 68 double DoEval (double x) const override {; 69 return fFunc( x );; 70 }; 71 ; 72 ; 73 Func fFunc;; 74 ; 75 ; 76}; // WrappedFunction; 77 ; 78 ; 79/**; 80 Template class to wrap any member function of a class; 81 taking a double and returning a double in a 1D function interface; 82 For example, if you have a class like:; 83 struct X {; 84 double Eval(double x);; 85 };; 86 you can wrapped in the following way:; 87 WrappedMemFunction<X, double ( X::* ) (double) > f;; 88 ; 89 ; 90 @ingroup GenFunc; 91 ; 92 */; 93 ; 94template<typename FuncObj, typename MemFuncPtr >; 95class WrappedMemFunction : public IGenFunction {; 96 ; 97 ; 98 public:; 99 ; 100 /**; 101 construct from the pointer to the object and the member function; 102 */; 103 WrappedMemFunction( FuncObj & obj, MemFuncPtr memFn ) :; 104 fObj(&obj),; 105 fMemFunc( memFn ); 106 { /* no op */ }; 107 ; 108 // use default copy constructor and assignment operator; 109 ; 110 /// clone (required by the interface); 111 WrappedMemFunction * Clone() const override {; 112 return new WrappedMemFunction(*fObj,fMemFunc);; 113 }; 114 ; 115 ; 116private:; 117 ; 118 double DoEval (double x) const override {; 119 return ((*fObj).*fMemFunc)( x );; 120 }; 121 ; 122 ; 123 FuncObj * fObj;; 124 MemFuncPtr fM",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:2156,Integrability,wrap,wrap,2156,"d copying) you need to use; 38 Func& or const Func & as template parameter. The former should be used when the; 39 operator() is not a const method of Func; 40 ; 41 @ingroup GenFunc; 42 ; 43 */; 44template< typename Func = FreeFunctionPtr >; 45class WrappedFunction : public IGenFunction {; 46 ; 47 ; 48 public:; 49 ; 50 /**; 51 construct from the pointer to the object and the member function; 52 */; 53 WrappedFunction( Func f ) :; 54 fFunc( f ); 55 { /* no op */ }; 56 ; 57 // use default copy constructor and assignment operator; 58 ; 59 /// clone (required by the interface); 60 WrappedFunction * Clone() const override {; 61 return new WrappedFunction(fFunc);; 62 }; 63 ; 64 // virtual ~WrappedFunction() { /**/ }; 65 ; 66private:; 67 ; 68 double DoEval (double x) const override {; 69 return fFunc( x );; 70 }; 71 ; 72 ; 73 Func fFunc;; 74 ; 75 ; 76}; // WrappedFunction; 77 ; 78 ; 79/**; 80 Template class to wrap any member function of a class; 81 taking a double and returning a double in a 1D function interface; 82 For example, if you have a class like:; 83 struct X {; 84 double Eval(double x);; 85 };; 86 you can wrapped in the following way:; 87 WrappedMemFunction<X, double ( X::* ) (double) > f;; 88 ; 89 ; 90 @ingroup GenFunc; 91 ; 92 */; 93 ; 94template<typename FuncObj, typename MemFuncPtr >; 95class WrappedMemFunction : public IGenFunction {; 96 ; 97 ; 98 public:; 99 ; 100 /**; 101 construct from the pointer to the object and the member function; 102 */; 103 WrappedMemFunction( FuncObj & obj, MemFuncPtr memFn ) :; 104 fObj(&obj),; 105 fMemFunc( memFn ); 106 { /* no op */ }; 107 ; 108 // use default copy constructor and assignment operator; 109 ; 110 /// clone (required by the interface); 111 WrappedMemFunction * Clone() const override {; 112 return new WrappedMemFunction(*fObj,fMemFunc);; 113 }; 114 ; 115 ; 116private:; 117 ; 118 double DoEval (double x) const override {; 119 return ((*fObj).*fMemFunc)( x );; 120 }; 121 ; 122 ; 123 FuncObj * fObj;; 124 MemFuncPtr fM",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:2252,Integrability,interface,interface,2252,"d copying) you need to use; 38 Func& or const Func & as template parameter. The former should be used when the; 39 operator() is not a const method of Func; 40 ; 41 @ingroup GenFunc; 42 ; 43 */; 44template< typename Func = FreeFunctionPtr >; 45class WrappedFunction : public IGenFunction {; 46 ; 47 ; 48 public:; 49 ; 50 /**; 51 construct from the pointer to the object and the member function; 52 */; 53 WrappedFunction( Func f ) :; 54 fFunc( f ); 55 { /* no op */ }; 56 ; 57 // use default copy constructor and assignment operator; 58 ; 59 /// clone (required by the interface); 60 WrappedFunction * Clone() const override {; 61 return new WrappedFunction(fFunc);; 62 }; 63 ; 64 // virtual ~WrappedFunction() { /**/ }; 65 ; 66private:; 67 ; 68 double DoEval (double x) const override {; 69 return fFunc( x );; 70 }; 71 ; 72 ; 73 Func fFunc;; 74 ; 75 ; 76}; // WrappedFunction; 77 ; 78 ; 79/**; 80 Template class to wrap any member function of a class; 81 taking a double and returning a double in a 1D function interface; 82 For example, if you have a class like:; 83 struct X {; 84 double Eval(double x);; 85 };; 86 you can wrapped in the following way:; 87 WrappedMemFunction<X, double ( X::* ) (double) > f;; 88 ; 89 ; 90 @ingroup GenFunc; 91 ; 92 */; 93 ; 94template<typename FuncObj, typename MemFuncPtr >; 95class WrappedMemFunction : public IGenFunction {; 96 ; 97 ; 98 public:; 99 ; 100 /**; 101 construct from the pointer to the object and the member function; 102 */; 103 WrappedMemFunction( FuncObj & obj, MemFuncPtr memFn ) :; 104 fObj(&obj),; 105 fMemFunc( memFn ); 106 { /* no op */ }; 107 ; 108 // use default copy constructor and assignment operator; 109 ; 110 /// clone (required by the interface); 111 WrappedMemFunction * Clone() const override {; 112 return new WrappedMemFunction(*fObj,fMemFunc);; 113 }; 114 ; 115 ; 116private:; 117 ; 118 double DoEval (double x) const override {; 119 return ((*fObj).*fMemFunc)( x );; 120 }; 121 ; 122 ; 123 FuncObj * fObj;; 124 MemFuncPtr fM",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:2366,Integrability,wrap,wrapped,2366,"d copying) you need to use; 38 Func& or const Func & as template parameter. The former should be used when the; 39 operator() is not a const method of Func; 40 ; 41 @ingroup GenFunc; 42 ; 43 */; 44template< typename Func = FreeFunctionPtr >; 45class WrappedFunction : public IGenFunction {; 46 ; 47 ; 48 public:; 49 ; 50 /**; 51 construct from the pointer to the object and the member function; 52 */; 53 WrappedFunction( Func f ) :; 54 fFunc( f ); 55 { /* no op */ }; 56 ; 57 // use default copy constructor and assignment operator; 58 ; 59 /// clone (required by the interface); 60 WrappedFunction * Clone() const override {; 61 return new WrappedFunction(fFunc);; 62 }; 63 ; 64 // virtual ~WrappedFunction() { /**/ }; 65 ; 66private:; 67 ; 68 double DoEval (double x) const override {; 69 return fFunc( x );; 70 }; 71 ; 72 ; 73 Func fFunc;; 74 ; 75 ; 76}; // WrappedFunction; 77 ; 78 ; 79/**; 80 Template class to wrap any member function of a class; 81 taking a double and returning a double in a 1D function interface; 82 For example, if you have a class like:; 83 struct X {; 84 double Eval(double x);; 85 };; 86 you can wrapped in the following way:; 87 WrappedMemFunction<X, double ( X::* ) (double) > f;; 88 ; 89 ; 90 @ingroup GenFunc; 91 ; 92 */; 93 ; 94template<typename FuncObj, typename MemFuncPtr >; 95class WrappedMemFunction : public IGenFunction {; 96 ; 97 ; 98 public:; 99 ; 100 /**; 101 construct from the pointer to the object and the member function; 102 */; 103 WrappedMemFunction( FuncObj & obj, MemFuncPtr memFn ) :; 104 fObj(&obj),; 105 fMemFunc( memFn ); 106 { /* no op */ }; 107 ; 108 // use default copy constructor and assignment operator; 109 ; 110 /// clone (required by the interface); 111 WrappedMemFunction * Clone() const override {; 112 return new WrappedMemFunction(*fObj,fMemFunc);; 113 }; 114 ; 115 ; 116private:; 117 ; 118 double DoEval (double x) const override {; 119 return ((*fObj).*fMemFunc)( x );; 120 }; 121 ; 122 ; 123 FuncObj * fObj;; 124 MemFuncPtr fM",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:2945,Integrability,interface,interface,2945,"d copying) you need to use; 38 Func& or const Func & as template parameter. The former should be used when the; 39 operator() is not a const method of Func; 40 ; 41 @ingroup GenFunc; 42 ; 43 */; 44template< typename Func = FreeFunctionPtr >; 45class WrappedFunction : public IGenFunction {; 46 ; 47 ; 48 public:; 49 ; 50 /**; 51 construct from the pointer to the object and the member function; 52 */; 53 WrappedFunction( Func f ) :; 54 fFunc( f ); 55 { /* no op */ }; 56 ; 57 // use default copy constructor and assignment operator; 58 ; 59 /// clone (required by the interface); 60 WrappedFunction * Clone() const override {; 61 return new WrappedFunction(fFunc);; 62 }; 63 ; 64 // virtual ~WrappedFunction() { /**/ }; 65 ; 66private:; 67 ; 68 double DoEval (double x) const override {; 69 return fFunc( x );; 70 }; 71 ; 72 ; 73 Func fFunc;; 74 ; 75 ; 76}; // WrappedFunction; 77 ; 78 ; 79/**; 80 Template class to wrap any member function of a class; 81 taking a double and returning a double in a 1D function interface; 82 For example, if you have a class like:; 83 struct X {; 84 double Eval(double x);; 85 };; 86 you can wrapped in the following way:; 87 WrappedMemFunction<X, double ( X::* ) (double) > f;; 88 ; 89 ; 90 @ingroup GenFunc; 91 ; 92 */; 93 ; 94template<typename FuncObj, typename MemFuncPtr >; 95class WrappedMemFunction : public IGenFunction {; 96 ; 97 ; 98 public:; 99 ; 100 /**; 101 construct from the pointer to the object and the member function; 102 */; 103 WrappedMemFunction( FuncObj & obj, MemFuncPtr memFn ) :; 104 fObj(&obj),; 105 fMemFunc( memFn ); 106 { /* no op */ }; 107 ; 108 // use default copy constructor and assignment operator; 109 ; 110 /// clone (required by the interface); 111 WrappedMemFunction * Clone() const override {; 112 return new WrappedMemFunction(*fObj,fMemFunc);; 113 }; 114 ; 115 ; 116private:; 117 ; 118 double DoEval (double x) const override {; 119 return ((*fObj).*fMemFunc)( x );; 120 }; 121 ; 122 ; 123 FuncObj * fObj;; 124 MemFuncPtr fM",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:3332,Integrability,wrap,wrap,3332," struct X {; 84 double Eval(double x);; 85 };; 86 you can wrapped in the following way:; 87 WrappedMemFunction<X, double ( X::* ) (double) > f;; 88 ; 89 ; 90 @ingroup GenFunc; 91 ; 92 */; 93 ; 94template<typename FuncObj, typename MemFuncPtr >; 95class WrappedMemFunction : public IGenFunction {; 96 ; 97 ; 98 public:; 99 ; 100 /**; 101 construct from the pointer to the object and the member function; 102 */; 103 WrappedMemFunction( FuncObj & obj, MemFuncPtr memFn ) :; 104 fObj(&obj),; 105 fMemFunc( memFn ); 106 { /* no op */ }; 107 ; 108 // use default copy constructor and assignment operator; 109 ; 110 /// clone (required by the interface); 111 WrappedMemFunction * Clone() const override {; 112 return new WrappedMemFunction(*fObj,fMemFunc);; 113 }; 114 ; 115 ; 116private:; 117 ; 118 double DoEval (double x) const override {; 119 return ((*fObj).*fMemFunc)( x );; 120 }; 121 ; 122 ; 123 FuncObj * fObj;; 124 MemFuncPtr fMemFunc;; 125 ; 126 ; 127}; // WrappedMemFunction; 128 ; 129 ; 130/**; 131 Template class to wrap any C++ callable object; 132 implementing operator() (const double * x) in a multi-dimensional function interface.; 133 It provides a ROOT::Math::IGenMultiFunction-like signature; 134 ; 135 Note: If you want to wrap just the reference (to avoid copying) you need to use; 136 Func& or const Func & as template parameter. The former should be used when the; 137 operator() is not a const method of Func; 138 ; 139 @ingroup GenFunc; 140 ; 141 */; 142template< typename Func = FreeMultiFunctionPtr >; 143class WrappedMultiFunction : public IMultiGenFunction {; 144 ; 145 ; 146 public:; 147 ; 148 /**; 149 construct from the pointer to the object and the member function; 150 */; 151 WrappedMultiFunction( Func f , unsigned int dim = 1) :; 152 fFunc( f ),; 153 fDim( dim); 154 { /* no op */ }; 155 ; 156 // use default copy constructor and assignment operator; 157 ; 158 /// clone (required by the interface); 159 WrappedMultiFunction * Clone() const override {; 160 return ne",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:3441,Integrability,interface,interface,3441," struct X {; 84 double Eval(double x);; 85 };; 86 you can wrapped in the following way:; 87 WrappedMemFunction<X, double ( X::* ) (double) > f;; 88 ; 89 ; 90 @ingroup GenFunc; 91 ; 92 */; 93 ; 94template<typename FuncObj, typename MemFuncPtr >; 95class WrappedMemFunction : public IGenFunction {; 96 ; 97 ; 98 public:; 99 ; 100 /**; 101 construct from the pointer to the object and the member function; 102 */; 103 WrappedMemFunction( FuncObj & obj, MemFuncPtr memFn ) :; 104 fObj(&obj),; 105 fMemFunc( memFn ); 106 { /* no op */ }; 107 ; 108 // use default copy constructor and assignment operator; 109 ; 110 /// clone (required by the interface); 111 WrappedMemFunction * Clone() const override {; 112 return new WrappedMemFunction(*fObj,fMemFunc);; 113 }; 114 ; 115 ; 116private:; 117 ; 118 double DoEval (double x) const override {; 119 return ((*fObj).*fMemFunc)( x );; 120 }; 121 ; 122 ; 123 FuncObj * fObj;; 124 MemFuncPtr fMemFunc;; 125 ; 126 ; 127}; // WrappedMemFunction; 128 ; 129 ; 130/**; 131 Template class to wrap any C++ callable object; 132 implementing operator() (const double * x) in a multi-dimensional function interface.; 133 It provides a ROOT::Math::IGenMultiFunction-like signature; 134 ; 135 Note: If you want to wrap just the reference (to avoid copying) you need to use; 136 Func& or const Func & as template parameter. The former should be used when the; 137 operator() is not a const method of Func; 138 ; 139 @ingroup GenFunc; 140 ; 141 */; 142template< typename Func = FreeMultiFunctionPtr >; 143class WrappedMultiFunction : public IMultiGenFunction {; 144 ; 145 ; 146 public:; 147 ; 148 /**; 149 construct from the pointer to the object and the member function; 150 */; 151 WrappedMultiFunction( Func f , unsigned int dim = 1) :; 152 fFunc( f ),; 153 fDim( dim); 154 { /* no op */ }; 155 ; 156 // use default copy constructor and assignment operator; 157 ; 158 /// clone (required by the interface); 159 WrappedMultiFunction * Clone() const override {; 160 return ne",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:3548,Integrability,wrap,wrap,3548,"95class WrappedMemFunction : public IGenFunction {; 96 ; 97 ; 98 public:; 99 ; 100 /**; 101 construct from the pointer to the object and the member function; 102 */; 103 WrappedMemFunction( FuncObj & obj, MemFuncPtr memFn ) :; 104 fObj(&obj),; 105 fMemFunc( memFn ); 106 { /* no op */ }; 107 ; 108 // use default copy constructor and assignment operator; 109 ; 110 /// clone (required by the interface); 111 WrappedMemFunction * Clone() const override {; 112 return new WrappedMemFunction(*fObj,fMemFunc);; 113 }; 114 ; 115 ; 116private:; 117 ; 118 double DoEval (double x) const override {; 119 return ((*fObj).*fMemFunc)( x );; 120 }; 121 ; 122 ; 123 FuncObj * fObj;; 124 MemFuncPtr fMemFunc;; 125 ; 126 ; 127}; // WrappedMemFunction; 128 ; 129 ; 130/**; 131 Template class to wrap any C++ callable object; 132 implementing operator() (const double * x) in a multi-dimensional function interface.; 133 It provides a ROOT::Math::IGenMultiFunction-like signature; 134 ; 135 Note: If you want to wrap just the reference (to avoid copying) you need to use; 136 Func& or const Func & as template parameter. The former should be used when the; 137 operator() is not a const method of Func; 138 ; 139 @ingroup GenFunc; 140 ; 141 */; 142template< typename Func = FreeMultiFunctionPtr >; 143class WrappedMultiFunction : public IMultiGenFunction {; 144 ; 145 ; 146 public:; 147 ; 148 /**; 149 construct from the pointer to the object and the member function; 150 */; 151 WrappedMultiFunction( Func f , unsigned int dim = 1) :; 152 fFunc( f ),; 153 fDim( dim); 154 { /* no op */ }; 155 ; 156 // use default copy constructor and assignment operator; 157 ; 158 /// clone (required by the interface); 159 WrappedMultiFunction * Clone() const override {; 160 return new WrappedMultiFunction(fFunc,fDim);; 161 }; 162 ; 163 unsigned int NDim() const override { return fDim; }; 164 ; 165 // virtual ~WrappedFunction() { /**/ }; 166 ; 167private:; 168 ; 169 double DoEval (const double * x) const override {; 170 retur",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:4230,Integrability,interface,interface,4230,"o avoid copying) you need to use; 136 Func& or const Func & as template parameter. The former should be used when the; 137 operator() is not a const method of Func; 138 ; 139 @ingroup GenFunc; 140 ; 141 */; 142template< typename Func = FreeMultiFunctionPtr >; 143class WrappedMultiFunction : public IMultiGenFunction {; 144 ; 145 ; 146 public:; 147 ; 148 /**; 149 construct from the pointer to the object and the member function; 150 */; 151 WrappedMultiFunction( Func f , unsigned int dim = 1) :; 152 fFunc( f ),; 153 fDim( dim); 154 { /* no op */ }; 155 ; 156 // use default copy constructor and assignment operator; 157 ; 158 /// clone (required by the interface); 159 WrappedMultiFunction * Clone() const override {; 160 return new WrappedMultiFunction(fFunc,fDim);; 161 }; 162 ; 163 unsigned int NDim() const override { return fDim; }; 164 ; 165 // virtual ~WrappedFunction() { /**/ }; 166 ; 167private:; 168 ; 169 double DoEval (const double * x) const override {; 170 return fFunc( x );; 171 }; 172 ; 173 ; 174 Func fFunc;; 175 unsigned int fDim;; 176 ; 177 ; 178}; // WrappedMultiFunction; 179 ; 180 ; 181template<typename FuncObj, typename MemFuncPtr >; 182class WrappedMemMultiFunction : public IMultiGenFunction {; 183 ; 184 ; 185 public:; 186 ; 187 /**; 188 construct from the pointer to the object and the member function; 189 */; 190 WrappedMemMultiFunction( FuncObj & obj, MemFuncPtr memFn, unsigned int dim = 1 ) :; 191 fObj(&obj),; 192 fMemFunc( memFn ),; 193 fDim(dim); 194 { /* no op */ }; 195 ; 196 // use default copy constructor and assignment operator; 197 ; 198 /// clone (required by the interface); 199 WrappedMemMultiFunction * Clone() const override {; 200 return new WrappedMemMultiFunction(*fObj,fMemFunc,fDim);; 201 }; 202 ; 203 ; 204 unsigned int NDim() const override { return fDim; }; 205 ; 206private:; 207 ; 208 double DoEval (const double * x) const override {; 209 return ((*fObj).*fMemFunc)( x );; 210 }; 211 ; 212 ; 213 FuncObj * fObj;; 214 MemFuncPtr fMemFunc;",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:5187,Integrability,interface,interface,5187,"o avoid copying) you need to use; 136 Func& or const Func & as template parameter. The former should be used when the; 137 operator() is not a const method of Func; 138 ; 139 @ingroup GenFunc; 140 ; 141 */; 142template< typename Func = FreeMultiFunctionPtr >; 143class WrappedMultiFunction : public IMultiGenFunction {; 144 ; 145 ; 146 public:; 147 ; 148 /**; 149 construct from the pointer to the object and the member function; 150 */; 151 WrappedMultiFunction( Func f , unsigned int dim = 1) :; 152 fFunc( f ),; 153 fDim( dim); 154 { /* no op */ }; 155 ; 156 // use default copy constructor and assignment operator; 157 ; 158 /// clone (required by the interface); 159 WrappedMultiFunction * Clone() const override {; 160 return new WrappedMultiFunction(fFunc,fDim);; 161 }; 162 ; 163 unsigned int NDim() const override { return fDim; }; 164 ; 165 // virtual ~WrappedFunction() { /**/ }; 166 ; 167private:; 168 ; 169 double DoEval (const double * x) const override {; 170 return fFunc( x );; 171 }; 172 ; 173 ; 174 Func fFunc;; 175 unsigned int fDim;; 176 ; 177 ; 178}; // WrappedMultiFunction; 179 ; 180 ; 181template<typename FuncObj, typename MemFuncPtr >; 182class WrappedMemMultiFunction : public IMultiGenFunction {; 183 ; 184 ; 185 public:; 186 ; 187 /**; 188 construct from the pointer to the object and the member function; 189 */; 190 WrappedMemMultiFunction( FuncObj & obj, MemFuncPtr memFn, unsigned int dim = 1 ) :; 191 fObj(&obj),; 192 fMemFunc( memFn ),; 193 fDim(dim); 194 { /* no op */ }; 195 ; 196 // use default copy constructor and assignment operator; 197 ; 198 /// clone (required by the interface); 199 WrappedMemMultiFunction * Clone() const override {; 200 return new WrappedMemMultiFunction(*fObj,fMemFunc,fDim);; 201 }; 202 ; 203 ; 204 unsigned int NDim() const override { return fDim; }; 205 ; 206private:; 207 ; 208 double DoEval (const double * x) const override {; 209 return ((*fObj).*fMemFunc)( x );; 210 }; 211 ; 212 ; 213 FuncObj * fObj;; 214 MemFuncPtr fMemFunc;",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:6151,Integrability,wrap,wrap,6151," ; 198 /// clone (required by the interface); 199 WrappedMemMultiFunction * Clone() const override {; 200 return new WrappedMemMultiFunction(*fObj,fMemFunc,fDim);; 201 }; 202 ; 203 ; 204 unsigned int NDim() const override { return fDim; }; 205 ; 206private:; 207 ; 208 double DoEval (const double * x) const override {; 209 return ((*fObj).*fMemFunc)( x );; 210 }; 211 ; 212 ; 213 FuncObj * fObj;; 214 MemFuncPtr fMemFunc;; 215 unsigned int fDim;; 216 ; 217 ; 218}; // WrappedMemMultiFunction; 219 ; 220 ; 221} // namespace Math; 222} // namespace ROOT; 223 ; 224 ; 225 ; 226#endif // ROOT_Math_WrappedFunction; IFunction.h; f#define f(i)Definition RSha256.hxx:104; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Math::WrappedFunctionTemplate class to wrap any C++ callable object which takes one argument i.e.Definition WrappedFunction.h:45; ROOT::Math::WrappedFunction::DoEvaldouble DoEval(double x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition WrappedFunction.h:68; ROOT::Math::WrappedFunction::fFuncFunc fFuncDefinition WrappedFunction.h:73; ROOT::Math::WrappedFunction::CloneWrappedFunction * Clone() const overrideclone (required by the interface)Definition WrappedFunction.h:60; ROOT::Math::WrappedFunction::WrappedFunctionWrappedFunction(Func f)construct from the pointer to the object and the member functionDefinition WrappedFunction.h:53; ROOT::Math::WrappedMemFunctionTemplate class to wrap any member function of a class taking a double and returning a double in a 1D ...Definition WrappedFunction.h:95; ROOT::Math::WrappedMemFunction::DoEvaldouble DoEval(double x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition WrappedF",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:6603,Integrability,interface,interface,6603,"Func;; 215 unsigned int fDim;; 216 ; 217 ; 218}; // WrappedMemMultiFunction; 219 ; 220 ; 221} // namespace Math; 222} // namespace ROOT; 223 ; 224 ; 225 ; 226#endif // ROOT_Math_WrappedFunction; IFunction.h; f#define f(i)Definition RSha256.hxx:104; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Math::WrappedFunctionTemplate class to wrap any C++ callable object which takes one argument i.e.Definition WrappedFunction.h:45; ROOT::Math::WrappedFunction::DoEvaldouble DoEval(double x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition WrappedFunction.h:68; ROOT::Math::WrappedFunction::fFuncFunc fFuncDefinition WrappedFunction.h:73; ROOT::Math::WrappedFunction::CloneWrappedFunction * Clone() const overrideclone (required by the interface)Definition WrappedFunction.h:60; ROOT::Math::WrappedFunction::WrappedFunctionWrappedFunction(Func f)construct from the pointer to the object and the member functionDefinition WrappedFunction.h:53; ROOT::Math::WrappedMemFunctionTemplate class to wrap any member function of a class taking a double and returning a double in a 1D ...Definition WrappedFunction.h:95; ROOT::Math::WrappedMemFunction::DoEvaldouble DoEval(double x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition WrappedFunction.h:118; ROOT::Math::WrappedMemFunction::fMemFuncMemFuncPtr fMemFuncDefinition WrappedFunction.h:124; ROOT::Math::WrappedMemFunction::WrappedMemFunctionWrappedMemFunction(FuncObj &obj, MemFuncPtr memFn)construct from the pointer to the object and the member functionDefinition WrappedFunction.h:103; ROOT::Math::WrappedMemFunction::fObjFuncObj * fObjDefinition WrappedFunction.h:123; ROOT::Math::WrappedMemFunct",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:6858,Integrability,wrap,wrap,6858,"r the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IBaseFunctionOneDimInterface (abstract class) for generic functions objects of one-dimension Provides a method to evalua...Definition IFunction.h:112; ROOT::Math::WrappedFunctionTemplate class to wrap any C++ callable object which takes one argument i.e.Definition WrappedFunction.h:45; ROOT::Math::WrappedFunction::DoEvaldouble DoEval(double x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition WrappedFunction.h:68; ROOT::Math::WrappedFunction::fFuncFunc fFuncDefinition WrappedFunction.h:73; ROOT::Math::WrappedFunction::CloneWrappedFunction * Clone() const overrideclone (required by the interface)Definition WrappedFunction.h:60; ROOT::Math::WrappedFunction::WrappedFunctionWrappedFunction(Func f)construct from the pointer to the object and the member functionDefinition WrappedFunction.h:53; ROOT::Math::WrappedMemFunctionTemplate class to wrap any member function of a class taking a double and returning a double in a 1D ...Definition WrappedFunction.h:95; ROOT::Math::WrappedMemFunction::DoEvaldouble DoEval(double x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition WrappedFunction.h:118; ROOT::Math::WrappedMemFunction::fMemFuncMemFuncPtr fMemFuncDefinition WrappedFunction.h:124; ROOT::Math::WrappedMemFunction::WrappedMemFunctionWrappedMemFunction(FuncObj &obj, MemFuncPtr memFn)construct from the pointer to the object and the member functionDefinition WrappedFunction.h:103; ROOT::Math::WrappedMemFunction::fObjFuncObj * fObjDefinition WrappedFunction.h:123; ROOT::Math::WrappedMemFunction::CloneWrappedMemFunction * Clone() const overrideclone (required by the interface)Definition WrappedFunction.h:111; ROOT::Math::WrappedMemMultiFunctionDefinition WrappedFunction.h:182; ROOT::Math::WrappedMemMultiFunction::fMemFuncMemFuncPtr fMemFuncDefinition WrappedFunction.h:214; ROOT::Math::Wrap",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:7646,Integrability,interface,interface,7646,"ace)Definition WrappedFunction.h:60; ROOT::Math::WrappedFunction::WrappedFunctionWrappedFunction(Func f)construct from the pointer to the object and the member functionDefinition WrappedFunction.h:53; ROOT::Math::WrappedMemFunctionTemplate class to wrap any member function of a class taking a double and returning a double in a 1D ...Definition WrappedFunction.h:95; ROOT::Math::WrappedMemFunction::DoEvaldouble DoEval(double x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition WrappedFunction.h:118; ROOT::Math::WrappedMemFunction::fMemFuncMemFuncPtr fMemFuncDefinition WrappedFunction.h:124; ROOT::Math::WrappedMemFunction::WrappedMemFunctionWrappedMemFunction(FuncObj &obj, MemFuncPtr memFn)construct from the pointer to the object and the member functionDefinition WrappedFunction.h:103; ROOT::Math::WrappedMemFunction::fObjFuncObj * fObjDefinition WrappedFunction.h:123; ROOT::Math::WrappedMemFunction::CloneWrappedMemFunction * Clone() const overrideclone (required by the interface)Definition WrappedFunction.h:111; ROOT::Math::WrappedMemMultiFunctionDefinition WrappedFunction.h:182; ROOT::Math::WrappedMemMultiFunction::fMemFuncMemFuncPtr fMemFuncDefinition WrappedFunction.h:214; ROOT::Math::WrappedMemMultiFunction::CloneWrappedMemMultiFunction * Clone() const overrideclone (required by the interface)Definition WrappedFunction.h:199; ROOT::Math::WrappedMemMultiFunction::WrappedMemMultiFunctionWrappedMemMultiFunction(FuncObj &obj, MemFuncPtr memFn, unsigned int dim=1)construct from the pointer to the object and the member functionDefinition WrappedFunction.h:190; ROOT::Math::WrappedMemMultiFunction::DoEvaldouble DoEval(const double *x) const overrideDefinition WrappedFunction.h:208; ROOT::Math::WrappedMemMultiFunction::fDimunsigned int fDimDefinition WrappedFunction.h:215; ROOT::Math::WrappedMemMultiFunction::fObjFuncObj * fObjDefinition WrappedFunction.h:213; ROOT::Math::WrappedMemMultiFunction::NDimunsigned int NDim()",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:7970,Integrability,interface,interface,7970,"uble in a 1D ...Definition WrappedFunction.h:95; ROOT::Math::WrappedMemFunction::DoEvaldouble DoEval(double x) const overrideimplementation of the evaluation function. Must be implemented by derived classesDefinition WrappedFunction.h:118; ROOT::Math::WrappedMemFunction::fMemFuncMemFuncPtr fMemFuncDefinition WrappedFunction.h:124; ROOT::Math::WrappedMemFunction::WrappedMemFunctionWrappedMemFunction(FuncObj &obj, MemFuncPtr memFn)construct from the pointer to the object and the member functionDefinition WrappedFunction.h:103; ROOT::Math::WrappedMemFunction::fObjFuncObj * fObjDefinition WrappedFunction.h:123; ROOT::Math::WrappedMemFunction::CloneWrappedMemFunction * Clone() const overrideclone (required by the interface)Definition WrappedFunction.h:111; ROOT::Math::WrappedMemMultiFunctionDefinition WrappedFunction.h:182; ROOT::Math::WrappedMemMultiFunction::fMemFuncMemFuncPtr fMemFuncDefinition WrappedFunction.h:214; ROOT::Math::WrappedMemMultiFunction::CloneWrappedMemMultiFunction * Clone() const overrideclone (required by the interface)Definition WrappedFunction.h:199; ROOT::Math::WrappedMemMultiFunction::WrappedMemMultiFunctionWrappedMemMultiFunction(FuncObj &obj, MemFuncPtr memFn, unsigned int dim=1)construct from the pointer to the object and the member functionDefinition WrappedFunction.h:190; ROOT::Math::WrappedMemMultiFunction::DoEvaldouble DoEval(const double *x) const overrideDefinition WrappedFunction.h:208; ROOT::Math::WrappedMemMultiFunction::fDimunsigned int fDimDefinition WrappedFunction.h:215; ROOT::Math::WrappedMemMultiFunction::fObjFuncObj * fObjDefinition WrappedFunction.h:213; ROOT::Math::WrappedMemMultiFunction::NDimunsigned int NDim() const overrideRetrieve the dimension of the function.Definition WrappedFunction.h:204; ROOT::Math::WrappedMultiFunctionTemplate class to wrap any C++ callable object implementing operator() (const double * x) in a multi-...Definition WrappedFunction.h:143; ROOT::Math::WrappedMultiFunction::WrappedMultiFunctionWrapped",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:8748,Integrability,wrap,wrap,8748,"OT::Math::WrappedMemMultiFunction::fMemFuncMemFuncPtr fMemFuncDefinition WrappedFunction.h:214; ROOT::Math::WrappedMemMultiFunction::CloneWrappedMemMultiFunction * Clone() const overrideclone (required by the interface)Definition WrappedFunction.h:199; ROOT::Math::WrappedMemMultiFunction::WrappedMemMultiFunctionWrappedMemMultiFunction(FuncObj &obj, MemFuncPtr memFn, unsigned int dim=1)construct from the pointer to the object and the member functionDefinition WrappedFunction.h:190; ROOT::Math::WrappedMemMultiFunction::DoEvaldouble DoEval(const double *x) const overrideDefinition WrappedFunction.h:208; ROOT::Math::WrappedMemMultiFunction::fDimunsigned int fDimDefinition WrappedFunction.h:215; ROOT::Math::WrappedMemMultiFunction::fObjFuncObj * fObjDefinition WrappedFunction.h:213; ROOT::Math::WrappedMemMultiFunction::NDimunsigned int NDim() const overrideRetrieve the dimension of the function.Definition WrappedFunction.h:204; ROOT::Math::WrappedMultiFunctionTemplate class to wrap any C++ callable object implementing operator() (const double * x) in a multi-...Definition WrappedFunction.h:143; ROOT::Math::WrappedMultiFunction::WrappedMultiFunctionWrappedMultiFunction(Func f, unsigned int dim=1)construct from the pointer to the object and the member functionDefinition WrappedFunction.h:151; ROOT::Math::WrappedMultiFunction::fDimunsigned int fDimDefinition WrappedFunction.h:175; ROOT::Math::WrappedMultiFunction::CloneWrappedMultiFunction * Clone() const overrideclone (required by the interface)Definition WrappedFunction.h:159; ROOT::Math::WrappedMultiFunction::DoEvaldouble DoEval(const double *x) const overrideDefinition WrappedFunction.h:169; ROOT::Math::WrappedMultiFunction::fFuncFunc fFuncDefinition WrappedFunction.h:174; ROOT::Math::WrappedMultiFunction::NDimunsigned int NDim() const overrideRetrieve the dimension of the function.Definition WrappedFunction.h:163; double; xDouble_t x[n]Definition legend1.C:17; MathNamespace for new Math classes and functions.; ROOT::Mat",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:9264,Integrability,interface,interface,9264,"rappedFunction.h:190; ROOT::Math::WrappedMemMultiFunction::DoEvaldouble DoEval(const double *x) const overrideDefinition WrappedFunction.h:208; ROOT::Math::WrappedMemMultiFunction::fDimunsigned int fDimDefinition WrappedFunction.h:215; ROOT::Math::WrappedMemMultiFunction::fObjFuncObj * fObjDefinition WrappedFunction.h:213; ROOT::Math::WrappedMemMultiFunction::NDimunsigned int NDim() const overrideRetrieve the dimension of the function.Definition WrappedFunction.h:204; ROOT::Math::WrappedMultiFunctionTemplate class to wrap any C++ callable object implementing operator() (const double * x) in a multi-...Definition WrappedFunction.h:143; ROOT::Math::WrappedMultiFunction::WrappedMultiFunctionWrappedMultiFunction(Func f, unsigned int dim=1)construct from the pointer to the object and the member functionDefinition WrappedFunction.h:151; ROOT::Math::WrappedMultiFunction::fDimunsigned int fDimDefinition WrappedFunction.h:175; ROOT::Math::WrappedMultiFunction::CloneWrappedMultiFunction * Clone() const overrideclone (required by the interface)Definition WrappedFunction.h:159; ROOT::Math::WrappedMultiFunction::DoEvaldouble DoEval(const double *x) const overrideDefinition WrappedFunction.h:169; ROOT::Math::WrappedMultiFunction::fFuncFunc fFuncDefinition WrappedFunction.h:174; ROOT::Math::WrappedMultiFunction::NDimunsigned int NDim() const overrideRetrieve the dimension of the function.Definition WrappedFunction.h:163; double; xDouble_t x[n]Definition legend1.C:17; MathNamespace for new Math classes and functions.; ROOT::Math::FreeMultiFunctionPtrdouble(* FreeMultiFunctionPtr)(const double *)Definition WrappedFunction.h:30; ROOT::Math::FreeFunctionPtrdouble(* FreeFunctionPtr)(double)Definition WrappedFunction.h:28; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::Math::NullTypeFunc1DDefinition WrappedFunction.h:26. mathmathcoreincMathWrappedFunction.h. ROOT master - Reference Guide",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:1235,Safety,avoid,avoid,1235,"hcore:$Id$; 2// Authors: L. Moneta, A. Zsenei 08/2005; 3 ; 4 /**********************************************************************; 5 * *; 6 * Copyright (c) 2004 CERN *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 * *; 12 **********************************************************************/; 13 ; 14#ifndef ROOT_Math_WrappedFunction; 15#define ROOT_Math_WrappedFunction; 16 ; 17#include ""IFunction.h""; 18 ; 19 ; 20namespace ROOT {; 21namespace Math {; 22 ; 23 ; 24 ; 25 ; 26struct NullTypeFunc1D {};; 27 ; 28typedef double(*FreeFunctionPtr)(double);; 29 ; 30typedef double(*FreeMultiFunctionPtr)(const double*);; 31 ; 32/**; 33 Template class to wrap any C++ callable object which takes one argument; 34 i.e. implementing operator() (double x) in a One-dimensional function interface.; 35 It provides a ROOT::Math::IGenFunction-like signature; 36 ; 37 Note: If you want to wrap just the reference (to avoid copying) you need to use; 38 Func& or const Func & as template parameter. The former should be used when the; 39 operator() is not a const method of Func; 40 ; 41 @ingroup GenFunc; 42 ; 43 */; 44template< typename Func = FreeFunctionPtr >; 45class WrappedFunction : public IGenFunction {; 46 ; 47 ; 48 public:; 49 ; 50 /**; 51 construct from the pointer to the object and the member function; 52 */; 53 WrappedFunction( Func f ) :; 54 fFunc( f ); 55 { /* no op */ }; 56 ; 57 // use default copy constructor and assignment operator; 58 ; 59 /// clone (required by the interface); 60 WrappedFunction * Clone() const override {; 61 return new WrappedFunction(fFunc);; 62 }; 63 ; 64 // virtual ~WrappedFunction() { /**/ }; 65 ; 66private:; 67 ; 68 double DoEval (double x) const override {; 69 return fFunc( x );; 70 }; 71 ; 72 ; 73 Func fFunc;; 74 ; 75 ; 76}; // WrappedFunction; 77 ; 78 ; 79/**; 80 Template class to wrap any member function of a class; 81 taking a double and ",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedFunction_8h_source.html:3576,Safety,avoid,avoid,3576,"95class WrappedMemFunction : public IGenFunction {; 96 ; 97 ; 98 public:; 99 ; 100 /**; 101 construct from the pointer to the object and the member function; 102 */; 103 WrappedMemFunction( FuncObj & obj, MemFuncPtr memFn ) :; 104 fObj(&obj),; 105 fMemFunc( memFn ); 106 { /* no op */ }; 107 ; 108 // use default copy constructor and assignment operator; 109 ; 110 /// clone (required by the interface); 111 WrappedMemFunction * Clone() const override {; 112 return new WrappedMemFunction(*fObj,fMemFunc);; 113 }; 114 ; 115 ; 116private:; 117 ; 118 double DoEval (double x) const override {; 119 return ((*fObj).*fMemFunc)( x );; 120 }; 121 ; 122 ; 123 FuncObj * fObj;; 124 MemFuncPtr fMemFunc;; 125 ; 126 ; 127}; // WrappedMemFunction; 128 ; 129 ; 130/**; 131 Template class to wrap any C++ callable object; 132 implementing operator() (const double * x) in a multi-dimensional function interface.; 133 It provides a ROOT::Math::IGenMultiFunction-like signature; 134 ; 135 Note: If you want to wrap just the reference (to avoid copying) you need to use; 136 Func& or const Func & as template parameter. The former should be used when the; 137 operator() is not a const method of Func; 138 ; 139 @ingroup GenFunc; 140 ; 141 */; 142template< typename Func = FreeMultiFunctionPtr >; 143class WrappedMultiFunction : public IMultiGenFunction {; 144 ; 145 ; 146 public:; 147 ; 148 /**; 149 construct from the pointer to the object and the member function; 150 */; 151 WrappedMultiFunction( Func f , unsigned int dim = 1) :; 152 fFunc( f ),; 153 fDim( dim); 154 { /* no op */ }; 155 ; 156 // use default copy constructor and assignment operator; 157 ; 158 /// clone (required by the interface); 159 WrappedMultiFunction * Clone() const override {; 160 return new WrappedMultiFunction(fFunc,fDim);; 161 }; 162 ; 163 unsigned int NDim() const override { return fDim; }; 164 ; 165 // virtual ~WrappedFunction() { /**/ }; 166 ; 167private:; 168 ; 169 double DoEval (const double * x) const override {; 170 retur",MatchSource.WIKI,doc/master/WrappedFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedFunction_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h.html:345,Integrability,depend,dependency,345,". ROOT: hist/hist/inc/Math/WrappedMultiTF1.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Typedefs |; Functions ; WrappedMultiTF1.h File Reference. #include ""Math/IParamFunction.h""; #include ""TF1.h""; #include <string>; #include <vector>; #include <algorithm>. Include dependency graph for WrappedMultiTF1.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  ROOT::Math::GeneralHessianCalc< T >;  ; struct  ROOT::Math::GeneralHessianCalc< double >;  ; struct  ROOT::Math::GeneralLinearFunctionDerivation< T >;  Auxiliar class to bypass the (provisional) lack of vectorization in TFormula::EvalPar. More...;  ; struct  ROOT::Math::GeneralLinearFunctionDerivation< double >;  ; class  ROOT::Math::WrappedMultiTF1Templ< T >;  Class to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions to be used in the ROOT::Math numerical algorithm. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Math;  ; namespace  ROOT::Math::Internal;  . Typedefs; using ROOT::Math::WrappedMultiTF1 = WrappedMultiTF1Templ< double >;  . Functions; TF1 * ROOT::Math::Internal::CopyTF1Ptr (const TF1 *funcToCopy);  ; double ROOT::Math::Internal::DerivPrecision (double eps);  . histhistincMathWrappedMultiTF1.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h.html
https://root.cern/doc/master/WrappedMultiTF1_8h.html:1081,Integrability,interface,interface,1081,". ROOT: hist/hist/inc/Math/WrappedMultiTF1.h File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Classes |; Namespaces |; Typedefs |; Functions ; WrappedMultiTF1.h File Reference. #include ""Math/IParamFunction.h""; #include ""TF1.h""; #include <string>; #include <vector>; #include <algorithm>. Include dependency graph for WrappedMultiTF1.h:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. This graph shows which files directly or indirectly include this file:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  ROOT::Math::GeneralHessianCalc< T >;  ; struct  ROOT::Math::GeneralHessianCalc< double >;  ; struct  ROOT::Math::GeneralLinearFunctionDerivation< T >;  Auxiliar class to bypass the (provisional) lack of vectorization in TFormula::EvalPar. More...;  ; struct  ROOT::Math::GeneralLinearFunctionDerivation< double >;  ; class  ROOT::Math::WrappedMultiTF1Templ< T >;  Class to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions to be used in the ROOT::Math numerical algorithm. More...;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  ; namespace  ROOT::Math;  ; namespace  ROOT::Math::Internal;  . Typedefs; using ROOT::Math::WrappedMultiTF1 = WrappedMultiTF1Templ< double >;  . Functions; TF1 * ROOT::Math::Internal::CopyTF1Ptr (const TF1 *funcToCopy);  ; double ROOT::Math::Internal::DerivPrecision (double eps);  . histhistincMathWrappedMultiTF1.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:20 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:7000,Availability,error,error,7000,"ble * p = (fParams.size() > 0) ? &fParams.front() : 0;; 177 ; 178 return fFunc->EvalPar(x, nullptr);; 179 }; 180 ; 181 /// evaluate the partial derivative with respect to the parameter; 182 T DoParameterDerivative(const T *x, const double *p, unsigned int ipar) const override;; 183 ; 184 bool fLinear; // flag for linear functions; 185 bool fPolynomial; // flag for polynomial functions; 186 bool fOwnFunc; // flag to indicate we own the TF1 function pointer; 187 TF1 *fFunc; // pointer to ROOT function; 188 unsigned int fDim; // cached value of dimension; 189 //std::vector<double> fParams; // cached vector with parameter values; 190 ; 191 };; 192 ; 193 /**; 194 * Auxiliar class to bypass the (provisional) lack of vectorization in TFormula::EvalPar.; 195 *; 196 * WrappedMultiTF1Templ::DoParameterDerivation calls TFormula::EvalPar in the case of a general linear function; 197 * built with TFormula using ++; as EvalPar is not vectorized, in order to generalize DoParameterDerivative with; 198 * a general type T, we use this auxiliar class to branch the code in compile time with the double; 199 * specialization (that can call EvalPar) and the general implementation (that throws an error in the case of; 200 * general linear function).; 201 */; 202 template <class T>; 203 struct GeneralLinearFunctionDerivation {; 204 static T DoParameterDerivative(const WrappedMultiTF1Templ<T> *, const T *, unsigned int); 205 {; 206 Error(""DoParameterDerivative"", ""The vectorized implementation of DoParameterDerivative does not support""; 207 ""general linear functions built in TFormula with ++"");; 208 ; 209 return TMath::SignalingNaN();; 210 }; 211 };; 212 ; 213 template <>; 214 struct GeneralLinearFunctionDerivation<double> {; 215 static double; 216 DoParameterDerivative(const WrappedMultiTF1Templ<double> *wrappedFunc, const double *x, unsigned int ipar); 217 {; 218 const TFormula *df = dynamic_cast<const TFormula *>(wrappedFunc->GetFunction()->GetLinearPart(ipar));; 219 assert(df != nullptr);",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:11000,Availability,avail,available,11000,"ters.; 291 // so in case of fLinear (or fPolynomial) a non-zero value will be returned for fixed parameters; 292 ; 293 if (!fLinear) {; 294 // need to set parameter values; 295 fFunc->SetParameters(par);; 296 // no need to call InitArgs (it is called in TF1::GradientPar); 297 double prec = this->GetDerivPrecision();; 298 fFunc->GradientPar(x, grad, prec);; 299 } else { // case of linear functions; 300 unsigned int np = NPar();; 301 for (unsigned int i = 0; i < np; ++i); 302 grad[i] = DoParameterDerivative(x, par, i);; 303 }; 304 }; 305 ; 306 // struct for dealing of generic Hessian computation, since it is available only in TFormula; 307 template <class T>; 308 struct GeneralHessianCalc {; 309 static bool Hessian(TF1 *, const T *, const double *, T *); 310 {; 311 Error(""Hessian"", ""The vectorized implementation of ParameterHessian is not supported"");; 312 return false;; 313 }; 314 static bool IsAvailable(TF1 * ) { return false;}; 315 };; 316 ; 317 template <>; 318 struct GeneralHessianCalc<double> {; 319 static bool Hessian(TF1 * func, const double *x, const double * par, double * h); 320 {; 321 // compute Hessian if TF1 is a formula based; 322 unsigned int np = func->GetNpar();; 323 auto formula = func->GetFormula();; 324 if (!formula) return false;; 325 std::vector<double> h2(np*np);; 326 func->SetParameters(par);; 327 formula->HessianPar(x,h2);; 328 for (unsigned int i = 0; i < np; i++) {; 329 for (unsigned int j = 0; j <= i; j++) {; 330 unsigned int ih = j + i *(i+1)/2; // formula for j <= i; 331 unsigned int im = i*np + j;; 332 h[ih] = h2[im];; 333 }; 334 }; 335 return true;; 336 }; 337 static bool IsAvailable(TF1 * func) {; 338 auto formula = func->GetFormula();; 339 if (!formula) return false;; 340 return formula->GenerateHessianPar();; 341 }; 342 };; 343 ; 344 ; 345 ; 346 template <class T>; 347 bool WrappedMultiTF1Templ<T>::ParameterHessian(const T *x, const double *par, T *h) const; 348 {; 349 if (fLinear) {; 350 std::fill(h, h + NPar()*(NPar()+1)/2, 0.0);; ",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:14502,Availability,error,error,14502,"LinearFunctionDerivation<T>::DoParameterDerivative(this, x, ipar);; 384 }; 385 }; 386 template<class T>; 387 void WrappedMultiTF1Templ<T>::SetDerivPrecision(double eps); 388 {; 389 ::ROOT::Math::Internal::DerivPrecision(eps);; 390 }; 391 ; 392 template<class T>; 393 double WrappedMultiTF1Templ<T>::GetDerivPrecision(); 394 {; 395 return ::ROOT::Math::Internal::DerivPrecision(-1);; 396 }; 397 ; 398 template<class T>; 399 void WrappedMultiTF1Templ<T>::SetAndCopyFunction(const TF1 *f); 400 {; 401 const TF1 *funcToCopy = (f) ? f : fFunc;; 402 fFunc = ::ROOT::Math::Internal::CopyTF1Ptr(funcToCopy);; 403 fOwnFunc = true;; 404 }; 405 ; 406 using WrappedMultiTF1 = WrappedMultiTF1Templ<double>;; 407 ; 408 } // end namespace Math; 409 ; 410} // end namespace ROOT; 411 ; 412 ; 413#endif /* ROOT_Fit_WrappedMultiTF1 */; IParamFunction.h; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TF1.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; npOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t npDefinition TGWin32VirtualXProxy.cxx:222; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IParametricGradFunctionMultiDimTemplInterface (abstract class) for parametric gradient multi-dimensional functions providing in addition ...Definition IParamFunction.h:227; RO",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:1028,Integrability,interface,interface,1028,". ROOT: hist/hist/inc/Math/WrappedMultiTF1.h Source File. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. WrappedMultiTF1.h. Go to the documentation of this file. 1// @(#)root/mathmore:$Id$; 2// Author: L. Moneta Wed Sep 6 09:52:26 2006; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class WrappedTFunction; 12 ; 13#ifndef ROOT_Math_WrappedMultiTF1; 14#define ROOT_Math_WrappedMultiTF1; 15 ; 16 ; 17#include ""Math/IParamFunction.h""; 18 ; 19#include ""TF1.h""; 20#include <string>; 21#include <vector>; 22#include <algorithm>; 23 ; 24namespace ROOT {; 25 ; 26 namespace Math {; 27 ; 28 namespace Internal {; 29 double DerivPrecision(double eps);; 30 TF1 *CopyTF1Ptr(const TF1 *funcToCopy);; 31 };; 32 ; 33 /**; 34 Class to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface; 35 of multi-dimensions to be used in the ROOT::Math numerical algorithm.; 36 This wrapper class does not own the TF1 pointer, so it assumes it exists during the wrapper lifetime.; 37 The class copy the TF1 pointer only when it owns it.; 38 ; 39 The class from ROOT version 6.03 does not contain anymore a copy of the parameters. The parameters are; 40 stored in the TF1 class.; 41 ; 42 @ingroup CppFunctions; 43 */; 44 ; 45 //LM note: are there any issues when cloning the class for the parameters that are not copied anymore ??; 46 ; 47 template<class T>; 48 class WrappedMultiTF1Templ: virtual public ROOT::Math::IParametricGradFunctionMultiDimTempl<T> {; 49 ; 50 public:; 51 ; 52 typedef ROOT::Math::IParametricGradFunctionMultiDimTempl<T> BaseParamFunc;; 53 typedef typename ROOT::Math::IParametricFunctionMultiDimTempl<T>::BaseFunc BaseFunc;; 54 ; 55 /**; 56 constructor from a function pointer to a TF1; 57 If dim = 0 dimension is taken from TF1::GetNdim()",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:1121,Integrability,wrap,wrapper,1121,"the documentation of this file. 1// @(#)root/mathmore:$Id$; 2// Author: L. Moneta Wed Sep 6 09:52:26 2006; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class WrappedTFunction; 12 ; 13#ifndef ROOT_Math_WrappedMultiTF1; 14#define ROOT_Math_WrappedMultiTF1; 15 ; 16 ; 17#include ""Math/IParamFunction.h""; 18 ; 19#include ""TF1.h""; 20#include <string>; 21#include <vector>; 22#include <algorithm>; 23 ; 24namespace ROOT {; 25 ; 26 namespace Math {; 27 ; 28 namespace Internal {; 29 double DerivPrecision(double eps);; 30 TF1 *CopyTF1Ptr(const TF1 *funcToCopy);; 31 };; 32 ; 33 /**; 34 Class to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface; 35 of multi-dimensions to be used in the ROOT::Math numerical algorithm.; 36 This wrapper class does not own the TF1 pointer, so it assumes it exists during the wrapper lifetime.; 37 The class copy the TF1 pointer only when it owns it.; 38 ; 39 The class from ROOT version 6.03 does not contain anymore a copy of the parameters. The parameters are; 40 stored in the TF1 class.; 41 ; 42 @ingroup CppFunctions; 43 */; 44 ; 45 //LM note: are there any issues when cloning the class for the parameters that are not copied anymore ??; 46 ; 47 template<class T>; 48 class WrappedMultiTF1Templ: virtual public ROOT::Math::IParametricGradFunctionMultiDimTempl<T> {; 49 ; 50 public:; 51 ; 52 typedef ROOT::Math::IParametricGradFunctionMultiDimTempl<T> BaseParamFunc;; 53 typedef typename ROOT::Math::IParametricFunctionMultiDimTempl<T>::BaseFunc BaseFunc;; 54 ; 55 /**; 56 constructor from a function pointer to a TF1; 57 If dim = 0 dimension is taken from TF1::GetNdim().; 58 In case of multi-dimensional function created using directly TF1 object the dimension; 59 returned by TF1::GetNdim is always 1. The user must then pass the c",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:1200,Integrability,wrap,wrapper,1200,"the documentation of this file. 1// @(#)root/mathmore:$Id$; 2// Author: L. Moneta Wed Sep 6 09:52:26 2006; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Header file for class WrappedTFunction; 12 ; 13#ifndef ROOT_Math_WrappedMultiTF1; 14#define ROOT_Math_WrappedMultiTF1; 15 ; 16 ; 17#include ""Math/IParamFunction.h""; 18 ; 19#include ""TF1.h""; 20#include <string>; 21#include <vector>; 22#include <algorithm>; 23 ; 24namespace ROOT {; 25 ; 26 namespace Math {; 27 ; 28 namespace Internal {; 29 double DerivPrecision(double eps);; 30 TF1 *CopyTF1Ptr(const TF1 *funcToCopy);; 31 };; 32 ; 33 /**; 34 Class to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface; 35 of multi-dimensions to be used in the ROOT::Math numerical algorithm.; 36 This wrapper class does not own the TF1 pointer, so it assumes it exists during the wrapper lifetime.; 37 The class copy the TF1 pointer only when it owns it.; 38 ; 39 The class from ROOT version 6.03 does not contain anymore a copy of the parameters. The parameters are; 40 stored in the TF1 class.; 41 ; 42 @ingroup CppFunctions; 43 */; 44 ; 45 //LM note: are there any issues when cloning the class for the parameters that are not copied anymore ??; 46 ; 47 template<class T>; 48 class WrappedMultiTF1Templ: virtual public ROOT::Math::IParametricGradFunctionMultiDimTempl<T> {; 49 ; 50 public:; 51 ; 52 typedef ROOT::Math::IParametricGradFunctionMultiDimTempl<T> BaseParamFunc;; 53 typedef typename ROOT::Math::IParametricFunctionMultiDimTempl<T>::BaseFunc BaseFunc;; 54 ; 55 /**; 56 constructor from a function pointer to a TF1; 57 If dim = 0 dimension is taken from TF1::GetNdim().; 58 In case of multi-dimensional function created using directly TF1 object the dimension; 59 returned by TF1::GetNdim is always 1. The user must then pass the c",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:2660,Integrability,interface,interface,2660,"edef ROOT::Math::IParametricGradFunctionMultiDimTempl<T> BaseParamFunc;; 53 typedef typename ROOT::Math::IParametricFunctionMultiDimTempl<T>::BaseFunc BaseFunc;; 54 ; 55 /**; 56 constructor from a function pointer to a TF1; 57 If dim = 0 dimension is taken from TF1::GetNdim().; 58 In case of multi-dimensional function created using directly TF1 object the dimension; 59 returned by TF1::GetNdim is always 1. The user must then pass the correct value of dim; 60 */; 61 WrappedMultiTF1Templ(TF1 &f, unsigned int dim = 0);; 62 ; 63 /**; 64 Destructor (no operations). Function pointer is not owned; 65 */; 66 ~WrappedMultiTF1Templ() override; 67 {; 68 if (fOwnFunc && fFunc) delete fFunc;; 69 }; 70 ; 71 /**; 72 Copy constructor; 73 */; 74 WrappedMultiTF1Templ(const WrappedMultiTF1Templ<T> &rhs);; 75 ; 76 /**; 77 Assignment operator; 78 */; 79 WrappedMultiTF1Templ &operator = (const WrappedMultiTF1Templ<T> &rhs);; 80 ; 81 /** @name interface inherited from IParamFunction */; 82 ; 83 /**; 84 Clone the wrapper but not the original function; 85 */; 86 IMultiGenFunctionTempl<T> *Clone() const override; 87 {; 88 return new WrappedMultiTF1Templ<T>(*this);; 89 }; 90 ; 91 /**; 92 Retrieve the dimension of the function; 93 */; 94 unsigned int NDim() const override; 95 {; 96 return fDim;; 97 }; 98 ; 99 /// get the parameter values (return values from TF1); 100 const double *Parameters() const override; 101 {; 102 //return (fParams.size() > 0) ? &fParams.front() : 0;; 103 return fFunc->GetParameters();; 104 }; 105 ; 106 /// set parameter values (only the cached one in this class,leave unchanges those of TF1); 107 void SetParameters(const double *p) override; 108 {; 109 //std::copy(p,p+fParams.size(),fParams.begin());; 110 fFunc->SetParameters(p);; 111 }; 112 ; 113 /// return number of parameters; 114 unsigned int NPar() const override; 115 {; 116 // return fParams.size();; 117 return fFunc->GetNpar();; 118 }; 119 ; 120 /// return parameter name (from TF1); 121 std::string ParameterName(u",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:2730,Integrability,wrap,wrapper,2730,"edef ROOT::Math::IParametricGradFunctionMultiDimTempl<T> BaseParamFunc;; 53 typedef typename ROOT::Math::IParametricFunctionMultiDimTempl<T>::BaseFunc BaseFunc;; 54 ; 55 /**; 56 constructor from a function pointer to a TF1; 57 If dim = 0 dimension is taken from TF1::GetNdim().; 58 In case of multi-dimensional function created using directly TF1 object the dimension; 59 returned by TF1::GetNdim is always 1. The user must then pass the correct value of dim; 60 */; 61 WrappedMultiTF1Templ(TF1 &f, unsigned int dim = 0);; 62 ; 63 /**; 64 Destructor (no operations). Function pointer is not owned; 65 */; 66 ~WrappedMultiTF1Templ() override; 67 {; 68 if (fOwnFunc && fFunc) delete fFunc;; 69 }; 70 ; 71 /**; 72 Copy constructor; 73 */; 74 WrappedMultiTF1Templ(const WrappedMultiTF1Templ<T> &rhs);; 75 ; 76 /**; 77 Assignment operator; 78 */; 79 WrappedMultiTF1Templ &operator = (const WrappedMultiTF1Templ<T> &rhs);; 80 ; 81 /** @name interface inherited from IParamFunction */; 82 ; 83 /**; 84 Clone the wrapper but not the original function; 85 */; 86 IMultiGenFunctionTempl<T> *Clone() const override; 87 {; 88 return new WrappedMultiTF1Templ<T>(*this);; 89 }; 90 ; 91 /**; 92 Retrieve the dimension of the function; 93 */; 94 unsigned int NDim() const override; 95 {; 96 return fDim;; 97 }; 98 ; 99 /// get the parameter values (return values from TF1); 100 const double *Parameters() const override; 101 {; 102 //return (fParams.size() > 0) ? &fParams.front() : 0;; 103 return fFunc->GetParameters();; 104 }; 105 ; 106 /// set parameter values (only the cached one in this class,leave unchanges those of TF1); 107 void SetParameters(const double *p) override; 108 {; 109 //std::copy(p,p+fParams.size(),fParams.begin());; 110 fFunc->SetParameters(p);; 111 }; 112 ; 113 /// return number of parameters; 114 unsigned int NPar() const override; 115 {; 116 // return fParams.size();; 117 return fFunc->GetNpar();; 118 }; 119 ; 120 /// return parameter name (from TF1); 121 std::string ParameterName(u",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:7618,Integrability,wrap,wrappedFunc,7618,"ar in the case of a general linear function; 197 * built with TFormula using ++; as EvalPar is not vectorized, in order to generalize DoParameterDerivative with; 198 * a general type T, we use this auxiliar class to branch the code in compile time with the double; 199 * specialization (that can call EvalPar) and the general implementation (that throws an error in the case of; 200 * general linear function).; 201 */; 202 template <class T>; 203 struct GeneralLinearFunctionDerivation {; 204 static T DoParameterDerivative(const WrappedMultiTF1Templ<T> *, const T *, unsigned int); 205 {; 206 Error(""DoParameterDerivative"", ""The vectorized implementation of DoParameterDerivative does not support""; 207 ""general linear functions built in TFormula with ++"");; 208 ; 209 return TMath::SignalingNaN();; 210 }; 211 };; 212 ; 213 template <>; 214 struct GeneralLinearFunctionDerivation<double> {; 215 static double; 216 DoParameterDerivative(const WrappedMultiTF1Templ<double> *wrappedFunc, const double *x, unsigned int ipar); 217 {; 218 const TFormula *df = dynamic_cast<const TFormula *>(wrappedFunc->GetFunction()->GetLinearPart(ipar));; 219 assert(df != nullptr);; 220 return (const_cast<TFormula *>(df))->EvalPar(x); // derivatives should not depend on parameters since; 221 // function is linear; 222 }; 223 };; 224 ; 225 // implementations for WrappedMultiTF1Templ<T>; 226 template<class T>; 227 WrappedMultiTF1Templ<T>::WrappedMultiTF1Templ(TF1 &f, unsigned int dim) :; 228 fLinear(false),; 229 fPolynomial(false),; 230 fOwnFunc(false),; 231 fFunc(&f),; 232 fDim(dim); 233 //fParams(f.GetParameters(),f.GetParameters()+f.GetNpar()); 234 {; 235 // constructor of WrappedMultiTF1Templ<T>; 236 // pass a dimension if dimension specified in TF1 does not correspond to real dimension; 237 // for example in case of multi-dimensional TF1 objects defined as TF1 (i.e. for functions with dims > 3 ); 238 if (fDim == 0) fDim = fFunc->GetNdim();; 239 ; 240 // check that in case function is linear the lin",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:7731,Integrability,wrap,wrappedFunc,7731,"ar in the case of a general linear function; 197 * built with TFormula using ++; as EvalPar is not vectorized, in order to generalize DoParameterDerivative with; 198 * a general type T, we use this auxiliar class to branch the code in compile time with the double; 199 * specialization (that can call EvalPar) and the general implementation (that throws an error in the case of; 200 * general linear function).; 201 */; 202 template <class T>; 203 struct GeneralLinearFunctionDerivation {; 204 static T DoParameterDerivative(const WrappedMultiTF1Templ<T> *, const T *, unsigned int); 205 {; 206 Error(""DoParameterDerivative"", ""The vectorized implementation of DoParameterDerivative does not support""; 207 ""general linear functions built in TFormula with ++"");; 208 ; 209 return TMath::SignalingNaN();; 210 }; 211 };; 212 ; 213 template <>; 214 struct GeneralLinearFunctionDerivation<double> {; 215 static double; 216 DoParameterDerivative(const WrappedMultiTF1Templ<double> *wrappedFunc, const double *x, unsigned int ipar); 217 {; 218 const TFormula *df = dynamic_cast<const TFormula *>(wrappedFunc->GetFunction()->GetLinearPart(ipar));; 219 assert(df != nullptr);; 220 return (const_cast<TFormula *>(df))->EvalPar(x); // derivatives should not depend on parameters since; 221 // function is linear; 222 }; 223 };; 224 ; 225 // implementations for WrappedMultiTF1Templ<T>; 226 template<class T>; 227 WrappedMultiTF1Templ<T>::WrappedMultiTF1Templ(TF1 &f, unsigned int dim) :; 228 fLinear(false),; 229 fPolynomial(false),; 230 fOwnFunc(false),; 231 fFunc(&f),; 232 fDim(dim); 233 //fParams(f.GetParameters(),f.GetParameters()+f.GetNpar()); 234 {; 235 // constructor of WrappedMultiTF1Templ<T>; 236 // pass a dimension if dimension specified in TF1 does not correspond to real dimension; 237 // for example in case of multi-dimensional TF1 objects defined as TF1 (i.e. for functions with dims > 3 ); 238 if (fDim == 0) fDim = fFunc->GetNdim();; 239 ; 240 // check that in case function is linear the lin",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:7889,Integrability,depend,depend,7889,"ar in the case of a general linear function; 197 * built with TFormula using ++; as EvalPar is not vectorized, in order to generalize DoParameterDerivative with; 198 * a general type T, we use this auxiliar class to branch the code in compile time with the double; 199 * specialization (that can call EvalPar) and the general implementation (that throws an error in the case of; 200 * general linear function).; 201 */; 202 template <class T>; 203 struct GeneralLinearFunctionDerivation {; 204 static T DoParameterDerivative(const WrappedMultiTF1Templ<T> *, const T *, unsigned int); 205 {; 206 Error(""DoParameterDerivative"", ""The vectorized implementation of DoParameterDerivative does not support""; 207 ""general linear functions built in TFormula with ++"");; 208 ; 209 return TMath::SignalingNaN();; 210 }; 211 };; 212 ; 213 template <>; 214 struct GeneralLinearFunctionDerivation<double> {; 215 static double; 216 DoParameterDerivative(const WrappedMultiTF1Templ<double> *wrappedFunc, const double *x, unsigned int ipar); 217 {; 218 const TFormula *df = dynamic_cast<const TFormula *>(wrappedFunc->GetFunction()->GetLinearPart(ipar));; 219 assert(df != nullptr);; 220 return (const_cast<TFormula *>(df))->EvalPar(x); // derivatives should not depend on parameters since; 221 // function is linear; 222 }; 223 };; 224 ; 225 // implementations for WrappedMultiTF1Templ<T>; 226 template<class T>; 227 WrappedMultiTF1Templ<T>::WrappedMultiTF1Templ(TF1 &f, unsigned int dim) :; 228 fLinear(false),; 229 fPolynomial(false),; 230 fOwnFunc(false),; 231 fFunc(&f),; 232 fDim(dim); 233 //fParams(f.GetParameters(),f.GetParameters()+f.GetNpar()); 234 {; 235 // constructor of WrappedMultiTF1Templ<T>; 236 // pass a dimension if dimension specified in TF1 does not correspond to real dimension; 237 // for example in case of multi-dimensional TF1 objects defined as TF1 (i.e. for functions with dims > 3 ); 238 if (fDim == 0) fDim = fFunc->GetNdim();; 239 ; 240 // check that in case function is linear the lin",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:13146,Integrability,depend,dependency,13146,"or (unsigned int j = 0; j <= i; j++) {; 330 unsigned int ih = j + i *(i+1)/2; // formula for j <= i; 331 unsigned int im = i*np + j;; 332 h[ih] = h2[im];; 333 }; 334 }; 335 return true;; 336 }; 337 static bool IsAvailable(TF1 * func) {; 338 auto formula = func->GetFormula();; 339 if (!formula) return false;; 340 return formula->GenerateHessianPar();; 341 }; 342 };; 343 ; 344 ; 345 ; 346 template <class T>; 347 bool WrappedMultiTF1Templ<T>::ParameterHessian(const T *x, const double *par, T *h) const; 348 {; 349 if (fLinear) {; 350 std::fill(h, h + NPar()*(NPar()+1)/2, 0.0);; 351 return true;; 352 }; 353 return GeneralHessianCalc<T>::Hessian(fFunc, x, par, h);; 354 }; 355 ; 356 template <class T>; 357 bool WrappedMultiTF1Templ<T>::HasParameterHessian() const; 358 {; 359 return GeneralHessianCalc<T>::IsAvailable(fFunc);; 360 }; 361 ; 362 template <class T>; 363 T WrappedMultiTF1Templ<T>::DoParameterDerivative(const T *x, const double *p, unsigned int ipar) const; 364 {; 365 // evaluate the derivative of the function with respect to parameter ipar; 366 // see note above concerning the fixed parameters; 367 if (!fLinear) {; 368 fFunc->SetParameters(p);; 369 double prec = this->GetDerivPrecision();; 370 return fFunc->GradientPar(ipar, x, prec);; 371 }; 372 if (fPolynomial) {; 373 // case of polynomial function (no parameter dependency) (case for dim = 1); 374 assert(fDim == 1);; 375 if (ipar == 0) return 1.0;; 376#ifdef R__HAS_VECCORE; 377 return vecCore::math::Pow(x[0], static_cast<T>(ipar));; 378#else; 379 return std::pow(x[0], static_cast<int>(ipar));; 380#endif; 381 } else {; 382 // case of general linear function (built in TFormula with ++ ); 383 return GeneralLinearFunctionDerivation<T>::DoParameterDerivative(this, x, ipar);; 384 }; 385 }; 386 template<class T>; 387 void WrappedMultiTF1Templ<T>::SetDerivPrecision(double eps); 388 {; 389 ::ROOT::Math::Internal::DerivPrecision(eps);; 390 }; 391 ; 392 template<class T>; 393 double WrappedMultiTF1Templ<T>::GetDerivPreci",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:15597,Integrability,interface,interface,15597,"D h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; npOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t npDefinition TGWin32VirtualXProxy.cxx:222; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IParametricGradFunctionMultiDimTemplInterface (abstract class) for parametric gradient multi-dimensional functions providing in addition ...Definition IParamFunction.h:227; ROOT::Math::WrappedMultiTF1TemplClass to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions...Definition WrappedMultiTF1.h:48; ROOT::Math::WrappedMultiTF1Templ::SetAndCopyFunctionvoid SetAndCopyFunction(const TF1 *f=nullptr)method to set a new function pointer and copy it inside.Definition WrappedMultiTF1.h:399; ROOT::Math::WrappedMultiTF1Templ::fFuncTF1 * fFuncDefinition WrappedMultiTF1.h:187; ROOT::Math::WrappedMultiTF1Templ::DoParameterDerivativeT DoParameterDerivative(const T *x, const double *p, unsigned int ipar) const overrideevaluate the partial derivative with respect to the parameterDefinition WrappedMultiTF1.h:363; ROOT::Math::WrappedMultiTF1Templ::HasParameterHessianbool HasParameterHessian() const overrideDefinition WrappedMultiTF1.h:357; ROOT::Math::WrappedMultiTF1Templ::~WrappedMultiTF1Templ~WrappedMultiTF1Templ() overrideDestructor (no operations).Definition WrappedMultiTF1.h:66; ROOT::Math::WrappedMultiTF1Templ::fDimunsigned int fDimDefinition WrappedMultiTF1.h:188; ROOT::Math::WrappedMulti",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:18643,Integrability,wrap,wrapper,18643,"radFunctionMultiDimTempl< T > BaseParamFuncDefinition WrappedMultiTF1.h:52; ROOT::Math::WrappedMultiTF1Templ::operator=WrappedMultiTF1Templ & operator=(const WrappedMultiTF1Templ< T > &rhs)Assignment operator.Definition WrappedMultiTF1.h:273; ROOT::Math::WrappedMultiTF1Templ::fLinearbool fLinearDefinition WrappedMultiTF1.h:184; ROOT::Math::WrappedMultiTF1Templ::ParameterNamestd::string ParameterName(unsigned int i) const overridereturn parameter name (from TF1)Definition WrappedMultiTF1.h:121; ROOT::Math::WrappedMultiTF1Templ::GetFunctionconst TF1 * GetFunction() constmethod to retrieve the internal function pointerDefinition WrappedMultiTF1.h:147; ROOT::Math::WrappedMultiTF1Templ::NDimunsigned int NDim() const overrideRetrieve the dimension of the function.Definition WrappedMultiTF1.h:94; ROOT::Math::WrappedMultiTF1Templ::NParunsigned int NPar() const overridereturn number of parametersDefinition WrappedMultiTF1.h:114; ROOT::Math::WrappedMultiTF1Templ::CloneIMultiGenFunctionTempl< T > * Clone() const overrideClone the wrapper but not the original function.Definition WrappedMultiTF1.h:86; ROOT::Math::WrappedMultiTF1Templ::SetParametersvoid SetParameters(const double *p) overrideset parameter values (only the cached one in this class,leave unchanges those of TF1)Definition WrappedMultiTF1.h:107; ROOT::Math::WrappedMultiTF1Templ::ParameterGradientvoid ParameterGradient(const T *x, const double *par, T *grad) const overrideEvaluate the all the derivatives (gradient vector) of the function with respect to the parameters at ...Definition WrappedMultiTF1.h:286; ROOT::Math::WrappedMultiTF1Templ::fOwnFuncbool fOwnFuncDefinition WrappedMultiTF1.h:186; ROOT::Math::WrappedMultiTF1Templ::BaseFuncROOT::Math::IParametricFunctionMultiDimTempl< T >::BaseFunc BaseFuncDefinition WrappedMultiTF1.h:53; ROOT::Math::WrappedMultiTF1Templ::DoEvalVecT DoEvalVec(const T *x) constevaluate function using the cached parameter values (of TF1) re-implement for better efficiencyDefinition WrappedM",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:21428,Integrability,rout,routine,21428,"7; TF11-Dim function classDefinition TF1.h:233; TF1::GetNumbervirtual Int_t GetNumber() constDefinition TF1.h:526; TF1::GetNparvirtual Int_t GetNpar() constDefinition TF1.h:509; TF1::GetParametersvirtual Double_t * GetParameters() constDefinition TF1.h:548; TF1::GetFormulavirtual TFormula * GetFormula()Definition TF1.h:481; TF1::GetParNamevirtual const char * GetParName(Int_t ipar) constDefinition TF1.h:557; TF1::EvalParvirtual Double_t EvalPar(const Double_t *x, const Double_t *params=nullptr)Evaluate function with given coordinates and parameters.Definition TF1.cxx:1468; TF1::IsLinearvirtual Bool_t IsLinear() constDefinition TF1.h:630; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::GetNdimvirtual Int_t GetNdim() constDefinition TF1.h:513; TF1::GetLinearPartvirtual const TObject * GetLinearPart(Int_t i) constDefinition TF1.h:493; TFormulaThe Formula class.Definition TFormula.h:89; TFormula::GenerateHessianParbool GenerateHessianPar()Generate hessian computation routine with respect to the parameters.Definition TFormula.cxx:3256; double; xDouble_t x[n]Definition legend1.C:17; MathNamespace for new Math classes and functions.; ROOT::Math::Internal::DerivPrecisiondouble DerivPrecision(double eps)Definition WrappedTF1.cxx:25; ROOT::Math::Internal::CopyTF1PtrTF1 * CopyTF1Ptr(const TF1 *funcToCopy)Definition WrappedTF1.cxx:33; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMath::SignalingNaNDouble_t SignalingNaN()Returns a signaling NaN as defined by IEEE 754](http://en.wikipedia.org/wiki/NaN#Signaling_NaN).Definition TMath.h:910; ROOT::Math::GeneralHessianCalc< double >::IsAvailablestatic bool IsAvailable(TF1 *func)Definition WrappedMultiTF1.h:337; ROOT::Math::GeneralHessianCalc< double >::Hessianstatic bool Hessian(TF1 *func, const double *x, const double *par, double *h)Definition WrappedMultiTF1.h:319; ROOT::Math::GeneralHess",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:22833,Integrability,wrap,wrappedFunc,22833,"e hessian computation routine with respect to the parameters.Definition TFormula.cxx:3256; double; xDouble_t x[n]Definition legend1.C:17; MathNamespace for new Math classes and functions.; ROOT::Math::Internal::DerivPrecisiondouble DerivPrecision(double eps)Definition WrappedTF1.cxx:25; ROOT::Math::Internal::CopyTF1PtrTF1 * CopyTF1Ptr(const TF1 *funcToCopy)Definition WrappedTF1.cxx:33; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; TMath::SignalingNaNDouble_t SignalingNaN()Returns a signaling NaN as defined by IEEE 754](http://en.wikipedia.org/wiki/NaN#Signaling_NaN).Definition TMath.h:910; ROOT::Math::GeneralHessianCalc< double >::IsAvailablestatic bool IsAvailable(TF1 *func)Definition WrappedMultiTF1.h:337; ROOT::Math::GeneralHessianCalc< double >::Hessianstatic bool Hessian(TF1 *func, const double *x, const double *par, double *h)Definition WrappedMultiTF1.h:319; ROOT::Math::GeneralHessianCalcDefinition WrappedMultiTF1.h:308; ROOT::Math::GeneralHessianCalc::Hessianstatic bool Hessian(TF1 *, const T *, const double *, T *)Definition WrappedMultiTF1.h:309; ROOT::Math::GeneralHessianCalc::IsAvailablestatic bool IsAvailable(TF1 *)Definition WrappedMultiTF1.h:314; ROOT::Math::GeneralLinearFunctionDerivation< double >::DoParameterDerivativestatic double DoParameterDerivative(const WrappedMultiTF1Templ< double > *wrappedFunc, const double *x, unsigned int ipar)Definition WrappedMultiTF1.h:216; ROOT::Math::GeneralLinearFunctionDerivationAuxiliar class to bypass the (provisional) lack of vectorization in TFormula::EvalPar.Definition WrappedMultiTF1.h:203; ROOT::Math::GeneralLinearFunctionDerivation::DoParameterDerivativestatic T DoParameterDerivative(const WrappedMultiTF1Templ< T > *, const T *, unsigned int)Definition WrappedMultiTF1.h:204. histhistincMathWrappedMultiTF1.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:2670,Modifiability,inherit,inherited,2670,"edef ROOT::Math::IParametricGradFunctionMultiDimTempl<T> BaseParamFunc;; 53 typedef typename ROOT::Math::IParametricFunctionMultiDimTempl<T>::BaseFunc BaseFunc;; 54 ; 55 /**; 56 constructor from a function pointer to a TF1; 57 If dim = 0 dimension is taken from TF1::GetNdim().; 58 In case of multi-dimensional function created using directly TF1 object the dimension; 59 returned by TF1::GetNdim is always 1. The user must then pass the correct value of dim; 60 */; 61 WrappedMultiTF1Templ(TF1 &f, unsigned int dim = 0);; 62 ; 63 /**; 64 Destructor (no operations). Function pointer is not owned; 65 */; 66 ~WrappedMultiTF1Templ() override; 67 {; 68 if (fOwnFunc && fFunc) delete fFunc;; 69 }; 70 ; 71 /**; 72 Copy constructor; 73 */; 74 WrappedMultiTF1Templ(const WrappedMultiTF1Templ<T> &rhs);; 75 ; 76 /**; 77 Assignment operator; 78 */; 79 WrappedMultiTF1Templ &operator = (const WrappedMultiTF1Templ<T> &rhs);; 80 ; 81 /** @name interface inherited from IParamFunction */; 82 ; 83 /**; 84 Clone the wrapper but not the original function; 85 */; 86 IMultiGenFunctionTempl<T> *Clone() const override; 87 {; 88 return new WrappedMultiTF1Templ<T>(*this);; 89 }; 90 ; 91 /**; 92 Retrieve the dimension of the function; 93 */; 94 unsigned int NDim() const override; 95 {; 96 return fDim;; 97 }; 98 ; 99 /// get the parameter values (return values from TF1); 100 const double *Parameters() const override; 101 {; 102 //return (fParams.size() > 0) ? &fParams.front() : 0;; 103 return fFunc->GetParameters();; 104 }; 105 ; 106 /// set parameter values (only the cached one in this class,leave unchanges those of TF1); 107 void SetParameters(const double *p) override; 108 {; 109 //std::copy(p,p+fParams.size(),fParams.begin());; 110 fFunc->SetParameters(p);; 111 }; 112 ; 113 /// return number of parameters; 114 unsigned int NPar() const override; 115 {; 116 // return fParams.size();; 117 return fFunc->GetNpar();; 118 }; 119 ; 120 /// return parameter name (from TF1); 121 std::string ParameterName(u",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:3284,Performance,cache,cached,3284,"inter is not owned; 65 */; 66 ~WrappedMultiTF1Templ() override; 67 {; 68 if (fOwnFunc && fFunc) delete fFunc;; 69 }; 70 ; 71 /**; 72 Copy constructor; 73 */; 74 WrappedMultiTF1Templ(const WrappedMultiTF1Templ<T> &rhs);; 75 ; 76 /**; 77 Assignment operator; 78 */; 79 WrappedMultiTF1Templ &operator = (const WrappedMultiTF1Templ<T> &rhs);; 80 ; 81 /** @name interface inherited from IParamFunction */; 82 ; 83 /**; 84 Clone the wrapper but not the original function; 85 */; 86 IMultiGenFunctionTempl<T> *Clone() const override; 87 {; 88 return new WrappedMultiTF1Templ<T>(*this);; 89 }; 90 ; 91 /**; 92 Retrieve the dimension of the function; 93 */; 94 unsigned int NDim() const override; 95 {; 96 return fDim;; 97 }; 98 ; 99 /// get the parameter values (return values from TF1); 100 const double *Parameters() const override; 101 {; 102 //return (fParams.size() > 0) ? &fParams.front() : 0;; 103 return fFunc->GetParameters();; 104 }; 105 ; 106 /// set parameter values (only the cached one in this class,leave unchanges those of TF1); 107 void SetParameters(const double *p) override; 108 {; 109 //std::copy(p,p+fParams.size(),fParams.begin());; 110 fFunc->SetParameters(p);; 111 }; 112 ; 113 /// return number of parameters; 114 unsigned int NPar() const override; 115 {; 116 // return fParams.size();; 117 return fFunc->GetNpar();; 118 }; 119 ; 120 /// return parameter name (from TF1); 121 std::string ParameterName(unsigned int i) const override {; 122 return std::string(fFunc->GetParName(i));; 123 }; 124 ; 125 // evaluate the derivative of the function with respect to the parameters; 126 void ParameterGradient(const T *x, const double *par, T *grad) const override;; 127 ; 128 // evaluate the hessian of the function with respect to the parameters; 129 bool ParameterHessian(const T *x, const double *par, T *h) const override;; 130 ; 131 // return capability of computing parameter Hessian; 132 bool HasParameterHessian() const override;; 133 ; 134 // evaluate the 2nd derivatives of the f",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:5385,Performance,cache,cached,5385,"6 return false; // not yet implemented; 137 }; 138 ; 139 /// precision value used for calculating the derivative step-size; 140 /// h = eps * |x|. The default is 0.001, give a smaller in case function changes rapidly; 141 static void SetDerivPrecision(double eps);; 142 ; 143 /// get precision value used for calculating the derivative step-size; 144 static double GetDerivPrecision();; 145 ; 146 /// method to retrieve the internal function pointer; 147 const TF1 *GetFunction() const; 148 {; 149 return fFunc;; 150 }; 151 ; 152 /// method to set a new function pointer and copy it inside.; 153 /// By calling this method the class manages now the passed TF1 pointer; 154 void SetAndCopyFunction(const TF1 *f = nullptr);; 155 ; 156 private:; 157 /// evaluate function passing coordinates x and vector of parameters; 158 T DoEvalPar(const T *x, const double *p) const override; 159 {; 160 return fFunc->EvalPar(x, p);; 161 }; 162 ; 163 /// evaluate function using the cached parameter values (of TF1); 164 /// re-implement for better efficiency; 165 T DoEvalVec(const T *x) const; 166 {; 167 return fFunc->EvalPar(x, 0);; 168 }; 169 ; 170 /// evaluate function using the cached parameter values (of TF1); 171 /// re-implement for better efficiency; 172 T DoEval(const T *x) const override; 173 {; 174 // no need to call InitArg for interpreted functions (done in ctor); 175 ; 176 //const double * p = (fParams.size() > 0) ? &fParams.front() : 0;; 177 ; 178 return fFunc->EvalPar(x, nullptr);; 179 }; 180 ; 181 /// evaluate the partial derivative with respect to the parameter; 182 T DoParameterDerivative(const T *x, const double *p, unsigned int ipar) const override;; 183 ; 184 bool fLinear; // flag for linear functions; 185 bool fPolynomial; // flag for polynomial functions; 186 bool fOwnFunc; // flag to indicate we own the TF1 function pointer; 187 TF1 *fFunc; // pointer to ROOT function; 188 unsigned int fDim; // cached value of dimension; 189 //std::vector<double> fParams; // cached vecto",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:5588,Performance,cache,cached,5588,"6 return false; // not yet implemented; 137 }; 138 ; 139 /// precision value used for calculating the derivative step-size; 140 /// h = eps * |x|. The default is 0.001, give a smaller in case function changes rapidly; 141 static void SetDerivPrecision(double eps);; 142 ; 143 /// get precision value used for calculating the derivative step-size; 144 static double GetDerivPrecision();; 145 ; 146 /// method to retrieve the internal function pointer; 147 const TF1 *GetFunction() const; 148 {; 149 return fFunc;; 150 }; 151 ; 152 /// method to set a new function pointer and copy it inside.; 153 /// By calling this method the class manages now the passed TF1 pointer; 154 void SetAndCopyFunction(const TF1 *f = nullptr);; 155 ; 156 private:; 157 /// evaluate function passing coordinates x and vector of parameters; 158 T DoEvalPar(const T *x, const double *p) const override; 159 {; 160 return fFunc->EvalPar(x, p);; 161 }; 162 ; 163 /// evaluate function using the cached parameter values (of TF1); 164 /// re-implement for better efficiency; 165 T DoEvalVec(const T *x) const; 166 {; 167 return fFunc->EvalPar(x, 0);; 168 }; 169 ; 170 /// evaluate function using the cached parameter values (of TF1); 171 /// re-implement for better efficiency; 172 T DoEval(const T *x) const override; 173 {; 174 // no need to call InitArg for interpreted functions (done in ctor); 175 ; 176 //const double * p = (fParams.size() > 0) ? &fParams.front() : 0;; 177 ; 178 return fFunc->EvalPar(x, nullptr);; 179 }; 180 ; 181 /// evaluate the partial derivative with respect to the parameter; 182 T DoParameterDerivative(const T *x, const double *p, unsigned int ipar) const override;; 183 ; 184 bool fLinear; // flag for linear functions; 185 bool fPolynomial; // flag for polynomial functions; 186 bool fOwnFunc; // flag to indicate we own the TF1 function pointer; 187 TF1 *fFunc; // pointer to ROOT function; 188 unsigned int fDim; // cached value of dimension; 189 //std::vector<double> fParams; // cached vecto",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:6340,Performance,cache,cached,6340,"x and vector of parameters; 158 T DoEvalPar(const T *x, const double *p) const override; 159 {; 160 return fFunc->EvalPar(x, p);; 161 }; 162 ; 163 /// evaluate function using the cached parameter values (of TF1); 164 /// re-implement for better efficiency; 165 T DoEvalVec(const T *x) const; 166 {; 167 return fFunc->EvalPar(x, 0);; 168 }; 169 ; 170 /// evaluate function using the cached parameter values (of TF1); 171 /// re-implement for better efficiency; 172 T DoEval(const T *x) const override; 173 {; 174 // no need to call InitArg for interpreted functions (done in ctor); 175 ; 176 //const double * p = (fParams.size() > 0) ? &fParams.front() : 0;; 177 ; 178 return fFunc->EvalPar(x, nullptr);; 179 }; 180 ; 181 /// evaluate the partial derivative with respect to the parameter; 182 T DoParameterDerivative(const T *x, const double *p, unsigned int ipar) const override;; 183 ; 184 bool fLinear; // flag for linear functions; 185 bool fPolynomial; // flag for polynomial functions; 186 bool fOwnFunc; // flag to indicate we own the TF1 function pointer; 187 TF1 *fFunc; // pointer to ROOT function; 188 unsigned int fDim; // cached value of dimension; 189 //std::vector<double> fParams; // cached vector with parameter values; 190 ; 191 };; 192 ; 193 /**; 194 * Auxiliar class to bypass the (provisional) lack of vectorization in TFormula::EvalPar.; 195 *; 196 * WrappedMultiTF1Templ::DoParameterDerivation calls TFormula::EvalPar in the case of a general linear function; 197 * built with TFormula using ++; as EvalPar is not vectorized, in order to generalize DoParameterDerivative with; 198 * a general type T, we use this auxiliar class to branch the code in compile time with the double; 199 * specialization (that can call EvalPar) and the general implementation (that throws an error in the case of; 200 * general linear function).; 201 */; 202 template <class T>; 203 struct GeneralLinearFunctionDerivation {; 204 static T DoParameterDerivative(const WrappedMultiTF1Templ<T> *, const ",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:6405,Performance,cache,cached,6405,"x and vector of parameters; 158 T DoEvalPar(const T *x, const double *p) const override; 159 {; 160 return fFunc->EvalPar(x, p);; 161 }; 162 ; 163 /// evaluate function using the cached parameter values (of TF1); 164 /// re-implement for better efficiency; 165 T DoEvalVec(const T *x) const; 166 {; 167 return fFunc->EvalPar(x, 0);; 168 }; 169 ; 170 /// evaluate function using the cached parameter values (of TF1); 171 /// re-implement for better efficiency; 172 T DoEval(const T *x) const override; 173 {; 174 // no need to call InitArg for interpreted functions (done in ctor); 175 ; 176 //const double * p = (fParams.size() > 0) ? &fParams.front() : 0;; 177 ; 178 return fFunc->EvalPar(x, nullptr);; 179 }; 180 ; 181 /// evaluate the partial derivative with respect to the parameter; 182 T DoParameterDerivative(const T *x, const double *p, unsigned int ipar) const override;; 183 ; 184 bool fLinear; // flag for linear functions; 185 bool fPolynomial; // flag for polynomial functions; 186 bool fOwnFunc; // flag to indicate we own the TF1 function pointer; 187 TF1 *fFunc; // pointer to ROOT function; 188 unsigned int fDim; // cached value of dimension; 189 //std::vector<double> fParams; // cached vector with parameter values; 190 ; 191 };; 192 ; 193 /**; 194 * Auxiliar class to bypass the (provisional) lack of vectorization in TFormula::EvalPar.; 195 *; 196 * WrappedMultiTF1Templ::DoParameterDerivation calls TFormula::EvalPar in the case of a general linear function; 197 * built with TFormula using ++; as EvalPar is not vectorized, in order to generalize DoParameterDerivative with; 198 * a general type T, we use this auxiliar class to branch the code in compile time with the double; 199 * specialization (that can call EvalPar) and the general implementation (that throws an error in the case of; 200 * general linear function).; 201 */; 202 template <class T>; 203 struct GeneralLinearFunctionDerivation {; 204 static T DoParameterDerivative(const WrappedMultiTF1Templ<T> *, const ",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:16805,Performance,cache,cached,16805,"nd copy it inside.Definition WrappedMultiTF1.h:399; ROOT::Math::WrappedMultiTF1Templ::fFuncTF1 * fFuncDefinition WrappedMultiTF1.h:187; ROOT::Math::WrappedMultiTF1Templ::DoParameterDerivativeT DoParameterDerivative(const T *x, const double *p, unsigned int ipar) const overrideevaluate the partial derivative with respect to the parameterDefinition WrappedMultiTF1.h:363; ROOT::Math::WrappedMultiTF1Templ::HasParameterHessianbool HasParameterHessian() const overrideDefinition WrappedMultiTF1.h:357; ROOT::Math::WrappedMultiTF1Templ::~WrappedMultiTF1Templ~WrappedMultiTF1Templ() overrideDestructor (no operations).Definition WrappedMultiTF1.h:66; ROOT::Math::WrappedMultiTF1Templ::fDimunsigned int fDimDefinition WrappedMultiTF1.h:188; ROOT::Math::WrappedMultiTF1Templ::Parametersconst double * Parameters() const overrideget the parameter values (return values from TF1)Definition WrappedMultiTF1.h:100; ROOT::Math::WrappedMultiTF1Templ::DoEvalT DoEval(const T *x) const overrideevaluate function using the cached parameter values (of TF1) re-implement for better efficiencyDefinition WrappedMultiTF1.h:172; ROOT::Math::WrappedMultiTF1Templ::ParameterG2bool ParameterG2(const T *, const double *, T *) const overrideEvaluate all the second derivatives (diagonal ones) of the function with respect to the parameters at...Definition WrappedMultiTF1.h:135; ROOT::Math::WrappedMultiTF1Templ::SetDerivPrecisionstatic void SetDerivPrecision(double eps)precision value used for calculating the derivative step-size h = eps * |x|.Definition WrappedMultiTF1.h:387; ROOT::Math::WrappedMultiTF1Templ::GetDerivPrecisionstatic double GetDerivPrecision()get precision value used for calculating the derivative step-sizeDefinition WrappedMultiTF1.h:393; ROOT::Math::WrappedMultiTF1Templ::BaseParamFuncROOT::Math::IParametricGradFunctionMultiDimTempl< T > BaseParamFuncDefinition WrappedMultiTF1.h:52; ROOT::Math::WrappedMultiTF1Templ::operator=WrappedMultiTF1Templ & operator=(const WrappedMultiTF1Templ< T > &rhs)",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:18836,Performance,cache,cached,18836,"ator.Definition WrappedMultiTF1.h:273; ROOT::Math::WrappedMultiTF1Templ::fLinearbool fLinearDefinition WrappedMultiTF1.h:184; ROOT::Math::WrappedMultiTF1Templ::ParameterNamestd::string ParameterName(unsigned int i) const overridereturn parameter name (from TF1)Definition WrappedMultiTF1.h:121; ROOT::Math::WrappedMultiTF1Templ::GetFunctionconst TF1 * GetFunction() constmethod to retrieve the internal function pointerDefinition WrappedMultiTF1.h:147; ROOT::Math::WrappedMultiTF1Templ::NDimunsigned int NDim() const overrideRetrieve the dimension of the function.Definition WrappedMultiTF1.h:94; ROOT::Math::WrappedMultiTF1Templ::NParunsigned int NPar() const overridereturn number of parametersDefinition WrappedMultiTF1.h:114; ROOT::Math::WrappedMultiTF1Templ::CloneIMultiGenFunctionTempl< T > * Clone() const overrideClone the wrapper but not the original function.Definition WrappedMultiTF1.h:86; ROOT::Math::WrappedMultiTF1Templ::SetParametersvoid SetParameters(const double *p) overrideset parameter values (only the cached one in this class,leave unchanges those of TF1)Definition WrappedMultiTF1.h:107; ROOT::Math::WrappedMultiTF1Templ::ParameterGradientvoid ParameterGradient(const T *x, const double *par, T *grad) const overrideEvaluate the all the derivatives (gradient vector) of the function with respect to the parameters at ...Definition WrappedMultiTF1.h:286; ROOT::Math::WrappedMultiTF1Templ::fOwnFuncbool fOwnFuncDefinition WrappedMultiTF1.h:186; ROOT::Math::WrappedMultiTF1Templ::BaseFuncROOT::Math::IParametricFunctionMultiDimTempl< T >::BaseFunc BaseFuncDefinition WrappedMultiTF1.h:53; ROOT::Math::WrappedMultiTF1Templ::DoEvalVecT DoEvalVec(const T *x) constevaluate function using the cached parameter values (of TF1) re-implement for better efficiencyDefinition WrappedMultiTF1.h:165; ROOT::Math::WrappedMultiTF1Templ::fPolynomialbool fPolynomialDefinition WrappedMultiTF1.h:185; ROOT::Math::WrappedMultiTF1Templ::DoEvalParT DoEvalPar(const T *x, const double *p) const overr",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:19522,Performance,cache,cached,19522,"on WrappedMultiTF1.h:114; ROOT::Math::WrappedMultiTF1Templ::CloneIMultiGenFunctionTempl< T > * Clone() const overrideClone the wrapper but not the original function.Definition WrappedMultiTF1.h:86; ROOT::Math::WrappedMultiTF1Templ::SetParametersvoid SetParameters(const double *p) overrideset parameter values (only the cached one in this class,leave unchanges those of TF1)Definition WrappedMultiTF1.h:107; ROOT::Math::WrappedMultiTF1Templ::ParameterGradientvoid ParameterGradient(const T *x, const double *par, T *grad) const overrideEvaluate the all the derivatives (gradient vector) of the function with respect to the parameters at ...Definition WrappedMultiTF1.h:286; ROOT::Math::WrappedMultiTF1Templ::fOwnFuncbool fOwnFuncDefinition WrappedMultiTF1.h:186; ROOT::Math::WrappedMultiTF1Templ::BaseFuncROOT::Math::IParametricFunctionMultiDimTempl< T >::BaseFunc BaseFuncDefinition WrappedMultiTF1.h:53; ROOT::Math::WrappedMultiTF1Templ::DoEvalVecT DoEvalVec(const T *x) constevaluate function using the cached parameter values (of TF1) re-implement for better efficiencyDefinition WrappedMultiTF1.h:165; ROOT::Math::WrappedMultiTF1Templ::fPolynomialbool fPolynomialDefinition WrappedMultiTF1.h:185; ROOT::Math::WrappedMultiTF1Templ::DoEvalParT DoEvalPar(const T *x, const double *p) const overrideevaluate function passing coordinates x and vector of parametersDefinition WrappedMultiTF1.h:158; ROOT::Math::WrappedMultiTF1Templ::WrappedMultiTF1TemplWrappedMultiTF1Templ(TF1 &f, unsigned int dim=0)constructor from a function pointer to a TF1 If dim = 0 dimension is taken from TF1::GetNdim().Definition WrappedMultiTF1.h:227; ROOT::Math::WrappedMultiTF1Templ::ParameterHessianbool ParameterHessian(const T *x, const double *par, T *h) const overrideEvaluate the all the Hessian (second derivatives matrix) of the function with respect to the paramete...Definition WrappedMultiTF1.h:347; TF11-Dim function classDefinition TF1.h:233; TF1::GetNumbervirtual Int_t GetNumber() constDefinition TF1.h:526",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:10269,Safety,avoid,avoid,10269,"rue;; 255 }; 256 }; 257 ; 258 template<class T>; 259 WrappedMultiTF1Templ<T>::WrappedMultiTF1Templ(const WrappedMultiTF1Templ<T> &rhs) :; 260 BaseParamFunc(rhs),; 261 fLinear(rhs.fLinear),; 262 fPolynomial(rhs.fPolynomial),; 263 fOwnFunc(rhs.fOwnFunc),; 264 fFunc(rhs.fFunc),; 265 fDim(rhs.fDim); 266 //fParams(rhs.fParams); 267 {; 268 // copy constructor; 269 if (fOwnFunc) SetAndCopyFunction(rhs.fFunc);; 270 }; 271 ; 272 template<class T>; 273 WrappedMultiTF1Templ<T> &WrappedMultiTF1Templ<T>::operator= (const WrappedMultiTF1Templ<T> &rhs); 274 {; 275 // Assignment operator; 276 if (this == &rhs) return *this; // time saving self-test; 277 fLinear = rhs.fLinear;; 278 fPolynomial = rhs.fPolynomial;; 279 fOwnFunc = rhs.fOwnFunc;; 280 fDim = rhs.fDim;; 281 //fParams = rhs.fParams;; 282 return *this;; 283 }; 284 ; 285 template <class T>; 286 void WrappedMultiTF1Templ<T>::ParameterGradient(const T *x, const double *par, T *grad) const; 287 {; 288 // evaluate the gradient of the function with respect to the parameters; 289 //IMPORTANT NOTE: TF1::GradientPar returns 0 for fixed parameters to avoid computing useless derivatives; 290 // BUT the TLinearFitter wants to have the derivatives also for fixed parameters.; 291 // so in case of fLinear (or fPolynomial) a non-zero value will be returned for fixed parameters; 292 ; 293 if (!fLinear) {; 294 // need to set parameter values; 295 fFunc->SetParameters(par);; 296 // no need to call InitArgs (it is called in TF1::GradientPar); 297 double prec = this->GetDerivPrecision();; 298 fFunc->GradientPar(x, grad, prec);; 299 } else { // case of linear functions; 300 unsigned int np = NPar();; 301 for (unsigned int i = 0; i < np; ++i); 302 grad[i] = DoParameterDerivative(x, par, i);; 303 }; 304 }; 305 ; 306 // struct for dealing of generic Hessian computation, since it is available only in TFormula; 307 template <class T>; 308 struct GeneralHessianCalc {; 309 static bool Hessian(TF1 *, const T *, const double *, T *); 310 {; 311 Error(""He",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:7786,Testability,assert,assert,7786,"ar in the case of a general linear function; 197 * built with TFormula using ++; as EvalPar is not vectorized, in order to generalize DoParameterDerivative with; 198 * a general type T, we use this auxiliar class to branch the code in compile time with the double; 199 * specialization (that can call EvalPar) and the general implementation (that throws an error in the case of; 200 * general linear function).; 201 */; 202 template <class T>; 203 struct GeneralLinearFunctionDerivation {; 204 static T DoParameterDerivative(const WrappedMultiTF1Templ<T> *, const T *, unsigned int); 205 {; 206 Error(""DoParameterDerivative"", ""The vectorized implementation of DoParameterDerivative does not support""; 207 ""general linear functions built in TFormula with ++"");; 208 ; 209 return TMath::SignalingNaN();; 210 }; 211 };; 212 ; 213 template <>; 214 struct GeneralLinearFunctionDerivation<double> {; 215 static double; 216 DoParameterDerivative(const WrappedMultiTF1Templ<double> *wrappedFunc, const double *x, unsigned int ipar); 217 {; 218 const TFormula *df = dynamic_cast<const TFormula *>(wrappedFunc->GetFunction()->GetLinearPart(ipar));; 219 assert(df != nullptr);; 220 return (const_cast<TFormula *>(df))->EvalPar(x); // derivatives should not depend on parameters since; 221 // function is linear; 222 }; 223 };; 224 ; 225 // implementations for WrappedMultiTF1Templ<T>; 226 template<class T>; 227 WrappedMultiTF1Templ<T>::WrappedMultiTF1Templ(TF1 &f, unsigned int dim) :; 228 fLinear(false),; 229 fPolynomial(false),; 230 fOwnFunc(false),; 231 fFunc(&f),; 232 fDim(dim); 233 //fParams(f.GetParameters(),f.GetParameters()+f.GetNpar()); 234 {; 235 // constructor of WrappedMultiTF1Templ<T>; 236 // pass a dimension if dimension specified in TF1 does not correspond to real dimension; 237 // for example in case of multi-dimensional TF1 objects defined as TF1 (i.e. for functions with dims > 3 ); 238 if (fDim == 0) fDim = fFunc->GetNdim();; 239 ; 240 // check that in case function is linear the lin",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:9805,Testability,test,test,9805," is a TFormula created with ""++""; 242 // hyperplane are not yet existing in TFormula; 243 if (fFunc->IsLinear()) {; 244 int ip = 0;; 245 fLinear = true;; 246 while (fLinear && ip < fFunc->GetNpar()) {; 247 fLinear &= (fFunc->GetLinearPart(ip) != nullptr);; 248 ip++;; 249 }; 250 }; 251 // distinguish case of polynomial functions and linear functions; 252 if (fDim == 1 && fFunc->GetNumber() >= 300 && fFunc->GetNumber() < 310) {; 253 fLinear = true;; 254 fPolynomial = true;; 255 }; 256 }; 257 ; 258 template<class T>; 259 WrappedMultiTF1Templ<T>::WrappedMultiTF1Templ(const WrappedMultiTF1Templ<T> &rhs) :; 260 BaseParamFunc(rhs),; 261 fLinear(rhs.fLinear),; 262 fPolynomial(rhs.fPolynomial),; 263 fOwnFunc(rhs.fOwnFunc),; 264 fFunc(rhs.fFunc),; 265 fDim(rhs.fDim); 266 //fParams(rhs.fParams); 267 {; 268 // copy constructor; 269 if (fOwnFunc) SetAndCopyFunction(rhs.fFunc);; 270 }; 271 ; 272 template<class T>; 273 WrappedMultiTF1Templ<T> &WrappedMultiTF1Templ<T>::operator= (const WrappedMultiTF1Templ<T> &rhs); 274 {; 275 // Assignment operator; 276 if (this == &rhs) return *this; // time saving self-test; 277 fLinear = rhs.fLinear;; 278 fPolynomial = rhs.fPolynomial;; 279 fOwnFunc = rhs.fOwnFunc;; 280 fDim = rhs.fDim;; 281 //fParams = rhs.fParams;; 282 return *this;; 283 }; 284 ; 285 template <class T>; 286 void WrappedMultiTF1Templ<T>::ParameterGradient(const T *x, const double *par, T *grad) const; 287 {; 288 // evaluate the gradient of the function with respect to the parameters; 289 //IMPORTANT NOTE: TF1::GradientPar returns 0 for fixed parameters to avoid computing useless derivatives; 290 // BUT the TLinearFitter wants to have the derivatives also for fixed parameters.; 291 // so in case of fLinear (or fPolynomial) a non-zero value will be returned for fixed parameters; 292 ; 293 if (!fLinear) {; 294 // need to set parameter values; 295 fFunc->SetParameters(par);; 296 // no need to call InitArgs (it is called in TF1::GradientPar); 297 double prec = this->GetDerivPrecisi",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedMultiTF1_8h_source.html:13182,Testability,assert,assert,13182,"or (unsigned int j = 0; j <= i; j++) {; 330 unsigned int ih = j + i *(i+1)/2; // formula for j <= i; 331 unsigned int im = i*np + j;; 332 h[ih] = h2[im];; 333 }; 334 }; 335 return true;; 336 }; 337 static bool IsAvailable(TF1 * func) {; 338 auto formula = func->GetFormula();; 339 if (!formula) return false;; 340 return formula->GenerateHessianPar();; 341 }; 342 };; 343 ; 344 ; 345 ; 346 template <class T>; 347 bool WrappedMultiTF1Templ<T>::ParameterHessian(const T *x, const double *par, T *h) const; 348 {; 349 if (fLinear) {; 350 std::fill(h, h + NPar()*(NPar()+1)/2, 0.0);; 351 return true;; 352 }; 353 return GeneralHessianCalc<T>::Hessian(fFunc, x, par, h);; 354 }; 355 ; 356 template <class T>; 357 bool WrappedMultiTF1Templ<T>::HasParameterHessian() const; 358 {; 359 return GeneralHessianCalc<T>::IsAvailable(fFunc);; 360 }; 361 ; 362 template <class T>; 363 T WrappedMultiTF1Templ<T>::DoParameterDerivative(const T *x, const double *p, unsigned int ipar) const; 364 {; 365 // evaluate the derivative of the function with respect to parameter ipar; 366 // see note above concerning the fixed parameters; 367 if (!fLinear) {; 368 fFunc->SetParameters(p);; 369 double prec = this->GetDerivPrecision();; 370 return fFunc->GradientPar(ipar, x, prec);; 371 }; 372 if (fPolynomial) {; 373 // case of polynomial function (no parameter dependency) (case for dim = 1); 374 assert(fDim == 1);; 375 if (ipar == 0) return 1.0;; 376#ifdef R__HAS_VECCORE; 377 return vecCore::math::Pow(x[0], static_cast<T>(ipar));; 378#else; 379 return std::pow(x[0], static_cast<int>(ipar));; 380#endif; 381 } else {; 382 // case of general linear function (built in TFormula with ++ ); 383 return GeneralLinearFunctionDerivation<T>::DoParameterDerivative(this, x, ipar);; 384 }; 385 }; 386 template<class T>; 387 void WrappedMultiTF1Templ<T>::SetDerivPrecision(double eps); 388 {; 389 ::ROOT::Math::Internal::DerivPrecision(eps);; 390 }; 391 ; 392 template<class T>; 393 double WrappedMultiTF1Templ<T>::GetDerivPreci",MatchSource.WIKI,doc/master/WrappedMultiTF1_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedMultiTF1_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:7144,Energy Efficiency,efficient,efficient,7144," 173 DoInit();; 174 }; 175 ; 176 /// clone the function; 177 IMultiGenFunction * Clone() const override {; 178 return new WrappedParamFunctionGen(fFunc, fDim, fParams.size(), fParams.empty() ? nullptr : &fParams.front(), fParIndices.empty() ? nullptr : &fParIndices.front());; 179 }; 180 ; 181private:; 182 // copy ctor; 183 WrappedParamFunctionGen(const WrappedParamFunctionGen &) = delete; // not implemented; 184 WrappedParamFunctionGen & operator=(const WrappedParamFunctionGen &) = delete; // not implemented; 185 ; 186public:; 187 ; 188 const double * Parameters() const override {; 189 return fParams.empty() ? nullptr : &fParams.front();; 190 }; 191 ; 192 void SetParameters(const double * p) override {; 193 unsigned int npar = NPar();; 194 std::copy(p, p+ npar, fParams.begin() );; 195 SetParValues(npar, p);; 196 }; 197 ; 198 unsigned int NPar() const override { return fParams.size(); }; 199 ; 200 unsigned int NDim() const override { return fDim; }; 201 ; 202// // re-implement this since is more efficient; 203// double operator() (const double * x, const double * p) {; 204// unsigned int n = fX.size();; 205// unsigned int npar = fParams.size();; 206// unsigned j = 0;; 207// return (*fFunc)( fX);; 208// }; 209 ; 210private:; 211 ; 212 /// evaluate the function (re-implement for being more efficient); 213 double DoEval(const double * x) const override {; 214 ; 215// std::cout << this << fDim << "" x : "";; 216// std::ostream_iterator<double> oix(std::cout,"" , "");; 217// std::copy(x, x+fDim, oix);; 218// std::cout << std::endl;; 219// std::cout << ""npar "" << npar << std::endl;; 220// std::cout << fVarIndices.size() << std::endl;; 221// assert ( fVarIndices.size() == fDim); // otherwise something is wrong; 222 ; 223 for (unsigned int i = 0; i < fDim; ++i) {; 224 unsigned int j = fVarIndices[i];; 225 assert ( j < NPar() + fDim);; 226 fX[ j ] = x[i];; 227 }; 228// std::cout << ""X : ("";; 229// std::ostream_iterator<double> oi(std::cout,"" , "");; 230// std::copy(fX.begin(), fX.",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:7442,Energy Efficiency,efficient,efficient,7442,"// not implemented; 184 WrappedParamFunctionGen & operator=(const WrappedParamFunctionGen &) = delete; // not implemented; 185 ; 186public:; 187 ; 188 const double * Parameters() const override {; 189 return fParams.empty() ? nullptr : &fParams.front();; 190 }; 191 ; 192 void SetParameters(const double * p) override {; 193 unsigned int npar = NPar();; 194 std::copy(p, p+ npar, fParams.begin() );; 195 SetParValues(npar, p);; 196 }; 197 ; 198 unsigned int NPar() const override { return fParams.size(); }; 199 ; 200 unsigned int NDim() const override { return fDim; }; 201 ; 202// // re-implement this since is more efficient; 203// double operator() (const double * x, const double * p) {; 204// unsigned int n = fX.size();; 205// unsigned int npar = fParams.size();; 206// unsigned j = 0;; 207// return (*fFunc)( fX);; 208// }; 209 ; 210private:; 211 ; 212 /// evaluate the function (re-implement for being more efficient); 213 double DoEval(const double * x) const override {; 214 ; 215// std::cout << this << fDim << "" x : "";; 216// std::ostream_iterator<double> oix(std::cout,"" , "");; 217// std::copy(x, x+fDim, oix);; 218// std::cout << std::endl;; 219// std::cout << ""npar "" << npar << std::endl;; 220// std::cout << fVarIndices.size() << std::endl;; 221// assert ( fVarIndices.size() == fDim); // otherwise something is wrong; 222 ; 223 for (unsigned int i = 0; i < fDim; ++i) {; 224 unsigned int j = fVarIndices[i];; 225 assert ( j < NPar() + fDim);; 226 fX[ j ] = x[i];; 227 }; 228// std::cout << ""X : ("";; 229// std::ostream_iterator<double> oi(std::cout,"" , "");; 230// std::copy(fX.begin(), fX.end(), oi);; 231// std::cout << std::endl;; 232 ; 233 return (*fFunc)( fX.empty() ? nullptr : &fX.front() );; 234 }; 235 ; 236 ; 237 /**; 238 implement the required IParamFunction interface; 239 */; 240 double DoEvalPar(const double * x, const double * p ) const override {; 241 SetParValues(NPar(), p);; 242 return DoEval(x);; 243 }; 244 ; 245 ; 246 void DoInit() {; 247 // calculate variabl",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:10996,Energy Efficiency,efficient,efficient,10996,"287 }; 288 ; 289 ; 290 mutable FuncPtr fFunc;; 291 unsigned int fDim;; 292 std::vector<double> fParams;; 293 std::vector<unsigned int> fVarIndices;; 294 std::vector<unsigned int> fParIndices;; 295 mutable std::vector<double> fX;; 296 ; 297 ; 298 ; 299};; 300 ; 301 ; 302 } // end namespace Math; 303 ; 304} // end namespace ROOT; 305 ; 306 ; 307#endif /* ROOT_Math_WrappedParamFunction */; IParamFunction.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IParametricFunctionMultiDimTempl< double >; ROOT::Math::WrappedParamFunctionGenWrappedParamGenFunction class to wrap any multi-dimensional function implementing the operator()(cons...Definition WrappedParamFunction.h:143; ROOT::Math::WrappedParamFunctionGen::operator=WrappedParamFunctionGen & operator=(const WrappedParamFunctionGen &)=delete; ROOT::Math::WrappedParamFunctionGen::DoEvaldouble DoEval(const double *x) const overrideevaluate the function (re-implement for being more efficient)Definition WrappedParamFunction.h:213; ROOT::Math::WrappedParamFunctionGen::WrappedParamFunctionGenWrappedParamFunctionGen(const WrappedParamFunctionGen &)=delete; ROOT::Math::WrappedParamFunctionGen::WrappedParamFunctionGenWrappedParamFunctionGen(const FuncPtr &func, unsigned int dim, unsigned int npar, const double *par, const unsigned int *idx)Constructor a wrapped function from a pointer to a generic callable object implementation operator()(...Definition WrappedParamFunction.h:152; ROOT::Math::WrappedParamFunctionGen::NDimunsigned int NDim() const overrideRetrieve the dimension of the function.Definition WrappedParamFunction.h:200; ROOT::Math::WrappedParamFunctionGen::SetParValuesvoid SetParValues(unsigned int npar, const double *p) constDefinition WrappedParamFunction.h:281; ROOT::Math::WrappedParamFunctionGen::SetParametersvoid SetParameters(const double *p)",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:1101,Integrability,wrap,wrap,1101,"5 * *; 6 * Copyright (c) 2006 CERN *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 * *; 12 **********************************************************************/; 13 ; 14// Header file for class WrappedParamFunction; 15 ; 16#ifndef ROOT_Math_WrappedParamFunction; 17#define ROOT_Math_WrappedParamFunction; 18 ; 19#include ""Math/IParamFunction.h""; 20 ; 21//#include <iostream>; 22//#include <iterator>; 23 ; 24#include <vector>; 25 ; 26 ; 27namespace ROOT {; 28 ; 29 namespace Math {; 30 ; 31 ; 32typedef double( * FreeParamMultiFunctionPtr ) (const double *, const double * );; 33 ; 34/**; 35 WrappedParamFunction class to wrap any multi-dimensional function object; 36 implementing the operator()(const double * x, const double * p); 37 in an interface-like IParamFunction with a vector storing and caching internally the; 38 parameter values; 39 ; 40 @ingroup ParamFunc; 41 ; 42*/; 43template< typename FuncPtr = FreeParamMultiFunctionPtr >; 44class WrappedParamFunction : public IParamMultiFunction {; 45 ; 46public:; 47 ; 48 /**; 49 Constructor a wrapped function from a pointer to a callable object, the function dimension and number of parameters; 50 which are set to zero by default; 51 */; 52 WrappedParamFunction (FuncPtr func, unsigned int dim = 1, unsigned int npar = 0, double * par = nullptr) :; 53 fFunc(func),; 54 fDim(dim),; 55 fParams(std::vector<double>(npar) ); 56 {; 57 if (par) std::copy(par, par+npar, fParams.begin());; 58 }; 59 ; 60// /**; 61// Constructor a wrapped function from a non-const pointer to a callable object, the function dimension and number of parameters; 62// which are set to zero by default; 63// This constructor is needed in the case FuncPtr is a std::unique_ptr which has a copy ctor taking non const objects; 64// */; 65// WrappedParamFunction (FuncPtr & func, unsigned int dim = 1, unsigned int npar = 0, double * par = 0) :; 66// fFunc(fun",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:1222,Integrability,interface,interface-like,1222,"5 * *; 6 * Copyright (c) 2006 CERN *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 * *; 12 **********************************************************************/; 13 ; 14// Header file for class WrappedParamFunction; 15 ; 16#ifndef ROOT_Math_WrappedParamFunction; 17#define ROOT_Math_WrappedParamFunction; 18 ; 19#include ""Math/IParamFunction.h""; 20 ; 21//#include <iostream>; 22//#include <iterator>; 23 ; 24#include <vector>; 25 ; 26 ; 27namespace ROOT {; 28 ; 29 namespace Math {; 30 ; 31 ; 32typedef double( * FreeParamMultiFunctionPtr ) (const double *, const double * );; 33 ; 34/**; 35 WrappedParamFunction class to wrap any multi-dimensional function object; 36 implementing the operator()(const double * x, const double * p); 37 in an interface-like IParamFunction with a vector storing and caching internally the; 38 parameter values; 39 ; 40 @ingroup ParamFunc; 41 ; 42*/; 43template< typename FuncPtr = FreeParamMultiFunctionPtr >; 44class WrappedParamFunction : public IParamMultiFunction {; 45 ; 46public:; 47 ; 48 /**; 49 Constructor a wrapped function from a pointer to a callable object, the function dimension and number of parameters; 50 which are set to zero by default; 51 */; 52 WrappedParamFunction (FuncPtr func, unsigned int dim = 1, unsigned int npar = 0, double * par = nullptr) :; 53 fFunc(func),; 54 fDim(dim),; 55 fParams(std::vector<double>(npar) ); 56 {; 57 if (par) std::copy(par, par+npar, fParams.begin());; 58 }; 59 ; 60// /**; 61// Constructor a wrapped function from a non-const pointer to a callable object, the function dimension and number of parameters; 62// which are set to zero by default; 63// This constructor is needed in the case FuncPtr is a std::unique_ptr which has a copy ctor taking non const objects; 64// */; 65// WrappedParamFunction (FuncPtr & func, unsigned int dim = 1, unsigned int npar = 0, double * par = 0) :; 66// fFunc(fun",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:1529,Integrability,wrap,wrapped,1529,"5 * *; 6 * Copyright (c) 2006 CERN *; 7 * All rights reserved. *; 8 * *; 9 * For the licensing terms see $ROOTSYS/LICENSE. *; 10 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 11 * *; 12 **********************************************************************/; 13 ; 14// Header file for class WrappedParamFunction; 15 ; 16#ifndef ROOT_Math_WrappedParamFunction; 17#define ROOT_Math_WrappedParamFunction; 18 ; 19#include ""Math/IParamFunction.h""; 20 ; 21//#include <iostream>; 22//#include <iterator>; 23 ; 24#include <vector>; 25 ; 26 ; 27namespace ROOT {; 28 ; 29 namespace Math {; 30 ; 31 ; 32typedef double( * FreeParamMultiFunctionPtr ) (const double *, const double * );; 33 ; 34/**; 35 WrappedParamFunction class to wrap any multi-dimensional function object; 36 implementing the operator()(const double * x, const double * p); 37 in an interface-like IParamFunction with a vector storing and caching internally the; 38 parameter values; 39 ; 40 @ingroup ParamFunc; 41 ; 42*/; 43template< typename FuncPtr = FreeParamMultiFunctionPtr >; 44class WrappedParamFunction : public IParamMultiFunction {; 45 ; 46public:; 47 ; 48 /**; 49 Constructor a wrapped function from a pointer to a callable object, the function dimension and number of parameters; 50 which are set to zero by default; 51 */; 52 WrappedParamFunction (FuncPtr func, unsigned int dim = 1, unsigned int npar = 0, double * par = nullptr) :; 53 fFunc(func),; 54 fDim(dim),; 55 fParams(std::vector<double>(npar) ); 56 {; 57 if (par) std::copy(par, par+npar, fParams.begin());; 58 }; 59 ; 60// /**; 61// Constructor a wrapped function from a non-const pointer to a callable object, the function dimension and number of parameters; 62// which are set to zero by default; 63// This constructor is needed in the case FuncPtr is a std::unique_ptr which has a copy ctor taking non const objects; 64// */; 65// WrappedParamFunction (FuncPtr & func, unsigned int dim = 1, unsigned int npar = 0, double * par = 0) :; 66// fFunc(fun",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:1961,Integrability,wrap,wrapped,1961," double * p); 37 in an interface-like IParamFunction with a vector storing and caching internally the; 38 parameter values; 39 ; 40 @ingroup ParamFunc; 41 ; 42*/; 43template< typename FuncPtr = FreeParamMultiFunctionPtr >; 44class WrappedParamFunction : public IParamMultiFunction {; 45 ; 46public:; 47 ; 48 /**; 49 Constructor a wrapped function from a pointer to a callable object, the function dimension and number of parameters; 50 which are set to zero by default; 51 */; 52 WrappedParamFunction (FuncPtr func, unsigned int dim = 1, unsigned int npar = 0, double * par = nullptr) :; 53 fFunc(func),; 54 fDim(dim),; 55 fParams(std::vector<double>(npar) ); 56 {; 57 if (par) std::copy(par, par+npar, fParams.begin());; 58 }; 59 ; 60// /**; 61// Constructor a wrapped function from a non-const pointer to a callable object, the function dimension and number of parameters; 62// which are set to zero by default; 63// This constructor is needed in the case FuncPtr is a std::unique_ptr which has a copy ctor taking non const objects; 64// */; 65// WrappedParamFunction (FuncPtr & func, unsigned int dim = 1, unsigned int npar = 0, double * par = 0) :; 66// fFunc(func),; 67// fDim(dim),; 68// fParams(std::vector<double>(npar) ); 69// {; 70// if (par != 0) std::copy(par,par+npar,fParams.begin() );; 71// }; 72 ; 73 /**; 74 Constructor a wrapped function from a pointer to a callable object, the function dimension and an iterator specifying begin and end; 75 of parameters; 76 */; 77 template<class Iterator>; 78 WrappedParamFunction (FuncPtr func, unsigned int dim, Iterator begin, Iterator end) :; 79 fFunc(func),; 80 fDim(dim),; 81 fParams(std::vector<double>(begin,end) ); 82 {}; 83 ; 84// /**; 85// Constructor a wrapped function from a non - const pointer to a callable object, the function dimension and an iterator specifying begin and end of parameters.; 86// This constructor is needed in the case FuncPtr is a std::unique_ptr which has a copy ctor taking non const objects; 87// */; 88//",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:2538,Integrability,wrap,wrapped,2538,"nullptr) :; 53 fFunc(func),; 54 fDim(dim),; 55 fParams(std::vector<double>(npar) ); 56 {; 57 if (par) std::copy(par, par+npar, fParams.begin());; 58 }; 59 ; 60// /**; 61// Constructor a wrapped function from a non-const pointer to a callable object, the function dimension and number of parameters; 62// which are set to zero by default; 63// This constructor is needed in the case FuncPtr is a std::unique_ptr which has a copy ctor taking non const objects; 64// */; 65// WrappedParamFunction (FuncPtr & func, unsigned int dim = 1, unsigned int npar = 0, double * par = 0) :; 66// fFunc(func),; 67// fDim(dim),; 68// fParams(std::vector<double>(npar) ); 69// {; 70// if (par != 0) std::copy(par,par+npar,fParams.begin() );; 71// }; 72 ; 73 /**; 74 Constructor a wrapped function from a pointer to a callable object, the function dimension and an iterator specifying begin and end; 75 of parameters; 76 */; 77 template<class Iterator>; 78 WrappedParamFunction (FuncPtr func, unsigned int dim, Iterator begin, Iterator end) :; 79 fFunc(func),; 80 fDim(dim),; 81 fParams(std::vector<double>(begin,end) ); 82 {}; 83 ; 84// /**; 85// Constructor a wrapped function from a non - const pointer to a callable object, the function dimension and an iterator specifying begin and end of parameters.; 86// This constructor is needed in the case FuncPtr is a std::unique_ptr which has a copy ctor taking non const objects; 87// */; 88// template<class Iterator>; 89// WrappedParamFunction (FuncPtr func, unsigned int dim, Iterator begin, Iterator end) :; 90// fFunc(func),; 91// fDim(dim),; 92// fParams(std::vector<double>(begin,end) ); 93// {}; 94 ; 95 /// clone the function; 96 IMultiGenFunction * Clone() const override {; 97 return new WrappedParamFunction(fFunc, fDim, fParams.begin(), fParams.end());; 98 }; 99 ; 100 const double * Parameters() const override {; 101 return fParams.empty() ? nullptr : &fParams.front();; 102 }; 103 ; 104 void SetParameters(const double * p) override {; 105 std::copy(p, p",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:2919,Integrability,wrap,wrapped,2919,"nullptr) :; 53 fFunc(func),; 54 fDim(dim),; 55 fParams(std::vector<double>(npar) ); 56 {; 57 if (par) std::copy(par, par+npar, fParams.begin());; 58 }; 59 ; 60// /**; 61// Constructor a wrapped function from a non-const pointer to a callable object, the function dimension and number of parameters; 62// which are set to zero by default; 63// This constructor is needed in the case FuncPtr is a std::unique_ptr which has a copy ctor taking non const objects; 64// */; 65// WrappedParamFunction (FuncPtr & func, unsigned int dim = 1, unsigned int npar = 0, double * par = 0) :; 66// fFunc(func),; 67// fDim(dim),; 68// fParams(std::vector<double>(npar) ); 69// {; 70// if (par != 0) std::copy(par,par+npar,fParams.begin() );; 71// }; 72 ; 73 /**; 74 Constructor a wrapped function from a pointer to a callable object, the function dimension and an iterator specifying begin and end; 75 of parameters; 76 */; 77 template<class Iterator>; 78 WrappedParamFunction (FuncPtr func, unsigned int dim, Iterator begin, Iterator end) :; 79 fFunc(func),; 80 fDim(dim),; 81 fParams(std::vector<double>(begin,end) ); 82 {}; 83 ; 84// /**; 85// Constructor a wrapped function from a non - const pointer to a callable object, the function dimension and an iterator specifying begin and end of parameters.; 86// This constructor is needed in the case FuncPtr is a std::unique_ptr which has a copy ctor taking non const objects; 87// */; 88// template<class Iterator>; 89// WrappedParamFunction (FuncPtr func, unsigned int dim, Iterator begin, Iterator end) :; 90// fFunc(func),; 91// fDim(dim),; 92// fParams(std::vector<double>(begin,end) ); 93// {}; 94 ; 95 /// clone the function; 96 IMultiGenFunction * Clone() const override {; 97 return new WrappedParamFunction(fFunc, fDim, fParams.begin(), fParams.end());; 98 }; 99 ; 100 const double * Parameters() const override {; 101 return fParams.empty() ? nullptr : &fParams.front();; 102 }; 103 ; 104 void SetParameters(const double * p) override {; 105 std::copy(p, p",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:4048,Integrability,interface,interface,4048,"amFunction (FuncPtr func, unsigned int dim, Iterator begin, Iterator end) :; 90// fFunc(func),; 91// fDim(dim),; 92// fParams(std::vector<double>(begin,end) ); 93// {}; 94 ; 95 /// clone the function; 96 IMultiGenFunction * Clone() const override {; 97 return new WrappedParamFunction(fFunc, fDim, fParams.begin(), fParams.end());; 98 }; 99 ; 100 const double * Parameters() const override {; 101 return fParams.empty() ? nullptr : &fParams.front();; 102 }; 103 ; 104 void SetParameters(const double * p) override {; 105 std::copy(p, p+NPar(), fParams.begin() );; 106 }; 107 ; 108 unsigned int NPar() const override { return fParams.size(); }; 109 ; 110 unsigned int NDim() const override { return fDim; }; 111 ; 112 ; 113private:; 114 ; 115 /// evaluate the function given values and parameters (requested interface); 116 double DoEvalPar(const double * x, const double * p) const override {; 117 return (*fFunc)( x, p );; 118 }; 119 ; 120 ; 121 FuncPtr fFunc;; 122 unsigned int fDim;; 123 std::vector<double> fParams;; 124 ; 125 ; 126 ; 127};; 128 ; 129 ; 130typedef double( * FreeMultiFunctionPtr ) (const double *);; 131 ; 132/**; 133 WrappedParamGenFunction class to wrap any multi-dimensional function; 134 implementing the operator()(const double * ); 135 in an interface-like IParamFunction, by fixing some of the variables and define them as; 136 parameters.; 137 i.e. transform any multi-dim function in a parametric function; 138 ; 139 @ingroup ParamFunc; 140 ; 141*/; 142template< typename FuncPtr = FreeMultiFunctionPtr >; 143class WrappedParamFunctionGen : public IParamMultiFunction {; 144 ; 145public:; 146 ; 147 /**; 148 Constructor a wrapped function from a pointer to a generic callable object implementation operator()(const double *), the new function dimension, the number of parameters (number of fixed variables) and an array specifying the index of the fixed variables which became; 149 parameters in the new API; 150 */; 151 ; 152 WrappedParamFunctionGen (const FuncPtr & fu",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:4413,Integrability,wrap,wrap,4413,"amFunction (FuncPtr func, unsigned int dim, Iterator begin, Iterator end) :; 90// fFunc(func),; 91// fDim(dim),; 92// fParams(std::vector<double>(begin,end) ); 93// {}; 94 ; 95 /// clone the function; 96 IMultiGenFunction * Clone() const override {; 97 return new WrappedParamFunction(fFunc, fDim, fParams.begin(), fParams.end());; 98 }; 99 ; 100 const double * Parameters() const override {; 101 return fParams.empty() ? nullptr : &fParams.front();; 102 }; 103 ; 104 void SetParameters(const double * p) override {; 105 std::copy(p, p+NPar(), fParams.begin() );; 106 }; 107 ; 108 unsigned int NPar() const override { return fParams.size(); }; 109 ; 110 unsigned int NDim() const override { return fDim; }; 111 ; 112 ; 113private:; 114 ; 115 /// evaluate the function given values and parameters (requested interface); 116 double DoEvalPar(const double * x, const double * p) const override {; 117 return (*fFunc)( x, p );; 118 }; 119 ; 120 ; 121 FuncPtr fFunc;; 122 unsigned int fDim;; 123 std::vector<double> fParams;; 124 ; 125 ; 126 ; 127};; 128 ; 129 ; 130typedef double( * FreeMultiFunctionPtr ) (const double *);; 131 ; 132/**; 133 WrappedParamGenFunction class to wrap any multi-dimensional function; 134 implementing the operator()(const double * ); 135 in an interface-like IParamFunction, by fixing some of the variables and define them as; 136 parameters.; 137 i.e. transform any multi-dim function in a parametric function; 138 ; 139 @ingroup ParamFunc; 140 ; 141*/; 142template< typename FuncPtr = FreeMultiFunctionPtr >; 143class WrappedParamFunctionGen : public IParamMultiFunction {; 144 ; 145public:; 146 ; 147 /**; 148 Constructor a wrapped function from a pointer to a generic callable object implementation operator()(const double *), the new function dimension, the number of parameters (number of fixed variables) and an array specifying the index of the fixed variables which became; 149 parameters in the new API; 150 */; 151 ; 152 WrappedParamFunctionGen (const FuncPtr & fu",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:4510,Integrability,interface,interface-like,4510,"amFunction (FuncPtr func, unsigned int dim, Iterator begin, Iterator end) :; 90// fFunc(func),; 91// fDim(dim),; 92// fParams(std::vector<double>(begin,end) ); 93// {}; 94 ; 95 /// clone the function; 96 IMultiGenFunction * Clone() const override {; 97 return new WrappedParamFunction(fFunc, fDim, fParams.begin(), fParams.end());; 98 }; 99 ; 100 const double * Parameters() const override {; 101 return fParams.empty() ? nullptr : &fParams.front();; 102 }; 103 ; 104 void SetParameters(const double * p) override {; 105 std::copy(p, p+NPar(), fParams.begin() );; 106 }; 107 ; 108 unsigned int NPar() const override { return fParams.size(); }; 109 ; 110 unsigned int NDim() const override { return fDim; }; 111 ; 112 ; 113private:; 114 ; 115 /// evaluate the function given values and parameters (requested interface); 116 double DoEvalPar(const double * x, const double * p) const override {; 117 return (*fFunc)( x, p );; 118 }; 119 ; 120 ; 121 FuncPtr fFunc;; 122 unsigned int fDim;; 123 std::vector<double> fParams;; 124 ; 125 ; 126 ; 127};; 128 ; 129 ; 130typedef double( * FreeMultiFunctionPtr ) (const double *);; 131 ; 132/**; 133 WrappedParamGenFunction class to wrap any multi-dimensional function; 134 implementing the operator()(const double * ); 135 in an interface-like IParamFunction, by fixing some of the variables and define them as; 136 parameters.; 137 i.e. transform any multi-dim function in a parametric function; 138 ; 139 @ingroup ParamFunc; 140 ; 141*/; 142template< typename FuncPtr = FreeMultiFunctionPtr >; 143class WrappedParamFunctionGen : public IParamMultiFunction {; 144 ; 145public:; 146 ; 147 /**; 148 Constructor a wrapped function from a pointer to a generic callable object implementation operator()(const double *), the new function dimension, the number of parameters (number of fixed variables) and an array specifying the index of the fixed variables which became; 149 parameters in the new API; 150 */; 151 ; 152 WrappedParamFunctionGen (const FuncPtr & fu",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:4893,Integrability,wrap,wrapped,4893,"eturn (*fFunc)( x, p );; 118 }; 119 ; 120 ; 121 FuncPtr fFunc;; 122 unsigned int fDim;; 123 std::vector<double> fParams;; 124 ; 125 ; 126 ; 127};; 128 ; 129 ; 130typedef double( * FreeMultiFunctionPtr ) (const double *);; 131 ; 132/**; 133 WrappedParamGenFunction class to wrap any multi-dimensional function; 134 implementing the operator()(const double * ); 135 in an interface-like IParamFunction, by fixing some of the variables and define them as; 136 parameters.; 137 i.e. transform any multi-dim function in a parametric function; 138 ; 139 @ingroup ParamFunc; 140 ; 141*/; 142template< typename FuncPtr = FreeMultiFunctionPtr >; 143class WrappedParamFunctionGen : public IParamMultiFunction {; 144 ; 145public:; 146 ; 147 /**; 148 Constructor a wrapped function from a pointer to a generic callable object implementation operator()(const double *), the new function dimension, the number of parameters (number of fixed variables) and an array specifying the index of the fixed variables which became; 149 parameters in the new API; 150 */; 151 ; 152 WrappedParamFunctionGen (const FuncPtr & func, unsigned int dim, unsigned int npar, const double * par, const unsigned int * idx) :; 153 fFunc(func),; 154 fDim(dim),; 155 fParams(std::vector<double>(par,par+npar) ),; 156 fParIndices(std::vector<unsigned int>(idx, idx + npar) ),; 157 fX(std::vector<double>(npar+dim) ) // cached vector; 158 {; 159 DoInit();; 160 }; 161 ; 162 /**; 163 Constructor as before but taking now a non - const pointer to a callable object.; 164 This constructor is needed in the case FuncPtr is a std::unique_ptr which has a copy ctor taking non const objects; 165 */; 166 WrappedParamFunctionGen (FuncPtr & func, unsigned int dim, unsigned int npar, const double * par, const unsigned int * idx) :; 167 fFunc(func),; 168 fDim(dim),; 169 fParams(std::vector<double>(par,par+npar) ),; 170 fParIndices(std::vector<unsigned int>(idx, idx + npar) ),; 171 fX(std::vector<double>(npar+dim) ) // cached vector; 172 {; 173 Do",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:8314,Integrability,interface,interface,8314,"ion (re-implement for being more efficient); 213 double DoEval(const double * x) const override {; 214 ; 215// std::cout << this << fDim << "" x : "";; 216// std::ostream_iterator<double> oix(std::cout,"" , "");; 217// std::copy(x, x+fDim, oix);; 218// std::cout << std::endl;; 219// std::cout << ""npar "" << npar << std::endl;; 220// std::cout << fVarIndices.size() << std::endl;; 221// assert ( fVarIndices.size() == fDim); // otherwise something is wrong; 222 ; 223 for (unsigned int i = 0; i < fDim; ++i) {; 224 unsigned int j = fVarIndices[i];; 225 assert ( j < NPar() + fDim);; 226 fX[ j ] = x[i];; 227 }; 228// std::cout << ""X : ("";; 229// std::ostream_iterator<double> oi(std::cout,"" , "");; 230// std::copy(fX.begin(), fX.end(), oi);; 231// std::cout << std::endl;; 232 ; 233 return (*fFunc)( fX.empty() ? nullptr : &fX.front() );; 234 }; 235 ; 236 ; 237 /**; 238 implement the required IParamFunction interface; 239 */; 240 double DoEvalPar(const double * x, const double * p ) const override {; 241 SetParValues(NPar(), p);; 242 return DoEval(x);; 243 }; 244 ; 245 ; 246 void DoInit() {; 247 // calculate variable indices and set in X the parameter values; 248 fVarIndices.reserve(fDim);; 249 unsigned int npar = NPar();; 250 for (unsigned int i = 0; i < npar + fDim; ++i) {; 251 bool isVar = true;; 252 for (unsigned int j = 0; j < npar; ++j) {; 253 if (fParIndices[j] == i) {; 254 isVar = false;; 255 break;; 256 }; 257 }; 258 if (isVar) fVarIndices.push_back(i);; 259 }; 260 assert ( fVarIndices.size() == fDim); // otherwise something is wrong; 261 ; 262// std::cout << ""n variables "" << fVarIndices.size() << std::endl;; 263// std::ostream_iterator<int> oi(std::cout,"" "");; 264// std::copy(fVarIndices.begin(), fVarIndices.end(), oi);; 265// std::cout << std::endl;; 266// assert( fVarIndices.size() == fDim);; 267// std::cout << this << std::endl;; 268 ; 269 // set parameter values in fX; 270 SetParValues(npar, fParams.empty() ? nullptr : &fParams.front());; 271 for (unsigned int i = 0; ",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:10624,Integrability,wrap,wrap,10624,"d fX vector; 280 // make const because it might be called from const methods; 281 void SetParValues(unsigned int npar, const double * p) const {; 282 for (unsigned int i = 0; i < npar; ++i) {; 283 unsigned int j = fParIndices[i];; 284 assert ( j < npar + fDim);; 285 fX[j] = p[i];; 286 }; 287 }; 288 ; 289 ; 290 mutable FuncPtr fFunc;; 291 unsigned int fDim;; 292 std::vector<double> fParams;; 293 std::vector<unsigned int> fVarIndices;; 294 std::vector<unsigned int> fParIndices;; 295 mutable std::vector<double> fX;; 296 ; 297 ; 298 ; 299};; 300 ; 301 ; 302 } // end namespace Math; 303 ; 304} // end namespace ROOT; 305 ; 306 ; 307#endif /* ROOT_Math_WrappedParamFunction */; IParamFunction.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IParametricFunctionMultiDimTempl< double >; ROOT::Math::WrappedParamFunctionGenWrappedParamGenFunction class to wrap any multi-dimensional function implementing the operator()(cons...Definition WrappedParamFunction.h:143; ROOT::Math::WrappedParamFunctionGen::operator=WrappedParamFunctionGen & operator=(const WrappedParamFunctionGen &)=delete; ROOT::Math::WrappedParamFunctionGen::DoEvaldouble DoEval(const double *x) const overrideevaluate the function (re-implement for being more efficient)Definition WrappedParamFunction.h:213; ROOT::Math::WrappedParamFunctionGen::WrappedParamFunctionGenWrappedParamFunctionGen(const WrappedParamFunctionGen &)=delete; ROOT::Math::WrappedParamFunctionGen::WrappedParamFunctionGenWrappedParamFunctionGen(const FuncPtr &func, unsigned int dim, unsigned int npar, const double *par, const unsigned int *idx)Constructor a wrapped function from a pointer to a generic callable object implementation operator()(...Definition WrappedParamFunction.h:152; ROOT::Math::WrappedParamFunctionGen::NDimunsigned int NDim() const overrideRetrieve the dimensio",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:11369,Integrability,wrap,wrapped,11369,"WrappedParamFunction */; IParamFunction.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IParametricFunctionMultiDimTempl< double >; ROOT::Math::WrappedParamFunctionGenWrappedParamGenFunction class to wrap any multi-dimensional function implementing the operator()(cons...Definition WrappedParamFunction.h:143; ROOT::Math::WrappedParamFunctionGen::operator=WrappedParamFunctionGen & operator=(const WrappedParamFunctionGen &)=delete; ROOT::Math::WrappedParamFunctionGen::DoEvaldouble DoEval(const double *x) const overrideevaluate the function (re-implement for being more efficient)Definition WrappedParamFunction.h:213; ROOT::Math::WrappedParamFunctionGen::WrappedParamFunctionGenWrappedParamFunctionGen(const WrappedParamFunctionGen &)=delete; ROOT::Math::WrappedParamFunctionGen::WrappedParamFunctionGenWrappedParamFunctionGen(const FuncPtr &func, unsigned int dim, unsigned int npar, const double *par, const unsigned int *idx)Constructor a wrapped function from a pointer to a generic callable object implementation operator()(...Definition WrappedParamFunction.h:152; ROOT::Math::WrappedParamFunctionGen::NDimunsigned int NDim() const overrideRetrieve the dimension of the function.Definition WrappedParamFunction.h:200; ROOT::Math::WrappedParamFunctionGen::SetParValuesvoid SetParValues(unsigned int npar, const double *p) constDefinition WrappedParamFunction.h:281; ROOT::Math::WrappedParamFunctionGen::SetParametersvoid SetParameters(const double *p) overrideSet the parameter values.Definition WrappedParamFunction.h:192; ROOT::Math::WrappedParamFunctionGen::NParunsigned int NPar() const overrideReturn the number of Parameters.Definition WrappedParamFunction.h:198; ROOT::Math::WrappedParamFunctionGen::fParIndicesstd::vector< unsigned int > fParIndicesDefinition WrappedParamFunction.h:294; ROOT::Math::WrappedP",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:12377,Integrability,interface,interfaceDefinition,12377,"ouble *par, const unsigned int *idx)Constructor a wrapped function from a pointer to a generic callable object implementation operator()(...Definition WrappedParamFunction.h:152; ROOT::Math::WrappedParamFunctionGen::NDimunsigned int NDim() const overrideRetrieve the dimension of the function.Definition WrappedParamFunction.h:200; ROOT::Math::WrappedParamFunctionGen::SetParValuesvoid SetParValues(unsigned int npar, const double *p) constDefinition WrappedParamFunction.h:281; ROOT::Math::WrappedParamFunctionGen::SetParametersvoid SetParameters(const double *p) overrideSet the parameter values.Definition WrappedParamFunction.h:192; ROOT::Math::WrappedParamFunctionGen::NParunsigned int NPar() const overrideReturn the number of Parameters.Definition WrappedParamFunction.h:198; ROOT::Math::WrappedParamFunctionGen::fParIndicesstd::vector< unsigned int > fParIndicesDefinition WrappedParamFunction.h:294; ROOT::Math::WrappedParamFunctionGen::DoEvalPardouble DoEvalPar(const double *x, const double *p) const overrideimplement the required IParamFunction interfaceDefinition WrappedParamFunction.h:240; ROOT::Math::WrappedParamFunctionGen::DoInitvoid DoInit()Definition WrappedParamFunction.h:246; ROOT::Math::WrappedParamFunctionGen::WrappedParamFunctionGenWrappedParamFunctionGen(FuncPtr &func, unsigned int dim, unsigned int npar, const double *par, const unsigned int *idx)Constructor as before but taking now a non - const pointer to a callable object.Definition WrappedParamFunction.h:166; ROOT::Math::WrappedParamFunctionGen::fDimunsigned int fDimDefinition WrappedParamFunction.h:291; ROOT::Math::WrappedParamFunctionGen::fFuncFuncPtr fFuncDefinition WrappedParamFunction.h:290; ROOT::Math::WrappedParamFunctionGen::CloneIMultiGenFunction * Clone() const overrideclone the functionDefinition WrappedParamFunction.h:177; ROOT::Math::WrappedParamFunctionGen::fXstd::vector< double > fXDefinition WrappedParamFunction.h:295; ROOT::Math::WrappedParamFunctionGen::fParamsstd::vector< double > fP",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:13708,Integrability,wrap,wrap,13708,"r as before but taking now a non - const pointer to a callable object.Definition WrappedParamFunction.h:166; ROOT::Math::WrappedParamFunctionGen::fDimunsigned int fDimDefinition WrappedParamFunction.h:291; ROOT::Math::WrappedParamFunctionGen::fFuncFuncPtr fFuncDefinition WrappedParamFunction.h:290; ROOT::Math::WrappedParamFunctionGen::CloneIMultiGenFunction * Clone() const overrideclone the functionDefinition WrappedParamFunction.h:177; ROOT::Math::WrappedParamFunctionGen::fXstd::vector< double > fXDefinition WrappedParamFunction.h:295; ROOT::Math::WrappedParamFunctionGen::fParamsstd::vector< double > fParamsDefinition WrappedParamFunction.h:292; ROOT::Math::WrappedParamFunctionGen::fVarIndicesstd::vector< unsigned int > fVarIndicesDefinition WrappedParamFunction.h:293; ROOT::Math::WrappedParamFunctionGen::Parametersconst double * Parameters() const overrideAccess the parameter values.Definition WrappedParamFunction.h:188; ROOT::Math::WrappedParamFunctionWrappedParamFunction class to wrap any multi-dimensional function object implementing the operator()(...Definition WrappedParamFunction.h:44; ROOT::Math::WrappedParamFunction::NDimunsigned int NDim() const overrideRetrieve the dimension of the function.Definition WrappedParamFunction.h:110; ROOT::Math::WrappedParamFunction::Parametersconst double * Parameters() const overrideAccess the parameter values.Definition WrappedParamFunction.h:100; ROOT::Math::WrappedParamFunction::SetParametersvoid SetParameters(const double *p) overrideSet the parameter values.Definition WrappedParamFunction.h:104; ROOT::Math::WrappedParamFunction::fDimunsigned int fDimDefinition WrappedParamFunction.h:122; ROOT::Math::WrappedParamFunction::fParamsstd::vector< double > fParamsDefinition WrappedParamFunction.h:123; ROOT::Math::WrappedParamFunction::WrappedParamFunctionWrappedParamFunction(FuncPtr func, unsigned int dim, Iterator begin, Iterator end)Constructor a wrapped function from a pointer to a callable object, the function dimension an",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:14631,Integrability,wrap,wrapped,14631,"ter values.Definition WrappedParamFunction.h:188; ROOT::Math::WrappedParamFunctionWrappedParamFunction class to wrap any multi-dimensional function object implementing the operator()(...Definition WrappedParamFunction.h:44; ROOT::Math::WrappedParamFunction::NDimunsigned int NDim() const overrideRetrieve the dimension of the function.Definition WrappedParamFunction.h:110; ROOT::Math::WrappedParamFunction::Parametersconst double * Parameters() const overrideAccess the parameter values.Definition WrappedParamFunction.h:100; ROOT::Math::WrappedParamFunction::SetParametersvoid SetParameters(const double *p) overrideSet the parameter values.Definition WrappedParamFunction.h:104; ROOT::Math::WrappedParamFunction::fDimunsigned int fDimDefinition WrappedParamFunction.h:122; ROOT::Math::WrappedParamFunction::fParamsstd::vector< double > fParamsDefinition WrappedParamFunction.h:123; ROOT::Math::WrappedParamFunction::WrappedParamFunctionWrappedParamFunction(FuncPtr func, unsigned int dim, Iterator begin, Iterator end)Constructor a wrapped function from a pointer to a callable object, the function dimension and an ite...Definition WrappedParamFunction.h:78; ROOT::Math::WrappedParamFunction::fFuncFuncPtr fFuncDefinition WrappedParamFunction.h:121; ROOT::Math::WrappedParamFunction::CloneIMultiGenFunction * Clone() const overrideclone the functionDefinition WrappedParamFunction.h:96; ROOT::Math::WrappedParamFunction::DoEvalPardouble DoEvalPar(const double *x, const double *p) const overrideevaluate the function given values and parameters (requested interface)Definition WrappedParamFunction.h:116; ROOT::Math::WrappedParamFunction::NParunsigned int NPar() const overrideReturn the number of Parameters.Definition WrappedParamFunction.h:108; ROOT::Math::WrappedParamFunction::WrappedParamFunctionWrappedParamFunction(FuncPtr func, unsigned int dim=1, unsigned int npar=0, double *par=nullptr)Constructor a wrapped function from a pointer to a callable object, the function dimension and numb",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:15156,Integrability,interface,interface,15156,"ition WrappedParamFunction.h:100; ROOT::Math::WrappedParamFunction::SetParametersvoid SetParameters(const double *p) overrideSet the parameter values.Definition WrappedParamFunction.h:104; ROOT::Math::WrappedParamFunction::fDimunsigned int fDimDefinition WrappedParamFunction.h:122; ROOT::Math::WrappedParamFunction::fParamsstd::vector< double > fParamsDefinition WrappedParamFunction.h:123; ROOT::Math::WrappedParamFunction::WrappedParamFunctionWrappedParamFunction(FuncPtr func, unsigned int dim, Iterator begin, Iterator end)Constructor a wrapped function from a pointer to a callable object, the function dimension and an ite...Definition WrappedParamFunction.h:78; ROOT::Math::WrappedParamFunction::fFuncFuncPtr fFuncDefinition WrappedParamFunction.h:121; ROOT::Math::WrappedParamFunction::CloneIMultiGenFunction * Clone() const overrideclone the functionDefinition WrappedParamFunction.h:96; ROOT::Math::WrappedParamFunction::DoEvalPardouble DoEvalPar(const double *x, const double *p) const overrideevaluate the function given values and parameters (requested interface)Definition WrappedParamFunction.h:116; ROOT::Math::WrappedParamFunction::NParunsigned int NPar() const overrideReturn the number of Parameters.Definition WrappedParamFunction.h:108; ROOT::Math::WrappedParamFunction::WrappedParamFunctionWrappedParamFunction(FuncPtr func, unsigned int dim=1, unsigned int npar=0, double *par=nullptr)Constructor a wrapped function from a pointer to a callable object, the function dimension and number...Definition WrappedParamFunction.h:52; double; int; xDouble_t x[n]Definition legend1.C:17; MathNamespace for new Math classes and functions.; ROOT::Math::FreeParamMultiFunctionPtrdouble(* FreeParamMultiFunctionPtr)(const double *, const double *)Definition WrappedParamFunction.h:32; ROOT::Math::FreeMultiFunctionPtrdouble(* FreeMultiFunctionPtr)(const double *)Definition WrappedFunction.h:30; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:15512,Integrability,wrap,wrapped,15512,"th::WrappedParamFunction::fDimunsigned int fDimDefinition WrappedParamFunction.h:122; ROOT::Math::WrappedParamFunction::fParamsstd::vector< double > fParamsDefinition WrappedParamFunction.h:123; ROOT::Math::WrappedParamFunction::WrappedParamFunctionWrappedParamFunction(FuncPtr func, unsigned int dim, Iterator begin, Iterator end)Constructor a wrapped function from a pointer to a callable object, the function dimension and an ite...Definition WrappedParamFunction.h:78; ROOT::Math::WrappedParamFunction::fFuncFuncPtr fFuncDefinition WrappedParamFunction.h:121; ROOT::Math::WrappedParamFunction::CloneIMultiGenFunction * Clone() const overrideclone the functionDefinition WrappedParamFunction.h:96; ROOT::Math::WrappedParamFunction::DoEvalPardouble DoEvalPar(const double *x, const double *p) const overrideevaluate the function given values and parameters (requested interface)Definition WrappedParamFunction.h:116; ROOT::Math::WrappedParamFunction::NParunsigned int NPar() const overrideReturn the number of Parameters.Definition WrappedParamFunction.h:108; ROOT::Math::WrappedParamFunction::WrappedParamFunctionWrappedParamFunction(FuncPtr func, unsigned int dim=1, unsigned int npar=0, double *par=nullptr)Constructor a wrapped function from a pointer to a callable object, the function dimension and number...Definition WrappedParamFunction.h:52; double; int; xDouble_t x[n]Definition legend1.C:17; MathNamespace for new Math classes and functions.; ROOT::Math::FreeParamMultiFunctionPtrdouble(* FreeParamMultiFunctionPtr)(const double *, const double *)Definition WrappedParamFunction.h:32; ROOT::Math::FreeMultiFunctionPtrdouble(* FreeMultiFunctionPtr)(const double *)Definition WrappedFunction.h:30; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. mathmathcoreincMathWrappedParamFunction.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:40 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:4563,Modifiability,variab,variables,4563,"amFunction (FuncPtr func, unsigned int dim, Iterator begin, Iterator end) :; 90// fFunc(func),; 91// fDim(dim),; 92// fParams(std::vector<double>(begin,end) ); 93// {}; 94 ; 95 /// clone the function; 96 IMultiGenFunction * Clone() const override {; 97 return new WrappedParamFunction(fFunc, fDim, fParams.begin(), fParams.end());; 98 }; 99 ; 100 const double * Parameters() const override {; 101 return fParams.empty() ? nullptr : &fParams.front();; 102 }; 103 ; 104 void SetParameters(const double * p) override {; 105 std::copy(p, p+NPar(), fParams.begin() );; 106 }; 107 ; 108 unsigned int NPar() const override { return fParams.size(); }; 109 ; 110 unsigned int NDim() const override { return fDim; }; 111 ; 112 ; 113private:; 114 ; 115 /// evaluate the function given values and parameters (requested interface); 116 double DoEvalPar(const double * x, const double * p) const override {; 117 return (*fFunc)( x, p );; 118 }; 119 ; 120 ; 121 FuncPtr fFunc;; 122 unsigned int fDim;; 123 std::vector<double> fParams;; 124 ; 125 ; 126 ; 127};; 128 ; 129 ; 130typedef double( * FreeMultiFunctionPtr ) (const double *);; 131 ; 132/**; 133 WrappedParamGenFunction class to wrap any multi-dimensional function; 134 implementing the operator()(const double * ); 135 in an interface-like IParamFunction, by fixing some of the variables and define them as; 136 parameters.; 137 i.e. transform any multi-dim function in a parametric function; 138 ; 139 @ingroup ParamFunc; 140 ; 141*/; 142template< typename FuncPtr = FreeMultiFunctionPtr >; 143class WrappedParamFunctionGen : public IParamMultiFunction {; 144 ; 145public:; 146 ; 147 /**; 148 Constructor a wrapped function from a pointer to a generic callable object implementation operator()(const double *), the new function dimension, the number of parameters (number of fixed variables) and an array specifying the index of the fixed variables which became; 149 parameters in the new API; 150 */; 151 ; 152 WrappedParamFunctionGen (const FuncPtr & fu",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:5067,Modifiability,variab,variables,5067,"eturn (*fFunc)( x, p );; 118 }; 119 ; 120 ; 121 FuncPtr fFunc;; 122 unsigned int fDim;; 123 std::vector<double> fParams;; 124 ; 125 ; 126 ; 127};; 128 ; 129 ; 130typedef double( * FreeMultiFunctionPtr ) (const double *);; 131 ; 132/**; 133 WrappedParamGenFunction class to wrap any multi-dimensional function; 134 implementing the operator()(const double * ); 135 in an interface-like IParamFunction, by fixing some of the variables and define them as; 136 parameters.; 137 i.e. transform any multi-dim function in a parametric function; 138 ; 139 @ingroup ParamFunc; 140 ; 141*/; 142template< typename FuncPtr = FreeMultiFunctionPtr >; 143class WrappedParamFunctionGen : public IParamMultiFunction {; 144 ; 145public:; 146 ; 147 /**; 148 Constructor a wrapped function from a pointer to a generic callable object implementation operator()(const double *), the new function dimension, the number of parameters (number of fixed variables) and an array specifying the index of the fixed variables which became; 149 parameters in the new API; 150 */; 151 ; 152 WrappedParamFunctionGen (const FuncPtr & func, unsigned int dim, unsigned int npar, const double * par, const unsigned int * idx) :; 153 fFunc(func),; 154 fDim(dim),; 155 fParams(std::vector<double>(par,par+npar) ),; 156 fParIndices(std::vector<unsigned int>(idx, idx + npar) ),; 157 fX(std::vector<double>(npar+dim) ) // cached vector; 158 {; 159 DoInit();; 160 }; 161 ; 162 /**; 163 Constructor as before but taking now a non - const pointer to a callable object.; 164 This constructor is needed in the case FuncPtr is a std::unique_ptr which has a copy ctor taking non const objects; 165 */; 166 WrappedParamFunctionGen (FuncPtr & func, unsigned int dim, unsigned int npar, const double * par, const unsigned int * idx) :; 167 fFunc(func),; 168 fDim(dim),; 169 fParams(std::vector<double>(par,par+npar) ),; 170 fParIndices(std::vector<unsigned int>(idx, idx + npar) ),; 171 fX(std::vector<double>(npar+dim) ) // cached vector; 172 {; 173 Do",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:5125,Modifiability,variab,variables,5125,"eturn (*fFunc)( x, p );; 118 }; 119 ; 120 ; 121 FuncPtr fFunc;; 122 unsigned int fDim;; 123 std::vector<double> fParams;; 124 ; 125 ; 126 ; 127};; 128 ; 129 ; 130typedef double( * FreeMultiFunctionPtr ) (const double *);; 131 ; 132/**; 133 WrappedParamGenFunction class to wrap any multi-dimensional function; 134 implementing the operator()(const double * ); 135 in an interface-like IParamFunction, by fixing some of the variables and define them as; 136 parameters.; 137 i.e. transform any multi-dim function in a parametric function; 138 ; 139 @ingroup ParamFunc; 140 ; 141*/; 142template< typename FuncPtr = FreeMultiFunctionPtr >; 143class WrappedParamFunctionGen : public IParamMultiFunction {; 144 ; 145public:; 146 ; 147 /**; 148 Constructor a wrapped function from a pointer to a generic callable object implementation operator()(const double *), the new function dimension, the number of parameters (number of fixed variables) and an array specifying the index of the fixed variables which became; 149 parameters in the new API; 150 */; 151 ; 152 WrappedParamFunctionGen (const FuncPtr & func, unsigned int dim, unsigned int npar, const double * par, const unsigned int * idx) :; 153 fFunc(func),; 154 fDim(dim),; 155 fParams(std::vector<double>(par,par+npar) ),; 156 fParIndices(std::vector<unsigned int>(idx, idx + npar) ),; 157 fX(std::vector<double>(npar+dim) ) // cached vector; 158 {; 159 DoInit();; 160 }; 161 ; 162 /**; 163 Constructor as before but taking now a non - const pointer to a callable object.; 164 This constructor is needed in the case FuncPtr is a std::unique_ptr which has a copy ctor taking non const objects; 165 */; 166 WrappedParamFunctionGen (FuncPtr & func, unsigned int dim, unsigned int npar, const double * par, const unsigned int * idx) :; 167 fFunc(func),; 168 fDim(dim),; 169 fParams(std::vector<double>(par,par+npar) ),; 170 fParIndices(std::vector<unsigned int>(idx, idx + npar) ),; 171 fX(std::vector<double>(npar+dim) ) // cached vector; 172 {; 173 Do",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:8519,Modifiability,variab,variable,8519,"ion (re-implement for being more efficient); 213 double DoEval(const double * x) const override {; 214 ; 215// std::cout << this << fDim << "" x : "";; 216// std::ostream_iterator<double> oix(std::cout,"" , "");; 217// std::copy(x, x+fDim, oix);; 218// std::cout << std::endl;; 219// std::cout << ""npar "" << npar << std::endl;; 220// std::cout << fVarIndices.size() << std::endl;; 221// assert ( fVarIndices.size() == fDim); // otherwise something is wrong; 222 ; 223 for (unsigned int i = 0; i < fDim; ++i) {; 224 unsigned int j = fVarIndices[i];; 225 assert ( j < NPar() + fDim);; 226 fX[ j ] = x[i];; 227 }; 228// std::cout << ""X : ("";; 229// std::ostream_iterator<double> oi(std::cout,"" , "");; 230// std::copy(fX.begin(), fX.end(), oi);; 231// std::cout << std::endl;; 232 ; 233 return (*fFunc)( fX.empty() ? nullptr : &fX.front() );; 234 }; 235 ; 236 ; 237 /**; 238 implement the required IParamFunction interface; 239 */; 240 double DoEvalPar(const double * x, const double * p ) const override {; 241 SetParValues(NPar(), p);; 242 return DoEval(x);; 243 }; 244 ; 245 ; 246 void DoInit() {; 247 // calculate variable indices and set in X the parameter values; 248 fVarIndices.reserve(fDim);; 249 unsigned int npar = NPar();; 250 for (unsigned int i = 0; i < npar + fDim; ++i) {; 251 bool isVar = true;; 252 for (unsigned int j = 0; j < npar; ++j) {; 253 if (fParIndices[j] == i) {; 254 isVar = false;; 255 break;; 256 }; 257 }; 258 if (isVar) fVarIndices.push_back(i);; 259 }; 260 assert ( fVarIndices.size() == fDim); // otherwise something is wrong; 261 ; 262// std::cout << ""n variables "" << fVarIndices.size() << std::endl;; 263// std::ostream_iterator<int> oi(std::cout,"" "");; 264// std::copy(fVarIndices.begin(), fVarIndices.end(), oi);; 265// std::cout << std::endl;; 266// assert( fVarIndices.size() == fDim);; 267// std::cout << this << std::endl;; 268 ; 269 // set parameter values in fX; 270 SetParValues(npar, fParams.empty() ? nullptr : &fParams.front());; 271 for (unsigned int i = 0; ",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:8991,Modifiability,variab,variables,8991,"( j < NPar() + fDim);; 226 fX[ j ] = x[i];; 227 }; 228// std::cout << ""X : ("";; 229// std::ostream_iterator<double> oi(std::cout,"" , "");; 230// std::copy(fX.begin(), fX.end(), oi);; 231// std::cout << std::endl;; 232 ; 233 return (*fFunc)( fX.empty() ? nullptr : &fX.front() );; 234 }; 235 ; 236 ; 237 /**; 238 implement the required IParamFunction interface; 239 */; 240 double DoEvalPar(const double * x, const double * p ) const override {; 241 SetParValues(NPar(), p);; 242 return DoEval(x);; 243 }; 244 ; 245 ; 246 void DoInit() {; 247 // calculate variable indices and set in X the parameter values; 248 fVarIndices.reserve(fDim);; 249 unsigned int npar = NPar();; 250 for (unsigned int i = 0; i < npar + fDim; ++i) {; 251 bool isVar = true;; 252 for (unsigned int j = 0; j < npar; ++j) {; 253 if (fParIndices[j] == i) {; 254 isVar = false;; 255 break;; 256 }; 257 }; 258 if (isVar) fVarIndices.push_back(i);; 259 }; 260 assert ( fVarIndices.size() == fDim); // otherwise something is wrong; 261 ; 262// std::cout << ""n variables "" << fVarIndices.size() << std::endl;; 263// std::ostream_iterator<int> oi(std::cout,"" "");; 264// std::copy(fVarIndices.begin(), fVarIndices.end(), oi);; 265// std::cout << std::endl;; 266// assert( fVarIndices.size() == fDim);; 267// std::cout << this << std::endl;; 268 ; 269 // set parameter values in fX; 270 SetParValues(npar, fParams.empty() ? nullptr : &fParams.front());; 271 for (unsigned int i = 0; i < npar; ++i) {; 272 unsigned int j = fParIndices[i];; 273 assert ( j < npar + fDim);; 274 fX[j] = fParams[i];; 275 }; 276 ; 277 }; 278 ; 279 // set the parameter values in the cached fX vector; 280 // make const because it might be called from const methods; 281 void SetParValues(unsigned int npar, const double * p) const {; 282 for (unsigned int i = 0; i < npar; ++i) {; 283 unsigned int j = fParIndices[i];; 284 assert ( j < npar + fDim);; 285 fX[j] = p[i];; 286 }; 287 }; 288 ; 289 ; 290 mutable FuncPtr fFunc;; 291 unsigned int fDim;; 292 std::vect",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:5520,Performance,cache,cached,5520,"eturn (*fFunc)( x, p );; 118 }; 119 ; 120 ; 121 FuncPtr fFunc;; 122 unsigned int fDim;; 123 std::vector<double> fParams;; 124 ; 125 ; 126 ; 127};; 128 ; 129 ; 130typedef double( * FreeMultiFunctionPtr ) (const double *);; 131 ; 132/**; 133 WrappedParamGenFunction class to wrap any multi-dimensional function; 134 implementing the operator()(const double * ); 135 in an interface-like IParamFunction, by fixing some of the variables and define them as; 136 parameters.; 137 i.e. transform any multi-dim function in a parametric function; 138 ; 139 @ingroup ParamFunc; 140 ; 141*/; 142template< typename FuncPtr = FreeMultiFunctionPtr >; 143class WrappedParamFunctionGen : public IParamMultiFunction {; 144 ; 145public:; 146 ; 147 /**; 148 Constructor a wrapped function from a pointer to a generic callable object implementation operator()(const double *), the new function dimension, the number of parameters (number of fixed variables) and an array specifying the index of the fixed variables which became; 149 parameters in the new API; 150 */; 151 ; 152 WrappedParamFunctionGen (const FuncPtr & func, unsigned int dim, unsigned int npar, const double * par, const unsigned int * idx) :; 153 fFunc(func),; 154 fDim(dim),; 155 fParams(std::vector<double>(par,par+npar) ),; 156 fParIndices(std::vector<unsigned int>(idx, idx + npar) ),; 157 fX(std::vector<double>(npar+dim) ) // cached vector; 158 {; 159 DoInit();; 160 }; 161 ; 162 /**; 163 Constructor as before but taking now a non - const pointer to a callable object.; 164 This constructor is needed in the case FuncPtr is a std::unique_ptr which has a copy ctor taking non const objects; 165 */; 166 WrappedParamFunctionGen (FuncPtr & func, unsigned int dim, unsigned int npar, const double * par, const unsigned int * idx) :; 167 fFunc(func),; 168 fDim(dim),; 169 fParams(std::vector<double>(par,par+npar) ),; 170 fParIndices(std::vector<unsigned int>(idx, idx + npar) ),; 171 fX(std::vector<double>(npar+dim) ) // cached vector; 172 {; 173 Do",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:6113,Performance,cache,cached,6113,"nst double *), the new function dimension, the number of parameters (number of fixed variables) and an array specifying the index of the fixed variables which became; 149 parameters in the new API; 150 */; 151 ; 152 WrappedParamFunctionGen (const FuncPtr & func, unsigned int dim, unsigned int npar, const double * par, const unsigned int * idx) :; 153 fFunc(func),; 154 fDim(dim),; 155 fParams(std::vector<double>(par,par+npar) ),; 156 fParIndices(std::vector<unsigned int>(idx, idx + npar) ),; 157 fX(std::vector<double>(npar+dim) ) // cached vector; 158 {; 159 DoInit();; 160 }; 161 ; 162 /**; 163 Constructor as before but taking now a non - const pointer to a callable object.; 164 This constructor is needed in the case FuncPtr is a std::unique_ptr which has a copy ctor taking non const objects; 165 */; 166 WrappedParamFunctionGen (FuncPtr & func, unsigned int dim, unsigned int npar, const double * par, const unsigned int * idx) :; 167 fFunc(func),; 168 fDim(dim),; 169 fParams(std::vector<double>(par,par+npar) ),; 170 fParIndices(std::vector<unsigned int>(idx, idx + npar) ),; 171 fX(std::vector<double>(npar+dim) ) // cached vector; 172 {; 173 DoInit();; 174 }; 175 ; 176 /// clone the function; 177 IMultiGenFunction * Clone() const override {; 178 return new WrappedParamFunctionGen(fFunc, fDim, fParams.size(), fParams.empty() ? nullptr : &fParams.front(), fParIndices.empty() ? nullptr : &fParIndices.front());; 179 }; 180 ; 181private:; 182 // copy ctor; 183 WrappedParamFunctionGen(const WrappedParamFunctionGen &) = delete; // not implemented; 184 WrappedParamFunctionGen & operator=(const WrappedParamFunctionGen &) = delete; // not implemented; 185 ; 186public:; 187 ; 188 const double * Parameters() const override {; 189 return fParams.empty() ? nullptr : &fParams.front();; 190 }; 191 ; 192 void SetParameters(const double * p) override {; 193 unsigned int npar = NPar();; 194 std::copy(p, p+ npar, fParams.begin() );; 195 SetParValues(npar, p);; 196 }; 197 ; 198 unsigned in",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:9588,Performance,cache,cached,9588," }; 257 }; 258 if (isVar) fVarIndices.push_back(i);; 259 }; 260 assert ( fVarIndices.size() == fDim); // otherwise something is wrong; 261 ; 262// std::cout << ""n variables "" << fVarIndices.size() << std::endl;; 263// std::ostream_iterator<int> oi(std::cout,"" "");; 264// std::copy(fVarIndices.begin(), fVarIndices.end(), oi);; 265// std::cout << std::endl;; 266// assert( fVarIndices.size() == fDim);; 267// std::cout << this << std::endl;; 268 ; 269 // set parameter values in fX; 270 SetParValues(npar, fParams.empty() ? nullptr : &fParams.front());; 271 for (unsigned int i = 0; i < npar; ++i) {; 272 unsigned int j = fParIndices[i];; 273 assert ( j < npar + fDim);; 274 fX[j] = fParams[i];; 275 }; 276 ; 277 }; 278 ; 279 // set the parameter values in the cached fX vector; 280 // make const because it might be called from const methods; 281 void SetParValues(unsigned int npar, const double * p) const {; 282 for (unsigned int i = 0; i < npar; ++i) {; 283 unsigned int j = fParIndices[i];; 284 assert ( j < npar + fDim);; 285 fX[j] = p[i];; 286 }; 287 }; 288 ; 289 ; 290 mutable FuncPtr fFunc;; 291 unsigned int fDim;; 292 std::vector<double> fParams;; 293 std::vector<unsigned int> fVarIndices;; 294 std::vector<unsigned int> fParIndices;; 295 mutable std::vector<double> fX;; 296 ; 297 ; 298 ; 299};; 300 ; 301 ; 302 } // end namespace Math; 303 ; 304} // end namespace ROOT; 305 ; 306 ; 307#endif /* ROOT_Math_WrappedParamFunction */; IParamFunction.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IParametricFunctionMultiDimTempl< double >; ROOT::Math::WrappedParamFunctionGenWrappedParamGenFunction class to wrap any multi-dimensional function implementing the operator()(cons...Definition WrappedParamFunction.h:143; ROOT::Math::WrappedParamFunctionGen::operator=WrappedParamFunctionGen & operator=(const Wrapped",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:7792,Testability,assert,assert,7792,"191 ; 192 void SetParameters(const double * p) override {; 193 unsigned int npar = NPar();; 194 std::copy(p, p+ npar, fParams.begin() );; 195 SetParValues(npar, p);; 196 }; 197 ; 198 unsigned int NPar() const override { return fParams.size(); }; 199 ; 200 unsigned int NDim() const override { return fDim; }; 201 ; 202// // re-implement this since is more efficient; 203// double operator() (const double * x, const double * p) {; 204// unsigned int n = fX.size();; 205// unsigned int npar = fParams.size();; 206// unsigned j = 0;; 207// return (*fFunc)( fX);; 208// }; 209 ; 210private:; 211 ; 212 /// evaluate the function (re-implement for being more efficient); 213 double DoEval(const double * x) const override {; 214 ; 215// std::cout << this << fDim << "" x : "";; 216// std::ostream_iterator<double> oix(std::cout,"" , "");; 217// std::copy(x, x+fDim, oix);; 218// std::cout << std::endl;; 219// std::cout << ""npar "" << npar << std::endl;; 220// std::cout << fVarIndices.size() << std::endl;; 221// assert ( fVarIndices.size() == fDim); // otherwise something is wrong; 222 ; 223 for (unsigned int i = 0; i < fDim; ++i) {; 224 unsigned int j = fVarIndices[i];; 225 assert ( j < NPar() + fDim);; 226 fX[ j ] = x[i];; 227 }; 228// std::cout << ""X : ("";; 229// std::ostream_iterator<double> oi(std::cout,"" , "");; 230// std::copy(fX.begin(), fX.end(), oi);; 231// std::cout << std::endl;; 232 ; 233 return (*fFunc)( fX.empty() ? nullptr : &fX.front() );; 234 }; 235 ; 236 ; 237 /**; 238 implement the required IParamFunction interface; 239 */; 240 double DoEvalPar(const double * x, const double * p ) const override {; 241 SetParValues(NPar(), p);; 242 return DoEval(x);; 243 }; 244 ; 245 ; 246 void DoInit() {; 247 // calculate variable indices and set in X the parameter values; 248 fVarIndices.reserve(fDim);; 249 unsigned int npar = NPar();; 250 for (unsigned int i = 0; i < npar + fDim; ++i) {; 251 bool isVar = true;; 252 for (unsigned int j = 0; j < npar; ++j) {; 253 if (fParIndices[j] == i)",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:7958,Testability,assert,assert,7958,"198 unsigned int NPar() const override { return fParams.size(); }; 199 ; 200 unsigned int NDim() const override { return fDim; }; 201 ; 202// // re-implement this since is more efficient; 203// double operator() (const double * x, const double * p) {; 204// unsigned int n = fX.size();; 205// unsigned int npar = fParams.size();; 206// unsigned j = 0;; 207// return (*fFunc)( fX);; 208// }; 209 ; 210private:; 211 ; 212 /// evaluate the function (re-implement for being more efficient); 213 double DoEval(const double * x) const override {; 214 ; 215// std::cout << this << fDim << "" x : "";; 216// std::ostream_iterator<double> oix(std::cout,"" , "");; 217// std::copy(x, x+fDim, oix);; 218// std::cout << std::endl;; 219// std::cout << ""npar "" << npar << std::endl;; 220// std::cout << fVarIndices.size() << std::endl;; 221// assert ( fVarIndices.size() == fDim); // otherwise something is wrong; 222 ; 223 for (unsigned int i = 0; i < fDim; ++i) {; 224 unsigned int j = fVarIndices[i];; 225 assert ( j < NPar() + fDim);; 226 fX[ j ] = x[i];; 227 }; 228// std::cout << ""X : ("";; 229// std::ostream_iterator<double> oi(std::cout,"" , "");; 230// std::copy(fX.begin(), fX.end(), oi);; 231// std::cout << std::endl;; 232 ; 233 return (*fFunc)( fX.empty() ? nullptr : &fX.front() );; 234 }; 235 ; 236 ; 237 /**; 238 implement the required IParamFunction interface; 239 */; 240 double DoEvalPar(const double * x, const double * p ) const override {; 241 SetParValues(NPar(), p);; 242 return DoEval(x);; 243 }; 244 ; 245 ; 246 void DoInit() {; 247 // calculate variable indices and set in X the parameter values; 248 fVarIndices.reserve(fDim);; 249 unsigned int npar = NPar();; 250 for (unsigned int i = 0; i < npar + fDim; ++i) {; 251 bool isVar = true;; 252 for (unsigned int j = 0; j < npar; ++j) {; 253 if (fParIndices[j] == i) {; 254 isVar = false;; 255 break;; 256 }; 257 }; 258 if (isVar) fVarIndices.push_back(i);; 259 }; 260 assert ( fVarIndices.size() == fDim); // otherwise something is wrong; 261 ;",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:8892,Testability,assert,assert,8892,"t i = 0; i < fDim; ++i) {; 224 unsigned int j = fVarIndices[i];; 225 assert ( j < NPar() + fDim);; 226 fX[ j ] = x[i];; 227 }; 228// std::cout << ""X : ("";; 229// std::ostream_iterator<double> oi(std::cout,"" , "");; 230// std::copy(fX.begin(), fX.end(), oi);; 231// std::cout << std::endl;; 232 ; 233 return (*fFunc)( fX.empty() ? nullptr : &fX.front() );; 234 }; 235 ; 236 ; 237 /**; 238 implement the required IParamFunction interface; 239 */; 240 double DoEvalPar(const double * x, const double * p ) const override {; 241 SetParValues(NPar(), p);; 242 return DoEval(x);; 243 }; 244 ; 245 ; 246 void DoInit() {; 247 // calculate variable indices and set in X the parameter values; 248 fVarIndices.reserve(fDim);; 249 unsigned int npar = NPar();; 250 for (unsigned int i = 0; i < npar + fDim; ++i) {; 251 bool isVar = true;; 252 for (unsigned int j = 0; j < npar; ++j) {; 253 if (fParIndices[j] == i) {; 254 isVar = false;; 255 break;; 256 }; 257 }; 258 if (isVar) fVarIndices.push_back(i);; 259 }; 260 assert ( fVarIndices.size() == fDim); // otherwise something is wrong; 261 ; 262// std::cout << ""n variables "" << fVarIndices.size() << std::endl;; 263// std::ostream_iterator<int> oi(std::cout,"" "");; 264// std::copy(fVarIndices.begin(), fVarIndices.end(), oi);; 265// std::cout << std::endl;; 266// assert( fVarIndices.size() == fDim);; 267// std::cout << this << std::endl;; 268 ; 269 // set parameter values in fX; 270 SetParValues(npar, fParams.empty() ? nullptr : &fParams.front());; 271 for (unsigned int i = 0; i < npar; ++i) {; 272 unsigned int j = fParIndices[i];; 273 assert ( j < npar + fDim);; 274 fX[j] = fParams[i];; 275 }; 276 ; 277 }; 278 ; 279 // set the parameter values in the cached fX vector; 280 // make const because it might be called from const methods; 281 void SetParValues(unsigned int npar, const double * p) const {; 282 for (unsigned int i = 0; i < npar; ++i) {; 283 unsigned int j = fParIndices[i];; 284 assert ( j < npar + fDim);; 285 fX[j] = p[i];; 286 }; 287 }; 2",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:9192,Testability,assert,assert,9192," 232 ; 233 return (*fFunc)( fX.empty() ? nullptr : &fX.front() );; 234 }; 235 ; 236 ; 237 /**; 238 implement the required IParamFunction interface; 239 */; 240 double DoEvalPar(const double * x, const double * p ) const override {; 241 SetParValues(NPar(), p);; 242 return DoEval(x);; 243 }; 244 ; 245 ; 246 void DoInit() {; 247 // calculate variable indices and set in X the parameter values; 248 fVarIndices.reserve(fDim);; 249 unsigned int npar = NPar();; 250 for (unsigned int i = 0; i < npar + fDim; ++i) {; 251 bool isVar = true;; 252 for (unsigned int j = 0; j < npar; ++j) {; 253 if (fParIndices[j] == i) {; 254 isVar = false;; 255 break;; 256 }; 257 }; 258 if (isVar) fVarIndices.push_back(i);; 259 }; 260 assert ( fVarIndices.size() == fDim); // otherwise something is wrong; 261 ; 262// std::cout << ""n variables "" << fVarIndices.size() << std::endl;; 263// std::ostream_iterator<int> oi(std::cout,"" "");; 264// std::copy(fVarIndices.begin(), fVarIndices.end(), oi);; 265// std::cout << std::endl;; 266// assert( fVarIndices.size() == fDim);; 267// std::cout << this << std::endl;; 268 ; 269 // set parameter values in fX; 270 SetParValues(npar, fParams.empty() ? nullptr : &fParams.front());; 271 for (unsigned int i = 0; i < npar; ++i) {; 272 unsigned int j = fParIndices[i];; 273 assert ( j < npar + fDim);; 274 fX[j] = fParams[i];; 275 }; 276 ; 277 }; 278 ; 279 // set the parameter values in the cached fX vector; 280 // make const because it might be called from const methods; 281 void SetParValues(unsigned int npar, const double * p) const {; 282 for (unsigned int i = 0; i < npar; ++i) {; 283 unsigned int j = fParIndices[i];; 284 assert ( j < npar + fDim);; 285 fX[j] = p[i];; 286 }; 287 }; 288 ; 289 ; 290 mutable FuncPtr fFunc;; 291 unsigned int fDim;; 292 std::vector<double> fParams;; 293 std::vector<unsigned int> fVarIndices;; 294 std::vector<unsigned int> fParIndices;; 295 mutable std::vector<double> fX;; 296 ; 297 ; 298 ; 299};; 300 ; 301 ; 302 } // end namespace Math;",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:9470,Testability,assert,assert,9470," }; 257 }; 258 if (isVar) fVarIndices.push_back(i);; 259 }; 260 assert ( fVarIndices.size() == fDim); // otherwise something is wrong; 261 ; 262// std::cout << ""n variables "" << fVarIndices.size() << std::endl;; 263// std::ostream_iterator<int> oi(std::cout,"" "");; 264// std::copy(fVarIndices.begin(), fVarIndices.end(), oi);; 265// std::cout << std::endl;; 266// assert( fVarIndices.size() == fDim);; 267// std::cout << this << std::endl;; 268 ; 269 // set parameter values in fX; 270 SetParValues(npar, fParams.empty() ? nullptr : &fParams.front());; 271 for (unsigned int i = 0; i < npar; ++i) {; 272 unsigned int j = fParIndices[i];; 273 assert ( j < npar + fDim);; 274 fX[j] = fParams[i];; 275 }; 276 ; 277 }; 278 ; 279 // set the parameter values in the cached fX vector; 280 // make const because it might be called from const methods; 281 void SetParValues(unsigned int npar, const double * p) const {; 282 for (unsigned int i = 0; i < npar; ++i) {; 283 unsigned int j = fParIndices[i];; 284 assert ( j < npar + fDim);; 285 fX[j] = p[i];; 286 }; 287 }; 288 ; 289 ; 290 mutable FuncPtr fFunc;; 291 unsigned int fDim;; 292 std::vector<double> fParams;; 293 std::vector<unsigned int> fVarIndices;; 294 std::vector<unsigned int> fParIndices;; 295 mutable std::vector<double> fX;; 296 ; 297 ; 298 ; 299};; 300 ; 301 ; 302 } // end namespace Math; 303 ; 304} // end namespace ROOT; 305 ; 306 ; 307#endif /* ROOT_Math_WrappedParamFunction */; IParamFunction.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IParametricFunctionMultiDimTempl< double >; ROOT::Math::WrappedParamFunctionGenWrappedParamGenFunction class to wrap any multi-dimensional function implementing the operator()(cons...Definition WrappedParamFunction.h:143; ROOT::Math::WrappedParamFunctionGen::operator=WrappedParamFunctionGen & operator=(const Wrapped",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/WrappedParamFunction_8h_source.html:9828,Testability,assert,assert,9828," }; 257 }; 258 if (isVar) fVarIndices.push_back(i);; 259 }; 260 assert ( fVarIndices.size() == fDim); // otherwise something is wrong; 261 ; 262// std::cout << ""n variables "" << fVarIndices.size() << std::endl;; 263// std::ostream_iterator<int> oi(std::cout,"" "");; 264// std::copy(fVarIndices.begin(), fVarIndices.end(), oi);; 265// std::cout << std::endl;; 266// assert( fVarIndices.size() == fDim);; 267// std::cout << this << std::endl;; 268 ; 269 // set parameter values in fX; 270 SetParValues(npar, fParams.empty() ? nullptr : &fParams.front());; 271 for (unsigned int i = 0; i < npar; ++i) {; 272 unsigned int j = fParIndices[i];; 273 assert ( j < npar + fDim);; 274 fX[j] = fParams[i];; 275 }; 276 ; 277 }; 278 ; 279 // set the parameter values in the cached fX vector; 280 // make const because it might be called from const methods; 281 void SetParValues(unsigned int npar, const double * p) const {; 282 for (unsigned int i = 0; i < npar; ++i) {; 283 unsigned int j = fParIndices[i];; 284 assert ( j < npar + fDim);; 285 fX[j] = p[i];; 286 }; 287 }; 288 ; 289 ; 290 mutable FuncPtr fFunc;; 291 unsigned int fDim;; 292 std::vector<double> fParams;; 293 std::vector<unsigned int> fVarIndices;; 294 std::vector<unsigned int> fParIndices;; 295 mutable std::vector<double> fX;; 296 ; 297 ; 298 ; 299};; 300 ; 301 ; 302 } // end namespace Math; 303 ; 304} // end namespace ROOT; 305 ; 306 ; 307#endif /* ROOT_Math_WrappedParamFunction */; IParamFunction.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; ROOT::Math::IBaseFunctionMultiDimTemplDocumentation for the abstract class IBaseFunctionMultiDim.Definition IFunction.h:61; ROOT::Math::IParametricFunctionMultiDimTempl< double >; ROOT::Math::WrappedParamFunctionGenWrappedParamGenFunction class to wrap any multi-dimensional function implementing the operator()(cons...Definition WrappedParamFunction.h:143; ROOT::Math::WrappedParamFunctionGen::operator=WrappedParamFunctionGen & operator=(const Wrapped",MatchSource.WIKI,doc/master/WrappedParamFunction_8h_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/WrappedParamFunction_8h_source.html
https://root.cern/doc/master/X3DBuffer_8c.html:294,Integrability,depend,dependency,294,". ROOT: graf3d/g3d/src/X3DBuffer.c File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Functions |; Variables ; X3DBuffer.c File Reference. #include ""X3DBuffer.h""; #include ""../../x3d/src/X3DDefs.h""; #include <stdio.h>; #include <stdlib.h>. Include dependency graph for X3DBuffer.c:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Functions; int AllocateX3DBuffer ();  ; void FillX3DBuffer (X3DBuffer *buff);  ; Size3D * gFuncSize3D ();  . Variables; Color * colors;  ; int currPoint = 0;  ; int currPoly = 0;  ; int currSeg = 0;  ; Size3D gVarSize3D;  ; point * points;  ; polygon * polys;  ; segment * segs;  . Function Documentation. ◆ AllocateX3DBuffer(). int AllocateX3DBuffer ; (; ). Definition at line 27 of file X3DBuffer.c. ◆ FillX3DBuffer(). void FillX3DBuffer ; (; X3DBuffer * ; buff). Definition at line 142 of file X3DBuffer.c. ◆ gFuncSize3D(). Size3D * gFuncSize3D ; (; ). Definition at line 10 of file X3DBuffer.c. Variable Documentation. ◆ colors. Color* colors. Definition at line 21 of file X3DBuffer.c. ◆ currPoint. int currPoint = 0. Definition at line 17 of file X3DBuffer.c. ◆ currPoly. int currPoly = 0. Definition at line 19 of file X3DBuffer.c. ◆ currSeg. int currSeg = 0. Definition at line 18 of file X3DBuffer.c. ◆ gVarSize3D. Size3D gVarSize3D. Definition at line 9 of file X3DBuffer.c. ◆ points. point* points. Definition at line 22 of file X3DBuffer.c. ◆ polys. polygon* polys. Definition at line 24 of file X3DBuffer.c. ◆ segs. segment* segs. Definition at line 23 of file X3DBuffer.c. graf3dg3dsrcX3DBuffer.c. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:18 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/X3DBuffer_8c.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:4233,Availability,error,error,4233,"colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;; 106 }; 107 }; 108 ; 109 ; 110 /*; 111 * Allocate memory for polygons; 112 */; 113 ; 114 if (gSize3D.numPolys) {; 115 polys = (polygon *) calloc(gSize3D.numPolys, sizeof (polygon));; 116 if (!polys) {; 117 puts (""Unable to allocate memory for polygons !"");; 118 ret = 0;; 119 }; 120 }; 121 ; 122 /*; 123 * In case of error, free allocated memory; 124 */; 125 ; 126 ; 127 if (!ret) {; 128 if (points) free (points);; 129 if (colors) free (colors);; 130 if (segs) free (segs);; 131 if (polys) free (polys);; 132 ; 133 points = NULL;; 134 colors = NULL;; 135 segs = NULL;; 136 polys = NULL;; 137 }; 138 ; 139 return (ret);; 140}; 141 ; 142void FillX3DBuffer (X3DBuffer *buff); 143{; 144/******************************************************************************; 145 Read points, Read segments & Read polygons; 146******************************************************************************/; 147 ; 148 ; 149 int n, i, j, p, q, c;; 150 int oldNumOfPoints, oldNumOfSegments;; 151 ; 152 if (buff) {; 153 ; 154 oldNumOfPoints = currPoint;; 155 oldNumOfSegments = currSeg;; 156 ; 157 /*; 158 * Read points; 159 */; 160 ; 161 for (i = 0; i < buff->numPoints; i++, currPoint++) {; 162 points[currPoint].x = buff->points[3*i ];; 163 points[currPoint].y = buff->points[3*i+1];; 164 points[currPoint].z = buff->points[3*i+2];; 165 }; 166 ; 167 ; 168 /*; 169 * Read segments; 170 */; 171 ; 172 for (i = 0; i < buff->numSegs; i++, currSeg++) {; 173 c = buff->segs[3*i];; 174 p = oldNumOfPoints + buff->segs[3*i+1];; 175 q = oldNumOfPoints + buff->segs[3*i+2];; 176 ; 177 segs[currSeg].color = &(colors[c]);; 178 segs[currSeg].P = &(points[p]);; 179 segs[currSeg].Q = &(points[q]);; 180",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:1316,Energy Efficiency,allocate,allocate,1316,"ed (__MWERKS__); 13 void FillX3DBuffer (X3DBuffer *buff) { }; 14 int AllocateX3DBuffer () { return 0;}; 15#else; 16 ; 17int currPoint = 0;; 18int currSeg = 0;; 19int currPoly = 0;; 20 ; 21Color *colors;; 22point *points;; 23segment *segs;; 24polygon *polys;; 25 ; 26 ; 27int AllocateX3DBuffer (); 28{; 29/******************************************************************************; 30 Allocate memory for points, colors, segments and polygons.; 31 Returns 1 if OK, otherwise 0.; 32******************************************************************************/; 33 ; 34 int ret = 1;; 35 ; 36 points = NULL;; 37 colors = NULL;; 38 segs = NULL;; 39 polys = NULL;; 40 ; 41 /*; 42 * Allocate memory for points; 43 */; 44 ; 45 if (gSize3D.numPoints) {; 46 points = (point *) calloc(gSize3D.numPoints, sizeof (point));; 47 if (!points) {; 48 puts (""Unable to allocate memory for points !"");; 49 ret = 0;; 50 }; 51 }; 52 else return (0); /* if there are no points, return back */; 53 ; 54 ; 55 ; 56 /*; 57 * Allocate memory for colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117;",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:1595,Energy Efficiency,allocate,allocate,1595,"ed (__MWERKS__); 13 void FillX3DBuffer (X3DBuffer *buff) { }; 14 int AllocateX3DBuffer () { return 0;}; 15#else; 16 ; 17int currPoint = 0;; 18int currSeg = 0;; 19int currPoly = 0;; 20 ; 21Color *colors;; 22point *points;; 23segment *segs;; 24polygon *polys;; 25 ; 26 ; 27int AllocateX3DBuffer (); 28{; 29/******************************************************************************; 30 Allocate memory for points, colors, segments and polygons.; 31 Returns 1 if OK, otherwise 0.; 32******************************************************************************/; 33 ; 34 int ret = 1;; 35 ; 36 points = NULL;; 37 colors = NULL;; 38 segs = NULL;; 39 polys = NULL;; 40 ; 41 /*; 42 * Allocate memory for points; 43 */; 44 ; 45 if (gSize3D.numPoints) {; 46 points = (point *) calloc(gSize3D.numPoints, sizeof (point));; 47 if (!points) {; 48 puts (""Unable to allocate memory for points !"");; 49 ret = 0;; 50 }; 51 }; 52 else return (0); /* if there are no points, return back */; 53 ; 54 ; 55 ; 56 /*; 57 * Allocate memory for colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117;",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:1693,Energy Efficiency,green,green,1693,"lygon *polys;; 25 ; 26 ; 27int AllocateX3DBuffer (); 28{; 29/******************************************************************************; 30 Allocate memory for points, colors, segments and polygons.; 31 Returns 1 if OK, otherwise 0.; 32******************************************************************************/; 33 ; 34 int ret = 1;; 35 ; 36 points = NULL;; 37 colors = NULL;; 38 segs = NULL;; 39 polys = NULL;; 40 ; 41 /*; 42 * Allocate memory for points; 43 */; 44 ; 45 if (gSize3D.numPoints) {; 46 points = (point *) calloc(gSize3D.numPoints, sizeof (point));; 47 if (!points) {; 48 puts (""Unable to allocate memory for points !"");; 49 ret = 0;; 50 }; 51 }; 52 else return (0); /* if there are no points, return back */; 53 ; 54 ; 55 ; 56 /*; 57 * Allocate memory for colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:1763,Energy Efficiency,green,green,1763,"*********************************************************************; 30 Allocate memory for points, colors, segments and polygons.; 31 Returns 1 if OK, otherwise 0.; 32******************************************************************************/; 33 ; 34 int ret = 1;; 35 ; 36 points = NULL;; 37 colors = NULL;; 38 segs = NULL;; 39 polys = NULL;; 40 ; 41 /*; 42 * Allocate memory for points; 43 */; 44 ; 45 if (gSize3D.numPoints) {; 46 points = (point *) calloc(gSize3D.numPoints, sizeof (point));; 47 if (!points) {; 48 puts (""Unable to allocate memory for points !"");; 49 ret = 0;; 50 }; 51 }; 52 else return (0); /* if there are no points, return back */; 53 ; 54 ; 55 ; 56 /*; 57 * Allocate memory for colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colo",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:1835,Energy Efficiency,green,green,1835,"0 Allocate memory for points, colors, segments and polygons.; 31 Returns 1 if OK, otherwise 0.; 32******************************************************************************/; 33 ; 34 int ret = 1;; 35 ; 36 points = NULL;; 37 colors = NULL;; 38 segs = NULL;; 39 polys = NULL;; 40 ; 41 /*; 42 * Allocate memory for points; 43 */; 44 ; 45 if (gSize3D.numPoints) {; 46 points = (point *) calloc(gSize3D.numPoints, sizeof (point));; 47 if (!points) {; 48 puts (""Unable to allocate memory for points !"");; 49 ret = 0;; 50 }; 51 }; 52 else return (0); /* if there are no points, return back */; 53 ; 54 ; 55 ; 56 /*; 57 * Allocate memory for colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; col",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:1907,Energy Efficiency,green,green,1907," 1 if OK, otherwise 0.; 32******************************************************************************/; 33 ; 34 int ret = 1;; 35 ; 36 points = NULL;; 37 colors = NULL;; 38 segs = NULL;; 39 polys = NULL;; 40 ; 41 /*; 42 * Allocate memory for points; 43 */; 44 ; 45 if (gSize3D.numPoints) {; 46 points = (point *) calloc(gSize3D.numPoints, sizeof (point));; 47 if (!points) {; 48 puts (""Unable to allocate memory for points !"");; 49 ret = 0;; 50 }; 51 }; 52 else return (0); /* if there are no points, return back */; 53 ; 54 ; 55 ; 56 /*; 57 * Allocate memory for colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; col",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:1979,Energy Efficiency,green,green,1979,"********************************/; 33 ; 34 int ret = 1;; 35 ; 36 points = NULL;; 37 colors = NULL;; 38 segs = NULL;; 39 polys = NULL;; 40 ; 41 /*; 42 * Allocate memory for points; 43 */; 44 ; 45 if (gSize3D.numPoints) {; 46 points = (point *) calloc(gSize3D.numPoints, sizeof (point));; 47 if (!points) {; 48 puts (""Unable to allocate memory for points !"");; 49 ret = 0;; 50 }; 51 }; 52 else return (0); /* if there are no points, return back */; 53 ; 54 ; 55 ; 56 /*; 57 * Allocate memory for colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; co",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:2049,Energy Efficiency,green,green,2049,"s = NULL;; 37 colors = NULL;; 38 segs = NULL;; 39 polys = NULL;; 40 ; 41 /*; 42 * Allocate memory for points; 43 */; 44 ; 45 if (gSize3D.numPoints) {; 46 points = (point *) calloc(gSize3D.numPoints, sizeof (point));; 47 if (!points) {; 48 puts (""Unable to allocate memory for points !"");; 49 ret = 0;; 50 }; 51 }; 52 else return (0); /* if there are no points, return back */; 53 ; 54 ; 55 ; 56 /*; 57 * Allocate memory for colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; ",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:2119,Energy Efficiency,green,green,2119,"41 /*; 42 * Allocate memory for points; 43 */; 44 ; 45 if (gSize3D.numPoints) {; 46 points = (point *) calloc(gSize3D.numPoints, sizeof (point));; 47 if (!points) {; 48 puts (""Unable to allocate memory for points !"");; 49 ret = 0;; 50 }; 51 }; 52 else return (0); /* if there are no points, return back */; 53 ; 54 ; 55 ; 56 /*; 57 * Allocate memory for colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:2189,Energy Efficiency,green,green,2189,"Points) {; 46 points = (point *) calloc(gSize3D.numPoints, sizeof (point));; 47 if (!points) {; 48 puts (""Unable to allocate memory for points !"");; 49 ret = 0;; 50 }; 51 }; 52 else return (0); /* if there are no points, return back */; 53 ; 54 ; 55 ; 56 /*; 57 * Allocate memory for colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 2",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:2260,Energy Efficiency,green,green,2260,"t));; 47 if (!points) {; 48 puts (""Unable to allocate memory for points !"");; 49 ret = 0;; 50 }; 51 }; 52 else return (0); /* if there are no points, return back */; 53 ; 54 ; 55 ; 56 /*; 57 * Allocate memory for colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = ",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:2330,Energy Efficiency,green,green,2330,"s !"");; 49 ret = 0;; 50 }; 51 }; 52 else return (0); /* if there are no points, return back */; 53 ; 54 ; 55 ; 56 /*; 57 * Allocate memory for colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green ",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:2400,Energy Efficiency,green,green,2400," points, return back */; 53 ; 54 ; 55 ; 56 /*; 57 * Allocate memory for colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].gree",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:2472,Energy Efficiency,green,green,2472,"colors; 58 */; 59 ; 60 colors = (Color *) calloc(28+4, sizeof (Color));; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].gree",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:2544,Energy Efficiency,green,green,2544,"; 61 if(!colors) {; 62 puts (""Unable to allocate memory for colors !"");; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].gree",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:2615,Energy Efficiency,green,green,2615,; 63 ret = 0;; 64 }; 65 else {; 66 colors[ 0].red = 92; colors[ 0].green = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].gr,MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:2686,Energy Efficiency,green,green,2686,n = 92; colors[0].blue = 92;; 67 colors[ 1].red = 122; colors[ 1].green = 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate,MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:2758,Energy Efficiency,green,green,2758, 122; colors[1].blue = 122;; 68 colors[ 2].red = 184; colors[ 2].green = 184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs ,MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:2831,Energy Efficiency,green,green,2831,"184; colors[2].blue = 184;; 69 colors[ 3].red = 215; colors[ 3].green = 215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs)",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:2903,Energy Efficiency,green,green,2903,"215; colors[3].blue = 215;; 70 colors[ 4].red = 138; colors[ 4].green = 15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:2975,Energy Efficiency,green,green,2975,"15; colors[4].blue = 15;; 71 colors[ 5].red = 184; colors[ 5].green = 20; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;; 106 }; 107 }; 108 ; 109 ; 110 /*; 111 * Allocate memory for polygons; ",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:3047,Energy Efficiency,green,green,3047,"; colors[5].blue = 20;; 72 colors[ 6].red = 235; colors[ 6].green = 71; colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;; 106 }; 107 }; 108 ; 109 ; 110 /*; 111 * Allocate memory for polygons; 112 */; 113 ; 114 if (gSize3D.numPolys) {; 115 polys = (polygon *) callo",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:3120,Energy Efficiency,green,green,3120,"colors[6].blue = 71;; 73 colors[ 7].red = 240; colors[ 7].green = 117; colors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;; 106 }; 107 }; 108 ; 109 ; 110 /*; 111 * Allocate memory for polygons; 112 */; 113 ; 114 if (gSize3D.numPolys) {; 115 polys = (polygon *) calloc(gSize3D.numPolys, sizeof (polygon));; 116 if (!polys) {; 117 puts (""Una",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:3192,Energy Efficiency,green,green,3192,"olors[7].blue = 117;; 74 colors[ 8].red = 15; colors[ 8].green = 138; colors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;; 106 }; 107 }; 108 ; 109 ; 110 /*; 111 * Allocate memory for polygons; 112 */; 113 ; 114 if (gSize3D.numPolys) {; 115 polys = (polygon *) calloc(gSize3D.numPolys, sizeof (polygon));; 116 if (!polys) {; 117 puts (""Unable to allocate memory for polygons !"");; 118 ret = 0;; 119 }; 120 }; 12",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:3264,Energy Efficiency,green,green,3264,"lors[8].blue = 15;; 75 colors[ 9].red = 20; colors[ 9].green = 184; colors[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;; 106 }; 107 }; 108 ; 109 ; 110 /*; 111 * Allocate memory for polygons; 112 */; 113 ; 114 if (gSize3D.numPolys) {; 115 polys = (polygon *) calloc(gSize3D.numPolys, sizeof (polygon));; 116 if (!polys) {; 117 puts (""Unable to allocate memory for polygons !"");; 118 ret = 0;; 119 }; 120 }; 121 ; 122 /*; 123 * In case of error, free allocated memory; 124 */; 125 ;",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:3336,Energy Efficiency,green,green,3336,"s[9].blue = 20;; 76 colors[10].red = 71; colors[10].green = 235; colors[10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;; 106 }; 107 }; 108 ; 109 ; 110 /*; 111 * Allocate memory for polygons; 112 */; 113 ; 114 if (gSize3D.numPolys) {; 115 polys = (polygon *) calloc(gSize3D.numPolys, sizeof (polygon));; 116 if (!polys) {; 117 puts (""Unable to allocate memory for polygons !"");; 118 ret = 0;; 119 }; 120 }; 121 ; 122 /*; 123 * In case of error, free allocated memory; 124 */; 125 ; 126 ; 127 if (!ret) {; 128 if (points) free (points);; 129 if (colors) ",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:3408,Energy Efficiency,green,green,3408,"10].blue = 71;; 77 colors[11].red = 117; colors[11].green = 240; colors[11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;; 106 }; 107 }; 108 ; 109 ; 110 /*; 111 * Allocate memory for polygons; 112 */; 113 ; 114 if (gSize3D.numPolys) {; 115 polys = (polygon *) calloc(gSize3D.numPolys, sizeof (polygon));; 116 if (!polys) {; 117 puts (""Unable to allocate memory for polygons !"");; 118 ret = 0;; 119 }; 120 }; 121 ; 122 /*; 123 * In case of error, free allocated memory; 124 */; 125 ; 126 ; 127 if (!ret) {; 128 if (points) free (points);; 129 if (colors) free (colors);; 130 if (segs) free (segs);; 131 if (polys) free (polys);",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:3480,Energy Efficiency,green,green,3480,"11].blue = 117;; 78 colors[12].red = 15; colors[12].green = 15; colors[12].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;; 106 }; 107 }; 108 ; 109 ; 110 /*; 111 * Allocate memory for polygons; 112 */; 113 ; 114 if (gSize3D.numPolys) {; 115 polys = (polygon *) calloc(gSize3D.numPolys, sizeof (polygon));; 116 if (!polys) {; 117 puts (""Unable to allocate memory for polygons !"");; 118 ret = 0;; 119 }; 120 }; 121 ; 122 /*; 123 * In case of error, free allocated memory; 124 */; 125 ; 126 ; 127 if (!ret) {; 128 if (points) free (points);; 129 if (colors) free (colors);; 130 if (segs) free (segs);; 131 if (polys) free (polys);; 132 ; 133 points = NULL;; 134 colors = NULL;; 135 segs = NULL;; 136 po",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:3552,Energy Efficiency,green,green,3552,"2].blue = 138;; 79 colors[13].red = 20; colors[13].green = 20; colors[13].blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;; 106 }; 107 }; 108 ; 109 ; 110 /*; 111 * Allocate memory for polygons; 112 */; 113 ; 114 if (gSize3D.numPolys) {; 115 polys = (polygon *) calloc(gSize3D.numPolys, sizeof (polygon));; 116 if (!polys) {; 117 puts (""Unable to allocate memory for polygons !"");; 118 ret = 0;; 119 }; 120 }; 121 ; 122 /*; 123 * In case of error, free allocated memory; 124 */; 125 ; 126 ; 127 if (!ret) {; 128 if (points) free (points);; 129 if (colors) free (colors);; 130 if (segs) free (segs);; 131 if (polys) free (polys);; 132 ; 133 points = NULL;; 134 colors = NULL;; 135 segs = NULL;; 136 polys = NULL;; 137 }; 138 ; 139 return (ret);; 140}; 141 ; 142void FillX3D",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:3625,Energy Efficiency,green,green,3625,".blue = 184;; 80 colors[14].red = 71; colors[14].green = 71; colors[14].blue = 235;; 81 colors[15].red = 117; colors[15].green = 117; colors[15].blue = 240;; 82 colors[16].red = 138; colors[16].green = 138; colors[16].blue = 15;; 83 colors[17].red = 184; colors[17].green = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;; 106 }; 107 }; 108 ; 109 ; 110 /*; 111 * Allocate memory for polygons; 112 */; 113 ; 114 if (gSize3D.numPolys) {; 115 polys = (polygon *) calloc(gSize3D.numPolys, sizeof (polygon));; 116 if (!polys) {; 117 puts (""Unable to allocate memory for polygons !"");; 118 ret = 0;; 119 }; 120 }; 121 ; 122 /*; 123 * In case of error, free allocated memory; 124 */; 125 ; 126 ; 127 if (!ret) {; 128 if (points) free (points);; 129 if (colors) free (colors);; 130 if (segs) free (segs);; 131 if (polys) free (polys);; 132 ; 133 points = NULL;; 134 colors = NULL;; 135 segs = NULL;; 136 polys = NULL;; 137 }; 138 ; 139 return (ret);; 140}; 141 ; 142void FillX3DBuffer (X3DBuffer *buff); 143{; 144/*************************************",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:3868,Energy Efficiency,allocate,allocate,3868," = 184; colors[17].blue = 20;; 84 colors[18].red = 235; colors[18].green = 235; colors[18].blue = 71;; 85 colors[19].red = 240; colors[19].green = 240; colors[19].blue = 117;; 86 colors[20].red = 138; colors[20].green = 15; colors[20].blue = 138;; 87 colors[21].red = 184; colors[21].green = 20; colors[21].blue = 184;; 88 colors[22].red = 235; colors[22].green = 71; colors[22].blue = 235;; 89 colors[23].red = 240; colors[23].green = 117; colors[23].blue = 240;; 90 colors[24].red = 15; colors[24].green = 138; colors[24].blue = 138;; 91 colors[25].red = 20; colors[25].green = 184; colors[25].blue = 184;; 92 colors[26].red = 71; colors[26].green = 235; colors[26].blue = 235;; 93 colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;; 106 }; 107 }; 108 ; 109 ; 110 /*; 111 * Allocate memory for polygons; 112 */; 113 ; 114 if (gSize3D.numPolys) {; 115 polys = (polygon *) calloc(gSize3D.numPolys, sizeof (polygon));; 116 if (!polys) {; 117 puts (""Unable to allocate memory for polygons !"");; 118 ret = 0;; 119 }; 120 }; 121 ; 122 /*; 123 * In case of error, free allocated memory; 124 */; 125 ; 126 ; 127 if (!ret) {; 128 if (points) free (points);; 129 if (colors) free (colors);; 130 if (segs) free (segs);; 131 if (polys) free (polys);; 132 ; 133 points = NULL;; 134 colors = NULL;; 135 segs = NULL;; 136 polys = NULL;; 137 }; 138 ; 139 return (ret);; 140}; 141 ; 142void FillX3DBuffer (X3DBuffer *buff); 143{; 144/******************************************************************************; 145 Read points, Read segments & Read polygons; 146******************************************************************************/; 147 ; 148 ; 149 int n, i, j, p, q, c;; 150 int oldNumOfPoints, oldNumOfSegments;; 151 ; 152 if (b",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:4139,Energy Efficiency,allocate,allocate,4139,"colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;; 106 }; 107 }; 108 ; 109 ; 110 /*; 111 * Allocate memory for polygons; 112 */; 113 ; 114 if (gSize3D.numPolys) {; 115 polys = (polygon *) calloc(gSize3D.numPolys, sizeof (polygon));; 116 if (!polys) {; 117 puts (""Unable to allocate memory for polygons !"");; 118 ret = 0;; 119 }; 120 }; 121 ; 122 /*; 123 * In case of error, free allocated memory; 124 */; 125 ; 126 ; 127 if (!ret) {; 128 if (points) free (points);; 129 if (colors) free (colors);; 130 if (segs) free (segs);; 131 if (polys) free (polys);; 132 ; 133 points = NULL;; 134 colors = NULL;; 135 segs = NULL;; 136 polys = NULL;; 137 }; 138 ; 139 return (ret);; 140}; 141 ; 142void FillX3DBuffer (X3DBuffer *buff); 143{; 144/******************************************************************************; 145 Read points, Read segments & Read polygons; 146******************************************************************************/; 147 ; 148 ; 149 int n, i, j, p, q, c;; 150 int oldNumOfPoints, oldNumOfSegments;; 151 ; 152 if (buff) {; 153 ; 154 oldNumOfPoints = currPoint;; 155 oldNumOfSegments = currSeg;; 156 ; 157 /*; 158 * Read points; 159 */; 160 ; 161 for (i = 0; i < buff->numPoints; i++, currPoint++) {; 162 points[currPoint].x = buff->points[3*i ];; 163 points[currPoint].y = buff->points[3*i+1];; 164 points[currPoint].z = buff->points[3*i+2];; 165 }; 166 ; 167 ; 168 /*; 169 * Read segments; 170 */; 171 ; 172 for (i = 0; i < buff->numSegs; i++, currSeg++) {; 173 c = buff->segs[3*i];; 174 p = oldNumOfPoints + buff->segs[3*i+1];; 175 q = oldNumOfPoints + buff->segs[3*i+2];; 176 ; 177 segs[currSeg].color = &(colors[c]);; 178 segs[currSeg].P = &(points[p]);; 179 segs[currSeg].Q = &(points[q]);; 180",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:4245,Energy Efficiency,allocate,allocated,4245,"colors[27].red = 117; colors[27].green = 240; colors[27].blue = 240;; 94 }; 95 ; 96 ; 97 /*; 98 * Allocate memory for segments; 99 */; 100 ; 101 if (gSize3D.numSegs) {; 102 segs = (segment *) calloc (gSize3D.numSegs, sizeof (segment));; 103 if (!segs) {; 104 puts (""Unable to allocate memory for segments !"");; 105 ret = 0;; 106 }; 107 }; 108 ; 109 ; 110 /*; 111 * Allocate memory for polygons; 112 */; 113 ; 114 if (gSize3D.numPolys) {; 115 polys = (polygon *) calloc(gSize3D.numPolys, sizeof (polygon));; 116 if (!polys) {; 117 puts (""Unable to allocate memory for polygons !"");; 118 ret = 0;; 119 }; 120 }; 121 ; 122 /*; 123 * In case of error, free allocated memory; 124 */; 125 ; 126 ; 127 if (!ret) {; 128 if (points) free (points);; 129 if (colors) free (colors);; 130 if (segs) free (segs);; 131 if (polys) free (polys);; 132 ; 133 points = NULL;; 134 colors = NULL;; 135 segs = NULL;; 136 polys = NULL;; 137 }; 138 ; 139 return (ret);; 140}; 141 ; 142void FillX3DBuffer (X3DBuffer *buff); 143{; 144/******************************************************************************; 145 Read points, Read segments & Read polygons; 146******************************************************************************/; 147 ; 148 ; 149 int n, i, j, p, q, c;; 150 int oldNumOfPoints, oldNumOfSegments;; 151 ; 152 if (buff) {; 153 ; 154 oldNumOfPoints = currPoint;; 155 oldNumOfSegments = currSeg;; 156 ; 157 /*; 158 * Read points; 159 */; 160 ; 161 for (i = 0; i < buff->numPoints; i++, currPoint++) {; 162 points[currPoint].x = buff->points[3*i ];; 163 points[currPoint].y = buff->points[3*i+1];; 164 points[currPoint].z = buff->points[3*i+2];; 165 }; 166 ; 167 ; 168 /*; 169 * Read segments; 170 */; 171 ; 172 for (i = 0; i < buff->numSegs; i++, currSeg++) {; 173 c = buff->segs[3*i];; 174 p = oldNumOfPoints + buff->segs[3*i+1];; 175 q = oldNumOfPoints + buff->segs[3*i+2];; 176 ; 177 segs[currSeg].color = &(colors[c]);; 178 segs[currSeg].P = &(points[p]);; 179 segs[currSeg].Q = &(points[q]);; 180",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:5785,Energy Efficiency,allocate,allocate,5785,"*******************/; 147 ; 148 ; 149 int n, i, j, p, q, c;; 150 int oldNumOfPoints, oldNumOfSegments;; 151 ; 152 if (buff) {; 153 ; 154 oldNumOfPoints = currPoint;; 155 oldNumOfSegments = currSeg;; 156 ; 157 /*; 158 * Read points; 159 */; 160 ; 161 for (i = 0; i < buff->numPoints; i++, currPoint++) {; 162 points[currPoint].x = buff->points[3*i ];; 163 points[currPoint].y = buff->points[3*i+1];; 164 points[currPoint].z = buff->points[3*i+2];; 165 }; 166 ; 167 ; 168 /*; 169 * Read segments; 170 */; 171 ; 172 for (i = 0; i < buff->numSegs; i++, currSeg++) {; 173 c = buff->segs[3*i];; 174 p = oldNumOfPoints + buff->segs[3*i+1];; 175 q = oldNumOfPoints + buff->segs[3*i+2];; 176 ; 177 segs[currSeg].color = &(colors[c]);; 178 segs[currSeg].P = &(points[p]);; 179 segs[currSeg].Q = &(points[q]);; 180 ; 181 /*; 182 * Update points' segment lists; 183 */; 184 ; 185 if(points[p].numSegs == 0){; 186 if((points[p].segs = (segment **)calloc(1, sizeof(segment *))) == NULL){; 187 puts(""Unable to allocate memory for point segments !"");; 188 return;; 189 }; 190 }else{; 191 if((points[p].segs = (segment **)realloc(points[p].segs,; 192 (points[p].numSegs + 1) * sizeof(segment *))) == NULL){; 193 puts(""Unable to allocate memory for point segments !"");; 194 return;; 195 }; 196 }; 197 ; 198 if(points[q].numSegs == 0){; 199 if((points[q].segs = (segment **)calloc(1, sizeof(segment *))) == NULL){; 200 puts(""Unable to allocate memory for point segments !"");; 201 return;; 202 }; 203 }else{; 204 if((points[q].segs = (segment **)realloc(points[q].segs,; 205 (points[q].numSegs + 1) * sizeof(segment *))) == NULL){; 206 puts(""Unable to allocate memory for point segments !"");; 207 return;; 208 }; 209 }; 210 points[p].segs[points[p].numSegs] = &(segs[currSeg]);; 211 points[q].segs[points[q].numSegs] = &(segs[currSeg]);; 212 points[p].numSegs++;; 213 points[q].numSegs++;; 214 ; 215 }; 216 ; 217 /*; 218 * Read polygons; 219 */; 220 ; 221 n = 0;; 222 ; 223 for (i = 0; i < buff->numPolys; i++, currPoly++",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:6001,Energy Efficiency,allocate,allocate,6001," points; 159 */; 160 ; 161 for (i = 0; i < buff->numPoints; i++, currPoint++) {; 162 points[currPoint].x = buff->points[3*i ];; 163 points[currPoint].y = buff->points[3*i+1];; 164 points[currPoint].z = buff->points[3*i+2];; 165 }; 166 ; 167 ; 168 /*; 169 * Read segments; 170 */; 171 ; 172 for (i = 0; i < buff->numSegs; i++, currSeg++) {; 173 c = buff->segs[3*i];; 174 p = oldNumOfPoints + buff->segs[3*i+1];; 175 q = oldNumOfPoints + buff->segs[3*i+2];; 176 ; 177 segs[currSeg].color = &(colors[c]);; 178 segs[currSeg].P = &(points[p]);; 179 segs[currSeg].Q = &(points[q]);; 180 ; 181 /*; 182 * Update points' segment lists; 183 */; 184 ; 185 if(points[p].numSegs == 0){; 186 if((points[p].segs = (segment **)calloc(1, sizeof(segment *))) == NULL){; 187 puts(""Unable to allocate memory for point segments !"");; 188 return;; 189 }; 190 }else{; 191 if((points[p].segs = (segment **)realloc(points[p].segs,; 192 (points[p].numSegs + 1) * sizeof(segment *))) == NULL){; 193 puts(""Unable to allocate memory for point segments !"");; 194 return;; 195 }; 196 }; 197 ; 198 if(points[q].numSegs == 0){; 199 if((points[q].segs = (segment **)calloc(1, sizeof(segment *))) == NULL){; 200 puts(""Unable to allocate memory for point segments !"");; 201 return;; 202 }; 203 }else{; 204 if((points[q].segs = (segment **)realloc(points[q].segs,; 205 (points[q].numSegs + 1) * sizeof(segment *))) == NULL){; 206 puts(""Unable to allocate memory for point segments !"");; 207 return;; 208 }; 209 }; 210 points[p].segs[points[p].numSegs] = &(segs[currSeg]);; 211 points[q].segs[points[q].numSegs] = &(segs[currSeg]);; 212 points[p].numSegs++;; 213 points[q].numSegs++;; 214 ; 215 }; 216 ; 217 /*; 218 * Read polygons; 219 */; 220 ; 221 n = 0;; 222 ; 223 for (i = 0; i < buff->numPolys; i++, currPoly++) {; 224 c = buff->polys[n++];; 225 polys[currPoly].color = &(colors)[c];; 226 polys[currPoly].numSegs = buff->polys[n++];; 227 ; 228 polys[currPoly].segs = (segment **) calloc(polys[currPoly].numSegs, sizeof(segment *));; ",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:6206,Energy Efficiency,allocate,allocate,6206,"z = buff->points[3*i+2];; 165 }; 166 ; 167 ; 168 /*; 169 * Read segments; 170 */; 171 ; 172 for (i = 0; i < buff->numSegs; i++, currSeg++) {; 173 c = buff->segs[3*i];; 174 p = oldNumOfPoints + buff->segs[3*i+1];; 175 q = oldNumOfPoints + buff->segs[3*i+2];; 176 ; 177 segs[currSeg].color = &(colors[c]);; 178 segs[currSeg].P = &(points[p]);; 179 segs[currSeg].Q = &(points[q]);; 180 ; 181 /*; 182 * Update points' segment lists; 183 */; 184 ; 185 if(points[p].numSegs == 0){; 186 if((points[p].segs = (segment **)calloc(1, sizeof(segment *))) == NULL){; 187 puts(""Unable to allocate memory for point segments !"");; 188 return;; 189 }; 190 }else{; 191 if((points[p].segs = (segment **)realloc(points[p].segs,; 192 (points[p].numSegs + 1) * sizeof(segment *))) == NULL){; 193 puts(""Unable to allocate memory for point segments !"");; 194 return;; 195 }; 196 }; 197 ; 198 if(points[q].numSegs == 0){; 199 if((points[q].segs = (segment **)calloc(1, sizeof(segment *))) == NULL){; 200 puts(""Unable to allocate memory for point segments !"");; 201 return;; 202 }; 203 }else{; 204 if((points[q].segs = (segment **)realloc(points[q].segs,; 205 (points[q].numSegs + 1) * sizeof(segment *))) == NULL){; 206 puts(""Unable to allocate memory for point segments !"");; 207 return;; 208 }; 209 }; 210 points[p].segs[points[p].numSegs] = &(segs[currSeg]);; 211 points[q].segs[points[q].numSegs] = &(segs[currSeg]);; 212 points[p].numSegs++;; 213 points[q].numSegs++;; 214 ; 215 }; 216 ; 217 /*; 218 * Read polygons; 219 */; 220 ; 221 n = 0;; 222 ; 223 for (i = 0; i < buff->numPolys; i++, currPoly++) {; 224 c = buff->polys[n++];; 225 polys[currPoly].color = &(colors)[c];; 226 polys[currPoly].numSegs = buff->polys[n++];; 227 ; 228 polys[currPoly].segs = (segment **) calloc(polys[currPoly].numSegs, sizeof(segment *));; 229 if (!polys[currPoly].segs) {; 230 puts(""Unable to allocate memory for polygon segments !"");; 231 return;; 232 }; 233 for (j = 0; j < polys[currPoly].numSegs; j++) {; 234 int seg = oldNumOfSegmen",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:6422,Energy Efficiency,allocate,allocate,6422,"= oldNumOfPoints + buff->segs[3*i+2];; 176 ; 177 segs[currSeg].color = &(colors[c]);; 178 segs[currSeg].P = &(points[p]);; 179 segs[currSeg].Q = &(points[q]);; 180 ; 181 /*; 182 * Update points' segment lists; 183 */; 184 ; 185 if(points[p].numSegs == 0){; 186 if((points[p].segs = (segment **)calloc(1, sizeof(segment *))) == NULL){; 187 puts(""Unable to allocate memory for point segments !"");; 188 return;; 189 }; 190 }else{; 191 if((points[p].segs = (segment **)realloc(points[p].segs,; 192 (points[p].numSegs + 1) * sizeof(segment *))) == NULL){; 193 puts(""Unable to allocate memory for point segments !"");; 194 return;; 195 }; 196 }; 197 ; 198 if(points[q].numSegs == 0){; 199 if((points[q].segs = (segment **)calloc(1, sizeof(segment *))) == NULL){; 200 puts(""Unable to allocate memory for point segments !"");; 201 return;; 202 }; 203 }else{; 204 if((points[q].segs = (segment **)realloc(points[q].segs,; 205 (points[q].numSegs + 1) * sizeof(segment *))) == NULL){; 206 puts(""Unable to allocate memory for point segments !"");; 207 return;; 208 }; 209 }; 210 points[p].segs[points[p].numSegs] = &(segs[currSeg]);; 211 points[q].segs[points[q].numSegs] = &(segs[currSeg]);; 212 points[p].numSegs++;; 213 points[q].numSegs++;; 214 ; 215 }; 216 ; 217 /*; 218 * Read polygons; 219 */; 220 ; 221 n = 0;; 222 ; 223 for (i = 0; i < buff->numPolys; i++, currPoly++) {; 224 c = buff->polys[n++];; 225 polys[currPoly].color = &(colors)[c];; 226 polys[currPoly].numSegs = buff->polys[n++];; 227 ; 228 polys[currPoly].segs = (segment **) calloc(polys[currPoly].numSegs, sizeof(segment *));; 229 if (!polys[currPoly].segs) {; 230 puts(""Unable to allocate memory for polygon segments !"");; 231 return;; 232 }; 233 for (j = 0; j < polys[currPoly].numSegs; j++) {; 234 int seg = oldNumOfSegments + buff->polys[n++];; 235 polys[currPoly].segs[j] = &(segs[seg]);; 236 ; 237 /*; 238 * Update segments' polygon lists; 239 */; 240 ; 241 if(segs[seg].numPolys == 0) {; 242 if((segs[seg].polys = (polygon **) calloc(1,",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:7068,Energy Efficiency,allocate,allocate,7068,"0){; 199 if((points[q].segs = (segment **)calloc(1, sizeof(segment *))) == NULL){; 200 puts(""Unable to allocate memory for point segments !"");; 201 return;; 202 }; 203 }else{; 204 if((points[q].segs = (segment **)realloc(points[q].segs,; 205 (points[q].numSegs + 1) * sizeof(segment *))) == NULL){; 206 puts(""Unable to allocate memory for point segments !"");; 207 return;; 208 }; 209 }; 210 points[p].segs[points[p].numSegs] = &(segs[currSeg]);; 211 points[q].segs[points[q].numSegs] = &(segs[currSeg]);; 212 points[p].numSegs++;; 213 points[q].numSegs++;; 214 ; 215 }; 216 ; 217 /*; 218 * Read polygons; 219 */; 220 ; 221 n = 0;; 222 ; 223 for (i = 0; i < buff->numPolys; i++, currPoly++) {; 224 c = buff->polys[n++];; 225 polys[currPoly].color = &(colors)[c];; 226 polys[currPoly].numSegs = buff->polys[n++];; 227 ; 228 polys[currPoly].segs = (segment **) calloc(polys[currPoly].numSegs, sizeof(segment *));; 229 if (!polys[currPoly].segs) {; 230 puts(""Unable to allocate memory for polygon segments !"");; 231 return;; 232 }; 233 for (j = 0; j < polys[currPoly].numSegs; j++) {; 234 int seg = oldNumOfSegments + buff->polys[n++];; 235 polys[currPoly].segs[j] = &(segs[seg]);; 236 ; 237 /*; 238 * Update segments' polygon lists; 239 */; 240 ; 241 if(segs[seg].numPolys == 0) {; 242 if((segs[seg].polys = (polygon **) calloc(1, sizeof(polygon *)))== NULL){; 243 puts(""Unable to allocate memory for segment polygons !"");; 244 return;; 245 }; 246 }; 247 else{; 248 if((segs[seg].polys = (polygon **) realloc(segs[seg].polys,; 249 (segs[seg].numPolys + 1) * sizeof(polygon *))) == NULL){; 250 puts(""Unable to allocate memory for segment polygons !"");; 251 return;; 252 }; 253 }; 254 segs[seg].polys[segs[seg].numPolys] = &(polys[currPoly]);; 255 segs[seg].numPolys++;; 256 }; 257 }; 258 }; 259}; 260 ; 261#endif; 262 ; c#define c(i)Definition RSha256.hxx:101; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; qfloat * qDefinition THbookFile.cxx:89; segssegment * seg",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:7481,Energy Efficiency,allocate,allocate,7481,"210 points[p].segs[points[p].numSegs] = &(segs[currSeg]);; 211 points[q].segs[points[q].numSegs] = &(segs[currSeg]);; 212 points[p].numSegs++;; 213 points[q].numSegs++;; 214 ; 215 }; 216 ; 217 /*; 218 * Read polygons; 219 */; 220 ; 221 n = 0;; 222 ; 223 for (i = 0; i < buff->numPolys; i++, currPoly++) {; 224 c = buff->polys[n++];; 225 polys[currPoly].color = &(colors)[c];; 226 polys[currPoly].numSegs = buff->polys[n++];; 227 ; 228 polys[currPoly].segs = (segment **) calloc(polys[currPoly].numSegs, sizeof(segment *));; 229 if (!polys[currPoly].segs) {; 230 puts(""Unable to allocate memory for polygon segments !"");; 231 return;; 232 }; 233 for (j = 0; j < polys[currPoly].numSegs; j++) {; 234 int seg = oldNumOfSegments + buff->polys[n++];; 235 polys[currPoly].segs[j] = &(segs[seg]);; 236 ; 237 /*; 238 * Update segments' polygon lists; 239 */; 240 ; 241 if(segs[seg].numPolys == 0) {; 242 if((segs[seg].polys = (polygon **) calloc(1, sizeof(polygon *)))== NULL){; 243 puts(""Unable to allocate memory for segment polygons !"");; 244 return;; 245 }; 246 }; 247 else{; 248 if((segs[seg].polys = (polygon **) realloc(segs[seg].polys,; 249 (segs[seg].numPolys + 1) * sizeof(polygon *))) == NULL){; 250 puts(""Unable to allocate memory for segment polygons !"");; 251 return;; 252 }; 253 }; 254 segs[seg].polys[segs[seg].numPolys] = &(polys[currPoly]);; 255 segs[seg].numPolys++;; 256 }; 257 }; 258 }; 259}; 260 ; 261#endif; 262 ; c#define c(i)Definition RSha256.hxx:101; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; qfloat * qDefinition THbookFile.cxx:89; segssegment * segsDefinition X3DBuffer.c:23; currSegint currSegDefinition X3DBuffer.c:18; polyspolygon * polysDefinition X3DBuffer.c:24; AllocateX3DBufferint AllocateX3DBuffer()Definition X3DBuffer.c:27; pointspoint * pointsDefinition X3DBuffer.c:22; currPointint currPointDefinition X3DBuffer.c:17; gVarSize3DSize3D gVarSize3DDefinition X3DBuffer.c:9; colorsColor * colorsDefinition X3DBuffer.c:21; gFun",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/X3DBuffer_8c_source.html:7709,Energy Efficiency,allocate,allocate,7709,"20 ; 221 n = 0;; 222 ; 223 for (i = 0; i < buff->numPolys; i++, currPoly++) {; 224 c = buff->polys[n++];; 225 polys[currPoly].color = &(colors)[c];; 226 polys[currPoly].numSegs = buff->polys[n++];; 227 ; 228 polys[currPoly].segs = (segment **) calloc(polys[currPoly].numSegs, sizeof(segment *));; 229 if (!polys[currPoly].segs) {; 230 puts(""Unable to allocate memory for polygon segments !"");; 231 return;; 232 }; 233 for (j = 0; j < polys[currPoly].numSegs; j++) {; 234 int seg = oldNumOfSegments + buff->polys[n++];; 235 polys[currPoly].segs[j] = &(segs[seg]);; 236 ; 237 /*; 238 * Update segments' polygon lists; 239 */; 240 ; 241 if(segs[seg].numPolys == 0) {; 242 if((segs[seg].polys = (polygon **) calloc(1, sizeof(polygon *)))== NULL){; 243 puts(""Unable to allocate memory for segment polygons !"");; 244 return;; 245 }; 246 }; 247 else{; 248 if((segs[seg].polys = (polygon **) realloc(segs[seg].polys,; 249 (segs[seg].numPolys + 1) * sizeof(polygon *))) == NULL){; 250 puts(""Unable to allocate memory for segment polygons !"");; 251 return;; 252 }; 253 }; 254 segs[seg].polys[segs[seg].numPolys] = &(polys[currPoly]);; 255 segs[seg].numPolys++;; 256 }; 257 }; 258 }; 259}; 260 ; 261#endif; 262 ; c#define c(i)Definition RSha256.hxx:101; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; qfloat * qDefinition THbookFile.cxx:89; segssegment * segsDefinition X3DBuffer.c:23; currSegint currSegDefinition X3DBuffer.c:18; polyspolygon * polysDefinition X3DBuffer.c:24; AllocateX3DBufferint AllocateX3DBuffer()Definition X3DBuffer.c:27; pointspoint * pointsDefinition X3DBuffer.c:22; currPointint currPointDefinition X3DBuffer.c:17; gVarSize3DSize3D gVarSize3DDefinition X3DBuffer.c:9; colorsColor * colorsDefinition X3DBuffer.c:21; gFuncSize3DSize3D * gFuncSize3D()Definition X3DBuffer.c:10; currPolyint currPolyDefinition X3DBuffer.c:19; FillX3DBuffervoid FillX3DBuffer(X3DBuffer *buff)Definition X3DBuffer.c:142; X3DBuffer.h; gSize3D#define gSize3DDefinition X3D",MatchSource.WIKI,doc/master/X3DBuffer_8c_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/X3DBuffer_8c_source.html
https://root.cern/doc/master/xtruSamples_8C.html:313,Testability,test,test,313,". ROOT: tutorials/geom/xtruSamples.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. xtruSamples.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Draw a sample of TXTRU shapes some convex, concave (and possibly malformed) ; Change Bool_t's to test alternative specifications. ; void xtruSamples(); {; // One normally specifies the x-y points in counter-clockwise order;; // flip this to TRUE to test that it doesn't matter.; Bool_t makecw = kFALSE;; ; // One normally specifies the z points in increasing z order;; // flip this to TRUE to test that it doesn't matter.; Bool_t reversez = kFALSE;; ; // One shouldn't be creating malformed polygons; // but to test what happens when one does here's a flag.; // The effect will be only apparent in solid rendering mode; Bool_t domalformed = kFALSE;; // domalformed = kTRUE;; ; TCanvas* c1 = new TCanvas(""c1"",""sample TXTRU Shapes"",200,10,640,640);; ; // Create a new geometry; TGeometry* geom = new TGeometry(""sample"",""sample"");; geom->cd();; ; // Define the complexity of the drawing; Int_t zseg = 6; // either 2 or 6; Int_t extravis = 0; // make extra z ""arrow"" visible; ; Float_t unit = 1;; ; // Create a large BRIK to embed things into; Float_t bigdim = 12.5*unit;; TBRIK* world = new TBRIK(""world"",""world"",""void"",bigdim,bigdim,bigdim);; ; // Create the main node, make it invisible; TNode* worldnode = new TNode(""worldnode"",""world node"",world);; worldnode->SetVisibility(0);; worldnode->cd();; ; // Canonical shape ... gets further modified by scale factors; // to create convex (and malformed) versions; Float_t x[] = { -0.50, -1.20, 1.20, 0.50, 0.50, 1.20, -1.20, -0.50 };; Float_t y[] = { -0.75, -2.00, -2.00, -0.75, 0.75, 2.00, 2.00, 0.75 };; Float_t z[] = { -0.50, -1.50, -1.50, 1.50, 1.50, 0.50 };; Float_t s[] = { 0.50, 1.00, 1.50, 1.50, 1.00, 0.50 };; Int_t nxy = sizeof(x)/sizeof(Float_t);; Float_t convexscale[] = { 7.0, -1.0, 1.5 };; ; Int_t icolor[] = { 1, 2, 3, 2, 2, ",MatchSource.WIKI,doc/master/xtruSamples_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/xtruSamples_8C.html
https://root.cern/doc/master/xtruSamples_8C.html:465,Testability,test,test,465,". ROOT: tutorials/geom/xtruSamples.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. xtruSamples.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Draw a sample of TXTRU shapes some convex, concave (and possibly malformed) ; Change Bool_t's to test alternative specifications. ; void xtruSamples(); {; // One normally specifies the x-y points in counter-clockwise order;; // flip this to TRUE to test that it doesn't matter.; Bool_t makecw = kFALSE;; ; // One normally specifies the z points in increasing z order;; // flip this to TRUE to test that it doesn't matter.; Bool_t reversez = kFALSE;; ; // One shouldn't be creating malformed polygons; // but to test what happens when one does here's a flag.; // The effect will be only apparent in solid rendering mode; Bool_t domalformed = kFALSE;; // domalformed = kTRUE;; ; TCanvas* c1 = new TCanvas(""c1"",""sample TXTRU Shapes"",200,10,640,640);; ; // Create a new geometry; TGeometry* geom = new TGeometry(""sample"",""sample"");; geom->cd();; ; // Define the complexity of the drawing; Int_t zseg = 6; // either 2 or 6; Int_t extravis = 0; // make extra z ""arrow"" visible; ; Float_t unit = 1;; ; // Create a large BRIK to embed things into; Float_t bigdim = 12.5*unit;; TBRIK* world = new TBRIK(""world"",""world"",""void"",bigdim,bigdim,bigdim);; ; // Create the main node, make it invisible; TNode* worldnode = new TNode(""worldnode"",""world node"",world);; worldnode->SetVisibility(0);; worldnode->cd();; ; // Canonical shape ... gets further modified by scale factors; // to create convex (and malformed) versions; Float_t x[] = { -0.50, -1.20, 1.20, 0.50, 0.50, 1.20, -1.20, -0.50 };; Float_t y[] = { -0.75, -2.00, -2.00, -0.75, 0.75, 2.00, 2.00, 0.75 };; Float_t z[] = { -0.50, -1.50, -1.50, 1.50, 1.50, 0.50 };; Float_t s[] = { 0.50, 1.00, 1.50, 1.50, 1.00, 0.50 };; Int_t nxy = sizeof(x)/sizeof(Float_t);; Float_t convexscale[] = { 7.0, -1.0, 1.5 };; ; Int_t icolor[] = { 1, 2, 3, 2, 2, ",MatchSource.WIKI,doc/master/xtruSamples_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/xtruSamples_8C.html
https://root.cern/doc/master/xtruSamples_8C.html:609,Testability,test,test,609,". ROOT: tutorials/geom/xtruSamples.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. xtruSamples.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Draw a sample of TXTRU shapes some convex, concave (and possibly malformed) ; Change Bool_t's to test alternative specifications. ; void xtruSamples(); {; // One normally specifies the x-y points in counter-clockwise order;; // flip this to TRUE to test that it doesn't matter.; Bool_t makecw = kFALSE;; ; // One normally specifies the z points in increasing z order;; // flip this to TRUE to test that it doesn't matter.; Bool_t reversez = kFALSE;; ; // One shouldn't be creating malformed polygons; // but to test what happens when one does here's a flag.; // The effect will be only apparent in solid rendering mode; Bool_t domalformed = kFALSE;; // domalformed = kTRUE;; ; TCanvas* c1 = new TCanvas(""c1"",""sample TXTRU Shapes"",200,10,640,640);; ; // Create a new geometry; TGeometry* geom = new TGeometry(""sample"",""sample"");; geom->cd();; ; // Define the complexity of the drawing; Int_t zseg = 6; // either 2 or 6; Int_t extravis = 0; // make extra z ""arrow"" visible; ; Float_t unit = 1;; ; // Create a large BRIK to embed things into; Float_t bigdim = 12.5*unit;; TBRIK* world = new TBRIK(""world"",""world"",""void"",bigdim,bigdim,bigdim);; ; // Create the main node, make it invisible; TNode* worldnode = new TNode(""worldnode"",""world node"",world);; worldnode->SetVisibility(0);; worldnode->cd();; ; // Canonical shape ... gets further modified by scale factors; // to create convex (and malformed) versions; Float_t x[] = { -0.50, -1.20, 1.20, 0.50, 0.50, 1.20, -1.20, -0.50 };; Float_t y[] = { -0.75, -2.00, -2.00, -0.75, 0.75, 2.00, 2.00, 0.75 };; Float_t z[] = { -0.50, -1.50, -1.50, 1.50, 1.50, 0.50 };; Float_t s[] = { 0.50, 1.00, 1.50, 1.50, 1.00, 0.50 };; Int_t nxy = sizeof(x)/sizeof(Float_t);; Float_t convexscale[] = { 7.0, -1.0, 1.5 };; ; Int_t icolor[] = { 1, 2, 3, 2, 2, ",MatchSource.WIKI,doc/master/xtruSamples_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/xtruSamples_8C.html
https://root.cern/doc/master/xtruSamples_8C.html:727,Testability,test,test,727,". ROOT: tutorials/geom/xtruSamples.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. xtruSamples.C File ReferenceTutorials » Geometry tutorials. Detailed Description; Draw a sample of TXTRU shapes some convex, concave (and possibly malformed) ; Change Bool_t's to test alternative specifications. ; void xtruSamples(); {; // One normally specifies the x-y points in counter-clockwise order;; // flip this to TRUE to test that it doesn't matter.; Bool_t makecw = kFALSE;; ; // One normally specifies the z points in increasing z order;; // flip this to TRUE to test that it doesn't matter.; Bool_t reversez = kFALSE;; ; // One shouldn't be creating malformed polygons; // but to test what happens when one does here's a flag.; // The effect will be only apparent in solid rendering mode; Bool_t domalformed = kFALSE;; // domalformed = kTRUE;; ; TCanvas* c1 = new TCanvas(""c1"",""sample TXTRU Shapes"",200,10,640,640);; ; // Create a new geometry; TGeometry* geom = new TGeometry(""sample"",""sample"");; geom->cd();; ; // Define the complexity of the drawing; Int_t zseg = 6; // either 2 or 6; Int_t extravis = 0; // make extra z ""arrow"" visible; ; Float_t unit = 1;; ; // Create a large BRIK to embed things into; Float_t bigdim = 12.5*unit;; TBRIK* world = new TBRIK(""world"",""world"",""void"",bigdim,bigdim,bigdim);; ; // Create the main node, make it invisible; TNode* worldnode = new TNode(""worldnode"",""world node"",world);; worldnode->SetVisibility(0);; worldnode->cd();; ; // Canonical shape ... gets further modified by scale factors; // to create convex (and malformed) versions; Float_t x[] = { -0.50, -1.20, 1.20, 0.50, 0.50, 1.20, -1.20, -0.50 };; Float_t y[] = { -0.75, -2.00, -2.00, -0.75, 0.75, 2.00, 2.00, 0.75 };; Float_t z[] = { -0.50, -1.50, -1.50, 1.50, 1.50, 0.50 };; Float_t s[] = { 0.50, 1.00, 1.50, 1.50, 1.00, 0.50 };; Int_t nxy = sizeof(x)/sizeof(Float_t);; Float_t convexscale[] = { 7.0, -1.0, 1.5 };; ; Int_t icolor[] = { 1, 2, 3, 2, 2, ",MatchSource.WIKI,doc/master/xtruSamples_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/xtruSamples_8C.html
https://root.cern/doc/master/zdemo_8C.html:299,Safety,predict,predictions,299,". ROOT: tutorials/graphs/zdemo.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. zdemo.C File ReferenceTutorials » Graphs tutorials. Detailed Description; This macro is an example of graphs in log scales with annotations. ; The presented results are predictions of invariant cross-section of Direct Photons produced at RHIC energies, based on the universality of scaling function H(z).; These Figures were published in JINR preprint E2-98-64, Dubna, 1998 and submitted to CPC.; Note that the way greek symbols, super/subscripts are obtained illustrate the current limitations of Root in this area. ; #include ""TCanvas.h""; #include ""TPad.h""; #include ""TPaveLabel.h""; #include ""TLatex.h""; #include ""TGraph.h""; #include ""TFrame.h""; ; #ifdef HZ; #undef HZ; #endif; ; const Int_t NMAX = 20;; Int_t NLOOP;; Float_t Z[NMAX], HZ[NMAX], PT[NMAX], INVSIG[NMAX];; ; void hz_calc(Float_t, Float_t, Float_t, Float_t, Float_t, Float_t);; ; //__________________________________________________________________; void zdemo(); {; ; Float_t energ;; Float_t dens;; Float_t tgrad;; Float_t ptmin;; Float_t ptmax;; Float_t delp;; ; // Create a new canvas.; TCanvas *c1 = new TCanvas(""zdemo"",; ""Monte Carlo Study of Z scaling"",10,40,800,600);; c1->Range(0,0,25,18);; c1->SetFillColor(40);; ; TPaveLabel *pl = new TPaveLabel(1,16.3,24,17.5,""Z-scaling of \; Direct Photon Productions in pp Collisions at RHIC Energies"",""br"");; pl->SetFillColor(18);; pl->SetTextFont(32);; pl->SetTextColor(49);; pl->Draw();; ; TLatex t0;; t0.SetTextFont(32);; t0.SetTextColor(1);; t0.SetTextSize(0.03);; t0.SetTextAlign(12);; t0.DrawLatex(3.1,15.5,""M.Tokarev, E.Potrebenikova "");; t0.DrawLatex(14.,15.5,""JINR preprint E2-98-64, Dubna, 1998 "");; ; TPad *pad1 = new TPad(""pad1"",""This is pad1"",0.02,0.02,0.48,0.83,33);; TPad *pad2 = new TPad(""pad2"",""This is pad2"",0.52,0.02,0.98,0.83,33);; ; pad1->Draw();; pad2->Draw();; ; //; // Cross-section of direct photon production in pp collisions; // at",MatchSource.WIKI,doc/master/zdemo_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/zdemo_8C.html
https://root.cern/doc/master/zdemo_8C.html:242,Testability,log,log,242,". ROOT: tutorials/graphs/zdemo.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. zdemo.C File ReferenceTutorials » Graphs tutorials. Detailed Description; This macro is an example of graphs in log scales with annotations. ; The presented results are predictions of invariant cross-section of Direct Photons produced at RHIC energies, based on the universality of scaling function H(z).; These Figures were published in JINR preprint E2-98-64, Dubna, 1998 and submitted to CPC.; Note that the way greek symbols, super/subscripts are obtained illustrate the current limitations of Root in this area. ; #include ""TCanvas.h""; #include ""TPad.h""; #include ""TPaveLabel.h""; #include ""TLatex.h""; #include ""TGraph.h""; #include ""TFrame.h""; ; #ifdef HZ; #undef HZ; #endif; ; const Int_t NMAX = 20;; Int_t NLOOP;; Float_t Z[NMAX], HZ[NMAX], PT[NMAX], INVSIG[NMAX];; ; void hz_calc(Float_t, Float_t, Float_t, Float_t, Float_t, Float_t);; ; //__________________________________________________________________; void zdemo(); {; ; Float_t energ;; Float_t dens;; Float_t tgrad;; Float_t ptmin;; Float_t ptmax;; Float_t delp;; ; // Create a new canvas.; TCanvas *c1 = new TCanvas(""zdemo"",; ""Monte Carlo Study of Z scaling"",10,40,800,600);; c1->Range(0,0,25,18);; c1->SetFillColor(40);; ; TPaveLabel *pl = new TPaveLabel(1,16.3,24,17.5,""Z-scaling of \; Direct Photon Productions in pp Collisions at RHIC Energies"",""br"");; pl->SetFillColor(18);; pl->SetTextFont(32);; pl->SetTextColor(49);; pl->Draw();; ; TLatex t0;; t0.SetTextFont(32);; t0.SetTextColor(1);; t0.SetTextSize(0.03);; t0.SetTextAlign(12);; t0.DrawLatex(3.1,15.5,""M.Tokarev, E.Potrebenikova "");; t0.DrawLatex(14.,15.5,""JINR preprint E2-98-64, Dubna, 1998 "");; ; TPad *pad1 = new TPad(""pad1"",""This is pad1"",0.02,0.02,0.48,0.83,33);; TPad *pad2 = new TPad(""pad2"",""This is pad2"",0.52,0.02,0.98,0.83,33);; ; pad1->Draw();; pad2->Draw();; ; //; // Cross-section of direct photon production in pp collisions; // at",MatchSource.WIKI,doc/master/zdemo_8C.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/zdemo_8C.html
https://root.cern/doc/master/zdemo_8py.html:7642,Performance,load,loaded,7642,"raph.Draw( 'LP' ); saves[ 'graph' ] = graph; ; graph = ROOT.TGraph( 1, dum, dum ); graph.SetMarkerColor( ROOT.kRed ); graph.SetMarkerStyle( 29 ); graph.SetMarkerSize( 1.5 ); graph.SetPoint( 0, 1.7, 2.e-17 ); graph.Draw( 'LP' ); saves[ 'graph2' ] = graph # note the label that is used!; ; graph = ROOT.TGraph( 1, dum, dum ); graph.SetMarkerColor( 6 ); graph.SetMarkerStyle( 8 ); graph.SetMarkerSize( 1.1 ); graph.SetPoint( 0, 1.7, 4.e-18); graph.Draw( 'LP' ); saves[ 'graph3' ] = graph # note the label that is used!; ; pad2.cd(); pad2.Range( -0.43642, -23.75, 3.92778, -6.25 ); pad2.SetLogx(); pad2.SetLogy(); ; pad2.DrawFrame( 1, 1e-22, 3100, 1e-8 ); pad2.GetFrame().SetFillColor( 19 ); ; gr = ROOT.TGraph( NLOOP, Z, HZ ); gr.SetTitle( 'HZ vs Z' ); gr.SetFillColor( 19 ); gr.SetLineColor( 9 ); gr.SetMarkerColor( 50 ); gr.SetMarkerStyle( 29 ); gr.SetMarkerSize( 1.5 ); gr.Draw( 'LP' ); saves[ 'gr' ] = gr; ; t = ROOT.TLatex(); t.SetNDC(); t.SetTextFont( 62 ); t.SetTextColor( 36 ); t.SetTextSize( 0.08 ); t.SetTextAlign( 12 ); t.DrawLatex( 0.6, 0.85, 'p - p' ); ; t.SetTextSize( 0.05 ); t.DrawLatex( 0.6, 0.79, 'Direct #gamma' ); t.DrawLatex( 0.6, 0.75, '#theta = 90^{o}' ); ; t.DrawLatex( 0.70, 0.55, 'H(z)' ); t.DrawLatex( 0.68, 0.50, '(barn)' ); ; t.SetTextSize( 0.045 ); t.SetTextColor( 46 ); t.DrawLatex( 0.20, 0.30, '#sqrt{s}, GeV' ); t.DrawLatex( 0.22, 0.26, '63' ); t.DrawLatex( 0.22, 0.22, '200' ); t.DrawLatex( 0.22, 0.18, '500' ); ; t.SetTextSize( 0.05 ); t.SetTextColor( 1 ); t.DrawLatex( 0.88, 0.06, 'z' ); saves[ 't3' ] = t # note the label that is used!; ; c1.Modified(); c1.Update(); ; ; if __name__ == '__main__': # run if loaded as script; zdemo(); SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; int; zdemoDefinition zdemo.py:1; AuthorsMichael Tokarev, Elena Potrebenikova (JINR Dubna) ; Definition in file zdemo.py. tutorialspyrootzdemo.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,doc/master/zdemo_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/zdemo_8py.html
https://root.cern/doc/master/zdemo_8py.html:314,Safety,predict,predictions,314,". ROOT: tutorials/pyroot/zdemo.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; zdemo.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This macro is an example of graphs in log scales with annotations. ; The presented results are predictions of invariant cross-section of Direct Photons produced at RHIC energies, based on the universality of scaling function H(z).; These Figures were published in JINR preprint E2-98-64, Dubna, 1998 and submitted to CPC. ; import ROOT; from array import array; ; NMAX = 20; Z = array( 'f', [0.]*NMAX ); HZ = array( 'f', [0.]*NMAX ); PT = array( 'f', [0.]*NMAX ); INVSIG = array( 'f', [0.]*NMAX ); ; NLOOP = 0; saves = {}; ; #_______________________________________________________________________________; def hz_calc( ENERG, DENS, TGRAD, PTMIN, PTMAX, DELP ):; from math import sin, cos, sqrt; global NLOOP; global Z, HZ, PT, INVSIG; ; CSEFT= 1.; GM1 = 0.00001; GM2 = 0.00001; A1 = 1.; A2 = 1.; ALX = 2.; BETA = 1.; KF1 = 8.E-7; KF2 = 5.215; ; MN = 0.9383; DEGRAD=0.01745329; ; # print 'ENR= %f DENS= %f PTMIN= %f PTMAX= %f DELP= %f ' % (ENERG,DENS,PTMIN,PTMAX,DELP); ; DNDETA= DENS; MB1 = MN*A1; MB2 = MN*A2; EB1 = ENERG/2.*A1; EB2 = ENERG/2.*A2; M1 = GM1; M2 = GM2; THET = TGRAD*DEGRAD; NLOOP = int((PTMAX-PTMIN)/DELP); ; for I in range(NLOOP):; PT[I]=PTMIN+I*DELP; PTOT = PT[I]/sin(THET); ; ETOT = sqrt(M1*M1 + PTOT*PTOT); PB1 = sqrt(EB1*EB1 - MB1*MB1); PB2 = sqrt(EB2*EB2 - MB2*MB2); P2P3 = EB2*ETOT+PB2*PTOT*cos(THET); P1P2 = EB2*EB1+PB2*PB1; P1P3 = EB1*ETOT-PB1*PTOT*cos(THET); ; X1 = P2P3/P1P2; X2 = P1P3/P1P2; Y1 = X1+sqrt(X1*X2*(1.-X1)/(1.-X2)); Y2 = X2+sqrt(X1*X2*(1.-X2)/(1.-X1)); ; S = (MB1*MB1)+2.*P1P2+(MB2*MB2); SMIN = 4.*((MB1*MB1)*(X1*X1) +2.*X1*X2*P1P2+(MB2*MB2)*(X2*X2)); SX1 = 4.*( 2*(MB1*MB1)*X1+2*X2*P1P2); SX2 = 4.*( 2*(MB2*MB2)*X2+2*X1*P1P2); SX1X2= 4.*(2*P1P2); DELM = pow((1.-Y1)*(1.-Y2),ALX); ; Z[I] = sqrt(SMIN)/DELM/pow(DNDETA,BETA); ; Y1X1 = 1. +X2*(",MatchSource.WIKI,doc/master/zdemo_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/zdemo_8py.html
https://root.cern/doc/master/zdemo_8py.html:257,Testability,log,log,257,". ROOT: tutorials/pyroot/zdemo.py File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; zdemo.py File ReferenceTutorials » PyRoot tutorials. Detailed Description; This macro is an example of graphs in log scales with annotations. ; The presented results are predictions of invariant cross-section of Direct Photons produced at RHIC energies, based on the universality of scaling function H(z).; These Figures were published in JINR preprint E2-98-64, Dubna, 1998 and submitted to CPC. ; import ROOT; from array import array; ; NMAX = 20; Z = array( 'f', [0.]*NMAX ); HZ = array( 'f', [0.]*NMAX ); PT = array( 'f', [0.]*NMAX ); INVSIG = array( 'f', [0.]*NMAX ); ; NLOOP = 0; saves = {}; ; #_______________________________________________________________________________; def hz_calc( ENERG, DENS, TGRAD, PTMIN, PTMAX, DELP ):; from math import sin, cos, sqrt; global NLOOP; global Z, HZ, PT, INVSIG; ; CSEFT= 1.; GM1 = 0.00001; GM2 = 0.00001; A1 = 1.; A2 = 1.; ALX = 2.; BETA = 1.; KF1 = 8.E-7; KF2 = 5.215; ; MN = 0.9383; DEGRAD=0.01745329; ; # print 'ENR= %f DENS= %f PTMIN= %f PTMAX= %f DELP= %f ' % (ENERG,DENS,PTMIN,PTMAX,DELP); ; DNDETA= DENS; MB1 = MN*A1; MB2 = MN*A2; EB1 = ENERG/2.*A1; EB2 = ENERG/2.*A2; M1 = GM1; M2 = GM2; THET = TGRAD*DEGRAD; NLOOP = int((PTMAX-PTMIN)/DELP); ; for I in range(NLOOP):; PT[I]=PTMIN+I*DELP; PTOT = PT[I]/sin(THET); ; ETOT = sqrt(M1*M1 + PTOT*PTOT); PB1 = sqrt(EB1*EB1 - MB1*MB1); PB2 = sqrt(EB2*EB2 - MB2*MB2); P2P3 = EB2*ETOT+PB2*PTOT*cos(THET); P1P2 = EB2*EB1+PB2*PB1; P1P3 = EB1*ETOT-PB1*PTOT*cos(THET); ; X1 = P2P3/P1P2; X2 = P1P3/P1P2; Y1 = X1+sqrt(X1*X2*(1.-X1)/(1.-X2)); Y2 = X2+sqrt(X1*X2*(1.-X2)/(1.-X1)); ; S = (MB1*MB1)+2.*P1P2+(MB2*MB2); SMIN = 4.*((MB1*MB1)*(X1*X1) +2.*X1*X2*P1P2+(MB2*MB2)*(X2*X2)); SX1 = 4.*( 2*(MB1*MB1)*X1+2*X2*P1P2); SX2 = 4.*( 2*(MB2*MB2)*X2+2*X1*P1P2); SX1X2= 4.*(2*P1P2); DELM = pow((1.-Y1)*(1.-Y2),ALX); ; Z[I] = sqrt(SMIN)/DELM/pow(DNDETA,BETA); ; Y1X1 = 1. +X2*(",MatchSource.WIKI,doc/master/zdemo_8py.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/zdemo_8py.html
https://root.cern/doc/master/__roofit_8pyzdoc_source.html:86703,Availability,error,error,86703,"tor automatically calls AddSWeight() with the given RooCmdArg; 1881 ; 1882For example, the following code is equivalent in PyROOT:; 1883\code{.py}; 1884# Directly passing a RooCmdArg:; 1885sData = ROOT.RooStats.SPlot(""sData"", ""An SPlot"", data, massModel, [zYield, qcdYield], ROOT.RooStats.RooCmdArg(""Strategy"", 0)); 1886 ; 1887# With keyword arguments:; 1888sData = ROOT.RooStats.SPlot(""sData"", ""An SPlot"", data, massModel, [zYield, qcdYield], Strategy=0); 1889\endcode; 1890\htmlonly; 1891</div>; 1892\endhtmlonly; 1893 ; 1894\fn RooFit::DataError(Int_t); 1895\brief \parblock \endparblock; 1896\htmlonly; 1897<div class=""pyrootbox"">; 1898\endhtmlonly; 1899## PyROOT; 1900Instead of passing an enum value to this function, you can pass a; 1901string with the name of that enum value, for example:; 1902 ; 1903~~~ {.py}; 1904 data.plotOn(frame, DataError=""SumW2""); 1905 # instead of DataError=ROOT.RooAbsData.SumW2; 1906~~~; 1907 ; 1908If you want to use the `""None""` enum value to disable error plotting, you; 1909can also pass `None` directly instead of passing a string:; 1910 ; 1911~~~ {.py}; 1912 data.plotOn(frame, DataError=None); 1913 # instead of DataError=""None""; 1914~~~; 1915\htmlonly; 1916</div>; 1917\endhtmlonly; 1918 ; 1919\fn RooFit::FitOptions(const RooCmdArg& arg1, const RooCmdArg& arg2,const RooCmdArg& arg3,const RooCmdArg& arg4,const RooCmdArg& arg5,const RooCmdArg& arg6); 1920\brief \parblock \endparblock; 1921\htmlonly; 1922<div class=""pyrootbox"">; 1923\endhtmlonly; 1924## PyROOT; 1925The FitOptions() function is pythonized with the command argument pythonization.; 1926The keywords must correspond to the CmdArg of the function.; 1927\htmlonly; 1928</div>; 1929\endhtmlonly; 1930 ; 1931\fn RooFit::Format(const char* what, const RooCmdArg& arg1, const RooCmdArg& arg2,const RooCmdArg& arg3,const RooCmdArg& arg4,const RooCmdArg& arg5,const RooCmdArg& arg6,const RooCmdArg& arg7,const RooCmdArg& arg8); 1932\brief \parblock \endparblock; 1933\htmlonly; 1934<div class=""pyr",MatchSource.WIKI,doc/master/__roofit_8pyzdoc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html
https://root.cern/doc/master/__roofit_8pyzdoc_source.html:572,Energy Efficiency,reduce,reduce,572, 1/**; 2\defgroup RoofitPythonizations RooFit Pythonizations; 3\ingroup Roofitmain; 4- [RooAbsCollection](\ref _rooabscollection); 5 - [printLatex](\ref _rooabscollection_printlatex); 6- [RooAbsData](\ref _rooabsdata); 7 - [createHistogram](\ref _rooabsdata_createhistogram); 8 - [plotOn](\ref _rooabsdata_ploton); 9 - [reduce](\ref _rooabsdata_reduce); 10 - [statOn](\ref _rooabsdata_staton); 11- [RooAbsPdf](\ref _rooabspdf); 12 - [createCdf](\ref _rooabspdf_createcdf); 13 - [createNLL](\ref _rooabspdf_createnll); 14 - [fitTo](\ref _rooabspdf_fitto); 15 - [generate](\ref _rooabspdf_generate); 16 - [generateBinned](\ref _rooabspdf_generatebinned); 17 - [paramOn](\ref _rooabspdf_paramon); 18 - [plotOn](\ref _rooabspdf_ploton); 19 - [prepareMultiGen](\ref _rooabspdf_preparemultigen); 20- [RooAbsReal](\ref _rooabsreal); 21 - [chi2FitTo](\ref _rooabsreal_chi2fitto); 22 - [createChi2](\ref _rooabsreal_createchi2); 23 - [createHistogram](\ref _rooabsreal_createhistogram); 24 - [createIntegral](\ref _rooabsreal_createintegral); 25 - [createRunningIntegral](\ref _rooabsreal_createrunningintegral); 26 - [plotOn](\ref _rooabsreal_ploton); 27- [RooAbsRealLValue](\ref _rooabsreallvalue); 28 - [createHistogram](\ref _rooabsreallvalue_createhistogram); 29 - [frame](\ref _rooabsreallvalue_frame); 30- [RooArgSet](\ref _rooargset); 31 - [__init__](\ref _rooargset___init__); 32- [RooBCPGenDecay](\ref _roobcpgendecay); 33 - [__init__](\ref _roobcpgendecay___init__); 34- [RooBCPEffDecay](\ref _roobcpeffdecay); 35 - [__init__](\ref _roobcpeffdecay___init__); 36- [RooBDecay](\ref _roobdecay); 37 - [__init__](\ref _roobdecay___init__); 38- [RooBMixDecay](\ref _roobmixdecay); 39 - [__init__](\ref _roobmixdecay___init__); 40- [RooCategory](\ref _r,MatchSource.WIKI,doc/master/__roofit_8pyzdoc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html
https://root.cern/doc/master/__roofit_8pyzdoc_source.html:5420,Energy Efficiency,reduce,reduce,5420,"example, the following code is equivalent in PyROOT:; 96\code{.py}; 97# Directly passing a RooCmdArg:; 98params.printLatex(ROOT.RooFit.Sibling(initParams), ROOT.RooFit.Columns(2)); 99 ; 100# With keyword arguments:; 101params.printLatex(Sibling=initParams, Columns =2); 102\endcode; 103 ; 104\anchor _rooabscollection_printlatex; 105### RooAbsCollection.printLatex; 106The RooAbsCollection::printLatex() function is pythonized with the command argument pythonization.; 107The keywords must correspond to the CmdArgs of the function.; 108 ; 109\see RooAbsCollection::printLatex(const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 110 ; 111\anchor _rooabsdata; 112## RooAbsData; 113\see RooAbsData; 114 ; 115Some member functions of RooAbsData that take a RooCmdArg as argument also support keyword arguments.; 116This applies to RooAbsData::plotOn, RooAbsData::createHistogram, RooAbsData::reduce, RooAbsData::statOn.; 117For example, the following code is equivalent in PyROOT:; 118\code{.py}; 119# Directly passing a RooCmdArg:; 120data.plotOn(frame, ROOT.RooFit.CutRange(""r1"")); 121 ; 122# With keyword arguments:; 123data.plotOn(frame, CutRange=""r1""); 124\endcode; 125 ; 126\anchor _rooabsdata_createhistogram; 127### RooAbsData.createHistogram; 128The RooAbsData::createHistogram() function is pythonized with the command argument pythonization.; 129The keywords must correspond to the CmdArgs of the function.; 130 ; 131\see RooAbsData::createHistogram(const char *name, const RooAbsRealLValue& xvar, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 132 ; 133\anchor _rooabsdata_ploton; 134### RooAbsData.plotOn; 135The RooAbsData::plotOn() function is pythonized with the command argument pythonization.; 136The ke",MatchSource.WIKI,doc/master/__roofit_8pyzdoc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html
https://root.cern/doc/master/__roofit_8pyzdoc_source.html:6744,Energy Efficiency,reduce,reduce,6744,"Data::createHistogram() function is pythonized with the command argument pythonization.; 129The keywords must correspond to the CmdArgs of the function.; 130 ; 131\see RooAbsData::createHistogram(const char *name, const RooAbsRealLValue& xvar, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 132 ; 133\anchor _rooabsdata_ploton; 134### RooAbsData.plotOn; 135The RooAbsData::plotOn() function is pythonized with the command argument pythonization.; 136The keywords must correspond to the CmdArgs of the function.; 137 ; 138\see RooAbsData::plotOn(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 139 ; 140\anchor _rooabsdata_reduce; 141### RooAbsData.reduce; 142The RooAbsData::reduce() function is pythonized with the command argument pythonization.; 143The keywords must correspond to the CmdArgs of the function.; 144 ; 145\see RooAbsData::reduce(const RooCmdArg& arg1,const RooCmdArg& arg2, const RooCmdArg& arg3,const RooCmdArg& arg4, const RooCmdArg& arg5,const RooCmdArg& arg6, const RooCmdArg& arg7,const RooCmdArg& arg8); 146 ; 147\anchor _rooabsdata_staton; 148### RooAbsData.statOn; 149The RooAbsData::statOn() function is pythonized with the command argument pythonization.; 150The keywords must correspond to the CmdArgs of the function.; 151 ; 152\see RooAbsData::statOn(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 153 ; 154\anchor _rooabspdf; 155## RooAbsPdf; 156\see RooAbsPdf; 157 ; 158Some member functions of RooAbsPdf that take a RooCmdArg as argument also support keyword arguments.; 159So far, this applies to RooAbsPdf::f",MatchSource.WIKI,doc/master/__roofit_8pyzdoc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html
https://root.cern/doc/master/__roofit_8pyzdoc_source.html:6771,Energy Efficiency,reduce,reduce,6771,"Data::createHistogram() function is pythonized with the command argument pythonization.; 129The keywords must correspond to the CmdArgs of the function.; 130 ; 131\see RooAbsData::createHistogram(const char *name, const RooAbsRealLValue& xvar, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 132 ; 133\anchor _rooabsdata_ploton; 134### RooAbsData.plotOn; 135The RooAbsData::plotOn() function is pythonized with the command argument pythonization.; 136The keywords must correspond to the CmdArgs of the function.; 137 ; 138\see RooAbsData::plotOn(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 139 ; 140\anchor _rooabsdata_reduce; 141### RooAbsData.reduce; 142The RooAbsData::reduce() function is pythonized with the command argument pythonization.; 143The keywords must correspond to the CmdArgs of the function.; 144 ; 145\see RooAbsData::reduce(const RooCmdArg& arg1,const RooCmdArg& arg2, const RooCmdArg& arg3,const RooCmdArg& arg4, const RooCmdArg& arg5,const RooCmdArg& arg6, const RooCmdArg& arg7,const RooCmdArg& arg8); 146 ; 147\anchor _rooabsdata_staton; 148### RooAbsData.statOn; 149The RooAbsData::statOn() function is pythonized with the command argument pythonization.; 150The keywords must correspond to the CmdArgs of the function.; 151 ; 152\see RooAbsData::statOn(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 153 ; 154\anchor _rooabspdf; 155## RooAbsPdf; 156\see RooAbsPdf; 157 ; 158Some member functions of RooAbsPdf that take a RooCmdArg as argument also support keyword arguments.; 159So far, this applies to RooAbsPdf::f",MatchSource.WIKI,doc/master/__roofit_8pyzdoc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html
https://root.cern/doc/master/__roofit_8pyzdoc_source.html:6936,Energy Efficiency,reduce,reduce,6936,"RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 132 ; 133\anchor _rooabsdata_ploton; 134### RooAbsData.plotOn; 135The RooAbsData::plotOn() function is pythonized with the command argument pythonization.; 136The keywords must correspond to the CmdArgs of the function.; 137 ; 138\see RooAbsData::plotOn(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 139 ; 140\anchor _rooabsdata_reduce; 141### RooAbsData.reduce; 142The RooAbsData::reduce() function is pythonized with the command argument pythonization.; 143The keywords must correspond to the CmdArgs of the function.; 144 ; 145\see RooAbsData::reduce(const RooCmdArg& arg1,const RooCmdArg& arg2, const RooCmdArg& arg3,const RooCmdArg& arg4, const RooCmdArg& arg5,const RooCmdArg& arg6, const RooCmdArg& arg7,const RooCmdArg& arg8); 146 ; 147\anchor _rooabsdata_staton; 148### RooAbsData.statOn; 149The RooAbsData::statOn() function is pythonized with the command argument pythonization.; 150The keywords must correspond to the CmdArgs of the function.; 151 ; 152\see RooAbsData::statOn(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 153 ; 154\anchor _rooabspdf; 155## RooAbsPdf; 156\see RooAbsPdf; 157 ; 158Some member functions of RooAbsPdf that take a RooCmdArg as argument also support keyword arguments.; 159So far, this applies to RooAbsPdf::fitTo, RooAbsPdf::plotOn, RooAbsPdf::generate, RooAbsPdf::paramOn, RooAbsPdf::createCdf,; 160RooAbsPdf::generateBinned, RooAbsPdf::prepareMultiGen and RooAbsPdf::createNLL.; 161For example, the following code is equivalent in PyROOT:; 162\code{.py}; 1",MatchSource.WIKI,doc/master/__roofit_8pyzdoc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html
https://root.cern/doc/master/__roofit_8pyzdoc_source.html:45560,Energy Efficiency,reduce,reduce,45560,"olumns(2)); 892 ; 893# With keyword arguments:; 894params.printLatex(Sibling=initParams, Columns =2); 895\endcode; 896\htmlonly; 897</div>; 898\endhtmlonly; 899 ; 900\fn RooAbsCollection::printLatex(const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 901\brief \parblock \endparblock; 902\htmlonly; 903<div class=""pyrootbox"">; 904\endhtmlonly; 905## PyROOT; 906The RooAbsCollection::printLatex() function is pythonized with the command argument pythonization.; 907The keywords must correspond to the CmdArgs of the function.; 908\htmlonly; 909</div>; 910\endhtmlonly; 911 ; 912\class RooAbsData; 913\brief \parblock \endparblock; 914\htmlonly; 915<div class=""pyrootbox"">; 916\endhtmlonly; 917## PyROOT; 918Some member functions of RooAbsData that take a RooCmdArg as argument also support keyword arguments.; 919This applies to RooAbsData::plotOn, RooAbsData::createHistogram, RooAbsData::reduce, RooAbsData::statOn.; 920For example, the following code is equivalent in PyROOT:; 921\code{.py}; 922# Directly passing a RooCmdArg:; 923data.plotOn(frame, ROOT.RooFit.CutRange(""r1"")); 924 ; 925# With keyword arguments:; 926data.plotOn(frame, CutRange=""r1""); 927\endcode; 928\htmlonly; 929</div>; 930\endhtmlonly; 931 ; 932\fn RooAbsData::createHistogram(const char *name, const RooAbsRealLValue& xvar, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 933\brief \parblock \endparblock; 934\htmlonly; 935<div class=""pyrootbox"">; 936\endhtmlonly; 937## PyROOT; 938The RooAbsData::createHistogram() function is pythonized with the command argument pythonization.; 939The keywords must correspond to the CmdArgs of the function.; 940\htmlonly; 941</div>; 942\endhtmlonly; 943 ; 944\fn RooAbsData::plotOn(RooPlot* frame, const Ro",MatchSource.WIKI,doc/master/__roofit_8pyzdoc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html
https://root.cern/doc/master/__roofit_8pyzdoc_source.html:47048,Energy Efficiency,reduce,reduce,47048,"y; 935<div class=""pyrootbox"">; 936\endhtmlonly; 937## PyROOT; 938The RooAbsData::createHistogram() function is pythonized with the command argument pythonization.; 939The keywords must correspond to the CmdArgs of the function.; 940\htmlonly; 941</div>; 942\endhtmlonly; 943 ; 944\fn RooAbsData::plotOn(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 945\brief \parblock \endparblock; 946\htmlonly; 947<div class=""pyrootbox"">; 948\endhtmlonly; 949## PyROOT; 950The RooAbsData::plotOn() function is pythonized with the command argument pythonization.; 951The keywords must correspond to the CmdArgs of the function.; 952\htmlonly; 953</div>; 954\endhtmlonly; 955 ; 956\fn RooAbsData::reduce(const RooCmdArg& arg1,const RooCmdArg& arg2, const RooCmdArg& arg3,const RooCmdArg& arg4, const RooCmdArg& arg5,const RooCmdArg& arg6, const RooCmdArg& arg7,const RooCmdArg& arg8); 957\brief \parblock \endparblock; 958\htmlonly; 959<div class=""pyrootbox"">; 960\endhtmlonly; 961## PyROOT; 962The RooAbsData::reduce() function is pythonized with the command argument pythonization.; 963The keywords must correspond to the CmdArgs of the function.; 964\htmlonly; 965</div>; 966\endhtmlonly; 967 ; 968\fn RooAbsData::statOn(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 969\brief \parblock \endparblock; 970\htmlonly; 971<div class=""pyrootbox"">; 972\endhtmlonly; 973## PyROOT; 974The RooAbsData::statOn() function is pythonized with the command argument pythonization.; 975The keywords must correspond to the CmdArgs of the function.; 976\htmlonly; 977</div>; 978\endhtmlonly; 979 ; 980\class RooAbsPdf; 981\brief \parblock \endparblock; 982\htmlonly; 983<div class=""pyrootbox"">; 984\endhtmlonly; 985#",MatchSource.WIKI,doc/master/__roofit_8pyzdoc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html
https://root.cern/doc/master/__roofit_8pyzdoc_source.html:47362,Energy Efficiency,reduce,reduce,47362,"y; 935<div class=""pyrootbox"">; 936\endhtmlonly; 937## PyROOT; 938The RooAbsData::createHistogram() function is pythonized with the command argument pythonization.; 939The keywords must correspond to the CmdArgs of the function.; 940\htmlonly; 941</div>; 942\endhtmlonly; 943 ; 944\fn RooAbsData::plotOn(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 945\brief \parblock \endparblock; 946\htmlonly; 947<div class=""pyrootbox"">; 948\endhtmlonly; 949## PyROOT; 950The RooAbsData::plotOn() function is pythonized with the command argument pythonization.; 951The keywords must correspond to the CmdArgs of the function.; 952\htmlonly; 953</div>; 954\endhtmlonly; 955 ; 956\fn RooAbsData::reduce(const RooCmdArg& arg1,const RooCmdArg& arg2, const RooCmdArg& arg3,const RooCmdArg& arg4, const RooCmdArg& arg5,const RooCmdArg& arg6, const RooCmdArg& arg7,const RooCmdArg& arg8); 957\brief \parblock \endparblock; 958\htmlonly; 959<div class=""pyrootbox"">; 960\endhtmlonly; 961## PyROOT; 962The RooAbsData::reduce() function is pythonized with the command argument pythonization.; 963The keywords must correspond to the CmdArgs of the function.; 964\htmlonly; 965</div>; 966\endhtmlonly; 967 ; 968\fn RooAbsData::statOn(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 969\brief \parblock \endparblock; 970\htmlonly; 971<div class=""pyrootbox"">; 972\endhtmlonly; 973## PyROOT; 974The RooAbsData::statOn() function is pythonized with the command argument pythonization.; 975The keywords must correspond to the CmdArgs of the function.; 976\htmlonly; 977</div>; 978\endhtmlonly; 979 ; 980\class RooAbsPdf; 981\brief \parblock \endparblock; 982\htmlonly; 983<div class=""pyrootbox"">; 984\endhtmlonly; 985#",MatchSource.WIKI,doc/master/__roofit_8pyzdoc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html
https://root.cern/doc/master/__roofit_8pyzdoc_source.html:22777,Modifiability,variab,variable,22777,"ataHist(std::string_view name, std::string_view title, const RooArgList& vars, RooCategory& indexCat, std::map<std::string,TH1*> histMap, Double_t initWgt); 421 ; 422\see RooDataHist(std::string_view name, std::string_view title, const RooArgList& vars, RooCategory& indexCat, std::map<std::string,RooDataHist*> dhistMap, Double_t wgt); 423 ; 424\anchor _roodatahist_from_numpy; 425### RooDataHist.from_numpy; 426Create a RooDataHist from numpy arrays.; 427 ; 428Note: The argument structure was inspired by numpy.histogramdd.; 429 ; 430Args:; 431 hist_weights (numpy.ndarray): The multidimensional histogram bin; 432 weights.; 433 bins (list): The bin specification, where each element is either:; 434 * a numpy array describing the monotonically; 435 increasing bin edges along each dimension.; 436 * a scalar value for the number of bins (in this; 437 case, the corresponding item in the `ranges`; 438 argument must be filled); 439 * `None` for a category dimension or if you want to; 440 use the default binning of the RooFit variable; 441 variables (RooArgSet, or list/tuple of RooAbsArgs):; 442 Specification of the variables in the RooDataHist, will be; 443 forwarded to the RooDataHist constructor. Both real values and; 444 categories are supported.; 445 ranges (list): An optional list specifying the variable range; 446 limits. Each element is either:; 447 * `None` if a full bin edges array is given to; 448 `bins` or for a category dimension; 449 * a tuple with two values corresponding to the; 450 minimum and maximum values; 451 weights_squared_sum (numpy.ndarray):; 452 The sum of squared weights of the original samples that were; 453 used to fill the histogram. If the input weights are from a; 454 weighted histogram, this parameter is no longer optional.; 455 name (str): Name of the RooDataSet, `None` is equivalent to an; 456 empty string.; 457 title (str): Title of the RooDataSet, `None` is equivalent to an; 458 empty string.; 459 ; 460Returns:; 461 RooDataHist; 462 ; 463\anc",MatchSource.WIKI,doc/master/__roofit_8pyzdoc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html
https://root.cern/doc/master/__roofit_8pyzdoc_source.html:22791,Modifiability,variab,variables,22791,"ataHist(std::string_view name, std::string_view title, const RooArgList& vars, RooCategory& indexCat, std::map<std::string,TH1*> histMap, Double_t initWgt); 421 ; 422\see RooDataHist(std::string_view name, std::string_view title, const RooArgList& vars, RooCategory& indexCat, std::map<std::string,RooDataHist*> dhistMap, Double_t wgt); 423 ; 424\anchor _roodatahist_from_numpy; 425### RooDataHist.from_numpy; 426Create a RooDataHist from numpy arrays.; 427 ; 428Note: The argument structure was inspired by numpy.histogramdd.; 429 ; 430Args:; 431 hist_weights (numpy.ndarray): The multidimensional histogram bin; 432 weights.; 433 bins (list): The bin specification, where each element is either:; 434 * a numpy array describing the monotonically; 435 increasing bin edges along each dimension.; 436 * a scalar value for the number of bins (in this; 437 case, the corresponding item in the `ranges`; 438 argument must be filled); 439 * `None` for a category dimension or if you want to; 440 use the default binning of the RooFit variable; 441 variables (RooArgSet, or list/tuple of RooAbsArgs):; 442 Specification of the variables in the RooDataHist, will be; 443 forwarded to the RooDataHist constructor. Both real values and; 444 categories are supported.; 445 ranges (list): An optional list specifying the variable range; 446 limits. Each element is either:; 447 * `None` if a full bin edges array is given to; 448 `bins` or for a category dimension; 449 * a tuple with two values corresponding to the; 450 minimum and maximum values; 451 weights_squared_sum (numpy.ndarray):; 452 The sum of squared weights of the original samples that were; 453 used to fill the histogram. If the input weights are from a; 454 weighted histogram, this parameter is no longer optional.; 455 name (str): Name of the RooDataSet, `None` is equivalent to an; 456 empty string.; 457 title (str): Title of the RooDataSet, `None` is equivalent to an; 458 empty string.; 459 ; 460Returns:; 461 RooDataHist; 462 ; 463\anc",MatchSource.WIKI,doc/master/__roofit_8pyzdoc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html
https://root.cern/doc/master/__roofit_8pyzdoc_source.html:22869,Modifiability,variab,variables,22869,"ataHist(std::string_view name, std::string_view title, const RooArgList& vars, RooCategory& indexCat, std::map<std::string,TH1*> histMap, Double_t initWgt); 421 ; 422\see RooDataHist(std::string_view name, std::string_view title, const RooArgList& vars, RooCategory& indexCat, std::map<std::string,RooDataHist*> dhistMap, Double_t wgt); 423 ; 424\anchor _roodatahist_from_numpy; 425### RooDataHist.from_numpy; 426Create a RooDataHist from numpy arrays.; 427 ; 428Note: The argument structure was inspired by numpy.histogramdd.; 429 ; 430Args:; 431 hist_weights (numpy.ndarray): The multidimensional histogram bin; 432 weights.; 433 bins (list): The bin specification, where each element is either:; 434 * a numpy array describing the monotonically; 435 increasing bin edges along each dimension.; 436 * a scalar value for the number of bins (in this; 437 case, the corresponding item in the `ranges`; 438 argument must be filled); 439 * `None` for a category dimension or if you want to; 440 use the default binning of the RooFit variable; 441 variables (RooArgSet, or list/tuple of RooAbsArgs):; 442 Specification of the variables in the RooDataHist, will be; 443 forwarded to the RooDataHist constructor. Both real values and; 444 categories are supported.; 445 ranges (list): An optional list specifying the variable range; 446 limits. Each element is either:; 447 * `None` if a full bin edges array is given to; 448 `bins` or for a category dimension; 449 * a tuple with two values corresponding to the; 450 minimum and maximum values; 451 weights_squared_sum (numpy.ndarray):; 452 The sum of squared weights of the original samples that were; 453 used to fill the histogram. If the input weights are from a; 454 weighted histogram, this parameter is no longer optional.; 455 name (str): Name of the RooDataSet, `None` is equivalent to an; 456 empty string.; 457 title (str): Title of the RooDataSet, `None` is equivalent to an; 458 empty string.; 459 ; 460Returns:; 461 RooDataHist; 462 ; 463\anc",MatchSource.WIKI,doc/master/__roofit_8pyzdoc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html
https://root.cern/doc/master/__roofit_8pyzdoc_source.html:23058,Modifiability,variab,variable,23058,"RooDataHist*> dhistMap, Double_t wgt); 423 ; 424\anchor _roodatahist_from_numpy; 425### RooDataHist.from_numpy; 426Create a RooDataHist from numpy arrays.; 427 ; 428Note: The argument structure was inspired by numpy.histogramdd.; 429 ; 430Args:; 431 hist_weights (numpy.ndarray): The multidimensional histogram bin; 432 weights.; 433 bins (list): The bin specification, where each element is either:; 434 * a numpy array describing the monotonically; 435 increasing bin edges along each dimension.; 436 * a scalar value for the number of bins (in this; 437 case, the corresponding item in the `ranges`; 438 argument must be filled); 439 * `None` for a category dimension or if you want to; 440 use the default binning of the RooFit variable; 441 variables (RooArgSet, or list/tuple of RooAbsArgs):; 442 Specification of the variables in the RooDataHist, will be; 443 forwarded to the RooDataHist constructor. Both real values and; 444 categories are supported.; 445 ranges (list): An optional list specifying the variable range; 446 limits. Each element is either:; 447 * `None` if a full bin edges array is given to; 448 `bins` or for a category dimension; 449 * a tuple with two values corresponding to the; 450 minimum and maximum values; 451 weights_squared_sum (numpy.ndarray):; 452 The sum of squared weights of the original samples that were; 453 used to fill the histogram. If the input weights are from a; 454 weighted histogram, this parameter is no longer optional.; 455 name (str): Name of the RooDataSet, `None` is equivalent to an; 456 empty string.; 457 title (str): Title of the RooDataSet, `None` is equivalent to an; 458 empty string.; 459 ; 460Returns:; 461 RooDataHist; 462 ; 463\anchor _roodatahist_to_numpy; 464### RooDataHist.to_numpy; 465Converts the weights and bin edges of a RooDataHist to numpy arrays.; 466 ; 467Note: The output structure was inspired by numpy.histogramdd.; 468 ; 469Returns:; 470 weight (numpy.ndarray): The weights for each histrogram bin.; 471 bin_edg",MatchSource.WIKI,doc/master/__roofit_8pyzdoc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html
https://root.cern/doc/master/__roofit_8pyzdoc_source.html:25585,Modifiability,variab,variables,25585,"ArgSet(x, y))); 485 ; 486# With keyword arguments:; 487dxy = ROOT.RooDataSet(""dxy"", ""dxy"", ROOT.RooArgSet(x, y), StoreError=(ROOT.RooArgSet(x, y))); 488\endcode; 489 ; 490\anchor _roodataset___init__; 491### RooDataSet.__init__; 492The RooDataSet constructor is pythonized with the command argument pythonization.; 493The keywords must correspond to the CmdArgs of the constructor.; 494 ; 495\see RooDataSet(std::string_view name, std::string_view title, const RooArgSet& vars, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4,const RooCmdArg& arg5, const RooCmdArg& arg6,const RooCmdArg& arg7,const RooCmdArg& arg8); 496 ; 497\anchor _roodataset_from_numpy; 498### RooDataSet.from_numpy; 499Create a RooDataSet from a dictionary of numpy arrays.; 500Args:; 501 data (dict): Dictionary with strings as keys and numpy arrays as; 502 values, to be imported into the RooDataSet.; 503 variables (RooArgSet, or list/tuple of RooAbsArgs):; 504 Specification of the variables in the RooDataSet, will be; 505 forwarded to the RooDataSet constructor. Both real values and; 506 categories are supported.; 507 name (str): Name of the RooDataSet, `None` is equivalent to an; 508 empty string.; 509 title (str): Title of the RooDataSet, `None` is equivalent to an; 510 empty string.; 511 weight_name (str): Key of the array in `data` that will be used for; 512 the dataset weights.; 513 ; 514Returns:; 515 RooDataSet; 516 ; 517\anchor _roodataset_from_pandas; 518### RooDataSet.from_pandas; 519Create a RooDataSet from a pandas DataFrame.; 520Args:; 521 df (pandas.DataFrame): Pandas DataFrame to import.; 522 variables (RooArgSet, or list/tuple of RooAbsArgs):; 523 Specification of the variables in the RooDataSet, will be; 524 forwarded to the RooDataSet constructor. Both real values and; 525 categories are supported.; 526 name (str): Name of the RooDataSet, `None` is equivalent to an; 527 empty string.; 528 title (str): Title of the RooDataSet, `None` is equivale",MatchSource.WIKI,doc/master/__roofit_8pyzdoc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html
https://root.cern/doc/master/__roofit_8pyzdoc_source.html:25663,Modifiability,variab,variables,25663,"ArgSet(x, y))); 485 ; 486# With keyword arguments:; 487dxy = ROOT.RooDataSet(""dxy"", ""dxy"", ROOT.RooArgSet(x, y), StoreError=(ROOT.RooArgSet(x, y))); 488\endcode; 489 ; 490\anchor _roodataset___init__; 491### RooDataSet.__init__; 492The RooDataSet constructor is pythonized with the command argument pythonization.; 493The keywords must correspond to the CmdArgs of the constructor.; 494 ; 495\see RooDataSet(std::string_view name, std::string_view title, const RooArgSet& vars, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4,const RooCmdArg& arg5, const RooCmdArg& arg6,const RooCmdArg& arg7,const RooCmdArg& arg8); 496 ; 497\anchor _roodataset_from_numpy; 498### RooDataSet.from_numpy; 499Create a RooDataSet from a dictionary of numpy arrays.; 500Args:; 501 data (dict): Dictionary with strings as keys and numpy arrays as; 502 values, to be imported into the RooDataSet.; 503 variables (RooArgSet, or list/tuple of RooAbsArgs):; 504 Specification of the variables in the RooDataSet, will be; 505 forwarded to the RooDataSet constructor. Both real values and; 506 categories are supported.; 507 name (str): Name of the RooDataSet, `None` is equivalent to an; 508 empty string.; 509 title (str): Title of the RooDataSet, `None` is equivalent to an; 510 empty string.; 511 weight_name (str): Key of the array in `data` that will be used for; 512 the dataset weights.; 513 ; 514Returns:; 515 RooDataSet; 516 ; 517\anchor _roodataset_from_pandas; 518### RooDataSet.from_pandas; 519Create a RooDataSet from a pandas DataFrame.; 520Args:; 521 df (pandas.DataFrame): Pandas DataFrame to import.; 522 variables (RooArgSet, or list/tuple of RooAbsArgs):; 523 Specification of the variables in the RooDataSet, will be; 524 forwarded to the RooDataSet constructor. Both real values and; 525 categories are supported.; 526 name (str): Name of the RooDataSet, `None` is equivalent to an; 527 empty string.; 528 title (str): Title of the RooDataSet, `None` is equivale",MatchSource.WIKI,doc/master/__roofit_8pyzdoc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html
https://root.cern/doc/master/__roofit_8pyzdoc_source.html:26301,Modifiability,variab,variables,26301,"et.from_numpy; 499Create a RooDataSet from a dictionary of numpy arrays.; 500Args:; 501 data (dict): Dictionary with strings as keys and numpy arrays as; 502 values, to be imported into the RooDataSet.; 503 variables (RooArgSet, or list/tuple of RooAbsArgs):; 504 Specification of the variables in the RooDataSet, will be; 505 forwarded to the RooDataSet constructor. Both real values and; 506 categories are supported.; 507 name (str): Name of the RooDataSet, `None` is equivalent to an; 508 empty string.; 509 title (str): Title of the RooDataSet, `None` is equivalent to an; 510 empty string.; 511 weight_name (str): Key of the array in `data` that will be used for; 512 the dataset weights.; 513 ; 514Returns:; 515 RooDataSet; 516 ; 517\anchor _roodataset_from_pandas; 518### RooDataSet.from_pandas; 519Create a RooDataSet from a pandas DataFrame.; 520Args:; 521 df (pandas.DataFrame): Pandas DataFrame to import.; 522 variables (RooArgSet, or list/tuple of RooAbsArgs):; 523 Specification of the variables in the RooDataSet, will be; 524 forwarded to the RooDataSet constructor. Both real values and; 525 categories are supported.; 526 name (str): Name of the RooDataSet, `None` is equivalent to an; 527 empty string.; 528 title (str): Title of the RooDataSet, `None` is equivalent to an; 529 empty string.; 530 weight_name (str): Key of the array in `data` that will be used for; 531 the dataset weights.; 532 ; 533Returns:; 534 RooDataSet; 535 ; 536\anchor _roodataset_plotonxy; 537### RooDataSet.plotOnXY; 538The RooDataSet::plotOnXY() function is pythonized with the command argument pythonization.; 539The keywords must correspond to the CmdArgs of the function.; 540 ; 541\see RooDataSet::plotOnXY(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 542 ; 543\anchor _roodataset_to_numpy; 544### RooDataSet.to_numpy; 545Export a RooDa",MatchSource.WIKI,doc/master/__roofit_8pyzdoc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html
https://root.cern/doc/master/__roofit_8pyzdoc_source.html:26379,Modifiability,variab,variables,26379,"et.from_numpy; 499Create a RooDataSet from a dictionary of numpy arrays.; 500Args:; 501 data (dict): Dictionary with strings as keys and numpy arrays as; 502 values, to be imported into the RooDataSet.; 503 variables (RooArgSet, or list/tuple of RooAbsArgs):; 504 Specification of the variables in the RooDataSet, will be; 505 forwarded to the RooDataSet constructor. Both real values and; 506 categories are supported.; 507 name (str): Name of the RooDataSet, `None` is equivalent to an; 508 empty string.; 509 title (str): Title of the RooDataSet, `None` is equivalent to an; 510 empty string.; 511 weight_name (str): Key of the array in `data` that will be used for; 512 the dataset weights.; 513 ; 514Returns:; 515 RooDataSet; 516 ; 517\anchor _roodataset_from_pandas; 518### RooDataSet.from_pandas; 519Create a RooDataSet from a pandas DataFrame.; 520Args:; 521 df (pandas.DataFrame): Pandas DataFrame to import.; 522 variables (RooArgSet, or list/tuple of RooAbsArgs):; 523 Specification of the variables in the RooDataSet, will be; 524 forwarded to the RooDataSet constructor. Both real values and; 525 categories are supported.; 526 name (str): Name of the RooDataSet, `None` is equivalent to an; 527 empty string.; 528 title (str): Title of the RooDataSet, `None` is equivalent to an; 529 empty string.; 530 weight_name (str): Key of the array in `data` that will be used for; 531 the dataset weights.; 532 ; 533Returns:; 534 RooDataSet; 535 ; 536\anchor _roodataset_plotonxy; 537### RooDataSet.plotOnXY; 538The RooDataSet::plotOnXY() function is pythonized with the command argument pythonization.; 539The keywords must correspond to the CmdArgs of the function.; 540 ; 541\see RooDataSet::plotOnXY(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 542 ; 543\anchor _roodataset_to_numpy; 544### RooDataSet.to_numpy; 545Export a RooDa",MatchSource.WIKI,doc/master/__roofit_8pyzdoc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html
https://root.cern/doc/master/__roofit_8pyzdoc_source.html:27746,Modifiability,variab,variable,27746,"used for; 531 the dataset weights.; 532 ; 533Returns:; 534 RooDataSet; 535 ; 536\anchor _roodataset_plotonxy; 537### RooDataSet.plotOnXY; 538The RooDataSet::plotOnXY() function is pythonized with the command argument pythonization.; 539The keywords must correspond to the CmdArgs of the function.; 540 ; 541\see RooDataSet::plotOnXY(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2, const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 542 ; 543\anchor _roodataset_to_numpy; 544### RooDataSet.to_numpy; 545Export a RooDataSet to a dictionary of numpy arrays.; 546 ; 547Args:; 548 copy (bool): If False, the data will not be copied. Use with; 549 caution, as the numpy arrays and the RooAbsData now; 550 own the same memory. If the dataset uses a; 551 RooTreeDataStore, there will always be a copy and the; 552 copy argument is ignored.; 553 ; 554Returns:; 555 dict: A dictionary with the variable or weight names as keys and; 556 the numpy arrays as values.; 557 ; 558\anchor _roodataset_to_pandas; 559### RooDataSet.to_pandas; 560Export a RooDataSet to a pandas DataFrame.; 561 ; 562Args:; 563 ; 564Note:; 565 Pandas copies the data from the numpy arrays when creating a; 566 DataFrame. That's why we can disable copying in the to_numpy call.; 567 ; 568Returns:; 569 pandas.DataFrame: A dataframe with the variable or weight names as; 570 column names and the a row for each variable or; 571 weight in the dataset.; 572 ; 573\anchor _roodecay; 574## RooDecay; 575\see RooDecay; 576 ; 577Some constructors of classes like RooDecay, RooBDecay, RooBCPGenDecay, RooBCPEffDecay and RooBMixDecay that take an enum; 578DecayType as argument also support keyword arguments.; 579For example, the following code is equivalent in PyROOT:; 580\code{.py}; 581# Directly passing keyword argument with string corresponding to enum value name:; 582decay_tm = ROOT.RooDecay(""decay_tm"", ""decay"", dt, tau, tm, ROOT",MatchSource.WIKI,doc/master/__roofit_8pyzdoc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html
https://root.cern/doc/master/__roofit_8pyzdoc_source.html:28165,Modifiability,variab,variable,28165,"oCmdArg& arg5, const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8) const; 542 ; 543\anchor _roodataset_to_numpy; 544### RooDataSet.to_numpy; 545Export a RooDataSet to a dictionary of numpy arrays.; 546 ; 547Args:; 548 copy (bool): If False, the data will not be copied. Use with; 549 caution, as the numpy arrays and the RooAbsData now; 550 own the same memory. If the dataset uses a; 551 RooTreeDataStore, there will always be a copy and the; 552 copy argument is ignored.; 553 ; 554Returns:; 555 dict: A dictionary with the variable or weight names as keys and; 556 the numpy arrays as values.; 557 ; 558\anchor _roodataset_to_pandas; 559### RooDataSet.to_pandas; 560Export a RooDataSet to a pandas DataFrame.; 561 ; 562Args:; 563 ; 564Note:; 565 Pandas copies the data from the numpy arrays when creating a; 566 DataFrame. That's why we can disable copying in the to_numpy call.; 567 ; 568Returns:; 569 pandas.DataFrame: A dataframe with the variable or weight names as; 570 column names and the a row for each variable or; 571 weight in the dataset.; 572 ; 573\anchor _roodecay; 574## RooDecay; 575\see RooDecay; 576 ; 577Some constructors of classes like RooDecay, RooBDecay, RooBCPGenDecay, RooBCPEffDecay and RooBMixDecay that take an enum; 578DecayType as argument also support keyword arguments.; 579For example, the following code is equivalent in PyROOT:; 580\code{.py}; 581# Directly passing keyword argument with string corresponding to enum value name:; 582decay_tm = ROOT.RooDecay(""decay_tm"", ""decay"", dt, tau, tm, ROOT.RooDecay.DoubleSided); 583 ; 584# With enum value:; 585decay_tm = ROOT.RooDecay(""decay_tm"", ""decay"", dt, tau, tm, type=""DoubleSided""); 586\endcode; 587 ; 588\anchor _roodecay___init__; 589### RooDecay.__init__; 590The RooDecay constructor is pythonized with enum values.; 591 ; 592\see RooDecay(const char *name, const char *title, RooRealVar& t, RooAbsReal& tau, const RooResolutionModel& model, DecayType type); 593 ; 594\anchor _roogenfitstudy; ",MatchSource.WIKI,doc/master/__roofit_8pyzdoc_source.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/doc/master/__roofit_8pyzdoc_source.html
