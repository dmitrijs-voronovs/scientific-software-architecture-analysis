id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:26922,Testability,log,logger,26922,"ct for x in range(self.num_tslots)]; if self.prop_computer.grad_exact and self.cache_prop_grad:; self._prop_grad = np.empty([self.num_tslots, self.num_ctrls],; dtype=object); # Time evolution operator (forward propagation); self._fwd_evo = [object for x in range(self.num_tslots+1)]; self._fwd_evo[0] = self._initial; if self.fid_computer.uses_onwd_evo:; # Time evolution operator (onward propagation); self._onwd_evo = [object for x in range(self.num_tslots)]; if self.fid_computer.uses_onto_evo:; # Onward propagation overlap with inverse target; self._onto_evo = [object for x in range(self.num_tslots+1)]; self._onto_evo[self.num_tslots] = self._get_onto_evo_target(); ; if isinstance(self.prop_computer, propcomp.PropCompDiag):; self._create_decomp_lists(). if (self.log_level <= logging.DEBUG; and isinstance(self, DynamicsUnitary)):; self.unitarity_check_level = 1. if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Dynamics dump will be written to:\n{}"".format(; self.dump.dump_dir)); ; self._evo_initialized = True. @property; def dyn_gen_phase(self):; """"""; Some op that is applied to the dyn_gen before expontiating to; get the propagator.; See `phase_application` for how this is applied; """"""; # Note that if this returns None then _apply_phase will never be; # called; return self._dyn_gen_phase; ; @dyn_gen_phase.setter; def dyn_gen_phase(self, value):; self._dyn_gen_phase = value; ; @property; def phase_application(self):; """"""; phase_application : scalar(string), default='preop'; Determines how the phase is applied to the dynamics generators; - 'preop' : P = expm(phase*dyn_gen); - 'postop' : P = expm(dyn_gen*phase); - 'custom' : Customised phase application; The 'custom' option assumes that the _apply_phase method has been; set to a custom function; """"""; return self._phase_application. @phase_application.setter; def phase_application(self, value):; self._set_phase_application(val",MatchSource.WIKI,docs/4.3/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:32386,Testability,log,logged,32386,"s(amps). def check_ctrls_initialized(self):; if not self._ctrls_initialized:; raise errors.UsageError(; ""Controls not initialised. ""; ""Ensure Dynamics.initialize_controls has been ""; ""executed with the initial control amplitudes.""). def get_amp_times(self):; return self.time[:self.num_tslots]. [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by t",MatchSource.WIKI,docs/4.3/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:32681,Testability,log,logger,32681," [docs] def save_amps(self, file_name=None, times=None, amps=None, verbose=False):; """"""; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters; ----------; file_name : string; Name of the file; If None given the def_amps_fname attribuite will be used. times : List type (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.co",MatchSource.WIKI,docs/4.3/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:33020,Testability,log,logger,33020,"e (or string); List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this return",MatchSource.WIKI,docs/4.3/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:33099,Testability,log,logger,33099," each slot; If None given this will be retrieved through get_amp_times(); If 'exclude' then times will not be saved in the file, just; the amplitudes. amps : Array[num_tslots, num_ctrls]; Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verbose : Boolean; If True then an info message will be logged; """"""; self.check_ctrls_initialized(). inctimes = True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh",MatchSource.WIKI,docs/4.3/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:33443,Testability,log,logging,33443,"= True; if file_name is None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]; ; [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs""""""; ; if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeErro",MatchSource.WIKI,docs/4.3/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:33467,Testability,log,logger,33467,"s None:; file_name = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]; ; [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs""""""; ; if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeError(""Unable to determine",MatchSource.WIKI,docs/4.3/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:33474,Testability,log,log,33474," = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]; ; [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs""""""; ; if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeError(""Unable to determine drift attributes",MatchSource.WIKI,docs/4.3/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:33478,Testability,log,logging,33478," = self.def_amps_fname; if amps is None:; amps = self.ctrl_amps; if times is None:; times = self.get_amp_times(); else:; if _is_string(times):; if times.lower() == 'exclude':; inctimes = False; else:; logger.warn(""Unknown option for times '{}' ""; ""when saving amplitudes"".format(times)); times = self.get_amp_times(). try:; if inctimes:; shp = amps.shape; data = np.empty([shp[0], shp[1] + 1], dtype=float); data[:, 0] = times; data[:, 1:] = amps; else:; data = amps. np.savetxt(file_name, data, delimiter='\t', fmt='%14.6g'). if verbose:; logger.info(""Amplitudes saved to file: "" + file_name); except Exception as e:; logger.error(""Failed to save amplitudes due to underling ""; ""error: {}"".format(e)). [docs] def update_ctrl_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer; """""". if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Updating amplitudes...\n""; ""Current control amplitudes:\n"" + str(self.ctrl_amps) +; ""\n(potenially) new amplitudes:\n"" + str(new_amps)). self.tslot_computer.compare_amps(new_amps). [docs] def flag_system_changed(self):; """"""; Flag evolution, fidelity and gradients as needing recalculation; """"""; self.evo_current = False; self.fid_computer.flag_system_changed(). [docs] def get_drift_dim(self):; """"""; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N; """"""; if self.dyn_shape is None:; self.refresh_drift_attribs(); return self.dyn_shape[0]; ; [docs] def refresh_drift_attribs(self):; """"""Reset the dyn_shape, dyn_dims and time_depend_drift attribs""""""; ; if isinstance(self.drift_dyn_gen, (list, tuple)):; d0 = self.drift_dyn_gen[0]; self.time_depend_drift = True; else:; d0 = self.drift_dyn_gen; self.time_depend_drift = False. if not isinstance(d0, Qobj):; raise TypeError(""Unable to determine drift attributes",MatchSource.WIKI,docs/4.3/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:42989,Testability,log,logging,42989,"._onwd_evo_qobj. @property; def evo_t2targ(self):; _attrib_deprecation(; ""'evo_t2targ' has been replaced by '_onto_evo'""); return self._onto_evo. @property; def onto_evo(self):; """"""; List of evolution operators (Qobj) from the initial to the given; timeslot; """"""; if self._onto_evo is not None:; if self._onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def",MatchSource.WIKI,docs/4.3/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:43013,Testability,log,logger,43013,"erty; def evo_t2targ(self):; _attrib_deprecation(; ""'evo_t2targ' has been replaced by '_onto_evo'""); return self._onto_evo. @property; def onto_evo(self):; """"""; List of evolution operators (Qobj) from the initial to the given; timeslot; """"""; if self._onto_evo is not None:; if self._onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):",MatchSource.WIKI,docs/4.3/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:43020,Testability,log,log,43020,"rg(self):; _attrib_deprecation(; ""'evo_t2targ' has been replaced by '_onto_evo'""); return self._onto_evo. @property; def onto_evo(self):; """"""; List of evolution operators (Qobj) from the initial to the given; timeslot; """"""; if self._onto_evo is not None:; if self._onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whe",MatchSource.WIKI,docs/4.3/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:43024,Testability,log,logging,43024,"rg(self):; _attrib_deprecation(; ""'evo_t2targ' has been replaced by '_onto_evo'""); return self._onto_evo. @property; def onto_evo(self):; """"""; List of evolution operators (Qobj) from the initial to the given; timeslot; """"""; if self._onto_evo is not None:; if self._onto_evo_qobj is None:; if self.oper_dtype == Qobj:; self._onto_evo_qobj = self._onto_evo; else:; self._onto_evo_qobj = []; for k in range(0, self.num_tslots):; self._onto_evo_qobj.append(Qobj(self._onto_evo[k],; dims=self.sys_dims)); self._onto_evo_qobj.append(self.onto_evo_target). return self._onto_evo_qobj. [docs] def compute_evolution(self):; """"""; Recalculate the time evolution operators; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; Actual work is completed by the recompute_evolution method; of the timeslot computer; """""". # Check if values are already current, otherwise calculate all values; if not self.evo_current:; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Computing evolution""); self.tslot_computer.recompute_evolution(); self.evo_current = True; return True; else:; return False. def _ensure_decomp_curr(self, k):; """"""; Checks to see if the diagonalisation has been completed since; the last update of the dynamics generators; (after the amplitude update); If not then the diagonlisation is completed; """"""; if self._decomp_curr is None:; raise errors.UsageError(""Decomp lists have not been created""); if not self._decomp_curr[k]:; self._spectral_decomp(k). def _spectral_decomp(self, k):; """"""; Calculate the diagonalization of the dynamics generator; generating lists of eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whe",MatchSource.WIKI,docs/4.3/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:44665,Testability,log,logger,44665,"f eigenvectors, propagators in the diagonalised; basis, and the 'factormatrix' used in calculating the propagator; gradient; Not implemented in this base class, because the method is specific; to the matrix type; """"""; raise errors.UsageError(""Decomposition cannot be completed by ""; ""this class. Try a(nother) subclass""). def _is_unitary(self, A):; """"""; Checks whether operator A is unitary; A can be either Qobj or ndarray; """"""; if isinstance(A, Qobj):; unitary = np.allclose(np.eye(A.shape[0]), A*A.dag().full(),; atol=self.unitarity_tol); else:; unitary = np.allclose(np.eye(len(A)), A.dot(A.T.conj()),; atol=self.unitarity_tol). return unitary. def _calc_unitary_err(self, A):; if isinstance(A, Qobj):; err = np.sum(abs(np.eye(A.shape[0]) - A*A.dag().full())); else:; err = np.sum(abs(np.eye(len(A)) - A.dot(A.T.conj()))). return err. [docs] def unitarity_check(self):; """"""; Checks whether all propagators are unitary; """"""; for k in range(self.num_tslots):; if not self._is_unitary(self._prop[k]):; logger.warning(; ""Progator of timeslot {} is not unitary"".format(k)). [docs]class DynamicsGenMat(Dynamics):; """"""; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Lindbladian; """"""; def reset(self):; Dynamics.reset(self); self.id_text = 'GEN_MAT'; self.apply_params(). [docs]class DynamicsUnitary(Dynamics):; """"""; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes; ----------; drift_ham : Qobj; This is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_ham : List of Qobj; These are the control Hamiltonians for unitary dynamics; It is",MatchSource.WIKI,docs/4.3/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:51287,Testability,log,logger,51287,"t None:; self._dyn_gen_eigenvectors_adj[k] = \; self._dyn_gen_eigenvectors[k].dag(); else:; self._prop_eigen[k] = np.diagflat(prop_eig); self._dyn_gen_eigenvectors[k] = eig_vec; # The _dyn_gen_eigenvectors_adj list is not used in; # memory optimised modes; if self._dyn_gen_eigenvectors_adj is not None:; self._dyn_gen_eigenvectors_adj[k] = \; self._dyn_gen_eigenvectors[k].conj().T. def _get_dyn_gen_eigenvectors_adj(self, k):; # The _dyn_gen_eigenvectors_adj list is not used in; # memory optimised modes; if self._dyn_gen_eigenvectors_adj is not None:; return self._dyn_gen_eigenvectors_adj[k]; else:; if self.oper_dtype == Qobj:; return self._dyn_gen_eigenvectors[k].dag(); else:; return self._dyn_gen_eigenvectors[k].conj().T. [docs] def check_unitarity(self):; """"""; Checks whether all propagators are unitary; For propagators found not to be unitary, the potential underlying; causes are investigated.; """"""; for k in range(self.num_tslots):; prop_unit = self._is_unitary(self._prop[k]); if not prop_unit:; logger.warning(; ""Progator of timeslot {} is not unitary"".format(k)); if not prop_unit or self.unitarity_check_level > 1:; # Check Hamiltonian; H = self._dyn_gen[k]; if isinstance(H, Qobj):; herm = H.isherm; else:; diff = np.abs(H.T.conj() - H); herm = False if np.any(diff > settings.atol) else True; eigval_unit = self._is_unitary(self._prop_eigen[k]); eigvec_unit = self._is_unitary(self._dyn_gen_eigenvectors[k]); if self._dyn_gen_eigenvectors_adj is not None:; eigvecadj_unit = self._is_unitary(; self._dyn_gen_eigenvectors_adj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omeg",MatchSource.WIKI,docs/4.3/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:52023,Testability,log,logger,52023,"rs[k].conj().T. [docs] def check_unitarity(self):; """"""; Checks whether all propagators are unitary; For propagators found not to be unitary, the potential underlying; causes are investigated.; """"""; for k in range(self.num_tslots):; prop_unit = self._is_unitary(self._prop[k]); if not prop_unit:; logger.warning(; ""Progator of timeslot {} is not unitary"".format(k)); if not prop_unit or self.unitarity_check_level > 1:; # Check Hamiltonian; H = self._dyn_gen[k]; if isinstance(H, Qobj):; herm = H.isherm; else:; diff = np.abs(H.T.conj() - H); herm = False if np.any(diff > settings.atol) else True; eigval_unit = self._is_unitary(self._prop_eigen[k]); eigvec_unit = self._is_unitary(self._dyn_gen_eigenvectors[k]); if self._dyn_gen_eigenvectors_adj is not None:; eigvecadj_unit = self._is_unitary(; self._dyn_gen_eigenvectors_adj[k]); else:; eigvecadj_unit = None; msg = (""prop unit: {}; H herm: {}; ""; ""eigval unit: {}; eigvec unit: {}; ""; ""eigvecadj_unit: {}"".format(; prop_unit, herm, eigval_unit, eigvec_unit,; eigvecadj_unit)); logger.info(msg). [docs]class DynamicsSymplectic(Dynamics):; """"""; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes; ----------; omega : array[drift_dyn_gen.shape]; matrix used in the calculation of propagators (time evolution); with symplectic systems.; ; """""". def reset(self):; Dynamics.reset(self); self.id_text = 'SYMPL'; self._omega = None; self._omega_qobj = None; self._phase_application = 'postop'; self.grad_exact = True; self.apply_params(). def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to _UpdateAll; # can be set to _DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUp",MatchSource.WIKI,docs/4.3/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:5037,Usability,simpl,simplefilter,5037,"ls[0], (list, tuple)):; ctrls = np.array(ctrls); except:; pass; ; if isinstance(ctrls, np.ndarray):; if len(ctrls.shape) != 2:; raise TypeError(""Incorrect shape for ctrl dyn gen array""); for k in range(ctrls.shape[0]):; for j in range(ctrls.shape[1]):; if not isinstance(ctrls[k, j], Qobj):; raise TypeError(""All control dyn gen must be Qobj""); elif isinstance(ctrls, (list, tuple)):; for ctrl in ctrls:; if not isinstance(ctrl, Qobj):; raise TypeError(""All control dyn gen must be Qobj"") ; else:; raise TypeError(""Controls list or array not set correctly""); ; return ctrls; ; def _check_drift_dyn_gen(drift):; if not isinstance(drift, Qobj):; if not isinstance(drift, (list, tuple)):; raise TypeError(""drift should be a Qobj or a list of Qobj""); else:; for d in drift:; if not isinstance(d, Qobj):; raise TypeError(; ""drift should be a Qobj or a list of Qobj""). warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class Dynamics(object):; """"""; This is a base class only. See subclass descriptions and choose an; appropriate one for the application. Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes. This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evol",MatchSource.WIKI,docs/4.3/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:16498,Usability,clear,clear,16498,"_prop_grad_qobj = None; self._fwd_evo_qobj = None; self._onwd_evo_qobj = None; self._onto_evo_qobj = None; # Atrributes used in diagonalisation; # again in internal operator data type (see above); self._decomp_curr = None; self._prop_eigen = None; self._dyn_gen_eigenvectors = None; self._dyn_gen_eigenvectors_adj = None; self._dyn_gen_factormatrix = None; self.fact_mat_round_prec = 1e-10. # Debug and information attribs; self.stats = None; self.id_text = 'DYN_BASE'; self.def_amps_fname = ""ctrl_amps.txt""; self.log_level = self.config.log_level; # Internal flags; self._dyn_gen_mapped = False; self._evo_initialized = False; self._timeslots_initialized = False; self._ctrls_initialized = False; self._ctrl_dyn_gen_checked = False; self._drift_dyn_gen_checked = False; # Unitary checking; self.unitarity_check_level = 0; self.unitarity_tol = 1e-10; # Data dumping; self.dump = None; self.dump_to_file = False. self.apply_params(). # Create the computing objects; self._create_computers(). self.clear(). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). @property; def dumping(self):; """"""; The level of data dumping that will occur during the time evolution; calculation.; - NONE : No processing data dumped (Default); - SUMMARY : A summary of each time evolution will be recorded; - FULL : All operators used",MatchSource.WIKI,docs/4.3/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:18932,Usability,clear,clear,18932,"ring(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._tau. @tau.setter; def tau(self, value):; self._tau = value; self.init_timeslots(). [docs] def init_timeslots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set",MatchSource.WIKI,docs/4.3/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html:19048,Usability,clear,clear,19048,"None; else:; if not isinstance(self.dump, qtrldump.DynamicsDump):; self.dump = qtrldump.DynamicsDump(self, level=lvl); else:; self.dump.level = lvl. @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_computers(self):; """"""; Create the default timeslot, fidelity and propagator computers; """"""; # The time slot computer. By default it is set to UpdateAll; # can be set to DynUpdate in the configuration; # (see class file for details); if self.config.tslot_type == 'DYNAMIC':; self.tslot_computer = tslotcomp.TSlotCompDynUpdate(self); else:; self.tslot_computer = tslotcomp.TSlotCompUpdateAll(self). self.prop_computer = propcomp.PropCompFrechet(self); self.fid_computer = fidcomp.FidCompTraceDiff(self). def clear(self):; self.ctrl_amps = None; self.evo_current = False; if self.fid_computer is not None:; self.fid_computer.clear(). @property; def num_tslots(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._num_tslots. @num_tslots.setter; def num_tslots(self, value):; self._num_tslots = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def evo_time(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._evo_time. @evo_time.setter; def evo_time(self, value):; self._evo_time = value; if self._timeslots_initialized:; self._tau = None; self.init_timeslots(). @property; def tau(self):; if not self._timeslots_initialized:; self.init_timeslots(); return self._tau. @tau.setter; def tau(self, value):; self._tau = value; self.init_timeslots(). [docs] def init_timeslots(self):; """"""; Generate the timeslot duration array 'tau' based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array 'time' based on the tau values; """"""; # s",MatchSource.WIKI,docs/4.3/modules/qutip/control/dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/dynamics.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:2316,Availability,error,error,2316," NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:2363,Availability,error,error,2363," NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:3263,Availability,error,errors,3263,"mputer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and c",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:3273,Availability,error,errors,3273,"mputer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and c",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:5478,Availability,error,error,5478,"-----; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_f",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:5794,Availability,error,error,5794,"ed.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_curre",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:5912,Availability,error,error,5912,"_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object ",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:7887,Availability,error,errors,7887,"lse; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecati",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:7947,Availability,error,error,7947,"the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def use",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:8115,Availability,error,error,8115," created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:8238,Availability,error,errors,8238," created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:8300,Availability,error,error,8300,"elf.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); self.uses_onto_evo = value. [docs]class FidCompUnitary(FidelityComputer):; """"""; Comput",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:9292,Availability,error,error,9292,"etting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); return self.uses_onwd_evo. @uses_evo_t2end.setter; def uses_evo_t2end(self, value):; _attrib_deprecation(; ""'uses_evo_t2end' has been replaced by 'uses_onwd_evo'""); self.uses_onwd_evo = value. @property; def uses_evo_t2targ(self):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); return self.uses_onto_evo. @uses_evo_t2targ.setter; def uses_evo_t2targ(self, value):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); self.uses_onto_evo = value. [docs]class FidCompUnitary(FidelityComputer):; """"""; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes; ----------; phase_option : string; determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'UNIT'; self.uses_onto_evo = True; self._init_phase_option('PSU'); self.apply_params(). [docs] def clear(self):; FidelityComputer.clear(self); self.fidelity_prenorm = None; self.fidelity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecate",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:11088,Availability,error,errors,11088," self.apply_params(). [docs] def clear(self):; FidelityComputer.clear(self); self.fidelity_prenorm = None; self.fidelity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; ",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:11189,Availability,error,errors,11189,"ty_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation functio",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:11423,Availability,error,errors,11423,"""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected; """"""; dyn = self.parent; self.dimensional_norm = 1.0; self.dimensional_norm = \; self.fid_norm_func(dyn.target.dag()*dyn.target). [do",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:13763,Availability,error,error,13763," np.real(norm) / self.dimensional_norm. [docs] def normalize_gradient_SU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This SU version respects global phase; """"""; grad_normalized = np.real(grad) / self.dimensional_norm. return grad_normalized. [docs] def normalize_PSU(self, A):; """""". """"""; try:; if A.shape[0] == A.shape[1]:; # input is an operator (Qobj, array, sparse etc), so; norm = _trace(A); else:; raise TypeError(""Cannot compute trace (not square)""); except:; # assume input is already scalar and hence assumed; # to be the prenormalised scalar value, e.g. fidelity; norm = A; return np.abs(norm) / self.dimensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_e",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:15136,Availability,error,error,15136,"er.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_e",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:16147,Availability,error,error,16147," in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:17355,Availability,error,error,17355,"eslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiff(FidelityComputer):; """"""; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityCom",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:17435,Availability,error,error,17435,"eslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiff(FidelityComputer):; """"""; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityCom",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:17930,Availability,error,error,17930,"range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiff(FidelityComputer):; """"""; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; G",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:18021,Availability,error,error,18021," _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiff(FidelityComputer):; """"""; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:18394,Availability,error,errors,18394,"stem dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error u",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:18939,Availability,error,error,18939,"rror calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.deb",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:19381,Availability,error,error,19381,"idelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:19945,Availability,error,error,19945,"or in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplit",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:20093,Availability,error,error,20093,"level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero a",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:20626,Availability,error,error,20626,"o_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:20892,Availability,error,error,20892," = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; g = -2*self.scale_factor*np.real(; (evo_f_diff.dag()*evo_grad).tr()); else:; evo_grad = dyn._get_prop_grad(k, j).dot(fwd_ev",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:23072,Availability,error,error,23072,"s.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiffApprox(FidCompTraceDiff):; """"""; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes; ----------; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude; ; """"""; [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:2644,Deployability,configurat,configuration,2644,"QUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). ",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:6269,Deployability,configurat,configuration,6269,"Computer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.pa",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:7657,Deployability,configurat,configuration,7657,"self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'use",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:11301,Deployability,configurat,configuration,11301," Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected; """"""; dyn = self.parent; ",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:15262,Deployability,update,updates,15262,"er.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_e",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:18597,Deployability,configurat,configuration,18597,"tance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:20219,Deployability,update,updates,20219,"level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero a",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:24463,Deployability,update,updated,24463,"ext = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:2531,Energy Efficiency,efficient,efficient,2531,"TORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated ",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:3375,Integrability,message,message,3375,"n. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the m",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:3463,Integrability,message,message,3463,"n. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the m",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:3551,Integrability,message,message,3551,"ds for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; i",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:3626,Integrability,message,message,3626,"s were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or ab",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:3714,Integrability,message,message,3714,"s were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or ab",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:3802,Integrability,message,message,3802,"es are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimension",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:3876,Integrability,wrap,wrapper,3876,"es are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimension",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:2644,Modifiability,config,configuration,2644,"QUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). ",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:6269,Modifiability,config,configuration,6269,"Computer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.pa",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:7657,Modifiability,config,configuration,7657,"self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculating; self.fid_err_grad_current = False. @property; def uses_evo_t2end(self):; _attrib_deprecation(; ""'use",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:11301,Modifiability,config,configuration,11301," Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to None""; "" for this FidelityComputer.""); else:; raise errors.UsageError(; ""No option for phase_option '{}'"".format(value)); ; [docs] def init_comp(self):; """"""; Check configuration and initialise the normalisation; """"""; if self.fid_norm_func is None or self.grad_norm_func is None:; raise errors.UsageError(""The phase_option must be be set""; ""for this fidelity computer""); self.init_normalization(). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; FidelityComputer.flag_system_changed(self); # Flag the fidelity (prenormalisation) value as needing calculation; self.fidelity_prenorm_current = False. [docs] def init_normalization(self):; """"""; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected; """"""; dyn = self.parent; ",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:14007,Modifiability,config,config,14007,"""""""; grad_normalized = np.real(grad) / self.dimensional_norm. return grad_normalized. [docs] def normalize_PSU(self, A):; """""". """"""; try:; if A.shape[0] == A.shape[1]:; # input is an operator (Qobj, array, sparse etc), so; norm = _trace(A); else:; raise TypeError(""Cannot compute trace (not square)""); except:; # assume input is already scalar and hence assumed; # to be the prenormalised scalar value, e.g. fidelity; norm = A; return np.abs(norm) / self.dimensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; ",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:18597,Modifiability,config,configuration,18597,"tance measure for dynamics described by matrices; Note the gradient calculation is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:14431,Performance,cache,cached,14431,"ensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_pre",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:15196,Performance,cache,cached,15196,"er.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_e",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:20153,Performance,cache,cached,20153,"level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero a",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:19499,Safety,avoid,avoids,19499,"params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(se",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:21718,Safety,avoid,avoids,21718,"ent norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; g = -2*self.scale_factor*np.real(; (evo_f_diff.dag()*evo_grad).tr()); else:; evo_grad = dyn._get_prop_grad(k, j).dot(fwd_evo); if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1].dot(evo_grad); g = -2*self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_grad))); if np.isnan(g):; g = np.Inf. grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiffApprox(FidCompTraceDiff):; """"""; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes; ----------; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude; ; """"""; [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of func",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:23762,Safety,avoid,avoids,23762,"ext = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_final_eps; fid_err_eps = self.scale_factor*np.real(_trace(; evo_f_diff_eps.conj().T.dot(evo_f_diff_eps))). g = (fid_err_eps - curr_fid_err)/self.epsilon; if np.isnan(g):; g = np.Inf. grad[k, j] = g. if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st. return grad.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:3138,Testability,log,logging,3138,"d; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:3177,Testability,log,logging,3177," # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class ",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:3186,Testability,log,logger,3186," # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class ",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:3195,Testability,log,logging,3195," # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class ",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:4517,Testability,log,logger,4517,"e function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_norm : float; Normalisation constant. fid_norm_func : function; Used to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_func : function; Used to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evo : boolean; flag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity er",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:7394,Testability,log,logger,7394," self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have b",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:7515,Testability,log,logger,7515,"unc = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """,MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:7536,Testability,log,logger,7536,"unc = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """,MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:7563,Testability,log,logger,7563,"pply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; """"""; # optionally implemented in subclass; pass. [docs] def get_fid_err(self):; """"""; returns the absolute distance from the maximum achievable fidelity; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for getting fidelity error.""; "" Suspect base class was used where sub class should have been""). [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude; """"""; # must be implemented by subclass; raise errors.UsageError(""No method defined for getting fidelity""; "" error gradient. Suspect base class was""; "" used where sub class should have been""). [docs] def flag_system_changed(self):; """"""; Flag fidelity and gradients as needing recalculation; """"""; self.fidelity_current = False; # Flag gradient as needing recalculatin",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:14170,Testability,log,logging,14170,"A); else:; raise TypeError(""Cannot compute trace (not square)""); except:; # assume input is already scalar and hence assumed; # to be the prenormalised scalar value, e.g. fidelity; norm = A; return np.abs(norm) / self.dimensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrl",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:14186,Testability,log,logger,14186,"ypeError(""Cannot compute trace (not square)""); except:; # assume input is already scalar and hence assumed; # to be the prenormalised scalar value, e.g. fidelity; norm = A; return np.abs(norm) / self.dimensional_norm. [docs] def normalize_gradient_PSU(self, grad):; """"""; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase; """"""; fid_pn = self.get_fidelity_prenorm(); grad_normalized = np.real(grad * np.exp(-1j * np.angle(fid_pn)) /; self.dimensional_norm); return grad_normalized. [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; return np.abs(1 - self.get_fidelity()). [docs] def get_fidelity(self):; """"""; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The grad",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:14915,Testability,log,logging,14915,"alue; The normalisation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:14931,Testability,log,logger,14931,"ation is determined by the fid_norm_func pointer; which should be set in the config; """"""; if not self.fidelity_current:; self.fidelity = \; self.fid_norm_func(self.get_fidelity_prenorm()); self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (normalised): {}"".format(self.fidelity)). return self.fidelity. [docs] def get_fidelity_prenorm(self):; """"""; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; i",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:15441,Testability,log,logging,15441," because it is used in the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; co",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:15465,Testability,log,logger,15465," the gradient calculation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:15472,Testability,log,log,15472,"ulation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients ",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:15476,Testability,log,logging,15476,"ulation; """"""; if not self.fidelity_prenorm_current:; dyn = self.parent; k = dyn.tslot_computer._get_timeslot_for_fidelity_calc(); dyn.compute_evolution(); if dyn.oper_dtype == Qobj:; f = (dyn._onto_evo[k]*dyn._fwd_evo[k]).tr(); else:; f = _trace(dyn._onto_evo[k].dot(dyn._fwd_evo[k])); self.fidelity_prenorm = f; self.fidelity_prenorm_current = True; if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity (pre normalisation): {}"".format(; self.fidelity_prenorm)); return self.fidelity_prenorm. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients ",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:16068,Testability,log,logging,16068,"_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_e",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:16092,Testability,log,logger,16092," Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:16099,Testability,log,log,16099,"lised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.do",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:16103,Testability,log,logging,16103,"lised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.do",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:16222,Testability,log,logging,16222," requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradien",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:16238,Testability,log,logger,16238,"le times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; grad_prenorm = self.compute_fid_grad(); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""pre-normalised fidelity ""; ""gradients:\n{}"".format(grad_prenorm)); # AJGP: Note this check should not be necessary if dynamics are; # unitary. However, if they are not then this gradient; # can still be used, however the interpretation is dubious; if self.get_fidelity() >= 1:; self.fid_err_grad = self.grad_norm_func(grad_prenorm); else:; self.fid_err_grad = -self.grad_norm_func(grad_prenorm). self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""Normalised fidelity error ""; ""gradients:\n{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient (sum sq norm): ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_grad(self):; """"""; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls], dtype=complex). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(); for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k] ; onto_evo = dyn._onto_evo[k+1]; if dyn.oper_dtype == Qobj:; g = (onto_evo*dyn._get_prop_grad(k, j)*fwd_evo).tr(); else:; g = _trace(onto_evo.dot(; dyn._get_prop_grad(k, j)).dot(fwd_evo)); grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; ti",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:18794,Testability,log,logging,18794,"an dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:18810,Testability,log,logger,18810,"erik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes; ----------; scale_factor : float; The fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not ",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:19156,Testability,log,logging,19156," the drift, when the Dynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are c",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:19180,Testability,log,logger,19180,"ynamics are initialised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:19187,Testability,log,log,19187,"lised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutli",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:19191,Testability,log,logging,19191,"lised.; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TRACEDIFF'; self.scale_factor = None; self.uses_onwd_evo = True; if not self.parent.prop_computer.grad_exact:; raise errors.UsageError(; ""This FidelityComputer can only be""; "" used with an exact gradient PropagatorComputer.""); self.apply_params(). [docs] def init_comp(self):; """"""; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set; """"""; if self.scale_factor is None:; self.scale_factor = 1.0 / (2.0*self.parent.get_drift_dim()); if self.log_level <= logging.DEBUG:; logger.debug(""Scale factor calculated as {}"".format(; self.scale_factor)). [docs] def get_fid_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutli",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:19906,Testability,log,logging,19906,"_err(self):; """"""; Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error functi",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:19922,Testability,log,logger,19922,"Gets the absolute error in the fidelity; """"""; if not self.fidelity_current:; dyn = self.parent; dyn.compute_evolution(); n_ts = dyn.num_tslots; evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""Calculating TraceDiff ""; ""fidelity...\n Target:\n{}\n Evo final:\n{}\n""; ""Evo final diff:\n{}"".format(dyn._target, evo_final,; evo_f_diff)). # Calculate the fidelity error using the trace difference norm; # Note that the value should have not imagnary part, so using; # np.real, just avoids the complex casting warning; if dyn.oper_dtype == Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each ti",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:20558,Testability,log,logging,20558," Qobj:; self.fid_err = self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._ge",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:20582,Testability,log,logger,20582," self.scale_factor*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:20589,Testability,log,log,20589,"*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_t",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:20593,Testability,log,logging,20593,"*np.real(; (evo_f_diff.dag()*evo_f_diff).tr()); else:; self.fid_err = self.scale_factor*np.real(_trace(; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_t",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:20701,Testability,log,logging,20701,"; evo_f_diff.conj().T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # u",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:20717,Testability,log,logger,20717,").T.dot(evo_f_diff))). if np.isnan(self.fid_err):; self.fid_err = np.Inf. if dyn.stats is not None:; dyn.stats.num_fidelity_computes += 1. self.fidelity_current = True; if self.log_level <= logging.DEBUG:; logger.debug(""Fidelity error: {}"".format(self.fid_err)). return self.fid_err. [docs] def get_fid_err_gradient(self):; """"""; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen); """"""; if not self.fid_err_grad_current:; dyn = self.parent; self.fid_err_grad = self.compute_fid_err_grad(); self.fid_err_grad_current = True; if dyn.stats is not None:; dyn.stats.num_grad_computes += 1. self.grad_norm = np.sqrt(np.sum(self.fid_err_grad**2)); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE, ""fidelity error gradients:\n""; ""{}"".format(self.fid_err_grad)). if self.log_level <= logging.DEBUG:; logger.debug(""Gradient norm: ""; ""{} "".format(self.grad_norm)). return self.fid_err_grad. [docs] def compute_fid_err_grad(self):; """"""; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). evo_final = dyn._fwd_evo[n_ts]; evo_f_diff = dyn._target - evo_final; for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; if dyn.oper_dtype == Qobj:; evo_grad = dyn._get_prop_grad(k, j)*fwd_evo; if k+1 < n_ts:; evo_grad = dyn._onwd_evo[k+1]*evo_grad; # Note that the value should have not imagnary part, so; # using np.real, just",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:23023,Testability,log,logging,23023," if np.isnan(g):; g = np.Inf. grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiffApprox(FidCompTraceDiff):; """"""; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes; ----------; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude; ; """"""; [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dy",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:23039,Testability,log,logger,23039,"g = np.Inf. grad[k, j] = g; if dyn.stats is not None:; dyn.stats.wall_time_gradient_compute += \; timeit.default_timer() - time_st; return grad. [docs]class FidCompTraceDiffApprox(FidCompTraceDiff):; """"""; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes; ----------; epsilon : float; control amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude; ; """"""; [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'TDAPPROX'; self.uses_onwd_evo = True; self.scale_factor = None; self.epsilon = 0.001; self.apply_params(). [docs] def compute_fid_err_grad(self):; """"""; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array; """"""; dyn = self.parent; prop_comp = dyn.prop_computer; n_ctrls = dyn.num_ctrls; n_ts = dyn.num_tslots. if self.log_level >= logging.DEBUG:; logger.debug(""Computing fidelity error gradient""); # create n_ts x n_ctrls zero array for grad start point; grad = np.zeros([n_ts, n_ctrls]). dyn.tslot_computer.flag_all_calc_now(); dyn.compute_evolution(); curr_fid_err = self.get_fid_err(). # loop through all ctrl timeslots calculating gradients; time_st = timeit.default_timer(). for j in range(n_ctrls):; for k in range(n_ts):; fwd_evo = dyn._fwd_evo[k]; prop_eps = prop_comp._compute_diff_prop(k, j, self.epsilon); if dyn.oper_dtype == Qobj:; evo_final_eps = fwd_evo*prop_eps; if k+1 < n_ts:; evo_final_eps = evo_final_eps*dyn._onwd_evo[k+1]; evo_f_diff_eps = dyn._target - evo_final_eps; # Note that the value should have not imagnary part, so; # using np.real, just avoids the complex casting warning; fid_err_eps = self.scale_factor*np.real(; (evo_f_diff_eps.dag()*evo_f_diff_eps).tr()); else:; evo_final_eps = fwd_evo.dot(prop_eps); if k+1 < n_ts:; evo_final_eps = evo_final_eps.dot(dyn._onwd_evo[k+1]); evo_f_diff_eps = dyn._target - evo_fi",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:2637,Usability,simpl,simple,2637,"QUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Fidelity Computer. These classes calculate the fidelity error - function to be minimised; and fidelity error gradient, which is used to direct the optimisation. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). ",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:3290,Usability,simpl,simplefilter,3290,"n. They may calculate the fidelity as an intermediary step, as in some case; e.g. unitary dynamics, this is more efficient. The idea is that different methods for computing the fidelity can be tried; and compared using simple configuration switches. Note the methods in these classes were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; The unitary dynamics fidelity is taken directly frm DYNAMO; The other fidelity measures are extensions, and the sources are given; in the class descriptions.; """""". import os; import warnings; import numpy as np; import scipy.sparse as sp; # import scipy.linalg as la; import timeit; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.errors as errors. warnings.simplefilter('always', DeprecationWarning) #turn off filter; def _attrib_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _trace(A):; """"""wrapper for calculating the trace""""""; # input is an operator (Qobj, array, sparse etc), so; if isinstance(A, Qobj):; return A.tr(); elif isinstance(A, np.ndarray):; return np.trace(A); else:; #Assume A some sparse matrix; return np.sum(A.diagonal()). [docs]class FidelityComputer(object):; """"""; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the m",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:6293,Usability,clear,clear,6293,"Computer. uses_onto_evo : boolean; flag to specify whether the onto_evo evolution operator; (see Dynamics) is used by the FidelityComputer. fid_err : float; Last computed value of the fidelity error. fidelity : float; Last computed value of the normalised fidelity. fidelity_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.pa",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:6576,Usability,clear,clear,6576,"lag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(l",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:6596,Usability,clear,clear,6596,"r are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initia",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:6615,Usability,clear,clear,6615,"r are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of float; Last computed values for the fidelity error gradients wrt the; control in the timeslot. grad_norm : float; Last computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_current : boolean; flag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data and; clear any temporarily held status data; """"""; self.log_level = self.parent.log_level; self.id_text = 'FID_COMP_BASE'; self.dimensional_norm = 1.0; self.fid_norm_func = None; self.grad_norm_func = None; self.uses_onwd_evo = False; self.uses_onto_evo = False; self.apply_params(); self.clear(). [docs] def clear(self):; """"""; clear any temporarily held status data; """"""; self.fid_err = None; self.fidelity = None; self.fid_err_grad = None; self.grad_norm = np.inf; self.fidelity_current = False; self.fid_err_grad_current = False; self.grad_norm = 0.0. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def init_comp(self):; """"""; initia",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:10099,Usability,clear,clear,10099,"e):; _attrib_deprecation(; ""'uses_evo_t2targ' has been replaced by 'uses_onto_evo'""); self.uses_onto_evo = value. [docs]class FidCompUnitary(FidelityComputer):; """"""; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes; ----------; phase_option : string; determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'UNIT'; self.uses_onto_evo = True; self._init_phase_option('PSU'); self.apply_params(). [docs] def clear(self):; FidelityComputer.clear(self); self.fidelity_prenorm = None; self.fidelity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""ph",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html:10130,Usability,clear,clear,10130,"es_evo_t2targ' has been replaced by 'uses_onto_evo'""); self.uses_onto_evo = value. [docs]class FidCompUnitary(FidelityComputer):; """"""; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes; ----------; phase_option : string; determines how global phase is treated in fidelity calculations:; PSU - global phase ignored; SU - global phase included. fidelity_prenorm : complex; Last computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_current : boolean; flag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change; """""". [docs] def reset(self):; FidelityComputer.reset(self); self.id_text = 'UNIT'; self.uses_onto_evo = True; self._init_phase_option('PSU'); self.apply_params(). [docs] def clear(self):; FidelityComputer.clear(self); self.fidelity_prenorm = None; self.fidelity_prenorm_current = False. [docs] def set_phase_option(self, phase_option=None):; """"""; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important; """"""; _func_deprecation(""'set_phase_option' is deprecated. ""; ""Use phase_option property""); self._init_phase_option(phase_option); ; @property; def phase_option(self):; return self._phase_option; ; @phase_option.setter; def phase_option(self, value):; """"""; # Phase options are; # SU - global phase important; # PSU - global phase is not important; """"""; self._init_phase_option(value). def _init_phase_option(self, value):; self._phase_option = value; if value == 'PSU':; self.fid_norm_func = self.normalize_PSU; self.grad_norm_func = self.normalize_gradient_PSU; elif value == 'SU':; self.fid_norm_func = self.normalize_SU; self.grad_norm_func = self.normalize_gradient_SU; elif value is None:; raise errors.UsageError(""phase_option cannot be set to No",MatchSource.WIKI,docs/4.3/modules/qutip/control/fidcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/fidcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:2643,Availability,error,error,2643,"OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - BroydenFletcherGoldfarbShanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: Optimize",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:2904,Availability,error,error,2904,"CE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - BroydenFletcherGoldfarbShanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:4208,Availability,error,error,4208,"m SciPy.optimize; The two methods implemented are:; ; BFGS - BroydenFletcherGoldfarbShanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:4763,Availability,error,errors,4763,"t generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:4773,Availability,error,errors,4773,"t generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:6634,Availability,error,error,6634,"rom the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:13267,Availability,error,errors,13267,"mp:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:13409,Availability,error,errors,13409,"dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_opt",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:13608,Availability,error,errors,13608,"al_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_met",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:13663,Availability,error,error,13663,"result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_o",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:13669,Availability,toler,tolerance,13669,"result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_o",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:17108,Availability,error,error,17108,"; if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_condition",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:19476,Availability,error,errors,19476,"bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error a",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:20469,Availability,error,error,20469,"cept errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_call",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:20846,Availability,error,error,20846,"t; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:21162,Availability,error,error,21162,"te for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:21618,Availability,error,errors,21618,"e minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not N",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:21712,Availability,error,errors,21712,"as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= loggi",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:21843,Availability,error,error,21843,"hey have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].c",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:23439,Availability,error,errors,23439," explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_r",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:24133,Availability,error,errors,24133,".num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:24485,Availability,error,errors,24485,"id_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:24575,Availability,error,errors,24575,", *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.s",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:24675,Availability,error,errors,24675,"s has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:24775,Availability,error,errors,24775," logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimize",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:25908,Availability,error,error,25908," the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimizer.reset(self); self.id_text = 'BFGS'. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenFletcherGoldfarbShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fpri",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:27828,Availability,error,errors,27828,"_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; optim_var_vals, cost, grad, invHess, nFCalls, nGCalls, warn = \; spopt.fmin_bfgs(self.fid_err_func_wrapper,; self.optim_var_vals,; fprime=fprime,; # approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """""";",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:29595,Availability,error,error,29595," term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.co",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:32580,Availability,error,errors,32580,"; m = 10. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_l_bfgs_b' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg); try:; optim_var_vals, fid, res_dict = spopt.fmin_l_bfgs_b(; self.fid_err_func_wrapper, self.optim_var_vals,; fprime=fprime,; approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:33057,Availability,error,error,33057,"fun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.Iterable):; pulse_gen_valid = False; err_msg = ""pulse_generator is not iterable"". elif len(self.pulse_generator) != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generat",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:34483,Availability,error,errors,34483,"onfiguration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.Iterable):; pulse_gen_valid = False; err_msg = ""pulse_generator is not iterable"". elif len(self.pulse_generator) != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generators {} does not equal ""; ""the number of controls {}"".format(; len(self.pulse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:36440,Availability,error,error,36440,"the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in func",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:37021,Availability,error,error,37021,"idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_op",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:39307,Availability,toler,tolerance,39307,"ogger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Function converged (within tolerance)""; elif warn_flag == 1:; result.termination_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:39675,Availability,error,errors,39675,"lf.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Function converged (within tolerance)""; elif warn_flag == 1:; result.termination_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time); """"""; # Note there is some duplication here with Optimizer attributes; # this exists solely to be copied into the summary dump; min_col_width = 11; summary_property_",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:40285,Availability,error,error,40285,"= \; ""Function converged (within tolerance)""; elif warn_flag == 1:; result.termination_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time); """"""; # Note there is some duplication here with Optimizer attributes; # this exists solely to be copied into the summary dump; min_col_width = 11; summary_property_names = (; ""idx"", ""iter_num"", ""fid_func_call_num"", ""grad_func_call_num"",; ""fid_err"", ""grad_norm"", ""wall_time""; ). summary_property_fmt_type = (; 'd', 'd', 'd', 'd',; 'g', 'g', 'g'; ). summary_property_fmt_prec = (; 0, 0, 0, 0,; 4, 4, 2; ). def __init__(self):; self.reset(). def reset(self):; qtrldump.DumpSummaryItem.reset(self); self.iter_num = None; self.fid_func_call_num = None; self.grad_func_call_num = None; self.fid_err = None; self.grad_norm = None; self.wall_time = 0.0.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:5410,Deployability,configurat,configuration,5410,"ort numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool;",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:8051,Deployability,configurat,configuration,8051,"lled; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be s",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:13064,Deployability,configurat,configuration,13064,".upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:16404,Deployability,update,update,16404,"_gradient_norm > 0 and not 'gtol' in mo:; mo['gtol'] = tc.min_gradient_norm; if not 'disp' in mo:; mo['disp'] = self.disp_conv_msg. return mo. [docs] def apply_method_params(self, params=None):; """"""; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function; """"""; if not params:; params = self.method_params. if isinstance(params, dict):; self.method_params = params; unused_params = {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:20788,Deployability,update,update,20788,"es; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_gra",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:20994,Deployability,update,update,20994,"; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradi",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:22206,Deployability,update,update,22206,"um_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. i",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:22540,Deployability,update,update,22540,"fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReach",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:24170,Deployability,update,update,24170,"d_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_c",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:25458,Deployability,update,update,25458,"sinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif isinstance(except_term, errors.MaxFidFuncCallTerminate):; result.max_fid_func_exceeded = True. def _add_common_result_attribs(self, result, st_time, end_time):; """"""; Update the result object attributes which are common to all; optimisers and outcomes; """"""; dyn = self.dynamics; result.num_iter = self.num_iter; result.num_fid_func_calls = self.num_fid_func_calls; result.wall_time = end_time - st_time; result.fid_err = dyn.fid_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimizer.reset(self); self.id_text = 'BFGS'. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenFletcherGoldfarbShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelit",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:28808,Deployability,configurat,configuration,28808,"ion_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm. The optimisa",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:33469,Deployability,configurat,configuration,33469,"elity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.Iterable):; pulse_gen_valid = False; err_msg = ""pulse_generator is not iterable"". elif len(self.pulse_generator) != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generators {} does not equal ""; ""the number of controls {}"".format(; len(self.pulse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:41267,Deployability,update,updated,41267,"ation_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_num : int; Iteration number of the pulse optimisation. fid_func_call_num : int; Fidelity function call number of the pulse optimisation. grad_func_call_num : int; Gradient function call number of the pulse optimisation. fid_err : float; Fidelity error. grad_norm : float; fidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_time : float; Time spent computing the pulse optimisation so far; (in seconds of elapsed time); """"""; # Note there is some duplication here with Optimizer attributes; # this exists solely to be copied into the summary dump; min_col_width = 11; summary_property_names = (; ""idx"", ""iter_num"", ""fid_func_call_num"", ""grad_func_call_num"",; ""fid_err"", ""grad_norm"", ""wall_time""; ). summary_property_fmt_type = (; 'd', 'd', 'd', 'd',; 'g', 'g', 'g'; ). summary_property_fmt_prec = (; 0, 0, 0, 0,; 4, 4, 2; ). def __init__(self):; self.reset(). def reset(self):; qtrldump.DumpSummaryItem.reset(self); self.iter_num = None; self.fid_func_call_num = None; self.grad_func_call_num = None; self.fid_err = None; self.grad_norm = None; self.wall_time = 0.0.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:8466,Energy Efficiency,reduce,reduce,8466,"the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Not",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:3890,Integrability,wrap,wrapper,3890,"t the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - BroydenFletcherGoldfarbShanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.du",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:4182,Integrability,wrap,wrappers,4182,"m SciPy.optimize; The two methods implemented are:; ; BFGS - BroydenFletcherGoldfarbShanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:6461,Integrability,message,message,6461,"instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the con",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:17017,Integrability,wrap,wrapper,17017,"instance(params, dict):; self.method_params = params; unused_params = {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult obj",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:19130,Integrability,message,message,19130,"als = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the functi",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:26176,Integrability,wrap,wrapper,26176,"d_computer.get_fid_err(); result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimizer.reset(self); self.id_text = 'BFGS'. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenFletcherGoldfarbShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self.",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:29962,Integrability,wrap,wrapper,29962,"ard compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self.",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:36376,Integrability,wrap,wrapper,36376,"he optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimis",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:36934,Integrability,wrap,wrapper,36934,"_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_v",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:2678,Modifiability,variab,variables,2678," LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - BroydenFletcherGoldfarbShanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian ap",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:3839,Modifiability,variab,variables,3839,"t the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - BroydenFletcherGoldfarbShanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.du",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:5410,Modifiability,config,configuration,5410,"ort numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool;",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:8012,Modifiability,config,config,8012,"lled; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be s",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:8051,Modifiability,config,configuration,8051,"lled; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be s",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:9501,Modifiability,config,config,9501,"te it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:9555,Modifiability,config,config,9555,": :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_uboun",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:9564,Modifiability,config,config,9564,": :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_uboun",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:9667,Modifiability,config,config,9667,"the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @l",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:10329,Modifiability,config,config,10329,"etting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, ke",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:10390,Modifiability,config,config,10390,"the most recent iteration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of da",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:10422,Modifiability,config,config,10422,"ration.; Note this is only set if dummping is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:10465,Modifiability,config,config,10465,"is on; ; """""". def __init__(self, config, dyn, params=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:10500,Modifiability,config,config,10500,"rams=None):; self.dynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:10532,Modifiability,config,config,10532,"ynamics = dyn; self.config = config; self.params = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each it",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:10575,Modifiability,config,config,10575,"arams = params; self.reset(); dyn.parent = self. def reset(self):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:13064,Modifiability,config,configuration,13064,".upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:16469,Modifiability,config,config,16469,"radient_norm; if not 'disp' in mo:; mo['disp'] = self.disp_conv_msg. return mo. [docs] def apply_method_params(self, params=None):; """"""; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function; """"""; if not params:; params = self.method_params. if isinstance(params, dict):; self.method_params = params; unused_params = {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The functio",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:18170,Modifiability,config,config,18170,"_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in t",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:19767,Modifiability,variab,variable,19767,"d)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the s",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:20042,Modifiability,variab,variable,20042,"func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:20653,Modifiability,variab,variable,20653,"t, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(e",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:21877,Modifiability,variab,variables,21877,"hey have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].c",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:22031,Modifiability,variab,variables,22031,"1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that r",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:22071,Modifiability,variab,variable,22071,"unc_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:22970,Modifiability,config,config,22970,"tion algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.w",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:28225,Modifiability,variab,variable,28225,"grad, invHess, nFCalls, nGCalls, warn = \; spopt.fmin_bfgs(self.fid_err_func_wrapper,; self.optim_var_vals,; fprime=fprime,; # approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; s",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:28808,Modifiability,config,configuration,28808,"ion_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm. The optimisa",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:28937,Modifiability,config,config,28937,"efault_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Esse",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:28998,Modifiability,config,config,28998,"ime). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function;",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:29035,Modifiability,config,config,29035,"docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a war",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:29088,Modifiability,config,config,29088,"ts the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BF",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:29128,Modifiability,config,config,29128,"ithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:29165,Modifiability,config,config,29165,"------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy d",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:29227,Modifiability,config,config,29227,"ble metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:30615,Modifiability,config,config,30615,"algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if 'accuracy_factor' in self.method_options:; factr = self.method_options['accuracy_factor']; elif 'ftol' in self.method_options:; factr = self.method_options['ftol']; elif hasattr(term_conds, 'accuracy_factor'):; factr = term_conds.accuracy_factor; else:; factr = 1e7. if 'max_metric_corr' in self.method_options:; m = self.method_options['max_metric_corr']; elif 'maxcor' in self.method_options:; m = self.method_options['maxcor']; elif hasattr(self, 'max_metric_corr'):; m = self.max_metric_corr; else:; m = 10. if self.log_level <= logging.INFO:; msg = (""Op",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:33469,Modifiability,config,configuration,33469,"elity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.Iterable):; pulse_gen_valid = False; err_msg = ""pulse_generator is not iterable"". elif len(self.pulse_generator) != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generators {} does not equal ""; ""the number of controls {}"".format(; len(self.pulse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:34935,Modifiability,variab,variable,34935,") != dyn.num_ctrls:; pulse_gen_valid = False; err_msg = (""the number of pulse generators {} does not equal ""; ""the number of controls {}"".format(; len(self.pulse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:35131,Modifiability,extend,extend,35131,"lse_generator), dyn.num_ctrls)). if pulse_gen_valid:; for p_gen in self.pulse_generator:; if not isinstance(p_gen, pulsegen.PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:35282,Modifiability,variab,variable,35282,".PulseGenCrab):; pulse_gen_valid = False; err_msg = (; ""pulse_generator contained object of type '{}'"".format(; p_gen.__class__.__name__)); break; self.num_optim_vars += p_gen.num_optim_vars. if not pulse_gen_valid:; raise errors.UsageError(; ""The pulse_generator attribute must be set to a list of ""; ""PulseGenCrab - one for each control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Op",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:37876,Modifiability,config,config,37876,"None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:18,Performance,optimiz,optimizer,18,". . qutip.control.optimizer  QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs ; Module code ; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:270,Performance,optimiz,optimizer,270,". . qutip.control.optimizer  QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs ; Module code ; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:311,Performance,optimiz,optimizer,311,". . qutip.control.optimizer  QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs ; Module code ; qutip.control.optimizer. Source code for qutip.control.optimizer; # -*- coding: utf-8 -*-; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2014 and later, Alexander J G Pitchford; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistributions in binary form must reproduce the above copyright; # notice, this list of conditions and the following disclaimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:3203,Performance,optimiz,optimize,3203,"s here are expected to implement a run_optimization function; that will use some method for optimising the control pulse, as defined; by the control amplitudes. The system that the pulse acts upon are defined; by the Dynamics object that must be passed in the instantiation. The methods are typically N dimensional function optimisers that; find the minima of a fidelity error function. Note the number of variables; for the fidelity function is the number of control timeslots,; i.e. n_ctrls x Ntimeslots; The methods will call functions on the Dynamics.fid_computer object,; one or many times per interation,; to get the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - BroydenFletcherGoldfarbShanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are cal",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:3791,Performance,perform,performs,3791,"t the fidelity error and gradient wrt to the amplitudes.; The optimisation will stop when one of the termination conditions are met,; for example: the fidelity aim has be reached, a local minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - BroydenFletcherGoldfarbShanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.du",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:4070,Performance,optimiz,optimize,4070,"al minima has been found,; the maximum time allowed has been exceeded. These function optimisation methods are so far from SciPy.optimize; The two methods implemented are:; ; BFGS - BroydenFletcherGoldfarbShanno algorithm; ; This a quasi second order Newton method. It uses successive calls to; the gradient function to make an estimation of the curvature (Hessian); and hence direct its search for the function minima; The SciPy implementation is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:;",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:4470,Performance,optimiz,optimize,4470,"on is pure Python and hance is execution speed is; not high; use subclass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control opti",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:6481,Performance,optimiz,optimize,6481,"uantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value appl",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:6547,Performance,optimiz,optimize,6547,"og_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_params : Dictionary; Options for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_grad : bool; If set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:8411,Performance,perform,performance,8411,"the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. bounds : List of floats; Bounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamics : Dynamics (subclass instance); describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). config : OptimConfig instance; various configuration options; (see OptimConfig for details). termination_conditions : TerminationCondition instance; attributes determine when the optimisation will end. pulse_generator : PulseGen (subclass instance); (can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. stats : Stats; attributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dump : :class:`dump.OptimDump`; Container for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumping : string; level of data dumping: NONE, SUMMARY, FULL or CUSTOM; See property docstring for details. dump_to_file : bool; If set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dir : string; Basically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summary : :class:`OptimIterSummary`; Summary of the most recent iteration.; Not",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:12813,Performance,optimiz,optimizer,12813,"lf.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.full_evo.copy(); result.time = self.dynamics.time.copy(); result.optimizer = self; return result. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_c",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:14474,Performance,optimiz,optimize,14474,"check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_options attribute may already contain items.; These values will NOT be overridden; """"""; tc = self.termination_conditions; if self.method_options is None:; self.method_options = {}; mo = self.method_options. if 'max_metric_corr' in mo and not 'maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(self, 'max_metric_corr') and not 'maxcor' in mo:; mo['maxcor'] = self.max_metric_corr; if 'accuracy_factor' in mo and not 'ftol' in mo:; mo['ftol'] = mo['accuracy_factor']; elif hasattr(tc, 'accuracy_factor') and not 'ftol' in mo:; mo['ftol'] = tc.accuracy_factor; if tc.max_iterations > 0 and not 'maxiter' in mo:; mo['maxiter'] = tc.max_iterations; if tc.max_fid_func_calls > 0 and not 'maxfev' in mo:; mo['maxfev'] = tc.max_fid_func_calls; if tc.min_gradient_norm > 0 and not 'gtol' in mo:; mo['gtol'] = tc.min_gr",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:15892,Performance,optimiz,optimize,15892,"maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(self, 'max_metric_corr') and not 'maxcor' in mo:; mo['maxcor'] = self.max_metric_corr; if 'accuracy_factor' in mo and not 'ftol' in mo:; mo['ftol'] = mo['accuracy_factor']; elif hasattr(tc, 'accuracy_factor') and not 'ftol' in mo:; mo['ftol'] = tc.accuracy_factor; if tc.max_iterations > 0 and not 'maxiter' in mo:; mo['maxiter'] = tc.max_iterations; if tc.max_fid_func_calls > 0 and not 'maxfev' in mo:; mo['maxfev'] = tc.max_fid_func_calls; if tc.min_gradient_norm > 0 and not 'gtol' in mo:; mo['gtol'] = tc.min_gradient_norm; if not 'disp' in mo:; mo['disp'] = self.disp_conv_msg. return mo. [docs] def apply_method_params(self, params=None):; """"""; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function; """"""; if not params:; params = self.method_params. if isinstance(params, dict):; self.method_params = params; unused_params = {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.app",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:17039,Performance,optimiz,optimize,17039,"= {}; for key in params:; val = params[key]; if hasattr(self, key):; setattr(self, key, val); if hasattr(self.termination_conditions, key):; setattr(self.termination_conditions, key, val); else:; unused_params[key] = val. if len(unused_params) > 0:; if not isinstance(self.method_options, dict):; self.method_options = unused_params; else:; self.method_options.update(unused_params). def _build_bounds_list(self):; cfg = self.config; dyn = self.dynamics; n_ctrls = dyn.num_ctrls; self.bounds = []; for t in range(dyn.num_tslots):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for t",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:26199,Performance,optimiz,optimize,26199,"result.grad_norm_final = dyn.fid_computer.grad_norm; result.final_amps = dyn.ctrl_amps; final_evo = dyn.full_evo; if isinstance(final_evo, Qobj):; result.evo_full_final = final_evo; else:; result.evo_full_final = Qobj(final_evo, dims=dyn.sys_dims); # *** update stats ***; if self.stats is not None:; self.stats.wall_time_optim_end = end_time; self.stats.calculate(); result.stats = copy.copy(self.stats). [docs]class OptimizerBFGS(Optimizer):; """"""; Implements the run_optimization method using the BFGS algorithm; """"""; def reset(self):; Optimizer.reset(self); self.id_text = 'BFGS'. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenFletcherGoldfarbShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; opt",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:28400,Performance,optimiz,optimize,28400,"_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes; ----------; max_metric_corr : integer; The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_lev",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:29985,Performance,optimiz,optimize,29985,"ttr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.a",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:32902,Performance,optimiz,optimize,32902,"f.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerCrab(Optimizer):; """"""; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients. AJGP ToDo: Add citation here; """""". def reset(self):; Optimizer.reset(self); self.id_text = 'CRAB'; self.num_optim_vars = 0. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; Optimizer.init_optim(self, term_conds); dyn = self.dynamics. self.num_optim_vars = 0; pulse_gen_valid = True; # check the pulse generators match the ctrls; # (in terms of number); # and count the number of parameters; if self.pulse_generator is None:; pulse_gen_valid = False; err_msg = ""pulse_generator attribute is None""; elif not isinstance(self.pulse_generator, collections.Iterable):; pulse_gen_valid = False; er",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:36330,Performance,optimiz,optimize,36330,"hat is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Spec",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:36956,Performance,optimiz,optimize,36956,"_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011).; """""". def reset(self):; OptimizerCrab.reset(self); self.id_text = 'CRAB_FMIN'; self.xtol = 1e-4; self.ftol = 1e-4. [docs] def run_optimization(self, term_conds=None):; """"""; This function optimisation method is a wrapper to the; scipy.optimize.fmin function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:4585,Testability,log,logging,4585,"ass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:4594,Testability,log,logger,4594,"ass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:4603,Testability,log,logging,4603,"ass: OptimizerBFGS. L-BFGS-B - Bounded, limited memory BFGS; ; This a version of the BFGS method where the Hessian approximation is; only based on a set of the most recent gradient calls. It generally; performs better where the are a large number of variables; The SciPy implementation of L-BFGS-B is wrapper around a well; established and actively maintained implementation in Fortran; Its is therefore very fast.; # See SciPy documentation for credit and details on the; # scipy.optimize.fmin_l_bfgs_b function; use subclass: OptimizerLBFGSB. The baseclass Optimizer implements the function wrappers to the; fidelity error, gradient, and iteration callback functions.; These are called from the within the SciPy optimisation functions.; The subclasses implement the algorithm specific pulse optimisation function.; """""". import os; import numpy as np; import timeit; import scipy.optimize as spopt; import copy; import collections; # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:5606,Testability,log,logger,5606,"ogging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimresult as optimresult; import qutip.control.termcond as termcond; import qutip.control.errors as errors; import qutip.control.dynamics as dynamics; import qutip.control.pulsegen as pulsegen; import qutip.control.dump as qtrldump. def _is_string(var):; try:; if isinstance(var, basestring):; return True; except NameError:; try:; if isinstance(var, str):; return True; except:; return False; except:; return False. return False. [docs]class Optimizer(object):; """"""; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a; ; OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: Dictionary; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msg : bool; Set true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_method : string; a scipy.optimize.minimize meth",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:10655,Testability,log,logger,10655,"elf):; self.log_level = self.config.log_level; self.id_text = 'OPTIM'; self.termination_conditions = None; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised l",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:10773,Testability,log,logger,10773,"one; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:10794,Testability,log,logger,10794,"one; self.pulse_generator = None; self.disp_conv_msg = False; self.iteration_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:10821,Testability,log,logger,10821,"on_steps = None; self.record_iteration_steps=False; self.alg = 'GRAPE'; self.alg_params = None; self.method = 'l_bfgs_b'; self.method_params = None; self.method_options = None; self.approx_grad = False; self.amp_lbound = None; self.amp_ubound = None; self.bounds = None; self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.stats = None; self.wall_time_optim_start = 0.0. self.dump_to_file = False; self.dump = None; self.iter_summary = None. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'amp_lbound'):; if self.config.amp_lbound:; self.amp_lbound = self.config.amp_lbound; if hasattr(self.config, 'amp_ubound'):; if self.config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped; """"""; if self.dump is None:; lvl = 'NONE'; e",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:11575,Testability,log,logs,11575,"config.amp_ubound:; self.amp_ubound = self.config.amp_ubound. self.apply_params(). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the curren",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:11755,Testability,log,logs,11755," and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def dumping(self):; """"""; The level of data dumping that will occur during the optimisation; - NONE : No processing data dumped (Default); - SUMMARY : A summary at each iteration will be recorded; - FULL : All logs will be generated and dumped; - CUSTOM : Some customised level of dumping; When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped; """"""; if self.dump is None:; lvl = 'NONE'; else:; lvl = self.dump.level. return lvl. @dumping.setter; def dumping(self, value):; if value is None:; self.dump = None; else:; if not _is_string(value):; raise TypeError(""Value must be string value""); lvl = value.upper(); if lvl == 'NONE':; self.dump = None; else:; if not isinstance(self.dump, qtrldump.OptimDump):; self.dump = qtrldump.OptimDump(self, level=lvl); else:; self.dump.level = lvl; @property; def dump_dir(self):; if self.dump:; return self.dump.dump_dir; else:; return None. @dump_dir.setter; def dump_dir(self, value):; if not self.dump:; self.dumping = 'SUMMARY'; self.dump.dump_dir = value. def _create_result(self):; """"""; create the result object; and set the initial_amps attribute as the current amplitudes; """"""; result = optimresult.OptimResult(); result.initial_fid_err = self.dynamics.fid_computer.get_fid_err(); result.initial_amps = self.dynamics.ctrl_amps.copy(); result.evo_full_initial = self.dynamics.",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:14104,Testability,log,logger,14104," is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_options attribute may already contain items.; These values will NOT be overridden; """"""; tc = self.termination_conditions; if self.method_options is None:; self.method_options = {}; mo = self.method_options. if 'max_metric_corr' in mo and not 'maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(self, 'max_metric_corr') and not 'maxcor' in mo:; mo['maxcor'] = self.max_metric_corr; if 'accuracy_factor' in mo and not 'ftol' in mo:",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:17589,Testability,test,tested,17589,"s):; for c in range(n_ctrls):; if isinstance(self.amp_lbound, list):; lb = self.amp_lbound[c]; else:; lb = self.amp_lbound; if isinstance(self.amp_ubound, list):; ub = self.amp_ubound[c]; else:; ub = self.amp_ubound. if not lb is None and np.isinf(lb):; lb = None; if not ub is None and np.isinf(ub):; ub = None. self.bounds.append((lb, ub)). [docs] def run_optimization(self, term_conds=None):; """"""; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function. It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below). The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient. The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_gra",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:18643,Testability,log,logging,18643," some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:18805,Testability,log,logger,18805,"ameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; ; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of th",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:19284,Testability,log,logger,19284,"e_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 0. if self.bounds is None:; self._build_bounds_list(). self._build_method_options(). result = self._create_result(). if self.approx_grad:; jac=None; else:; jac=self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""minimise '{}' method"").format(self.alg, self.method); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). try:; opt_res = spopt.minimize(; self.fid_err_func_wrapper, self.optim_var_vals,; method=self.method,; jac=jac,; bounds=self.bounds,; options=self.method_options,; callback=self.iter_step_callback_func). amps = self._get_ctrl_amps(opt_res.x); dyn.update_ctrl_amps(amps); result.termination_reason = opt_res.message; # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != opt_res.nit:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, opt_res.nit,; self.method)); result.num_iter = opt_res.nit. except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; By default (as used in GRAPE) these are the control amplitudes; in each timeslot; """"""; return self.dynamics.ctrl_amps.reshape([-1]). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamic",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:21123,Testability,log,logging,21123,"s passed from the optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed a",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:21139,Testability,log,logger,21139,"optimisation method; Note for GRAPE these are the function optimiser parameters; (and this is the default); ; Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; amps = optim_var_vals.reshape(self.dynamics.ctrl_amps.shape). return amps. [docs] def fid_err_func_wrapper(self, *args):; """"""; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument. This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). The error is checked against the target, and the optimisation is; terminated if the target has been achieved.; """"""; self.num_fid_func_calls += 1; # *** update stats ***; if self.stats is not None:; self.stats.num_fidelity_func_calls = self.num_fid_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""fidelity error call {}"".format(; self.stats.num_fidelity_func_calls)). amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps). tc = self.termination_conditions; err = self.dynamics.fid_computer.get_fid_err(). if self.iter_summary:; self.iter_summary.fid_func_call_num = self.num_fid_func_calls; self.iter_summary.fid_err = err. if self.dump and self.dump.dump_fid_err:; self.dump.update_fid_err_log(err). if err <= tc.fid_err_targ:; raise errors.GoalAchievedTerminate(err). if self.num_fid_func_calls > tc.max_fid_func_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. H",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:22697,Testability,log,logging,22697,"unc_calls:; raise errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; se",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:22713,Testability,log,logger,22713,"errors.MaxFidFuncCallTerminate(). return err. [docs] def fid_err_grad_wrapper(self, *args):; """"""; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot. This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed). Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition; """"""; # *** update stats ***; self.num_grad_func_calls += 1; if self.stats is not None:; self.stats.num_grad_func_calls = self.num_grad_func_calls; if self.log_level <= logging.DEBUG:; logger.debug(""gradient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:23734,Testability,log,logging,23734,"ient call {}"".format(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_re",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:23750,Testability,log,logger,23750,"at(; self.stats.num_grad_func_calls)); amps = self._get_ctrl_amps(args[0].copy()); self.dynamics.update_ctrl_amps(amps); fid_comp = self.dynamics.fid_computer; # gradient_norm_func is a pointer to the function set in the config; # that returns the normalised gradients; grad = fid_comp.get_fid_err_gradient(). if self.iter_summary:; self.iter_summary.grad_func_call_num = self.num_grad_func_calls; self.iter_summary.grad_norm = fid_comp.grad_norm. if self.dump:; if self.dump.dump_grad_norm:; self.dump.update_grad_norm_log(fid_comp.grad_norm). if self.dump.dump_grad:; self.dump.update_grad_log(grad). tc = self.termination_conditions; if fid_comp.grad_norm < tc.min_gradient_norm:; raise errors.GradMinReachedTerminate(fid_comp.grad_norm); return grad.flatten(). [docs] def iter_step_callback_func(self, *args):; """"""; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time; """"""; self.num_iter += 1. if self.log_level <= logging.DEBUG:; logger.debug(""Iteration callback {}"".format(self.num_iter)). wall_time = timeit.default_timer() - self.wall_time_optimize_start. if self.iter_summary:; self.iter_summary.iter_num = self.num_iter; self.iter_summary.wall_time = wall_time. if self.dump and self.dump.dump_summary:; self.dump.add_iter_summary(). tc = self.termination_conditions. if wall_time > tc.max_wall_time:; raise errors.MaxWallTimeTerminate(). # *** update stats ***; if self.stats is not None:; self.stats.num_iter = self.num_iter. def _interpret_term_exception(self, except_term, result):; """"""; Update the result object based on the exception that occurred; during the optimisation; """"""; result.termination_reason = except_term.reason; if isinstance(except_term, errors.GoalAchievedTerminate):; result.goal_achieved = True; elif isinstance(except_term, errors.MaxWallTimeTerminate):; result.wall_time_limit_exceeded = True; elif isinstance(except_term, errors.GradMinReachedTerminate):; result.grad_norm_min_reached = True; elif",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:26998,Testability,log,logging,26998,"d when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; optim_var_vals, cost, grad, invHess, nFCalls, nGCalls, warn = \; spopt.fmin_bfgs(self.fid_err_func_wrapper,; self.optim_var_vals,; fprime=fprime,; # approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(re",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:27145,Testability,log,logger,27145," iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_bfgs' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg). result = self._create_result(); try:; optim_var_vals, cost, grad, invHess, nFCalls, nGCalls, warn = \; spopt.fmin_bfgs(self.fid_err_func_wrapper,; self.optim_var_vals,; fprime=fprime,; # approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; gtol=term_conds.min_gradient_norm,; maxiter=term_conds.max_iterations,; full_output=True, disp=True). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); if warn == 1:; result.max_iter_exceeded = True; result.termination_reason = ""Iteration count limit reached""; elif warn == 2:; result.grad_norm_min_reached = True; result.termination_reason = ""Gradient normal minimum reached"". except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimizerLBFGSB(Optimizer):; """"""; Implements the run_optimization method using t",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:29352,Testability,log,logging,29352,"re used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if th",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:29411,Testability,log,logging,29411,".fmin_l_bfgs_b documentation for description; of m argument. """""". def reset(self):; Optimizer.reset(self); self.id_text = 'LBFGSB'; self.max_metric_corr = 10; self.msg_level = None. [docs] def init_optim(self, term_conds):; """"""; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is None:; term_conds = self.termination_conditions. # AJGP 2015-04-21:; # These (copying from config) are here for backward compatibility; if hasattr(self.config, 'max_metric_corr'):; if self.config.max_metric_corr:; self.max_metric_corr = self.config.max_metric_corr; if hasattr(self.config, 'accuracy_factor'):; if self.config.accuracy_factor:; term_conds.accuracy_factor = \; self.config.accuracy_factor. Optimizer.init_optim(self, term_conds). if not isinstance(self.msg_level, int):; if self.log_level < logging.DEBUG:; self.msg_level = 2; elif self.log_level <= logging.DEBUG:; self.msg_level = 1; else:; self.msg_level = 0. [docs] def run_optimization(self, term_conds=None):; """"""; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm. The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded. Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an Opti",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:31597,Testability,log,logging,31597,"dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if 'accuracy_factor' in self.method_options:; factr = self.method_options['accuracy_factor']; elif 'ftol' in self.method_options:; factr = self.method_options['ftol']; elif hasattr(term_conds, 'accuracy_factor'):; factr = term_conds.accuracy_factor; else:; factr = 1e7. if 'max_metric_corr' in self.method_options:; m = self.method_options['max_metric_corr']; elif 'maxcor' in self.method_options:; m = self.method_options['maxcor']; elif hasattr(self, 'max_metric_corr'):; m = self.max_metric_corr; else:; m = 10. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_l_bfgs_b' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg); try:; optim_var_vals, fid, res_dict = spopt.fmin_l_bfgs_b(; self.fid_err_func_wrapper, self.optim_var_vals,; fprime=fprime,; approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.Optimiza",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:31748,Testability,log,logger,31748,"r(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. bounds = self._build_bounds_list(); result = self._create_result(). if self.approx_grad:; fprime = None; else:; fprime = self.fid_err_grad_wrapper. if 'accuracy_factor' in self.method_options:; factr = self.method_options['accuracy_factor']; elif 'ftol' in self.method_options:; factr = self.method_options['ftol']; elif hasattr(term_conds, 'accuracy_factor'):; factr = term_conds.accuracy_factor; else:; factr = 1e7. if 'max_metric_corr' in self.method_options:; m = self.method_options['max_metric_corr']; elif 'maxcor' in self.method_options:; m = self.method_options['maxcor']; elif hasattr(self, 'max_metric_corr'):; m = self.max_metric_corr; else:; m = 10. if self.log_level <= logging.INFO:; msg = (""Optimising pulse(s) using {} with ""; ""'fmin_l_bfgs_b' method"").format(self.alg); if self.approx_grad:; msg += "" (approx grad)""; logger.info(msg); try:; optim_var_vals, fid, res_dict = spopt.fmin_l_bfgs_b(; self.fid_err_func_wrapper, self.optim_var_vals,; fprime=fprime,; approx_grad=self.approx_grad,; callback=self.iter_step_callback_func,; bounds=self.bounds, m=m, factr=factr,; pgtol=term_conds.min_gradient_norm,; disp=self.msg_level,; maxfun=term_conds.max_fid_func_calls,; maxiter=term_conds.max_iterations). amps = self._get_ctrl_amps(optim_var_vals); dyn.update_ctrl_amps(amps); warn = res_dict['warnflag']; if warn == 0:; result.grad_norm_min_reached = True; result.termination_reason = ""function converged""; elif warn == 1:; result.max_iter_exceeded = True; result.termination_reason = (""Iteration or fidelity ""; ""function call limit reached""); elif warn == 2:; result.termination_reason = res_dict['task']. result.num_iter = res_dict['nit']; except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_r",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:35592,Testability,log,logging,35592,"h control. Here "" + err_msg). def _build_bounds_list(self):; """"""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:35664,Testability,log,logger,35664,"""""""; No bounds necessary here, as the bounds for the CRAB parameters; do not have much physical meaning.; This needs to override the default method, otherwise the shape; will be wrong; """"""; return None. def _get_optim_var_vals(self):; """"""; Generate the 1d array that holds the current variable values; of the function to be optimised; For CRAB these are the basis coefficients; ; Returns; -------; ndarray (1d) of float; ; """"""; pvals = []; for pgen in self.pulse_generator:; pvals.extend(pgen.get_optim_var_vals()). return np.array(pvals). def _get_ctrl_amps(self, optim_var_vals):; """"""; Get the control amplitudes from the current variable values; of the function to be optimised.; that is the 1d array that is passed from the optimisation method; For CRAB the amplitudes will need to calculated by expanding the; series. Returns; -------; float array[dynamics.num_tslots, dynamics.num_ctrls]; """"""; dyn = self.dynamics. if self.log_level <= logging.DEBUG:; changed_params = self.optim_var_vals != optim_var_vals; logger.debug(; ""{} out of {} optimisation parameters changed"".format(; changed_params.sum(), len(optim_var_vals))). amps = np.empty([dyn.num_tslots, dyn.num_ctrls]); j = 0; param_idx_st = 0; for p_gen in self.pulse_generator:; param_idx_end = param_idx_st + p_gen.num_optim_vars; pg_pvals = optim_var_vals[param_idx_st:param_idx_end]; p_gen.set_optim_var_vals(pg_pvals); amps[:, j] = p_gen.gen_pulse(); param_idx_st = param_idx_end; j += 1. #print(""param_idx_end={}"".format(param_idx_end)); self.optim_var_vals = optim_var_vals; return amps. [docs]class OptimizerCrabFmin(OptimizerCrab):; """"""; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB. Notes; -----; [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,; 190501 (2011).; [2] T",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:38286,Testability,log,logging,38286," or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Func",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:38301,Testability,log,logger,38301," or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol. If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None. The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc; """"""; self.init_optim(term_conds); term_conds = self.termination_conditions; dyn = self.dynamics; cfg = self.config; self.optim_var_vals = self._get_optim_var_vals(); self._build_method_options(). #print(""Initial values:\n{}"".format(self.optim_var_vals)); st_time = timeit.default_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Function converged (w",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:39049,Testability,log,logger,39049,"efault_timer(); self.wall_time_optimize_start = st_time. if self.stats is not None:; self.stats.wall_time_optim_start = st_time; self.stats.wall_time_optim_end = 0.0; self.stats.num_iter = 1. result = self._create_result(). if self.log_level <= logging.INFO:; logger.info(""Optimising pulse(s) using {} with ""; ""'fmin' (Nelder-Mead) method"".format(self.alg)). try:; ret = spopt.fmin(; self.fid_err_func_wrapper, self.optim_var_vals,; xtol=self.xtol, ftol=self.ftol,; maxiter=term_conds.max_iterations,; maxfun=term_conds.max_fid_func_calls,; full_output=True, disp=self.disp_conv_msg,; retall=self.record_iteration_steps,; callback=self.iter_step_callback_func). final_param_vals = ret[0]; num_iter = ret[2]; warn_flag = ret[4]; if self.record_iteration_steps:; self.iteration_steps = ret[5]; amps = self._get_ctrl_amps(final_param_vals); dyn.update_ctrl_amps(amps). # Note the iterations are counted in this object as well; # so there are compared here for interest sake only; if self.num_iter != num_iter:; logger.info(""The number of iterations counted {} ""; "" does not match the number reported {} ""; ""by {}"".format(self.num_iter, num_iter,; self.method)); result.num_iter = num_iter; if warn_flag == 0:; result.termination_reason = \; ""Function converged (within tolerance)""; elif warn_flag == 1:; result.termination_reason = \; ""Maximum number of function evaluations reached""; result.max_fid_func_exceeded = True; elif warn_flag == 2:; result.termination_reason = \; ""Maximum number of iterations reached""; result.max_iter_exceeded = True; else:; result.termination_reason = \; ""Unknown (warn_flag={})"".format(warn_flag). except errors.OptimizationTerminate as except_term:; self._interpret_term_exception(except_term, result). end_time = timeit.default_timer(); self._add_common_result_attribs(result, st_time, end_time). return result. [docs]class OptimIterSummary(qtrldump.DumpSummaryItem):; """"""A summary of the most recent iteration of the pulse optimisation. Attributes; ----------; iter_nu",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html:13962,Usability,clear,clear,13962,"e optimisation.; This is called by run_optimization, but could called independently; to check the configuration.; """"""; if term_conds is not None:; self.termination_conditions = term_conds; term_conds = self.termination_conditions. if not isinstance(term_conds, termcond.TerminationConditions):; raise errors.UsageError(""No termination conditions for the ""; ""optimisation function""). if not isinstance(self.dynamics, dynamics.Dynamics):; raise errors.UsageError(""No dynamics object attribute set""); self.dynamics.check_ctrls_initialized(). self.apply_method_params(). if term_conds.fid_err_targ is None and term_conds.fid_goal is None:; raise errors.UsageError(""Either the goal or the fidelity ""; ""error tolerance must be set""). if term_conds.fid_err_targ is None:; term_conds.fid_err_targ = np.abs(1 - term_conds.fid_goal). if term_conds.fid_goal is None:; term_conds.fid_goal = 1 - term_conds.fid_err_targ. if self.alg == 'CRAB':; self.approx_grad = True. if self.stats is not None:; self.stats.clear(). if self.dump_to_file:; if self.dump is None:; self.dumping = 'SUMMARY'; self.dump.write_to_file = True; self.dump.create_dump_dir(); logger.info(""Optimiser dump will be written to:\n{}"".format(; self.dump.dump_dir)). if self.dump:; self.iter_summary = OptimIterSummary(); else:; self.iter_summary = None. self.num_iter = 0; self.num_fid_func_calls = 0; self.num_grad_func_calls = 0; self.iteration_steps = None. def _build_method_options(self):; """"""; Creates the method_options dictionary for the scipy.optimize.minimize; function based on the attributes of this object and the; termination_conditions; It assumes that apply_method_params has already been run and; hence the method_options attribute may already contain items.; These values will NOT be overridden; """"""; tc = self.termination_conditions; if self.method_options is None:; self.method_options = {}; mo = self.method_options. if 'max_metric_corr' in mo and not 'maxcor' in mo:; mo['maxcor'] = mo['max_metric_corr']; elif hasattr(sel",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimizer.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimizer.html
https://qutip.org/docs/4.3/modules/qutip/control/optimresult.html:2666,Availability,error,error,2666,"OODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tsl",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.3/modules/qutip/control/optimresult.html:2736,Availability,error,error,2736,"OODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tsl",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.3/modules/qutip/control/optimresult.html:2805,Availability,error,error,2805,"# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operat",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.3/modules/qutip/control/optimresult.html:2935,Availability,error,error,2935,"R OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Class containing the results of the pulse optimisation; """""". import numpy as np. [docs]class OptimResult(object):; """"""; Attributes give the result of the pulse optimisation attempt. Attributes; ----------; termination_reason : string; Description of the reason for terminating the optimisation. fidelity : float; final (normalised) fidelity that was achieved. initial_fid_err : float; fidelity error before optimisation starting; ; fid_err : float; final fidelity error that was achieved. goal_achieved : boolean; True is the fidely error achieved was below the target. grad_norm_final : float; Final value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator fro",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.3/modules/qutip/control/optimresult.html:4817,Deployability,update,updated,4817,"of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps; ; stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.evo_full_initial = None; self.stats = None; self.optimizer = None.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.3/modules/qutip/control/optimresult.html:4014,Performance,optimiz,optimizer,4014,"of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps; ; stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.evo_full_initial = None; self.stats = None; self.optimizer = None.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.3/modules/qutip/control/optimresult.html:4689,Performance,optimiz,optimizer,4689,"of the (normalised) fidelity; error gradients. grad_norm_min_reached : float; True if the optimisation terminated due to the minimum value; of the gradient being reached. num_iter : integer; Number of iterations of the optimisation algorithm completed. max_iter_exceeded : boolean; True if the iteration limit was reached; ; max_fid_func_exceeded : boolean; True if the fidelity function call limit was reached. wall_time : float; time elapsed during the optimisation. wall_time_limit_exceeded : boolean; True if the wall time limit was reached. time : array[num_tslots+1] of float; Time are the start of each timeslot; with the final value being the total evolution time. initial_amps : array[num_tslots, n_ctrls]; The amplitudes at the start of the optimisation. final_amps : array[num_tslots, n_ctrls]; The amplitudes at the end of the optimisation. evo_full_final : Qobj; The evolution operator from t=0 to t=T based on the final amps. evo_full_initial : Qobj; The evolution operator from t=0 to t=T based on the initial amps; ; stats : Stats; Object contaning the stats for the run (if any collected); ; optimizer : Optimizer; Instance of the Optimizer used to generate the result; """"""; def __init__(self):; self.reset(). def reset(self):; self.fidelity = 0.0; self.initial_fid_err = np.Inf; self.fid_err = np.Inf; self.goal_achieved = False; self.grad_norm_final = 0.0; self.grad_norm_min_reached = False; self.num_iter = 0; self.max_iter_exceeded = False; self.num_fid_func_calls = 0; self.max_fid_func_exceeded = False; self.wall_time = 0.0; self.wall_time_limit_exceeded = False; self.termination_reason = ""not started yet""; self.time = None; self.initial_amps = None; self.final_amps = None; self.evo_full_final = None; self.evo_full_initial = None; self.stats = None; self.optimizer = None.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/control/optimresult.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/optimresult.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:2826,Availability,error,errors,2826,"IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' ",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:6235,Availability,error,errors,6235,"he logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX';",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:6681,Availability,error,errors,6681," dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """""";",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:4323,Deployability,configurat,configuration,4323,"ted with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been ",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:7033,Deployability,configurat,configuration,7033,"""""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generat",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:7817,Deployability,configurat,configuration,7817,"e a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generator (H); As part of the calc the the eigen decomposition is required, which; is reused in the propagator gradient calculation; """"""; dyn = self.parent; dyn._ensure_decomp_curr(k). if dyn.oper_dtype == Qobj:. prop = (dyn._dyn_gen_eigenvectors[k]*dyn._prop_eigen[k]*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; prop = dyn._dyn_gen_eigenvectors[k].dot(; dyn._prop_eigen[k]).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). return prop. def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot. Returns:; [prop], prop_grad; """"""; dyn = self.parent; dyn._ensure_decomp_curr(k). if compute_prop:; prop = self._compute_propagator(k). if",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:14140,Deployability,update,updated,14140,"pagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient; """"""; [docs] def reset(self):; PropagatorComputer.reset(self); self.id_text = 'FRECHET'; self.grad_exact = True; self.apply_params(). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot using the expm_frechet method; The propagtor is calculated (almost) for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent. if dyn.oper_dtype == Qobj:; A = dyn._get_phased_dyn_gen(k).full()*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j).full()*dyn.tau[k]; if compute_prop:; prop_dense, prop_grad_dense = la.expm_frechet(A, E); prop = Qobj(prop_dense, dims=dyn.dyn_dims); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); else:; prop_grad_dense = la.expm_frechet(A, E, compute_expm=False); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); elif dyn.oper_dtype == np.ndarray:; A = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j)*dyn.tau[k]; if compute_prop:; prop, prop_grad = la.expm_frechet(A, E); else:; prop_grad = la.expm_frechet(A, E,; compute_expm=False); else:; # Assuming some sparse matrix; spcls = dyn._dyn_gen[k].__class__; A = (dyn._get_phased_dyn_gen(k)*dyn.tau[k]).toarray(); E = (dyn._get_phased_ctrl_dyn_gen(k, j)*dyn.tau[k]).toarray(); if compute_prop:; prop_dense, prop_grad_dense = la.expm_frechet(A, E); prop = spcls(prop_dense); prop_grad = spcls(prop_grad_dense); else:; prop_grad_dense = la.expm_frechet(A, E, compute_expm=False); prop_grad = spcls(prop_grad_dense). if compute_prop:; return prop, prop_grad; else:; return prop_grad.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:9916,Energy Efficiency,efficient,efficient,9916,"genvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = Qobj(np.multiply(cdg.full()*dyn.tau[k],; dyn._dyn_gen_factormatrix[k]), dims=dyn.dyn_dims); # Return to canonical basis; prop_grad = (dyn._dyn_gen_eigenvectors[k]*cdg*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; # put control dyn_gen in combined dg diagonal basis; cdg = dyn._get_dyn_gen_eigenvectors_adj(k).dot(; dyn._get_phased_ctrl_dyn_gen(k, j)).dot(; dyn._dyn_gen_eigenvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = np.multiply(cdg*dyn.tau[k], dyn._dyn_gen_factormatrix[k]); # Return to canonical basis; prop_grad = dyn._dyn_gen_eigenvectors[k].dot(cdg).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). if compute_prop:; return prop, prop_grad; else:; return prop_grad. class PropCompAugMat(PropagatorComputer):; """"""; Augmented Matrix (deprecated - see _Frechet). It should work for all systems, e.g. open, symplectic; There will be other PropagatorComputer subclasses that are more efficient; The _Frechet class should provide exactly the same functionality; more efficiently. Note the propagator gradient calculation using the augmented matrix; is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer; """"""; def reset(self):; PropagatorComputer.reset(self); self.id_text = 'AUG_MAT'; self.grad_exact = True; self.apply_params(). def _get_aug_mat(self, k, j):; """"""; Generate the matrix [[A, E], [0, A]] where; A is the overall dynamics generator; E is the control dynamics generator; for a given timeslot and control; returns this augmented matrix; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k). if dyn.oper_dtype == Qobj:; A = dg.data*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j).data*dyn.tau[k]; Z = sp.csr_matrix(dg.data.shape); aug = Qobj(sp.vstack([sp.hstack([A, E]), sp.hstack([Z, A])])); elif dyn.oper_dtype == np.ndarray:; A = dg*dyn.tau",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:9998,Energy Efficiency,efficient,efficiently,9998,"genvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = Qobj(np.multiply(cdg.full()*dyn.tau[k],; dyn._dyn_gen_factormatrix[k]), dims=dyn.dyn_dims); # Return to canonical basis; prop_grad = (dyn._dyn_gen_eigenvectors[k]*cdg*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; # put control dyn_gen in combined dg diagonal basis; cdg = dyn._get_dyn_gen_eigenvectors_adj(k).dot(; dyn._get_phased_ctrl_dyn_gen(k, j)).dot(; dyn._dyn_gen_eigenvectors[k]); # multiply (elementwise) by timeslice and factor matrix; cdg = np.multiply(cdg*dyn.tau[k], dyn._dyn_gen_factormatrix[k]); # Return to canonical basis; prop_grad = dyn._dyn_gen_eigenvectors[k].dot(cdg).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). if compute_prop:; return prop, prop_grad; else:; return prop_grad. class PropCompAugMat(PropagatorComputer):; """"""; Augmented Matrix (deprecated - see _Frechet). It should work for all systems, e.g. open, symplectic; There will be other PropagatorComputer subclasses that are more efficient; The _Frechet class should provide exactly the same functionality; more efficiently. Note the propagator gradient calculation using the augmented matrix; is taken from:; 'Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics'; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer; """"""; def reset(self):; PropagatorComputer.reset(self); self.id_text = 'AUG_MAT'; self.grad_exact = True; self.apply_params(). def _get_aug_mat(self, k, j):; """"""; Generate the matrix [[A, E], [0, A]] where; A is the overall dynamics generator; E is the control dynamics generator; for a given timeslot and control; returns this augmented matrix; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k). if dyn.oper_dtype == Qobj:; A = dg.data*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j).data*dyn.tau[k]; Z = sp.csr_matrix(dg.data.shape); aug = Qobj(sp.vstack([sp.hstack([A, E]), sp.hstack([Z, A])])); elif dyn.oper_dtype == np.ndarray:; A = dg*dyn.tau",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:12373,Energy Efficiency,efficient,efficient,12373," using the exponentiation of the the augmented; matrix.; The propagtor is calculated for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent; dg = dyn._get_phased_dyn_gen(k); aug = self._get_aug_mat(k, j). if dyn.oper_dtype == Qobj:; aug_exp = aug.expm(); prop_grad = Qobj(aug_exp.data[:dg.shape[0], dg.shape[1]:],; dims=dyn.dyn_dims); if compute_prop:; prop = Qobj(aug_exp.data[:dg.shape[0], :dg.shape[1]],; dims=dyn.dyn_dims); else:; aug_exp = la.expm(aug); prop_grad = aug_exp[:dg.shape[0], dg.shape[1]:]; if compute_prop:; prop = aug_exp[:dg.shape[0], :dg.shape[1]]. if compute_prop:; return prop, prop_grad; else:; return prop_grad. [docs]class PropCompFrechet(PropagatorComputer):; """"""; Frechet method for calculating the propagator:; exponentiating the combined dynamics generator; and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient; """"""; [docs] def reset(self):; PropagatorComputer.reset(self); self.id_text = 'FRECHET'; self.grad_exact = True; self.apply_params(). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot using the expm_frechet method; The propagtor is calculated (almost) for 'free' in this method; and hence it is returned if compute_prop==True; Returns:; [prop], prop_grad; """"""; dyn = self.parent. if dyn.oper_dtype == Qobj:; A = dyn._get_phased_dyn_gen(k).full()*dyn.tau[k]; E = dyn._get_phased_ctrl_dyn_gen(k, j).full()*dyn.tau[k]; if compute_prop:; prop_dense, prop_grad_dense = la.expm_frechet(A, E); prop = Qobj(prop_dense, dims=dyn.dyn_dims); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); else:; prop_grad_dense = la.expm_frechet(A, E, compute_expm=False); prop_grad = Qobj(prop_grad_dense,; dims=dyn.dyn_dims); elif dyn.oper_dtype == np.ndarray:; A = dyn._get_phased_dyn_gen(k)*dyn.tau[",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:2856,Integrability,message,message,2856,"USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken f",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:2944,Integrability,message,message,2944,"USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken f",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:3032,Integrability,message,message,3032,"###############################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:4323,Modifiability,config,configuration,4323,"ted with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been ",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:7033,Modifiability,config,configuration,7033,"""""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generat",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:7817,Modifiability,config,configuration,7817,"e a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'DIAG'; self.grad_exact = True; self.apply_params(). def _compute_propagator(self, k):; """"""; Calculates the exponentiation of the dynamics generator (H); As part of the calc the the eigen decomposition is required, which; is reused in the propagator gradient calculation; """"""; dyn = self.parent; dyn._ensure_decomp_curr(k). if dyn.oper_dtype == Qobj:. prop = (dyn._dyn_gen_eigenvectors[k]*dyn._prop_eigen[k]*; dyn._get_dyn_gen_eigenvectors_adj(k)); else:; prop = dyn._dyn_gen_eigenvectors[k].dot(; dyn._prop_eigen[k]).dot(; dyn._get_dyn_gen_eigenvectors_adj(k)). return prop. def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot. Returns:; [prop], prop_grad; """"""; dyn = self.parent; dyn._ensure_decomp_curr(k). if compute_prop:; prop = self._compute_propagator(k). if",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:2696,Testability,log,logging,2696,"ITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasi",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:2735,Testability,log,logging,2735,"R BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, ",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:2744,Testability,log,logger,2744,"R BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, ",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:2753,Testability,log,logging,2753,"R BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Propagator Computer; Classes used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used. Note the methods in the _Diag class was inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". # import os; import warnings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, ",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:3612,Testability,log,logger,3612,"ings; import numpy as np; import scipy.linalg as la; import scipy.sparse as sp; # QuTiP; from qutip import Qobj; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instanti",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:3659,Testability,log,logging,3659,"logger(); # QuTiP control modules; from qutip.control import errors. def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class PropagatorComputer(object):; """"""; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exi",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:4999,Testability,log,logger,4999,"RN. grad_exact : boolean; indicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsil",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:5117,Testability,log,logger,5117,"gator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:5138,Testability,log,logger,5138,"gator gradients. It is used to determine; whether to create the Dynamics prop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:5165,Testability,log,logger,5165,"rop_grad array; """"""; def __init__(self, dynamics, params=None):; self.parent = dynamics; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset any configuration data; """"""; self.id_text = 'PROP_COMP_BASE'; self.log_level = self.parent.log_level; self._grad_exact = False. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl). def grad_exact(self):; return self._grad_exact. def compute_propagator(self, k):; _func_deprecation(""'compute_propagator' has been replaced ""; ""by '_compute_propagator'""); return self._compute_propagator(k); ; def _compute_propagator(self, k):; """"""; calculate the progator between X(k) and X(k+1); Uses matrix expm of the dyn_gen at that point (in time); Assumes that the dyn_gen have been been calculated,; i.e. drift and ctrls combined; Return the propagator; """"""; dyn = self.parent; dgt = dyn._get_phased_dyn_gen(k)*dyn.tau[k]; if dyn.oper_dtype == Qobj:; prop = dgt.expm(); else:; prop = la.expm(dgt); return prop. def compute_diff_prop(self, k, j, epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the dire",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html:6877,Usability,simpl,simply,6877,"epsilon):; _func_deprecation(""'compute_diff_prop' has been replaced ""; ""by '_compute_diff_prop'""); return self._compute_diff_prop( k, j, epsilon). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). def compute_prop_grad(self, k, j, compute_prop=True):; _func_deprecation(""'compute_prop_grad' has been replaced ""; ""by '_compute_prop_grad'""); return self._compute_prop_grad(self, k, j, compute_prop=compute_prop). def _compute_prop_grad(self, k, j, compute_prop=True):; """"""; Calculate the gradient of propagator wrt the control amplitude; in the timeslot.; """"""; raise errors.UsageError(""Not implemented in the baseclass.""; "" Choose a subclass""). [docs]class PropCompApproxGrad(PropagatorComputer):; """"""; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods.; """""". [docs] def reset(self):; """"""; reset any configuration data; """"""; PropagatorComputer.reset(self); self.id_text = 'APPROX'; self.grad_exact = False; self.apply_params(). def _compute_diff_prop(self, k, j, epsilon):; """"""; Calculate the propagator from the current point to a trial point; a distance 'epsilon' (change in amplitude); in the direction the given control j in timeslot k; Returns the propagator; """"""; dyn = self.parent; dgt_eps = (dyn._get_phased_dyn_gen(k) +; epsilon*dyn._get_phased_ctrl_dyn_gen(k, j))*dyn.tau[k]. if dyn.oper_dtype == Qobj:; prop_eps = dgt_eps.expm(); else:; prop_eps = la.expm(dgt_eps). return prop_eps. [docs]class PropCompDiag(PropagatorComputer):; """"""; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator; """"""; [docs] def reset(self):; """"""; reset any configuration data; """"""",MatchSource.WIKI,docs/4.3/modules/qutip/control/propcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/propcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:2672,Availability,error,errors,2672,"TUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied ov",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:2682,Availability,error,errors,2682,"TUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied ov",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:8515,Availability,error,errors,8515,".scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None; ; if not self.ubound is None and not self.lbound is None:; if self.ubound < self.lbound:; raise ValueError(""ubound cannot be less the lbound""). def _apply_bounds_and_offset(self, pulse):; """"""; Ensure that the randomly generated pulse fits within the bounds",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:36483,Deployability,update,updated,36483,"urier basis functions, i.e. sin and cos. Attributes; ----------; freqs : float array[num_coeffs]; Frequencies for the basis functions; randomize_freqs : bool; If True (default) the some random offset is applied to the frequencies; """""". [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGenCrab.reset(self); self.freqs = None; self.randomize_freqs = True. [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGenCrab.init_pulse(self); ; self.init_freqs(); ; [docs] def init_freqs(self):; """"""; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset; """"""; self.freqs = np.empty(self.num_coeffs); ff = 2*np.pi / self.pulse_time; for i in range(self.num_coeffs):; self.freqs[i] = ff*(i + 1); ; if self.randomize_freqs:; self.freqs += np.random.random(self.num_coeffs) - 0.5; ; [docs] def gen_pulse(self, coeffs=None):; """"""; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes.; ; Parameters; ----------; coeffs : float array[num_coeffs, num_basis_funcs]; The basis coefficient values; If given this overides the default and sets the attribute; of the same name.; """"""; if coeffs:; self.coeffs = coeffs; ; if not self._pulse_initialised:; self.init_pulse(); ; pulse = np.zeros(self.num_tslots). for i in range(self.num_coeffs):; phase = self.freqs[i]*self.time; # basis1comp = self.coeffs[i, 0]*np.sin(phase); # basis2comp = self.coeffs[i, 1]*np.cos(phase); # pulse += basis1comp + basis2comp; pulse += self.coeffs[i, 0]*np.sin(phase) + \; self.coeffs[i, 1]*np.cos(phase) . if self.guess_pulse_func:; pulse = self.guess_pulse_func(pulse); if self.ramping_pulse is not None:; pulse = self._apply_ramping_pulse(pulse); ; return self._apply_bounds(pulse); .  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:30738,Energy Efficiency,efficient,efficient,30738,"If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; T",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:30821,Integrability,message,message,30821,"effs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:29267,Modifiability,variab,variables,29267,".parent = dyn; self.num_coeffs = num_coeffs; self.params = params; self.reset(); ; [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.NUM_COEFFS_WARN_LVL = 20; self.DEF_NUM_COEFFS = 4; self._BSC_ALL = 1; self._BSC_GT_MEAN = 2; self._BSC_LT_MEAN = 3; ; self._uses_time = True; self.time = None; self.num_basis_funcs = 2; self.num_optim_vars = 0; self.coeffs = None; self.randomize_coeffs = True; self._num_coeffs_estimated = False; self.guess_pulse_action = 'MODULATE'; self.guess_pulse = None; self.guess_pulse_func = None; self.apply_params(); ; [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGen.init_pulse(self); self.init_coeffs(num_coeffs=num_coeffs); ; if self.guess_pulse is not None:; self.init_guess_pulse(); self._init_bounds(); ; if self.log_level <= logging.DEBUG and not self._num_coeffs_estimated:; logger.debug(; ""CRAB pulse initialised with {} coefficients per basis ""; ""function, which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_leve",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:30379,Modifiability,variab,variables,30379,"um_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:12666,Safety,avoid,avoid,12666,"scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). min_wavelen : float; Minimum wavelength of any component wave; Set by default to 1/10th of the pulse time; """""". def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.random = True; self._uses_time = True; try:; self.min_wavelen = self.pulse_time / 10.0; except:; self.min_wavelen = 0.1; self.apply_params(). def gen_pulse(self, min_wavelen=None):; """"""; Generate a random pulse based on a Fourier series with a minimum; wavelength; """""". if min_wavelen is not None:; self.min_wavelen = min_wavelen; min_wavelen = self.min_wavelen. if min_wavelen > self.pulse_time:; raise ValueError(""Minimum wavelength cannot be greater than ""; ""the pulse time""); if not self._pulse_initialised:; self.init_pulse(). # use some phase to avoid the first pulse being always 0. sum_wave = np.zeros(self.tau.shape); wavelen = 2.0*self.pulse_time. t = self.time; wl = []; while wavelen > min_wavelen:; wl.append(wavelen); wavelen = wavelen/2.0. num_comp_waves = len(wl); amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves). for wavelen in wl:; amp = amp_scale*(np.random.rand()*2 - 1); phase_off = np.random.rand()*np.pi/2.0; curr_wave = amp*np.sin(2*np.pi*t/wavelen + phase_off); sum_wave += curr_wave. return self._apply_bounds_and_offset(sum_wave). class PulseGenRndWaves(PulseGen):; """"""; Generates pulses by summing sine waves with random frequencies; amplitudes and phase offset. Attributes; ----------; scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). num_comp_waves : integer; Number of component waves. That is the number of waves that; are summe",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:15062,Safety,avoid,avoid,15062,"elf.num_comp_waves = 20; try:; self.min_wavelen = self.pulse_time / 10.0; except:; self.min_wavelen = 0.1; try:; self.max_wavelen = 2*self.pulse_time; except:; self.max_wavelen = 10.0; self.apply_params(). def gen_pulse(self, num_comp_waves=None,; min_wavelen=None, max_wavelen=None):; """"""; Generate a random pulse by summing sine waves with random freq,; amplitude and phase offset; """""". if num_comp_waves is not None:; self.num_comp_waves = num_comp_waves; if min_wavelen is not None:; self.min_wavelen = min_wavelen; if max_wavelen is not None:; self.max_wavelen = max_wavelen. num_comp_waves = self.num_comp_waves; min_wavelen = self.min_wavelen; max_wavelen = self.max_wavelen. if min_wavelen > self.pulse_time:; raise ValueError(""Minimum wavelength cannot be greater than ""; ""the pulse time""); if max_wavelen <= min_wavelen:; raise ValueError(""Maximum wavelength must be greater than ""; ""the minimum wavelength""). if not self._pulse_initialised:; self.init_pulse(). # use some phase to avoid the first pulse being always 0. sum_wave = np.zeros(self.tau.shape). t = self.time; wl_range = max_wavelen - min_wavelen; amp_scale = np.sqrt(8)*self.scaling / float(num_comp_waves); for n in range(num_comp_waves):; amp = amp_scale*(np.random.rand()*2 - 1); phase_off = np.random.rand()*np.pi/2.0; wavelen = min_wavelen + np.random.rand()*wl_range; curr_wave = amp*np.sin(2*np.pi*t/wavelen + phase_off); sum_wave += curr_wave. return self._apply_bounds_and_offset(sum_wave). class PulseGenRndWalk1(PulseGen):; """"""; Generates pulses by using a random walk algorithm. Attributes; ----------; scaling : float; Used as the range for the starting amplitude; Note must used bounds if values must be restricted.; Also scales the max_d_amp value; (copied from Dynamics.initial_ctrl_scaling if given). max_d_amp : float; Maximum amount amplitude will change between timeslots; Note this is also factored by the scaling attribute; """"""; def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.res",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:31782,Safety,avoid,avoided,31782," {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the ; # main optmisation call sequence; self.set_coeffs(param_vals); ; def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]); ; def init_guess_pulse(self):; ; self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)); ; def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse; ; def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse; ; def _init_bounds(self):; add_guess_pulse_scale ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:2568,Testability,log,logging,2568,"AL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then t",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:2577,Testability,log,logger,2577,"AL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then t",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:2586,Testability,log,logging,2586,"AL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details; """""". import numpy as np. import qutip.logging_utils as logging; logger = logging.get_logger(). import qutip.control.dynamics as dynamics; import qutip.control.errors as errors. [docs]def create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None):; """"""; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:; ; RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot; ; These are the other non-periodic options:; ; LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0; ; These are the periodic options; ; SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave; ; If a Dynamics object is passed in then t",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:6553,Testability,log,logger,6553,"caling applied to the pulse; (copied from Dynamics.initial_ctrl_scaling if given). offset : float; linear offset applied to the pulse; (copied from Dynamics.initial_ctrl_offset if given). tau : array[num_tslots] of float; Duration of each timeslot; (copied from Dynamics if given). lbound : float; Lower boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is -Inf. ubound : float; Upper boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is Inf. periodic : boolean; True if the pulse generator produces periodic pulses. random : boolean; True if the pulse generator produces random pulses. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; """"""; def __init__(self, dyn=None, params=None):; self.parent = dyn; self.params = params; self.reset(). [docs] def reset(self):; """"""; reset attributes to default values; """"""; if isinstance(self.parent, dynamics.Dynamics):; dyn = self.parent; self.num_tslots = dyn.num_tslots; self.pulse_time = dyn.evo_time; self.scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pul",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:8151,Testability,log,logger,8151,"ics.Dynamics):; dyn = self.parent; self.num_tslots = dyn.num_tslots; self.pulse_time = dyn.evo_time; self.scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:8272,Testability,log,logger,8272,".scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None; ; if not self.ubound is None and not self.lbound is None:; if self.ubou",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:8293,Testability,log,logger,8293,".scaling = dyn.initial_ctrl_scaling; self.offset = dyn.initial_ctrl_offset; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None; ; if not self.ubound is None and not self.lbound is None:; if self.ubou",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:8320,Testability,log,logger,8320,"; self.tau = dyn.tau; self.log_level = dyn.log_level; else:; self.num_tslots = 100; self.pulse_time = 1.0; self.scaling = 1.0; self.tau = None; self.offset = 0.0. self._uses_time = False; self.time = None; self._pulse_initialised = False; self.periodic = False; self.random = False; self.lbound = None; self.ubound = None; self.ramping_pulse = None; ; self.apply_params(); ; [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the ; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; """""" ; if not params:; params = self.params; ; if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). @property; def log_level(self):; return logger.level ; ; @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def gen_pulse(self):; """"""; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass; """"""; # must be implemented by subclass; raise errors.UsageError(; ""No method defined for generating a pulse. ""; "" Suspect base class was used where sub class should have been""). [docs] def init_pulse(self):; """"""; Initialise the pulse parameters; """"""; if self.tau is None:; self.tau = np.ones(self.num_tslots, dtype='f') * \; self.pulse_time/self.num_tslots; ; if self._uses_time:; self.time = np.zeros(self.num_tslots, dtype=float); for k in range(self.num_tslots-1):; self.time[k+1] = self.time[k] + self.tau[k]; ; self._pulse_initialised = True. if not self.lbound is None:; if np.isinf(self.lbound):; self.lbound = None; if not self.ubound is None:; if np.isinf(self.ubound):; self.ubound = None; ; if not self.ubound is None and not self.lbound is None:; if self.ubound < self.lbound:; raise ValueError(""ubound cannot be less the lbound""). d",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:29089,Testability,log,logging,29089," initialised, otherwise they will all be equal to self.scaling; """"""; def __init__(self, dyn=None, num_coeffs=None, params=None):; self.parent = dyn; self.num_coeffs = num_coeffs; self.params = params; self.reset(); ; [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.NUM_COEFFS_WARN_LVL = 20; self.DEF_NUM_COEFFS = 4; self._BSC_ALL = 1; self._BSC_GT_MEAN = 2; self._BSC_LT_MEAN = 3; ; self._uses_time = True; self.time = None; self.num_basis_funcs = 2; self.num_optim_vars = 0; self.coeffs = None; self.randomize_coeffs = True; self._num_coeffs_estimated = False; self.guess_pulse_action = 'MODULATE'; self.guess_pulse = None; self.guess_pulse_func = None; self.apply_params(); ; [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGen.init_pulse(self); self.init_coeffs(num_coeffs=num_coeffs); ; if self.guess_pulse is not None:; self.init_guess_pulse(); self._init_bounds(); ; if self.log_level <= logging.DEBUG and not self._num_coeffs_estimated:; logger.debug(; ""CRAB pulse initialised with {} coefficients per basis ""; ""function, which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:29140,Testability,log,logger,29140,"l to self.scaling; """"""; def __init__(self, dyn=None, num_coeffs=None, params=None):; self.parent = dyn; self.num_coeffs = num_coeffs; self.params = params; self.reset(); ; [docs] def reset(self):; """"""; reset attributes to default values; """"""; PulseGen.reset(self); self.NUM_COEFFS_WARN_LVL = 20; self.DEF_NUM_COEFFS = 4; self._BSC_ALL = 1; self._BSC_GT_MEAN = 2; self._BSC_LT_MEAN = 3; ; self._uses_time = True; self.time = None; self.num_basis_funcs = 2; self.num_optim_vars = 0; self.coeffs = None; self.randomize_coeffs = True; self._num_coeffs_estimated = False; self.guess_pulse_action = 'MODULATE'; self.guess_pulse = None; self.guess_pulse_func = None; self.apply_params(); ; [docs] def init_pulse(self, num_coeffs=None):; """"""; Set the initial freq and coefficient values; """"""; PulseGen.init_pulse(self); self.init_coeffs(num_coeffs=num_coeffs); ; if self.guess_pulse is not None:; self.init_guess_pulse(); self._init_bounds(); ; if self.log_level <= logging.DEBUG and not self._num_coeffs_estimated:; logger.debug(; ""CRAB pulse initialised with {} coefficients per basis ""; ""function, which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:30225,Testability,log,logging,30225,", which means a total of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:30240,Testability,log,logger,30240,"tal of {} ""; ""optimisation variables for this pulse"".format(; self.num_coeffs, self.num_optim_vars)); ; # def generate_guess_pulse(self); # if isinstance(self.guess_pulsegen, PulseGen):; # self.guess_pulse = self.guess_pulsegen.gen_pulse(); # return self.guess_pulse; ; [docs] def init_coeffs(self, num_coeffs=None):; """"""; Generate the initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Return",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:30576,Testability,log,logging,30576,"he initial ceofficent values.; ; Parameters; ----------; num_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:30639,Testability,log,logger,30639,"um_coeffs : integer; Number of coefficients used for each basis function; If given this overides the default and sets the attribute; of the same name.; """"""; if num_coeffs:; self.num_coeffs = num_coeffs; ; self._num_coeffs_estimated = False; if not self.num_coeffs:; if isinstance(self.parent, dynamics.Dynamics):; dim = self.parent.get_drift_dim(); self.num_coeffs = self.estimate_num_coeffs(dim); self._num_coeffs_estimated = True; else:; self.num_coeffs = self.DEF_NUM_COEFFS; self.num_optim_vars = self.num_coeffs*self.num_basis_funcs; ; if self._num_coeffs_estimated:; if self.log_level <= logging.INFO:; logger.info(; ""The number of CRAB coefficients per basis function ""; ""has been estimated as {}, which means a total of {} ""; ""optimisation variables for this pulse. Based on the ""; ""dimension ({}) of the system"".format(; self.num_coeffs, self.num_optim_vars, dim)); # Issue warning if beyond the recommended level; if self.log_level <= logging.WARN:; if self.num_coeffs > self.NUM_COEFFS_WARN_LVL:; logger.warn(; ""The estimated number of coefficients {} exceeds ""; ""the amount ({}) recommended for efficient ""; ""optimisation. You can set this level explicitly ""; ""to suppress this message."".format(; self.num_coeffs, self.NUM_COEFFS_WARN_LVL)); ; if self.randomize_coeffs:; r = np.random.random([self.num_coeffs, self.num_basis_funcs]); self.coeffs = (2*r - 1.0) * self.scaling; else:; self.coeffs = np.ones([self.num_coeffs, ; self.num_basis_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:32088,Testability,log,logger,32088,"s_funcs])*self.scaling; ; [docs] def estimate_num_coeffs(self, dim):; """"""; Estimate the number coefficients based on the dimensionality of the; system.; Returns; -------; num_coeffs : int; estimated number of coefficients; """"""; num_coeffs = max(2, dim - 1); return num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the ; # main optmisation call sequence; self.set_coeffs(param_vals); ; def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]); ; def init_guess_pulse(self):; ; self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)); ; def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse; ; def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse; ; def _init_bounds(self):; add_guess_pulse_scale = False; if self.lbound is None and self.ubound is None:; # no bounds to apply; self._bound_scale_cond = None; elif self.lbound is None:; # only upper bound; if self.ubound > 0:; self._bound_mean = 0.0; self._bound_scale = self.ubound; else:; add_guess_pulse_scale = True; self._bound_scale = self.scaling*self.num_coeffs + \; self.get_guess_pulse_scale(); self._bound_mean = -abs(self._boun",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:32353,Testability,log,logger,32353,"n num_coeffs; ; [docs] def get_optim_var_vals(self):; """"""; Get the parameter values to be optimised; Returns; -------; list (or 1d array) of floats ; """"""; return self.coeffs.ravel().tolist(); ; [docs] def set_optim_var_vals(self, param_vals):; """"""; Set the values of the any of the pulse generation parameters; based on new values from the optimisation method; Typically this will be the basis coefficients; """"""; # Type and size checking avoided here as this is in the ; # main optmisation call sequence; self.set_coeffs(param_vals); ; def set_coeffs(self, param_vals):; self.coeffs = param_vals.reshape(; [self.num_coeffs, self.num_basis_funcs]); ; def init_guess_pulse(self):; ; self.guess_pulse_func = None; if not self.guess_pulse_action:; logger.WARN(""No guess pulse action given, hence ignored.""); elif self.guess_pulse_action.upper() == 'MODULATE':; self.guess_pulse_func = self.guess_pulse_modulate; elif self.guess_pulse_action.upper() == 'ADD':; self.guess_pulse_func = self.guess_pulse_add; else:; logger.WARN(""No option for guess pulse action '{}' ""; "", hence ignored."".format(self.guess_pulse_action)); ; def guess_pulse_add(self, pulse):; pulse = pulse + self.guess_pulse; return pulse; ; def guess_pulse_modulate(self, pulse):; pulse = (1.0 + pulse)*self.guess_pulse; return pulse; ; def _init_bounds(self):; add_guess_pulse_scale = False; if self.lbound is None and self.ubound is None:; # no bounds to apply; self._bound_scale_cond = None; elif self.lbound is None:; # only upper bound; if self.ubound > 0:; self._bound_mean = 0.0; self._bound_scale = self.ubound; else:; add_guess_pulse_scale = True; self._bound_scale = self.scaling*self.num_coeffs + \; self.get_guess_pulse_scale(); self._bound_mean = -abs(self._bound_scale) + self.ubound; self._bound_scale_cond = self._BSC_GT_MEAN. elif self.ubound is None:; # only lower bound; if self.lbound < 0:; self._bound_mean = 0.0; self._bound_scale = abs(self.lbound); else:; self._bound_scale = self.scaling*self.num_coeffs + \; self.",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html:11044,Usability,simpl,simply,11044," - max_amp; else:; # min_amp + offset must exceed the lbound; return pulse + self.lbound - min_amp; else:; bound_range = self.ubound - self.lbound; amp_range = max_amp - min_amp; if max_amp - min_amp > bound_range:; # pulse range is too high, it must be scaled; pulse = pulse * bound_range / amp_range. # otherwise the pulse should fit anyway; return pulse + self.lbound - min(pulse). def _apply_ramping_pulse(self, pulse, ramping_pulse=None):; if ramping_pulse is None:; ramping_pulse = self.ramping_pulse; if ramping_pulse is not None:; pulse = pulse*ramping_pulse; ; return pulse; ; [docs]class PulseGenZero(PulseGen):; """"""; Generates a flat pulse; """"""; [docs] def gen_pulse(self):; """"""; Generate a pulse with the same value in every timeslot.; The value will be zero, unless the offset is not zero,; in which case it will be the offset; """"""; pulse = np.zeros(self.num_tslots); return self._apply_bounds_and_offset(pulse). [docs]class PulseGenRandom(PulseGen):; """"""; Generates random pulses as simply random values for each timeslot; """"""; [docs] def reset(self):; PulseGen.reset(self); self.random = True; self.apply_params(). [docs] def gen_pulse(self):; """"""; Generate a pulse of random values between 1 and -1; Values are scaled using the scaling property; and shifted using the offset property; Returns the pulse as an array of vales for each timeslot; """"""; pulse = (2*np.random.random(self.num_tslots) - 1) * self.scaling. return self._apply_bounds_and_offset(pulse). class PulseGenRndFourier(PulseGen):; """"""; Generates pulses by summing sine waves as a Fourier series; with random coefficients. Attributes; ----------; scaling : float; The pulses should fit approximately within -/+scaling; (before the offset is applied); as it is used to set a maximum for each component wave; Use bounds to be sure; (copied from Dynamics.initial_ctrl_scaling if given). min_wavelen : float; Minimum wavelength of any component wave; Set by default to 1/10th of the pulse time; """""". def reset(self):; """"""; re",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulsegen.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulsegen.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:2472,Availability,error,error,2472,"TORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number o",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:2640,Availability,error,error,2640,"# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:2937,Availability,error,error,2937,"F THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Opt",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:3190,Availability,error,error,3190,"email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Co",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:3873,Availability,error,error,3873,"odule. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 14 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import q",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:4867,Availability,error,errors,4867,"imisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 14 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_param",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:4877,Availability,error,errors,4877,"imisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 14 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_param",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:6292,Availability,error,error,6292,"e message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:6701,Availability,error,error,6701,"10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be gi",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:6721,Availability,error,error,6721,"10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be gi",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:8249,Availability,error,error,8249,"ntrol generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a sc",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:8316,Availability,error,error,8316,"on.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:9331,Availability,error,error,9331,"lue. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameter",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:10955,Availability,error,error,10955,"minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; amp_update_mode : string; Deprecated. Use tslot_type inste",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:10975,Availability,error,error,10975,"minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; amp_update_mode : string; Deprecated. Use tslot_type inste",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:14171,Availability,error,error,14171,"name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:19520,Availability,error,error,19520,"not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:20187,Availability,error,error,20187,"im_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:20354,Availability,error,error,20354,"mping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot duration",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:21774,Availability,error,error,21774,"t control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scip",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:21841,Availability,error,error,21841,"on.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pu",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:22854,Availability,error,error,22854,"value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; ; PSU - global phase ignored; SU - global phase included. dyn_para",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:27066,Availability,error,error,27066,"be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # parameters are checked in create pulse optimiser; ; # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = accuracy_factor; else:; method_params = {'accuracy_factor':accuracy_factor}; _param_deprecation(; ""The 'a",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:30220,Availability,error,error,30220,"nit_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext,; gen_stats=gen_stats); ; [docs]def opt_pulse_crab(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:30699,Availability,error,error,30699," optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:30719,Availability,error,error,30719," optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:32247,Availability,error,error,32247,"ntrol generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:32314,Availability,error,error,32314,"on.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while sti",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:34009,Availability,error,error,34009,"his is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:34845,Availability,error,error,34845," be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; guess_pulse_type : string; type / shape of pulse(s) used modulate the control amplitudes. ; Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN; Default is None; ; guess_pulse_params : di",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:34865,Availability,error,error,34865," be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; guess_pulse_type : string; type / shape of pulse(s) used modulate the control amplitudes. ; Options include:; RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN; Default is None; ; guess_pulse_params : di",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:37908,Availability,error,error,37908,"e attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_param",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:40713,Availability,error,error,40713,"t_type=tslot_type, tslot_params=tslot_params,; init_pulse_type=guess_pulse_type, ; init_pulse_params=guess_pulse_params,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext, gen_stats=gen_stats); ; [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of th",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:41452,Availability,error,error,41452,"ss_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the tim",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:41472,Availability,error,error,41472,"ss_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the tim",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:42997,Availability,error,error,42997,"t control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:43064,Availability,error,error,43064,"on.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while sti",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:44759,Availability,error,error,44759," -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:48170,Availability,error,error,48170,"e attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_param",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:52775,Availability,error,error,52775,"ntrol generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a sc",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:52842,Availability,error,error,52842,"on.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targ : float; Fidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:53857,Availability,error,error,53857,"lue. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:55492,Availability,error,error,55492,"minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; amp_update_mode : string; Deprecated. Use tslot_type inste",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:55512,Availability,error,error,55512,"minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; phase_option : string; Deprecated. Pass in fid_params instead. fid_err_scale_factor : float; Deprecated. Use scale_factor key in fid_params instead. tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ; tslot_params : dict; Parameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; amp_update_mode : string; Deprecated. Use tslot_type inste",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:60974,Availability,error,errors,60974,"tion is None:; if isinstance(fid_params, dict):; if not 'phase_option' in fid_params:; fid_params['phase_option'] = phase_option; else:; fid_params = {'phase_option':phase_option}; _param_deprecation(; ""The 'phase_option' parameter is deprecated. ""; ""Use 'phase_option' in fid_params instead""); ; # fid_err_scale_factor; if not fid_err_scale_factor is None:; if isinstance(fid_params, dict):; if not 'fid_err_scale_factor' in fid_params:; fid_params['scale_factor'] = fid_err_scale_factor; else:; fid_params = {'scale_factor':fid_err_scale_factor}; _param_deprecation(; ""The 'fid_err_scale_factor' parameter is deprecated. ""; ""Use 'scale_factor' in fid_params instead""); ; # amp_update_mode; if not amp_update_mode is None:; amp_update_mode_up = _upper_safe(amp_update_mode); if amp_update_mode_up == 'ALL':; tslot_type = 'UPDATE_ALL'; else:; tslot_type = amp_update_mode; _param_deprecation(; ""The 'amp_update_mode' parameter is deprecated. ""; ""Use 'tslot_type' instead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_le",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:61552,Availability,error,errors,61552,"er is deprecated. ""; ""Use 'scale_factor' in fid_params instead""); ; # amp_update_mode; if not amp_update_mode is None:; amp_update_mode_up = _upper_safe(amp_update_mode); if amp_update_mode_up == 'ALL':; tslot_type = 'UPDATE_ALL'; else:; tslot_type = amp_update_mode; _param_deprecation(; ""The 'amp_update_mode' parameter is deprecated. ""; ""Use 'tslot_type' instead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True; ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None o",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:62231,Availability,error,errors,62231,"ulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True; ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_type == 'AUG_MAT':; if not isinstance(dyn.prop_computer, propcomp.PropCompAugMat):; dyn.prop_computer = propcomp.PropCompAugMat(dyn); elif prop_type == 'FRECHET':; if not isinstance(dyn.prop_computer, propcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No op",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:63192,Availability,error,errors,63192,"dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True; ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); elif prop_type == 'AUG_MAT':; if not isinstance(dyn.prop_computer, propcomp.PropCompAugMat):; dyn.prop_computer = propcomp.PropCompAugMat(dyn); elif prop_type == 'FRECHET':; if not isinstance(dyn.prop_computer, propcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No option for prop_type: "" + prop_type); dyn.prop_computer.apply_params(prop_params). # Create the FidelityComputer instance; # The default will be typically be the best option; # Note: the FidCompTraceDiffApprox is a subclass of FidCompTraceDiff; # so need to check this type first; fid_type_up = _upper_safe(fid_type); if fid_type_up == 'DEF' or fid_type_up is None or fid_type_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.f",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:64115,Availability,error,errors,64115,"ropcomp.PropCompFrechet):; dyn.prop_computer = propcomp.PropCompFrechet(dyn); else:; raise errors.UsageError(""No option for prop_type: "" + prop_type); dyn.prop_computer.apply_params(prop_params). # Create the FidelityComputer instance; # The default will be typically be the best option; # Note: the FidCompTraceDiffApprox is a subclass of FidCompTraceDiff; # so need to check this type first; fid_type_up = _upper_safe(fid_type); if fid_type_up == 'DEF' or fid_type_up is None or fid_type_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method;",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:64516,Availability,error,errors,64516,"ceDiff; # so need to check this type first; fid_type_up = _upper_safe(fid_type); if fid_type_up == 'DEF' or fid_type_up is None or fid_type_up == '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; t",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:64923,Availability,error,errors,64923,"Diff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:66300,Availability,error,errors,66300,"tim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; n_ctrls = dyn.num_ctrls. ramping_pgen = None; if ramping_pulse_type:; ramping_pgen = pulsegen.create_pulse_gen(; pulse_type=ramping_pulse_type, dyn=dyn, ; pulse_params=ramping_pulse_params); if alg_up == 'CRAB':; # Create a pulse generator for each ctrl; crab_pulse_params = None; num_coeffs = None; init_coeff_scaling = None; if isinstance(alg_params, dict):; num_coeffs = alg_params.get('num_coeffs'); init_coeff_scaling = alg_params.get('init_coeff_scaling'); if 'crab_pulse_params' in alg_params:; crab_pulse_params = alg_params.get('crab_pulse_params'); ; guess_pulse_type = init_pul",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:2344,Deployability,configurat,configuration,2344,"OT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:17668,Deployability,configurat,configuration,17668,"tim_method=optim_method, method_params=method_params,; dyn_type=dyn_type, dyn_params=dyn_params, ; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics. dyn.init_timeslots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]); ; if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amp",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:51179,Deployability,configurat,configuration,51179,"_file_ext, gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. t",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:69412,Deployability,update,updated,69412,"e_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:3509,Energy Efficiency,reduce,reduces,3509,"time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 14 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as loggin",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:5158,Integrability,message,message,5158,"o, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 14 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, ou",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:5246,Integrability,message,message,5246,"o, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 14 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, ou",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:5334,Integrability,message,message,5334,"random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combin",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:7003,Integrability,depend,dependent,7003,"tion=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundarie",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:7227,Integrability,depend,dependent,7227,"ging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a li",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:9562,Integrability,depend,dependent,9562,"me : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPRO",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:19632,Integrability,wrap,wrapper,19632,"e). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided f",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:20539,Integrability,depend,dependent,20539,"fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:20756,Integrability,depend,dependent,20756," chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list o",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:23085,Integrability,depend,dependent,23085,"ime : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; ; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs;",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:31001,Integrability,depend,dependent,31001,"=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundarie",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:31225,Integrability,depend,dependent,31225,"trol pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a li",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:40825,Integrability,wrap,wrapper,40825,"_ext=out_file_ext, gen_stats=gen_stats); ; [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Arra",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:41764,Integrability,depend,dependent,41764,"e fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control am",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:41979,Integrability,depend,dependent,41979,"es are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list o",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:51529,Integrability,depend,dependent,51529,"m_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundarie",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:51753,Integrability,depend,dependent,51753,"scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. tau : array[num_tslots] of floats or None; durations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lbound : float or list of floats; lower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_ubound : float or list of floats; upper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a li",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:54088,Integrability,depend,dependent,54088,"float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:68527,Integrability,message,message,68527,"e_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:2344,Modifiability,config,configuration,2344,"OT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:2962,Modifiability,variab,variables,2962,"F THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Opt",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:3544,Modifiability,variab,variables,3544,"time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 14 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as loggin",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:3633,Modifiability,variab,variables,3633,"time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 14 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as loggin",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:3714,Modifiability,variab,variables,3714,"um control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 14 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qut",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:17668,Modifiability,config,configuration,17668,"tim_method=optim_method, method_params=method_params,; dyn_type=dyn_type, dyn_params=dyn_params, ; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics. dyn.init_timeslots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]); ; if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amp",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:30506,Modifiability,variab,variables,30506,"ft, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:33426,Modifiability,variab,variable,33426,"um allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:33951,Modifiability,variab,variable,33951,"his is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:41259,Modifiability,variab,variables,41259,"=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0 : Qobj; starting point for the evolution.; Typically the identity matrix. U_targ : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : in",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:44176,Modifiability,variab,variable,44176,"um allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The ke",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:44701,Modifiability,variab,variable,44701," -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details); ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:51179,Modifiability,config,configuration,51179,"_file_ext, gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate or state, for the time evolution. num_tslots : integer or None; number of timeslots.; None implies that timeslots will be given in the tau array. evo_time : float or None; total time for the evolution; None implies that timeslots will be given in the tau array. t",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:68937,Modifiability,config,config,68937,"e_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:2894,Performance,optimiz,optimize,2894,"F THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Opt",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:4396,Performance,optimiz,optimization,4396,"was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 14 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:4785,Performance,optimiz,optimizer,4785,"it gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 14 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:4798,Performance,optimiz,optimizer,4798,"it gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 14 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:9244,Performance,optimiz,optimize,9244," error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:9429,Performance,optimiz,optimize,9429,"e, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; ; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:9941,Performance,optimiz,optimize,9941,"rams : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:22767,Performance,optimiz,optimize,22767,"ty error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_typ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:22952,Performance,optimiz,optimize,22952,"lue, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; ; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the obj",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:23466,Performance,optimiz,optimize,23466,"ms : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; ; GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; ; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the tim",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:33228,Performance,perform,performane,33228,"misation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:33567,Performance,optimiz,optimize,33567,"ithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:33874,Performance,optimiz,optimize,33874," float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; Fidelity error (and fidelity error gradient",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:43978,Performance,perform,performane,43978,"misation will; terminate when the fidelity error falls below this value. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:44317,Performance,optimiz,optimize,44317,"ithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict;",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:44624,Performance,optimiz,optimize,44624," float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_params : dict; Parameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; tslot_type : string; Method for computing the dynamics generators, propagators and ; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPD",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:53770,Performance,optimiz,optimize,53770," error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_grad : float; Minimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamic",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:53955,Performance,optimiz,optimize,53955,"e, the optimisation terminates, assuming local minima. max_iter : integer; Maximum number of iterations of the optimisation algorithm. max_wall_time : float; Maximum allowed elapsed time for the optimisation algorithm; ; alg : string; Algorithm to use in pulse optimisation.; Options are:; 'GRAPE' (default) - GRadient Ascent Pulse Engineering; 'CRAB' - Chopped RAndom Basis. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is cr",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:54478,Performance,optimiz,optimize,54478,"ionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these; ; optim_method : string; a scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards ; capatibility reasons.; Supplying DEF will given alg dependent result:; - GRAPE - Default optim_method is FMIN_L_BFGS_B; - CRAB - Default optim_method is Nelder-Mead; ; method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method. ; ; optim_alg : string; Deprecated. Use optim_method. max_metric_corr : integer; Deprecated. Use method_params instead. accuracy_factor : float; Deprecated. Use method_params instead. dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_params : dict; Parameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; fid_type : string; ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:58632,Performance,optimiz,optimizer,58632,"The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:58705,Performance,optimiz,optimizer,58705," name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_facto",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:64655,Performance,optimiz,optimizer,64655,"== '':; # None given, use the default for the Dynamics; pass; elif fid_type_up == 'TDAPPROX':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wa",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:64771,Performance,optimiz,optimizer,64771,", fidcomp.FidCompTraceDiffApprox):; dyn.fid_computer = fidcomp.FidCompTraceDiffApprox(dyn); elif fid_type_up == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:64871,Performance,optimiz,optimizer,64871," == 'TRACEDIFF':; if not isinstance(dyn.fid_computer, fidcomp.FidCompTraceDiff):; dyn.fid_computer = fidcomp.FidCompTraceDiff(dyn); elif fid_type_up == 'UNIT':; if not isinstance(dyn.fid_computer, fidcomp.FidCompUnitary):; dyn.fid_computer = fidcomp.FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:65077,Performance,optimiz,optimize,65077,"FidCompUnitary(dyn); else:; raise errors.UsageError(""No option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = dr",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:65179,Performance,optimiz,optimizer,65179,"option for fid_type: "" + fid_type); dyn.fid_computer.apply_params(fid_params); ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dy",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:65229,Performance,optimiz,optimizer,65229,"; ; # Currently the only working option for tslot computer is ; # TSlotCompUpdateAll.; # so just apply the parameters; dyn.tslot_computer.apply_params(tslot_params) . # Create the Optimiser instance; optim_method_up = _upper_safe(optim_method); if optim_method is None or optim_method_up == '':; raise errors.UsageError(""Optimisation method must be specified ""; ""via 'optim_method' parameter""); elif optim_method_up == 'FMIN_BFGS':; optim = optimizer.OptimizerBFGS(cfg, dyn); elif optim_method_up == 'LBFGSB' or optim_method_up == 'FMIN_L_BFGS_B':; optim = optimizer.OptimizerLBFGSB(cfg, dyn); elif optim_method_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been suppli",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:65891,Performance,perform,performance,65891,"od_up == 'FMIN':; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrabFmin(cfg, dyn); else:; raise errors.UsageError(; ""Invalid optim_method '{}' for '{}' algorthim"".format(; optim_method, alg)); else:; # Assume that the optim_method is a valid; #scipy.optimize.minimize method; # Choose an optimiser based on the algorithm; if alg_up == 'CRAB':; optim = optimizer.OptimizerCrab(cfg, dyn); else:; optim = optimizer.Optimizer(cfg, dyn); ; optim.alg = alg; optim.method = optim_method; optim.amp_lbound = amp_lbound; optim.amp_ubound = amp_ubound; optim.apply_params(optim_params); ; # Create the TerminationConditions instance; tc = termcond.TerminationConditions(); tc.fid_err_targ = fid_err_targ; tc.min_gradient_norm = min_grad; tc.max_iterations = max_iter; tc.max_wall_time = max_wall_time; optim.termination_conditions = tc; ; optim.apply_method_params(method_params). if gen_stats:; # Create a stats object; # Note that stats object is optional; # if the Dynamics and Optimizer stats attribute is not set; # then no stats will be collected, which could improve performance; if amp_update_mode == 'DYNAMIC':; sts = stats.StatsDynTsUpdate(); else:; sts = stats.Stats(). dyn.stats = sts; optim.stats = sts. # Configure the dynamics; dyn.drift_dyn_gen = drift; dyn.ctrl_dyn_gen = ctrls; dyn.initial = initial; dyn.target = target; if tau is None:; # Check that parameters have been supplied to generate the; # timeslot durations; try:; evo_time / num_tslots; except:; raise errors.UsageError(; ""Either the timeslot durations should be supplied as an ""; ""array 'tau' or the number of timeslots 'num_tslots' ""; ""and the evolution time 'evo_time' must be given.""). dyn.num_tslots = num_tslots; dyn.evo_time = evo_time; else:; dyn.tau = tau. # this function is called, so that the num_ctrls attribute will be set; n_ctrls = dyn.num_ctrls. ramping_pgen = None; if ramping_pulse_type:; ramping_pgen = pulsegen.create_pulse_gen(; pulse_type=ramping_pulse_type, dyn=dyn, ; pulse_params=ramping_pulse_params",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:68983,Performance,optimiz,optimizer,68983,"e_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:2812,Security,access,accessible,2812," CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots. There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; -----; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; ----; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables ; by defining the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default i",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:13976,Security,access,accessible,13976,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:26872,Security,access,accessible,26872,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # parameters are checked in create pulse optimiser; ; # The deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if no",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:37713,Security,access,accessible,37713,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:47975,Security,access,accessible,47975,"emented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:58274,Security,access,accessible,58274,"any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params,",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:58477,Security,access,accessed,58477,"n, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:58580,Security,access,accessed,58580,"pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization; ; """""". # check parameters; ctrls = dynamics._check_ctrls_container(ctrls); dynamics._check_drift_dyn_gen(drift). if not isinstance(initial, Qobj):; raise TypeError(""initial must be a Qobj""). if not isinstance(target, Qobj):; raise TypeError(""target must be a Qobj""); ; # Deprecated parameter management; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:4564,Testability,log,logging,4564,"the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 14 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lboun",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:4573,Testability,log,logger,4573,"the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 14 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lboun",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:4582,Testability,log,logging,4582,"the control pulses by expansions of basis functions, ; where the variables are the coefficients. Typically a Fourier series is chosen, ; i.e. the variables are the Fourier coefficients. ; Therefore it does not need to compute an explicit gradient. ; By default it uses the Nelder-Mead method for fidelity error minimisation. . References; ----------; 1. N Khaneja et. al. ; Optimal control of coupled spin dynamics: Design of NMR pulse sequences ; by gradient ascent algorithms. J. Magn. Reson. 172, 296305 (2005).; 2. Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; 3. Doria, P., Calarco, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 14 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lboun",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:6183,Testability,log,logging,6183,"tion(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:13259,Testability,log,logger,13259,"_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:14252,Testability,log,logging,14252,"name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:14281,Testability,log,logger,14281,"s are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = accuracy_factor; else:; method_params = {'accuracy_factor':accuracy_factor}; _param_deprecat",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:14316,Testability,log,logger,14316,"ng_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""; if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level); ; # The parameters types are checked in create_pulse_optimizer; # so no need to do so here; # However, the deprecation management is repeated here; # so that the stack level is correct; if not optim_alg is None:; optim_method = optim_alg; _param_deprecation(; ""The 'optim_alg' parameter is deprecated. ""; ""Use 'optim_method' instead""); ; if not max_metric_corr is None:; if isinstance(method_params, dict):; if not 'max_metric_corr' in method_params:; method_params['max_metric_corr'] = max_metric_corr; else:; method_params = {'max_metric_corr':max_metric_corr}; _param_deprecation(; ""The 'max_metric_corr' parameter is deprecated. ""; ""Use 'max_metric_corr' in method_params instead""); ; if not accuracy_factor is None:; if isinstance(method_params, dict):; if not 'accuracy_factor' in method_params:; method_params['accuracy_factor'] = accuracy_factor; else:; method_params = {'accuracy_factor':accuracy_factor}; _param_deprecation(; ""The 'accuracy_factor' par",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:17639,Testability,log,logging,17639," max_wall_time=max_wall_time,; alg=alg, alg_params=alg_params, optim_params=optim_params,; optim_method=optim_method, method_params=method_params,; dyn_type=dyn_type, dyn_params=dyn_params, ; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, gen_stats=gen_stats). dyn = optim.dynamics. dyn.init_timeslots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]); ; if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:18194,Testability,log,logger,18194,"ots(); # Generate initial pulses for each control; init_amps = np.zeros([dyn.num_tslots, dyn.num_ctrls]); ; if alg == 'CRAB':; for j in range(dyn.num_ctrls):; pgen = optim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:18375,Testability,log,logging,18375,"ptim.pulse_generator[j]; pgen.init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_puls",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:18390,Testability,log,logger,18390,"init_pulse(); init_amps[:, j] = pgen.gen_pulse(); else:; pgen = optim.pulse_generator; for j in range(dyn.num_ctrls):; init_amps[:, j] = pgen.gen_pulse(); ; # Initialise the starting amplitudes; dyn.initialize_controls(init_amps); ; if log_level <= logging.INFO:; msg = ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_par",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:18674,Testability,log,logging,18674," ""System configuration:\n""; dg_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse,",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:18689,Testability,log,logger,18689,"_name = ""dynamics generator""; if dyn_type == 'UNIT':; dg_name = ""Hamiltonian""; if dyn.time_depend_drift:; msg += ""Initial drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen[0]); else:; msg += ""Drift {}:\n"".format(dg_name); msg += str(dyn.drift_dyn_gen); for j in range(dyn.num_ctrls):; msg += ""\nControl {} {}:\n"".format(j+1, dg_name); msg += str(dyn.ctrl_dyn_gen[j]); msg += ""\nInitial state / operator:\n""; msg += str(dyn.initial); msg += ""\nTarget state / operator:\n""; msg += str(dyn.target); logger.info(msg). if out_file_ext is not None:; # Save initial amplitudes to a text file; pulsefile = ""ctrl_amps_initial_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate option",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:19411,Testability,log,logging,19411,"g.INFO:; logger.info(""Initial amplitudes output to file: "" + pulsefile). # Start the optimisation; result = optim.run_optimization(). if out_file_ext is not None:; # Save final amplitudes to a text file; pulsefile = ""ctrl_amps_final_"" + out_file_ext; dyn.save_amps(pulsefile); if log_level <= logging.INFO:; logger.info(""Final amplitudes output to file: "" + pulsefile). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Param",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:26155,Testability,log,logger,26155,"_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""".",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:30111,Testability,log,logging,30111,"method_params,; dyn_type='UNIT', dyn_params=dyn_params,; prop_params=prop_params, fid_params=fid_params,; init_pulse_type=init_pulse_type, init_pulse_params=init_pulse_params,; pulse_scaling=pulse_scaling, pulse_offset=pulse_offset,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext,; gen_stats=gen_stats); ; [docs]def opt_pulse_crab(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots,",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:33465,Testability,test,tested,33465,"um allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence; ; dyn_type : string; Dynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details); ; dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_type : string; Propagator type i.e. the method used to calculate the; propagtors ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:36996,Testability,log,logger,36996,"d after the object is created; ; guess_pulse_action : string; Determines how the guess pulse is applied to the pulse generated; by the basis expansion.; Options are: MODULATE, ADD ; Default is MODULATE. pulse_scaling : float; Linear scale factor for generated guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:38073,Testability,log,logging,38073,"evels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pul",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:38102,Testability,log,logger,38102,"EBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:38137,Testability,log,logger,38137,"BUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and ; not 'pulse_action' in guess_pu",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:40604,Testability,log,logging,40604,"arams,; dyn_type=dyn_type, dyn_params=dyn_params, ; prop_type=prop_type, prop_params=prop_params,; fid_type=fid_type, fid_params=fid_params,; tslot_type=tslot_type, tslot_params=tslot_params,; init_pulse_type=guess_pulse_type, ; init_pulse_params=guess_pulse_params,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext, gen_stats=gen_stats); ; [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolu",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:44215,Testability,test,tested,44215,"um allowed elapsed time for the optimisation algorithm. alg_params : Dictionary; options that are specific to the algorithm see above; ; optim_params : Dictionary; The key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scaling : float; Linear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there); ; num_coeffs : integer; Number of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the ; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there); ; optim_method : string; Multi-variable optimisation method; The only tested options are 'fmin' and 'Nelder-mead'; In theory any non-gradient method implemented in ; scipy.optimize.mininize could be used. method_params : dict; Parameters for the optim_method. ; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key ; that attribute. Otherwise, and in some case also, ; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:; xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_option : string; determines how global phase is treated in fidelity; calculations (fid_type='UNIT' only). Options:; PSU - global phase ignored; SU - global phase included. dyn_params : dict; Parameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_params : dict; Parameters for the PropagatorComputer object; The ke",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:47258,Testability,log,logger,47258,"d after the object is created; ; guess_pulse_action : string; Determines how the guess pulse is applied to the pulse generated; by the basis expansion.; Options are: MODULATE, ADD ; Default is MODULATE. pulse_scaling : float; Linear scale factor for generated guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """"""",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:48335,Testability,log,logging,48335,"evels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pul",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:48364,Testability,log,logger,48364,"EBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:48399,Testability,log,logger,48399,"BUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_ext : string or None; files containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : OptimResult ; Returns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc; ; """""". # The parameters are checked in create_pulse_optimizer; # so no need to do so here. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). # build the algorithm options; if not isinstance(alg_params, dict): ; alg_params = {'num_coeffs':num_coeffs, ; 'init_coeff_scaling':init_coeff_scaling}; else:; if (num_coeffs is not None and ; not 'num_coeffs' in alg_params):; alg_params['num_coeffs'] = num_coeffs; if (init_coeff_scaling is not None and ; not 'init_coeff_scaling' in alg_params):; alg_params['init_coeff_scaling'] = init_coeff_scaling; ; # Build the guess pulse options; # Any options passed in the guess_pulse_params take precedence; # over the parameter values.; if guess_pulse_type: ; if not isinstance(guess_pulse_params, dict):; guess_pulse_params = {}; if (guess_pulse_scaling is not None and ; not 'scaling' in guess_pulse_params):; guess_pulse_params['scaling'] = guess_pulse_scaling; if (guess_pulse_offset is not None and ; not 'offset' in guess_pulse_params):; guess_pulse_params['offset'] = guess_pulse_offset; if (guess_pulse_action is not None and ; not 'pulse_action' in guess_pu",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:50942,Testability,log,logging,50942,"ms=fid_params,; tslot_type=tslot_type, tslot_params=tslot_params,; init_pulse_type=guess_pulse_type, ; init_pulse_params=guess_pulse_params,; ramping_pulse_type=ramping_pulse_type, ; ramping_pulse_params=ramping_pulse_params,; log_level=log_level, out_file_ext=out_file_ext, gen_stats=gen_stats). [docs]def create_pulse_optimizer(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, gen_stats=False):. """"""; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters; ----------; drift : Qobj or list of Qobj; the underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrls : List of Qobj or array like [num_tslots, evo_time]; a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initial : Qobj; starting point for the evolution.; Typically the identity matrix. target : Qobj; target transformation, e.g. gate ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:57802,Testability,log,logger,57802," ; (see PulseGen classes for details); For the CRAB the this the guess_pulse_type. . init_pulse_params : dict; Parameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. pulse_scaling : float; Linear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offset : float; Linear offset for the pulse. That is this value will be added; to any initial / guess pulses generated.; ; ramping_pulse_type : string; Type of pulse used to modulate the control pulse.; It's intended use for a ramping modulation, which is often required in ; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose.; ; ramping_pulse_params : dict; Parameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created; ; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_stats : boolean; if set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns; -------; opt : Optimizer ; Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:61836,Testability,log,logging,61836,"e_mode' parameter is deprecated. ""; ""Use 'tslot_type' instead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True; ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCom",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:61865,Testability,log,logger,61865,"ated. ""; ""Use 'tslot_type' instead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True; ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:61900,Testability,log,logger,61900,"ead""); ; # set algorithm defaults; alg_up = _upper_safe(alg); if alg is None:; raise errors.UsageError(; ""Optimisation algorithm must be specified through 'alg' parameter""); elif alg_up == 'GRAPE':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN_L_BFGS_B'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = 'RND'; elif alg_up == 'CRAB':; if optim_method is None or optim_method.upper() == 'DEF':; optim_method = 'FMIN'; if prop_type is None or prop_type.upper() == 'DEF':; prop_type = 'APPROX'; if init_pulse_type is None or init_pulse_type.upper() == 'DEF':; init_pulse_type = None; else:; raise errors.UsageError(; ""No option for pulse optimisation algorithm alg={}"".format(alg)). cfg = optimconfig.OptimConfig(); cfg.optim_method = optim_method; cfg.dyn_type = dyn_type; cfg.prop_type = prop_type; cfg.fid_type = fid_type; cfg.init_pulse_type = init_pulse_type. if log_level == logging.NOTSET:; log_level = logger.getEffectiveLevel(); else:; logger.setLevel(log_level). cfg.log_level = log_level. # Create the Dynamics instance; if dyn_type == 'GEN_MAT' or dyn_type is None or dyn_type == '':; dyn = dynamics.DynamicsGenMat(cfg); elif dyn_type == 'UNIT':; dyn = dynamics.DynamicsUnitary(cfg); elif dyn_type == 'SYMPL':; dyn = dynamics.DynamicsSymplectic(cfg); else:; raise errors.UsageError(""No option for dyn_type: "" + dyn_type); dyn.apply_params(dyn_params); dyn._drift_dyn_gen_checked = True; dyn._ctrl_dyn_gen_checked = True; ; # Create the PropagatorComputer instance; # The default will be typically be the best option; if prop_type == 'DEF' or prop_type is None or prop_type == '':; # Do nothing use the default for the Dynamics; pass; elif prop_type == 'APPROX':; if not isinstance(dyn.prop_computer, propcomp.PropCompApproxGrad):; dyn.prop_computer = propcomp.PropCompApproxGrad(dyn); elif prop_type == 'DIAG':; if not isinstance(dyn.prop_computer, propcomp.PropCompDiag):; dyn.prop_computer = propcomp.PropCompDiag(dyn); e",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:68892,Testability,log,logging,68892,"e_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:68908,Testability,log,logger,68908,"e_params); guess_pulse_action = init_pulse_params.get('pulse_action'). optim.pulse_generator = []; for j in range(n_ctrls):; crab_pgen = pulsegen.PulseGenCrabFourier(; dyn=dyn, num_coeffs=num_coeffs); if init_coeff_scaling is not None:; crab_pgen.scaling = init_coeff_scaling; if isinstance(crab_pulse_params, dict):; crab_pgen.apply_params(crab_pulse_params); ; lb = None; if amp_lbound:; if isinstance(amp_lbound, list):; try:; lb = amp_lbound[j]; except:; lb = amp_lbound[-1]; else:; lb = amp_lbound; ub = None; if amp_ubound:; if isinstance(amp_ubound, list):; try:; ub = amp_ubound[j]; except:; ub = amp_ubound[-1]; else:; ub = amp_ubound; crab_pgen.lbound = lb; crab_pgen.ubound = ub; ; if guess_pulse_type:; guess_pgen.lbound = lb; guess_pgen.ubound = ub; crab_pgen.guess_pulse = guess_pgen.gen_pulse(); if guess_pulse_action:; crab_pgen.guess_pulse_action = guess_pulse_action; ; if ramping_pgen:; crab_pgen.ramping_pulse = ramping_pgen.gen_pulse(). optim.pulse_generator.append(crab_pgen); #This is just for the debug message now; pgen = optim.pulse_generator[0]; ; else:; # Create a pulse generator of the type specified; pgen = pulsegen.create_pulse_gen(pulse_type=init_pulse_type, dyn=dyn,; pulse_params=init_pulse_params); pgen.scaling = pulse_scaling; pgen.offset = pulse_offset; pgen.lbound = amp_lbound; pgen.ubound = amp_ubound. optim.pulse_generator = pgen. if log_level <= logging.DEBUG:; logger.debug(; ""Optimisation config summary...\n""; "" object classes:\n""; "" optimizer: "" + optim.__class__.__name__ +; ""\n dynamics: "" + dyn.__class__.__name__ +; ""\n tslotcomp: "" + dyn.tslot_computer.__class__.__name__ +; ""\n fidcomp: "" + dyn.fid_computer.__class__.__name__ +; ""\n propcomp: "" + dyn.prop_computer.__class__.__name__ +; ""\n pulsegen: "" + pgen.__class__.__name__). return optim.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:5073,Usability,simpl,simplefilter,5073,"o, T. & Montangero, S. ; Optimal Control Technique for Many-Body Quantum Dynamics. ; Phys. Rev. Lett. 106, 14 (2011).; 4. Caneva, T., Calarco, T. & Montangero, S. ; Chopped random-basis quantum optimization. ; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). """"""; import numpy as np; import warnings. # QuTiP; from qutip import Qobj; import qutip.logging_utils as logging; logger = logging.get_logger(); # QuTiP control modules; import qutip.control.optimconfig as optimconfig; import qutip.control.dynamics as dynamics; import qutip.control.termcond as termcond; import qutip.control.optimizer as optimizer; import qutip.control.stats as stats; import qutip.control.errors as errors; import qutip.control.fidcomp as fidcomp; import qutip.control.propcomp as propcomp; import qutip.control.pulsegen as pulsegen; #import qutip.control.pulsegencrab as pulsegencrab. warnings.simplefilter('always', DeprecationWarning) #turn off filter ; def _param_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel); ; def _upper_safe(s):; try:; s = s.upper(); except:; pass; return s; ; [docs]def optimize_pulse(; drift, ctrls, initial, target,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; dyn_type='GEN_MAT', dyn_params=None,; prop_type='DEF', prop_params=None,; fid_type='DEF', fid_params=None,; phase_option=None, fid_err_scale_factor=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, ou",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:19623,Usability,simpl,simply,19623,"e). return result. [docs]def optimize_pulse_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-10, min_grad=1e-10,; max_iter=500, max_wall_time=180,; alg='GRAPE', alg_params=None,; optim_params=None, optim_method='DEF', method_params=None,; optim_alg=None, max_metric_corr=None, accuracy_factor=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; amp_update_mode=None,; init_pulse_type='DEF', init_pulse_params=None,; pulse_scaling=1.0, pulse_offset=0.0,; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):. """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters; ----------; H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift; ; H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided f",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html:40816,Usability,simpl,simply,40816,"_ext=out_file_ext, gen_stats=gen_stats); ; [docs]def opt_pulse_crab_unitary(; H_d, H_c, U_0, U_targ,; num_tslots=None, evo_time=None, tau=None,; amp_lbound=None, amp_ubound=None,; fid_err_targ=1e-5,; max_iter=500, max_wall_time=180,; alg_params=None,; num_coeffs=None, init_coeff_scaling=1.0, ; optim_params=None, optim_method='fmin', method_params=None,; phase_option='PSU', ; dyn_params=None, prop_params=None, fid_params=None,; tslot_type='DEF', tslot_params=None,; guess_pulse_type=None, guess_pulse_params=None,; guess_pulse_scaling=1.0, guess_pulse_offset=0.0,; guess_pulse_action='MODULATE', ; ramping_pulse_type=None, ramping_pulse_params=None,; log_level=logging.NOTSET, out_file_ext=None, gen_stats=False):; """"""; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; ; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters; ----------. H_d : Qobj or list of Qobj; Drift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_c : List of Qobj or array like [num_tslots, evo_time]; a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Arra",MatchSource.WIKI,docs/4.3/modules/qutip/control/pulseoptim.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/pulseoptim.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:2324,Availability,redundant,redundant,2324," BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (el",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:4025,Availability,error,error,4025,"me for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute : float; Total wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating the propagators themselves. wall_time_onwd_prop_compute : float; Total wall (elasped) time computing combined onward propagation,; that is the time evolution from a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_compute : float; Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:2517,Deployability,configurat,configurations,2517,"CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_ti",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:2556,Deployability,update,updated,2556,"CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_ti",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:4830,Deployability,update,updated,4830,"ned onward propagation,; that is the time evolution from a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_compute : float; Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; sel",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:4916,Deployability,update,updates,4916,".; Excludes calculating the propagators themselves. wall_time_gradient_compute : float; Total wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; sel",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:5152,Deployability,update,update,5152,"adient; methods). num_fidelity_func_calls : integer; Number of calls to fidelity function by the optimisation algorithm. num_grad_func_calls : integer; Number of calls to gradient function by the optimisation algorithm. num_tslot_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; self.num_fidelity_func_calls = 0; self.num_grad_func_calls = 0; self.num_tslot_recompute = 0; self.num_fidelity_computes = 0; self.num_grad_computes = 0; # Control amplitudes; self.num_ctrl_amp_updates = 0; self.mea",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:5365,Deployability,update,update,5365,"_recompute : integer; Number of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; self.num_fidelity_func_calls = 0; self.num_grad_func_calls = 0; self.num_tslot_recompute = 0; self.num_fidelity_computes = 0; self.num_grad_computes = 0; # Control amplitudes; self.num_ctrl_amp_updates = 0; self.mean_num_ctrl_amp_updates_per_iter = 0.0; self.num_timeslot_changes = 0; self.mean_num_timeslot_changes_per_update = 0.0; self.num_ctrl_amp_changes = 0; self.mean_num_ctrl_amp_changes_per_update = 0.0. [docs] def calculate(self):; """"",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:9078,Deployability,update,updates,9078,"(""Wall time computing forward propagation: "" +; self._format_datetime(self.wall_time_fwd_prop_compute, tot)); print(""Wall time computing onward propagation: "" +; self._format_datetime(self.wall_time_onwd_prop_compute, tot)); print(""Wall time computing gradient: "" +; self._format_datetime(self.wall_time_gradient_compute, tot)); print(""""). def report_func_calls(self):; print(""**** Iterations and function calls ****""); print(""Number of iterations: {}"".format(self.num_iter)); print(""Number of fidelity function calls: ""; ""{}"".format(self.num_fidelity_func_calls)); print(""Number of times fidelity is computed: ""; ""{}"".format(self.num_fidelity_computes)); print(""Number of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift an",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:9153,Deployability,update,updates,9153,"int(""Wall time computing onward propagation: "" +; self._format_datetime(self.wall_time_onwd_prop_compute, tot)); print(""Wall time computing gradient: "" +; self._format_datetime(self.wall_time_gradient_compute, tot)); print(""""). def report_func_calls(self):; print(""**** Iterations and function calls ****""); print(""Number of iterations: {}"".format(self.num_iter)); print(""Number of fidelity function calls: ""; ""{}"".format(self.num_fidelity_func_calls)); print(""Number of times fidelity is computed: ""; ""{}"".format(self.num_fidelity_computes)); print(""Number of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:9363,Deployability,update,update,9363,"gradient_compute, tot)); print(""""). def report_func_calls(self):; print(""**** Iterations and function calls ****""); print(""Number of iterations: {}"".format(self.num_iter)); print(""Number of fidelity function calls: ""; ""{}"".format(self.num_fidelity_func_calls)); print(""Number of times fidelity is computed: ""; ""{}"".format(self.num_fidelity_computes)); print(""Number of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:9562,Deployability,update,update,9562,"function calls: ""; ""{}"".format(self.num_fidelity_func_calls)); print(""Number of times fidelity is computed: ""; ""{}"".format(self.num_fidelity_computes)); print(""Number of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator com",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:9696,Deployability,configurat,configurations,9696,"of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total num",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:9752,Deployability,update,updated,9752,"of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total num",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:9880,Deployability,update,update,9880,"mat(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total number of steps (matrix product) computing forward propagation. mean_num_fwd_prop_step_computes_per_update : float; Mean average num",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:10224,Deployability,update,update,10224,"n: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total number of steps (matrix product) computing forward propagation. mean_num_fwd_prop_step_computes_per_update : float; Mean average number of steps computing forward propagation. mean_wall_time_fwd_prop_compute : float; Mean average time to compute forward propagation. num_onwd_prop_step_computes : integer; Total number of steps (matrix product) computing onward propagation. mean_num_onwd_prop_step_computes_per_update : float; Mean average number of steps computing onward",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:10550,Deployability,update,update,10550,"_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total number of steps (matrix product) computing forward propagation. mean_num_fwd_prop_step_computes_per_update : float; Mean average number of steps computing forward propagation. mean_wall_time_fwd_prop_compute : float; Mean average time to compute forward propagation. num_onwd_prop_step_computes : integer; Total number of steps (matrix product) computing onward propagation. mean_num_onwd_prop_step_computes_per_update : float; Mean average number of steps computing onward propagation. mean_wall_time_onwd_prop_compute; Mean average time to compute onward propagation; """""". def __init__(self):; self.reset(). def reset(self):; Stats.reset(self); # Dynamics generators (Hamiltonians); self.num_dyn_gen_computes = 0; self.mean_num_dyn_gen_computes_per_update = 0.0; self.mean_wall_time_dyn_gen_compute = 0.",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:13552,Deployability,update,update,13552,"_step_computes /; float(self.num_ctrl_amp_updates)). self.mean_wall_time_fwd_prop_compute = \; (self.wall_time_fwd_prop_compute /; float(self.num_fwd_prop_step_computes)). self.mean_num_onwd_prop_step_computes_per_update = \; (self.num_onwd_prop_step_computes /; float(self.num_ctrl_amp_updates)). self.mean_wall_time_onwd_prop_compute = \; (self.wall_time_onwd_prop_compute /; float(self.num_onwd_prop_step_computes)). def report(self):; """"""; Print a report of the stats to the console; """""". print(""\n------------------------------------""; ""\n---- Control optimisation stats ----""); self.report_timings(); self.report_func_calls(); self.report_amp_updates(); self.report_dyn_gen_comps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:13937,Deployability,update,update,13937,"t(self.num_onwd_prop_step_computes)). def report(self):; """"""; Print a report of the stats to the console; """""". print(""\n------------------------------------""; ""\n---- Control optimisation stats ----""); self.report_timings(); self.report_func_calls(); self.report_amp_updates(); self.report_dyn_gen_comps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute)). def report_onwd_prop(self):; print(""**** Onward Propagation ****""); print(""Total number of onward propagation step computations: ""; ""{}"".format(self.num_onwd_prop_step_computes)); print(""Mean number of onward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_onwd_prop_step_computes_per_update)); print(""Mean wall time to compute onward propagation ""; ""{",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:14347,Deployability,update,update,14347,"elf.report_amp_updates(); self.report_dyn_gen_comps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute)). def report_onwd_prop(self):; print(""**** Onward Propagation ****""); print(""Total number of onward propagation step computations: ""; ""{}"".format(self.num_onwd_prop_step_computes)); print(""Mean number of onward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_onwd_prop_step_computes_per_update)); print(""Mean wall time to compute onward propagation ""; ""{} s"".format(self.mean_wall_time_onwd_prop_compute)).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:14778,Deployability,update,update,14778,"elf.report_amp_updates(); self.report_dyn_gen_comps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute)). def report_onwd_prop(self):; print(""**** Onward Propagation ****""); print(""Total number of onward propagation step computations: ""; ""{}"".format(self.num_onwd_prop_step_computes)); print(""Mean number of onward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_onwd_prop_step_computes_per_update)); print(""Mean wall time to compute onward propagation ""; ""{} s"".format(self.mean_wall_time_onwd_prop_compute)).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:15073,Deployability,update,updated,15073,"elf.report_amp_updates(); self.report_dyn_gen_comps(); self.report_fwd_prop(); self.report_onwd_prop(); print(""------------------------------------""). def report_dyn_gen_comps(self):; print(""**** {} Computations ****"".format(self.dyn_gen_name)); print(""Total number of {} computations: ""; ""{}"".format(self.dyn_gen_name, self.num_dyn_gen_computes)); print(""Mean number of {} computations per update: ""; ""{}"".format(self.dyn_gen_name,; self.mean_num_dyn_gen_computes_per_update)); print(""Mean wall time to compute {}s: ""; ""{} s"".format(self.dyn_gen_name,; self.mean_wall_time_dyn_gen_compute)); print(""**** Propagator Computations ****""); print(""Total number of propagator computations: ""; ""{}"".format(self.num_prop_computes)); print(""Mean number of propagator computations per update: ""; ""{}"".format(self.mean_num_prop_computes_per_update)); print(""Mean wall time to compute propagator ""; ""{} s"".format(self.mean_wall_time_prop_compute)). def report_fwd_prop(self):; print(""**** Forward Propagation ****""); print(""Total number of forward propagation step computations: ""; ""{}"".format(self.num_fwd_prop_step_computes)); print(""Mean number of forward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_fwd_prop_step_computes_per_update)); print(""Mean wall time to compute forward propagation ""; ""{} s"".format(self.mean_wall_time_fwd_prop_compute)). def report_onwd_prop(self):; print(""**** Onward Propagation ****""); print(""Total number of onward propagation step computations: ""; ""{}"".format(self.num_onwd_prop_step_computes)); print(""Mean number of onward propagation step computations""; "" per update: ""; ""{}"".format(self.mean_num_onwd_prop_step_computes_per_update)); print(""Mean wall time to compute onward propagation ""; ""{} s"".format(self.mean_wall_time_onwd_prop_compute)).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:2517,Modifiability,config,configurations,2517,"CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_ti",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:9696,Modifiability,config,configurations,9696,"of gradient function calls: ""; ""{}"".format(self.num_grad_func_calls)); print(""Number of times gradients are computed: ""; ""{}"".format(self.num_grad_computes)); print(""Number of times timeslot evolution is recomputed: ""; ""{}"".format(self.num_tslot_recompute)); print(""""). def report_amp_updates(self):; print(""**** Control amplitudes ****""); print(""Number of control amplitude updates: ""; ""{}"".format(self.num_ctrl_amp_updates)); print(""Mean number of updates per iteration: ""; ""{}"".format(self.mean_num_ctrl_amp_updates_per_iter)); print(""Number of timeslot values changed: ""; ""{}"".format(self.num_timeslot_changes)); print(""Mean number of timeslot changes per update: ""; ""{}"".format(self.mean_num_timeslot_changes_per_update)); print(""Number of amplitude values changed: ""; ""{}"".format(self.num_ctrl_amp_changes)); print(""Mean number of amplitude changes per update: ""; ""{}"".format(self.mean_num_ctrl_amp_changes_per_update)). class StatsDynTsUpdate(Stats):; """"""; Optimisation stats class for configurations where all timeslots are not; necessarily updated at each iteration. In this case it may be interesting; to know how many Hamiltions etc are computed each ctrl amplitude update. Attributes; ----------; num_dyn_gen_computes : integer; Total number of dynamics generator (Hamiltonian) computations,; that is combining drift and control dynamics to calculate the; combined dynamics generator for the timeslot. mean_num_dyn_gen_computes_per_update : float; # Mean average number of dynamics generator computations per update. mean_wall_time_dyn_gen_compute : float; # Mean average time to compute a timeslot dynamics generator. num_prop_computes : integer; Total number of propagator (and propagator gradient for exact; gradient types) computations. mean_num_prop_computes_per_update : float; Mean average number of propagator computations per update. mean_wall_time_prop_compute : float; Mean average time to compute a propagator (and its gradient). num_fwd_prop_step_computes : integer; Total num",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:2324,Safety,redund,redundant,2324," BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (el",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:2849,Usability,simpl,simply,2849,"CT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Statistics for the optimisation; Note that some of the stats here are redundant copies from the optimiser; used here for calculations; """"""; import numpy as np; import datetime. [docs]class Stats(object):; """"""; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes; ----------; dyn_gen_name : string; Text used in some report functions.; Makes sense to set it to 'Hamiltonian' when using unitary dynamics; Default is simply 'dynamics generator'. num_iter : integer; Number of iterations of the optimisation algorithm. wall_time_optim_start : float; Start time for the optimisation. wall_time_optim_end : float; End time for the optimisation. wall_time_optim : float; Time elasped during the optimisation. wall_time_dyn_gen_compute : float; Total wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_compute : float; Total wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_compute : float; Total wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating the propagators themselves. wall_time_onwd_prop_compute : float; Total wall (elasped) time computing combined onward propagation,; th",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:5478,Usability,clear,clear,5478,"ity_computes : integer; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; self.num_fidelity_func_calls = 0; self.num_grad_func_calls = 0; self.num_tslot_recompute = 0; self.num_fidelity_computes = 0; self.num_grad_computes = 0; # Control amplitudes; self.num_ctrl_amp_updates = 0; self.mean_num_ctrl_amp_updates_per_iter = 0.0; self.num_timeslot_changes = 0; self.mean_num_timeslot_changes_per_update = 0.0; self.num_ctrl_amp_changes = 0; self.mean_num_ctrl_amp_changes_per_update = 0.0. [docs] def calculate(self):; """"""; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report; """"""; # If the optimation is still ru",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/stats.html:5491,Usability,clear,clear,5491,"nteger; Number of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computes : integer; Number of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updates : integer; Number of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iter : float; Mean number of control amplitude updates per iteration. num_timeslot_changes : integer; Number of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_update : float; Mean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changes : integer; Number of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_update : float; Mean average number of control amplitudes that are changed per update; """"""; def __init__(self):; self.reset(). def reset(self):; self.dyn_gen_name = ""dynamics generator""; self.clear(). def clear(self):; self.num_iter = 0; # Duration attributes; self.wall_time_optim_start = 0.0; self.wall_time_optim_end = 0.0; self.wall_time_optim = 0.0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; self.wall_time_gradient_compute = 0.0; # Fidelity and gradient function calls and computes; self.num_fidelity_func_calls = 0; self.num_grad_func_calls = 0; self.num_tslot_recompute = 0; self.num_fidelity_computes = 0; self.num_grad_computes = 0; # Control amplitudes; self.num_ctrl_amp_updates = 0; self.mean_num_ctrl_amp_updates_per_iter = 0.0; self.num_timeslot_changes = 0; self.mean_num_timeslot_changes_per_update = 0.0; self.num_ctrl_amp_changes = 0; self.mean_num_ctrl_amp_changes_per_update = 0.0. [docs] def calculate(self):; """"""; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report; """"""; # If the optimation is still running then the o",MatchSource.WIKI,docs/4.3/modules/qutip/control/stats.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/stats.html
https://qutip.org/docs/4.3/modules/qutip/control/termcond.html:2789,Availability,error,error,2789,"ON) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(se",MatchSource.WIKI,docs/4.3/modules/qutip/control/termcond.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/termcond.html
https://qutip.org/docs/4.3/modules/qutip/control/termcond.html:4046,Deployability,update,updated,4046,"1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(self):; self.fid_err_targ = 1e-5; self.fid_goal = None; self.max_wall_time = 60*60.0; self.min_gradient_norm = 1e-5; self.max_iterations = 1e10; self.max_fid_func_calls = 1e10.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/control/termcond.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/termcond.html
https://qutip.org/docs/4.3/modules/qutip/control/termcond.html:3456,Performance,optimiz,optimize,3456,"1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Classes containing termination conditions for the control pulse optimisation; i.e. attributes that will be checked during the optimisation, that; will determine if the algorithm has completed its task / exceeded limits; """""". [docs]class TerminationConditions(object):; """"""; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes; ----------; fid_err_targ : float; Target fidelity error. fid_goal : float; goal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_time : float; # maximum time for optimisation (seconds). min_gradient_norm : float; Minimum normalised gradient after which optimisation will terminate. max_iterations : integer; Maximum iterations of the optimisation algorithm. max_fid_func_calls : integer; Maximum number of calls to the fidelity function during; the optimisation algorithm; ; accuracy_factor : float; Determines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user; """"""; def __init__(self):; self.reset(). def reset(self):; self.fid_err_targ = 1e-5; self.fid_goal = None; self.max_wall_time = 60*60.0; self.min_gradient_norm = 1e-5; self.max_iterations = 1e10; self.max_fid_func_calls = 1e10.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/control/termcond.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/termcond.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:3624,Availability,error,errors,3624,"; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP sett",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:3634,Availability,error,errors,3634,"; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP sett",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:14206,Availability,mask,masks,14206,"inal; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts, dtype=bool); self.evo_init2t_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_init2t_recalc[0] = False; self.evo_t2targ_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_t2targ_recalc[-1] = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find firs",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:20388,Availability,error,errors,20388,"w.sum(); dyn.stats.wall_time_onwd_prop_compute += \; timeit.default_timer() - time_start. # Clear calc now flags; self.dyn_gen_calc_now[:] = False; self.prop_calc_now[:] = False; self.evo_init2t_calc_now[:] = False; self.evo_t2targ_calc_now[:] = False. def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value. Attempts to find a timeslot where the least number of propagator; calculations will be required.; Flags the associated evolution operators for calculation now; """"""; dyn = self.parent; n_ts = dyn.num_tslots; kBothEvoCurrent = -1; kFwdEvoCurrent = -1; kUse = -1; # If no specific timeslot set in config, then determine dynamically; if kUse < 0:; for k in range(n_ts):; # find first timeslot where both evo_init2t and; # evo_t2targ are current; if not self.evo_init2t_recalc[k]:; kFwdEvoCurrent = k; if not self.evo_t2targ_recalc[k]:; kBothEvoCurrent = k; break. if kBothEvoCurrent >= 0:; kUse = kBothEvoCurrent; elif kFwdEvoCurrent >= 0:; kUse = kFwdEvoCurrent; else:; raise errors.FunctionalError(""No timeslot found matching ""; ""criteria""). self.evo_init2t_calc_now[kUse] = True; self.evo_t2targ_calc_now[kUse] = True; return kUse. class EvoCompSummary(qtrldump.DumpSummaryItem):; """"""; A summary of the most recent time evolution computation; Used in stats calculations and for data dumping; ; Attributes; ----------; evo_dump_idx : int; Index of the linked :class:`dump.EvoCompDumpItem`; None if no linked item; ; iter_num : int; Iteration number of the pulse optimisation; None if evolution compute outside of a pulse optimisation; ; fid_func_call_num : int; Fidelity function call number of the pulse optimisation; None if evolution compute outside of a pulse optimisation; ; grad_func_call_num : int; Gradient function call number of the pulse optimisation; None if evolution compute outside of a pulse optimisation; ; num_amps_changed : int; Number of control timeslot amplitudes changed since previous; evolution ca",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:2415,Deployability,update,update,2415,"INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods ",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:2519,Deployability,update,updates,2519,"NDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from ",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:2549,Deployability,update,update,2549,"NDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from ",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:2781,Deployability,update,updated,2781,"; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Alexander Pitchford; # @email1: agp1@aber.ac.uk; # @email2: alex.pitchford@gmail.com; # @organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(mes",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:3180,Deployability,update,update,3180,"organization: Aberystwyth University; # @supervisor: Daniel Burgarth. """"""; Timeslot Computer; These classes determine which dynamics generators, propagators and evolutions; are recalculated when there is a control amplitude update.; The timeslot computer processes the lists held by the dynamics object. The default (UpdateAll) updates all of these each amp update, on the; assumption that all amplitudes are changed each iteration. This is typical; when using optimisation methods like BFGS in the GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the da",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:6805,Deployability,update,updated,6805,"def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gr",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:8099,Deployability,update,update,8099,"they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_r",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:12613,Deployability,update,updated,12613,"itarity_check_level:; dyn.check_unitarity(); ; if dyn.dump:; self.dump_current(). [docs] def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; _func_deprecation(""'get_timeslot_for_fidelity_calc' is deprecated. ""; ""Use '_get_timeslot_for_fidelity_calc'""); return self._get_timeslot_for_fidelity_calc. def _get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_recalc = None; self.dyn_gen_calc_now = None; self.prop_calc_now = None; self.evo_init2t_calc_now = None; self.evo_t2targ_calc_now = None; TimeslotComputer.reset(self); self.id_text = 'DYNAMIC'; self.apply_params(). def init_comp(self):; """"""; Initialise the flags; """"""; ####; # These maps are used to determine what needs to be updated; ####; # Note _recalc means the value needs updating at some point; # e.g. here no values have been set, except the initial and final; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:12628,Deployability,update,update,12628,"""""""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; _func_deprecation(""'get_timeslot_for_fidelity_calc' is deprecated. ""; ""Use '_get_timeslot_for_fidelity_calc'""); return self._get_timeslot_for_fidelity_calc. def _get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_recalc = None; self.dyn_gen_calc_now = None; self.prop_calc_now = None; self.evo_init2t_calc_now = None; self.evo_t2targ_calc_now = None; TimeslotComputer.reset(self); self.id_text = 'DYNAMIC'; self.apply_params(). def init_comp(self):; """"""; Initialise the flags; """"""; ####; # These maps are used to determine what needs to be updated; ####; # Note _recalc means the value needs updating at some point; # e.g. here no values have been set, except the initial and final; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts, dtype=bool); self.evo_init2t_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_init2t_recalc[0] = False; self.evo_t2targ_recalc = n",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:13116,Deployability,update,updated,13116,"imply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_recalc = None; self.dyn_gen_calc_now = None; self.prop_calc_now = None; self.evo_init2t_calc_now = None; self.evo_t2targ_calc_now = None; TimeslotComputer.reset(self); self.id_text = 'DYNAMIC'; self.apply_params(). def init_comp(self):; """"""; Initialise the flags; """"""; ####; # These maps are used to determine what needs to be updated; ####; # Note _recalc means the value needs updating at some point; # e.g. here no values have been set, except the initial and final; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts, dtype=bool); self.evo_init2t_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_init2t_recalc[0] = False; self.evo_t2targ_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_t2targ_recalc[-1] = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:14280,Deployability,update,update,14280,"inal; # evolution operator vals (which never change) and hence all other; # values are set as requiring calculation.; n_ts = self.parent.num_tslots; self.dyn_gen_recalc = np.ones(n_ts, dtype=bool); # np.ones(n_ts, dtype=bool); self.prop_recalc = np.ones(n_ts, dtype=bool); self.evo_init2t_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_init2t_recalc[0] = False; self.evo_t2targ_recalc = np.ones(n_ts + 1, dtype=bool); self.evo_t2targ_recalc[-1] = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find firs",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:15231,Deployability,update,updated,15231," are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalcula",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:15758,Deployability,update,update,15758,"changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_ca",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:16687,Deployability,update,update,16687,"adients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now = (evo_init2t_recomp_now[1:]; | evo_t2targ_recomp_now[:-1]; | self.prop_calc_now[:]) & self.prop_recalc[:]; dyn_gen_recomp_now = (prop_recomp_now[:] | self.dyn_gen_calc_now[:]) \; & self.dyn_gen_r",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:23072,Deployability,update,updated,23072,"e optimisation; None if evolution compute outside of a pulse optimisation; ; num_amps_changed : int; Number of control timeslot amplitudes changed since previous; evolution calculation; ; num_timeslots_changed : int; Number of timeslots in which any amplitudes changed since previous; evolution calculation; ; wall_time_dyn_gen_compute : float; Time spent computing dynamics generators; (in seconds of elapsed time); ; wall_time_prop_compute : float; Time spent computing propagators (including and propagator gradients); (in seconds of elapsed time); ; wall_time_fwd_prop_compute : float; Time spent computing the forward evolution of the system; see :property:`dynamics.fwd_evo` ; (in seconds of elapsed time); ; wall_time_onwd_prop_compute : float; Time spent computing the 'backward' evolution of the system; see :property:`dynamics.onwd_evo` and :property:`dynamics.onto_evo`; (in seconds of elapsed time); """"""; ; min_col_width = 11; summary_property_names = (; ""idx"", ""evo_dump_idx"", ; ""iter_num"", ""fid_func_call_num"", ""grad_func_call_num"",; ""num_amps_changed"", ""num_timeslots_changed"",; ""wall_time_dyn_gen_compute"", ""wall_time_prop_compute"",; ""wall_time_fwd_prop_compute"", ""wall_time_onwd_prop_compute""); ; summary_property_fmt_type = (; 'd', 'd',; 'd', 'd', 'd',; 'd', 'd',; 'g', 'g', ; 'g', 'g'; ); ; summary_property_fmt_prec = (; 0, 0, ; 0, 0, 0,; 0, 0, ; 3, 3,; 3, 3; ); ; def __init__(self):; self.reset(); ; def reset(self):; qtrldump.DumpSummaryItem.reset(self); self.evo_dump_idx = None; self.iter_num = None; self.fid_func_call_num = None; self.grad_func_call_num = None; self.num_amps_changed = 0; self.num_timeslots_changed = 0; self.wall_time_dyn_gen_compute = 0.0; self.wall_time_prop_compute = 0.0; self.wall_time_fwd_prop_compute = 0.0; self.wall_time_onwd_prop_compute = 0.0; .  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:3790,Integrability,message,message,3790,"ns accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init_",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:3878,Integrability,message,message,3878,"ns accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init_",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:3966,Integrability,message,message,3966,"sed for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init__(self, dynamics, params=None):; from qutip.control.dynamics import Dynamics; if not isinstance(dynamics, Dynamics):; raise Ty",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:6619,Modifiability,config,config,6619,"if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # Tru",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:20009,Modifiability,config,config,20009,"mer(); # compute the onward propagation; R = range(n_ts-1, -1, -1); for k in R:; if evo_t2targ_recomp_now[k]:; dyn.evo_t2targ[k] = dyn.evo_t2targ[k+1].dot(dyn.prop[k]); self.evo_t2targ_recalc[k] = False; if dyn.stats is not None:; dyn.stats.num_onwd_prop_step_computes += \; evo_t2targ_recomp_now.sum(); dyn.stats.wall_time_onwd_prop_compute += \; timeit.default_timer() - time_start. # Clear calc now flags; self.dyn_gen_calc_now[:] = False; self.prop_calc_now[:] = False; self.evo_init2t_calc_now[:] = False; self.evo_t2targ_calc_now[:] = False. def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value. Attempts to find a timeslot where the least number of propagator; calculations will be required.; Flags the associated evolution operators for calculation now; """"""; dyn = self.parent; n_ts = dyn.num_tslots; kBothEvoCurrent = -1; kFwdEvoCurrent = -1; kUse = -1; # If no specific timeslot set in config, then determine dynamically; if kUse < 0:; for k in range(n_ts):; # find first timeslot where both evo_init2t and; # evo_t2targ are current; if not self.evo_init2t_recalc[k]:; kFwdEvoCurrent = k; if not self.evo_t2targ_recalc[k]:; kBothEvoCurrent = k; break. if kBothEvoCurrent >= 0:; kUse = kBothEvoCurrent; elif kFwdEvoCurrent >= 0:; kUse = kFwdEvoCurrent; else:; raise errors.FunctionalError(""No timeslot found matching ""; ""criteria""). self.evo_init2t_calc_now[kUse] = True; self.evo_t2targ_calc_now[kUse] = True; return kUse. class EvoCompSummary(qtrldump.DumpSummaryItem):; """"""; A summary of the most recent time evolution computation; Used in stats calculations and for data dumping; ; Attributes; ----------; evo_dump_idx : int; Index of the linked :class:`dump.EvoCompDumpItem`; None if no linked item; ; iter_num : int; Iteration number of the pulse optimisation; None if evolution compute outside of a pulse optimisation; ; fid_func_call_num : int; Fidelity function call number of the pulse optimisation; None if ",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:8758,Security,access,access,8758,"ity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:3689,Testability,log,logging,3689,"he GRAPE algorithm. The alternative (DynUpdate) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:3728,Testability,log,logging,3728,"e) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the mo",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:3737,Testability,log,logger,3737,"e) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the mo",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:3746,Testability,log,logging,3746,"e) assumes that only a subset of amplitudes; are updated each iteration and attempts to minimise the number of expensive; calculations accordingly. This would be the appropriate class for Krotov type; methods. Note that the Stats_DynTsUpdate class must be used for stats; in conjunction with this class.; NOTE: AJGP 2011-10-2014: This _DynUpdate class currently has some bug,; no pressing need to fix it presently. If all amplitudes change at each update, then the behavior of the classes is; equivalent. _UpdateAll is easier to understand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the mo",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:4303,Testability,log,logger,4303,"stand and potentially slightly faster; in this situation. Note the methods in the _DynUpdate class were inspired by:; DYNAMO - Dynamic Framework for Quantum Optimal Control; See Machnes et.al., arXiv.1011.4874; """""". import os; import warnings; import numpy as np; import timeit; # QuTiP; from qutip import Qobj; # QuTiP control modules; import qutip.control.errors as errors; import qutip.control.dump as qtrldump; # QuTiP logging; import qutip.logging_utils as logging; logger = logging.get_logger(). def _func_deprecation(message, stacklevel=3):; """"""; Issue deprecation warning; Using stacklevel=3 will ensure message refers the function; calling with the deprecated parameter,; """"""; warnings.warn(message, DeprecationWarning, stacklevel=stacklevel). [docs]class TimeslotComputer(object):; """"""; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes; ----------; log_level : integer; level of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively 'quiet' execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN; ; evo_comp_summary : EvoCompSummary; A summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set; """"""; def __init__(self, dynamics, params=None):; from qutip.control.dynamics import Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:5846,Testability,log,logger,5846,"s or dump are set; """"""; def __init__(self, dynamics, params=None):; from qutip.control.dynamics import Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:5964,Testability,log,logger,5964," Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amp",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:5985,Testability,log,logger,5985," Dynamics; if not isinstance(dynamics, Dynamics):; raise TypeError(""Must instantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amp",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:6012,Testability,log,logger,6012,"nstantiate with {} type"".format(; Dynamics)); self.parent = dynamics; self.params = params; self.reset(). def reset(self):; self.log_level = self.parent.log_level; self.id_text = 'TS_COMP_BASE'; self.evo_comp_summary = None. [docs] def apply_params(self, params=None):; """"""; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, ",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:6562,Testability,log,logger,6562," are created if they do not exist already,; and are overwritten if they do.; """"""; if not params:; params = self.params. if isinstance(params, dict):; self.params = params; for key in params:; setattr(self, key, params[key]). def flag_all_calc_now(self):; pass. def init_comp(self):; pass. @property; def log_level(self):; return logger.level. @log_level.setter; def log_level(self, lvl):; """"""; Set the log_level attribute and set the level of the logger; that is call logger.setLevel(lvl); """"""; logger.setLevel(lvl); ; [docs] def dump_current(self):; """"""Store a copy of the current time evolution""""""; dyn = self.parent; dump = dyn.dump; if not isinstance(dump, qtrldump.DynamicsDump):; raise RuntimeError(""Cannot dump current evolution, ""; ""as dynamics.dump is not set""); ; anything_dumped = False; item_idx = None; if dump.dump_any:; dump_item = dump.add_evo_dump(); item_idx = dump_item.idx; anything_dumped = True; ; if dump.dump_summary:; dump.add_evo_comp_summary(dump_item_idx=item_idx); anything_dumped = True; ; if not anything_dumped:; logger.warning(""Dump set, but nothing dumped, check dump config""); . [docs]class TSlotCompUpdateAll(TimeslotComputer):; """"""; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = n",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:7813,Testability,log,logging,7813,"ed; """"""; def reset(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:7829,Testability,log,logger,7829,"(self):; TimeslotComputer.reset(self); self.id_text = 'ALL'; self.apply_params(). [docs] def compare_amps(self, new_amps):; """"""; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:8038,Testability,log,logging,8038,"eeding recalculation; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs =",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:8054,Testability,log,logger,8054,"on; Returns: True if amplitudes are the same, False if they have changed; """"""; changed = False; dyn = self.parent; ; if (dyn.stats or dyn.dump):; if self.evo_comp_summary:; self.evo_comp_summary.reset(); else:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary; ; if dyn.ctrl_amps is None:; # Flag fidelity and gradients as needing recalculation; changed = True; if ecs:; ecs.num_amps_changed = len(new_amps.flat); ecs.num_timeslots_changed = new_amps.shape[0]; else:; # create boolean array with same shape as ctrl_amps; # True where value in new_amps differs, otherwise false; changed_amps = dyn.ctrl_amps != new_amps; if np.any(changed_amps):; # Flag fidelity and gradients as needing recalculation; changed = True; if self.log_level <= logging.DEBUG:; logger.debug(""{} amplitudes changed"".format(; changed_amps.sum())); ; if ecs:; ecs.num_amps_changed = changed_amps.sum(); ecs.num_timeslots_changed = np.any(changed_amps, 1).sum(). else:; if self.log_level <= logging.DEBUG:; logger.debug(""No amplitudes changed""). # *** update stats ***; if dyn.stats:; dyn.stats.num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_sum",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:9144,Testability,log,logging,9144,".num_ctrl_amp_updates += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:9160,Testability,log,logger,9160,"tes += bool(ecs.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; time",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:9167,Testability,log,log,9167,"s.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_ti",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:9171,Testability,log,logging,9171,"s.num_amps_changed); dyn.stats.num_ctrl_amp_changes += ecs.num_amps_changed; dyn.stats.num_timeslot_changes += ecs.num_timeslots_changed; ; if changed:; dyn.ctrl_amps = new_amps; dyn.flag_system_changed(); return False; else:; return True. [docs] def recompute_evolution(self):; """"""; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary; """""". dyn = self.parent; prop_comp = dyn.prop_computer; n_ts = dyn.num_tslots; n_ctrls = dyn.num_ctrls. # Clear the public lists; # These are only set if (external) users access them; dyn._dyn_gen_qobj = None; dyn._prop_qobj = None; dyn._prop_grad_qobj = None; dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_ti",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:9851,Testability,log,logging,9851,"dyn._fwd_evo_qobj = None; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_timer() - time_start. if ecs: time_start = timeit.default_timer(); # compute the forward propagation; R = range(n_ts); for k in R:; if dyn.oper_dtype == Qobj:; dyn._fwd_evo[k+1] = dyn._prop[k]*dyn._fwd_evo[k]; else:; dyn._fwd_evo[k+1] = dyn._prop[k].dot(dyn._fwd_evo[k]). if ecs:; ecs.wall_time_fwd_prop_compute = \; timeit.default_timer() - time_start; time_start = timeit.default_timer(); # compute the onward propagation; if dyn.fid_computer.uses_onwd_evo:; dyn._onwd_evo[n_ts-1] = dyn._prop[n_ts-1]; R = range(n_ts-2, -1, -1); for k in R:; if dyn.oper_dtype == Qobj:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1]*dyn._prop[k]; else:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1].dot(dyn._",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:9875,Testability,log,logger,9875,"ne; dyn._onwd_evo_qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_timer() - time_start. if ecs: time_start = timeit.default_timer(); # compute the forward propagation; R = range(n_ts); for k in R:; if dyn.oper_dtype == Qobj:; dyn._fwd_evo[k+1] = dyn._prop[k]*dyn._fwd_evo[k]; else:; dyn._fwd_evo[k+1] = dyn._prop[k].dot(dyn._fwd_evo[k]). if ecs:; ecs.wall_time_fwd_prop_compute = \; timeit.default_timer() - time_start; time_start = timeit.default_timer(); # compute the onward propagation; if dyn.fid_computer.uses_onwd_evo:; dyn._onwd_evo[n_ts-1] = dyn._prop[n_ts-1]; R = range(n_ts-2, -1, -1); for k in R:; if dyn.oper_dtype == Qobj:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1]*dyn._prop[k]; else:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1].dot(dyn._prop[k]). if dyn.fid_c",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:9882,Testability,log,log,9882,"qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_timer() - time_start. if ecs: time_start = timeit.default_timer(); # compute the forward propagation; R = range(n_ts); for k in R:; if dyn.oper_dtype == Qobj:; dyn._fwd_evo[k+1] = dyn._prop[k]*dyn._fwd_evo[k]; else:; dyn._fwd_evo[k+1] = dyn._prop[k].dot(dyn._fwd_evo[k]). if ecs:; ecs.wall_time_fwd_prop_compute = \; timeit.default_timer() - time_start; time_start = timeit.default_timer(); # compute the onward propagation; if dyn.fid_computer.uses_onwd_evo:; dyn._onwd_evo[n_ts-1] = dyn._prop[n_ts-1]; R = range(n_ts-2, -1, -1); for k in R:; if dyn.oper_dtype == Qobj:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1]*dyn._prop[k]; else:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1].dot(dyn._prop[k]). if dyn.fid_computer.uses_onto",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:9886,Testability,log,logging,9886,"qobj = None; dyn._onto_evo_qobj = None; ; if (dyn.stats or dyn.dump) and not self.evo_comp_summary:; self.evo_comp_summary = EvoCompSummary(); ecs = self.evo_comp_summary. if dyn.stats is not None:; dyn.stats.num_tslot_recompute += 1; if self.log_level <= logging.DEBUG:; logger.log(logging.DEBUG, ""recomputing evolution {} ""; ""(UpdateAll)"".format(; dyn.stats.num_tslot_recompute)). # calculate the Hamiltonians; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; dyn._combine_dyn_gen(k); if dyn._decomp_curr is not None:; dyn._decomp_curr[k] = False; ; if ecs:; ecs.wall_time_dyn_gen_compute = \; timeit.default_timer() - time_start. # calculate the propagators and the propagotor gradients; if ecs: time_start = timeit.default_timer(); for k in range(n_ts):; if prop_comp.grad_exact and dyn.cache_prop_grad:; for j in range(n_ctrls):; if j == 0:; dyn._prop[k], dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j); if self.log_level <= logging.DEBUG_INTENSE:; logger.log(logging.DEBUG_INTENSE,; ""propagator {}:\n{:10.3g}"".format(; k, self._prop[k])); else:; dyn._prop_grad[k, j] = \; prop_comp._compute_prop_grad(k, j, ; compute_prop=False); else:; dyn._prop[k] = prop_comp._compute_propagator(k); ; if ecs:; ecs.wall_time_prop_compute = \; timeit.default_timer() - time_start. if ecs: time_start = timeit.default_timer(); # compute the forward propagation; R = range(n_ts); for k in R:; if dyn.oper_dtype == Qobj:; dyn._fwd_evo[k+1] = dyn._prop[k]*dyn._fwd_evo[k]; else:; dyn._fwd_evo[k+1] = dyn._prop[k].dot(dyn._fwd_evo[k]). if ecs:; ecs.wall_time_fwd_prop_compute = \; timeit.default_timer() - time_start; time_start = timeit.default_timer(); # compute the onward propagation; if dyn.fid_computer.uses_onwd_evo:; dyn._onwd_evo[n_ts-1] = dyn._prop[n_ts-1]; R = range(n_ts-2, -1, -1); for k in R:; if dyn.oper_dtype == Qobj:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1]*dyn._prop[k]; else:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1].dot(dyn._prop[k]). if dyn.fid_computer.uses_onto",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:14680,Testability,log,logging,14680,".evo_t2targ_recalc[-1] = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fi",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:14704,Testability,log,logger,14704," = False. # The _calc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients a",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:14711,Testability,log,log,14711,"alc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalcu",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:14715,Testability,log,logging,14715,"alc_now map is used to during the calcs to specify; # which values need updating immediately; self.dyn_gen_calc_now = np.zeros(n_ts, dtype=bool); self.prop_calc_now = np.zeros(n_ts, dtype=bool); self.evo_init2t_calc_now = np.zeros(n_ts + 1, dtype=bool); self.evo_t2targ_calc_now = np.zeros(n_ts + 1, dtype=bool). def compare_amps(self, new_amps):; """"""; Determine which timeslots will have changed Hamiltonians; i.e. any where control amplitudes have changed for that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalcu",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:15182,Testability,log,logging,15182,"that slot; and mark (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_n",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:15198,Testability,log,logger,15198,"k (using masks) them and corresponding exponentiations and; time evo operators for update; Returns: True if amplitudes are the same, False if they have changed; """"""; dyn = self.parent; n_ts = dyn.num_tslots; # create boolean array with same shape as ctrl_amps; # True where value in New_amps differs, otherwise false; if self.parent.ctrl_amps is None:; changed_amps = np.ones(new_amps.shape, dtype=bool); else:; changed_amps = self.parent.ctrl_amps != new_amps. if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""changed_amps:\n{}"".format(; changed_amps)); # create Boolean vector with same length as number of timeslots; # True where any of the amplitudes have changed, otherwise false; changed_ts_mask = np.any(changed_amps, 1); # if any of the amplidudes have changed then mark for recalc; if np.any(changed_ts_mask):; self.dyn_gen_recalc[changed_ts_mask] = True; self.prop_recalc[changed_ts_mask] = True; dyn.ctrl_amps = new_amps; if self.log_level <= logging.DEBUG:; logger.debug(""Control amplitudes updated""); # find first and last changed dynamics generators; first_changed = None; for i in range(n_ts):; if changed_ts_mask[i]:; last_changed = i; if first_changed is None:; first_changed = i. # set all fwd evo ops after first changed Ham to be recalculated; self.evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:16499,Testability,log,logging,16499,".evo_init2t_recalc[first_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now =",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:16523,Testability,log,logger,16523,"st_changed + 1:] = True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now = (evo_init2t_recomp_no",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:16530,Testability,log,log,16530," True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now = (evo_init2t_recomp_now[1:]; | evo_t2ta",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:16534,Testability,log,logging,16534," True; # set all bkwd evo ops up to (incl) last changed Ham to be; # recalculated; self.evo_t2targ_recalc[:last_changed + 1] = True. # Flag fidelity and gradients as needing recalculation; dyn.flag_system_changed(). # *** update stats ***; if dyn.stats is not None:; dyn.stats.num_ctrl_amp_updates += 1; dyn.stats.num_ctrl_amp_changes += changed_amps.sum(); dyn.stats.num_timeslot_changes += changed_ts_mask.sum(). return False; else:; return True. def flag_all_calc_now(self):; """"""; Flags all Hamiltonians, propagators and propagations to be; calculated now; """"""; # set flags for calculations; self.dyn_gen_calc_now[:] = True; self.prop_calc_now[:] = True; self.evo_init2t_calc_now[:-1] = True; self.evo_t2targ_calc_now[1:] = True. def recompute_evolution(self):; """"""; Recalculates the evo_init2t (forward) and evo_t2targ (onward) time; evolution operators; DynGen (Hamiltonians etc) and prop (propagator) are calculated; as necessary; """"""; if self.log_level <= logging.DEBUG_VERBOSE:; logger.log(logging.DEBUG_VERBOSE, ""recomputing evolution ""; ""(DynUpdate)""). dyn = self.parent; n_ts = dyn.num_tslots; # find the op slots that have been marked for update now; # and need recalculation; evo_init2t_recomp_now = self.evo_init2t_calc_now & \; self.evo_init2t_recalc; evo_t2targ_recomp_now = self.evo_t2targ_calc_now & \; self.evo_t2targ_recalc. # to recomupte evo_init2t, will need to start; # at a cell that has been computed; if np.any(evo_init2t_recomp_now):; for k in range(n_ts, 0, -1):; if evo_init2t_recomp_now[k] and self.evo_init2t_recalc[k-1]:; evo_init2t_recomp_now[k-1] = True. # for evo_t2targ, will also need to start; # at a cell that has been computed; if np.any(evo_t2targ_recomp_now):; for k in range(0, n_ts):; if evo_t2targ_recomp_now[k] and self.evo_t2targ_recalc[k+1]:; evo_t2targ_recomp_now[k+1] = True. # determine which dyn gen and prop need recalculating now in order to; # calculate the forwrd and onward evolutions; prop_recomp_now = (evo_init2t_recomp_now[1:]; | evo_t2ta",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:11750,Usability,simpl,simply,11750,"[k]; else:; dyn._onwd_evo[k] = dyn._onwd_evo[k+1].dot(dyn._prop[k]). if dyn.fid_computer.uses_onto_evo:; #R = range(n_ts-1, -1, -1); R = range(n_ts-1, -1, -1); for k in R:; if dyn.oper_dtype == Qobj:; dyn._onto_evo[k] = dyn._onto_evo[k+1]*dyn._prop[k]; else:; dyn._onto_evo[k] = dyn._onto_evo[k+1].dot(dyn._prop[k]). if ecs:; ecs.wall_time_onwd_prop_compute = \; timeit.default_timer() - time_start; ; if dyn.stats:; dyn.stats.wall_time_dyn_gen_compute += \; ecs.wall_time_dyn_gen_compute; dyn.stats.wall_time_prop_compute += \; ecs.wall_time_prop_compute; dyn.stats.wall_time_fwd_prop_compute += \; ecs.wall_time_fwd_prop_compute; dyn.stats.wall_time_onwd_prop_compute += \; ecs.wall_time_onwd_prop_compute; ; if dyn.unitarity_check_level:; dyn.check_unitarity(); ; if dyn.dump:; self.dump_current(). [docs] def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; _func_deprecation(""'get_timeslot_for_fidelity_calc' is deprecated. ""; ""Use '_get_timeslot_for_fidelity_calc'""); return self._get_timeslot_for_fidelity_calc. def _get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_re",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html:12098,Usability,simpl,simply,12098,"cs:; ecs.wall_time_onwd_prop_compute = \; timeit.default_timer() - time_start; ; if dyn.stats:; dyn.stats.wall_time_dyn_gen_compute += \; ecs.wall_time_dyn_gen_compute; dyn.stats.wall_time_prop_compute += \; ecs.wall_time_prop_compute; dyn.stats.wall_time_fwd_prop_compute += \; ecs.wall_time_fwd_prop_compute; dyn.stats.wall_time_onwd_prop_compute += \; ecs.wall_time_onwd_prop_compute; ; if dyn.unitarity_check_level:; dyn.check_unitarity(); ; if dyn.dump:; self.dump_current(). [docs] def get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; _func_deprecation(""'get_timeslot_for_fidelity_calc' is deprecated. ""; ""Use '_get_timeslot_for_fidelity_calc'""); return self._get_timeslot_for_fidelity_calc. def _get_timeslot_for_fidelity_calc(self):; """"""; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot; """"""; return self.parent.num_tslots. class TSlotCompDynUpdate(TimeslotComputer):; """"""; Timeslot Computer - Dynamic Update; ********************************; ***** CURRENTLY HAS ISSUES *****; ***** AJGP 2014-10-02; ***** and is therefore not being maintained; ***** i.e. changes made to _UpdateAll are not being implemented here; ********************************; Updates only the dynamics generators, propagators and evolutions as; required when a subset of the ctrl amplitudes are updated.; Will update all if all amps have changed.; """""". def reset(self):; self.dyn_gen_recalc = None; self.prop_recalc = None; self.evo_init2t_recalc = None; self.evo_t2targ_recalc = None; self.dyn_gen_calc_now = None; self.prop_calc_now = None; self.evo_init2t_calc_now = None; self.evo_t2targ_calc_now = None; TimeslotComputer.reset(self); self.id_text = 'DYNAMIC'; self.apply_params(). def init_comp(self):; """"""; Initialise the flags; """"""; ####; # These maps are used to determine what needs to",MatchSource.WIKI,docs/4.3/modules/qutip/control/tslotcomp.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/control/tslotcomp.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:2454,Deployability,integrat,integrate,2454,"OSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides exact solvers for a system-bath setup using the; hierarchy equations of motion (HEOM).; """""". # Authors: Neill Lambert, Anubhav Vardhan, Alexander Pitchford; # Contact: nwlambert@gmail.com. import timeit; import numpy as np; #from scipy.misc import factorial; import scipy.sparse as sp; import scipy.integrate; from copy import copy; from qutip import Qobj, qeye; from qutip.states import enr_state_dictionaries; from qutip.superoperator import liouvillian, spre, spost; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.solver import Options, Result, Stats; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.heom import cy_pad_csr; from qutip.cy.spmath import zcsr_kron; from qutip.fastsparse import fast_csr_matrix, fast_identity. [docs]class HEOMSolver(object):; """"""; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentia",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:7390,Deployability,integrat,integrate,7390,"ar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; re",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:13391,Deployability,integrat,integrate,13391,"he; N_he_interact += 1. he_state_neigh[k] = n_k. if n_excite <= N_c - 1:; # find the hierarchy element index of the neighbour after; # this element, for this Matsubara term; he_state_neigh[k] = n_k + 1; he_idx_neigh = he2idx[tuple(he_state_neigh)]. op = commQ; if renorm:; op = -1j*norm_plus[n_k, k]*op; else:; op = -1j*op. L_he = cy_pad_csr(op, N_he, N_he, he_idx, he_idx_neigh); L_helems += L_he; N_he_interact += 1. he_state_neigh[k] = n_k. if stats:; stats.add_timing('hierarchy contruct',; timeit.default_timer() - start_helem_constr,; ss_conf); stats.add_count('Num hierarchy elements', N_he, ss_conf); stats.add_count('Num he interactions', N_he_interact, ss_conf). # Setup Liouvillian; if stats: ; start_louvillian = timeit.default_timer(); ; H_he = zcsr_kron(unit_helems, liouvillian(H_sys).data). L_helems += H_he. if stats:; stats.add_timing('Liouvillian contruct',; timeit.default_timer() - start_louvillian,; ss_conf). if stats: start_integ_conf = timeit.default_timer(). r = scipy.integrate.ode(cy_ode_rhs). r.set_f_params(L_helems.data, L_helems.indices, L_helems.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """"""",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:15465,Deployability,integrat,integrate,15465,".stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_integ, ss_run); if ss_run.total_time is None:; ss_run.total_time = time_now - start_run; else:; ss_run.total_time += time_now - start_run; stats.total_time = ss_conf.total_time + ss_run.total_time. return output. def _calc_matsubara_params(self):; """"""; Calculate the Matsubara coefficents and frequencies. Returns; -------; c, nu: both list(float). """"""; c = []; nu = []; lam0 = self.coup_strength; gam = self.cut_freq; hbar = self.planck; beta = 1.0/(self.boltzmann*self.temperature); N_m = self.N_exp. g = 2*np.pi / (beta*hbar); for k in range(N_m):; if k == 0:; nu.append(gam); c.append(lam0*gam*; (1.0/np.tan(gam*hbar*beta/2.0) - 1j) / hbar); else:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:15647,Deployability,integrat,integrate,15647,"meError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_integ, ss_run); if ss_run.total_time is None:; ss_run.total_time = time_now - start_run; else:; ss_run.total_time += time_now - start_run; stats.total_time = ss_conf.total_time + ss_run.total_time. return output. def _calc_matsubara_params(self):; """"""; Calculate the Matsubara coefficents and frequencies. Returns; -------; c, nu: both list(float). """"""; c = []; nu = []; lam0 = self.coup_strength; gam = self.cut_freq; hbar = self.planck; beta = 1.0/(self.boltzmann*self.temperature); N_m = self.N_exp. g = 2*np.pi / (beta*hbar); for k in range(N_m):; if k == 0:; nu.append(gam); c.append(lam0*gam*; (1.0/np.tan(gam*hbar*beta/2.0) - 1j) / hbar); else:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _calc_renorm_factors(self):; """"""; Calculate the renormalisation factors. Returns; -------; norm_plus, norm_minus : array[N_c, N_m] of float; """"""; c = self.exp_coeff; N_m = self.N_exp; N_c = self.N_cu",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:18726,Deployability,update,updated,18726,"rt(abs(c[k])*(n + 1)); norm_minus[n, k] = np.sqrt(float(n)/abs(c[k])). return norm_plus, norm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_scale - 1)*nrowin),; A.indptr)); elif insertrow > 0 and insertrow < row_scale - 1:; A.indptr = np.concatenate((np.array([0]*insertrow*nrowin), A.indptr,; np.array([A.indptr[-1]]*(row_scale - insertrow - 1)*nrowin))); else:; raise ValueError(""insertrow must be >= 0 and < row_scale""). return A.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:4418,Energy Efficiency,reduce,reduced,4418,"he bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve). This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate. There are opportunities to develop a more general spectral density code. Attributes; ----------; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann's constant. options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example HSolverDL""). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; self.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_c",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:17329,Energy Efficiency,efficient,efficient,17329,"se:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _calc_renorm_factors(self):; """"""; Calculate the renormalisation factors. Returns; -------; norm_plus, norm_minus : array[N_c, N_m] of float; """"""; c = self.exp_coeff; N_m = self.N_exp; N_c = self.N_cut. norm_plus = np.empty((N_c+1, N_m)); norm_minus = np.empty((N_c+1, N_m)); for k in range(N_m):; for n in range(N_c+1):; norm_plus[n, k] = np.sqrt(abs(c[k])*(n + 1)); norm_minus[n, k] = np.sqrt(float(n)/abs(c[k])). return norm_plus, norm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_sca",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:17636,Energy Efficiency,efficient,efficient,17636,"ut. norm_plus = np.empty((N_c+1, N_m)); norm_minus = np.empty((N_c+1, N_m)); for k in range(N_m):; for n in range(N_c+1):; norm_plus[n, k] = np.sqrt(abs(c[k])*(n + 1)); norm_minus[n, k] = np.sqrt(float(n)/abs(c[k])). return norm_plus, norm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_scale - 1)*nrowin),; A.indptr)); elif insertrow > 0 and insertrow < row_scale - 1:; A.indptr = np.concatenate((np.array([0]*insertrow*nrowin), A.indptr,; np.array([A.indptr[-1]]*(row_scale - insertrow - 1)*nrowin))); else:; raise ValueError(""insertrow must be >= 0 and < row_scale""). return A.  Copyright 2011 and later, P.D. Nation, J.R. Johans",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:2454,Integrability,integrat,integrate,2454,"OSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides exact solvers for a system-bath setup using the; hierarchy equations of motion (HEOM).; """""". # Authors: Neill Lambert, Anubhav Vardhan, Alexander Pitchford; # Contact: nwlambert@gmail.com. import timeit; import numpy as np; #from scipy.misc import factorial; import scipy.sparse as sp; import scipy.integrate; from copy import copy; from qutip import Qobj, qeye; from qutip.states import enr_state_dictionaries; from qutip.superoperator import liouvillian, spre, spost; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.solver import Options, Result, Stats; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.heom import cy_pad_csr; from qutip.cy.spmath import zcsr_kron; from qutip.fastsparse import fast_csr_matrix, fast_identity. [docs]class HEOMSolver(object):; """"""; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentia",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:7390,Integrability,integrat,integrate,7390,"ar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; re",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:7729,Integrability,depend,depend,7729,"t; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the config",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:13391,Integrability,integrat,integrate,13391,"he; N_he_interact += 1. he_state_neigh[k] = n_k. if n_excite <= N_c - 1:; # find the hierarchy element index of the neighbour after; # this element, for this Matsubara term; he_state_neigh[k] = n_k + 1; he_idx_neigh = he2idx[tuple(he_state_neigh)]. op = commQ; if renorm:; op = -1j*norm_plus[n_k, k]*op; else:; op = -1j*op. L_he = cy_pad_csr(op, N_he, N_he, he_idx, he_idx_neigh); L_helems += L_he; N_he_interact += 1. he_state_neigh[k] = n_k. if stats:; stats.add_timing('hierarchy contruct',; timeit.default_timer() - start_helem_constr,; ss_conf); stats.add_count('Num hierarchy elements', N_he, ss_conf); stats.add_count('Num he interactions', N_he_interact, ss_conf). # Setup Liouvillian; if stats: ; start_louvillian = timeit.default_timer(); ; H_he = zcsr_kron(unit_helems, liouvillian(H_sys).data). L_helems += H_he. if stats:; stats.add_timing('Liouvillian contruct',; timeit.default_timer() - start_louvillian,; ss_conf). if stats: start_integ_conf = timeit.default_timer(). r = scipy.integrate.ode(cy_ode_rhs). r.set_f_params(L_helems.data, L_helems.indices, L_helems.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """"""",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:15465,Integrability,integrat,integrate,15465,".stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_integ, ss_run); if ss_run.total_time is None:; ss_run.total_time = time_now - start_run; else:; ss_run.total_time += time_now - start_run; stats.total_time = ss_conf.total_time + ss_run.total_time. return output. def _calc_matsubara_params(self):; """"""; Calculate the Matsubara coefficents and frequencies. Returns; -------; c, nu: both list(float). """"""; c = []; nu = []; lam0 = self.coup_strength; gam = self.cut_freq; hbar = self.planck; beta = 1.0/(self.boltzmann*self.temperature); N_m = self.N_exp. g = 2*np.pi / (beta*hbar); for k in range(N_m):; if k == 0:; nu.append(gam); c.append(lam0*gam*; (1.0/np.tan(gam*hbar*beta/2.0) - 1j) / hbar); else:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:15647,Integrability,integrat,integrate,15647,"meError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_integ, ss_run); if ss_run.total_time is None:; ss_run.total_time = time_now - start_run; else:; ss_run.total_time += time_now - start_run; stats.total_time = ss_conf.total_time + ss_run.total_time. return output. def _calc_matsubara_params(self):; """"""; Calculate the Matsubara coefficents and frequencies. Returns; -------; c, nu: both list(float). """"""; c = []; nu = []; lam0 = self.coup_strength; gam = self.cut_freq; hbar = self.planck; beta = 1.0/(self.boltzmann*self.temperature); N_m = self.N_exp. g = 2*np.pi / (beta*hbar); for k in range(N_m):; if k == 0:; nu.append(gam); c.append(lam0*gam*; (1.0/np.tan(gam*hbar*beta/2.0) - 1j) / hbar); else:; nu.append(k*g); c.append(4*lam0*gam*nu[k] /; ((nu[k]**2 - gam**2)*beta*hbar**2)). self.exp_coeff = c; self.exp_freq = nu; return c, nu. def _calc_renorm_factors(self):; """"""; Calculate the renormalisation factors. Returns; -------; norm_plus, norm_minus : array[N_c, N_m] of float; """"""; c = self.exp_coeff; N_m = self.N_exp; N_c = self.N_cu",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:4115,Modifiability,coupling,coupling,4115,"duction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve). This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate. There are opportunities to develop a more general spectral density code. Attributes; ----------; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann's constant. options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:5595,Modifiability,config,configured,5595,"ess_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example HSolverDL""). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; self.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_cut = 10; self.N_exp = 2; self.N_he = 0. self.exp_coeff = None; self.exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:5626,Modifiability,config,configure,5626,"ner for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example HSolverDL""). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; self.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_cut = 10; self.N_exp = 2; self.N_he = 0. self.exp_coeff = None; self.exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.bolt",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:7382,Modifiability,config,config,7382,"ar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; re",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:7422,Modifiability,config,config,7422,"ar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; re",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:8068,Modifiability,coupling,coupling,8068,"ats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return stats. [docs]class HSolverDL(HEOMSolver):; """"""; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:8705,Modifiability,config,configure,8705,"nfinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cu",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:8728,Modifiability,config,configure,8728,"ies. For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes; ----------; cut_freq : float; Bath spectral density cutoff frequency. renorm : bool; Apply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approx : bool; Use boundary cut off approximation; Can be; """""". def __init__(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:9085,Modifiability,config,configure,9085,"_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; N_temp",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:9293,Modifiability,config,configure,9293,"_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0,; renorm=True, bnd_cut_approx=True,; options=None, progress_bar=None, stats=None):. self.reset(). if options is None:; self.options = Options(); else:; self.options = options. self.progress_bar = False; if progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; N_temp",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:9444,Modifiability,config,configure,9444,"f progress_bar is None:; self.progress_bar = BaseProgressBar(); elif progress_bar == True:; self.progress_bar = TextProgressBar(). # the other attributes will be set in the configure method; self.configure(H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=planck, boltzmann=boltzmann,; renorm=renorm, bnd_cut_approx=bnd_cut_approx, stats=stats). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; HEOMSolver.reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; N_temp = 1; for i in H_sys.dims[0]:; N_temp *= i; sup_dim = N_temp**2; unit_sys = qeye(N_temp). # Use shorthands (mainly as in referenced PRL); lam0 = self.coup_strength; gam = self.cut_freq; N_c = self.N_cut; N_m = self.N_exp; Q = coup_op # Q as shorthand for coupling operator; beta = 1.0/(s",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:9969,Modifiability,config,config,9969,"reset(self); self.cut_freq = 1.0; self.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; N_temp = 1; for i in H_sys.dims[0]:; N_temp *= i; sup_dim = N_temp**2; unit_sys = qeye(N_temp). # Use shorthands (mainly as in referenced PRL); lam0 = self.coup_strength; gam = self.cut_freq; N_c = self.N_cut; N_m = self.N_exp; Q = coup_op # Q as shorthand for coupling operator; beta = 1.0/(self.boltzmann*self.temperature). # Ntot is the total number of ancillary elements in the hierarchy; # Ntot = factorial(N_c + N_m) / (factorial(N_c)*factorial(N_m)); # Turns out to be the same as nstates from state_number_enumerate; N_he, he2idx, idx2he = enr_state_dictionaries([N_c + 1]*N_m , N_c). unit_helems = fast_identity(N_he); if self.bnd_cut_approx:; # the Tanimura boundary cut off operator; if stats:; stats.add_message('options', 'boundary cutoff",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:10029,Modifiability,config,config,10029,"f.renorm = False; self.bnd_cut_approx = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, cut_freq, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Calls configure from :class:`HEOMSolver` and sets any attributes; that are specific to this subclass; """"""; start_config = timeit.default_timer(). HEOMSolver.configure(self, H_sys, coup_op, coup_strength,; temperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; N_temp = 1; for i in H_sys.dims[0]:; N_temp *= i; sup_dim = N_temp**2; unit_sys = qeye(N_temp). # Use shorthands (mainly as in referenced PRL); lam0 = self.coup_strength; gam = self.cut_freq; N_c = self.N_cut; N_m = self.N_exp; Q = coup_op # Q as shorthand for coupling operator; beta = 1.0/(self.boltzmann*self.temperature). # Ntot is the total number of ancillary elements in the hierarchy; # Ntot = factorial(N_c + N_m) / (factorial(N_c)*factorial(N_m)); # Turns out to be the same as nstates from state_number_enumerate; N_he, he2idx, idx2he = enr_state_dictionaries([N_c + 1]*N_m , N_c). unit_helems = fast_identity(N_he); if self.bnd_cut_approx:; # the Tanimura boundary cut off operator; if stats:; stats.add_message('options', 'boundary cutoff approx', ss_conf); op = -2*spre(Q)*s",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:10500,Modifiability,coupling,coupling,10500,"mperature, N_cut, N_exp,; planck=planck, boltzmann=boltzmann,; options=options, progress_bar=progress_bar, stats=stats); self.cut_freq = cut_freq; if renorm is not None: self.renorm = renorm; if bnd_cut_approx is not None: self.bnd_cut_approx = bnd_cut_approx. # Load local values for optional parameters; # Constants and Hamiltonian.; hbar = self.planck; options = self.options; progress_bar = self.progress_bar; stats = self.stats. if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; ss_conf = stats.add_section('config'). c, nu = self._calc_matsubara_params(). if renorm:; norm_plus, norm_minus = self._calc_renorm_factors(); if stats:; stats.add_message('options', 'renormalisation', ss_conf); # Dimensions et by system; N_temp = 1; for i in H_sys.dims[0]:; N_temp *= i; sup_dim = N_temp**2; unit_sys = qeye(N_temp). # Use shorthands (mainly as in referenced PRL); lam0 = self.coup_strength; gam = self.cut_freq; N_c = self.N_cut; N_m = self.N_exp; Q = coup_op # Q as shorthand for coupling operator; beta = 1.0/(self.boltzmann*self.temperature). # Ntot is the total number of ancillary elements in the hierarchy; # Ntot = factorial(N_c + N_m) / (factorial(N_c)*factorial(N_m)); # Turns out to be the same as nstates from state_number_enumerate; N_he, he2idx, idx2he = enr_state_dictionaries([N_c + 1]*N_m , N_c). unit_helems = fast_identity(N_he); if self.bnd_cut_approx:; # the Tanimura boundary cut off operator; if stats:; stats.add_message('options', 'boundary cutoff approx', ss_conf); op = -2*spre(Q)*spost(Q.dag()) + spre(Q.dag()*Q) + spost(Q.dag()*Q). approx_factr = ((2*lam0 / (beta*gam*hbar)) - 1j*lam0) / hbar; for k in range(N_m):; approx_factr -= (c[k] / nu[k]); L_bnd = -approx_factr*op.data; L_helems = zcsr_kron(unit_helems, L_bnd); else:; L_helems = fast_csr_matrix(shape=(N_he*sup_dim, N_he*sup_dim)). # Build the hierarchy element interaction matrix; if stats: start_helem_constr = timeit.default_timer(). unit_sup = spre(unit_sys).data; spreQ = spre(Q).da",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:14277,Modifiability,evolve,evolves,14277,"contruct',; timeit.default_timer() - start_louvillian,; ss_conf). if stats: start_integ_conf = timeit.default_timer(). r = scipy.integrate.ode(cy_ode_rhs). r.set_f_params(L_helems.data, L_helems.indices, L_helems.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """""". start_run = timeit.default_timer(). sup_dim = self._sup_dim; stats = self.stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('in",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:14555,Modifiability,config,configured,14555,"=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """""". start_run = timeit.default_timer(). sup_dim = self._sup_dim; stats = self.stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); outp",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:14627,Modifiability,config,config,14627,"max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """""". start_run = timeit.default_timer(). sup_dim = self._sup_dim; stats = self.stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:14681,Modifiability,config,config,14681,"max_step=options.max_step). if stats:; time_now = timeit.default_timer(); stats.add_timing('Liouvillian contruct',; time_now - start_integ_conf,; ss_conf); if ss_conf.total_time is None:; ss_conf.total_time = time_now - start_config; else:; ss_conf.total_time += time_now - start_config. self._ode = r; self._N_he = N_he; self._sup_dim = sup_dim; self._configured = True. [docs] def run(self, rho0, tlist):; """"""; Function to solve for an open quantum system using the; HEOM model. Parameters; ----------; rho0 : Qobj; Initial state (density matrix) of the system. tlist : list; Time over which system evolves. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation.; """""". start_run = timeit.default_timer(). sup_dim = self._sup_dim; stats = self.stats; r = self._ode. if not self._configured:; raise RuntimeError(""Solver must be configured before it is run""); if stats:; ss_conf = stats.sections.get('config'); if ss_conf is None:; raise RuntimeError(""No config section for solver stats""); ss_run = stats.sections.get('run'); if ss_run is None:; ss_run = stats.add_section('run'). # Set up terms of the matsubara and tanimura boundaries; output = Result(); output.solver = ""hsolve""; output.times = tlist; output.states = []. if stats: start_init = timeit.default_timer(); output.states.append(Qobj(rho0)); rho0_flat = rho0.full().ravel('F') # Using 'F' effectively transposes; rho0_he = np.zeros([sup_dim*self._N_he], dtype=complex); rho0_he[:sup_dim] = rho0_flat; r.set_initial_value(rho0_he, tlist[0]). if stats:; stats.add_timing('initialize',; timeit.default_timer() - start_init, ss_run); start_integ = timeit.default_timer(). dt = np.diff(tlist); n_tsteps = len(tlist); for t_idx, t in enumerate(tlist):; if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); rho = Qobj(r.y[:sup_dim].reshape(rho0.shape), dims=rho0.dims); output.states.append(rho). if stats:; time_now = timeit.default_timer(); stats.add_timing('integrate',; time_now - start_",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:3872,Performance,perform,performance,3872,"n; from qutip.fastsparse import fast_csr_matrix, fast_identity. [docs]class HEOMSolver(object):; """"""; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve). This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate. There are opportunities to develop a more general spectral density code. Attributes; ----------; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann's constant. options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics a",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:4804,Performance,perform,performance,4804,"odel, and there; are some performance advantages to assuming this model where it is; appropriate. There are opportunities to develop a more general spectral density code. Attributes; ----------; H_sys : Qobj; System Hamiltonian. coup_op : Qobj; Operator describing the coupling between system and bath. coup_strength : float; Coupling strength. temperature : float; Bath temperature, in units corresponding to planck. N_cut : int; Cutoff parameter for the bath. N_exp : int; Number of exponential terms used to approximate the bath correlation; functions. planck : float; reduced Planck constant. boltzmann : float; Boltzmann's constant. options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. stats : :class:`qutip.solver.Stats`; optional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coeff : list of complex; Coefficients for the exponential series terms. exp_freq : list of complex; Frequencies for the exponential series terms; """"""; def __init__(self):; raise NotImplementedError(""This is a abstract class only. ""; ""Use a subclass, for example HSolverDL""). [docs] def reset(self):; """"""; Reset any attributes to default values; """"""; self.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_cut = 10; self.N_exp = 2; self.N_he = 0. self.exp_coeff = None; self.exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using th",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:6442,Performance,perform,performance,6442,".exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections; config; integrate; """"""; stats = Stats(['config', 'run']); stats.header = ""Hierarchy Solver Stats""; return st",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:6274,Usability,progress bar,progress bar,6274,"f.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_cut = 10; self.N_exp = 2; self.N_he = 0. self.exp_coeff = None; self.exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object s",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:6321,Usability,progress bar,progress bar,6321,"f.planck = 1.0; self.boltzmann = 1.0; self.H_sys = None; self.coup_op = None; self.coup_strength = 0.0; self.temperature = 1.0; self.N_cut = 10; self.N_exp = 2; self.N_he = 0. self.exp_coeff = None; self.exp_freq = None. self.options = None; self.progress_bar = None; self.stats = None. self.ode = None; self.configured = False. [docs] def configure(self, H_sys, coup_op, coup_strength, temperature,; N_cut, N_exp, planck=None, boltzmann=None,; renorm=None, bnd_cut_approx=None,; options=None, progress_bar=None, stats=None):; """"""; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters; ----------; options : :class:`qutip.solver.Options`; Generic solver options.; If set to None the default options will be used. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`; Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats; """""". self.H_sys = H_sys; self.coup_op = coup_op; self.coup_strength = coup_strength; self.temperature = temperature; self.N_cut = N_cut; self.N_exp = N_exp; if planck: self.planck = planck; if boltzmann: self.boltzmann = boltzmann; if isinstance(options, Options): self.options = options; if isinstance(progress_bar, BaseProgressBar):; self.progress_bar = progress_bar; elif progress_bar == True:; self.progress_bar = TextProgressBar(); elif progress_bar == False:; self.progress_bar = None; if isinstance(stats, Stats):; self.stats = stats; elif stats == True:; self.stats = self.create_new_stats(); elif stats == False:; self.stats = None. [docs] def create_new_stats(self):; """"""; Creates a new stats object s",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html:17394,Usability,simpl,simple,17394,"c_renorm_factors(self):; """"""; Calculate the renormalisation factors. Returns; -------; norm_plus, norm_minus : array[N_c, N_m] of float; """"""; c = self.exp_coeff; N_m = self.N_exp; N_c = self.N_cut. norm_plus = np.empty((N_c+1, N_m)); norm_minus = np.empty((N_c+1, N_m)); for k in range(N_m):; for n in range(N_c+1):; norm_plus[n, k] = np.sqrt(abs(c[k])*(n + 1)); norm_minus[n, k] = np.sqrt(float(n)/abs(c[k])). return norm_plus, norm_minus. def _pad_csr(A, row_scale, col_scale, insertrow=0, insertcol=0):; """"""; Expand the input csr_matrix to a greater space as given by the scale.; Effectively inserting A into a larger matrix; zeros([A.shape[0]*row_scale, A.shape[1]*col_scale]; at the position [A.shape[0]*insertrow, A.shape[1]*insertcol]; The same could be achieved through using a kron with a matrix with; one element set to 1. However, this is more efficient; """""". # ajgpitch 2016-03-08:; # Clearly this is a very simple operation in dense matrices; # It seems strange that there is nothing equivalent in sparse however,; # after much searching most threads suggest directly addressing; # the underlying arrays, as done here.; # This certainly proved more efficient than other methods such as stacking; #TODO: Perhaps cythonize and move to spmatfuncs. if not isinstance(A, sp.csr_matrix):; raise TypeError(""First parameter must be a csr matrix""); nrowin = A.shape[0]; ncolin = A.shape[1]; nrowout = nrowin*row_scale; ncolout = ncolin*col_scale. A._shape = (nrowout, ncolout); if insertcol == 0:; pass; elif insertcol > 0 and insertcol < col_scale:; A.indices = A.indices + insertcol*ncolin; else:; raise ValueError(""insertcol must be >= 0 and < col_scale""). if insertrow == 0:; A.indptr = np.concatenate((A.indptr,; np.array([A.indptr[-1]]*(row_scale-1)*nrowin))); elif insertrow == row_scale-1:; A.indptr = np.concatenate((np.array([0]*(row_scale - 1)*nrowin),; A.indptr)); elif insertrow > 0 and insertrow < row_scale - 1:; A.indptr = np.concatenate((np.array([0]*insertrow*nrowin), A.indptr,;",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/heom.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:3543,Deployability,integrat,integrator,3543,"s MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_mat",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:3730,Deployability,integrat,integrator,3730," :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:3804,Deployability,integrat,integrator,3804,"iouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = in",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:3961,Deployability,integrat,integrator,3961,"ors. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; -------",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:4777,Deployability,integrat,integrator,4777,"or'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:4790,Deployability,integrat,integrator,4790,"or'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:5528,Deployability,integrat,integrator,5528,"(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to t",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:5544,Deployability,integrat,integrator,5544,"elf.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; que",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:5764,Deployability,integrat,integrator,5764,"ons.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specifie",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:5780,Deployability,integrat,integrator,5780,"grator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:8003,Deployability,integrat,integrator,8003," generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : fl",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:8019,Deployability,integrat,integrator,8019,"for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:8599,Deployability,integrat,integrator,8599," []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; """"""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; List",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:8615,Deployability,integrat,integrator,8615,"append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; """"""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothi",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:12210,Deployability,integrat,integrator,12210,"s+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:12287,Deployability,integrat,integrator,12287,"s+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:12320,Deployability,integrat,integrator,12320,"s+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:12539,Deployability,integrat,integrator,12539,"s+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:12671,Deployability,integrat,integrator,12671,"s+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:12867,Deployability,update,updated,12867,"s+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:5346,Energy Efficiency,reduce,reduced,5346,"ce(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of correspond",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:8796,Energy Efficiency,reduce,reduced,8796,"; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; """"""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:3543,Integrability,integrat,integrator,3543,"s MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_mat",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:3730,Integrability,integrat,integrator,3730," :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:3804,Integrability,integrat,integrator,3804,"iouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = in",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:3961,Integrability,integrat,integrator,3961,"ors. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; -------",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:4777,Integrability,integrat,integrator,4777,"or'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:4790,Integrability,integrat,integrator,4790,"or'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinstance(L2, qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:5528,Integrability,integrat,integrator,5528,"(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to t",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:5544,Integrability,integrat,integrator,5544,"elf.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; que",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:5764,Integrability,integrat,integrator,5764,"ons.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specifie",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:5780,Integrability,integrat,integrator,5780,"grator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:8003,Integrability,integrat,integrator,8003," generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : fl",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:8019,Integrability,integrat,integrator,8019,"for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:8599,Integrability,integrat,integrator,8599," []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; """"""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; List",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:8615,Integrability,integrat,integrator,8615,"append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blist are 0, 1, 2, 3 ' +; 'and 4.'); superop.dims = E.dims; E = superop*E; sprev = s; E = _integrate(G1, E, slist[-1], tau, integrator=self.integrator,; parallel=self.parallel, opt=self.options). E.dims = E0.dims; if not notrace:; E = _genptrace(E, kmax); return E. [docs] def rhot(self, rho0, t, tau):; """"""; Compute the reduced system density matrix :math:`\\rho(t)`. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). t : float; current time. tau : float; time-delay. Returns; -------; : :class:`qutip.Qobj`; density matrix at time :math:`t`; """"""; if qt.isket(rho0):; rho0 = qt.ket2dm(rho0). E = self.propagator(t, tau); rhovec = qt.operator_to_vector(rho0); return qt.vector_to_operator(E*rhovec). [docs] def outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None):; """"""; Compute output field expectation value; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; rho0 : :class:`qutip.Qobj`; initial density matrix or state vector (ket). blist : array_like; List of integers specifying the field operators:; 0: I (nothi",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:12210,Integrability,integrat,integrator,12210,"s+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:12287,Integrability,integrat,integrator,12287,"s+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:12320,Integrability,integrat,integrator,12320,"s+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:12539,Integrability,integrat,integrator,12539,"s+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:12671,Integrability,integrat,integrator,12671,"s+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [], parallel=parallel,; options=opt)*E0; else:; raise ValueError('integrator keyword must be either ""propagator""' +; 'or ""mesolve""'); else:; return E0.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:2877,Modifiability,coupling,coupling,2877,"LUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver op",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:3033,Modifiability,coupling,coupling,3033,"#############################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:;",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:11616,Modifiability,coupling,coupling,11616,".dims = op.dims; for i in range(1, l):; h = qt.tensor(I, h); for i in range(l+1, k+1):; h = qt.tensor(h, I); return h. def _genptrace(E, k):; """"""; Perform a gneralized partial trace on a superoperator E, tracing out all; subsystems but one.; """"""; for l in range(k-1):; nsys = len(E.dims[0][0]); E = qt.tensor_contract(E, (0, 2*nsys+1), (nsys, 3*nsys+1)); return E. def _generator(k, H, L1, L2, S=None, c_ops_markov=None):; """"""; Create a Liouvillian for a cascaded chain of k system copies; """"""; id = qt.qeye(H.dims[0][0]); Id = qt.sprepost(id, id); if S is None:; S = np.identity(len(L1)); # create Lindbladian; L = qt.Qobj(); E0 = Id; # first system; L += qt.liouvillian(None, [_localop(c, 1, k) for c in L2]); for l in range(1, k):; # Identiy superoperator; E0 = qt.composite(E0, Id); # Bare Hamiltonian; Hl = _localop(H, l, k); L += qt.liouvillian(Hl, []); # Markovian Decay channels; if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, l, k); L += qt.liouvillian(None, [cl]); # Cascade coupling; c1 = np.array([_localop(c, l, k) for c in L1]); c2 = np.array([_localop(c, l+1, k) for c in L2]); c2dag = np.array([c.dag() for c in c2]); Hcasc = -0.5j*np.dot(c2dag, np.dot(S, c1)); Hcasc += Hcasc.dag(); Lvec = c2 + np.dot(S, c1); L += qt.liouvillian(Hcasc, [c for c in Lvec]); # last system; L += qt.liouvillian(_localop(H, k, k), [_localop(c, k, k) for c in L1]); if c_ops_markov is not None:; for c in c_ops_markov:; cl = _localop(c, k, k); L += qt.liouvillian(None, [cl]); E0.dims = L.dims; # return generator and identity superop E0; return L, E0. def _integrate(L, E0, ti, tf, integrator='propagator', parallel=False,; opt=qt.Options()):; """"""; Basic ode integrator; """"""; if tf > ti:; if integrator == 'mesolve':; if parallel:; warnings.warn('parallelization not implemented for ""mesolve""'); opt.store_final_state = True; sol = qt.mesolve(L, E0, [ti, tf], [], [], options=opt); return sol.final_state; elif integrator == 'propagator':; return qt.propagator(L, (tf-ti), [], [],",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:5223,Performance,perform,performed,5223," qt.Qobj):; self.L2 = [L2]; else:; self.L2 = L2; if not len(self.L1) == len(self.L2):; raise ValueError('L1 and L2 has to be of equal length.'); if isinstance(c_ops_markov, qt.Qobj):; self.c_ops_markov = [c_ops_markov]; else:; self.c_ops_markov = c_ops_markov. if S_matrix is None:; self.S_matrix = np.identity(len(self.L1)); else:; self.S_matrix = S_matrix; # create system identity superoperator; self.Id = qt.qeye(H_S.shape[0]); self.Id.dims = self.sysdims; self.Id = qt.sprepost(self.Id, self.Id); self.store_states = self.options.store_states; self.integrator = integrator; self.parallel = parallel. [docs] def propagator(self, t, tau, notrace=False):; """"""; Compute propagator for time t and time-delay tau. Parameters; ----------; t : *float*; current time. tau : *float*; time-delay. notrace : *bool* {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned.; Returns; -------; : :class:`qutip.Qobj`; time-propagator for reduced system dynamics; """"""; k = int(t/tau)+1; s = t-(k-1)*tau; G1, E0 = _generator(k, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); E = _integrate(G1, E0, 0., s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if k > 1:; G2, null = _generator(k-1, self.H_S, self.L1, self.L2,; self.S_matrix, self.c_ops_markov); G2 = qt.composite(G2, self.Id); E = _integrate(G2, E, s, tau, integrator=self.integrator, ; parallel=self.parallel, opt=self.options); E.dims = E0.dims; if not notrace:; E = _genptrace(E, k); return E. [docs] def outfieldpropagator(self, blist, tlist, tau, c1=None, c2=None,; notrace=False):; """"""; Compute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List o",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:7004,Performance,perform,performed,7004,"ute propagator for computing output field expectation values; <O_n(tn)...O_2(t2)O_1(t1)> for times t1,t2,... and; O_i = I, b_out, b_out^\dagger, b_loop, b_loop^\dagger. Parameters; ----------; blist : array_like; List of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, i",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:2332,Usability,feedback,feedback,2332,"TRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to a",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:2695,Usability,feedback,feedback,2695,"S (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagato",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:2895,Usability,feedback,feedback,2895,"LUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver op",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:3053,Usability,feedback,feedback,3053,"#############################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:;",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:3260,Usability,feedback,feedback,3260,"s module is an implementation of the method introduced in [1], for; solving open quantum systems subject to coherent feedback with a single; discrete time-delay. This method is referred to as the ``memory cascade''; method in qutip. [1] Arne L. Grimsmo, Phys. Rev. Lett 115, 060402 (2015); """""". import numpy as np; import warnings. import qutip as qt. [docs]class MemoryCascade:; """"""Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes; ----------; H_S : :class:`qutip.Qobj`; System Hamiltonian (can also be a Liouvillian). L1 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2 : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; System operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*; S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markov : :class:`qutip.Qobj` / list of :class:`qutip.Qobj`; Decay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integrator : str {'propagator', 'mesolve'}; Integrator method to use. Defaults to 'propagator' which tends to be ; faster for long times (i.e., large Hilbert space). parallel : bool; Run integrator in parallel if True. Only implemented for 'propagator'; as the integrator method. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, H_S, L1, L2, S_matrix=None, c_ops_markov=None,; integrator='propagator', parallel=False, options=None):. if options is None:; self.options = qt.Options(); else:; self.options = options. self.H_S = H_S; self.sysdims = H_S.dims; if isinstance(L1, qt.Qobj):; self.L1 = [L1]; else:; self.L1 = L1; if isinst",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:7338,Usability,feedback,feedback,7338,"_out; 2: b_out^\dagger; 3: b_loop; 4: b_loop^\dagger. tlist : array_like; list of corresponding times t1,..,tn at which to evaluate the field; operators. tau : float; time-delay. c1 : :class:`qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html:7530,Usability,feedback,feedback,7530,"qutip.Qobj`; system collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2 : :class:`qutip.Qobj`; system collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notrace : bool {False}; If this optional is set to True, a propagator is returned for a; cascade of k systems, where :math:`(k-1) tau < t < k tau`.; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; -------; : :class:`qutip.Qobj`; time-propagator for computing field correlation function; """"""; if c1 is None and len(self.L1) == 1:; c1 = self.L1[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); if c2 is None and len(self.L2) == 1:; c2 = self.L2[0]; else:; raise ValueError('Argument c1 has to be specified when more than' +; 'one collapse operator couples to the feedback' +; 'loop.'); klist = []; slist = []; for t in tlist:; klist.append(int(t/tau)+1); slist.append(t-(klist[-1]-1)*tau); kmax = max(klist); zipped = sorted(zip(slist, klist, blist)); slist = [s for (s, k, b) in zipped]; klist = [k for (s, k, b) in zipped]; blist = [b for (s, k, b) in zipped]. G1, E0 = _generator(kmax, self.H_S, self.L1, self.L2, self.S_matrix,; self.c_ops_markov); sprev = 0.; E = E0; for i, s in enumerate(slist):; E = _integrate(G1, E, sprev, s, integrator=self.integrator,; parallel=self.parallel, opt=self.options); if klist[i] == 1:; l1 = 0.*qt.Qobj(); else:; l1 = _localop(c1, klist[i]-1, kmax); l2 = _localop(c2, klist[i], kmax); if blist[i] == 0:; superop = self.Id; elif blist[i] == 1:; superop = qt.spre(l1+l2); elif blist[i] == 2:; superop = qt.spost(l1.dag()+l2.dag()); elif blist[i] == 3:; superop = qt.spre(l1); elif blist[i] == 4:; superop = qt.spost(l1.dag()); else:; raise ValueError('Allowed values in blis",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/memorycascade.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/memorycascade.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html:8135,Deployability,update,updated,8135,"mes. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html:2955,Usability,learn,learningtimes,2955,"AGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module contains an implementation of the non-Markovian transfer tensor; method (TTM), introduced in [1]. [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014); """""". import numpy as np. from qutip import (Options, spre, vector_to_operator, operator_to_vector,; ket2dm, isket); from qutip.solver import Result; from qutip.expect import expect_rho_vec. [docs]class TTMSolverOptions:; """"""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of tim",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html:3019,Usability,learn,learning,3019,"AGE.; ###############################################################################. # @author: Arne L. Grimsmo; # @email1: arne.grimsmo@gmail.com; # @organization: University of Sherbrooke. """"""; This module contains an implementation of the non-Markovian transfer tensor; method (TTM), introduced in [1]. [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014); """""". import numpy as np. from qutip import (Options, spre, vector_to_operator, operator_to_vector,; ket2dm, isket); from qutip.solver import Result; from qutip.expect import expect_rho_vec. [docs]class TTMSolverOptions:; """"""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of tim",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html:3288,Usability,learn,learningtimes,3288,"sfer tensor; method (TTM), introduced in [1]. [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014); """""". import numpy as np. from qutip import (Options, spre, vector_to_operator, operator_to_vector,; ket2dm, isket); from qutip.solver import Result; from qutip.expect import expect_rho_vec. [docs]class TTMSolverOptions:; """"""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html:3425,Usability,learn,learningtimes,3425,"ptions, spre, vector_to_operator, operator_to_vector,; ket2dm, isket); from qutip.solver import Result; from qutip.expect import expect_rho_vec. [docs]class TTMSolverOptions:; """"""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dict",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html:3441,Usability,learn,learningtimes,3441,"ptions, spre, vector_to_operator, operator_to_vector,; ket2dm, isket); from qutip.solver import Result; from qutip.expect import expect_rho_vec. [docs]class TTMSolverOptions:; """"""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dict",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html:3569,Usability,learn,learningtimes,3569,"""""""Class of options for the Transfer Tensor Method solver. Attributes; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. times : array_like; List of times :math:`t_n` at which to calculate :math:`\\rho(t_n)`. learningtimes : array_like; List of times :math:`t_k` to use as learning times if argument; `dynmaps` is a callback function. thres : float; Threshold for halting. Halts if :math:`||T_{n}-T_{n-1}||` is below; treshold. options : :class:`qutip.solver.Options`; Generic solver options.; """""". def __init__(self, dynmaps=None, times=[], learningtimes=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; output: :class:`qutip.solver.Result`; An instance of the class :class:`",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html:4237,Usability,learn,learningtimes,4237,"times=[],; thres=0.0, options=None):. if options is None:; options = Options(). self.dynmaps = dynmaps; self.times = times; self.learningtimes = learningtimes; self.thres = thres; self.store_states = options.store_states. [docs]def ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None,; **kwargs):; """"""; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; output: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`.; """""". opt = TTMSolverOptions(dynmaps=dynmaps, times=times,; learningtimes=learningtimes, **kwargs). diff = None. if isket(rho0):; rho0 = ket2dm(rho0). output = Result(); e_sops_data = []. if callable(e_ops):; n_expt_op = 0; expt_callback = True. else:; try:; tmp = e_ops[:]; del tmp. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; opt.store_states = True. for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(len(times))); else:; output.expect.append(np.zeros(len(times), dtype=complex)); except TypeError:; raise TypeError(""Argument 'e_ops' s",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html:4702,Usability,learn,learningtimes,4702," precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; output: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`.; """""". opt = TTMSolverOptions(dynmaps=dynmaps, times=times,; learningtimes=learningtimes, **kwargs). diff = None. if isket(rho0):; rho0 = ket2dm(rho0). output = Result(); e_sops_data = []. if callable(e_ops):; n_expt_op = 0; expt_callback = True. else:; try:; tmp = e_ops[:]; del tmp. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; opt.store_states = True. for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(len(times))); else:; output.expect.append(np.zeros(len(times), dtype=complex)); except TypeError:; raise TypeError(""Argument 'e_ops' should be a callable or"" +; ""list-like.""). if tensors is None:; tensors, diff = _generatetensors(dynmaps, learningtimes, opt=opt). if rho0.isoper:; # vectorize density matrix; rho0vec = operator_to_vector(rho0); else:; # rho0 might be a super in which case we should not vectorize; rho0vec = rho0. K = len(tensors); states = [rho0vec]; for n in range(1, len(times)):; states.append(None); for k in ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html:4716,Usability,learn,learningtimes,4716," precomputed dynamical maps. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0 : :class:`qutip.Qobj`; Initial density matrix or state vector (ket). times : array_like; list of times :math:`t_n` at which to compute :math:`\\rho(t_n)`.; Must be uniformily spaced. e_ops : list of :class:`qutip.Qobj` / callback function; single operator or list of operators for which to evaluate; expectation values. learningtimes : array_like; list of times :math:`t_k` for which we have knowledge of the dynamical; maps :math:`E(t_k)`. tensors : array_like; optional list of precomputed tensors :math:`T_k`. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; output: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`.; """""". opt = TTMSolverOptions(dynmaps=dynmaps, times=times,; learningtimes=learningtimes, **kwargs). diff = None. if isket(rho0):; rho0 = ket2dm(rho0). output = Result(); e_sops_data = []. if callable(e_ops):; n_expt_op = 0; expt_callback = True. else:; try:; tmp = e_ops[:]; del tmp. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; opt.store_states = True. for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(len(times))); else:; output.expect.append(np.zeros(len(times), dtype=complex)); except TypeError:; raise TypeError(""Argument 'e_ops' should be a callable or"" +; ""list-like.""). if tensors is None:; tensors, diff = _generatetensors(dynmaps, learningtimes, opt=opt). if rho0.isoper:; # vectorize density matrix; rho0vec = operator_to_vector(rho0); else:; # rho0 might be a super in which case we should not vectorize; rho0vec = rho0. K = len(tensors); states = [rho0vec]; for n in range(1, len(times)):; states.append(None); for k in ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html:5402,Usability,learn,learningtimes,5402,"tional list of precomputed tensors :math:`T_k`. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; output: :class:`qutip.solver.Result`; An instance of the class :class:`qutip.solver.Result`.; """""". opt = TTMSolverOptions(dynmaps=dynmaps, times=times,; learningtimes=learningtimes, **kwargs). diff = None. if isket(rho0):; rho0 = ket2dm(rho0). output = Result(); e_sops_data = []. if callable(e_ops):; n_expt_op = 0; expt_callback = True. else:; try:; tmp = e_ops[:]; del tmp. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; opt.store_states = True. for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(len(times))); else:; output.expect.append(np.zeros(len(times), dtype=complex)); except TypeError:; raise TypeError(""Argument 'e_ops' should be a callable or"" +; ""list-like.""). if tensors is None:; tensors, diff = _generatetensors(dynmaps, learningtimes, opt=opt). if rho0.isoper:; # vectorize density matrix; rho0vec = operator_to_vector(rho0); else:; # rho0 might be a super in which case we should not vectorize; rho0vec = rho0. K = len(tensors); states = [rho0vec]; for n in range(1, len(times)):; states.append(None); for k in range(n):; if n-k < K:; states[-1] += tensors[n-k]*states[k]; for i, r in enumerate(states):; if opt.store_states or expt_callback:; if r.type == 'operator-ket':; states[i] = vector_to_operator(r); else:; states[i] = r; if expt_callback:; # use callback method; e_ops(times[i], states[i]); for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 0); else:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 1). output.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """,MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html:6349,Usability,learn,learningtimes,6349,"dynmaps, learningtimes, opt=opt). if rho0.isoper:; # vectorize density matrix; rho0vec = operator_to_vector(rho0); else:; # rho0 might be a super in which case we should not vectorize; rho0vec = rho0. K = len(tensors); states = [rho0vec]; for n in range(1, len(times)):; states.append(None); for k in range(n):; if n-k < K:; states[-1] += tensors[n-k]*states[k]; for i, r in enumerate(states):; if opt.store_states or expt_callback:; if r.type == 'operator-ket':; states[i] = vector_to_operator(r); else:; states[i] = r; if expt_callback:; # use callback method; e_ops(times[i], states[i]); for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 0); else:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 1). output.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; d",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html:6679,Usability,learn,learningtimes,6679,"one); for k in range(n):; if n-k < K:; states[-1] += tensors[n-k]*states[k]; for i, r in enumerate(states):; if opt.store_states or expt_callback:; if r.type == 'operator-ket':; states[i] = vector_to_operator(r); else:; states[i] = r; if expt_callback:; # use callback method; e_ops(times[i], states[i]); for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 0); else:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 1). output.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = k",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html:6767,Usability,learn,learningtimes,6767,"back:; if r.type == 'operator-ket':; states[i] = vector_to_operator(r); else:; states[i] = r; if expt_callback:; # use callback method; e_ops(times[i], states[i]); for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 0); else:; output.expect[m][i] = expect_rho_vec(e_sops_data[m], r, 1). output.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html:7161,Usability,learn,learningtimes,7161,"put.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx us",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html:7212,Usability,learn,learnintimes,7212,"put.solver = ""ttmsolve""; output.times = times. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx us",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html:7316,Usability,learn,learningtimes,7316,"mes. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html:7346,Usability,learn,learningtimes,7346,"mes. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html:7624,Usability,learn,learningtimes,7624,"mes. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html:7638,Usability,learn,learningtimes,7638,"mes. output.ttmconvergence = diff. if opt.store_states:; output.states = states. return output. def _generatetensors(dynmaps, learningtimes=None, **kwargs):; """"""; Generate the tensors :math:`T_1,\dots,T_K` from the dynamical maps; :math:`E(t_k)`. A stationary process is assumed, i.e., :math:`T_{n,k} = T_{n-k}`. Parameters; ----------; dynmaps : list of :class:`qutip.Qobj`; List of precomputed dynamical maps (superoperators) at the times; specified in `learningtimes`, or a callback function that returns the; superoperator at a given time. learningtimes : array_like; list of times :math:`t_k` to use if argument `dynmaps` is a callback; function. kwargs : dictionary; Optional keyword arguments. See; :class:`qutip.nonmarkov.ttm.TTMSolverOptions`. Returns; -------; Tlist: list of :class:`qutip.Qobj.`; A list of transfer tensors :math:`T_1,\dots,T_K`; """""". # Determine if dynmaps is callable or list-like; if callable(dynmaps):; if learningtimes is None:; raise TypeError(""Argument 'learnintimes' required when 'dynmaps'"" +; ""is a callback function.""). def dynmapfunc(n): return dynmaps(learningtimes[n]); Kmax = len(learningtimes); else:; try:; tmp = dynmaps[:]; del tmp. def dynmapfunc(n): return dynmaps[n]; Kmax = len(dynmaps); except TypeError:; raise TypeError(""Argument 'dynmaps' should be a callable or"" +; ""list-like.""). if ""opt"" not in kwargs:; opt = TTMSolverOptions(dynmaps=dynmaps, learningtimes=learningtimes,; **kwargs); else:; opt = kwargs['opt']. Tlist = []; diff = [0.0]; for n in range(Kmax):; T = dynmapfunc(n); for m in range(1, n):; T -= Tlist[n-m]*dynmapfunc(m); Tlist.append(T); if n > 1:; diff.append((Tlist[-1]-Tlist[-2]).norm()); if diff[-1] < opt.thres:; # Below threshold for truncation; print('breaking', (Tlist[-1]-Tlist[-2]).norm(), n); break; return Tlist, diff.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/nonmarkov/transfertensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/nonmarkov/transfertensor.html
https://qutip.org/docs/4.3/modules/qutip/qip/circuit.html:32108,Deployability,update,updated,32108,"""CNOT"":; col.append(r"" \targ ""); elif gate.name == ""TOFFOLI"":; col.append(r"" \targ ""); else:; col.append(r"" \gate{%s} "" %; _gate_label(gate.name, gate.arg_label)). elif gate.controls and n in gate.controls:; m = (gate.targets[0] - n) * (-1 if self.reverse_states; else 1); col.append(r"" \ctrl{%d} "" % m). elif (not gate.controls and not gate.targets):; # global gate; if ((self.reverse_states and n == self.N - 1); or (not self.reverse_states and n == 0)):; col.append(r"" \multigate{%d}{%s} "" %; (self.N - 1,; _gate_label(gate.name, gate.arg_label))); else:; col.append(r"" \ghost{%s} "" %; (_gate_label(gate.name, gate.arg_label))). else:; col.append(r"" \qw ""). col.append(r"" \qw ""); rows.append(col). input_states = [""\lstick{\ket{"" + x + ""}}"" if x is not None; else """" for x in self.input_states]. code = """"; n_iter = (reversed(range(self.N)) if self.reverse_states; else range(self.N)); for n in n_iter:; code += r"" & %s"" % input_states[n]; for m in range(len(gates)):; code += r"" & %s"" % rows[m][n]; code += r"" & \qw \\ "" + ""\n"". return code. def _repr_png_(self):; return _latex_compile(self.latex_code(), format=""png""). def _repr_svg_(self):; return _latex_compile(self.latex_code(), format=""svg""). @property; def png(self):; from IPython.display import Image; return Image(self._repr_png_(), embed=True). @property; def svg(self):; from IPython.display import SVG; return SVG(self._repr_svg_()). def qasm(self):. code = ""# qasm code generated by QuTiP\n\n"". for n in range(self.N):; code += ""\tqubit\tq%d\n"" % n. code += ""\n"". for gate in self.gates:; code += ""\t%s\t"" % gate.name; qtargets = [""q%d"" %; t for t in gate.targets] if gate.targets else []; qcontrols = ([""q%d"" % c for c in gate.controls] if gate.controls; else []); code += "","".join(qtargets + qcontrols); code += ""\n"". return code.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qip/circuit.html
https://qutip.org/docs/4.3/modules/qutip/qip/circuit.html:7175,Modifiability,variab,variable,7175,"ult: ""input"". """"""; if state_type == ""input"":; for i in targets:; self.input_states[i] = state; if state_type == ""output"":; for i in targets:; self.output_states[i] = state. [docs] def add_gate(self, gate, targets=None, controls=None, arg_value=None,; arg_label=None):; """"""; Adds a gate with specified parameters to the circuit. Parameters; ----------; gate: String or `Gate`; Gate name. If gate is an instance of `Gate`, parameters are; unpacked and added.; targets: List; Gate targets.; controls: List; Gate controls.; arg_value: Float; Argument value(phi).; arg_label: String; Label for gate representation.; """"""; if isinstance(gate, Gate):; name = gate.name; targets = gate.targets; controls = gate.controls; arg_value = gate.arg_value; arg_label = gate.arg_label. else:; name = gate; self.gates.append(Gate(name, targets=targets, controls=controls,; arg_value=arg_value, arg_label=arg_label)). [docs] def add_1q_gate(self, name, start=0, end=None, qubits=None,; arg_value=None, arg_label=None):; """"""; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters; ----------; name : String; Gate name.; start : Integer; Starting location of qubits.; end : Integer; Last qubit for the gate.; qubits : List; Specific qubits for applying gates.; arg_value : Float; Argument value(phi).; arg_label : String; Label for gate representation.; """"""; if name not in [""RX"", ""RY"", ""RZ"", ""SNOT"", ""SQRTNOT"", ""PHASEGATE""]:; raise ValueError(""%s is not a single qubit gate"" % name). if qubits is not None:; for i in range(len(qubits)):; self.gates.append(Gate(name, targets=qubits[i], controls=None,; arg_value=arg_value,; arg_label=arg_label)). else:; if end is None:; end = self.N - 1; for i in range(start, end):; self.gates.append(Gate(name, targets=i, controls=None,; arg_value=arg_value,; arg_label=arg_label)). [docs] def add_circuit(self, qc, start=0):; """"""; Adds a block of a qubit",MatchSource.WIKI,docs/4.3/modules/qutip/qip/circuit.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qip/circuit.html
https://qutip.org/docs/4.3/modules/qutip/qip/gates.html:25514,Deployability,update,updated,25514,"0]], p[1]. elif target == 1 and controls[1] == 0:; # target -> controls[1] -> controls[0] -> outside; p[2], p[1] = p[1], p[2]; p[2], p[0] = p[0], p[2]; p[2], p[controls[0]] = p[controls[0]], p[2]. elif target == 0 and controls[0] == 1:; # target -> controls[0] -> controls[1] -> outside; p[2], p[0] = p[0], p[2]; p[2], p[1] = p[1], p[2]; p[2], p[controls[1]] = p[controls[1]], p[2]. elif controls[0] == 0 and controls[1] == 2:; # controls[0] -> self, controls[1] -> target -> outside; p[1], p[2] = p[2], p[1]; p[1], p[target] = p[target], p[1]. elif controls[1] == 1 and controls[0] == 2:; # controls[1] -> self, controls[0] -> target -> outside; p[0], p[2] = p[2], p[0]; p[0], p[target] = p[target], p[0]. elif target == 2 and controls[0] == 1:; # target -> self, controls[0] -> controls[1] -> outside; p[0], p[1] = p[1], p[0]; p[0], p[controls[1]] = p[controls[1]], p[0]. #; # N > 4 cases; #. elif controls[0] == 1 and controls[1] > 2 and target > 2:; # controls[0] -> controls[1] -> outside, target -> outside; p[0], p[1] = p[1], p[0]; p[0], p[controls[1]] = p[controls[1]], p[0]; p[2], p[target] = p[target], p[2]. elif controls[0] == 2 and controls[1] > 2 and target > 2:; # controls[0] -> target -> outside, controls[1] -> outside; p[0], p[2] = p[2], p[0]; p[0], p[target] = p[target], p[0]; p[1], p[controls[1]] = p[controls[1]], p[1]. elif controls[1] == 2 and controls[0] > 2 and target > 2:; # controls[1] -> target -> outside, controls[0] -> outside; p[1], p[2] = p[2], p[1]; p[1], p[target] = p[target], p[1]; p[0], p[controls[0]] = p[controls[0]], p[0]. else:; p[0], p[controls[0]] = p[controls[0]], p[0]; p1[1], p1[controls[1]] = p1[controls[1]], p1[1]; p2[2], p2[target] = p2[target], p2[2]; p = [p[p1[p2[k]]] for k in range(N)]. return tensor([U] + [identity(2)] * (N - 3)).permute(p).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/qip/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qip/gates.html
https://qutip.org/docs/4.3/modules/qutip/qip/gates.html:2348,Energy Efficiency,reduce,reduce,2348,"ITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from __future__ import division. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj; from qutip.operators import identity, qeye, sigmax; from qutip.tensor import tensor; from qutip.states import fock_dm. from itertools import product; from functools import partial, reduce; from operator import mul. __all__ = ['rx', 'ry', 'rz', 'sqrtnot', 'snot', 'phasegate', 'cphase', 'cnot',; 'csign', 'berkeley', 'swapalpha', 'swap', 'iswap', 'sqrtswap',; 'sqrtiswap', 'fredkin', 'toffoli', 'rotation', 'controlled_gate',; 'globalphase', 'hadamard_transform', 'gate_sequence_product',; 'gate_expand_1toN', 'gate_expand_2toN', 'gate_expand_3toN',; 'qubit_clifford_group']. #; # Single Qubit Gates; #. [docs]def rx(phi, N=None, target=0):; """"""Single-qubit rotation for operator sigmax with angle phi. Returns; -------; result : qobj; Quantum object for operator describing the rotation. """"""; if N is not None:; return gate_expand_1toN(rx(phi), N, target); else:; return Qobj([[np.cos(phi / 2), -1j * np.sin(phi / 2)],; [-1j * np.sin(phi / 2), np.cos(phi / 2)]]). [docs]def ry(phi, N=None, target=0):; """"""Single-qubit rotation for operator sigmay with angle phi. Returns; -------; result : qobj; Quantum object for operator describing the rotation. """"""; if N is not ",MatchSource.WIKI,docs/4.3/modules/qutip/qip/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qip/gates.html
https://qutip.org/docs/4.3/modules/qutip/qip/gates.html:17569,Energy Efficiency,power,powers,17569,"teger x.; """"""; tot = 0; while x:; tot += 1; x &= x - 1; return tot. [docs]def hadamard_transform(N=1):; """"""Quantum object representing the N-qubit Hadamard gate. Returns; -------; q : qobj; Quantum object representation of the N-qubit Hadamard gate. """"""; data = 2 ** (-N / 2) * np.array([[(-1) ** _hamming_distance(i & j); for i in range(2 ** N)]; for j in range(2 ** N)]). return Qobj(data, dims=[[2] * N, [2] * N]). [docs]def gate_sequence_product(U_list, left_to_right=True):; """"""; Calculate the overall unitary matrix for a given list of unitary operations. Parameters; ----------; U_list : list; List of gates implementing the quantum circuit. left_to_right : Boolean; Check if multiplication is to be done from left to right. Returns; -------; U_overall : qobj; Overall unitary matrix of a given quantum circuit. """"""; U_overall = 1; for U in U_list:; if left_to_right:; U_overall = U * U_overall; else:; U_overall = U_overall * U. return U_overall. def _powers(op, N):; """"""; Generator that yields powers of an operator `op`,; through to `N`.; """"""; acc = qeye(op.dims[0]); yield acc. for _ in range(N - 1):; acc *= op; yield acc. def qubit_clifford_group(N=None, target=0):; """"""; Generates the Clifford group on a single qubit,; using the presentation of the group given by Ross and Selinger; (http://www.mathstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi ",MatchSource.WIKI,docs/4.3/modules/qutip/qip/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qip/gates.html
https://qutip.org/docs/4.3/modules/qutip/qip/gates.html:18674,Energy Efficiency,reduce,reduce,18674,"cc. def qubit_clifford_group(N=None, target=0):; """"""; Generates the Clifford group on a single qubit,; using the presentation of the group given by Ross and Selinger; (http://www.mathstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2), _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if targe",MatchSource.WIKI,docs/4.3/modules/qutip/qip/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qip/gates.html
https://qutip.org/docs/4.3/modules/qutip/qip/gates.html:18755,Energy Efficiency,reduce,reduce,18755,"bit,; using the presentation of the group given by Ross and Selinger; (http://www.mathstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2), _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if target >= N:; raise ValueError(""target must be integer < integer N""). return tensor([identity(2)] * (t",MatchSource.WIKI,docs/4.3/modules/qutip/qip/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qip/gates.html
https://qutip.org/docs/4.3/modules/qutip/qip/gates.html:18901,Energy Efficiency,reduce,reduce,18901,"hstat.dal.ca/~selinger/newsynth/). Parameters; -----------. N : int or None; Number of qubits on which each operator is to be defined; (default: 1).; target : int; Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2), _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if target >= N:; raise ValueError(""target must be integer < integer N""). return tensor([identity(2)] * (target) + [U] +; [identity(2)] * (N - target - 1)). [docs]def gate_expand_2toN(U, N, c",MatchSource.WIKI,docs/4.3/modules/qutip/qip/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qip/gates.html
https://qutip.org/docs/4.3/modules/qutip/qip/gates.html:19050,Energy Efficiency,reduce,reduce,19050," Index of the target qubit on which the single-qubit; Clifford operators are to act. Yields; ------. op : Qobj; Clifford operators, represented as Qobj instances. """""". # The Ross-Selinger presentation of the single-qubit Clifford; # group expresses each element in the form C_{ijk} = E^i X^j S^k; # for gates E, X and S, and for i in range(3), j in range(2) and; # k in range(4).; #; # We start by defining these gates. E is defined in terms of H,; # \omega and S, so we define \omega and H first.; w = np.exp(1j * 2 * np.pi / 8); H = snot(). X = sigmax(); S = phasegate(np.pi / 2); E = H * (S ** 3) * w ** 3. for op in map(partial(reduce, mul), product(_powers(E, 3),; _powers(X, 2), _powers(S, 4))):. # partial(reduce, mul) returns a function that takes products; # of its argument, by analogy to sum. Note that by analogy,; # sum can be written as partial(reduce, add). # product(...) yields the Cartesian product of its arguments.; # Here, each element is a tuple (E**i, X**j, S**k) such that; # partial(reduce, mul) acting on the tuple yields E**i * X**j * S**k. # Finally, we optionally expand the gate.; if N is not None:; yield gate_expand_1toN(op, N, target); else:; yield op. #; # Gate Expand; #. [docs]def gate_expand_1toN(U, N, target):; """"""; Create a Qobj representing a one-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; The one-qubit gate. N : integer; The number of qubits in the target space. target : integer; The index of the target qubit. Returns; -------; gate : qobj; Quantum object representation of N-qubit gate. """""". if N < 1:; raise ValueError(""integer N must be larger or equal to 1""). if target >= N:; raise ValueError(""target must be integer < integer N""). return tensor([identity(2)] * (target) + [U] +; [identity(2)] * (N - target - 1)). [docs]def gate_expand_2toN(U, N, control=None, target=None, targets=None):; """"""; Create a Qobj representing a two-qubit gate that act on a system with N; qubits. Parameters; ----------; U : Qobj; T",MatchSource.WIKI,docs/4.3/modules/qutip/qip/gates.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qip/gates.html
https://qutip.org/docs/4.3/modules/qutip/qip/qubits.html:2793,Deployability,update,updated,2793,"claimer in the; # documentation and/or other materials provided with the distribution.; #; # 3. Neither the name of the QuTiP: Quantum Toolbox in Python nor the names; # of its contributors may be used to endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['qubit_states']. from qutip.tensor import tensor; from numpy import sqrt; from qutip.states import basis. [docs]def qubit_states(N=1, states=[0]):; """"""; Function to define initial state of the qubits. Parameters; ----------; N : Integer; Number of qubits in the register.; states : List; Initial state of each qubit. Returns; ----------; qstates : Qobj; List of qubits. """"""; state_list = []; for i in range(N):; if N > len(states) and i >= len(states):; state_list.append(0); else:; state_list.append(states[i]). return tensor([alpha * basis(2, 1) + sqrt(1 - alpha**2) * basis(2, 0); for alpha in state_list]).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/qip/qubits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qip/qubits.html
https://qutip.org/docs/4.3/modules/qutip/qip/algorithms/qft.html:4591,Deployability,update,updated,4591,"pi / N2; arr = np.arange(N2); L, M = np.meshgrid(arr, arr); L = phase * (L * M); L = np.exp(L); dims = [[2] * N, [2] * N]; return Qobj(1.0 / np.sqrt(N2) * L, dims=dims). [docs]def qft_steps(N=1, swapping=True):; """"""; Quantum Fourier Transform operator on N qubits returning the individual; steps as unitary matrices operating from left to right. Parameters; ----------; N: int; Number of qubits.; swap: boolean; Flag indicating sequence of swap gates to be applied at the end or not. Returns; -------; U_step_list: list of qobj; List of Hadamard and controlled rotation gates implementing QFT. """"""; if N < 1:; raise ValueError(""Minimum value of N can be 1""). U_step_list = []; if N == 1:; U_step_list.append(snot()); else:; for i in range(N):; for j in range(i):; U_step_list.append(cphase(np.pi / (2 ** (i - j)), N,; control=i, target=j)); U_step_list.append(snot(N, i)); if swapping:; for i in range(N // 2):; U_step_list.append(swap(N, [N - i - 1, i])). return U_step_list. [docs]def qft_gate_sequence(N=1, swapping=True):; """"""; Quantum Fourier Transform operator on N qubits returning the gate sequence. Parameters; ----------; N: int; Number of qubits.; swap: boolean; Flag indicating sequence of swap gates to be applied at the end or not. Returns; -------; qc: instance of QubitCircuit; Gate sequence of Hadamard and controlled rotation gates implementing; QFT.; """""". if N < 1:; raise ValueError(""Minimum value of N can be 1""). qc = QubitCircuit(N); if N == 1:; qc.add_gate(""SNOT"", targets=[0]); else:; for i in range(N):; for j in range(i):; qc.add_gate(""CPHASE"", targets=[j], controls=[i],; arg_label=r""{\pi/2^{%d}}"" % (i - j),; arg_value=np.pi / (2 ** (i - j))); qc.add_gate(""SNOT"", targets=[i]); if swapping:; for i in range(N // 2):; qc.add_gate(""SWAP"", targets=[N - i - 1, i]). return qc.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/qip/algorithms/qft.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qip/algorithms/qft.html
https://qutip.org/docs/4.3/modules/qutip/qip/models/circuitprocessor.html:7243,Deployability,update,updated,7243,"The propagator matrix obtained from the physical implementation.; """"""; if states is None:; raise NotImplementedError(""Qubit state not defined.""); if qc:; self.load_circuit(qc); U_list = [states]; H_ops, H_u = self.get_ops_and_u(). for n in range(len(self.T_list)):; H = sum([H_u[n, m] * H_ops[m] for m in range(len(H_ops))]); U = (-1j * H * self.T_list[n]).expm(); U = self.eliminate_auxillary_modes(U); U_list.append(U). if self.correct_global_phase and self.global_phase != 0:; U_list.append(globalphase(self.global_phase, N=self.N)). return U_list. [docs] def pulse_matrix(self):; """"""; Generates the pulse matrix for the desired physical system. Returns; --------; t, u, labels:; Returns the total time and label for every operation.; """"""; dt = 0.01; H_ops, H_u = self.get_ops_and_u(). t_tot = sum(self.T_list); n_t = int(np.ceil(t_tot / dt)); n_ops = len(H_ops). t = np.linspace(0, t_tot, n_t); u = np.zeros((n_ops, n_t)). t_start = 0; for n in range(len(self.T_list)):. t_idx_len = int(np.floor(self.T_list[n] / dt)). mm = 0; for m in range(len(H_ops)):; u[mm, t_start:(t_start + t_idx_len)] = (np.ones(t_idx_len) *; H_u[n, m]); mm += 1. t_start += t_idx_len. return t, u, self.get_ops_labels(). [docs] def plot_pulses(self):; """"""; Maps the physical interaction between the circuit components for the; desired physical system. Returns; --------; fig, ax: Figure; Maps the physical interaction between the circuit components.; """"""; import matplotlib.pyplot as plt; t, u, u_labels = self.pulse_matrix(); fig, ax = plt.subplots(1, 1, figsize=(12, 6)). for n, uu in enumerate(u):; ax.plot(t, u[n], label=u_labels[n]). ax.axis('tight'); ax.set_ylim(-1.5 * 2 * np.pi, 1.5 * 2 * np.pi); ax.legend(loc='center left',; bbox_to_anchor=(1, 0.5), ncol=(1 + len(u) // 16)); fig.tight_layout(). return fig, ax.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/qip/models/circuitprocessor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qip/models/circuitprocessor.html
https://qutip.org/docs/4.3/modules/qutip/qip/models/cqed.html:9294,Deployability,update,updated,9294,"argets[0]], None,; arg_value=-np.pi / 2,; arg_label=r""-\pi/2"")); qc.gates.append(Gate(""RZ"", [gate.targets[1]], None,; arg_value=-np.pi / 2,; arg_label=r""-\pi/2"")); qc.gates.append(Gate(""GLOBALPHASE"", None, None,; arg_value=-np.pi / 2,; arg_label=r""-\pi/2"")). return qc. [docs] def load_circuit(self, qc):. gates = self.optimize_circuit(qc).gates. self.global_phase = 0; self.sx_u = np.zeros((len(gates), len(self.sx_ops))); self.sz_u = np.zeros((len(gates), len(self.sz_ops))); self.g_u = np.zeros((len(gates), len(self.cavityqubit_ops))); self.T_list = []. n = 0; for gate in gates:. if gate.name == ""ISWAP"":; t0, t1 = gate.targets[0], gate.targets[1]; self.sz_u[n, t0] = self.wq[t0] - self.w0; self.sz_u[n, t1] = self.wq[t1] - self.w0; self.g_u[n, t0] = self.g[t0]; self.g_u[n, t1] = self.g[t1]. J = self.g[t0] * self.g[t1] * (1 / self.Delta[t0] +; 1 / self.Delta[t1]) / 2; T = (4 * np.pi / abs(J)) / 4; self.T_list.append(T); n += 1. elif gate.name == ""SQRTISWAP"":; t0, t1 = gate.targets[0], gate.targets[1]; self.sz_u[n, t0] = self.wq[t0] - self.w0; self.sz_u[n, t1] = self.wq[t1] - self.w0; self.g_u[n, t0] = self.g[t0]; self.g_u[n, t1] = self.g[t1]. J = self.g[t0] * self.g[t1] * (1 / self.Delta[t0] +; 1 / self.Delta[t1]) / 2; T = (4 * np.pi / abs(J)) / 8; self.T_list.append(T); n += 1. elif gate.name == ""RZ"":; g = self.sz_coeff[gate.targets[0]]; self.sz_u[n, gate.targets[0]] = np.sign(gate.arg_value) * g; T = abs(gate.arg_value) / (2 * g); self.T_list.append(T); n += 1. elif gate.name == ""RX"":; g = self.sx_coeff[gate.targets[0]]; self.sx_u[n, gate.targets[0]] = np.sign(gate.arg_value) * g; T = abs(gate.arg_value) / (2 * g); self.T_list.append(T); n += 1. elif gate.name == ""GLOBALPHASE"":; self.global_phase += gate.arg_value. else:; raise ValueError(""Unsupported gate %s"" % gate.name).  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/qip/models/cqed.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qip/models/cqed.html
https://qutip.org/docs/4.3/modules/qutip/qip/models/cqed.html:2663,Energy Efficiency,energy,energy,2663,"MPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; import numpy as np; import warnings; from qutip import tensor, identity, destroy, sigmax, sigmaz, basis; from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.models.circuitprocessor import CircuitProcessor. [docs]class DispersivecQED(CircuitProcessor):; """"""; Representation of the physical implementation of a quantum; program/algorithm on a dispersive cavity-QED system.; """""". def __init__(self, N, correct_global_phase=True, Nres=None, deltamax=None,; epsmax=None, w0=None, wq=None, eps=None, delta=None, g=None):; """"""; Parameters; ----------; Nres: Integer; The number of energy levels in the resonator. deltamax: Integer/List; The sigma-x coefficient for each of the qubits in the system. epsmax: Integer/List; The sigma-z coefficient for each of the qubits in the system. wo: Integer; The base frequency of the resonator. wq: Integer/List; The frequency of the qubits. eps: Integer/List; The epsilon for each of the qubits in the system. delta: Integer/List; The epsilon for each of the qubits in the system. g: Integer/List; The interaction strength for each of the qubit with the resonator.; """""". super(DispersivecQED, self).__init__(N, correct_global_phase). # user definable; if Nres is None:; self.Nres = 10; else:; self.Nres = Nres. if deltamax is None:; self.sx_coeff = np.array([1.0 * 2 * np.pi] * N); elif not isinstance(deltamax, list):; self.sx_coeff = np.array([deltamax * 2 * np.pi] * N); else:; self.sx_coeff = np.array(deltamax). if epsmax is None:; self.sz_coeff = np.arr",MatchSource.WIKI,docs/4.3/modules/qutip/qip/models/cqed.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qip/models/cqed.html
https://qutip.org/docs/4.3/modules/qutip/qip/models/cqed.html:4892,Testability,test,tests,4892,"):; self.eps = np.array([eps * 2 * np.pi] * N); else:; self.eps = np.array(eps). if delta is None:; self.delta = np.array([0.0 * 2 * np.pi] * N); elif not isinstance(delta, list):; self.delta = np.array([delta * 2 * np.pi] * N); else:; self.delta = np.array(delta). if g is None:; self.g = np.array([0.01 * 2 * np.pi] * N); elif not isinstance(g, list):; self.g = np.array([g * 2 * np.pi] * N); else:; self.g = np.array(g). if wq is not None:; if not isinstance(wq, list):; self.wq = np.array([wq] * N); else:; self.wq = np.array(wq). if wq is None:; if eps is None:; self.eps = np.array([9.5 * 2 * np.pi] * N); elif not isinstance(eps, list):; self.eps = np.array([eps] * N); else:; self.eps = np.array(eps). if delta is None:; self.delta = np.array([0.0 * 2 * np.pi] * N); elif not isinstance(delta, list):; self.delta = np.array([delta] * N); else:; self.delta = np.array(delta). # computed; self.wq = np.sqrt(self.eps ** 2 + self.delta ** 2); self.Delta = self.wq - self.w0. # rwa/dispersive regime tests; if any(self.g / (self.w0 - self.wq) > 0.05):; warnings.warn(""Not in the dispersive regime""). if any((self.w0 - self.wq) / (self.w0 + self.wq) > 0.05):; warnings.warn(; ""The rotating-wave approximation might not be valid.""). self.sx_ops = [tensor([identity(self.Nres)] +; [sigmax() if m == n else identity(2); for n in range(N)]); for m in range(N)]; self.sz_ops = [tensor([identity(self.Nres)] +; [sigmaz() if m == n else identity(2); for n in range(N)]); for m in range(N)]. self.a = tensor([destroy(self.Nres)] + [identity(2) for n in range(N)]). self.cavityqubit_ops = []; for n in range(N):; sm = tensor([identity(self.Nres)] +; [destroy(2) if m == n else identity(2); for m in range(N)]); self.cavityqubit_ops.append(self.a.dag() * sm + self.a * sm.dag()). self.psi_proj = tensor([basis(self.Nres, 0)] +; [identity(2) for n in range(N)]). [docs] def get_ops_and_u(self):; H0 = self.a.dag() * self.a; return ([H0] + self.sx_ops + self.sz_ops + self.cavityqubit_ops,; np.hstack((self.w0 ",MatchSource.WIKI,docs/4.3/modules/qutip/qip/models/cqed.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qip/models/cqed.html
https://qutip.org/docs/4.3/modules/qutip/qip/models/spinchain.html:12574,Deployability,update,updated,12574,"It is a sub-class of SpinChain.; """""". def __init__(self, N, correct_global_phase=True,; sx=None, sz=None, sxsy=None):. super(LinearSpinChain, self).__init__(N, correct_global_phase,; sx, sz, sxsy). [docs] def get_ops_labels(self):; return ([r""$\sigma_x^%d$"" % n for n in range(self.N)] +; [r""$\sigma_z^%d$"" % n for n in range(self.N)] +; [r""$\sigma_x^%d\sigma_x^{%d} + \sigma_y^%d\sigma_y^{%d}$""; % (n, n, n + 1, n + 1) for n in range(self.N - 1)]). [docs] def optimize_circuit(self, qc):; self.qc0 = qc; self.qc1 = self.adjacent_gates(self.qc0, ""linear""); self.qc2 = self.qc1.resolve_gates(basis=[""ISWAP"", ""RX"", ""RZ""]); return self.qc2. [docs]class CircularSpinChain(SpinChain):; """"""; Representation of the physical implementation of a quantum; program/algorithm on a spin chain qubit system arranged in a circular; formation. It is a sub-class of SpinChain.; """""". def __init__(self, N, correct_global_phase=True,; sx=None, sz=None, sxsy=None):. super(CircularSpinChain, self).__init__(N, correct_global_phase,; sx, sz, sxsy). x = [identity(2)] * N; x[0] = x[N - 1] = sigmax(); y = [identity(2)] * N; y[0] = y[N - 1] = sigmay(); self.sxsy_ops.append(tensor(x) + tensor(y)). if sxsy is None:; self.sxsy_coeff = [0.1 * 2 * np.pi] * N; elif not isinstance(sxsy, list):; self.sxsy_coeff = [sxsy * 2 * np.pi] * N; else:; self.sxsy_coeff = sxsy. [docs] def get_ops_labels(self):; return ([r""$\sigma_x^%d$"" % n for n in range(self.N)] +; [r""$\sigma_z^%d$"" % n for n in range(self.N)] +; [r""$\sigma_x^%d\sigma_x^{%d} + \sigma_y^%d\sigma_y^{%d}$""; % (n, n, (n + 1) % self.N, (n + 1) % self.N); for n in range(self.N)]). [docs] def optimize_circuit(self, qc):; self.qc0 = qc; self.qc1 = self.adjacent_gates(self.qc0, ""circular""); self.qc2 = self.qc1.resolve_gates(basis=[""ISWAP"", ""RX"", ""RZ""]); return self.qc2.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/modules/qutip/qip/models/spinchain.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/modules/qutip/qip/models/spinchain.html
https://qutip.org/docs/4.4/apidoc/apidoc.html:1914,Deployability,update,updated,1914," . API documentation  QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; API documentation; Classes; Functions. Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs ; API documentation. API documentation; This chapter contains automatically generated API documentation, including a; complete list of QuTiPs public classes and functions. Classes; Qobj; QobjEvo; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results. Permutational Invariance; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Dynamics and Time-Evolution; Schrdinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrdinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Next ; Previous.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,docs/4.4/apidoc/apidoc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/apidoc.html
https://qutip.org/docs/4.4/apidoc/apidoc.html:1307,Integrability,depend,dependent,1307," . API documentation  QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; API documentation; Classes; Functions. Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs ; API documentation. API documentation; This chapter contains automatically generated API documentation, including a; complete list of QuTiPs public classes and functions. Classes; Qobj; QobjEvo; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results. Permutational Invariance; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Dynamics and Time-Evolution; Schrdinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrdinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Next ; Previous.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,docs/4.4/apidoc/apidoc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/apidoc.html
https://qutip.org/docs/4.4/apidoc/classes.html:6220,Availability,toler,tolerance,6220,"itian,; otherwise complex values are returned. dnorm(self, B=None)[source]; Calculates the diamond norm, or the diamond distance to another; operator. Parameters. Bqutip.Qobj or NoneIf B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns. dfloatEither the diamond norm of this operator, or the diamond distance; from this operator to B. dual_chan(self)[source]; Dual channel of quantum object representing a completely positive; map. eigenenergies(self, sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues low to high, or high to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(self, sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) low to high, or high to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. eigvecsarrayArray of quantum operators representin",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:7002,Availability,toler,tolerance,7002," eigenvalues low to high, or high to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(self, sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) low to high, or high to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. eigvecsarrayArray of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(self, states_inds, normalize=False)[source]; Creates a new quantum object with states in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:8968,Availability,avail,available,8968," the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, sin(w * t)]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[w] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(self, method='dense')[source]; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {dense, sparse}Use set method to use to calculate the matrix exponentiation. The; available choices includes dense and sparse. Since the; exponential of a matrix is nearly always dense, method=dense; is set as default.s. Returns. operqutip.QobjExponentiated quantum operator. Raises. TypeErrorQuantum operator is not square. extract_states(self, states_inds, normalize=False)[source]; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(self, order='C', squeeze=False)[source]; Dense array from quantum object. Parameters. orderstr {C, F}Return array in C (default) or Fortran order",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:10449,Availability,toler,tolerance,10449,"nce should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(self, order='C', squeeze=False)[source]; Dense array from quantum object. Parameters. orderstr {C, F}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True)[source]; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(self, bra, ket)[source]; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type bra or ket. ketqutip.QobjQuantum object of type ket. Returns. elemcomplexComplex valued matrix element. norm(self, norm=None, sparse=False, tol=0, maxiter=100000)[source]; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters. nor",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:11789,Availability,toler,tolerance,11789," is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(self, bra, ket)[source]; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type bra or ket. ketqutip.QobjQuantum object of type ket. Returns. elemcomplexComplex valued matrix element. norm(self, norm=None, sparse=False, tol=0, maxiter=100000)[source]; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters. normstrWhich norm to use for ket/bra vectors: L2 l2, max norm max,; or for operators: trace tr, Frobius fro, one one, or max; max. sparseboolUse sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tolfloatTolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used); for trace norm. Returns. normfloatThe requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(self, other)[source]; Overlap between two state vectors or two operators.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters. otherqutip.QobjQuantum object for a state vector of type ket, bra or density; matrix. Returns. overlapcomplexComplex valued overlap. Raises. TypeErrorCan only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|ot",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:14337,Availability,toler,tolerance,14337," representing partial trace with selected components; remaining. Notes; This function is identical to the qutip.qobj.ptrace function; that has been deprecated. sinm(self)[source]; Sine of a quantum operator.; Operator must be square. Returns. operqutip.QobjMatrix sine of operator. Raises. TypeErrorQuantum object is not square. Notes; Uses the Q.expm() method. sqrtm(self, sparse=False, tol=0, maxiter=100000)[source]; Sqrt of a quantum operator.; Operator must be square. Parameters. sparseboolUse sparse eigenvalue/vector solver. tolfloatTolerance used by sparse solver (0 = machine precision). maxiterintMaximum number of iterations used by sparse solver. Returns. operqutip.QobjMatrix square root of operator. Raises. TypeErrorQuantum object is not square. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. tidyup(self, atol=1e-12)[source]; Removes small elements from the quantum object. Parameters. atolfloatAbsolute tolerance used by tidyup. Default is set; via qutip global settings parameters. Returns. operqutip.QobjQuantum object with small elements removed. tr(self)[source]; Trace of a quantum object. Returns. tracefloatReturns real if operator is Hermitian, returns complex; otherwise. trans(self)[source]; Transposed operator. Returns. operqutip.QobjTranspose of input operator. transform(self, inpt, inverse=False, sparse=True)[source]; Basis transform defined by input array.; Input array can be a matrix defining the transformation,; or a list of kets that defines the new basis. Parameters. inptarray_likeA matrix or list of kets defining the transformation. inverseboolWhether to return inverse transformation. sparseboolUse sparse matrices when possible. Can be slower. Returns. operqutip.QobjOperator in new basis. Notes; This function is still in development. trunc_neg(self, method='clip')[source]; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eige",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:39361,Availability,toler,tolerance,39361,"unction. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes. atolfloat {1e-8}Absolute tolerance. rtolfloat {1e-6}Relative tolerance. methodstr {adams,bdf}Integration method. orderint {12}Order of integrator (<=12 adams, <=5 bdf). nstepsint {2500}Max. number of internal steps/call. first_stepfloat {0}Size of initial step (0 = automatic). min_stepfloat {0}Minimum step size (0 = automatic). max_stepfloat {0}Maximum step size (0 = automatic). tidybool {True,False}Tidyup Hamiltonian and initial state by removing small terms. num_cpusintNumber of cpus used by mcsolver (default = # of cpus). norm_tolfloatTolerance used when finding wavefunction norm in mcsolve. norm_stepsintMax. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_statesbool {False}Average states values over trajectories in stochastic solvers. average_expectbool {True}Average expectation values over trajectories for stochastic solvers. mc_corr_epsfloat {1e-10}Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when usi",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:39397,Availability,toler,tolerance,39397,"ting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes. atolfloat {1e-8}Absolute tolerance. rtolfloat {1e-6}Relative tolerance. methodstr {adams,bdf}Integration method. orderint {12}Order of integrator (<=12 adams, <=5 bdf). nstepsint {2500}Max. number of internal steps/call. first_stepfloat {0}Size of initial step (0 = automatic). min_stepfloat {0}Minimum step size (0 = automatic). max_stepfloat {0}Maximum step size (0 = automatic). tidybool {True,False}Tidyup Hamiltonian and initial state by removing small terms. num_cpusintNumber of cpus used by mcsolver (default = # of cpus). norm_tolfloatTolerance used when finding wavefunction norm in mcsolve. norm_stepsintMax. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_statesbool {False}Average states values over trajectories in stochastic solvers. average_expectbool {True}Average expectation values over trajectories for stochastic solvers. mc_corr_epsfloat {1e-10}Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntrajint {500}Number of ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:40309,Availability,error,errors,40309,"options in evolution solvers. Attributes. atolfloat {1e-8}Absolute tolerance. rtolfloat {1e-6}Relative tolerance. methodstr {adams,bdf}Integration method. orderint {12}Order of integrator (<=12 adams, <=5 bdf). nstepsint {2500}Max. number of internal steps/call. first_stepfloat {0}Size of initial step (0 = automatic). min_stepfloat {0}Minimum step size (0 = automatic). max_stepfloat {0}Maximum step size (0 = automatic). tidybool {True,False}Tidyup Hamiltonian and initial state by removing small terms. num_cpusintNumber of cpus used by mcsolver (default = # of cpus). norm_tolfloatTolerance used when finding wavefunction norm in mcsolve. norm_stepsintMax. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_statesbool {False}Average states values over trajectories in stochastic solvers. average_expectbool {True}Average expectation values over trajectories for stochastic solvers. mc_corr_epsfloat {1e-10}Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntrajint {500}Number of trajectories in stochastic solvers. openmp_threadsintNumber of OPENMP threads to use. Default is number of cpu cores. rhs_reusebool {False,True}Reuse Hamiltonian data. rhs_with_statebool {False,True}Whether or not to include the state in the Hamiltonian function; callback signature. rhs_filenamestrName for compiled Cython file. seedsndarrayArray containing random number seeds for mcsolver. store_final_statebool {False, True}Whether or not to store the final state of the evolution in the; result class. store_statesbool {False, True}Whether or not to store the state vectors or density matrices in the; result class, even if expectation values operators are given. If no; expectation are provided, then states are stored by default and this; option has no effect. use_openmpbool {True, False}Use OPENMP for sparse matrix vector multiplication. Default; None means auto check. class Result[source]; Cla",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:49059,Availability,toler,tolerance,49059,"qutip.QobjList of operators representing the measurement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. argsdictDictionary of parameters for time dependent systems. tolfloatTolerance of the solver for implicit methods. ntrajintNumber of trajectors. nsubstepsintNumber of sub steps between each time-spep given in times. dW_factorsarrayArray of length len(sc_ops), containing scaling factors for each; measurement operator in m_ops. solverstringName of the solver method to use for solving the stochastic; equations. Valid values are:; order 1/2 algorithms: euler-maruyama, pc-euler, pc-euler-imp; order 1 algorithms: milstein, platen, milstein-imp, rouchon; order 3/2 algorithms: taylor1.5, taylor1.5-imp, explicit1.5; order 2 algorithms: taylor2.0; call help of qutip.stochastic.stochastic_solvers; for a description of the solvers.; Implicit methods can adjust tolerance via the kw tol; default is {tol:1e-6}. methodstring (homodyne, heterodyne)The name of the type of measurement process that give rise to the; stochastic equation to solve. store_all_expectbool (default False)Whether or not to store the e_ops expect values for all paths. store_measurementbool (default False)Whether or not to store the measurement results in the; qutip.solver.Result instance returned by the solver. noiseint, array[int, 1d], array[double, 4d]int : seed of the noise; array[int, 1d], length = ntraj, seeds for each trajectories; array[double, 4d] (ntraj, len(times), nsubsteps, len(sc_ops)*[1|2]). vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. The correspond to results.noise. noiseDepthintNumber of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalizebool(default True for (photo)ssesolve, False for (photo)smesolve); Whether or not to normalize the wave function during the evolution.; ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:50119,Availability,error,errors,50119," {tol:1e-6}. methodstring (homodyne, heterodyne)The name of the type of measurement process that give rise to the; stochastic equation to solve. store_all_expectbool (default False)Whether or not to store the e_ops expect values for all paths. store_measurementbool (default False)Whether or not to store the measurement results in the; qutip.solver.Result instance returned by the solver. noiseint, array[int, 1d], array[double, 4d]int : seed of the noise; array[int, 1d], length = ntraj, seeds for each trajectories; array[double, 4d] (ntraj, len(times), nsubsteps, len(sc_ops)*[1|2]). vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. The correspond to results.noise. noiseDepthintNumber of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalizebool(default True for (photo)ssesolve, False for (photo)smesolve); Whether or not to normalize the wave function during the evolution.; Normalizing density matrices introduce numerical errors. optionsqutip.solver.OptionsGeneric solver options. Only options.average_states and; options.store_states are used. map_func: functionA map function or managing the calls to single-trajactory solvers. map_kwargs: dictionaryOptional keyword arguments to the map_func function function. progress_barqutip.ui.BaseProgressBarOptional progress bar class instance. *; time-dependent Qobj can be used for H, c_ops and sc_ops.; The format for time-dependent system hamiltonian is:; H = [Qobj0,[Qobj1,coeff1],[Qobj2,coeff2],]= Qobj0 + Qobj1 * coeff1(t) + Qobj2 * coeff2(t). coeff function can be:function: coeff(t, args) -> complex; str: sin(1j*w*t); np.array[complex, 1d] of length equal to the times array. The argument args for the function coeff is the args keyword argument ofthe stochastic solver. Likewisem in str cases, the parameters (w in this case) are taken fromthe args keywords argument. *While mixing coeff type does not results in errors, it is not recommende",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:51069,Availability,error,errors,51069,"lution.; Normalizing density matrices introduce numerical errors. optionsqutip.solver.OptionsGeneric solver options. Only options.average_states and; options.store_states are used. map_func: functionA map function or managing the calls to single-trajactory solvers. map_kwargs: dictionaryOptional keyword arguments to the map_func function function. progress_barqutip.ui.BaseProgressBarOptional progress bar class instance. *; time-dependent Qobj can be used for H, c_ops and sc_ops.; The format for time-dependent system hamiltonian is:; H = [Qobj0,[Qobj1,coeff1],[Qobj2,coeff2],]= Qobj0 + Qobj1 * coeff1(t) + Qobj2 * coeff2(t). coeff function can be:function: coeff(t, args) -> complex; str: sin(1j*w*t); np.array[complex, 1d] of length equal to the times array. The argument args for the function coeff is the args keyword argument ofthe stochastic solver. Likewisem in str cases, the parameters (w in this case) are taken fromthe args keywords argument. *While mixing coeff type does not results in errors, it is not recommended.*; For the collapse operators (c_ops, sc_ops):; Each operators can only be composed of 1 Qobj.; c_ops = [c_op1, c_op2, ]; where, c_opN = Qobj or [Qobj,coeff]; The coeff format is the same as for the Hamiltonian. Permutational Invariance. class Dicke(N, hamiltonian=None, emission=0.0, dephasing=0.0, pumping=0.0, collective_emission=0.0, collective_dephasing=0.0, collective_pumping=0.0)[source]; The Dicke class which builds the Lindbladian and Liouvillian matrix. Parameters. N: intThe number of two-level systems. hamiltonianqutip.QobjA Hamiltonian in the Dicke basis.; The matrix dimensions are (nds, nds),; with nds being the number of Dicke states.; The Hamiltonian can be built with the operators; given by the jspin functions. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:74296,Availability,error,error,74296," of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. algstringAlgorithm to use in pulse optimisation.; Options are:. GRAPE (default) - GRadient Ascent Pulse Engineering; CRAB - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_gradboolIf set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:78431,Availability,error,error,78431,"ute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping. The level of data dumping that will occur during the optimisation; NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(self, *args)[source]; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation al",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:78809,Availability,error,error,78809,"the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping. The level of data dumping that will occur during the optimisation; NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(self, *args)[source]; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimi",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:78992,Availability,error,error,78992,". property dumping. The level of data dumping that will occur during the optimisation; NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(self, *args)[source]; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]; Check the elapsed wall time",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:80258,Availability,error,error,80258," n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(self, term_conds=None)[source]; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]; Implements the run_optimization method using the BFGS algor",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:81446,Availability,error,error,81446,"ime, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]; Implements the run_optimization method using the BFGS algorithm. run_optimization(self, term_conds=None)[source]; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenFletcherGoldfarbShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:82814,Availability,error,error,82814,"bute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(self, term_conds=None)[source]; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1].; It use",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:84007,Availability,error,error,84007,"f the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(self, term_conds=None)[source]; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise th",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:84575,Availability,error,error,84575,"e; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(self, term_conds=None)[source]; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It wil",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:85025,Availability,error,error,85025,"self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(self, term_conds=None)[source]; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]; A summary of the most recent iteration of the pulse optimisation. Attributes. iter_numintIteration number of the pulse optimisation. fid_func_call_numintFidelity function call number of the pulse optimisation. grad_func_call_numintGradient function call number of the pulse optimisation. fid_errfloatFidelity error",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:86115,Availability,error,error,86115,"s which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]; A summary of the most recent iteration of the pulse optimisation. Attributes. iter_numintIteration number of the pulse optimisation. fid_func_call_numintFidelity function call number of the pulse optimisation. grad_func_call_numintGradient function call number of the pulse optimisation. fid_errfloatFidelity error. grad_normfloatfidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_timefloatTime spent computing the pulse optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes. fid_err_targfloatTarget fidelity error. fid_goalfloatgoal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_timefloat# maximum time for optimisation (seconds). min_gradient_normfloatMinimum normalised gradient after which optimisation will terminate. max_iterationsintegerMaximum iterations of the optimisation algorithm. max_fid_func_callsintegerMaximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.;",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:86604,Availability,error,error,86604,"It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]; A summary of the most recent iteration of the pulse optimisation. Attributes. iter_numintIteration number of the pulse optimisation. fid_func_call_numintFidelity function call number of the pulse optimisation. grad_func_call_numintGradient function call number of the pulse optimisation. fid_errfloatFidelity error. grad_normfloatfidelity gradient (wrt the control parameters) vector norm; that is the magnitude of the gradient. wall_timefloatTime spent computing the pulse optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes. fid_err_targfloatTarget fidelity error. fid_goalfloatgoal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_timefloat# maximum time for optimisation (seconds). min_gradient_normfloatMinimum normalised gradient after which optimisation will terminate. max_iterationsintegerMaximum iterations of the optimisation algorithm. max_fid_func_callsintegerMaximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]; Attributes give the result of the pulse optimisation attempt. Attribut",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:87767,Availability,error,error,87767,"onds). min_gradient_normfloatMinimum normalised gradient after which optimisation will terminate. max_iterationsintegerMaximum iterations of the optimisation algorithm. max_fid_func_callsintegerMaximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]; Attributes give the result of the pulse optimisation attempt. Attributes. termination_reasonstringDescription of the reason for terminating the optimisation. fidelityfloatfinal (normalised) fidelity that was achieved. initial_fid_errfloatfidelity error before optimisation starting. fid_errfloatfinal fidelity error that was achieved. goal_achievedbooleanTrue is the fidely error achieved was below the target. grad_norm_finalfloatFinal value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reachedfloatTrue if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exceededbooleanTrue if the iteration limit was reached. max_fid_func_exceededbooleanTrue if the fidelity function call limit was reached. wall_timefloattime elapsed during the optimisation. wall_time_limit_exceededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:87830,Availability,error,error,87830,"ter which optimisation will terminate. max_iterationsintegerMaximum iterations of the optimisation algorithm. max_fid_func_callsintegerMaximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]; Attributes give the result of the pulse optimisation attempt. Attributes. termination_reasonstringDescription of the reason for terminating the optimisation. fidelityfloatfinal (normalised) fidelity that was achieved. initial_fid_errfloatfidelity error before optimisation starting. fid_errfloatfinal fidelity error that was achieved. goal_achievedbooleanTrue is the fidely error achieved was below the target. grad_norm_finalfloatFinal value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reachedfloatTrue if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exceededbooleanTrue if the iteration limit was reached. max_fid_func_exceededbooleanTrue if the fidelity function call limit was reached. wall_timefloattime elapsed during the optimisation. wall_time_limit_exceededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution o",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:87894,Availability,error,error,87894,"mum iterations of the optimisation algorithm. max_fid_func_callsintegerMaximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]; Attributes give the result of the pulse optimisation attempt. Attributes. termination_reasonstringDescription of the reason for terminating the optimisation. fidelityfloatfinal (normalised) fidelity that was achieved. initial_fid_errfloatfidelity error before optimisation starting. fid_errfloatfinal fidelity error that was achieved. goal_achievedbooleanTrue is the fidely error achieved was below the target. grad_norm_finalfloatFinal value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reachedfloatTrue if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exceededbooleanTrue if the iteration limit was reached. max_fid_func_exceededbooleanTrue if the fidelity function call limit was reached. wall_timefloattime elapsed during the optimisation. wall_time_limit_exceededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initia",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:88019,Availability,error,error,88019,"alls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]; Attributes give the result of the pulse optimisation attempt. Attributes. termination_reasonstringDescription of the reason for terminating the optimisation. fidelityfloatfinal (normalised) fidelity that was achieved. initial_fid_errfloatfidelity error before optimisation starting. fid_errfloatfinal fidelity error that was achieved. goal_achievedbooleanTrue is the fidely error achieved was below the target. grad_norm_finalfloatFinal value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reachedfloatTrue if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exceededbooleanTrue if the iteration limit was reached. max_fid_func_exceededbooleanTrue if the fidelity function call limit was reached. wall_timefloattime elapsed during the optimisation. wall_time_limit_exceededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initialQobjThe evolution operator from t=0 to t=T based on the initial amps. statsStatsObject con",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:91007,Availability,error,error,91007,"es of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom)",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:91030,Availability,error,error,91030,"es of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom)",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:107092,Availability,error,error,107092,"hat the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evobooleanflag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evoboolean; flag to specify whether the onto_evo evolution operator(see Dynamics) is used by the FidelityComputer. fid_errfloatLast computed value of the fidelity error. fidelityfloatLast computed value of the normalised fidelity. fidelity_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of floatLast computed values for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clea",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:107396,Availability,error,error,107396,"tion,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evobooleanflag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evoboolean; flag to specify whether the onto_evo evolution operator(see Dynamics) is used by the FidelityComputer. fid_errfloatLast computed value of the fidelity error. fidelityfloatLast computed value of the normalised fidelity. fidelity_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of floatLast computed values for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear(self)[source]; clear any temporarily held status data. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient(self)[source]; Returns the normalised g",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:107509,Availability,error,error,107509," file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evobooleanflag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evoboolean; flag to specify whether the onto_evo evolution operator(see Dynamics) is used by the FidelityComputer. fid_errfloatLast computed value of the fidelity error. fidelityfloatLast computed value of the normalised fidelity. fidelity_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of floatLast computed values for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear(self)[source]; clear any temporarily held status data. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp(self)[source];",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:108400,Availability,error,error,108400," error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear(self)[source]; clear any temporarily held status data. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear(self)[source]; clear any temporarily held ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:108740,Availability,error,error,108740,"lf, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear(self)[source]; clear any temporarily held status data. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear(self)[source]; clear any temporarily held status data. compute_fid_grad(self)[source]; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[sour",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:109752,Availability,error,error,109752," error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear(self)[source]; clear any temporarily held status data. compute_fid_grad(self)[source]; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity(self)[source]; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm(self)[source]; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp(self)[source]; Check configuration and initialise the normalisation. init_normalization(self)[source]; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:109860,Availability,error,error,109860,"phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear(self)[source]; clear any temporarily held status data. compute_fid_grad(self)[source]; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity(self)[source]; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm(self)[source]; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp(self)[source]; Check configuration and initialise the normalisation. init_normalization(self)[source]; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:111661,Availability,error,error,111661,"e equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(self, A)[source]. normalize_SU(self, A)[source]. normalize_gradient_PSU(self, grad)[source]; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(self, grad)[source]; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. set_phase_option(self, phase_option=None)[source]; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad(self)[source]; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err(self",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:111741,Availability,error,error,111741,"e equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(self, A)[source]. normalize_SU(self, A)[source]. normalize_gradient_PSU(self, grad)[source]; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(self, grad)[source]; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. set_phase_option(self, phase_option=None)[source]; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad(self)[source]; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err(self",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:112219,Availability,error,error,112219,"d)[source]; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. set_phase_option(self, phase_option=None)[source]; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad(self)[source]; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset(self)[source]; r",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:112310,Availability,error,error,112310,"nd; clear any temporarily held status data. set_phase_option(self, phase_option=None)[source]; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad(self)[source]; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]; As FidCompTrace",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:112567,Availability,error,error,112567," global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad(self)[source]; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a time",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:112766,Availability,error,error,112766," trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad(self)[source]; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad(self)[source]; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; Th",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:112874,Availability,error,error,112874,"re for dynamics described by matrices; Note the gradient calculation is taken from:; Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad(self)[source]; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad(self)[source]; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class TimeslotCompute",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:127542,Availability,error,error,127542,"ll_time_optim_startfloatStart time for the optimisation. wall_time_optim_endfloatEnd time for the optimisation. wall_time_optimfloatTime elasped during the optimisation. wall_time_dyn_gen_computefloatTotal wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_computefloatTotal wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_computefloatTotal wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating the propagators themselves. wall_time_onwd_prop_computefloatTotal wall (elasped) time computing combined onward propagation,; that is the time evolution from a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_computefloatTotal wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_callsintegerNumber of calls to fidelity function by the optimisation algorithm. num_grad_func_callsintegerNumber of calls to gradient function by the optimisation algorithm. num_tslot_recomputeintegerNumber of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computesintegerNumber of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computesintegerNumber of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updatesintegerNumber of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iterfloatMean number of control amplitude updates per iteration. num_timeslot_changesintegerNumber of times the amplitudes of a any control in a timeslot",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:131306,Availability,error,error,131306,"elimiter for the summary file.; default is a space. data_sepstrdelimiter for the data files (arrays saved to file).; default is a space. summary_filestrFile path for summary file.; Automatically generated. Can be set specifically. create_dump_dir(self)[source]; Checks dump directory exists, creates it if not. property level. The level of data dumping that will occur; SUMMARY : A summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary(self)[source]; add copy of current optimizer iteration summary. property dump_all; True if everything (ignoring the summary) is to be dumped. property dump_any; True if anything other than the summary is to be dumped. update_fid_err_log(self, fid_err)[source]; add an entry to the fid_err log. update_grad_log(self, grad)[source]; add an entry to the grad log. update_grad_norm_log(self, grad_norm)[source]; add an entry to the grad_norm log. writeout(self, f=None)[source]; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:17997,Deployability,update,update,17997,"args[w2]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={w1:1., w2:2.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. sin cos tan asin acos atan pi; sinh cosh tanh asinh acosh atanh; exp log log10 erf zerf sqrt; real imag conj abs norm arg proj; numpy as np, and scipy.special as spe. Examples; H = QobjEvo([H0, [H1, exp(-1j*w1*t)], [H2, cos(w2*t)]],args={w1:1.,w2:2.}). For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; Examples. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],. tlist=tlist). args is a dict of (name:object). The name must be a valid variables string.; Some solvers support arguments that update at each call:; sesolve, mesolve, mcsolve:. state can be obtained with:name+=vec:Qobj => args[name] == state as 1D np.ndarray; name+=mat:Qobj => args[name] == state as 2D np.ndarray; name+=Qobj:Qobj => args[name] == state as Qobj; This Qobj is the initial value. expectation values:name+=expect:O (Qobj/QobjEvo) => args[name] == expect(O, state); expect is <phi|O|psi> or tr(state * O) depending on state dimensions. mcsolve:; collapse can be obtained with:name+=collapse:list => args[name] == list of collapse; each collapse will be appended to the list as (time, which c_ops). Mixing the formats is possible, but not recommended.; Mixing tlist will cause problem. Parameters. QobjEvo(Q_object=[], args={}, tlist=None); Q_objectarray_likeData for vector/matrix representation of the quantum object. argsdictionary that contain the arguments for; tlistarray_likeList of times at which the numpy-array coefficients are applied. Times; must be equidistant and start from 0. Attributes. cteQob",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:32177,Deployability,integrat,integrate,32177,"e, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats(self)[source]; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset(self)[source]; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:33811,Deployability,integrat,integrator,33811,"tributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset(self)[source]; Reset any attributes to default values. run(self, rho0, tlist)[source]; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {propagator, mesolve}Integrator method to use. Defaults to propagator which tends to be; faster for long times (i.e., l",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:34724,Deployability,integrat,integratorstr,34724,"yCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {propagator, mesolve}Integrator method to use. Defaults to propagator which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for propagator; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None)[source]; Compute output field expectation value; <O_n(tn)O_2(t2)O_1(t1)> for times t1,t2, and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem coll",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:34900,Deployability,integrat,integrator,34900,"e simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {propagator, mesolve}Integrator method to use. Defaults to propagator which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for propagator; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None)[source]; Compute output field expectation value; <O_n(tn)O_2(t2)O_1(t1)> for times t1,t2, and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). Returns. : complexexpec",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:34974,Deployability,integrat,integrator,34974,"ed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {propagator, mesolve}Integrator method to use. Defaults to propagator which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for propagator; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None)[source]; Compute output field expectation value; <O_n(tn)O_2(t2)O_1(t1)> for times t1,t2, and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). Returns. : complexexpectation value of field correlation function. outfieldpro",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:39475,Deployability,integrat,integrator,39475,"olver options. Solver Options and Results. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes. atolfloat {1e-8}Absolute tolerance. rtolfloat {1e-6}Relative tolerance. methodstr {adams,bdf}Integration method. orderint {12}Order of integrator (<=12 adams, <=5 bdf). nstepsint {2500}Max. number of internal steps/call. first_stepfloat {0}Size of initial step (0 = automatic). min_stepfloat {0}Minimum step size (0 = automatic). max_stepfloat {0}Maximum step size (0 = automatic). tidybool {True,False}Tidyup Hamiltonian and initial state by removing small terms. num_cpusintNumber of cpus used by mcsolver (default = # of cpus). norm_tolfloatTolerance used when finding wavefunction norm in mcsolve. norm_stepsintMax. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_statesbool {False}Average states values over trajectories in stochastic solvers. average_expectbool {True}Average expectation values over trajectories for stochastic solvers. mc_corr_epsfloat {1e-10}Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntrajint {500}Number of trajectories in stochastic solvers. openmp_threadsintNumber of OPENMP threads to use. Default",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:54174,Deployability,integrat,integrate,54174,"(nds, nds). c_ops(self)[source]; Build collapse operators in the full Hilbert space 2^N. Returns. c_ops_list: listThe list with the collapse operators in the 2^N Hilbert space. coefficient_matrix(self)[source]; Build coefficient matrix for ODE for a diagonal problem. Returns. M: ndarrayThe matrix M of the coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis. lindbladian(self)[source]; Build the Lindbladian superoperator of the dissipative dynamics. Returns. lindbladianqutip.QobjThe Lindbladian matrix as a qutip.Qobj. liouvillian(self)[source]; Build the total Liouvillian using the Dicke basis. Returns. liouvqutip.QobjThe Liouvillian matrix for the system. pisolve(self, initial_state, tlist, options=None)[source]; Solve for diagonal Hamiltonians and initial states faster. Parameters. initial_statequtip.QobjAn initial state specified as a density matrix of; qutip.Qbj type. tlist: ndarrayA 1D numpy array of list of timesteps to integrate. optionsqutip.solver.OptionsThe options for the solver. Returns. result: listA dictionary of the type qutip.solver.Result which holds the; results of the evolution. class Pim(N, emission=0.0, dephasing=0, pumping=0, collective_emission=0, collective_pumping=0, collective_dephasing=0)[source]; The Permutation Invariant Matrix class.; Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state p as:. dp/dt = Mp. Parameters. N: intThe number of two-level systems. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_emission: floatCollective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: floatCollective pumping coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coeff",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:61023,Deployability,update,update,61023," in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. figmatplotlib Figure instanceIf given, use this figure instance for the visualization,. axmatplotlib Axes instanceIf given, render the visualization using this axis instance. figsizetupleSize of the new Figure instance, if one needs to be created. colorbar: BoolWhether or not the colorbar (in 2D visualization) should be used. cmap: matplotlib colormap instanceIf given, use this colormap for 2D visualizations. stylestringType of visualization: colormap (default) or surface. Returns. fig, axtupleA tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)[source]. update(self, state)[source]; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(self, psi)[source]; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(self, rho)[source]; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]. update(self, psi)[source]; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]. update(self, rho)[source]; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]; Representation of a quantum gate, with its required parametrs, and target; and control qubits. Param",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:61541,Deployability,update,update,61541,"ualizations. stylestringType of visualization: colormap (default) or surface. Returns. fig, axtupleA tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)[source]. update(self, state)[source]; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(self, psi)[source]; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(self, rho)[source]; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]. update(self, psi)[source]; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]. update(self, rho)[source]; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]; Representation of a quantum gate, with its required parametrs, and target; and control qubits. Parameters. namestringGate name. targetslist or intGate targets. controlslist or intGate controls. arg_valuefloatArgument value(phi). arg_labelstringLabel for gate representation. class QubitCircuit(N, input_states=None, output_states=None, reverse_states=True, user_gates=None)[source]; Representation of a quantum program/algorithm, maintaining a sequence; of gates. Parameters. NintNumber of qubits in the system. user_gatesdictDefine a dictionary of the custom gates. See examples for detail. i",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:61746,Deployability,update,update,61746,"=250)[source]. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)[source]. update(self, state)[source]; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix. update_psi(self, psi)[source]; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction. update_rho(self, rho)[source]; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)[source]. update(self, psi)[source]; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]. update(self, rho)[source]; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]; Representation of a quantum gate, with its required parametrs, and target; and control qubits. Parameters. namestringGate name. targetslist or intGate targets. controlslist or intGate controls. arg_valuefloatArgument value(phi). arg_labelstringLabel for gate representation. class QubitCircuit(N, input_states=None, output_states=None, reverse_states=True, user_gates=None)[source]; Representation of a quantum program/algorithm, maintaining a sequence; of gates. Parameters. NintNumber of qubits in the system. user_gatesdictDefine a dictionary of the custom gates. See examples for detail. input_stateslistA list of string such as 0,+, A, Y. Only used for latex. Examples; >>> def user_gate():; ... mat = np.array([[1., 0],; ... [0., 1.j]]); ... return Qobj(mat, dims=[[2], [2]]); >>> qc.QubitCircuit(2, ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:73111,Deployability,configurat,configuration,73111,"cking; them together. get_ops_labels(self)[source]; Returns the Hamiltonian operators and corresponding labels by stacking; them together. load_circuit(self, qc)[source]; Translates an abstract quantum circuit to its corresponding Hamiltonian; for a specific model. Parameters. qc: QubitCircuitTakes the quantum circuit to be implemented. optimize_circuit(self, qc)[source]; Function to take a quantum circuit/algorithm and convert it into the; optimal form/basis for the desired physical system. Parameters. qc: QubitCircuitTakes the quantum circuit to be implemented. Returns. qc: QubitCircuitThe optimal circuit representation. Optimal control. class Optimizer(config, dyn, params=None)[source]; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. algstringAlgorithm to use in pulse optimisation.; Options are:. GRAPE (default) - GRadient Ascent Pulse Engineering; CRAB - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msgboolSet true to display a convergence message; (fo",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:75678,Deployability,configurat,configuration,75678,"rapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpdump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation - NONE : No processing data dumped (Default) - SUMMARY : A summary at each iteration will be recorded - FULL : All logs will be generated and dumped - CUSTOM : Some cus",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:78751,Deployability,update,update,78751,"the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping. The level of data dumping that will occur during the optimisation; NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(self, *args)[source]; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimi",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:79355,Deployability,update,update,79355,"lf, *args)[source]; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(self, term_conds=None)[source]; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the p",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:79888,Deployability,configurat,configuration,79888," optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(self, term_conds=None)[source]; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:82686,Deployability,configurat,configuration,82686,"ma), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(self, term_conds=None)[source]; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:84318,Deployability,configurat,configuration,84318,"ed implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(self, term_conds=None)[source]; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall ti",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:90816,Deployability,update,updated,90816,"ultiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:99222,Deployability,configurat,configuration,99222,"he initial to the given; timeslot. get_ctrl_dyn_gen(self, j)[source]; Get the dynamics generator for the control; Not implemented in the base class. Choose a subclass. get_drift_dim(self)[source]; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N. get_dyn_gen(self, k)[source]; Get the combined dynamics generator for the timeslot; Not implemented in the base class. Choose a subclass. get_num_ctrls(self)[source]; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. init_timeslots(self)[source]; Generate the timeslot duration array tau based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array time based on the tau values. initialize_controls(self, amps, init_tslots=True)[source]; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. property num_ctrls; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. property onto_evo; List of evolution operators (Qobj) from the initial to the given; timeslot. property onwd_evo; List of evolution operators (Qobj) from the initial to the given; timeslot. property phase_application; scalar(string), default=preop; Determines how the phase is applied to the dynamics generators. preop : P = expm(phase*dyn_gen); postop : P = expm(dyn_gen*phase); custom : Customised phase application. The custom option assumes that the _apply_phase method has been; set to a custom function. Type; phase_application. property prop; List of propagators (Qobj) for each timeslot. property prop_grad; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs(self)[source];",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:102636,Deployability,configurat,configuration,102636,"escribed by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes. drift_hamQobjThis is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_hamList of QobjThese are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. HList of QobjThe combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls. check_unitarity(self)[source]; Checks whether all propagators are unitary; For propagators found not to be unitary, the potential underlying; causes are investigated. initialize_controls(self, amplitudes, init_tslots=True)[source]; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. property num_ctrls; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. class DynamicsSymplectic(optimconfig, params=None)[source]; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes. omegaarray[drift_dyn_gen.shape]matrix used in the calculation of propagators (time evolution); with symplectic systems. property dyn_gen_phase; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as postop dyn_gen*-Omega; If phase_application is preop it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]; Base for all Propagator Computer classes; that are used to calculate the propagators,; an",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:104911,Deployability,configurat,configuration,104911,"Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset(self)[source]; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset(self)[source]; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset(self)[source]; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]. Frechet method for calculating the propagator:exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset(self)[source]; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]; Base class for all Fidelity Computers.; This cannot be used directly. Se",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:105191,Deployability,configurat,configuration,105191,"on,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset(self)[source]; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset(self)[source]; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset(self)[source]; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]. Frechet method for calculating the propagator:exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset(self)[source]; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are at",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:105388,Deployability,configurat,configuration,105388,"omputer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset(self)[source]; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset(self)[source]; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset(self)[source]; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]. Frechet method for calculating the propagator:exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset(self)[source]; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:105756,Deployability,configurat,configuration,105756,"irs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset(self)[source]; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset(self)[source]; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset(self)[source]; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]. Frechet method for calculating the propagator:exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset(self)[source]; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:108541,Deployability,configurat,configuration,108541,"s; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear(self)[source]; clear any temporarily held status data. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear(self)[source]; clear any temporarily held status data. compute_fid_grad(self)[source]; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Not",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:108604,Deployability,configurat,configuration,108604,"lity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear(self)[source]; clear any temporarily held status data. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear(self)[source]; clear any temporarily held status data. compute_fid_grad(self)[source]; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. fla",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:109986,Deployability,update,updates,109986,"phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear(self)[source]; clear any temporarily held status data. compute_fid_grad(self)[source]; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity(self)[source]; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm(self)[source]; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp(self)[source]; Check configuration and initialise the normalisation. init_normalization(self)[source]; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:110459,Deployability,configurat,configuration,110459," of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity(self)[source]; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm(self)[source]; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp(self)[source]; Check configuration and initialise the normalisation. init_normalization(self)[source]; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(self, A)[source]. normalize_SU(self, A)[source]. normalize_gradient_PSU(self, grad)[source]; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(self, grad)[source]; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. set_phase_option(self, phase_option=None)[sourc",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:111355,Deployability,configurat,configuration,111355," cached, because it is used in the gradient calculation. init_comp(self)[source]; Check configuration and initialise the normalisation. init_normalization(self)[source]; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(self, A)[source]. normalize_SU(self, A)[source]. normalize_gradient_PSU(self, grad)[source]; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(self, grad)[source]; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. set_phase_option(self, phase_option=None)[source]; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:113000,Deployability,update,updates,113000,"re for dynamics described by matrices; Note the gradient calculation is taken from:; Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad(self)[source]; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad(self)[source]; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class TimeslotCompute",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:113123,Deployability,configurat,configuration,113123,"r, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad(self)[source]; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad(self)[source]; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:113234,Deployability,configurat,configuration,113234,"bitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad(self)[source]; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad(self)[source]; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasi",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:113838,Deployability,configurat,configuration,113838,"ient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad(self)[source]; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summaryEvoCompSummaryA summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or pass",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:115323,Deployability,update,updated,115323,"in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summaryEvoCompSummaryA summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dump_current(self)[source]; Store a copy of the current time evolution. class TSlotCompUpdateAll(dynamics, params=None)[source]; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated. compare_amps(self, new_amps)[source]; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed. get_timeslot_for_fidelity_calc(self)[source]; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot. recompute_evolution(self)[source]; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary. class PulseGen(dyn=None, params=None)[source]; Pulse generator; Base class for all Pulse generators; The object can optionally be instantiated with a Dynamics object,; in which case the timeslots and amplitude scaling and offset; are copied from that.; Otherwise the class can be used independently by setting:; tau (array of timeslot durations);",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:126096,Deployability,configurat,configurations,126096,"method; Typically this will be the basis coefficients. class PulseGenCrabFourier(dyn=None, num_coeffs=None, params=None)[source]; Generates a pulse using the Fourier basis functions, i.e. sin and cos. Attributes. freqsfloat array[num_coeffs]Frequencies for the basis functions. randomize_freqsboolIf True (default) the some random offset is applied to the frequencies. gen_pulse(self, coeffs=None)[source]; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters. coeffsfloat array[num_coeffs, num_basis_funcs]The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs(self)[source]; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(self, num_coeffs=None)[source]; Set the initial freq and coefficient values. reset(self)[source]; reset attributes to default values. class Stats[source]; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes. dyn_gen_namestringText used in some report functions.; Makes sense to set it to Hamiltonian when using unitary dynamics; Default is simply dynamics generator. num_iterintegerNumber of iterations of the optimisation algorithm. wall_time_optim_startfloatStart time for the optimisation. wall_time_optim_endfloatEnd time for the optimisation. wall_time_optimfloatTime elasped during the optimisation. wall_time_dyn_gen_computefloatTotal wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_computefloatTotal wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_computefloatTotal wall (elasped) time com",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:126135,Deployability,update,updated,126135,"method; Typically this will be the basis coefficients. class PulseGenCrabFourier(dyn=None, num_coeffs=None, params=None)[source]; Generates a pulse using the Fourier basis functions, i.e. sin and cos. Attributes. freqsfloat array[num_coeffs]Frequencies for the basis functions. randomize_freqsboolIf True (default) the some random offset is applied to the frequencies. gen_pulse(self, coeffs=None)[source]; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters. coeffsfloat array[num_coeffs, num_basis_funcs]The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs(self)[source]; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(self, num_coeffs=None)[source]; Set the initial freq and coefficient values. reset(self)[source]; reset attributes to default values. class Stats[source]; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes. dyn_gen_namestringText used in some report functions.; Makes sense to set it to Hamiltonian when using unitary dynamics; Default is simply dynamics generator. num_iterintegerNumber of iterations of the optimisation algorithm. wall_time_optim_startfloatStart time for the optimisation. wall_time_optim_endfloatEnd time for the optimisation. wall_time_optimfloatTime elasped during the optimisation. wall_time_dyn_gen_computefloatTotal wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_computefloatTotal wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_computefloatTotal wall (elasped) time com",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:128317,Deployability,update,updated,128317,"ll (elasped) time computing combined onward propagation,; that is the time evolution from a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_computefloatTotal wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_callsintegerNumber of calls to fidelity function by the optimisation algorithm. num_grad_func_callsintegerNumber of calls to gradient function by the optimisation algorithm. num_tslot_recomputeintegerNumber of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computesintegerNumber of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computesintegerNumber of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updatesintegerNumber of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iterfloatMean number of control amplitude updates per iteration. num_timeslot_changesintegerNumber of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_updatefloatMean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changesintegerNumber of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_updatefloatMean average number of control amplitudes that are changed per update. calculate(self)[source]; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report(self)[source]; Print a report of the stats to the console. class Dump[source]; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:128398,Deployability,update,updates,128398,om a specific timeslot to the end time.; Excludes calculating the propagators themselves. wall_time_gradient_computefloatTotal wall (elasped) time computing the fidelity error gradient.; Excludes calculating the propagator gradients (in exact gradient; methods). num_fidelity_func_callsintegerNumber of calls to fidelity function by the optimisation algorithm. num_grad_func_callsintegerNumber of calls to gradient function by the optimisation algorithm. num_tslot_recomputeintegerNumber of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computesintegerNumber of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computesintegerNumber of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updatesintegerNumber of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iterfloatMean number of control amplitude updates per iteration. num_timeslot_changesintegerNumber of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_updatefloatMean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changesintegerNumber of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_updatefloatMean average number of control amplitudes that are changed per update. calculate(self)[source]; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report(self)[source]; Print a report of the stats to the console. class Dump[source]; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dirstrdirectory where files (if any) will be writte,MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:128624,Deployability,update,update,128624,ating the propagator gradients (in exact gradient; methods). num_fidelity_func_callsintegerNumber of calls to fidelity function by the optimisation algorithm. num_grad_func_callsintegerNumber of calls to gradient function by the optimisation algorithm. num_tslot_recomputeintegerNumber of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computesintegerNumber of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computesintegerNumber of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updatesintegerNumber of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iterfloatMean number of control amplitude updates per iteration. num_timeslot_changesintegerNumber of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_updatefloatMean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changesintegerNumber of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_updatefloatMean average number of control amplitudes that are changed per update. calculate(self)[source]; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report(self)[source]; Print a report of the stats to the console. class Dump[source]; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dirstrdirectory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. l,MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:128827,Deployability,update,update,128827,gradient function by the optimisation algorithm. num_tslot_recomputeintegerNumber of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computesintegerNumber of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computesintegerNumber of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updatesintegerNumber of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iterfloatMean number of control amplitude updates per iteration. num_timeslot_changesintegerNumber of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_updatefloatMean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changesintegerNumber of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_updatefloatMean average number of control amplitudes that are changed per update. calculate(self)[source]; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report(self)[source]; Print a report of the stats to the console. class Dump[source]; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dirstrdirectory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. levelstringThe level of data dumping that will occur - SUMMARY : A summary will be recorded - FULL : All possible dumping - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equiv,MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:135012,Deployability,update,updated,135012,"d_evoboolIf True onward evolution operators are dumped. dump_onto_evoboolIf True onto (or backward) evolution operators are dumped. evo_dumpslist of EvoCompDumpItemA new dump item is appended at each recomputation of the evolution.; That is if any of the calculation objects are to be dumped. add_evo_comp_summary(self, dump_item_idx=None)[source]; add copy of current evo comp summary. add_evo_dump(self)[source]; Add dump of current time evolution generating objects. property dump_all; True if all of the calculation objects are to be dumped. property dump_any; True if any of the calculation objects are to be dumped. writeout(self, f=None)[source]; write all the dump items and the summary out to file(s); :param f: If specified then all summary and object data will go in one file. If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DumpItem[source]; An item in a dump list. class EvoCompDumpItem(dump)[source]; A copy of all objects generated to calculate one time evolution; Note the attributes are only set if the corresponding; DynamicsDump dump_ attribute is set. writeout(self, f=None)[source]; write all the objects out to files. Parameters. ffilename or filehandleIf specified then all object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DumpSummaryItem[source]; A summary of the most recent iteration; Abstract class only; Attributes:; idx : int. Index in the summary list in which this is stored. Previous.  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:12692,Energy Efficiency,efficient,efficient,12692,"ed) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used); for trace norm. Returns. normfloatThe requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(self, other)[source]; Overlap between two state vectors or two operators.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters. otherqutip.QobjQuantum object for a state vector of type ket, bra or density; matrix. Returns. overlapcomplexComplex valued overlap. Raises. TypeErrorCan only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets. permute(self, order)[source]; Permutes a composite quantum object. Parameters. orderlist/arrayList specifying new tensor order. Returns. Pqutip.QobjPermuted quantum object. proj(self)[source]; Form the projector from a given ket or bra vector. Parameters. Qqutip.QobjInput bra or ket vector. Returns. Pqutip.QobjProjection operator. ptrace(self, sel)[source]; Partial trace of the quantum object. Parameters. selint/listAn int or list of components to keep after partial trace. Returns. operqutip.QobjQuantum object representing partial trace with selected components; remaining. Notes; This function is identical to the qutip.qobj.ptrace function; that has been deprecated. sinm(self)[source]; Sine of a quantum operator.; Operator must be square. Returns. operqutip.QobjMatrix sine of operator. Raises. TypeErrorQuantum object is not square. Notes; Uses the Q.expm() method. sqrtm(self, sparse=False",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:37576,Energy Efficiency,reduce,reduced,37576,"ified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(self, t, tau, notrace=False)[source]; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; -; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(self, rho0, t, tau)[source]; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results. class Options(atol=1e-08, rtol=1e-06, method='adam",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:37648,Energy Efficiency,reduce,reduced,37648,"pse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(self, t, tau, notrace=False)[source]; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; -; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(self, rho0, t, tau)[source]; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, aver",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:59287,Energy Efficiency,reduce,reduced,59287,"ng of the valid; taus for this row and column of the Dicke space element. Distribution functions. class Distribution(data=None, xvecs=[], xlabels=[])[source]; A class for representation spatial distribution functions.; The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far).; It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters. dataarray_likeData for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecslistList of arrays that spans the space for each coordinate. xlabelslistList of labels for each coordinate. marginal(self, dim=0)[source]; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; marginal distribution. Returns. dDistributionsA new instances of Distribution that describes the marginal; distribution. project(self, dim=0)[source]; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; projected distribution. Returns. dDistributionsA new instances of Distribution that describes the projection. visualize(self, fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. figmatplotlib Figure instanceIf given, use this figure instance for the visualization,. a",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:59693,Energy Efficiency,reduce,reduced-dimensionality,59693,"ase class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters. dataarray_likeData for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecslistList of arrays that spans the space for each coordinate. xlabelslistList of labels for each coordinate. marginal(self, dim=0)[source]; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; marginal distribution. Returns. dDistributionsA new instances of Distribution that describes the marginal; distribution. project(self, dim=0)[source]; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; projected distribution. Returns. dDistributionsA new instances of Distribution that describes the projection. visualize(self, fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. figmatplotlib Figure instanceIf given, use this figure instance for the visualization,. axmatplotlib Axes instanceIf given, render the visualization using this axis instance. figsizetupleSize of the new Figure instance, if one needs to be created. colorbar: BoolWhether or not the colorbar (in 2D visualization) should be used. cmap: matplotlib colormap instanceIf given, use this colormap for 2D visualizations. stylestringType of visualization: colormap (default) or surface. Returns. fig",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:76078,Energy Efficiency,reduce,reduce,76078,"floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpdump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation - NONE : No processing data dumped (Default) - SUMMARY : A summary at each iteration will be recorded - FULL : All logs will be generated and dumped - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dirstringBasically a link to dump.dump_dir. Exists so that it can be set throu",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:90586,Energy Efficiency,reduce,reduce,90586,"at is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory s",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:105713,Energy Efficiency,efficient,efficient,105713,"ter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset(self)[source]; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset(self)[source]; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset(self)[source]; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]. Frechet method for calculating the propagator:exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset(self)[source]; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary d",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:8138,Integrability,depend,dependent,8138,"Array of eigenvalues for operator. eigvecsarrayArray of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(self, states_inds, normalize=False)[source]; Creates a new quantum object with states in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, sin(w * t)]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[w] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(self, method='dense')[source]; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {dense, sparse}Use set method to use to calculate the matrix exponentiation. The; available choices includes dense and sparse. Since the; exponential of a matrix is nearly always dense, method=dense; is set as default.s. Returns. operq",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:8460,Integrability,depend,dependent,8460," states_inds, normalize=False)[source]; Creates a new quantum object with states in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, sin(w * t)]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[w] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(self, method='dense')[source]; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {dense, sparse}Use set method to use to calculate the matrix exponentiation. The; available choices includes dense and sparse. Since the; exponential of a matrix is nearly always dense, method=dense; is set as default.s. Returns. operqutip.QobjExponentiated quantum operator. Raises. TypeErrorQuantum operator is not square. extract_states(self, states_inds, normalize=False)[source]; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj inst",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:8531,Integrability,depend,dependent,8531,"in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, sin(w * t)]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[w] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(self, method='dense')[source]; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {dense, sparse}Use set method to use to calculate the matrix exponentiation. The; available choices includes dense and sparse. Since the; exponential of a matrix is nearly always dense, method=dense; is set as default.s. Returns. operqutip.QobjExponentiated quantum operator. Raises. TypeErrorQuantum operator is not square. extract_states(self, states_inds, normalize=False)[source]; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density m",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:8636,Integrability,depend,dependent,8636,"e removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, sin(w * t)]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[w] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(self, method='dense')[source]; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {dense, sparse}Use set method to use to calculate the matrix exponentiation. The; available choices includes dense and sparse. Since the; exponential of a matrix is nearly always dense, method=dense; is set as default.s. Returns. operqutip.QobjExponentiated quantum operator. Raises. TypeErrorQuantum operator is not square. extract_states(self, states_inds, normalize=False)[source]; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; tha",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:16355,Integrability,depend,dependent,16355,"igenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters. methodstrAlgorithm to use to remove negative eigenvalues. clip; simply discards negative eigenvalues, then renormalizes.; sgs uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(self, inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo. class QobjEvo(Q_object=[], args={}, tlist=None, copy=True)[source]; A class for representing time-dependent quantum objects,; such as quantum operators and states.; The QobjEvo class is a representation of time-dependent Qutip quantum; objects (Qobj). This class implements math operations :. +,- : QobjEvo, Qobj; * : Qobj, C-number; / : C-number. and some common linear operator/state operations. The QobjEvo; are constructed from a nested list of Qobj with their time-dependent; coefficients. The time-dependent coefficients are either a funciton, a; string or a numpy array.; For function format, the function signature must be f(t, args).; Examples. def f1_t(t, args):return np.exp(-1j * t * args[w1]). def f2_t(t, args):return np.cos(t * args[w2]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={w1:1., w2:2.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. sin cos tan asin acos atan pi; sinh cosh tanh asinh acosh atanh; exp log log10 erf zerf sqrt; real imag conj abs norm arg",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:16468,Integrability,depend,dependent,16468,"remove negative eigenvalues. clip; simply discards negative eigenvalues, then renormalizes.; sgs uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(self, inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo. class QobjEvo(Q_object=[], args={}, tlist=None, copy=True)[source]; A class for representing time-dependent quantum objects,; such as quantum operators and states.; The QobjEvo class is a representation of time-dependent Qutip quantum; objects (Qobj). This class implements math operations :. +,- : QobjEvo, Qobj; * : Qobj, C-number; / : C-number. and some common linear operator/state operations. The QobjEvo; are constructed from a nested list of Qobj with their time-dependent; coefficients. The time-dependent coefficients are either a funciton, a; string or a numpy array.; For function format, the function signature must be f(t, args).; Examples. def f1_t(t, args):return np.exp(-1j * t * args[w1]). def f2_t(t, args):return np.cos(t * args[w2]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={w1:1., w2:2.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. sin cos tan asin acos atan pi; sinh cosh tanh asinh acosh atanh; exp log log10 erf zerf sqrt; real imag conj abs norm arg proj; numpy as np, and scipy.special as spe. Examples; H = QobjEvo([H0, [H1, exp(-1j*w1*t)], [H2, cos(w2*t)]],args={w1:",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:16727,Integrability,depend,dependent,16727," density operator. unit(self, inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo. class QobjEvo(Q_object=[], args={}, tlist=None, copy=True)[source]; A class for representing time-dependent quantum objects,; such as quantum operators and states.; The QobjEvo class is a representation of time-dependent Qutip quantum; objects (Qobj). This class implements math operations :. +,- : QobjEvo, Qobj; * : Qobj, C-number; / : C-number. and some common linear operator/state operations. The QobjEvo; are constructed from a nested list of Qobj with their time-dependent; coefficients. The time-dependent coefficients are either a funciton, a; string or a numpy array.; For function format, the function signature must be f(t, args).; Examples. def f1_t(t, args):return np.exp(-1j * t * args[w1]). def f2_t(t, args):return np.cos(t * args[w2]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={w1:1., w2:2.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. sin cos tan asin acos atan pi; sinh cosh tanh asinh acosh atanh; exp log log10 erf zerf sqrt; real imag conj abs norm arg proj; numpy as np, and scipy.special as spe. Examples; H = QobjEvo([H0, [H1, exp(-1j*w1*t)], [H2, cos(w2*t)]],args={w1:1.,w2:2.}). For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:16761,Integrability,depend,dependent,16761,"0)[source]; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo. class QobjEvo(Q_object=[], args={}, tlist=None, copy=True)[source]; A class for representing time-dependent quantum objects,; such as quantum operators and states.; The QobjEvo class is a representation of time-dependent Qutip quantum; objects (Qobj). This class implements math operations :. +,- : QobjEvo, Qobj; * : Qobj, C-number; / : C-number. and some common linear operator/state operations. The QobjEvo; are constructed from a nested list of Qobj with their time-dependent; coefficients. The time-dependent coefficients are either a funciton, a; string or a numpy array.; For function format, the function signature must be f(t, args).; Examples. def f1_t(t, args):return np.exp(-1j * t * args[w1]). def f2_t(t, args):return np.cos(t * args[w2]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={w1:1., w2:2.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. sin cos tan asin acos atan pi; sinh cosh tanh asinh acosh atanh; exp log log10 erf zerf sqrt; real imag conj abs norm arg proj; numpy as np, and scipy.special as spe. Examples; H = QobjEvo([H0, [H1, exp(-1j*w1*t)], [H2, cos(w2*t)]],args={w1:1.,w2:2.}). For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; Examples. tlist = np.logspace(-5",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:18397,Integrability,depend,depending,18397,"y as np, and scipy.special as spe. Examples; H = QobjEvo([H0, [H1, exp(-1j*w1*t)], [H2, cos(w2*t)]],args={w1:1.,w2:2.}). For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; Examples. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],. tlist=tlist). args is a dict of (name:object). The name must be a valid variables string.; Some solvers support arguments that update at each call:; sesolve, mesolve, mcsolve:. state can be obtained with:name+=vec:Qobj => args[name] == state as 1D np.ndarray; name+=mat:Qobj => args[name] == state as 2D np.ndarray; name+=Qobj:Qobj => args[name] == state as Qobj; This Qobj is the initial value. expectation values:name+=expect:O (Qobj/QobjEvo) => args[name] == expect(O, state); expect is <phi|O|psi> or tr(state * O) depending on state dimensions. mcsolve:; collapse can be obtained with:name+=collapse:list => args[name] == list of collapse; each collapse will be appended to the list as (time, which c_ops). Mixing the formats is possible, but not recommended.; Mixing tlist will cause problem. Parameters. QobjEvo(Q_object=[], args={}, tlist=None); Q_objectarray_likeData for vector/matrix representation of the quantum object. argsdictionary that contain the arguments for; tlistarray_likeList of times at which the numpy-array coefficients are applied. Times; must be equidistant and start from 0. Attributes. cteQobjConstant part of the QobjEvo. opslistList of Qobj and the coefficients.; [(Qobj, coefficient as a function, original coefficient,. type, local arguments ),  ]. type :1: function; 2: string; 3: np.array; 4: Cubic_Spline. argsmaparguments of the coefficients. tlistarray_likeList of times at which the numpy-array coefficients are applied. compil",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:22334,Integrability,depend,dependent,22334,"tum object and coeff type. compile(code=False, matched=False, dense=False, omp=0):; Create the associated cython object for faster usage. code: return the code generated for compilation of the strings. matched: the compiled object use sparse matrix with matching indices. (experimental, no real advantage) dense: the compiled object use dense matrix. omp: (int) number of thread: the compiled object use spmvpy_openmp. __call__(t, data=False, state=None, args={}):; Return the Qobj at time t. *Faster after compilation. mul_mat(t, mat):; Product of this at t time with the dense matrix mat. *Faster after compilation. mul_vec(t, psi):; Apply the quantum object (if operator, no check) to psi. More generaly, return the product of the object at t with psi. *Faster after compilation. expect(t, psi, herm=False):; Calculates the expectation value for the quantum object (if operator, no check) and state psi. Return only the real part if herm. *Faster after compilation. to_list():; Return the time-dependent quantum object as a list. eseries. class eseries(q=None, s=array([], dtype=float64))[source]; Class representation of an exponential-series expansion of; time-dependent quantum objects. Attributes. amplndarrayArray of amplitudes for exponential series. ratesndarrayArray of rates for exponential series. dimslistDimensions of exponential series components. shapelistShape corresponding to exponential series components. Methods. value(tlist); Evaluate an exponential series at the times listed in tlist. spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup(); Returns a tidier version of the exponential series. spec(self, wlist)[source]; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters. wlistarray_likeArray/list of frequenies. Returns. val_listndarrayValues of exponential series at frequencies in wlist. tidyup(self, *args)[source]; Returns a tidier version of exponential series. value(self, tlist)[source]; E",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:22505,Integrability,depend,dependent,22505,"t for faster usage. code: return the code generated for compilation of the strings. matched: the compiled object use sparse matrix with matching indices. (experimental, no real advantage) dense: the compiled object use dense matrix. omp: (int) number of thread: the compiled object use spmvpy_openmp. __call__(t, data=False, state=None, args={}):; Return the Qobj at time t. *Faster after compilation. mul_mat(t, mat):; Product of this at t time with the dense matrix mat. *Faster after compilation. mul_vec(t, psi):; Apply the quantum object (if operator, no check) to psi. More generaly, return the product of the object at t with psi. *Faster after compilation. expect(t, psi, herm=False):; Calculates the expectation value for the quantum object (if operator, no check) and state psi. Return only the real part if herm. *Faster after compilation. to_list():; Return the time-dependent quantum object as a list. eseries. class eseries(q=None, s=array([], dtype=float64))[source]; Class representation of an exponential-series expansion of; time-dependent quantum objects. Attributes. amplndarrayArray of amplitudes for exponential series. ratesndarrayArray of rates for exponential series. dimslistDimensions of exponential series components. shapelistShape corresponding to exponential series components. Methods. value(tlist); Evaluate an exponential series at the times listed in tlist. spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup(); Returns a tidier version of the exponential series. spec(self, wlist)[source]; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters. wlistarray_likeArray/list of frequenies. Returns. val_listndarrayValues of exponential series at frequencies in wlist. tidyup(self, *args)[source]; Returns a tidier version of exponential series. value(self, tlist)[source]; Evaluates an exponential series at the times listed in tlist. Parameters. tlistndarrayTimes at which to evaluate expone",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:32177,Integrability,integrat,integrate,32177,"e, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats(self)[source]; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset(self)[source]; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:32643,Integrability,depend,depend,32643,"to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats(self)[source]; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset(self)[source]; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset(self)[source]; Reset any attributes to default values. run(self, rho0, tlist)[source]; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solve",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:33811,Integrability,integrat,integrator,33811,"tributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset(self)[source]; Reset any attributes to default values. run(self, rho0, tlist)[source]; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {propagator, mesolve}Integrator method to use. Defaults to propagator which tends to be; faster for long times (i.e., l",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:34724,Integrability,integrat,integratorstr,34724,"yCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {propagator, mesolve}Integrator method to use. Defaults to propagator which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for propagator; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None)[source]; Compute output field expectation value; <O_n(tn)O_2(t2)O_1(t1)> for times t1,t2, and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem coll",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:34900,Integrability,integrat,integrator,34900,"e simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {propagator, mesolve}Integrator method to use. Defaults to propagator which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for propagator; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None)[source]; Compute output field expectation value; <O_n(tn)O_2(t2)O_1(t1)> for times t1,t2, and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). Returns. : complexexpec",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:34974,Integrability,integrat,integrator,34974,"ed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {propagator, mesolve}Integrator method to use. Defaults to propagator which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for propagator; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None)[source]; Compute output field expectation value; <O_n(tn)O_2(t2)O_1(t1)> for times t1,t2, and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). Returns. : complexexpectation value of field correlation function. outfieldpro",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:39475,Integrability,integrat,integrator,39475,"olver options. Solver Options and Results. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes. atolfloat {1e-8}Absolute tolerance. rtolfloat {1e-6}Relative tolerance. methodstr {adams,bdf}Integration method. orderint {12}Order of integrator (<=12 adams, <=5 bdf). nstepsint {2500}Max. number of internal steps/call. first_stepfloat {0}Size of initial step (0 = automatic). min_stepfloat {0}Minimum step size (0 = automatic). max_stepfloat {0}Maximum step size (0 = automatic). tidybool {True,False}Tidyup Hamiltonian and initial state by removing small terms. num_cpusintNumber of cpus used by mcsolver (default = # of cpus). norm_tolfloatTolerance used when finding wavefunction norm in mcsolve. norm_stepsintMax. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_statesbool {False}Average states values over trajectories in stochastic solvers. average_expectbool {True}Average expectation values over trajectories for stochastic solvers. mc_corr_epsfloat {1e-10}Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntrajint {500}Number of trajectories in stochastic solvers. openmp_threadsintNumber of OPENMP threads to use. Default",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:43336,Integrability,message,message,43336," are given in the the contructor, then all statistics; will be added to one section main. Parameters. section_nameslistlist of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called main is created. Attributes. sectionsOrderedDict of _StatsSectionThese are the sections that are created automatically on instantiation; or added using add_section. headerstringSome text that will be used as the heading in the report; By default there is None. total_timefloatTime in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. Methods. add_section(self,name); Add another section with the given name. add_count(self,key,value[,section]); Add value to count. add_timing(self,key,value[,section]); Add value to timing. add_message(self,key,value[,section,sep]); Add value to message. report:; Output the statistics report to console or file. add_count(self, key, value, section=None)[source]; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. section: string or `class`_StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(self, key, value, section=None, sep=';')[source]; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will res",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:44040,Integrability,message,message,44040,"ing; Can be None, meaning that total timing percentages will be reported. Methods. add_section(self,name); Add another section with the given name. add_count(self,key,value[,section]); Add value to count. add_timing(self,key,value[,section]); Add value to timing. add_message(self,key,value[,section,sep]); Add value to message. report:; Output the statistics report to console or file. add_count(self, key, value, section=None)[source]; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. section: string or `class`_StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(self, key, value, section=None, sep=';')[source]; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(self, name)[source]; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. sectionclassThe new section. add_timing(self, key, value, section=None)[source]; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:44176,Integrability,message,message,44176,"value[,section]); Add value to count. add_timing(self,key,value[,section]); Add value to timing. add_message(self,key,value[,section,sep]); Add value to message. report:; Output the statistics report to console or file. add_count(self, key, value, section=None)[source]; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. section: string or `class`_StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(self, key, value, section=None, sep=';')[source]; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(self, name)[source]; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. sectionclassThe new section. add_timing(self, key, value, section=None)[source]; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:44267,Integrability,message,messages,44267,"e[,section,sep]); Add value to message. report:; Output the statistics report to console or file. add_count(self, key, value, section=None)[source]; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. section: string or `class`_StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(self, key, value, section=None, sep=';')[source]; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(self, name)[source]; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. sectionclassThe new section. add_timing(self, key, value, section=None)[source]; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:44370,Integrability,message,message,44370," report to console or file. add_count(self, key, value, section=None)[source]; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. section: string or `class`_StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(self, key, value, section=None, sep=';')[source]; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(self, name)[source]; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. sectionclassThe new section. add_timing(self, key, value, section=None)[source]; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:44403,Integrability,message,message,44403," report to console or file. add_count(self, key, value, section=None)[source]; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. section: string or `class`_StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(self, key, value, section=None, sep=';')[source]; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(self, name)[source]; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. sectionclassThe new section. add_timing(self, key, value, section=None)[source]; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:44547,Integrability,message,message,44547,"; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. section: string or `class`_StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(self, key, value, section=None, sep=';')[source]; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(self, name)[source]; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. sectionclassThe new section. add_timing(self, key, value, section=None)[source]; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear(self)[source]; Clear counts, timings and messages from all sections. report(self, output=<_io.T",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:45466,Integrability,message,messages,45466," string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(self, name)[source]; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. sectionclassThe new section. add_timing(self, key, value, section=None)[source]; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear(self)[source]; Clear counts, timings and messages from all sections. report(self, output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)[source]; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters. outputstreamfile or console stream - anything that support write - where; the output will be written. set_total_time(self, value, section=None)[source]; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters. valuefloatTime in seconds to complete the solver section. sectionstring or classSection which to set the total_time for; If None given, the total_time for complete solve",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:45618,Integrability,message,messages,45618,"ault (first) section will be used. add_section(self, name)[source]; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. sectionclassThe new section. add_timing(self, key, value, section=None)[source]; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear(self)[source]; Clear counts, timings and messages from all sections. report(self, output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)[source]; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters. outputstreamfile or console stream - anything that support write - where; the output will be written. set_total_time(self, value, section=None)[source]; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters. valuefloatTime in seconds to complete the solver section. sectionstring or classSection which to set the total_time for; If None given, the total_time for complete solve is set. class StochasticSolverOptions(me, H=None, c_ops=[], sc_ops=[], state0=None, e_ops=[], m_ops=None, store_all_expect=Fal",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:45757,Integrability,message,messages,45757,"he new section. add_timing(self, key, value, section=None)[source]; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear(self)[source]; Clear counts, timings and messages from all sections. report(self, output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)[source]; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters. outputstreamfile or console stream - anything that support write - where; the output will be written. set_total_time(self, value, section=None)[source]; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters. valuefloatTime in seconds to complete the solver section. sectionstring or classSection which to set the total_time for; If None given, the total_time for complete solve is set. class StochasticSolverOptions(me, H=None, c_ops=[], sc_ops=[], state0=None, e_ops=[], m_ops=None, store_all_expect=False, store_measurement=False, dW_factors=None, solver=None, method='homodyne', normalize=None, times=None, nsubsteps=1, ntraj=1, tol=None, generate_noise=None, noise=None, progress_bar=None, map_func=None, map_kwargs=None, args={}, opt",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:47414,Integrability,depend,dependent,47414,"l_time for complete solve is set. class StochasticSolverOptions(me, H=None, c_ops=[], sc_ops=[], state0=None, e_ops=[], m_ops=None, store_all_expect=False, store_measurement=False, dW_factors=None, solver=None, method='homodyne', normalize=None, times=None, nsubsteps=1, ntraj=1, tol=None, generate_noise=None, noise=None, progress_bar=None, map_func=None, map_kwargs=None, args={}, options=None, noiseDepth=20)[source]; Class of options for stochastic solvers such as; qutip.stochastic.ssesolve, qutip.stochastic.smesolve, etc.; The stochastic solvers qutip.stochastic.general_stochastic,; qutip.stochastic.ssesolve, qutip.stochastic.smesolve,; qutip.stochastic.photocurrent_sesolve and; qutip.stochastic.photocurrent_mesolve; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class. Attributes. Hqutip.Qobj, time-dependent Qobj as a list*System Hamiltonian. state0qutip.QobjInitial state vector (ket) or density matrix. timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, qutip.QobjEvo or [Qobj, coeff*]List of deterministic collapse operators. sc_opslist of qutip.Qobj, qutip.QobjEvo or [Qobj, coeff*]List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. e_opslist of qutip.QobjSingle operator or list of operators for which to evaluate; expectation values. m_opslist of qutip.QobjList of operators representing the measurement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. argsdictDictionary of parameters for time dependent systems. tolfloatTolerance of the solver for implicit methods. ntrajintNumber of trajectors. nsubstep",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:48320,Integrability,depend,dependent,48320,"ass, so it is rarely needed to explicitly; create an instance of this class. Attributes. Hqutip.Qobj, time-dependent Qobj as a list*System Hamiltonian. state0qutip.QobjInitial state vector (ket) or density matrix. timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, qutip.QobjEvo or [Qobj, coeff*]List of deterministic collapse operators. sc_opslist of qutip.Qobj, qutip.QobjEvo or [Qobj, coeff*]List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. e_opslist of qutip.QobjSingle operator or list of operators for which to evaluate; expectation values. m_opslist of qutip.QobjList of operators representing the measurement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. argsdictDictionary of parameters for time dependent systems. tolfloatTolerance of the solver for implicit methods. ntrajintNumber of trajectors. nsubstepsintNumber of sub steps between each time-spep given in times. dW_factorsarrayArray of length len(sc_ops), containing scaling factors for each; measurement operator in m_ops. solverstringName of the solver method to use for solving the stochastic; equations. Valid values are:; order 1/2 algorithms: euler-maruyama, pc-euler, pc-euler-imp; order 1 algorithms: milstein, platen, milstein-imp, rouchon; order 3/2 algorithms: taylor1.5, taylor1.5-imp, explicit1.5; order 2 algorithms: taylor2.0; call help of qutip.stochastic.stochastic_solvers; for a description of the solvers.; Implicit methods can adjust tolerance via the kw tol; default is {tol:1e-6}. methodstring (homodyne, heterodyne)The name of the type of measurement process that give rise to the; stochastic equation to solve. store_all_expectbool (default False)Whether or not to store ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:50493,Integrability,depend,dependent,50493,"1d], array[double, 4d]int : seed of the noise; array[int, 1d], length = ntraj, seeds for each trajectories; array[double, 4d] (ntraj, len(times), nsubsteps, len(sc_ops)*[1|2]). vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. The correspond to results.noise. noiseDepthintNumber of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalizebool(default True for (photo)ssesolve, False for (photo)smesolve); Whether or not to normalize the wave function during the evolution.; Normalizing density matrices introduce numerical errors. optionsqutip.solver.OptionsGeneric solver options. Only options.average_states and; options.store_states are used. map_func: functionA map function or managing the calls to single-trajactory solvers. map_kwargs: dictionaryOptional keyword arguments to the map_func function function. progress_barqutip.ui.BaseProgressBarOptional progress bar class instance. *; time-dependent Qobj can be used for H, c_ops and sc_ops.; The format for time-dependent system hamiltonian is:; H = [Qobj0,[Qobj1,coeff1],[Qobj2,coeff2],]= Qobj0 + Qobj1 * coeff1(t) + Qobj2 * coeff2(t). coeff function can be:function: coeff(t, args) -> complex; str: sin(1j*w*t); np.array[complex, 1d] of length equal to the times array. The argument args for the function coeff is the args keyword argument ofthe stochastic solver. Likewisem in str cases, the parameters (w in this case) are taken fromthe args keywords argument. *While mixing coeff type does not results in errors, it is not recommended.*; For the collapse operators (c_ops, sc_ops):; Each operators can only be composed of 1 Qobj.; c_ops = [c_op1, c_op2, ]; where, c_opN = Qobj or [Qobj,coeff]; The coeff format is the same as for the Hamiltonian. Permutational Invariance. class Dicke(N, hamiltonian=None, emission=0.0, dephasing=0.0, pumping=0.0, collective_emission=0.0, collective_dephasing=0.0, collective_pumping=0.0)[source]; The Dicke class",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:50566,Integrability,depend,dependent,50566,"ies; array[double, 4d] (ntraj, len(times), nsubsteps, len(sc_ops)*[1|2]). vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. The correspond to results.noise. noiseDepthintNumber of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalizebool(default True for (photo)ssesolve, False for (photo)smesolve); Whether or not to normalize the wave function during the evolution.; Normalizing density matrices introduce numerical errors. optionsqutip.solver.OptionsGeneric solver options. Only options.average_states and; options.store_states are used. map_func: functionA map function or managing the calls to single-trajactory solvers. map_kwargs: dictionaryOptional keyword arguments to the map_func function function. progress_barqutip.ui.BaseProgressBarOptional progress bar class instance. *; time-dependent Qobj can be used for H, c_ops and sc_ops.; The format for time-dependent system hamiltonian is:; H = [Qobj0,[Qobj1,coeff1],[Qobj2,coeff2],]= Qobj0 + Qobj1 * coeff1(t) + Qobj2 * coeff2(t). coeff function can be:function: coeff(t, args) -> complex; str: sin(1j*w*t); np.array[complex, 1d] of length equal to the times array. The argument args for the function coeff is the args keyword argument ofthe stochastic solver. Likewisem in str cases, the parameters (w in this case) are taken fromthe args keywords argument. *While mixing coeff type does not results in errors, it is not recommended.*; For the collapse operators (c_ops, sc_ops):; Each operators can only be composed of 1 Qobj.; c_ops = [c_op1, c_op2, ]; where, c_opN = Qobj or [Qobj,coeff]; The coeff format is the same as for the Hamiltonian. Permutational Invariance. class Dicke(N, hamiltonian=None, emission=0.0, dephasing=0.0, pumping=0.0, collective_emission=0.0, collective_dephasing=0.0, collective_pumping=0.0)[source]; The Dicke class which builds the Lindbladian and Liouvillian matrix. Parameters. N: intThe number of two-level systems.",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:54174,Integrability,integrat,integrate,54174,"(nds, nds). c_ops(self)[source]; Build collapse operators in the full Hilbert space 2^N. Returns. c_ops_list: listThe list with the collapse operators in the 2^N Hilbert space. coefficient_matrix(self)[source]; Build coefficient matrix for ODE for a diagonal problem. Returns. M: ndarrayThe matrix M of the coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis. lindbladian(self)[source]; Build the Lindbladian superoperator of the dissipative dynamics. Returns. lindbladianqutip.QobjThe Lindbladian matrix as a qutip.Qobj. liouvillian(self)[source]; Build the total Liouvillian using the Dicke basis. Returns. liouvqutip.QobjThe Liouvillian matrix for the system. pisolve(self, initial_state, tlist, options=None)[source]; Solve for diagonal Hamiltonians and initial states faster. Parameters. initial_statequtip.QobjAn initial state specified as a density matrix of; qutip.Qbj type. tlist: ndarrayA 1D numpy array of list of timesteps to integrate. optionsqutip.solver.OptionsThe options for the solver. Returns. result: listA dictionary of the type qutip.solver.Result which holds the; results of the evolution. class Pim(N, emission=0.0, dephasing=0, pumping=0, collective_emission=0, collective_pumping=0, collective_dephasing=0)[source]; The Permutation Invariant Matrix class.; Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state p as:. dp/dt = Mp. Parameters. N: intThe number of two-level systems. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_emission: floatCollective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: floatCollective pumping coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coeff",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:60111,Integrability,depend,depending,60111,"at spans the space for each coordinate. xlabelslistList of labels for each coordinate. marginal(self, dim=0)[source]; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; marginal distribution. Returns. dDistributionsA new instances of Distribution that describes the marginal; distribution. project(self, dim=0)[source]; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; projected distribution. Returns. dDistributionsA new instances of Distribution that describes the projection. visualize(self, fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. figmatplotlib Figure instanceIf given, use this figure instance for the visualization,. axmatplotlib Axes instanceIf given, render the visualization using this axis instance. figsizetupleSize of the new Figure instance, if one needs to be created. colorbar: BoolWhether or not the colorbar (in 2D visualization) should be used. cmap: matplotlib colormap instanceIf given, use this colormap for 2D visualizations. stylestringType of visualization: colormap (default) or surface. Returns. fig, axtupleA tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]. class QDistribution(rho=None, extent=[[-5, 5], [-5, 5]], steps=250)[source]. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250)[source]. update(self, state)[sour",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:74128,Integrability,message,message,74128,"onfiguration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. algstringAlgorithm to use in pulse optimisation.; Options are:. GRAPE (default) - GRadient Ascent Pulse Engineering; CRAB - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_gradboolIf set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a s",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:80166,Integrability,wrap,wrapper,80166," as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(self, term_conds=None)[source]; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult obje",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:81715,Integrability,wrap,wrapper,81715," these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]; Implements the run_optimization method using the BFGS algorithm. run_optimization(self, term_conds=None)[source]; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenFletcherGoldfarbShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimizatio",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:83183,Integrability,wrap,wrapper,83183,"tes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(self, term_conds=None)[source]; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]; Check optimiser attribute status and ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:84511,Integrability,wrap,wrapper,84511,"s; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(self, term_conds=None)[source]; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter te",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:84937,Integrability,wrap,wrapper,84937,"d; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(self, term_conds=None)[source]; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]; A summary of the most recent iteration of the pulse optimisation. Attributes. iter_numintIteratio",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:100912,Integrability,message,message,100912," that the _apply_phase method has been; set to a custom function. Type; phase_application. property prop; List of propagators (Qobj) for each timeslot. property prop_grad; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs(self)[source]; Reset the dyn_shape, dyn_dims and time_depend_drift attribs. save_amps(self, file_name=None, times=None, amps=None, verbose=False)[source]; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters. file_namestringName of the file; If None given the def_amps_fname attribuite will be used. timesList type (or string)List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If exclude then times will not be saved in the file, just; the amplitudes. ampsArray[num_tslots, num_ctrls]Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verboseBooleanIf True then an info message will be logged. unitarity_check(self)[source]; Checks whether all propagators are unitary. update_ctrl_amps(self, new_amps)[source]; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer. class DynamicsGenMat(optimconfig, params=None)[source]; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Lindbladian. class DynamicsUnitary(optimconfig, params=None)[source]; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes. drift_hamQobjThis is the drift Ha",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:129119,Integrability,depend,depends,129119,putesintegerNumber of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updatesintegerNumber of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iterfloatMean number of control amplitude updates per iteration. num_timeslot_changesintegerNumber of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_updatefloatMean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changesintegerNumber of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_updatefloatMean average number of control amplitudes that are changed per update. calculate(self)[source]; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report(self)[source]; Print a report of the stats to the console. class Dump[source]; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dirstrdirectory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. levelstringThe level of data dumping that will occur - SUMMARY : A summary will be recorded - FULL : All possible dumping - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY. write_to_fileboolWhen set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_extstrDefault file extension for any file names that are auto generated. fname_basestrFirst part of any auto generated f,MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:17942,Modifiability,variab,variables,17942,"p.exp(-1j * t * args[w1]). def f2_t(t, args):return np.cos(t * args[w2]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={w1:1., w2:2.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. sin cos tan asin acos atan pi; sinh cosh tanh asinh acosh atanh; exp log log10 erf zerf sqrt; real imag conj abs norm arg proj; numpy as np, and scipy.special as spe. Examples; H = QobjEvo([H0, [H1, exp(-1j*w1*t)], [H2, cos(w2*t)]],args={w1:1.,w2:2.}). For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; Examples. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],. tlist=tlist). args is a dict of (name:object). The name must be a valid variables string.; Some solvers support arguments that update at each call:; sesolve, mesolve, mcsolve:. state can be obtained with:name+=vec:Qobj => args[name] == state as 1D np.ndarray; name+=mat:Qobj => args[name] == state as 2D np.ndarray; name+=Qobj:Qobj => args[name] == state as Qobj; This Qobj is the initial value. expectation values:name+=expect:O (Qobj/QobjEvo) => args[name] == expect(O, state); expect is <phi|O|psi> or tr(state * O) depending on state dimensions. mcsolve:; collapse can be obtained with:name+=collapse:list => args[name] == list of collapse; each collapse will be appended to the list as (time, which c_ops). Mixing the formats is possible, but not recommended.; Mixing tlist will cause problem. Parameters. QobjEvo(Q_object=[], args={}, tlist=None); Q_objectarray_likeData for vector/matrix representation of the quantum object. argsdictionary that contain the arguments for; tlistarray_likeList of times at which the numpy-array coefficients are applied",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:30199,Modifiability,coupling,coupling,30199,"this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes. H_sysQobjSystem Hamiltonian. coup_opQobjOperator describing the coupling between system and bath. coup_strengthfloatCoupling strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmanns constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, re",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:31093,Modifiability,config,configure,31093,"trength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmanns constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats(self)[source]; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset(self)[source]; Reset any attributes to default values. class HSolv",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:32169,Modifiability,config,config,32169,"e, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats(self)[source]; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset(self)[source]; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:32960,Modifiability,coupling,coupling,32960,"e used; Set to False for no stats. create_new_stats(self)[source]; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset(self)[source]; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset(self)[source]; Reset any attributes to default values. run(self, rho0, tlist)[source]; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedba",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:33096,Modifiability,config,configure,33096,"values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset(self)[source]; Reset any attributes to default values. run(self, rho0, tlist)[source]; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coup",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:33304,Modifiability,config,configure,33304,"values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset(self)[source]; Reset any attributes to default values. run(self, rho0, tlist)[source]; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coup",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:33652,Modifiability,evolve,evolves,33652,"ich depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset(self)[source]; Reset any attributes to default values. run(self, rho0, tlist)[source]; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conve",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:34106,Modifiability,coupling,coupling,34106," H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset(self)[source]; Reset any attributes to default values. run(self, rho0, tlist)[source]; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {propagator, mesolve}Integrator method to use. Defaults to propagator which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for propagator; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None)[source",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:34239,Modifiability,coupling,coupling,34239,"tions=None, progress_bar=None, stats=None)[source]; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset(self)[source]; Reset any attributes to default values. run(self, rho0, tlist)[source]; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {propagator, mesolve}Integrator method to use. Defaults to propagator which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for propagator; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None)[source]; Compute output field expectation value; <O_n(tn)O_2(t2)O_1(t1)> for times t1,t2, and; O_i = I, b_out, b_out^dagger, b_loop, b_lo",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:54614,Modifiability,evolve,evolves,54614,"sis. lindbladian(self)[source]; Build the Lindbladian superoperator of the dissipative dynamics. Returns. lindbladianqutip.QobjThe Lindbladian matrix as a qutip.Qobj. liouvillian(self)[source]; Build the total Liouvillian using the Dicke basis. Returns. liouvqutip.QobjThe Liouvillian matrix for the system. pisolve(self, initial_state, tlist, options=None)[source]; Solve for diagonal Hamiltonians and initial states faster. Parameters. initial_statequtip.QobjAn initial state specified as a density matrix of; qutip.Qbj type. tlist: ndarrayA 1D numpy array of list of timesteps to integrate. optionsqutip.solver.OptionsThe options for the solver. Returns. result: listA dictionary of the type qutip.solver.Result which holds the; results of the evolution. class Pim(N, emission=0.0, dephasing=0, pumping=0, collective_emission=0, collective_pumping=0, collective_dephasing=0)[source]; The Permutation Invariant Matrix class.; Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state p as:. dp/dt = Mp. Parameters. N: intThe number of two-level systems. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_emission: floatCollective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: floatCollective pumping coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coefficient.; default: 0.0. Attributes. N: intThe number of two-level systems. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_emission: floatCollective (superradiant) emmission coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coefficient.;",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:63029,Modifiability,variab,variable,63029,"arg_label=None)[source]; Representation of a quantum gate, with its required parametrs, and target; and control qubits. Parameters. namestringGate name. targetslist or intGate targets. controlslist or intGate controls. arg_valuefloatArgument value(phi). arg_labelstringLabel for gate representation. class QubitCircuit(N, input_states=None, output_states=None, reverse_states=True, user_gates=None)[source]; Representation of a quantum program/algorithm, maintaining a sequence; of gates. Parameters. NintNumber of qubits in the system. user_gatesdictDefine a dictionary of the custom gates. See examples for detail. input_stateslistA list of string such as 0,+, A, Y. Only used for latex. Examples; >>> def user_gate():; ... mat = np.array([[1., 0],; ... [0., 1.j]]); ... return Qobj(mat, dims=[[2], [2]]); >>> qc.QubitCircuit(2, user_gates={""T"":user_gate}); >>> qc.add_gate(""T"", targets=[0]). add_1q_gate(self, name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)[source]; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters. namestringGate name. startintStarting location of qubits. endintLast qubit for the gate. qubitslistSpecific qubits for applying gates. arg_valuefloatArgument value(phi). arg_labelstringLabel for gate representation. add_circuit(self, qc, start=0)[source]; Adds a block of a qubit circuit to the main circuit.; Globalphase gates are not added. Parameters. qcQubitCircuitThe circuit block to be added to the main circuit. startintThe qubit on which the first gate is applied. add_gate(self, gate, targets=None, controls=None, arg_value=None, arg_label=None, index=None)[source]; Adds a gate with specified parameters to the circuit. Parameters. gate: string or `Gate`Gate name. If gate is an instance of Gate, parameters are; unpacked and added. targets: listGate targets. controls: listGate controls. arg_value: fl",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:72808,Modifiability,config,config,72808,": QobjThe circular spin chain circuit to be resolved. rwa: BooleanSpecify if RWA is used or not. Returns. qc: QubitCircuitReturns QubitCircuit of resolved gates for the qubit circuit in the; desired basis. get_ops_and_u(self)[source]; Returns the Hamiltonian operators and corresponding values by stacking; them together. get_ops_labels(self)[source]; Returns the Hamiltonian operators and corresponding labels by stacking; them together. load_circuit(self, qc)[source]; Translates an abstract quantum circuit to its corresponding Hamiltonian; for a specific model. Parameters. qc: QubitCircuitTakes the quantum circuit to be implemented. optimize_circuit(self, qc)[source]; Function to take a quantum circuit/algorithm and convert it into the; optimal form/basis for the desired physical system. Parameters. qc: QubitCircuitTakes the quantum circuit to be implemented. Returns. qc: QubitCircuitThe optimal circuit representation. Optimal control. class Optimizer(config, dyn, params=None)[source]; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. algstringAlg",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:73111,Modifiability,config,configuration,73111,"cking; them together. get_ops_labels(self)[source]; Returns the Hamiltonian operators and corresponding labels by stacking; them together. load_circuit(self, qc)[source]; Translates an abstract quantum circuit to its corresponding Hamiltonian; for a specific model. Parameters. qc: QubitCircuitTakes the quantum circuit to be implemented. optimize_circuit(self, qc)[source]; Function to take a quantum circuit/algorithm and convert it into the; optimal form/basis for the desired physical system. Parameters. qc: QubitCircuitTakes the quantum circuit to be implemented. Returns. qc: QubitCircuitThe optimal circuit representation. Optimal control. class Optimizer(config, dyn, params=None)[source]; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. algstringAlgorithm to use in pulse optimisation.; Options are:. GRAPE (default) - GRadient Ascent Pulse Engineering; CRAB - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msgboolSet true to display a convergence message; (fo",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:75644,Modifiability,config,configOptimConfig,75644,"rapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpdump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation - NONE : No processing data dumped (Default) - SUMMARY : A summary at each iteration will be recorded - FULL : All logs will be generated and dumped - CUSTOM : Some cus",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:75678,Modifiability,config,configuration,75678,"rapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpdump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation - NONE : No processing data dumped (Default) - SUMMARY : A summary at each iteration will be recorded - FULL : All logs will be generated and dumped - CUSTOM : Some cus",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:78616,Modifiability,variab,variable,78616,"ze function. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping. The level of data dumping that will occur during the optimisation; NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(self, *args)[source]; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisatio",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:79026,Modifiability,variab,variables,79026,". property dumping. The level of data dumping that will occur during the optimisation; NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(self, *args)[source]; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]; Check the elapsed wall time",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:79180,Modifiability,variab,variables,79180," : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(self, *args)[source]; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(self, term_conds=None)[source]",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:79220,Modifiability,variab,variable,79220,"OM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(self, *args)[source]; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(self, term_conds=None)[source]; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:79888,Modifiability,config,configuration,79888," optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(self, term_conds=None)[source]; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:81232,Modifiability,config,config,81232,"spect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]; Implements the run_optimization method using the BFGS algorithm. run_optimization(self, term_conds=None)[source]; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenFletcherGoldfarbShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to defi",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:82071,Modifiability,config,config,82071," OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]; Implements the run_optimization method using the BFGS algorithm. run_optimization(self, term_conds=None)[source]; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenFletcherGoldfarbShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(self, term_conds=None)[source]; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (loc",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:82232,Modifiability,variab,variable,82232," params=None)[source]; Implements the run_optimization method using the BFGS algorithm. run_optimization(self, term_conds=None)[source]; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenFletcherGoldfarbShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(self, term_conds=None)[source]; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This i",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:82686,Modifiability,config,configuration,82686,"ma), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(self, term_conds=None)[source]; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:83747,Modifiability,config,config,83747,"mplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,190501 (2011). [2] T. ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:84318,Modifiability,config,configuration,84318,"ed implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(self, term_conds=None)[source]; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall ti",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:84357,Modifiability,config,config,84357," documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(self, term_conds=None)[source]; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation wil",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:99222,Modifiability,config,configuration,99222,"he initial to the given; timeslot. get_ctrl_dyn_gen(self, j)[source]; Get the dynamics generator for the control; Not implemented in the base class. Choose a subclass. get_drift_dim(self)[source]; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N. get_dyn_gen(self, k)[source]; Get the combined dynamics generator for the timeslot; Not implemented in the base class. Choose a subclass. get_num_ctrls(self)[source]; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. init_timeslots(self)[source]; Generate the timeslot duration array tau based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array time based on the tau values. initialize_controls(self, amps, init_tslots=True)[source]; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. property num_ctrls; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. property onto_evo; List of evolution operators (Qobj) from the initial to the given; timeslot. property onwd_evo; List of evolution operators (Qobj) from the initial to the given; timeslot. property phase_application; scalar(string), default=preop; Determines how the phase is applied to the dynamics generators. preop : P = expm(phase*dyn_gen); postop : P = expm(dyn_gen*phase); custom : Customised phase application. The custom option assumes that the _apply_phase method has been; set to a custom function. Type; phase_application. property prop; List of propagators (Qobj) for each timeslot. property prop_grad; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs(self)[source];",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:102636,Modifiability,config,configuration,102636,"escribed by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes. drift_hamQobjThis is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_hamList of QobjThese are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. HList of QobjThe combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls. check_unitarity(self)[source]; Checks whether all propagators are unitary; For propagators found not to be unitary, the potential underlying; causes are investigated. initialize_controls(self, amplitudes, init_tslots=True)[source]; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. property num_ctrls; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. class DynamicsSymplectic(optimconfig, params=None)[source]; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes. omegaarray[drift_dyn_gen.shape]matrix used in the calculation of propagators (time evolution); with symplectic systems. property dyn_gen_phase; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as postop dyn_gen*-Omega; If phase_application is preop it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]; Base for all Propagator Computer classes; that are used to calculate the propagators,; an",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:104911,Modifiability,config,configuration,104911,"Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset(self)[source]; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset(self)[source]; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset(self)[source]; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]. Frechet method for calculating the propagator:exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset(self)[source]; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]; Base class for all Fidelity Computers.; This cannot be used directly. Se",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:105191,Modifiability,config,configuration,105191,"on,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset(self)[source]; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset(self)[source]; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset(self)[source]; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]. Frechet method for calculating the propagator:exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset(self)[source]; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are at",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:105388,Modifiability,config,configuration,105388,"omputer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset(self)[source]; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset(self)[source]; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset(self)[source]; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]. Frechet method for calculating the propagator:exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset(self)[source]; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:105756,Modifiability,config,configuration,105756,"irs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset(self)[source]; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset(self)[source]; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset(self)[source]; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]. Frechet method for calculating the propagator:exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset(self)[source]; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:108541,Modifiability,config,configuration,108541,"s; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear(self)[source]; clear any temporarily held status data. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear(self)[source]; clear any temporarily held status data. compute_fid_grad(self)[source]; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Not",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:108604,Modifiability,config,configuration,108604,"lity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear(self)[source]; clear any temporarily held status data. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear(self)[source]; clear any temporarily held status data. compute_fid_grad(self)[source]; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. fla",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:110213,Modifiability,config,config,110213," It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear(self)[source]; clear any temporarily held status data. compute_fid_grad(self)[source]; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity(self)[source]; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm(self)[source]; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp(self)[source]; Check configuration and initialise the normalisation. init_normalization(self)[source]; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(self, A)[source]. normalize_SU(self, A)[source]. normalize_gradient_PSU(self, grad)[source]; Normalise the gradient matrix pas",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:110459,Modifiability,config,configuration,110459," of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity(self)[source]; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm(self)[source]; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp(self)[source]; Check configuration and initialise the normalisation. init_normalization(self)[source]; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(self, A)[source]. normalize_SU(self, A)[source]. normalize_gradient_PSU(self, grad)[source]; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(self, grad)[source]; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. set_phase_option(self, phase_option=None)[sourc",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:111355,Modifiability,config,configuration,111355," cached, because it is used in the gradient calculation. init_comp(self)[source]; Check configuration and initialise the normalisation. init_normalization(self)[source]; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(self, A)[source]. normalize_SU(self, A)[source]. normalize_gradient_PSU(self, grad)[source]; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(self, grad)[source]; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. set_phase_option(self, phase_option=None)[source]; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:113123,Modifiability,config,configuration,113123,"r, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad(self)[source]; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad(self)[source]; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:113234,Modifiability,config,configuration,113234,"bitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad(self)[source]; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad(self)[source]; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasi",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:113838,Modifiability,config,configuration,113838,"ient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad(self)[source]; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summaryEvoCompSummaryA summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or pass",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:126096,Modifiability,config,configurations,126096,"method; Typically this will be the basis coefficients. class PulseGenCrabFourier(dyn=None, num_coeffs=None, params=None)[source]; Generates a pulse using the Fourier basis functions, i.e. sin and cos. Attributes. freqsfloat array[num_coeffs]Frequencies for the basis functions. randomize_freqsboolIf True (default) the some random offset is applied to the frequencies. gen_pulse(self, coeffs=None)[source]; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters. coeffsfloat array[num_coeffs, num_basis_funcs]The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs(self)[source]; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(self, num_coeffs=None)[source]; Set the initial freq and coefficient values. reset(self)[source]; reset attributes to default values. class Stats[source]; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes. dyn_gen_namestringText used in some report functions.; Makes sense to set it to Hamiltonian when using unitary dynamics; Default is simply dynamics generator. num_iterintegerNumber of iterations of the optimisation algorithm. wall_time_optim_startfloatStart time for the optimisation. wall_time_optim_endfloatEnd time for the optimisation. wall_time_optimfloatTime elasped during the optimisation. wall_time_dyn_gen_computefloatTotal wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_computefloatTotal wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_computefloatTotal wall (elasped) time com",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:129850,Modifiability,config,configured,129850,"erages) that are required on the stats; Should be called before calling report. report(self)[source]; Print a report of the stats to the console. class Dump[source]; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dirstrdirectory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. levelstringThe level of data dumping that will occur - SUMMARY : A summary will be recorded - FULL : All possible dumping - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY. write_to_fileboolWhen set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_extstrDefault file extension for any file names that are auto generated. fname_basestrFirst part of any auto generated file names.; This is usually overridden in the subclass. dump_summaryboolIf True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sepstrdelimiter for the summary file.; default is a space. data_sepstrdelimiter for the data files (arrays saved to file).; default is a space. summary_filestrFile path for summary file.; Automatically generated. Can be set specifically. create_dump_dir(self)[source]; Checks dump directory exists, creates it if not. property level. The level of data dumping that will occur; SUMMARY : A summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specif",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:3988,Performance,perform,performing,3988,"; Adjoint (dagger) of quantum object. dnorm(); Diamond norm of quantum operator. dual_chan(); Dual channel of quantum object representing a CP map. eigenenergies(sparse=False, sort=low, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object. eigenstates(sparse=False, sort=low, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object. expm(); Matrix exponential of quantum object. full(order=C); Returns dense array of quantum object data attribute. groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum object. matrix_element(bra, ket); Returns the matrix element of operator between bra and ket vectors. norm(norm=tr, sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator. permute(order); Returns composite qobj with indices reordered. proj(); Computes the projector for a ket or bra vector. ptrace(sel); Returns quantum object for selected dimensions after performing partial trace. sinm(); Sine of quantum object. sqrtm(); Matrix square root of quantum object. tidyup(atol=1e-12); Removes small elements from quantum object. tr(); Trace of quantum object. trans(); Transpose of quantum object. transform(inpt, inverse=False); Performs a basis transformation defined by inpt matrix. trunc_neg(method=clip); Removes negative eigenvalues and returns a new Qobj that is a valid density operator. unit(norm=tr, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. check_herm(self)[source]; Check if the quantum object is hermitian. Returns. ishermboolReturns the new value of isherm property. check_isunitary(self)[source]; Checks whether qobj is a unitary matrix. conj(self)[source]; Conjugate operator of quantum object. copy(self)[source]; Create identical copy. cosm(self)[source]; Cosine of a quantum operator.; Operator must be square. Returns. operqutip.QobjMatrix cosine of operator. Raises. TypeErrorQu",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:6285,Performance,perform,performed,6285,"]; Calculates the diamond norm, or the diamond distance to another; operator. Parameters. Bqutip.Qobj or NoneIf B is not None, the diamond distance d(A, B) = dnorm(A - B) between; this operator and B is returned instead of the diamond norm. Returns. dfloatEither the diamond norm of this operator, or the diamond distance; from this operator to B. dual_chan(self)[source]; Dual channel of quantum object representing a completely positive; map. eigenenergies(self, sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues low to high, or high to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(self, sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) low to high, or high to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. eigvecsarrayArray of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of ei",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:7067,Performance,perform,performed,7067,"ed eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(self, sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) low to high, or high to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. eigvecsarrayArray of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(self, states_inds, normalize=False)[source]; Creates a new quantum object with states in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Expe",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:10514,Performance,perform,performed,10514,"ensity matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(self, order='C', squeeze=False)[source]; Dense array from quantum object. Parameters. orderstr {C, F}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True)[source]; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(self, bra, ket)[source]; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type bra or ket. ketqutip.QobjQuantum object of type ket. Returns. elemcomplexComplex valued matrix element. norm(self, norm=None, sparse=False, tol=0, maxiter=100000)[source]; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters. normstrWhich norm to use for ket/bra vectors: L2 l2, max norm max,; or f",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:11854,Performance,perform,performed,11854,"emand it. matrix_element(self, bra, ket)[source]; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type bra or ket. ketqutip.QobjQuantum object of type ket. Returns. elemcomplexComplex valued matrix element. norm(self, norm=None, sparse=False, tol=0, maxiter=100000)[source]; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters. normstrWhich norm to use for ket/bra vectors: L2 l2, max norm max,; or for operators: trace tr, Frobius fro, one one, or max; max. sparseboolUse sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tolfloatTolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used); for trace norm. Returns. normfloatThe requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(self, other)[source]; Overlap between two state vectors or two operators.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters. otherqutip.QobjQuantum object for a state vector of type ket, bra or density; matrix. Returns. overlapcomplexComplex valued overlap. Raises. TypeErrorCan only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets. permute(self, order)[source]; Permutes",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:16135,Performance,perform,performed,16135,"jOperator in new basis. Notes; This function is still in development. trunc_neg(self, method='clip')[source]; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters. methodstrAlgorithm to use to remove negative eigenvalues. clip; simply discards negative eigenvalues, then renormalizes.; sgs uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(self, inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo. class QobjEvo(Q_object=[], args={}, tlist=None, copy=True)[source]; A class for representing time-dependent quantum objects,; such as quantum operators and states.; The QobjEvo class is a representation of time-dependent Qutip quantum; objects (Qobj). This class implements math operations :. +,- : QobjEvo, Qobj; * : Qobj, C-number; / : C-number. and some common linear operator/state operations. The QobjEvo; are constructed from a nested list of Qobj with their time-dependent; coefficients. The time-dependent coefficients are either a funciton, a; string or a numpy array.; For function format, the function signature must be f(t, args).; Examples. def f1_t(t, args):return np.exp(-1j * t * args[w1]). def f2_t(t, args):return np.cos(t * args[w2]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={w1:1., w2:2.}). For string based coeffients, the string must be ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:20436,Performance,perform,performing,20436,"qobjevocy_qobj (CQobjCte or CQobjEvoTd)Cython version of the QobjEvo. dummy_cteboolis self.cte a dummy Qobj. constboolIndicates if quantum object is Constant. typeint; information about the type of coefficientstring, func, array,; spline, mixed_callable, mixed_compilable. num_objintnumber of Qobj in the QobjEvo : len(ops) + (1 if not dummy_cte). Methods. copy() :; Create copy of Qobj. arguments(new_args):; Update the args of the object. Math:; +/- QobjEvo, Qobj, scalar: Addition is possible between QobjEvo and with Qobj or scalar -: Negation operator * Qobj, scalar: Product is possible with Qobj or scalar / scalar: It is possible to divide by scalar only. conj(); Return the conjugate of quantum object. dag(); Return the adjoint (dagger) of quantum object. trans(); Return the transpose of quantum object. norm(); Return self.dag() * self. Only possible if num_obj == 1. permute(order); Returns composite qobj with indices reordered. ptrace(sel); Returns quantum object for selected dimensions after performing partial trace. apply(f, *args, **kw_args); Apply the function f to every Qobj. f(Qobj) -> Qobj Return a modified QobjEvo and let the original one untouched. apply_decorator(decorator, *args, str_mod=None,; inplace_np=False, **kw_args): Apply the decorator to each function of the ops. The *args and **kw_args are passed to the decorator. new_coeff_function = decorator(coeff_function, *args, **kw_args) str_mod : list of 2 elements replace the string : str_mod[0] + original_string + str_mod[1] *exemple: str_mod = [exp(,)] inplace_np: Change the numpy array instead of applying the decorator to the function reading the array. Some decorators create incorrect array. Transformations f(t) = f(g(t)) create a missmatch between the array and the associated time list. tidyup(atol=1e-12); Removes small elements from quantum object. compress():; Merge ops which are based on the same quantum object and coeff type. compile(code=False, matched=False, dense=False, omp",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:29977,Performance,perform,performance,29977,"ndarrayArray of coeffcients defining cubic spline. Non-Markovian Solvers. class HEOMSolver[source]; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes. H_sysQobjSystem Hamiltonian. coup_opQobjOperator describing the coupling between system and bath. coup_strengthfloatCoupling strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmanns constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflis",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:30828,Performance,perform,performance,30828," density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes. H_sysQobjSystem Hamiltonian. coup_opQobjOperator describing the coupling between system and bath. coup_strengthfloatCoupling strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmanns constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; s",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:31879,Performance,perform,performance,31879,"ad in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats(self)[source]; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset(self)[source]; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency.",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:36970,Performance,perform,performed,36970,"self, blist, tlist, tau, c1=None, c2=None, notrace=False)[source]; Compute propagator for computing output field expectation values; <O_n(tn)O_2(t2)O_1(t1)> for times t1,t2, and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(self, t, tau, notrace=False)[source]; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; -; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(self, rho0, t, tau)[source]; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]; Class of options",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:37460,Performance,perform,performed,37460,"e-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(self, t, tau, notrace=False)[source]; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; -; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(self, rho0, t, tau)[source]; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.s",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:42235,Performance,perform,performance,42235,"multiplication. Default; None means auto check. class Result[source]; Class for storing simulation results from any of the dynamics solvers. Attributes. solverstrWhich solver was used [e.g., mesolve, mcsolve, brmesolve, ]. timeslist/arrayTimes at which simulation data was collected. expectlist/arrayExpectation values (if requested) for simulation. statesarrayState of the simulation (density matrix or ket) evaluated at times. num_expectintNumber of expectation value operators in simulation. num_collapseintNumber of collapse operators in simualation. ntrajint/listNumber of trajectories (for stochastic solvers). A list indicates; that averaging of expectation values was done over a subset of total; number of trajectories. col_timeslistTimes at which state collpase occurred. Only for Monte Carlo solver. col_whichlistWhich collapse operator was responsible for each collapse in; col_times. Only for Monte Carlo solver. class Stats(section_names=None)[source]; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section main. Parameters. section_nameslistlist of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called main is created. Attributes. sectionsOrderedDict of _StatsSectionThese are the sections that are created automatically on instantiation; or added using add_section. headerstringSome text that will be used as the heading in the report; By default there is None. total_timefloatTime in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. Methods. add_section(self,name); Add another section with the given name. add_count(self,key,value[,section]); Add value to count. add_tim",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:74148,Performance,optimiz,optimize,74148,"- describes the dynamics of the (quantum) system. to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. algstringAlgorithm to use in pulse optimisation.; Options are:. GRAPE (default) - GRadient Ascent Pulse Engineering; CRAB - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_gradboolIf set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:74209,Performance,optimiz,optimize,74209,"ol optimised. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. algstringAlgorithm to use in pulse optimisation.; Options are:. GRAPE (default) - GRadient Ascent Pulse Engineering; CRAB - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_gradboolIf set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:76023,Performance,perform,performance,76023,"floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpdump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation - NONE : No processing data dumped (Default) - SUMMARY : A summary at each iteration will be recorded - FULL : All logs will be generated and dumped - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dirstringBasically a link to dump.dump_dir. Exists so that it can be set throu",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:77595,Performance,optimiz,optimize,77595,"tion will be recorded - FULL : All logs will be generated and dumped - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dirstringBasically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summaryOptimIterSummarySummary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(self, params=None)[source]; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping. The level of data dumping that will occur during the optimisation; NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(self, *args)[source]; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:80188,Performance,optimiz,optimize,80188,"he argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(self, term_conds=None)[source]; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason fo",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:81738,Performance,optimiz,optimize,81738,"sted.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]; Implements the run_optimization method using the BFGS algorithm. run_optimization(self, term_conds=None)[source]; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenFletcherGoldfarbShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(self, term_conds=None)[so",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:82407,Performance,optimiz,optimize,82407,"mplitudes to minimise the fidelity error; using the BFGS (BroydenFletcherGoldfarbShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(self, term_conds=None)[source]; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credi",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:83206,Performance,optimiz,optimize,83206,"The maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(self, term_conds=None)[source]; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; r",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:83852,Performance,optimiz,optimize,83852," is the constrained; (bounded amplitude values), limited memory, version of the; BroydenFletcherGoldfarbShanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optim",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:84465,Performance,optimiz,optimize,84465,"onds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(self, term_conds=None)[source]; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:84959,Performance,optimiz,optimize,84959,"tion for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(self, term_conds)[source]; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]; Optimises the pulse using the CRAB algorithm [1, 2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-mead method.; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; This is the default Optimizer for CRAB.; Notes. [1] P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106,190501 (2011). [2] T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326 (2011). run_optimization(self, term_conds=None)[source]; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]; A summary of the most recent iteration of the pulse optimisation. Attributes. iter_numintIteration number of the pulse optimisation. fid_func_call_numintFidel",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:87239,Performance,optimiz,optimize,87239,"efloatTime spent computing the pulse optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes. fid_err_targfloatTarget fidelity error. fid_goalfloatgoal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_timefloat# maximum time for optimisation (seconds). min_gradient_normfloatMinimum normalised gradient after which optimisation will terminate. max_iterationsintegerMaximum iterations of the optimisation algorithm. max_fid_func_callsintegerMaximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]; Attributes give the result of the pulse optimisation attempt. Attributes. termination_reasonstringDescription of the reason for terminating the optimisation. fidelityfloatfinal (normalised) fidelity that was achieved. initial_fid_errfloatfidelity error before optimisation starting. fid_errfloatfinal fidelity error that was achieved. goal_achievedbooleanTrue is the fidely error achieved was below the target. grad_norm_finalfloatFinal value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reachedfloatTrue if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exc",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:89032,Performance,optimiz,optimizerOptimizerInstance,89032,"if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exceededbooleanTrue if the iteration limit was reached. max_fid_func_exceededbooleanTrue if the fidelity function call limit was reached. wall_timefloattime elapsed during the optimisation. wall_time_limit_exceededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initialQobjThe evolution operator from t=0 to t=T based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENS",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:89813,Performance,perform,performance,89813,"n. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initialQobjThe evolution operator from t=0 to t=T based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propaga",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:90531,Performance,perform,performance,90531,"at is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory s",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:91856,Performance,perform,performs,91856,"stance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsU",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:91909,Performance,perform,perform,91909,"ance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, o",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:91959,Performance,perform,perform,91959,"ance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, o",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:92452,Performance,cache,cache,92452," maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslotsintegerNumber of timeslots (aka timeslices). num_ctrlsintegercalculate the of controls from the length of the control list. evo_timefloatTotal time for the evolution. tauarray[num_tslots] of floatDuration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:92705,Performance,cache,cached,92705,". This can be ndarray or Qobj, or (in theory) any; other representaion that supports typical matrix methods (e.g. dot); ndarray performs best for smaller quantum systems.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslotsintegerNumber of timeslots (aka timeslices). num_ctrlsintegercalculate the of controls from the length of the control list. evo_timefloatTotal time for the evolution. tauarray[num_tslots] of floatDuration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time slices. timearray[num_tslots+1] of floatCumulative time for the evolution, that is the time at the start; of each time slice. drift_dyn_genQobj or list of QobjDrift or system dynamics generator (Hamiltonian); Matrix defining the underlying dynamics of the system; Can also be a list of Qobj (length num_tslo",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:109920,Performance,cache,cached,109920,"phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear(self)[source]; clear any temporarily held status data. compute_fid_grad(self)[source]; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity(self)[source]; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm(self)[source]; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp(self)[source]; Check configuration and initialise the normalisation. init_normalization(self)[source]; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:110371,Performance,cache,cached,110371,"hen amplitudes change. clear(self)[source]; clear any temporarily held status data. compute_fid_grad(self)[source]; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity(self)[source]; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm(self)[source]; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp(self)[source]; Check configuration and initialise the normalisation. init_normalization(self)[source]; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(self, A)[source]. normalize_SU(self, A)[source]. normalize_gradient_PSU(self, grad)[source]; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(self, grad)[source]; Normalise the gradient matrix passed as grad; This SU version respects global phase. ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:112934,Performance,cache,cached,112934,"re for dynamics described by matrices; Note the gradient calculation is taken from:; Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad(self)[source]; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad(self)[source]; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class TimeslotCompute",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:131154,Performance,optimiz,optimizer,131154,"ally overridden in the subclass. dump_summaryboolIf True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sepstrdelimiter for the summary file.; default is a space. data_sepstrdelimiter for the data files (arrays saved to file).; default is a space. summary_filestrFile path for summary file.; Automatically generated. Can be set specifically. create_dump_dir(self)[source]; Checks dump directory exists, creates it if not. property level. The level of data dumping that will occur; SUMMARY : A summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary(self)[source]; add copy of current optimizer iteration summary. property dump_all; True if everything (ignoring the summary) is to be dumped. property dump_any; True if anything other than the summary is to be dumped. update_fid_err_log(self, fid_err)[source]; add an entry to the fid_err log. update_grad_log(self, grad)[source]; add an entry to the grad log. update_grad_norm_log(self, grad_norm)[source]; add an entry to the grad_norm log. writeout(self, f=None)[source]; write all the logs and the summar",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:131670,Performance,optimiz,optimizer,131670,"mping that will occur; SUMMARY : A summary will be recorded; FULL : All possible dumping; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary(self)[source]; add copy of current optimizer iteration summary. property dump_all; True if everything (ignoring the summary) is to be dumped. property dump_any; True if anything other than the summary is to be dumped. update_fid_err_log(self, fid_err)[source]; add an entry to the fid_err log. update_grad_log(self, grad)[source]; add an entry to the grad log. update_grad_norm_log(self, grad_norm)[source]; add an entry to the grad_norm log. writeout(self, f=None)[source]; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]; A container for dumps of dynamics data.; Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_s",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:10173,Safety,safe,safe,10173," TypeErrorQuantum operator is not square. extract_states(self, states_inds, normalize=False)[source]; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(self, order='C', squeeze=False)[source]; Dense array from quantum object. Parameters. orderstr {C, F}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True)[source]; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(self, bra, ket)[source]; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type bra or ket. ketqutip.QobjQuantum object of type ket. Returns. elemcomplexComplex valued mat",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:10552,Safety,safe,safebool,10552,"to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(self, order='C', squeeze=False)[source]; Dense array from quantum object. Parameters. orderstr {C, F}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(self, sparse=False, tol=0, maxiter=100000, safe=True)[source]; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. matrix_element(self, bra, ket)[source]; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type bra or ket. ketqutip.QobjQuantum object of type ket. Returns. elemcomplexComplex valued matrix element. norm(self, norm=None, sparse=False, tol=0, maxiter=100000)[source]; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters. normstrWhich norm to use for ket/bra vectors: L2 l2, max norm max,; or for operators: trace tr, Frobius fro, one one, or max; max. ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:89408,Security,access,access,89408,"ededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initialQobjThe evolution operator from t=0 to t=T based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exis",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:17286,Testability,log,log,17286,"tlist=None, copy=True)[source]; A class for representing time-dependent quantum objects,; such as quantum operators and states.; The QobjEvo class is a representation of time-dependent Qutip quantum; objects (Qobj). This class implements math operations :. +,- : QobjEvo, Qobj; * : Qobj, C-number; / : C-number. and some common linear operator/state operations. The QobjEvo; are constructed from a nested list of Qobj with their time-dependent; coefficients. The time-dependent coefficients are either a funciton, a; string or a numpy array.; For function format, the function signature must be f(t, args).; Examples. def f1_t(t, args):return np.exp(-1j * t * args[w1]). def f2_t(t, args):return np.cos(t * args[w2]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={w1:1., w2:2.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. sin cos tan asin acos atan pi; sinh cosh tanh asinh acosh atanh; exp log log10 erf zerf sqrt; real imag conj abs norm arg proj; numpy as np, and scipy.special as spe. Examples; H = QobjEvo([H0, [H1, exp(-1j*w1*t)], [H2, cos(w2*t)]],args={w1:1.,w2:2.}). For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; Examples. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],. tlist=tlist). args is a dict of (name:object). The name must be a valid variables string.; Some solvers support arguments that update at each call:; sesolve, mesolve, mcsolve:. state can be obtained with:name+=vec:Qobj => args[name] == state as 1D np.ndarray; name+=mat:Qobj => args[name] == state as 2D np.ndarray; name+=Qobj:Qobj => args[name] == state as Qobj; This Qobj is the initial value. expectation values:n",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:17782,Testability,log,logspace,17782,"n, a; string or a numpy array.; For function format, the function signature must be f(t, args).; Examples. def f1_t(t, args):return np.exp(-1j * t * args[w1]). def f2_t(t, args):return np.cos(t * args[w2]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={w1:1., w2:2.}). For string based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:. sin cos tan asin acos atan pi; sinh cosh tanh asinh acosh atanh; exp log log10 erf zerf sqrt; real imag conj abs norm arg proj; numpy as np, and scipy.special as spe. Examples; H = QobjEvo([H0, [H1, exp(-1j*w1*t)], [H2, cos(w2*t)]],args={w1:1.,w2:2.}). For numpy array format, the array must be an 1d of dtype float or complex.; A list of times (float64) at which the coeffients must be given (tlist).; The coeffients array must have the same len as the tlist.; The time of the tlist do not need to be equidistant, but must be sorted.; Examples. tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],. tlist=tlist). args is a dict of (name:object). The name must be a valid variables string.; Some solvers support arguments that update at each call:; sesolve, mesolve, mcsolve:. state can be obtained with:name+=vec:Qobj => args[name] == state as 1D np.ndarray; name+=mat:Qobj => args[name] == state as 2D np.ndarray; name+=Qobj:Qobj => args[name] == state as Qobj; This Qobj is the initial value. expectation values:name+=expect:O (Qobj/QobjEvo) => args[name] == expect(O, state); expect is <phi|O|psi> or tr(state * O) depending on state dimensions. mcsolve:; collapse can be obtained with:name+=collapse:list => args[name] == list of collapse; each collapse will be appended to the list as (time, which c_ops). Mixing the formats is possible, but not recommended.; Mixing tlist will cause problem. Parameters. QobjEvo(Q_object=[], args={}, tlist=None); Q_objectarray_likeData for vector/matrix representation of the quantum ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:73290,Testability,log,logger,73290,"em together. load_circuit(self, qc)[source]; Translates an abstract quantum circuit to its corresponding Hamiltonian; for a specific model. Parameters. qc: QubitCircuitTakes the quantum circuit to be implemented. optimize_circuit(self, qc)[source]; Function to take a quantum circuit/algorithm and convert it into the; optimal form/basis for the desired physical system. Parameters. qc: QubitCircuitTakes the quantum circuit to be implemented. Returns. qc: QubitCircuitThe optimal circuit representation. Optimal control. class Optimizer(config, dyn, params=None)[source]; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses; This class implements the fidelity, gradient and interation callback; functions.; All subclass objects must be initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system. to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. algstringAlgorithm to use in pulse optimisation.; Options are:. GRAPE (default) - GRadient Ascent Pulse Engineering; CRAB - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the pulse optim algorithm; that is GRAPE or CRAB. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:76634,Testability,log,logs,76634,"sed; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpdump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation - NONE : No processing data dumped (Default) - SUMMARY : A summary at each iteration will be recorded - FULL : All logs will be generated and dumped - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dirstringBasically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summaryOptimIterSummarySummary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(self, params=None)[source]; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:78175,Testability,log,logs,78175,"ing to SUMMARY; when setting a path. iter_summaryOptimIterSummarySummary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(self, params=None)[source]; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping. The level of data dumping that will occur during the optimisation; NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(self, *args)[source]; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algor",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:78353,Testability,log,logs,78353,"e method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping. The level of data dumping that will occur during the optimisation; NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(self, *args)[source]; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(self, *args)[source]; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; a",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:80740,Testability,test,tested,80740,"ck optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(self, *args)[source]; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(self, term_conds=None)[source]; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]; Implements the run_optimization method using the BFGS algorithm. run_optimization(self, term_conds=None)[source]; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (BroydenFletcherGoldfarbShanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrappe",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:89958,Testability,log,logger,89958," based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_com",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:100928,Testability,log,logged,100928," that the _apply_phase method has been; set to a custom function. Type; phase_application. property prop; List of propagators (Qobj) for each timeslot. property prop_grad; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs(self)[source]; Reset the dyn_shape, dyn_dims and time_depend_drift attribs. save_amps(self, file_name=None, times=None, amps=None, verbose=False)[source]; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters. file_namestringName of the file; If None given the def_amps_fname attribuite will be used. timesList type (or string)List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If exclude then times will not be saved in the file, just; the amplitudes. ampsArray[num_tslots, num_ctrls]Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verboseBooleanIf True then an info message will be logged. unitarity_check(self)[source]; Checks whether all propagators are unitary. update_ctrl_amps(self, new_amps)[source]; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer. class DynamicsGenMat(optimconfig, params=None)[source]; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Lindbladian. class DynamicsUnitary(optimconfig, params=None)[source]; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes. drift_hamQobjThis is the drift Ha",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:103967,Testability,log,logger,103967,"his is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes. omegaarray[drift_dyn_gen.shape]matrix used in the calculation of propagators (time evolution); with symplectic systems. property dyn_gen_phase; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as postop dyn_gen*-Omega; If phase_application is preop it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset(self)[source]; reset any configuration data. class PropComp",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:104014,Testability,log,logging,104014,"hape]matrix used in the calculation of propagators (time evolution); with symplectic systems. property dyn_gen_phase; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as postop dyn_gen*-Omega; If phase_application is preop it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset(self)[source]; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:106161,Testability,log,logger,106161,"approximate methods. reset(self)[source]; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset(self)[source]; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]. Frechet method for calculating the propagator:exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset(self)[source]; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evobooleanflag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evoboolean; flag to specify whether the onto_evo evolution operator(see Dynamics) is used by the FidelityComputer. fid_errfloatLast computed value of the fidelity error. fidelityfloatLast computed value of the ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:114181,Testability,log,logger,114181,"ulates the scale_factor is not already set. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad(self)[source]; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summaryEvoCompSummaryA summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dump_current(self)[source]; Store a copy of the current time evolution. class TSlotC",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:117495,Testability,log,logger,117495,"e if given). scalingfloatlinear scaling applied to the pulse; (copied from Dynamics.initial_ctrl_scaling if given). offsetfloatlinear offset applied to the pulse; (copied from Dynamics.initial_ctrl_offset if given). tauarray[num_tslots] of floatDuration of each timeslot; (copied from Dynamics if given). lboundfloatLower boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is -Inf. uboundfloatUpper boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is Inf. periodicbooleanTrue if the pulse generator produces periodic pulses. randombooleanTrue if the pulse generator produces random pulses. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value. gen_pulse(self)[source]; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass. init_pulse(self)[source]; Initialise the pulse parameters. reset(self)[source]; reset attributes to default values. class PulseGenRandom(dyn=None, params=None)[source]; Generates random pulses as simply random values for ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:131927,Testability,log,log,131927,"cifically is dumped. class OptimDump(optim, level='SUMMARY')[source]; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary(self)[source]; add copy of current optimizer iteration summary. property dump_all; True if everything (ignoring the summary) is to be dumped. property dump_any; True if anything other than the summary is to be dumped. update_fid_err_log(self, fid_err)[source]; add an entry to the fid_err log. update_grad_log(self, grad)[source]; add an entry to the grad log. update_grad_norm_log(self, grad_norm)[source]; add an entry to the grad_norm log. writeout(self, f=None)[source]; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]; A container for dumps of dynamics data.; Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of :class:`tslotcomp.EvoCompSummarySummary items are appended if dump_summary is True; at each recomputation of the evolution. dump_ampsboolIf True control amplitudes are dumped. dump_dyn_genboolIf True the dynamics generato",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:131995,Testability,log,log,131995,"container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary(self)[source]; add copy of current optimizer iteration summary. property dump_all; True if everything (ignoring the summary) is to be dumped. property dump_any; True if anything other than the summary is to be dumped. update_fid_err_log(self, fid_err)[source]; add an entry to the fid_err log. update_grad_log(self, grad)[source]; add an entry to the grad log. update_grad_norm_log(self, grad_norm)[source]; add an entry to the grad_norm log. writeout(self, f=None)[source]; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]; A container for dumps of dynamics data.; Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of :class:`tslotcomp.EvoCompSummarySummary items are appended if dump_summary is True; at each recomputation of the evolution. dump_ampsboolIf True control amplitudes are dumped. dump_dyn_genboolIf True the dynamics generators (Hamiltonians) are dumped. dump_propboolIf True propagators are dumpe",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:132078,Testability,log,log,132078,"sation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary(self)[source]; add copy of current optimizer iteration summary. property dump_all; True if everything (ignoring the summary) is to be dumped. property dump_any; True if anything other than the summary is to be dumped. update_fid_err_log(self, fid_err)[source]; add an entry to the fid_err log. update_grad_log(self, grad)[source]; add an entry to the grad log. update_grad_norm_log(self, grad_norm)[source]; add an entry to the grad_norm log. writeout(self, f=None)[source]; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]; A container for dumps of dynamics data.; Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of :class:`tslotcomp.EvoCompSummarySummary items are appended if dump_summary is True; at each recomputation of the evolution. dump_ampsboolIf True control amplitudes are dumped. dump_dyn_genboolIf True the dynamics generators (Hamiltonians) are dumped. dump_propboolIf True propagators are dumped. dump_prop_gradboolIf True propagator gradients are dumped. dump_fwd_evobo",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:132130,Testability,log,logs,132130,"_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary(self)[source]; add copy of current optimizer iteration summary. property dump_all; True if everything (ignoring the summary) is to be dumped. property dump_any; True if anything other than the summary is to be dumped. update_fid_err_log(self, fid_err)[source]; add an entry to the fid_err log. update_grad_log(self, grad)[source]; add an entry to the grad log. update_grad_norm_log(self, grad_norm)[source]; add an entry to the grad_norm log. writeout(self, f=None)[source]; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]; A container for dumps of dynamics data.; Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of :class:`tslotcomp.EvoCompSummarySummary items are appended if dump_summary is True; at each recomputation of the evolution. dump_ampsboolIf True control amplitudes are dumped. dump_dyn_genboolIf True the dynamics generators (Hamiltonians) are dumped. dump_propboolIf True propagators are dumped. dump_prop_gradboolIf True propagator gradients are dumped. dump_fwd_evoboolIf True forward evolution operators are dumped. dump_onwd_evoboolIf True onward e",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:15501,Usability,simpl,simply,15501,"ject. Returns. tracefloatReturns real if operator is Hermitian, returns complex; otherwise. trans(self)[source]; Transposed operator. Returns. operqutip.QobjTranspose of input operator. transform(self, inpt, inverse=False, sparse=True)[source]; Basis transform defined by input array.; Input array can be a matrix defining the transformation,; or a list of kets that defines the new basis. Parameters. inptarray_likeA matrix or list of kets defining the transformation. inverseboolWhether to return inverse transformation. sparseboolUse sparse matrices when possible. Can be slower. Returns. operqutip.QobjOperator in new basis. Notes; This function is still in development. trunc_neg(self, method='clip')[source]; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters. methodstrAlgorithm to use to remove negative eigenvalues. clip; simply discards negative eigenvalues, then renormalizes.; sgs uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(self, inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo. class QobjEvo(Q_object=[], args={}, tlist=None, copy=True)[source]; A class for representing time-dependent quantum objects,; such as quantum operators and states.; The QobjEvo class is a representation of time-dependent Qutip quantum; objects (Qobj). This class imple",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:24980,Usability,simpl,simple,24980,"f font used for Bloch sphere labels. frame_alphafloat {0.1}Sets transparency of Bloch sphere frame. frame_colorstr {gray}Color of sphere wireframe. frame_widthint {1}Width of wireframe. point_colorlist {[b,r,g,#CC6600]}List of colors for Bloch sphere point markers to cycle through.; i.e. By default, points 0 and 4 will both be blue (b). point_markerlist {[o,s,d,^]}List of point marker shapes to cycle through. point_sizelist {[25,32,35,45]}List of point marker sizes. Note, not all point markers look; the same size when plotted!. sphere_alphafloat {0.2}Transparency of Bloch sphere itself. sphere_colorstr {#FFDDDD}Color of Bloch sphere. figsizelist {[7,7]}Figure size of Bloch sphere plot. Best to have both numbers the same;; otherwise you will have a Bloch sphere that looks like a football. vector_colorlist {[g,#CC6600,b,r]}List of vector colors to cycle through. vector_widthint {5}Width of displayed vectors. vector_stylestr {-|>, simple, fancy, }Vector arrowhead style (from matplotlibs arrow style). vector_mutationint {20}Width of vectors arrowhead. viewlist {[-60,30]}Azimuthal and Elevation viewing angles. xlabellist {[$x$,]}List of strings corresponding to +x and -x axes labels, respectively. xlposlist {[1.1,-1.1]}Positions of +x and -x labels respectively. ylabellist {[$y$,]}List of strings corresponding to +y and -y axes labels, respectively. ylposlist {[1.2,-1.2]}Positions of +y and -y labels respectively. zlabellist {[r$\left|0\right>$,r$\left|1\right>$]}List of strings corresponding to +z and -z axes labels, respectively. zlposlist {[1.2,-1.2]}Positions of +z and -z labels respectively. add_annotation(self, state_or_vector, text, **kwargs)[source]; Add a text or LaTeX annotation to Bloch sphere,; parametrized by a qubit state or a vector. Parameters. state_or_vectorQobj/array/list/tuplePosition for the annotaion.; Qobj of a qubit or a vector of 3 elements. textstr/unicodeAnnotation text.; You can use LaTeX, bu",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:26815,Usability,clear,clear,26815,"ate_or_vectorQobj/array/list/tuplePosition for the annotaion.; Qobj of a qubit or a vector of 3 elements. textstr/unicodeAnnotation text.; You can use LaTeX, but remember to use raw string; e.g. r$langle x rangle$; or escape backslashes; e.g. $\langle x \rangle$. **kwargs :Options as for mplot3d.axes3d.text, including:; fontsize, color, horizontalalignment, verticalalignment. add_points(self, points, meth='s')[source]; Add a list of data points to bloch sphere. Parameters. pointsarray/listCollection of data points. methstr {s, m, l}Type of points to plot, use m for multicolored, l for points; connected with a line. add_states(self, state, kind='vector')[source]; Add a state vector Qobj to Bloch sphere. Parameters. stateqobjInput state vector. kindstr {vector,point}Type of object to plot. add_vectors(self, vectors)[source]; Add a list of vectors to Bloch sphere. Parameters. vectorsarray_likeArray with vectors of unit length or smaller. clear(self)[source]; Resets Bloch sphere data sets to empty. make_sphere(self)[source]; Plots Bloch sphere and data sets. render(self, fig=None, axes=None)[source]; Render the Bloch sphere and its data sets in on given figure and axes. save(self, name=None, format='png', dirc=None)[source]; Saves Bloch sphere to file of type format in directory dirc. Parameters. namestrName of saved image. Must include path and format as well.; i.e. /Users/Paul/Desktop/bloch.png; This overrides the format and dirc arguments. formatstrFormat of output image. dircstrDirectory for output images. Defaults to current working directory. Returns. File containing plot of Bloch sphere. set_label_convention(self, convention)[source]; Set x, y and z labels according to one of conventions. Parameters. conventionstringOne of the following:. original; xyz; sx sy sz; 01; polarization jones; polarization jones letters; see also: http://en.wikipedia.org/wiki/Jones_calculus; polarization stokes; see also: http://en.wikipedia",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:28078,Usability,simpl,simple,28078,"axes. save(self, name=None, format='png', dirc=None)[source]; Saves Bloch sphere to file of type format in directory dirc. Parameters. namestrName of saved image. Must include path and format as well.; i.e. /Users/Paul/Desktop/bloch.png; This overrides the format and dirc arguments. formatstrFormat of output image. dircstrDirectory for output images. Defaults to current working directory. Returns. File containing plot of Bloch sphere. set_label_convention(self, convention)[source]; Set x, y and z labels according to one of conventions. Parameters. conventionstringOne of the following:. original; xyz; sx sy sz; 01; polarization jones; polarization jones letters; see also: http://en.wikipedia.org/wiki/Jones_calculus; polarization stokes; see also: http://en.wikipedia.org/wiki/Stokes_parameters. show(self)[source]; Display Bloch sphere and corresponding data sets. vector_mutation = None; Sets the width of the vectors arrowhead. vector_style = None; Style of Bloch vectors, default = -|> (or simple). vector_width = None; Width of Bloch vectors, default = 5. Cubic Spline. class Cubic_Spline(a, b, y, alpha=0, beta=0)[source]; Calculates coefficients for a cubic spline; interpolation of a given data set.; This function assumes that the data is sampled; uniformly over a given interval. Parameters. afloatLower bound of the interval. bfloatUpper bound of the interval. yndarrayFunction values at interval points. alphafloatSecond-order derivative at a. Default is 0. betafloatSecond-order derivative at b. Default is 0. Notes; This object can be called like a normal function with a; single or array of input points at which to evaluate; the interplating function.; Habermann & Kindermann, Multidimensional Spline Interpolation:; Theory and Applications, Comput Econ 30, 153 (2007). Attributes. afloatLower bound of the interval. bfloatUpper bound of the interval. coeffsndarrayArray of coeffcients defining cubic spline. Non-Markovian Solvers. class HEOM",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:31713,Usability,progress bar,progress bar,31713,"of, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats(self)[source]; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset(self)[source]; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:31760,Usability,progress bar,progress bar,31760,"of, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats(self)[source]; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset(self)[source]; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:33973,Usability,feedback,feedback,33973,"tributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(self, H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset(self)[source]; Reset any attributes to default values. run(self, rho0, tlist)[source]; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {propagator, mesolve}Integrator method to use. Defaults to propagator which tends to be; faster for long times (i.e., l",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:34124,Usability,feedback,feedback,34124," H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset(self)[source]; Reset any attributes to default values. run(self, rho0, tlist)[source]; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {propagator, mesolve}Integrator method to use. Defaults to propagator which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for propagator; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None)[source",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:34259,Usability,feedback,feedback,34259,"tions=None, progress_bar=None, stats=None)[source]; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset(self)[source]; Reset any attributes to default values. run(self, rho0, tlist)[source]; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {propagator, mesolve}Integrator method to use. Defaults to propagator which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for propagator; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None)[source]; Compute output field expectation value; <O_n(tn)O_2(t2)O_1(t1)> for times t1,t2, and; O_i = I, b_out, b_out^dagger, b_loop, b_lo",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:34464,Usability,feedback,feedback,34464,"ny attributes to default values. run(self, rho0, tlist)[source]; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {propagator, mesolve}Integrator method to use. Defaults to propagator which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for propagator; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(self, rho0, blist, tlist, tau, c1=None, c2=None)[source]; Compute output field expectation value; <O_n(tn)O_2(t2)O_1(t1)> for times t1,t2, and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:37901,Usability,learn,learningtimes,37901,") tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(self, t, tau, notrace=False)[source]; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; -; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(self, rho0, t, tau)[source]; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_sta",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:38302,Usability,learn,learning,38302,"t to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; -; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(self, rho0, t, tau)[source]; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:45418,Usability,clear,clear,45418," string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(self, name)[source]; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. sectionclassThe new section. add_timing(self, key, value, section=None)[source]; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear(self)[source]; Clear counts, timings and messages from all sections. report(self, output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>)[source]; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters. outputstreamfile or console stream - anything that support write - where; the output will be written. set_total_time(self, value, section=None)[source]; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters. valuefloatTime in seconds to complete the solver section. sectionstring or classSection which to set the total_time for; If None given, the total_time for complete solve",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:50456,Usability,progress bar,progress bar,50456,"t instance returned by the solver. noiseint, array[int, 1d], array[double, 4d]int : seed of the noise; array[int, 1d], length = ntraj, seeds for each trajectories; array[double, 4d] (ntraj, len(times), nsubsteps, len(sc_ops)*[1|2]). vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. The correspond to results.noise. noiseDepthintNumber of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalizebool(default True for (photo)ssesolve, False for (photo)smesolve); Whether or not to normalize the wave function during the evolution.; Normalizing density matrices introduce numerical errors. optionsqutip.solver.OptionsGeneric solver options. Only options.average_states and; options.store_states are used. map_func: functionA map function or managing the calls to single-trajactory solvers. map_kwargs: dictionaryOptional keyword arguments to the map_func function function. progress_barqutip.ui.BaseProgressBarOptional progress bar class instance. *; time-dependent Qobj can be used for H, c_ops and sc_ops.; The format for time-dependent system hamiltonian is:; H = [Qobj0,[Qobj1,coeff1],[Qobj2,coeff2],]= Qobj0 + Qobj1 * coeff1(t) + Qobj2 * coeff2(t). coeff function can be:function: coeff(t, args) -> complex; str: sin(1j*w*t); np.array[complex, 1d] of length equal to the times array. The argument args for the function coeff is the args keyword argument ofthe stochastic solver. Likewisem in str cases, the parameters (w in this case) are taken fromthe args keywords argument. *While mixing coeff type does not results in errors, it is not recommended.*; For the collapse operators (c_ops, sc_ops):; Each operators can only be composed of 1 Qobj.; c_ops = [c_op1, c_op2, ]; where, c_opN = Qobj or [Qobj,coeff]; The coeff format is the same as for the Hamiltonian. Permutational Invariance. class Dicke(N, hamiltonian=None, emission=0.0, dephasing=0.0, pumping=0.0, collective_emission=0.0, collective_dephasin",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:56527,Usability,simpl,simple,56527,"diant) emmission coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coefficient.; default: 0.0. collective_pumping: floatCollective pumping coefficient.; default: 0.0. M: dictA nested dictionary of the structure {row: {col: val}} which holds; non zero elements of the matrix M. calculate_j_m(self, dicke_row, dicke_col)[source]; Get the value of j and m for the particular Dicke space element. Parameters. dicke_row, dicke_col: intThe row and column from the Dicke space matrix. Returns. j, m: floatThe j and m values. calculate_k(self, dicke_row, dicke_col)[source]; Get k value from the current row and column element in the Dicke space. Parameters. dicke_row, dicke_col: intThe row and column from the Dicke space matrix. Returns; -; k: intThe row index for the matrix M for given Dicke space; element. coefficient_matrix(self)[source]; Generate the matrix M governing the dynamics for diagonal cases.; If the initial density matrix and the Hamiltonian is diagonal, the; evolution of the system is given by the simple ODE: dp/dt = Mp. isdicke(self, dicke_row, dicke_col)[source]; Check if an element in a matrix is a valid element in the Dicke space.; Dicke row: j value index. Dicke column: m value index.; The function returns True if the element exists in the Dicke space and; False otherwise. Parameters. dicke_row, dicke_colintIndex of the element in Dicke space which needs to be checked. solve(self, rho0, tlist, options=None)[source]; Solve the ODE for the evolution of diagonal states and Hamiltonians. tau1(self, j, m)[source]; Calculate coefficient matrix element relative to (j, m, m). tau2(self, j, m)[source]; Calculate coefficient matrix element relative to (j, m+1, m+1). tau3(self, j, m)[source]; Calculate coefficient matrix element relative to (j+1, m+1, m+1). tau4(self, j, m)[source]; Calculate coefficient matrix element relative to (j-1, m+1, m+1). tau5(self, j, m)[source]; Calculate coefficient matrix element relative to (j+1, m, m). t",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:105049,Usability,simpl,simply,105049,"s.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset(self)[source]; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset(self)[source]; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset(self)[source]; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]. Frechet method for calculating the propagator:exponentiating the combined dynamics generator. and the propagator gradient; It should work for all systems, e.g. unitary, open, symplectic; There are other PropagatorComputer subclasses that may be more efficient. reset(self)[source]; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated wit",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:108067,Usability,clear,clear,108067,". fidelityfloatLast computed value of the normalised fidelity. fidelity_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of floatLast computed values for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear(self)[source]; clear any temporarily held status data. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of th",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:108089,Usability,clear,clear,108089,". fidelityfloatLast computed value of the normalised fidelity. fidelity_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of floatLast computed values for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear(self)[source]; clear any temporarily held status data. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of th",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:108628,Usability,clear,clear,108628,"lity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear(self)[source]; clear any temporarily held status data. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear(self)[source]; clear any temporarily held status data. compute_fid_grad(self)[source]; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. fla",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:109346,Usability,clear,clear,109346,"radient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear(self)[source]; clear any temporarily held status data. compute_fid_grad(self)[source]; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity(self)[source]; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm(self)[source]; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cache",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:109368,Usability,clear,clear,109368,"radient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear(self)[source]; clear any temporarily held status data. compute_fid_grad(self)[source]; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed(self)[source]; Flag fidelity and gradients as needing recalculation. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity(self)[source]; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm(self)[source]; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cache",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:111379,Usability,clear,clear,111379," cached, because it is used in the gradient calculation. init_comp(self)[source]; Check configuration and initialise the normalisation. init_normalization(self)[source]; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(self, A)[source]. normalize_SU(self, A)[source]. normalize_gradient_PSU(self, grad)[source]; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(self, grad)[source]; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. set_phase_option(self, phase_option=None)[source]; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If ",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:113258,Usability,clear,clear,113258,"bitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad(self)[source]; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err(self)[source]; Gets the absolute error in the fidelity. get_fid_err_gradient(self)[source]; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad(self)[source]; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasi",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:113862,Usability,clear,clear,113862,"ient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp(self)[source]; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad(self)[source]; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset(self)[source]; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summaryEvoCompSummaryA summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or pass",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:115691,Usability,simpl,simply,115691," stats or dump are set. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dump_current(self)[source]; Store a copy of the current time evolution. class TSlotCompUpdateAll(dynamics, params=None)[source]; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated. compare_amps(self, new_amps)[source]; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed. get_timeslot_for_fidelity_calc(self)[source]; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot. recompute_evolution(self)[source]; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary. class PulseGen(dyn=None, params=None)[source]; Pulse generator; Base class for all Pulse generators; The object can optionally be instantiated with a Dynamics object,; in which case the timeslots and amplitude scaling and offset; are copied from that.; Otherwise the class can be used independently by setting:; tau (array of timeslot durations); or; num_tslots and pulse_time for equally spaced timeslots. Attributes. num_tslotsintegerNumber of timeslots, aka timeslices; (copied from Dynamics if given). pulse_timefloattotal duration of the pulse; (copied from Dynamics.evo_time if given). scalingfloatlinear scaling applied to the pulse; (copied from Dynamics.initial_ctrl_scaling if given). offsetfloatlinear offset applied to the pulse; (copied from Dynamics.initial_ctrl_offset if given). tauarray",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:118448,Usability,simpl,simply,118448,"es random pulses. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. apply_params(self, params=None)[source]; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value. gen_pulse(self)[source]; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass. init_pulse(self)[source]; Initialise the pulse parameters. reset(self)[source]; reset attributes to default values. class PulseGenRandom(dyn=None, params=None)[source]; Generates random pulses as simply random values for each timeslot. gen_pulse(self)[source]; Generate a pulse of random values between 1 and -1; Values are scaled using the scaling property; and shifted using the offset property; Returns the pulse as an array of vales for each timeslot. reset(self)[source]; reset attributes to default values. class PulseGenZero(dyn=None, params=None)[source]; Generates a flat pulse. gen_pulse(self)[source]; Generate a pulse with the same value in every timeslot.; The value will be zero, unless the offset is not zero,; in which case it will be the offset. class PulseGenLinear(dyn=None, params=None)[source]; Generates linear pulses. Attributes. gradientfloatGradient of the line.; Note this is calculated from the start_val and end_val if these; are given. start_valfloatStart point of the line. That is the starting amplitude. end_valfloatEnd point of the line.; That is the amplitude at the start of the last timeslot. gen_pulse(self, gradient=None, start_val=",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/classes.html:126411,Usability,simpl,simply,126411,"boolIf True (default) the some random offset is applied to the frequencies. gen_pulse(self, coeffs=None)[source]; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters. coeffsfloat array[num_coeffs, num_basis_funcs]The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs(self)[source]; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(self, num_coeffs=None)[source]; Set the initial freq and coefficient values. reset(self)[source]; reset attributes to default values. class Stats[source]; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes. dyn_gen_namestringText used in some report functions.; Makes sense to set it to Hamiltonian when using unitary dynamics; Default is simply dynamics generator. num_iterintegerNumber of iterations of the optimisation algorithm. wall_time_optim_startfloatStart time for the optimisation. wall_time_optim_endfloatEnd time for the optimisation. wall_time_optimfloatTime elasped during the optimisation. wall_time_dyn_gen_computefloatTotal wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_computefloatTotal wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_computefloatTotal wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating the propagators themselves. wall_time_onwd_prop_computefloatTotal wall (elasped) time computing combined onward propagation,; that is the time evolution from a specific",MatchSource.WIKI,docs/4.4/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/classes.html
https://qutip.org/docs/4.4/apidoc/functions.html:2835,Availability,down,down,2835,"resenting the requested number state |n>. Notes; A subtle incompatibility with the quantum optics toolbox: In QuTiP:; basis(N, 0) = ground state. but in the qotoolbox:; basis(N, 1) = ground state. Examples; >>> basis(5,2); Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.+0.j]; [ 0.+0.j]; [ 1.+0.j]; [ 0.+0.j]; [ 0.+0.j]]. bell_state(state='00')[source]; Returns the Bell state:. |B00> = 1 / sqrt(2)*[|0>|0>+|1>|1>]; |B01> = 1 / sqrt(2)*[|0>|0>-|1>|1>]; |B10> = 1 / sqrt(2)*[|0>|1>+|1>|0>]; |B11> = 1 / sqrt(2)*[|0>|1>-|1>|0>]. Returns. Bell_stateqobjBell state. bra(seq, dim=2)[source]; Produces a multiparticle bra state for a list or string,; where each element stands for state of the respective particle. Parameters. seqstr / list of ints or charactersEach element defines state of the respective particle.; (e.g. [1,1,0,1] or a string 1101).; For qubits it is also possible to use the following conventions:; - g/e (ground and excited state); - u/d (spin up and down); - H/V (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dimint (default: 2) / list of intsSpace dimension for each particle:; int if there are the same, list if they are different. Returns. braqobj. Examples; >>> bra(""10""); Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra; Qobj data =; [[ 0. 0. 1. 0.]]. >>> bra(""Hue""); Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra; Qobj data =; [[ 0. 1. 0. 0. 0. 0. 0. 0.]]. >>> bra(""12"", 3); Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 1. 0. 0. 0.]]. >>> bra(""31"", [5, 2]); Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]. coherent(N, alpha, offset=0, method='operator')[source]; Generates a coherent state with eigenvalue alpha.; Constructed using displacement operator on vacuum state. Parameters. NintNumber of Fock states in",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:10646,Availability,down,down,10646,"sity matrix representation of Fock state. Examples; >>> fock_dm(3,1); Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 0.+0.j]]. ghz_state(N=3)[source]; Returns the N-qubit GHZ-state. Parameters. Nint (default=3)Number of qubits in state. Returns. GqobjN-qubit GHZ-state. maximally_mixed_dm(N)[source]; Returns the maximally mixed density matrix for a Hilbert space of; dimension N. Parameters. NintNumber of basis states in Hilbert space. Returns. dmqobjThermal state density matrix. ket(seq, dim=2)[source]; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters. seqstr / list of ints or charactersEach element defines state of the respective particle.; (e.g. [1,1,0,1] or a string 1101).; For qubits it is also possible to use the following conventions:; - g/e (ground and excited state); - u/d (spin up and down); - H/V (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dimint (default: 2) / list of intsSpace dimension for each particle:; int if there are the same, list if they are different. Returns. ketqobj. Examples; >>> ket(""10""); Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 1.]; [ 0.]]. >>> ket(""Hue""); Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3); Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]); Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]. ket2dm(Q)[source]; Takes input ket or bra vector and returns density matrix; formed by outer prod",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:29703,Availability,error,error,29703," m=1)[source]; Tunneling operator with elements of the form; \(\sum |N><N+m| + |N+m><N|\). Parameters. NintNumber of basis states in Hilbert space. mint (default = 1)Number of excitations in tunneling event. Returns. TQobjTunneling operator. Notes. New in version 3.2. Random Operators and States; This module is a collection of random state and operator generators.; The sparsity of the ouput Qobjs is controlled by varing the; density parameter. rand_dm(N, density=0.75, pure=False, dims=None, seed=None)[source]; Creates a random NxN density matrix. Parameters. Nint, ndarray, listIf int, then shape of output operator. If list/ndarray then eigenvalues; of generated density matrix. densityfloatDensity between [0,1] of output density matrix. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. operqobjNxN density matrix quantum operator. Notes; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that \(Tr(\rho)=1\). rand_dm_ginibre(N=2, rank=None, dims=None, seed=None)[source]; Returns a Ginibre random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. If rank is None, a full-rank; (Hilbert-Schmidt ensemble) random density operator will be; returned. Parameters. NintDimension of the density operator to be returned. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. rankint or NoneRank of the sampled density operator. If None, a full-rank; density operator is generated. Returns. rhoQobjAn N  N density operator sampled from the Ginibre; or Hilbert-Schmidt distribution. rand_dm_hs(N=2, dims=None, seed=None)[source]; Returns a Hilbert-Schmidt random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. Parameters. NintDimension of the density operator to be returned. dimslistDimensions of quantum object. Used for specifyin",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:42301,Availability,mask,mask,42301," over each argument.; For ordinary operators and vectors, this is the tensor product,; while for superoperators and vectorized operators, this is; the column-reshuffled tensor product.; If a mix of Qobjs supported on Hilbert and Liouville spaces; are passed in, the former are promoted. Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose. partial_transpose(rho, mask, method='dense')[source]; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions. concurrence(rho)[source]; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/C",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:42393,Availability,mask,mask,42393," over each argument.; For ordinary operators and vectors, this is the tensor product,; while for superoperators and vectorized operators, this is; the column-reshuffled tensor product.; If a mix of Qobjs supported on Hilbert and Liouville spaces; are passed in, the former are promoted. Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose. partial_transpose(rho, mask, method='dense')[source]; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions. concurrence(rho)[source]; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/C",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:42529,Availability,mask,mask,42529,"led tensor product.; If a mix of Qobjs supported on Hilbert and Liouville spaces; are passed in, the former are promoted. Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose. partial_transpose(rho, mask, method='dense')[source]; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions. concurrence(rho)[source]; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:42626,Availability,mask,mask,42626,"Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose. partial_transpose(rho, mask, method='dense')[source]; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions. concurrence(rho)[source]; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected c",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:42788,Availability,mask,masklist,42788,"using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose. partial_transpose(rho, mask, method='dense')[source]; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions. concurrence(rho)[source]; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entr",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:42806,Availability,mask,mask,42806,"using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose. partial_transpose(rho, mask, method='dense')[source]; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions. concurrence(rho)[source]; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entr",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:83234,Availability,error,errors,83234,"; be used as the initial state. The steady-state is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_ss(H, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object at 0x2b22624eaac8>)[source]; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\]; along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; solver parameter. Parameters. HQobjsystem Hamiltonian. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, ca",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:84648,Availability,error,errors,84648,"False, args={}, options=<qutip.solver.Options object at 0x2b22624eaac8>)[source]; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\]; along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; solver parameter. Parameters. HQobjsystem Hamiltonian. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate; \(\lim_{t \to \infty} \left<A(t)B(t+\tau)\right>\) instead of; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object at 0x2b22624ea978>)[source]; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If state0 is None, then the steady state will; be used as the initial state. The steady-state is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:86212,Availability,error,errors,86212,"arameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If state0 is None, then the steady state will; be used as the initial state. The steady-state is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstr {me, mc, es}choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionsSolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecndarrayAn array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object at 0x2b22624ea9b0>)[source]; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If state0 is None, then the steady state will; be used as the initial state. The steady-state is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-s",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:88017,Availability,error,errors,88017,"he initial state. The steady-state is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matndarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object at 0x2b22624ea9e8>)[source]; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:89722,Availability,error,errors,89722," parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If state0 is None, then the steady state will; be used as the initial state. The steady-state is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object at 0x2b22624eaa20>)[source]; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If state0 is None, then the steady state will; be used as the initial state. The steady-state is only implemented; for the me and es solvers. tlistarra",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:91530,Availability,error,errors,91530,"ho_0\) or state vector; \(\psi_0\). If state0 is None, then the steady state will; be used as the initial state. The steady-state is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object at 0x2b22624eab38>)[source]; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:93267,Availability,error,errors,93267,"t is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If state0 is None, then the steady state will; be used as the initial state. The steady-state is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object at 0x2b22624eab70>)[source]; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If state0 is None, then the steady state will; be used as the initial stat",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:95174,Availability,error,errors,95174,"or; \(\psi_0\). If state0 is None, then the steady state will; be used as the initial state. The steady-state is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. spectrum(H, wlist, c_ops, a_op, b_op, solver='es', use_pinv=False)[source]; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using the solver indicated by the solver parameter. Note: this spectrum; is only defined for stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobj",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:99961,Availability,error,errors,99961,"qrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If state0 is None, then the steady state will; be used as the initial state. The steady-state is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g1, G1tupleThe normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object at 0x2b22624eaa90>)[source]; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If state0 is None, then the steady state will; be used as the initial state. The steady-state is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and c",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:101441,Availability,error,errors,101441,"agger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If state0 is None, then the steady state will; be used as the initial state. The steady-state is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. argsdictDictionary of arguments to be passed to solver. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. Steady-state Solvers; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solverstr {None, scipy, mkl}Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. methodstr {direct, eigen, it",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:102387,Availability,avail,availability,102387,"t,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. Steady-state Solvers; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solverstr {None, scipy, mkl}Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. methodstr {direct, eigen, iterative-gmres,; iterative-lgmres, iterative-bicgstab, svd, power,; power-gmres, power-lgmres, power-bicgstab}. Method for solving the underlying linear equation. Direct LU solver; direct (default), sparse eigenvalue problem eigen,; iterative GMRES method iterative-gmres, iterative LGMRES method; iterative-lgmres, iterative BICGSTAB method iterative-bicgstab,; SVD svd (dense), or inverse-power method power. The iterative; power methods power-gmres, power-lgmres, power-bicgstab use; the same solvers as their direct counterparts. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. sparsebool, optional, default = TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for smaller systems. use_rcmbool,",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:104685,Availability,toler,tolerance,104685,"is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint {10}MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsbool {True, False}MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingbool {True, False}MKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, optional, default=1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, optional, default=1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optional, default=NoneITERATIVE power methods ONLY. Tolerance for lu solve method.; If None given then max(0.1*tol, 1e-15) is used. matolfloat, optional, default=1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optional, default=COLAMDITERATIVE ONLY. Column ordering used internally by superLU for the; direct LU decomposition method. Options include COLAMD and; NATURAL. If using RCM then this is set to NATURAL automatically; unless explicitly specified. use_precondbool optional, default = FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the iterative GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically. fill_factorfloat, optional, default = 100ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower v",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:111633,Availability,error,error,111633,"ed, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object at 0x2b225f631c18>, name=None, cleanup=True)[source]; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters. waveguide_emission_indiceslist or tupleList of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:155479,Availability,error,error,155479,"al maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0qutip.QobjInitial density matrix or state vector (ket). timesarray_likelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisat",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:155647,Availability,error,error,155647,"kelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the v",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:155944,Availability,error,error,155944,"mes \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:156191,Availability,error,error,156191,"TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, ",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:156864,Availability,error,error,156864,"hods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 14 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF'",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:158214,Availability,error,error,158214,"rXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 14 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependen",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:158623,Availability,error,error,158623,"targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjstarting point for the evolution.; Typically the identity matrix. targetQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots]",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:158643,Availability,error,error,158643,"targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjstarting point for the evolution.; Typically the identity matrix. targetQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots]",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:160109,Availability,error,error,160109,"can be provided for time dependent control generators. initialQobjstarting point for the evolution.; Typically the identity matrix. targetQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. GRAPE (default) - GRadient Ascent Pulse Engineering; CRAB - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be u",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:160176,Availability,error,error,160176,"lQobjstarting point for the evolution.; Typically the identity matrix. targetQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. GRAPE (default) - GRadient Ascent Pulse Engineering; CRAB - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note th",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:161150,Availability,error,error,161150,"en the fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. GRAPE (default) - GRadient Ascent Pulse Engineering; CRAB - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value p",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:162715,Availability,error,error,162715," Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_paramsdictParameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. phase_optionstringDeprecated. Pass in fid_params instead. fid_err_scale_factorfloatDeprecated. Use scale_factor key in fid_params instead. tslot_typestringMethod for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_paramsdictParameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. amp_update_modestringDeprecated. Use tslot_type instead. init_pulse_typestringtype / shape of pulse(s) used to initialise the; the control amplitudes.; Options (GRAPE) include:. RN",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:162735,Availability,error,error,162735," Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_paramsdictParameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. phase_optionstringDeprecated. Pass in fid_params instead. fid_err_scale_factorfloatDeprecated. Use scale_factor key in fid_params instead. tslot_typestringMethod for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_paramsdictParameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. amp_update_modestringDeprecated. Use tslot_type instead. init_pulse_typestringtype / shape of pulse(s) used to initialise the; the control amplitudes.; Options (GRAPE) include:. RN",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:165821,Availability,error,error,165821,"pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_extstring or Nonefiles containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:166595,Availability,error,error,166595,"tsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system; can pro",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:167262,Availability,error,error,167262,"od_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0Qobjstarting point for the evolution.; Typically the identity matrix. U_targQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution;",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:167429,Availability,error,error,167429,"set=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an intital (typically random) pulse,; a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The maximum fidelity for a unitary system is 1, i.e. when the; time evolution resulting from the pulse is equivalent to the target.; And therefore the fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0Qobjstarting point for the evolution.; Typically the identity matrix. U_targQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_t",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:168785,Availability,error,error,168785,"put can be provided for time dependent control generators. U_0Qobjstarting point for the evolution.; Typically the identity matrix. U_targQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. GRAPE (default) - GRadient Ascent Pulse Engineering; CRAB - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be u",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:168852,Availability,error,error,168852,"0Qobjstarting point for the evolution.; Typically the identity matrix. U_targQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. GRAPE (default) - GRadient Ascent Pulse Engineering; CRAB - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note th",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:169826,Availability,error,error,169826,"en the fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. GRAPE (default) - GRadient Ascent Pulse Engineering; CRAB - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringdetermines how global phase is treated in fidelity; calculations (fid_type=UNIT only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics objec",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:173886,Availability,error,error,173886,"pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_extstring or Nonefiles containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_puls",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:176409,Availability,error,error,176409,"can be provided for time dependent control generators. initialQobjstarting point for the evolution.; Typically the identity matrix. targetQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. GRAPE (default) - GRadient Ascent Pulse Engineering; CRAB - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be u",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:176476,Availability,error,error,176476,"lQobjstarting point for the evolution.; Typically the identity matrix. targetQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. GRAPE (default) - GRadient Ascent Pulse Engineering; CRAB - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note th",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:177450,Availability,error,error,177450,"en the fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the; gradients wrt to the control amplitudes falls below this; value, the optimisation terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. GRAPE (default) - GRadient Ascent Pulse Engineering; CRAB - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key ",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:179022,Availability,error,error,179022," Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_paramsdictParameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. phase_optionstringDeprecated. Pass in fid_params instead. fid_err_scale_factorfloatDeprecated. Use scale_factor key in fid_params instead. tslot_typestringMethod for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_paramsdictParameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. amp_update_modestringDeprecated. Use tslot_type instead. init_pulse_typestringtype / shape of pulse(s) used to initialise the; the control amplitudes.; Options (GRAPE) include:. RN",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:179042,Availability,error,error,179042," Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_paramsdictParameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. phase_optionstringDeprecated. Pass in fid_params instead. fid_err_scale_factorfloatDeprecated. Use scale_factor key in fid_params instead. tslot_typestringMethod for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_paramsdictParameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. amp_update_modestringDeprecated. Use tslot_type instead. init_pulse_typestringtype / shape of pulse(s) used to initialise the; the control amplitudes.; Options (GRAPE) include:. RN",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:182876,Availability,error,error,182876,"Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitu",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:183355,Availability,error,error,183355,"t_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjstarting point for the evolution.; Typically the identity matrix. targetQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots an",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:183375,Availability,error,error,183375,"t_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjstarting point for the evolution.; Typically the identity matrix. targetQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots an",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:184841,Availability,error,error,184841,"can be provided for time dependent control generators. initialQobjstarting point for the evolution.; Typically the identity matrix. targetQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:184908,Availability,error,error,184908,"lQobjstarting point for the evolution.; Typically the identity matrix. targetQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:186552,Availability,error,error,186552,"e from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method; The only tested options are fmin and Nelder-mead; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComput",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:187357,Availability,error,error,187357," The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_paramsdictParameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_paramsdictParameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. guess_pulse_typestringtype / shape of pulse(s) used modulate the control amplitudes.; Options include:. RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN. Default is None. guess_pulse_paramsdictParameters for the guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They a",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:187377,Availability,error,error,187377," The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_paramsdictParameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_paramsdictParameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. guess_pulse_typestringtype / shape of pulse(s) used modulate the control amplitudes.; Options include:. RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN. Default is None. guess_pulse_paramsdictParameters for the guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They a",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:190320,Availability,error,error,190320,"pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_extstring or Nonefiles containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:191069,Availability,error,error,191069,"ill suppress the output of files. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the ",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:191806,Availability,error,error,191806,"params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0Qobjstarting point for the evolution.; Typically the identity matrix. U_targQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots and e",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:191826,Availability,error,error,191826,"params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]; Optimise a control pulse to minimise the fidelity error, assuming that; the dynamics of the system are generated by unitary operators.; This function is simply a wrapper for optimize_pulse, where the; appropriate options for unitary dynamics are chosen and the parameter; names are in the format familiar to unitary dynamics; The dynamics of the system in any given timeslot are governed; by the combined Hamiltonian,; i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system; can provide list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]a list of control Hamiltonians. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. U_0Qobjstarting point for the evolution.; Typically the identity matrix. U_targQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots and e",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:193289,Availability,error,error,193289,"put can be provided for time dependent control generators. U_0Qobjstarting point for the evolution.; Typically the identity matrix. U_targQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:193356,Availability,error,error,193356,"0Qobjstarting point for the evolution.; Typically the identity matrix. U_targQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array. tauarray[num_tslots] of floats or Nonedurations for the timeslots.; if this is given then num_tslots and evo_time are dervived; from it; None implies that timeslot durations will be equal and; calculated as evo_time/num_tslots. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will; terminate when the fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value; used to set attribute values; Note: attributes are created if they do not exist already,; and are overwritten if they do.; Note: method_params are applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients; By default these range from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:195000,Availability,error,error,195000,"e from -1.0 to 1.0; Note this is overridden by alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function; Note this is calculated automatically based on the dimension of the; dynamics if not given. It is crucial to the performane of the; algorithm that it is set as low as possible, while still giving; high enough frequencies.; Note this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method; The only tested options are fmin and Nelder-mead; In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method.; The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringdetermines how global phase is treated in fidelity; calculations (fid_type=UNIT only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_paramsdictParameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_paramsdictParameters for the TimeslotCo",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:198296,Availability,error,error,198296,"pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively quiet execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. out_file_extstring or Nonefiles containing the initial and final control pulse; amplitudes are saved to the current directory.; The default name will be postfixed with this extension; Setting this to None will suppress the output of files. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:34775,Deployability,configurat,configuration,34775,"ue to; finite numerical precision, for ranks less than full-rank,; zero eigenvalues may become slightly negative, such that the; returned operator is not actually completely positive. Parameters. NintSquare root of the dimension of the superoperator to be returned. enforce_tpboolIf True, the trace-preserving condition of [BCSZ08] is enforced;; otherwise only complete positivity is enforced. rankint or NoneRank of the sampled superoperator. If None, a full-rank; superoperator is generated. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns. rhoQobjA superoperator acting on vectorized dim  dim density operators,; sampled from the BCSZ distribution. Three-Level Atoms; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R0be8dcf25d86-1] . R0be8dcf25d86-1; Shore, B. W., The Theory of Coherent Atomic Excitation,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians. operator_to_vector(op)[source]; Create a vector representation of a quantum operator given; the matrix representation. vecto",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:34864,Deployability,configurat,configurations,34864,"re root of the dimension of the superoperator to be returned. enforce_tpboolIf True, the trace-preserving condition of [BCSZ08] is enforced;; otherwise only complete positivity is enforced. rankint or NoneRank of the sampled superoperator. If None, a full-rank; superoperator is generated. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[[N],[N]], [[N],[N]]]. Returns. rhoQobjA superoperator acting on vectorized dim  dim density operators,; sampled from the BCSZ distribution. Three-Level Atoms; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [R0be8dcf25d86-1] . R0be8dcf25d86-1; Shore, B. W., The Theory of Coherent Atomic Excitation,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians. operator_to_vector(op)[source]; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)[source]; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]; Assembles the Liouvillian superoperator f",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:47765,Deployability,continuous,continuous,47765,"]; Returns the Hilbert-Schmidt distance between two density matrices A & B. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. distfloatHilbert-Schmidt distance between density matrices. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). average_gate_fidelity(oper, target=None)[source]; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters. AQobjQuantum object representing a superoperator. targetQobjQuantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns. fidfloatFidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary. process_fidelity(U1, U2, normalize=True)[source]; Calculate the process fidelity given two process operators. Continuous Variables; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters. basislistList of operators that defines the basis for the correlation matrix. rhoQobjDensity matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns. corr_matndarrayA 2-dimensional array of correlation values or operators. covariance_matrix(basis, rho, symmetrized=True)[source]; Given a basis set of operators \(\{a\}_n\), calculate the covariance; matrix:. \[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle\]; or, if of the optional argument symmetrized=False,. \[V_{mn} = \langle a_m a_n\rangle -; \langle a_m \rangle \langle a_n\rangle\]. Parameter",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:52059,Deployability,integrat,integrating,52059,"s. cov_matndarrayA 2-dimensional array of covariance values. logarithmic_negativity(V)[source]; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters. V2d arrayThe covariance matrix. Returns. NfloatThe logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. Dynamics and Time-Evolution. Schrdinger Equation; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=[], args={}, options=<qutip.solver.Options object at 0x2b2261cb9eb8>, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2b2261cb9ef0>, _safe_mode=True)[source]; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian.; Evolve the state vector (psi0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. Hqutip.qobj, qutip.qobjevo, list, callablesystem Hamiltonian as a Qobj, list of Qobj and coefficient, QobjEvo,; or a callback function for time-dependent Hamiltonians.; list format and options can be found in QobjEvos description. psi0qutip.qobjinitial state vector (ket); or initial unitary operator psi0 = U. tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionsingle operator or list of oper",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:54405,Deployability,integrat,integrating,54405,"aseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. output: qutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=<qutip.solver.Options object at 0x2b225f643f98>, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2b225f643fd0>, _safe_mode=True)[source]; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:56689,Deployability,integrat,integration,56689,"ent for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, sin(w*t)], [H1, sin(2*w*t)]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:57328,Deployability,integrat,integrator,57328,"number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; coll",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:57665,Deployability,integrat,integrator,57665,"olver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsqutip.Optionswith options for the solver. progress_barBaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified ",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:112012,Deployability,configurat,configuration,112012,"state density matrix. Time-dependent problems. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object at 0x2b225f631c18>, name=None, cleanup=True)[source]; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. rhs_clear()[source]; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. Scattering in Quantum Optical Systems; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). temporal_basis_vector(waveguide_emission_indices, n_time_bins)[source]; Generate a temporal basis vector for emissions at specified time bins into; specified waveguides. Parameters. waveguide_emission_indiceslist or tupleList of indices where photon emission occurs for each waveguide,; e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]]. n_time_binsintNumber of time bins; the range over which each index can vary. Returns. temporal_basis_vector:class: qutip.QobjA basis vector representing photon scattering at the specified indices.; If there are W waveguides, T times, and N photon emissions, then the; basis vector has dimensionality (W*T)^N. temporal",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:114477,Deployability,integrat,integrated,114477," \(\psi(t_0)\). n_emissionsintNumber of photon emissions to calculate. c_opslistList of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; \(\sigma = \sqrt \gamma \cdot a\). tlistarray_likeList of times for \(\tau_i\). tlist should contain 0 and exceed; the pulse duration / temporal region of interest. system_zero_state:class: qutip.QobjState representing zero excitations in the system. Defaults to; \(\psi(t_0)\). construct_effective_hamiltonianboolWhether an effective Hamiltonian should be constructed from H and c_ops:; \(H_{eff} = H - \frac{i}{2} \sum_n \sigma_n^\dagger \sigma_n\); Default: True. Returns. phi_n:class: qutip.QobjThe scattered bath state projected onto the temporal basis given by; tlist. If there are W waveguides, T times, and N photon emissions, then; the state is a tensor product state with dimensionality T^(W*N). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; c_ops. psi0:class: qutip.QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). n_emissionsintNumber of photons emitted by the system (into any combination of; waveguides). c_opslistList of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; \(\sigma = \sqrt \gamma \cdot a\). tlistarray_likeList of times for \(\tau_i\). tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced. system_zero_state:class: qutip.QobjState representing zero excitations in the syst",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:155351,Deployability,configurat,configuration,155351,"source]; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0qutip.QobjInitial density matrix or state vector (ket). timesarray_likelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; The C",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:174875,Deployability,configurat,configuration,174875,"ributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]; Generate the objects of the appropriate subclasses; required for the pulse optmisation based on the parameters given; Note this method may be preferable to calling optimize_pulse; if more detailed configuration is required before running the; optmisation algorthim, or the algorithm will be run many times,; for instances when trying to finding global the optimum or; minimum time optimisation. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjstarting point for the evolution.; Typically the identity matrix. targetQobjtarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or Nonenumber of timeslots.; None implies that timeslots will be given in the tau array. evo_timefloat or Nonetotal time for the evolution; None implies that timeslots will be given in the tau array.",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:214512,Deployability,update,updated,214512,"function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous. about()[source]; About box for QuTiP. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)[source]; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array of qobjs representing commuting Hermitian; operators. Returns. eigstupleTuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next .  Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:17636,Energy Efficiency,charge,charge,17636,"too aggressively.; Examples; >>> thermal_dm(5, 1); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.000000",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:17700,Energy Efficiency,charge,charge,17700,"too aggressively.; Examples; >>> thermal_dm(5, 1); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.000000",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:17721,Energy Efficiency,charge,charge,17721,"too aggressively.; Examples; >>> thermal_dm(5, 1); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.000000",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:17782,Energy Efficiency,charge,charge,17782,"= [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:17840,Energy Efficiency,charge,charge,17840," [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[source]; Destruction (lowering) operator. Par",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:17908,Energy Efficiency,charge,charge,17908," 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. zero_ket(N, dims=None)[source]; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4); Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[source]; Destruction (lowering) operator. Parameters. NintDimension of Hilbert space. offsetint (default",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:68271,Energy Efficiency,power,power,68271,"tation values. optionsqutip.QdeoptionsOptions for the ODE solver. Returns. output: qutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Floquet States and Floquet-Markov Master Equation. fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object at 0x2b226247fbe0>, floquet_basis=True, kmax=5, _safe_mode=True)[source]; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; None indicates that the tlist spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry w_th, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specif",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:68717,Energy Efficiency,energy,energy,68717,"loquet_basis=True, kmax=5, _safe_mode=True)[source]; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; None indicates that the tlist spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry w_th, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:76431,Energy Efficiency,power,power,76431," to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. k_maxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_basis_transform(f_modes, f_energies, rho0)[source]; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=None, floquet_basis=True)[source]; Solve the dynamics for the system using the Floquet-Markov master equation. ",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:98219,Energy Efficiency,power,power,98219,"ctrumarrayAn array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False)[source]; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslist of qutip.qobjlist of collapse operators. a_opqutip.qobjoperator A. b_opqutip.qobjoperator B. use_pinvboolIf True use numpys pinv method, otherwise use a generic solver. Returns. spectrumarrayAn array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y, inverse=False)[source]; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters. tlistarray_likelist/array of times \(t\) which the correlation function is given. yarray_likelist/array of correlations corresponding to time delays \(t\). inverse: booleanboolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns. w, StupleReturns an array of angular frequencies w and the corresponding; two-sided power spectrum S(w). coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object at 0x2b22624eaa58>)[source]; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:98674,Energy Efficiency,power,power,98674,"d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslist of qutip.qobjlist of collapse operators. a_opqutip.qobjoperator A. b_opqutip.qobjoperator B. use_pinvboolIf True use numpys pinv method, otherwise use a generic solver. Returns. spectrumarrayAn array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y, inverse=False)[source]; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters. tlistarray_likelist/array of times \(t\) which the correlation function is given. yarray_likelist/array of correlations corresponding to time delays \(t\). inverse: booleanboolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns. w, StupleReturns an array of angular frequencies w and the corresponding; two-sided power spectrum S(w). coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object at 0x2b22624eaa58>)[source]; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If state0 is None, then the steady state will; be used as the initial state. The steady-state is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver ",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:102520,Energy Efficiency,power,power,102520,"10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. Steady-state Solvers; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solverstr {None, scipy, mkl}Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. methodstr {direct, eigen, iterative-gmres,; iterative-lgmres, iterative-bicgstab, svd, power,; power-gmres, power-lgmres, power-bicgstab}. Method for solving the underlying linear equation. Direct LU solver; direct (default), sparse eigenvalue problem eigen,; iterative GMRES method iterative-gmres, iterative LGMRES method; iterative-lgmres, iterative BICGSTAB method iterative-bicgstab,; SVD svd (dense), or inverse-power method power. The iterative; power methods power-gmres, power-lgmres, power-bicgstab use; the same solvers as their direct counterparts. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. sparsebool, optional, default = TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for smaller systems. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the ",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:102530,Energy Efficiency,power,power-gmres,102530,"10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. Steady-state Solvers; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solverstr {None, scipy, mkl}Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. methodstr {direct, eigen, iterative-gmres,; iterative-lgmres, iterative-bicgstab, svd, power,; power-gmres, power-lgmres, power-bicgstab}. Method for solving the underlying linear equation. Direct LU solver; direct (default), sparse eigenvalue problem eigen,; iterative GMRES method iterative-gmres, iterative LGMRES method; iterative-lgmres, iterative BICGSTAB method iterative-bicgstab,; SVD svd (dense), or inverse-power method power. The iterative; power methods power-gmres, power-lgmres, power-bicgstab use; the same solvers as their direct counterparts. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. sparsebool, optional, default = TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for smaller systems. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the ",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:102545,Energy Efficiency,power,power-lgmres,102545,"10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. Steady-state Solvers; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solverstr {None, scipy, mkl}Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. methodstr {direct, eigen, iterative-gmres,; iterative-lgmres, iterative-bicgstab, svd, power,; power-gmres, power-lgmres, power-bicgstab}. Method for solving the underlying linear equation. Direct LU solver; direct (default), sparse eigenvalue problem eigen,; iterative GMRES method iterative-gmres, iterative LGMRES method; iterative-lgmres, iterative BICGSTAB method iterative-bicgstab,; SVD svd (dense), or inverse-power method power. The iterative; power methods power-gmres, power-lgmres, power-bicgstab use; the same solvers as their direct counterparts. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. sparsebool, optional, default = TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for smaller systems. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the ",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:102561,Energy Efficiency,power,power-bicgstab,102561,"10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. Steady-state Solvers; Module contains functions for solving for the steady state density matrix of; open quantum systems defined by a Liouvillian or Hamiltonian and a list of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solverstr {None, scipy, mkl}Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. methodstr {direct, eigen, iterative-gmres,; iterative-lgmres, iterative-bicgstab, svd, power,; power-gmres, power-lgmres, power-bicgstab}. Method for solving the underlying linear equation. Direct LU solver; direct (default), sparse eigenvalue problem eigen,; iterative GMRES method iterative-gmres, iterative LGMRES method; iterative-lgmres, iterative BICGSTAB method iterative-bicgstab,; SVD svd (dense), or inverse-power method power. The iterative; power methods power-gmres, power-lgmres, power-bicgstab use; the same solvers as their direct counterparts. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. sparsebool, optional, default = TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for smaller systems. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the ",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:102870,Energy Efficiency,power,power,102870,"of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solverstr {None, scipy, mkl}Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. methodstr {direct, eigen, iterative-gmres,; iterative-lgmres, iterative-bicgstab, svd, power,; power-gmres, power-lgmres, power-bicgstab}. Method for solving the underlying linear equation. Direct LU solver; direct (default), sparse eigenvalue problem eigen,; iterative GMRES method iterative-gmres, iterative LGMRES method; iterative-lgmres, iterative BICGSTAB method iterative-bicgstab,; SVD svd (dense), or inverse-power method power. The iterative; power methods power-gmres, power-lgmres, power-bicgstab use; the same solvers as their direct counterparts. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. sparsebool, optional, default = TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for smaller systems. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbmbool, optional, default = FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfl",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:102884,Energy Efficiency,power,power,102884,"of; collapse operators. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]; Calculates the steady state for quantum evolution subject to the; supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solverstr {None, scipy, mkl}Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. methodstr {direct, eigen, iterative-gmres,; iterative-lgmres, iterative-bicgstab, svd, power,; power-gmres, power-lgmres, power-bicgstab}. Method for solving the underlying linear equation. Direct LU solver; direct (default), sparse eigenvalue problem eigen,; iterative GMRES method iterative-gmres, iterative LGMRES method; iterative-lgmres, iterative BICGSTAB method iterative-bicgstab,; SVD svd (dense), or inverse-power method power. The iterative; power methods power-gmres, power-lgmres, power-bicgstab use; the same solvers as their direct counterparts. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. sparsebool, optional, default = TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for smaller systems. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbmbool, optional, default = FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfl",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:102907,Energy Efficiency,power,power,102907,"ouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solverstr {None, scipy, mkl}Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. methodstr {direct, eigen, iterative-gmres,; iterative-lgmres, iterative-bicgstab, svd, power,; power-gmres, power-lgmres, power-bicgstab}. Method for solving the underlying linear equation. Direct LU solver; direct (default), sparse eigenvalue problem eigen,; iterative GMRES method iterative-gmres, iterative LGMRES method; iterative-lgmres, iterative BICGSTAB method iterative-bicgstab,; SVD svd (dense), or inverse-power method power. The iterative; power methods power-gmres, power-lgmres, power-bicgstab use; the same solvers as their direct counterparts. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. sparsebool, optional, default = TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for smaller systems. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbmbool, optional, default = FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by t",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:102922,Energy Efficiency,power,power-gmres,102922,"ouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solverstr {None, scipy, mkl}Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. methodstr {direct, eigen, iterative-gmres,; iterative-lgmres, iterative-bicgstab, svd, power,; power-gmres, power-lgmres, power-bicgstab}. Method for solving the underlying linear equation. Direct LU solver; direct (default), sparse eigenvalue problem eigen,; iterative GMRES method iterative-gmres, iterative LGMRES method; iterative-lgmres, iterative BICGSTAB method iterative-bicgstab,; SVD svd (dense), or inverse-power method power. The iterative; power methods power-gmres, power-lgmres, power-bicgstab use; the same solvers as their direct counterparts. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. sparsebool, optional, default = TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for smaller systems. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbmbool, optional, default = FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by t",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:102937,Energy Efficiency,power,power-lgmres,102937,"ouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solverstr {None, scipy, mkl}Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. methodstr {direct, eigen, iterative-gmres,; iterative-lgmres, iterative-bicgstab, svd, power,; power-gmres, power-lgmres, power-bicgstab}. Method for solving the underlying linear equation. Direct LU solver; direct (default), sparse eigenvalue problem eigen,; iterative GMRES method iterative-gmres, iterative LGMRES method; iterative-lgmres, iterative BICGSTAB method iterative-bicgstab,; SVD svd (dense), or inverse-power method power. The iterative; power methods power-gmres, power-lgmres, power-bicgstab use; the same solvers as their direct counterparts. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. sparsebool, optional, default = TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for smaller systems. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbmbool, optional, default = FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by t",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:102953,Energy Efficiency,power,power-bicgstab,102953,"ouvillian operator and (if given a Hamiltonian) a; list of collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solverstr {None, scipy, mkl}Selects the sparse solver to use. Default is auto-select; based on the availability of the MKL library. methodstr {direct, eigen, iterative-gmres,; iterative-lgmres, iterative-bicgstab, svd, power,; power-gmres, power-lgmres, power-bicgstab}. Method for solving the underlying linear equation. Direct LU solver; direct (default), sparse eigenvalue problem eigen,; iterative GMRES method iterative-gmres, iterative LGMRES method; iterative-lgmres, iterative BICGSTAB method iterative-bicgstab,; SVD svd (dense), or inverse-power method power. The iterative; power methods power-gmres, power-lgmres, power-bicgstab use; the same solvers as their direct counterparts. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. sparsebool, optional, default = TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for smaller systems. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbmbool, optional, default = FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by t",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:104524,Energy Efficiency,power,power,104524," use_wbmbool, optional, default = FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint {10}MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsbool {True, False}MKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingbool {True, False}MKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, optional, default=1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, optional, default=1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optional, default=NoneITERATIVE power methods ONLY. Tolerance for lu solve method.; If None given then max(0.1*tol, 1e-15) is used. matolfloat, optional, default=1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optional, default=COLAMDITERATIVE ONLY. Column ordering used internally by superLU for the; direct LU decomposition method. Options include COLAMD and; NATURAL. If using RCM then this is set to NATURAL automatically; unless explicitly specified. use_precondbool optional, default = FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the iterative GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precon",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:105942,Energy Efficiency,reduce,reduced,105942,"l optional, default = FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the iterative GMRES and BICG solvers.; Speeds up convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically. fill_factorfloat, optional, default = 100ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tolfloat, optional, default = 1e-4ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_threshfloat, optional, default = NoneITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILUstr, optional, default = smilu_2ITERATIVE ONLY. Selects the incomplete LU decomposition method; algoithm used in creating the preconditoner. Should only be used by; advanced users. Returns. dmqobjSteady state density matrix. infodict, optionalDictionary containing solver-specific information about the solution. Notes; The SVD method works only for dense operators (i.e. small systems). build_preconditioner(A, c_op_list=[], **kwargs)[source]; Constructs a iLU preconditioner necessary for solving for; the steady state density matrix using the iterative linear solvers; in the steadystate function. Parameters. AqobjA Hamiltonian or Liouvillian operator. c_op_",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:107935,Energy Efficiency,power,power,107935,". AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbmbool, optional, default = FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. methodstr, default = iterativeTells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use iterative.; For power iterative methods use power. permc_specstr, optional, default=COLAMDColumn ordering used internally by superLU for the; direct LU decomposition method. Options include COLAMD and; NATURAL. If using RCM then this is set to NATURAL automatically; unless explicitly specified. fill_factorfloat, optional, default = 100Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tolfloat, optional, default = 1e-4Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_threshfloat, optional, default = NoneSets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_M",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:107964,Energy Efficiency,power,power,107964,". AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbmbool, optional, default = FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. methodstr, default = iterativeTells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use iterative.; For power iterative methods use power. permc_specstr, optional, default=COLAMDColumn ordering used internally by superLU for the; direct LU decomposition method. Options include COLAMD and; NATURAL. If using RCM then this is set to NATURAL automatically; unless explicitly specified. fill_factorfloat, optional, default = 100Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tolfloat, optional, default = 1e-4Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_threshfloat, optional, default = NoneSets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_M",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:108577,Energy Efficiency,reduce,reduced,108577,"ce condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. methodstr, default = iterativeTells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use iterative.; For power iterative methods use power. permc_specstr, optional, default=COLAMDColumn ordering used internally by superLU for the; direct LU decomposition method. Options include COLAMD and; NATURAL. If using RCM then this is set to NATURAL automatically; unless explicitly specified. fill_factorfloat, optional, default = 100Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tolfloat, optional, default = 1e-4Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_threshfloat, optional, default = NoneSets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILUstr, optional, default = smilu_2Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. Propagators. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, _safe_mode=True, **kwargs)[source]; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector r",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:121131,Energy Efficiency,energy,energy,121131,"vel systems it counts how many different; j exist or the number of blocks in the block-diagonal matrix. Parameters. N: intThe number of two-level systems. Returns. Nj: intThe number of Dicke ladders. num_tls(nds)[source]; Calculate the number of two-level systems. Parameters. nds: intThe number of Dicke states. Returns. N: intThe number of two-level systems. isdiagonal(mat)[source]; Check if the input matrix is diagonal. Parameters. mat: ndarray/QobjA 2D numpy array. Returns. diag: boolTrue/False depending on whether the input matrix is diagonal. state_degeneracy(N, j)[source]; Calculate the degeneracy of the Dicke state.; Each state \(|j, m\rangle\) includes D(N,j) irreducible; representations \(|j, m, \alpha\rangle\).; Uses Decimals to calculate higher numerator and denominators numbers. Parameters. N: intThe number of two-level systems. j: floatTotal spin eigenvalue (cooperativity). Returns. degeneracy: intThe state degeneracy. m_degeneracy(N, m)[source]; Calculate the number of Dicke states \(|j, m\rangle\) with; same energy. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue (proportional to the total; energy). Returns. degeneracy: intThe m-degeneracy. ap(j, m)[source]; Calculate the coefficient ap by applying J_+ |j, m>.; The action of ap is given by:; \(J_{+}|j, m\rangle = A_{+}(j, m)|j, m+1\rangle\). Parameters. j, m: floatThe value for j and m in the dicke basis |j,m>. Returns. a_plus: floatThe value of \(a_{+}\). am(j, m)[source]; Calculate the operator am used later.; The action of ap is given by: J_{-}|j, m> = A_{-}(jm)|j, m-1>. Parameters. j: floatThe value for j. m: floatThe value for m. Returns. a_minus: floatThe value of \(a_{-}\). spin_algebra(N, op=None)[source]; Create the list [sx, sy, sz] with the spin operators.; The operators are constructed for a collection of N two-level systems; (TLSs). Each element of the list, i.e., sx, is a vector of qutip.Qobj; objects (spin matrices), as it coint",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:121266,Energy Efficiency,energy,energy,121266,"vel systems. Returns. Nj: intThe number of Dicke ladders. num_tls(nds)[source]; Calculate the number of two-level systems. Parameters. nds: intThe number of Dicke states. Returns. N: intThe number of two-level systems. isdiagonal(mat)[source]; Check if the input matrix is diagonal. Parameters. mat: ndarray/QobjA 2D numpy array. Returns. diag: boolTrue/False depending on whether the input matrix is diagonal. state_degeneracy(N, j)[source]; Calculate the degeneracy of the Dicke state.; Each state \(|j, m\rangle\) includes D(N,j) irreducible; representations \(|j, m, \alpha\rangle\).; Uses Decimals to calculate higher numerator and denominators numbers. Parameters. N: intThe number of two-level systems. j: floatTotal spin eigenvalue (cooperativity). Returns. degeneracy: intThe state degeneracy. m_degeneracy(N, m)[source]; Calculate the number of Dicke states \(|j, m\rangle\) with; same energy. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue (proportional to the total; energy). Returns. degeneracy: intThe m-degeneracy. ap(j, m)[source]; Calculate the coefficient ap by applying J_+ |j, m>.; The action of ap is given by:; \(J_{+}|j, m\rangle = A_{+}(j, m)|j, m+1\rangle\). Parameters. j, m: floatThe value for j and m in the dicke basis |j,m>. Returns. a_plus: floatThe value of \(a_{+}\). am(j, m)[source]; Calculate the operator am used later.; The action of ap is given by: J_{-}|j, m> = A_{-}(jm)|j, m-1>. Parameters. j: floatThe value for j. m: floatThe value for m. Returns. a_minus: floatThe value of \(a_{-}\). spin_algebra(N, op=None)[source]; Create the list [sx, sy, sz] with the spin operators.; The operators are constructed for a collection of N two-level systems; (TLSs). Each element of the list, i.e., sx, is a vector of qutip.Qobj; objects (spin matrices), as it cointains the list of the SU(2) Pauli; matrices for the N TLSs. Each TLS operator sx[i], with i = 0, , (N-1),; is placed in a \(2^N\)-dimensional Hil",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:126735,Energy Efficiency,efficient,efficient,126735,"pecified; by THETA and PHI. Notes; Experimental. wigner(psi, xvec, yvec, method='clenshaw', g=1.4142135623730951, sparse=False, parfor=False)[source]; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters. stateqobjA state vector or density matrix. xvecarray_likex-coordinates at which to calculate the Wigner function. yvecarray_likey-coordinates at which to calculate the Wigner function. Does not; apply to the fft method. gfloatScaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2). methodstring {clenshaw, iterative, laguerre, fft}Select method clenshaw iterative, laguerre, or fft, where clenshaw; and iterative use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while laguerre uses the Laguerre polynomials; in scipy for the same task. The fft method evaluates the Fourier; transform of the density matrix. The iterative method is default, and; in general recommended, but the laguerre method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The clenshaw method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). clenshaw is a fast and numerically stable method. sparsebool {False, True}Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parforbool {False, True}Flag for calculating the Laguerre polynomial based Wigner function; method=laguerre in parallel using the parfor function. Returns. WarrayValues representing the Wigner function calculated over the specified; range [xvec,yvec]. yvexarrayFFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The fft method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally.; ",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:130564,Energy Efficiency,energy,energy,130564,"ax=None, threshold=None)[source]; Draw a histogram for the amplitudes of matrix M, using the argument; of each element for coloring the bars, with the given x and y labels; and title. Parameters. MMatrix of QobjThe matrix to visualize. xlabelslist of stringslist of x labels. ylabelslist of stringslist of y labels. titlestringtitle of the plot (optional). limitslist/array with two float numbersThe z-axis limits [min, max] (optional). phase_limitslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, uni",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:130631,Energy Efficiency,energy,energy,130631,"t; of each element for coloring the bars, with the given x and y labels; and title. Parameters. MMatrix of QobjThe matrix to visualize. xlabelslist of stringslist of x labels. ylabelslist of stringslist of y labels. titlestringtitle of the plot (optional). limitslist/array with two float numbersThe z-axis limits [min, max] (optional). phase_limitslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]; Plot the Fock distribution for a density matrix (or ket) that describes; an",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:130678,Energy Efficiency,energy,energy,130678,"Matrix of QobjThe matrix to visualize. xlabelslist of stringslist of x labels. ylabelslist of stringslist of y labels. titlestringtitle of the plot (optional). limitslist/array with two float numbersThe z-axis limits [min, max] (optional). phase_limitslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters. rhoqutip.qobj.QobjThe density matrix (or ket) of the state to visual",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:130985,Energy Efficiency,energy,energy,130985,"itslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters. rhoqutip.qobj.QobjThe density matrix (or ket) of the state to visualize. figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. titlestringAn optional title for the figure. figsize(width, height)The size of the ",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:131046,Energy Efficiency,energy,energy,131046,"n, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_fock_distribution(rho, offset=0, fig=None, ax=None, figsize=(8, 6), title=None, unit_y_range=True)[source]; Plot the Fock distribution for a density matrix (or ket) that describes; an oscillator mode. Parameters. rhoqutip.qobj.QobjThe density matrix (or ket) of the state to visualize. figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. titlestringAn optional title for the figure. figsize(width, height)The size of the matplotlib figure (in inches) if it is to be created; (that is, if no fi",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:156505,Energy Efficiency,reduce,reduces,156505,"tion in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 14 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:205598,Energy Efficiency,energy,energy,205598," interval; with additional elements added.; Returns num spaced array with elements from elems inserted; if not already included in set.; Returned sample array is not evenly spaced if addtional elements; are added. Parameters. startintThe starting value of the sequence. stopintThe stoping values of the sequence. numint, optionalNumber of samples to generate. elemslist/ndarray, optionalRequested elements to include in array. Returns. samplesndadrrayOriginal equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)[source]; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (J, eV, meV, GHz, mK). tostringThe name of the new unit (J, eV, meV, GHz, mK). Returns. value_new_unitfloat / arrayThe energy in the new unit. File I/O Functions. file_data_read(filename, sep=None)[source]; Retrieves an array of data from the requested file. Parameters. filenamestrName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]; Stores a matrix of data to a file to be read by an external program. Parameters. filenamestrName of data file to be stored, including extension. data: array_likeData to be written to file. numtypestr {complex, real}Type of numerical data. numformatstr {decimal,exp}Format for written data. sepstrSingle-character field seperato",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:205666,Energy Efficiency,energy,energy,205666,"rom elems inserted; if not already included in set.; Returned sample array is not evenly spaced if addtional elements; are added. Parameters. startintThe starting value of the sequence. stopintThe stoping values of the sequence. numint, optionalNumber of samples to generate. elemslist/ndarray, optionalRequested elements to include in array. Returns. samplesndadrrayOriginal equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)[source]; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (J, eV, meV, GHz, mK). tostringThe name of the new unit (J, eV, meV, GHz, mK). Returns. value_new_unitfloat / arrayThe energy in the new unit. File I/O Functions. file_data_read(filename, sep=None)[source]; Retrieves an array of data from the requested file. Parameters. filenamestrName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]; Stores a matrix of data to a file to be read by an external program. Parameters. filenamestrName of data file to be stored, including extension. data: array_likeData to be written to file. numtypestr {complex, real}Type of numerical data. numformatstr {decimal,exp}Format for written data. sepstrSingle-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]; Loads data fil",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:205869,Energy Efficiency,energy,energy,205869,"toping values of the sequence. numint, optionalNumber of samples to generate. elemslist/ndarray, optionalRequested elements to include in array. Returns. samplesndadrrayOriginal equally spaced sample array with additional; elements added. clebsch(j1, j2, j3, m1, m2, m3)[source]; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (J, eV, meV, GHz, mK). tostringThe name of the new unit (J, eV, meV, GHz, mK). Returns. value_new_unitfloat / arrayThe energy in the new unit. File I/O Functions. file_data_read(filename, sep=None)[source]; Retrieves an array of data from the requested file. Parameters. filenamestrName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=', ')[source]; Stores a matrix of data to a file to be read by an external program. Parameters. filenamestrName of data file to be stored, including extension. data: array_likeData to be written to file. numtypestr {complex, real}Type of numerical data. numformatstr {decimal,exp}Format for written data. sepstrSingle-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]; Loads data file from file named filename.qu in current directory. Parameters. namestrName of data file to be loaded. Returns. qobjectinstance / array_likeObject retrieved from requested file. qsave(data, name='q",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:211072,Energy Efficiency,schedul,scheduling,211072,"g QuTiP with IPython notebooks. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The c",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:211417,Energy Efficiency,schedul,scheduled,211417,", args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe lis",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:212788,Energy Efficiency,schedul,scheduling,212788,"ask_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:213133,Energy Efficiency,schedul,scheduled,213133,"t and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. version_table(verbose=False)[source]; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous. about()[source]; About box for QuTiP. Gives version numbers for; QuTiP, NumPy, SciPy, Cython, and MatPlotLib. simdiag(ops, evals=True)[source]; Simultaneous diagonalization of commuting Hermitian m",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:825,Integrability,depend,dependent,825,". . Functions  QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; API documentation; Classes; Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Dynamics and Time-Evolution; Schrdinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrdinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs ; API documentation ; Functions. Functions. Manipulation and Creation of States and Operators. Quantum States. basis(N, n=0, offset=0)[source]; Generates the vector representation of a Fock state. Parameters. NintNumber of Fock states in Hilbert space. nintInteger corresponding to desired number state, defaults; to 0 if omitted. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the state. Returns. statequtip.QobjQobj representing the requested number state |n>. Notes; A subtle incompatibility with the quantum optics toolbox: In QuTiP:; basis(N, 0) = ground state. but in the qotoolbox:; basis(N, 1",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:42165,Integrability,contract,contracted,42165," vectorized operator; acts. Parameters. argsarray_likelist or array of quantum objects with type=""super"". Returns. objqobjA composite quantum object. composite(*args)[source]; Given two or more operators, kets or bras, returns the Qobj; corresponding to a composite system over each argument.; For ordinary operators and vectors, this is the tensor product,; while for superoperators and vectorized operators, this is; the column-reshuffled tensor product.; If a mix of Qobjs supported on Hilbert and Liouville spaces; are passed in, the former are promoted. Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose. partial_transpose(rho, mask, method='dense')[source]; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transp",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:42240,Integrability,contract,contracted,42240," Returns. objqobjA composite quantum object. composite(*args)[source]; Given two or more operators, kets or bras, returns the Qobj; corresponding to a composite system over each argument.; For ordinary operators and vectors, this is the tensor product,; while for superoperators and vectorized operators, this is; the column-reshuffled tensor product.; If a mix of Qobjs supported on Hilbert and Liouville spaces; are passed in, the former are promoted. Ordinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). tensor_contract(qobj, *pairs)[source]; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose. partial_transpose(rho, mask, method='dense')[source]; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions. concurrence(rho)[source]; Calculate the concurrence entanglement measure for a",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:52059,Integrability,integrat,integrating,52059,"s. cov_matndarrayA 2-dimensional array of covariance values. logarithmic_negativity(V)[source]; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters. V2d arrayThe covariance matrix. Returns. NfloatThe logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. Dynamics and Time-Evolution. Schrdinger Equation; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=[], args={}, options=<qutip.solver.Options object at 0x2b2261cb9eb8>, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2b2261cb9ef0>, _safe_mode=True)[source]; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian.; Evolve the state vector (psi0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. Hqutip.qobj, qutip.qobjevo, list, callablesystem Hamiltonian as a Qobj, list of Qobj and coefficient, QobjEvo,; or a callback function for time-dependent Hamiltonians.; list format and options can be found in QobjEvos description. psi0qutip.qobjinitial state vector (ket); or initial unitary operator psi0 = U. tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionsingle operator or list of oper",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:52781,Integrability,depend,dependent,52781,"gs={}, options=<qutip.solver.Options object at 0x2b2261cb9eb8>, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2b2261cb9ef0>, _safe_mode=True)[source]; Schrodinger equation evolution of a state vector or unitary matrix; for a given Hamiltonian.; Evolve the state vector (psi0) using a given; Hamiltonian (H), by integrating the set of ordinary differential; equations that define the system. Alternatively evolve a unitary matrix in; solving the Schrodinger operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. Hqutip.qobj, qutip.qobjevo, list, callablesystem Hamiltonian as a Qobj, list of Qobj and coefficient, QobjEvo,; or a callback function for time-dependent Hamiltonians.; list format and options can be found in QobjEvos description. psi0qutip.qobjinitial state vector (ket); or initial unitary operator psi0 = U. tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values.; For list operator evolution, the overlapse is computed:. tr(e_ops[i].dag()*op(t)). argsdictionarydictionary of parameters for time-dependent Hamiltonians. optionsqutip.Qdeoptionswith options for the ODE solver. progress_barBaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. output: qutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a ca",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:53246,Integrability,depend,dependent,53246,"ut is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. Hqutip.qobj, qutip.qobjevo, list, callablesystem Hamiltonian as a Qobj, list of Qobj and coefficient, QobjEvo,; or a callback function for time-dependent Hamiltonians.; list format and options can be found in QobjEvos description. psi0qutip.qobjinitial state vector (ket); or initial unitary operator psi0 = U. tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values.; For list operator evolution, the overlapse is computed:. tr(e_ops[i].dag()*op(t)). argsdictionarydictionary of parameters for time-dependent Hamiltonians. optionsqutip.Qdeoptionswith options for the ODE solver. progress_barBaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. output: qutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=<qutip.solver.Options object at 0x2b225f643f98>, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2b225f643fd0>, _safe_mode=True)[source]; Master equation evolution of a density matrix for a given Hamiltonian and; set of coll",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:54405,Integrability,integrat,integrating,54405,"aseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. output: qutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the; times in tlist [if e_ops is an empty list], or; nothing if a callback function was given inplace of operators for; which to calculate the expectation values. Master Equation; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=[], e_ops=[], args={}, options=<qutip.solver.Options object at 0x2b225f643f98>, progress_bar=<qutip.ui.progressbar.BaseProgressBar object at 0x2b225f643fd0>, _safe_mode=True)[source]; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:55202,Integrability,depend,dependent,55202,"o0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, sin(w*t)], [H1, sin(2*w*t)]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (c",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:55232,Integrability,depend,dependent,55232,"o0) using a given; Hamiltonian (H) and an [optional] set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, sin(w*t)], [H1, sin(2*w*t)]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (c",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:55759,Integrability,depend,dependent,55759,"t is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows to solve master equations that are not on standard Lindblad; form by passing a custom Liouvillian in place of either the H or c_ops; elements.; Time-dependent operators; For time-dependent problems, H and c_ops can be callback; functions that takes two arguments, time and args, and returns the; Hamiltonian or Liouvillian for the system at that point in time; (callback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, sin(w*t)], [H1, sin(2*w*t)]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state ",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:56380,Integrability,depend,dependent,56380,"allback format).; Alternatively, H and c_ops can be a specified in a nested-list format; where each element in the list is a list of length 2, containing an; operator (qutip.qobj) at the first element and where the; second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, sin(w*t)], [H1, sin(2*w*t)]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qu",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:56689,Integrability,integrat,integration,56689,"ent for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Examples. H = [[H0, sin(w*t)], [H1, sin(2*w*t)]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:57328,Integrability,integrat,integrator,57328,"number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; coll",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:57665,Integrability,integrat,integrator,57665,"olver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsqutip.Optionswith options for the solver. progress_barBaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified ",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:57807,Integrability,depend,dependent,57807,"even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem with out further; transformation. This allows for using mesolve for solving master; equations that are not on standard Lindblad form. Note; On using callback function: mesolve transforms all qutip.qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsqutip.Optionswith options for the solver. progress_barBaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or noth",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:58273,Integrability,depend,dependent,58273,"ts to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.qobj in; args and handle the conversion to sparse matrices. All other; qutip.qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise an NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsqutip.Optionswith options for the solver. progress_barBaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=<qutip.solver.Options object at 0x2b2261d09978>, progress_bar=True, map_func=<function parallel_map at 0x2b225f61c620>, map_kwargs={}, _safe_mode=True, _exp=False)[source]; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:59456,Integrability,depend,dependent,59456,"s. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=<qutip.solver.Options object at 0x2b2261d09978>, progress_bar=True, map_func=<function parallel_map at 0x2b225f61c620>, map_kwargs={}, _safe_mode=True, _exp=False)[source]; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; opera",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:59562,Integrability,depend,dependent,59562,"s. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=<qutip.solver.Options object at 0x2b2261d09978>, progress_bar=True, map_func=<function parallel_map at 0x2b225f61c620>, map_kwargs={}, _safe_mode=True, _exp=False)[source]; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; opera",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:59685,Integrability,depend,dependent,59685,"e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=<qutip.solver.Options object at 0x2b2261d09978>, progress_bar=True, map_func=<function parallel_map at 0x2b225f61c620>, map_kwargs={}, _safe_mode=True, _exp=False)[source]; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_o",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:59771,Integrability,depend,dependent,59771,"e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=<qutip.solver.Options object at 0x2b2261d09978>, progress_bar=True, map_func=<function parallel_map at 0x2b225f61c620>, map_kwargs={}, _safe_mode=True, _exp=False)[source]; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_o",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:59861,Integrability,depend,dependent,59861,"e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=<qutip.solver.Options object at 0x2b2261d09978>, progress_bar=True, map_func=<function parallel_map at 0x2b225f61c620>, map_kwargs={}, _safe_mode=True, _exp=False)[source]; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_o",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:59989,Integrability,depend,dependent,59989,"utip.solver.Options object at 0x2b2261d09978>, progress_bar=True, map_func=<function parallel_map at 0x2b225f61c620>, map_kwargs={}, _safe_mode=True, _exp=False)[source]; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_opsqutip.Qobj, listsingle operator as Qobj or list or equivalent of Qobj operators; for calculating expectation values. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver op",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:60924,Integrability,depend,dependent,60924," with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_opsqutip.Qobj, listsingle operator as Qobj or list or equivalent of Qobj operators; for calculating expectation values. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: functionA map function for managing the calls to the single-trajactory solver. map_kwargs: dictionaryOptional keyword arguments to the map_func function. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. Note; It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series. essolve(H, rho0, tlist, c_op_list, e_ops)[source]; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbit",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:62474,Integrability,depend,dependent,62474," to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series. essolve(H, rho0, tlist, c_op_list, e_ops)[source]; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Parameters. Hqobj/function_typeSystem Hamiltonian. rho0qutip.qobjInitial state density matrix. tlistlist/arraylist of times for \(t\). c_op_listlist of qutip.qobjlist of qutip.qobj collapse operators. e_opslist of qutip.qobjlist of qutip.qobj operators for which to evaluate; expectation values. Returns. expt_arrayarrayExpectation values of wavefunctions/density matrices for the; times specified in tlist. Note; This solver does not support time-dependent Hamiltonians.; .. ode2es(L, rho0)[source]; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Parameters. LqobjLiouvillian of the system. rho0qobjInitial state vector or density matrix. Returns. eseriesqutip.eserieseseries represention of the system dynamics. Bloch-Redfield Master Equation. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested lis",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:63623,Integrability,depend,dependent,63623,"rameters. LqobjLiouvillian of the system. rho0qobjInitial state vector or density matrix. Returns. eseriesqutip.eserieseseries represention of the system dynamics. Bloch-Redfield Master Equation. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), 0.2*exp(-t)*(w>=0)]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))], ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:63756,Integrability,depend,dependent,63756,"rameters. LqobjLiouvillian of the system. rho0qobjInitial state vector or density matrix. Returns. eseriesqutip.eserieseseries represention of the system dynamics. Bloch-Redfield Master Equation. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), 0.2*exp(-t)*(w>=0)]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))], ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:63927,Integrability,depend,dependence,63927,"ter Equation. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), 0.2*exp(-t)*(w>=0)]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))], ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermi",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:64079,Integrability,depend,dependence,64079,"_mode=True, verbose=False)[source]; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), 0.2*exp(-t)*(w>=0)]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))], ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_opslistList of operators for which to evaluate expectation values. c_opsli",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:64292,Integrability,depend,dependence,64292,"functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), 0.2*exp(-t)*(w>=0)]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))], ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_opslistList of operators for which to evaluate expectation values. c_opslistList of system collapse operators, or nested list in; string-based format. argsdictPlaceholder for future implementation, kept for API consistency. use_secularbool {True}Use secular approximation when e",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:64579,Integrability,depend,dependence,64579,"le.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), 0.2*exp(-t)*(w>=0)]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))], ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_opslistList of operators for which to evaluate expectation values. c_opslistList of system collapse operators, or nested list in; string-based format. argsdictPlaceholder for future implementation, kept for API consistency. use_secularbool {True}Use secular approximation when evaluating bath-coupling terms. sec_cutofffloat {0.1}Cutoff for secular approximation. tolfloat {qutip.setttings.atol}Tolerance used for removing small values after; basis transformation. spectra_cblistDEPRECIATED. Do not use. optionsqutip.solver.OptionsOptions for the solver. progress_barBaseProg",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:68380,Integrability,depend,dependence,68380,"e class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. Floquet States and Floquet-Markov Master Equation. fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object at 0x2b226247fbe0>, floquet_basis=True, kmax=5, _safe_mode=True)[source]; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; None indicates that the tlist spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry w_th, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]; Calculate the initial Floquet modes ",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:68550,Integrability,depend,dependent,68550,"ve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object at 0x2b226247fbe0>, floquet_basis=True, kmax=5, _safe_mode=True)[source]; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; None indicates that the tlist spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry w_th, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorte",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:69760,Integrability,depend,dependent,69760,"n. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; None indicates that the tlist spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. T",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
https://qutip.org/docs/4.4/apidoc/functions.html:69878,Integrability,depend,dependence,69878,"nversion; >>> temperature = 25e-3 # unit K; >>> h = 6.626e-34; >>> kB = 1.38e-23; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9. optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. floquet_modes(H, T, args=None, sort=False, U=None)[source]; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; None indicates that the tlist spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputlist of ketsThe Floquet modes as kets at time ",MatchSource.WIKI,docs/4.4/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/apidoc/functions.html
